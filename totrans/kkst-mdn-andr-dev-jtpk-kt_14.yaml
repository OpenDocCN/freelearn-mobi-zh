- en: '*Chapter 11*: Creating Infinite Lists with Jetpack Paging and Kotlin Flow'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：使用 Jetpack Paging 和 Kotlin Flow 创建无限列表'
- en: In the previous chapters, we built the great Restaurants App that displayed
    content from our own backend. However, the number of restaurants displayed in
    the Restaurants App was fixed, and the user was only able to browse through the
    few restaurants that we added to our Firebase database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了伟大的餐厅应用，该应用显示了来自我们自己的后端的内容。然而，餐厅应用中显示的餐厅数量是固定的，用户只能浏览我们添加到 Firebase
    数据库中的少数几家餐厅。
- en: In this chapter, we will understand how pagination can help us display large
    datasets of items without putting pressure on our backend and without huge network
    bandwidth consumption. We will create the impression of an infinite list of items
    inside a new app that we will be working on called the Repositories App, and we
    will achieve that with the help of yet another Jetpack library called **Paging**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解分页如何帮助我们显示大量项目数据集，而不会给后端施加压力，也不会消耗巨大的网络带宽。我们将在一个新应用中创建无限列表项目的印象，这个应用就是我们正在工作的
    Repositories 应用，我们将借助另一个名为 **Paging** 的 Jetpack 库来实现这一点。
- en: 'In the first section, *Why do we need pagination?*, we will explore what data
    pagination is and how it can help us break large datasets into pages of data,
    thereby optimizing the communication between our app and the backend server. Up
    next, in the *Importing and exploring the Repositories App* section, we will explore
    a project in which we will integrate pagination: the Repositories App that displays
    information about GitHub repositories.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，*为什么我们需要分页？*中，我们将探讨数据分页是什么以及它如何帮助我们将大型数据集拆分为数据页，从而优化我们应用与后端服务器之间的通信。接下来，在*导入和探索
    Repositories 应用*部分，我们将探索一个将集成分页的项目：显示 GitHub 仓库信息的 Repositories 应用。
- en: Then, in the *Using Kotlin Flow to handle streams of data* section, we will
    cover how paginated content can be expressed as a data stream and how Kotlin Flow
    is a great solution to handle such content. In the last section, *Exploring pagination
    with Jetpack Paging*, we will first explore the Jetpack Paging library as a solution
    to working with paginated content in our Android app, and then, with the help
    of this new library, we will integrate paging in our Repositories App to create
    the illusion of an infinite list of repositories.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*使用 Kotlin Flow 处理数据流*部分，我们将介绍如何将分页内容表示为数据流，以及 Kotlin Flow 如何成为处理此类内容的绝佳解决方案。在最后一节，*探索
    Jetpack Paging 的分页功能*中，我们首先将探索 Jetpack Paging 库作为我们在 Android 应用中处理分页内容的解决方案，然后，借助这个新库，我们将在我们的
    Repositories 应用中集成分页功能，以创建无限列表仓库的错觉。
- en: 'To summarize, in this chapter, we will be covering the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下部分：
- en: Why do we need pagination?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要分页？
- en: Importing and exploring the Repositories App
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入和探索 Repositories 应用
- en: Using Kotlin Flow to handle streams of data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kotlin Flow 处理数据流
- en: Exploring pagination with Jetpack Paging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Jetpack Paging 的分页功能
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为本章设置技术要求。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects for this chapter usually requires your
    day-to-day tools. However, to follow along smoothly, make sure you have the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 构建本章的 Compose-based Android 项目通常需要你日常使用的工具。然而，为了顺利跟进，请确保你具备以下条件：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that IDE interface and other
    generated code files might differ from the ones used throughout this book.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1 版本的 Android Studio。你也可以使用更新的 Android Studio 版本，甚至是 Canary
    构建，但请注意，IDE 界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10 or newer plugin installed in Android Studio
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中安装了 Kotlin 1.6.10 或更高版本的插件
- en: The existing Repositories App from the GitHub repository of the book
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自本书 GitHub 仓库的现有 Repositories 应用
- en: The starting point for this chapter is represented by the Repositories App that
    you can find by navigating to the `Chapter_11` directory of the GitHub repository
    of the book, and then by importing the `repositories_app_starting_point_ch11`
    directory from within Android Studio. Don't worry, as we will do this together
    later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是你可以通过导航到本书 GitHub 仓库的 `Chapter_11` 目录，然后从 Android Studio 内导入 `repositories_app_starting_point_ch11`
    目录找到的 Repositories 应用。不用担心，我们将在本章的后面一起完成这个操作。
- en: To access the solution code for this chapter, navigate to the `Chapter_11` directory
    and then import the `repositories_app_solution_ch11` directory from within Android
    Studio.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到 `Chapter_11` 目录，然后在 Android Studio 中从 `repositories_app_solution_ch11`
    目录导入。
- en: 'You can find the `Chapter_11` directory by following this link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接找到 `Chapter_11` 目录：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11)'
- en: Why do we need pagination?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要分页？
- en: Let's say we have an Android application that allows you to explore GitHub repositories
    by displaying a list of projects. It does that by querying the GitHub **REpresentational
    State Transfer** (**REST**) **application programming interface** (**API**) with
    Retrofit and obtaining a fixed number of repositories inside the app. While the
    REST API serves the application with detailed information for each repository,
    the app only uses and displays the title and description of the repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 Android 应用程序，允许你通过显示项目列表来探索 GitHub 仓库。它是通过使用 Retrofit 查询 GitHub **表示状态传输**（**REST**）**应用程序编程接口**（**API**）并获取应用内的固定数量的仓库来实现的。虽然
    REST API 为每个仓库提供详细的信息，但应用只使用并显示仓库的标题和描述。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don't confuse the Repository classes in our project architecture that abstract
    data logic with the GitHub repositories that are displayed in our Repositories
    App.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆我们项目架构中抽象数据逻辑的仓库类与在我们的仓库应用中显示的 GitHub 仓库。
- en: Now, let's imagine that this application retrieves and displays 20 repository
    elements. Because of this, the user will be able to scroll the content until the
    20th element, and therefore will be able to visualize no more than 20 elements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象这个应用检索并显示 20 个仓库元素。因此，用户将能够滚动内容直到第 20 个元素，因此将能够可视化不超过 20 个元素。
- en: But what if we wanted to allow the user to explore more repositories inside
    our list? In the end, the purpose of the app is to browse a larger number of repositories
    and not just 20.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想允许用户在我们的列表中探索更多仓库呢？最终，应用的目的在于浏览更多的仓库，而不仅仅是 20 个。
- en: We could update the network call and request a larger list of elements from
    one single shot. In other words, we could refactor our app to obtain and display
    a list of 10,000 repositories on one occasion—that is, when the app is launched.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新网络调用，并一次性请求一个更大的元素列表。换句话说，我们可以重构我们的应用，在应用启动时一次性获取并显示 10,000 个仓库列表。
- en: 'However, with such an approach, we can think of three main issues, as outlined
    here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，采用这种方法，我们可以想到三个主要问题，如下所述：
- en: '`LazyColumn` composable to render UI elements in a lazy manner (when needed),
    so we can conclude that this issue can be easily fixed.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn` 可用于以懒加载方式（当需要时）渲染 UI 元素，因此我们可以得出结论，这个问题可以很容易地解决。'
- en: '**The app would put a lot of pressure on the backend**—Imagine what would happen
    if every Android application client requested 10,000 database records from the
    backend server—these services would have to consume quite some resources to query
    and return so many elements.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用会对后端造成很大压力**——想象一下，如果每个 Android 应用客户端都从后端服务器请求 10,000 条数据库记录会发生什么——这些服务将不得不消耗大量资源来查询和返回这么多元素。'
- en: Such a **HyperText Transfer Protocol** (**HTTP**) request and response would
    cause a high network bandwidth consumption caused by the huge **JavaScript Object
    Notation** (**JSON**) payload that would have to be transferred. All 10,000 elements
    could contain a lot of fields and nested information—it's clear that having such
    a payload sent around between our apps and the server would be highly inefficient.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的 **超文本传输协议**（**HTTP**）请求和响应将导致由必须传输的大量 **JavaScript 对象表示法**（**JSON**）有效负载引起的高网络带宽消耗。所有
    10,000 个元素可能包含许多字段和嵌套信息——很明显，在我们的应用和服务器之间发送这样的有效负载将非常低效。
- en: While we can easily address the first issue, we can conclude that the second
    and third issues are very concerning. Many real-world applications and systems
    face these problems, and in order to alleviate them, the concept of pagination
    was adopted for most client-server communication-based relationships where large
    datasets had to be displayed to the end user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以轻松解决第一个问题，但我们得出结论，第二个和第三个问题非常令人担忧。许多现实世界的应用程序和系统面临这些问题，为了减轻这些问题，采用了分页的概念，用于大多数基于客户端-服务器通信的关系，在这些关系中必须向最终用户显示大量数据集。
- en: '**Pagination** is a server-friendly communication approach that breaks a huge
    result into multiple smaller chunks. In other words, if your backend supports
    pagination, your application can request only a portion of data (often called
    a **page**) and receive a partial response, thereby allowing the transfer to be
    faster and more efficient on both sides.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**分页**是一种对服务器友好的通信方法，它将大量结果分成多个较小的块。换句话说，如果您的后端支持分页，您的应用程序可以请求只获取部分数据（通常称为**页面**）并接收部分响应，从而允许在双方之间更快、更有效地传输。'
- en: When the application needs more results, it just requests another page, and
    another page, and so on. This approach is beneficial both for the app and backend
    service since only small portions of data are served and interpreted at a certain
    moment in time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要更多结果时，它只需请求另一页，再一页，依此类推。这种方法对应用和后端服务都有益，因为只有一小部分数据在某一时刻被提供和解释。
- en: With pagination, if the user decides to visualize only a small portion of items
    and then switch to another app, your app would have requested only this small
    portion of data. Without pagination, in the same case, your backend would have
    served your app with the entire collection of items, while some of your users
    wouldn't have had a chance to see all of them. This would be a waste of resources
    from the perspective of your app, but especially from the perspective of your
    backend service. Also, only a small portion out of the huge payload sent over
    the internet was needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分页，如果用户决定只可视化一小部分项目然后切换到另一个应用，您的应用只会请求这一小部分数据。没有分页的情况下，在相同的情况下，您的后端会为您的应用提供整个项目的集合，而一些用户可能没有机会看到所有这些项目。这从您应用的角度来看是资源的浪费，但从您后端服务的角度来看尤其如此。此外，只有互联网上发送的大量负载中的一小部分是需要的。
- en: 'To implement such a pagination behavior on the UI, there are two well-known
    UI approaches for mobile apps, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在UI上实现这种分页行为，对于移动应用来说有两种众所周知的UI方法，如下所述：
- en: A fixed number of items are displayed on a screen that resembles a web page.
    On this page, there is a fixed amount of scrolling space because if the user wants
    to see new items, a button must be pressed to switch pages (often representing
    the number of a specific page), and then a new set of data is loaded and displayed,
    replacing the existing content.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个类似于网页的屏幕上显示固定数量的项目。在这个页面上，有固定数量的滚动空间，因为如果用户想看到新项目，必须按下一个按钮来切换页面（通常表示特定页面的编号），然后加载并显示一组新数据，替换现有内容。
- en: From a mobile **user experience** (**UX**) perspective, this is a poor design
    choice because, as opposed to monitor screens used for web pages, scrolling over
    contents is more natural on smaller-sized devices such as phones.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从移动**用户体验**（**UX**）的角度来看，这是一个糟糕的设计选择，因为与用于网页的显示器屏幕相比，在尺寸较小的设备（如手机）上滚动内容更为自然。
- en: The list of items displayed grows as the user scrolls, thereby creating the
    impression that the list is infinite—such an approach is often referred to as
    infinite scrolling. While there is no such thing as an infinite list, this approach
    mimics one. It starts with a few requests for the initial page/s, and as the user
    scrolls to see more elements, it requests more pages with more content on the
    fly. This approach relies heavily on scrolling and usually creates a better UX.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着用户滚动，显示的项目列表会增长，从而产生列表无限的印象——这种做法通常被称为无限滚动。虽然没有无限列表这样的东西，但这种做法模仿了它。它从对初始页面/的几个请求开始，当用户滚动以查看更多元素时，它会动态地请求包含更多内容的更多页面。这种方法高度依赖于滚动，通常创造出更好的用户体验。
- en: 'In this chapter, we will go for the second option—in other words, we will implement
    paging in an attempt to mimic the infinite list effect. Let''s also try to visualize
    how the app could request more items as the user scrolls in the following simplified
    example, where **Page 1** contains only six elements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将选择第二种方案——换句话说，我们将尝试实现分页以模拟无限列表效果。让我们也尝试在以下简化示例中可视化应用如何随着用户滚动而请求更多项目，其中**第1页**仅包含六个元素：
- en: '![Figure 11.1 – Observing how infinite lists can be achieved with pagination'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 观察如何通过分页实现无限列表'
- en: '](img/B17788_11_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_11_01.jpg]'
- en: Figure 11.1 – Observing how infinite lists can be achieved with pagination
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 观察如何通过分页实现无限列表
- en: For the app to request the second page with items, the users must scroll further
    down, thereby informing the app about their intention of wanting to see more elements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让应用请求包含项目的第二页，用户必须进一步向下滚动，从而通知应用他们想要查看更多元素。
- en: When the app catches on to this intention (because the user reached the end
    of the list), it asks for the second page with items from the backend, making
    the list of repositories grow and allowing the user to browse through the new
    content. This process repeats on and on, as the user keeps on reaching the end
    of the list.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用捕捉到这个意图（因为用户到达列表的末尾）时，它会请求包含后端项目的第二页，使仓库列表增长，并允许用户浏览新内容。这个过程会不断重复，因为用户会不断到达列表的末尾。
- en: Before implementing this pagination approach, let's first get to know our starting
    point—the GitHub Repositories App!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此分页方法之前，让我们首先了解我们的起点——GitHub仓库应用！
- en: Importing and exploring the Repositories App
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入并探索仓库应用
- en: The Repositories App project is a simple application that displays a list of
    repositories obtained from the GitHub Search API. This project is a simplified
    version of a Compose-based application that incorporates only a few concepts from
    the previous chapters as it tries to be a good candidate for implementing pagination
    with the Jetpack Paging library rather than being a fully-fledged sample app that
    applies all the concepts taught in the book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库应用项目是一个简单的应用，它显示从GitHub搜索API获取的仓库列表。该项目是Compose应用的一个简化版本，它只包含前几章中的一些概念，因为它试图成为实现分页的Jetpack
    Paging库的良好候选者，而不是一个完全实现的应用程序，该应用程序应用了书中教授的所有概念。
- en: Nevertheless, we will see how the Repositories App follows a `ViewModel` class
    to hold state and present data, coroutines for the **asynchronous** (**async**)
    operation of obtaining data from the server, and Compose for the UI layer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们将看到仓库应用如何遵循`ViewModel`类来保持状态和展示数据，使用协程进行从服务器获取数据的**异步**（**async**）操作，以及使用Compose进行UI层。
- en: 'Let''s start off by importing this project into Android Studio, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将此项目导入Android Studio开始，如下所示：
- en: Navigate to the GitHub repository page of the book, located at [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到本书的GitHub仓库页面，位于[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin)。
- en: Download the repository files. You can do that by pressing the **Code** button
    and then by selecting **Download zip**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载仓库文件。您可以通过按下**代码**按钮，然后选择**下载zip**来完成此操作。
- en: Unzip the downloaded files and remember the location where you did this.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载的文件，并记住您这样做的地方。
- en: Open Android Studio, press on the **File** tab option, and then select **Open**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，点击**文件**选项卡，然后选择**打开**。
- en: Search for the directory where you unzipped the project files. Once you have
    found it, navigate to the `Chapter_11` directory, select the `repositories_app_starting_point_ch11`
    directory, and press **Open**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索您解压项目文件的目录。一旦找到，导航到`Chapter_11`目录，选择`repositories_app_starting_point_ch11`目录，然后按**打开**。
- en: Run the application on your test device.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的测试设备上运行应用程序。
- en: 'You should notice that our Repositories App displays a list of repositories,
    and the index of each repository item from the list is displayed on the left side,
    as illustrated in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到我们的仓库应用显示了一个仓库列表，列表中每个仓库项目的索引显示在左侧，如下面的截图所示：
- en: '![Figure 11.2 – Observing the Repositories App without pagination'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 – 观察没有分页的仓库应用'
- en: '](img/B17788_11_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_11_02.jpg]'
- en: Figure 11.2 – Observing the Repositories App without pagination
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 查看未启用分页的仓库应用
- en: If you scroll further down, you will notice that only 20 elements can be viewed.
    This means that our app doesn't support paging and the user can only browse through
    20 repositories.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你继续向下滚动，你会注意到只能查看20个元素。这意味着我们的应用不支持分页，用户只能浏览20个仓库。
- en: 'If we have a look inside the `RepositoriesApiService.kt` file, we will notice
    that our app instructs the REST API through the `@GET()` endpoint **Uniform Resource
    Locator** (**URL**) to obtain the first page of repositories while fetching only
    20 items per page, as illustrated in the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`RepositoriesApiService.kt`文件，我们会注意到我们的应用通过`@GET()`端点**统一资源定位符**（**URL**）指令REST
    API获取仓库的第一页，每次只获取每页20个项目，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have a look at the parameters hardcoded within the request, you will
    notice that our app always requests the first page of repositories. Also, because
    it can specify the page number, this clearly means that the backend we're accessing
    supports pagination, but because we always ask for page `1`, our app doesn't take
    advantage of it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看请求中硬编码的参数，你会注意到我们的应用总是请求仓库的第一页。此外，因为它可以指定页码，这显然意味着我们访问的后端支持分页，但因为我们总是请求页码`1`，所以我们的应用没有利用这一点。
- en: More specifically, when the app performs this request, it will always retrieve
    20 records from the backend from the page with index `1`. Later in this chapter,
    we will learn how to make multiple network calls requesting different page numbers,
    therefore adopting pagination.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，当应用执行此请求时，它将从索引为`1`的页面从后端检索20条记录。在本章的后面部分，我们将学习如何进行多个网络调用，请求不同的页码，从而实现分页。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're looking to build an app that supports pagination, you must first make
    sure that your backend supports pagination, just as the GitHub Search API does.
    Remember that the whole purpose of pagination is to ease the workload of the backend
    API and to minimize the network bandwidth consumption associated with retrieving
    a huge JSON payload, so if your backend doesn't support pagination, you can't
    implement pagination in your app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要构建一个支持分页的应用，你必须首先确保你的后端支持分页，就像GitHub搜索API一样。记住，分页的整个目的是减轻后端API的工作负担，并最小化与检索大量JSON有效负载相关的网络带宽消耗，所以如果你的后端不支持分页，你无法在你的应用中实现分页。
- en: 'Let''s have a brief look over the response we receive from the GitHub API by
    navigating to the `Repository.kt` file. Basically, we get a list of `Repository`
    objects, and we parse the `id`, `name`, and `description` values of the repository,
    as illustrated in the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下我们从GitHub API收到的响应，通过导航到`Repository.kt`文件。基本上，我们得到一个`Repository`对象的列表，并解析仓库的`id`、`name`和`description`值，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As mentioned before, our app makes use of the GitHub Search API, and this can
    be better observed inside the `DependencyContainer.kt` class where the Retrofit
    `RepositoriesApiService` dependency is manually constructed, and the base URL
    of this API is passed. You can view the code for this process in the following
    snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的应用使用了GitHub搜索API，这可以在`DependencyContainer.kt`类中更好地观察到，其中手动构建了Retrofit的`RepositoriesApiService`依赖项，并传递了此API的基本URL。你可以查看此过程的代码如下所示：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you're looking to find out more about the API we're using in this chapter,
    head over to the official documentation of the GitHub Search API, at [https://docs.github.com/en/rest/search#search-repositories](https://docs.github.com/en/rest/search#search-repositories).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于本章中使用的API的信息，请访问GitHub搜索API的官方文档，网址为[https://docs.github.com/en/rest/search#search-repositories](https://docs.github.com/en/rest/search#search-repositories)。
- en: 'Now, going back to our Repositories App, if we navigate to the `RepositoriesViewModel.kt`
    file, we will see that our `ViewModel` class uses the `RepositoriesApiService`
    dependency to obtain a list of repositories by launching a coroutine and setting
    the result to a Compose `State` object holding a list of `Repository` objects.
    The code is illustrated in the following snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的仓库应用，如果我们导航到`RepositoriesViewModel.kt`文件，我们会看到我们的`ViewModel`类使用`RepositoriesApiService`依赖项通过启动协程并将结果设置为一个包含`Repository`对象列表的Compose
    `State`对象来获取仓库列表。代码如下所示：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The approach of having a Jetpack ViewModel launch a coroutine to obtain data
    with the help of Retrofit is very similar to what we've done in the Restaurants
    App.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jetpack ViewModel 启动协程并通过 Retrofit 获取数据的做法与我们在 Restaurants App 中所做的是非常相似的。
- en: 'The UI level is also similar to the Restaurants App. If we navigate to the
    `MainActivity.kt` file, we can see that our `Activity` class creates a `ViewModel`
    instance, retrieves a Compose `State` object, obtains its value of type `List<Repository>`,
    and passes it to a composable function to consume it, as illustrated in the following
    code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: UI 层也与 Restaurants App 类似。如果我们导航到 `MainActivity.kt` 文件，我们可以看到我们的 `Activity`
    类创建了一个 `ViewModel` 实例，检索了一个 Compose `State` 对象，获取了其类型为 `List<Repository>` 的值，并将其传递给一个可组合函数以消费它，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The composable function that consumes the list of `Repository` objects resides
    inside the `RepositoriesScreen.kt` file, as illustrated in the following code
    snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 消费 `Repository` 对象列表的可组合函数位于 `RepositoriesScreen.kt` 文件中，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just as in the Restaurants App, our screen-level composable uses the `LazyColumn`
    composable to optimize the way the UI renders elements in the list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Restaurants App 一样，我们屏幕级别的可组合组件使用 `LazyColumn` 可组合组件来优化 UI 在列表中渲染元素的方式。
- en: '`LazyColumn` usage is important for our use case of trying to implement pagination
    because we don''t want our UI to render thousands of UI elements. Luckily, as
    we know already, `LazyColumn` has us covered because it only composes and lays
    out visible elements on the screen.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们尝试实现分页的用例，`LazyColumn` 的使用非常重要，因为我们不希望我们的 UI 渲染成千上万的 UI 元素。幸运的是，正如我们所知，`LazyColumn`
    已经为我们解决了这个问题，因为它只组合和布局屏幕上的可见元素。
- en: Now, you might have noticed that the `RepositoriesScreen` composable uses the
    `itemsIndexed()` `items()` function that we used in the Restaurants App. This
    is because, since our app will support pagination, we want to paint the index
    of the element displayed on the screen to better understand where we are at right
    now. To get the index of the composable item visible on the screen, the `itemsIndexed()`
    function provides us with this information out of the box.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经注意到 `RepositoriesScreen` 可组合组件使用了我们在 Restaurants App 中使用的 `itemsIndexed()`
    和 `items()` 函数。这是因为，由于我们的应用将支持分页，我们希望显示屏幕上显示的元素的索引，以便更好地理解我们现在在哪里。为了获取屏幕上可见的可组合项的索引，`itemsIndexed()`
    函数为我们提供了这种信息。
- en: 'Finally, let''s have a brief look over the structure of the `RepositoryItem`
    composable that displays the contents of a `Repository` object, while also rendering
    the index of the repository, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要地看一下显示 `Repository` 对象内容的 `RepositoryItem` 可组合组件的结构，同时渲染仓库的索引，如下所示：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have briefly covered the current state of the Repositories App,
    we can conclude that it could really use pagination to show more repositories,
    especially when the GitHub Search API supports that. It's time to cover another
    important aspect that pagination forces us to be aware of, and that's the concept
    of streams of data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了 Repositories App 的当前状态，我们可以得出结论，它确实需要分页来显示更多仓库，尤其是在 GitHub 搜索 API
    支持分页的情况下。现在是时候探讨另一个 pagination 强迫我们注意的重要方面，那就是数据流的概念。
- en: Using Kotlin Flow to handle streams of data
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin Flow 处理数据流
- en: If we want our app to support pagination in the form of an infinite list, it's
    clear that our existing approach of having a single one-shot request to the backend
    that results in one UI update will not suffice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的应用以无限列表的形式支持分页，很明显，我们现有的通过一次性的请求后端并导致一次 UI 更新的方法是不够的。
- en: 'Let''s first have a look in the following code snippet at how our `RepositoriesViewModel`
    class requests data:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下以下代码片段，看看我们的 `RepositoriesViewModel` 类是如何请求数据的：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the `ViewModel` is initialized, it executes the `getRepositories()` suspending
    function inside a coroutine. The suspending function returns a list of `Repository`
    objects that is passed to the `repositories` variable. This means that our `ViewModel`
    performs a one-shot request for data in the form of a one-time call to the suspending
    function—no other request is done over time to get new repositories as the user
    scrolls through the list. That's why our app receives a single event with data
    (an initial list of objects) from the backend as a single result.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ViewModel` 初始化时，它在一个协程内部执行 `getRepositories()` 挂起函数。挂起函数返回一个 `Repository`
    对象列表，并将其传递给 `repositories` 变量。这意味着我们的 `ViewModel` 以一次性调用挂起函数的形式进行一次性的数据请求——在用户滚动列表时不会进行其他请求以获取新的仓库。这就是为什么我们的应用程序从后端接收一个包含数据（对象初始列表）的单个事件作为单个结果。
- en: 'We can imagine that calling a similar `getRepositories()` suspending function
    with the one in our app would just as well return a one-time response as its return
    type would be `List<Repository>`, as illustrated in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象，调用与我们的应用程序中类似的 `getRepositories()` 挂起函数将同样返回一次性响应，因为它的返回类型将是 `List<Repository>`，如下面的截图所示：
- en: '![Figure 11.3 – Observing one-shot data result with suspending function'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 使用挂起函数观察单次数据结果'
- en: '](img/B17788_11_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_11_03.jpg]'
- en: Figure 11.3 – Observing one-shot data result with suspending function
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 使用挂起函数观察单次数据结果
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While our `ViewModel` contains a `repositories` variable whose type is `MutableState`,
    meaning that it can change its value over time, we aren't going to use Compose
    `State` objects to observe changes coming from the data layer as this would break
    the responsibilities of layers. Right now, in our code, we are calling a suspending
    function that returns only one result or one set of data asynchronously. This
    result is passed to the `repositories` variable, so even though our UI state can
    change over time, it only receives one update.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的 `ViewModel` 包含一个类型为 `MutableState` 的 `repositories` 变量，这意味着它的值可以在时间上改变，但我们不会使用
    Compose `State` 对象来观察数据层的变化，因为这会破坏层的职责。目前，在我们的代码中，我们调用一个返回单个结果或一组数据的挂起函数，该结果异步地传递给
    `repositories` 变量，因此尽管我们的 UI 状态可以随时间改变，但它只接收一个更新。
- en: To support an infinite list, we must somehow design our app to receive multiple
    results over time, just as with a stream of data. In other words, our app must
    request new `Repository` objects as the user scrolls, thereby receiving multiple
    events with data, and not just one. With every new data event coming in, our app
    should get a new list of `Repository` objects that now contains the newly received
    repositories as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持无限列表，我们必须以某种方式设计我们的应用程序以接收随时间推移的多个结果，就像接收数据流一样。换句话说，我们的应用程序必须在用户滚动时请求新的
    `Repository` 对象，从而接收包含多个事件的数据，而不仅仅是单个事件。每当有新的数据事件到来时，我们的应用程序应该获得一个新的 `Repository`
    对象列表，其中现在包含了新接收的仓库。
- en: To make our `ViewModel` receive multiple events of data in the form of a stream
    of data, we can use Flow. Kotlin **Flow** is a data type built on top of coroutines
    that exposes a stream of multiple, asynchronously computed values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的 `ViewModel` 以数据流的形式接收多个数据事件，我们可以使用 Flow。Kotlin 的 **Flow** 是建立在协程之上的数据类型，它公开了一个异步计算的多值流。
- en: As opposed to suspending functions, which emit a single result, Flow allows
    us to emit multiple values sequentially over time. However, just as a suspending
    function emits a result in an asynchronous manner that you can later obtain from
    within a coroutine, Flow also emits results asynchronously, so you must observe
    its results from within a launched coroutine.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与只发出单个结果的挂起函数不同，Flow 允许我们在时间上顺序地发出多个值。然而，就像挂起函数以异步方式发出结果，你可以在协程中稍后获取一样，Flow
    也以异步方式发出结果，因此你必须从启动的协程中观察其结果。
- en: You could use Flow to listen for events coming from various sources; for example,
    you could use Flow to get location updates every time the location of the user
    changes. Or, you could use Flow to get sequential updates from your Room database—instead
    of manually querying the database every time you insert or update items, you can
    tell Room to return a flow that will emit updates with its most up-to-date content
    whenever you perform insertions, updates, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Flow 来监听来自各种来源的事件；例如，您可以使用 Flow 在用户位置每次改变时获取位置更新。或者，您可以使用 Flow 从您的 Room
    数据库获取连续更新——而不是每次插入或更新项目时都手动查询数据库，您可以告诉 Room 返回一个流，该流将在您执行插入、更新等操作时发出包含最新内容的更新。
- en: 'Getting back to our example with repositories, let''s imagine that our `getRepositories()`
    function is no longer a suspending function, but instead returns a flow whose
    contained data is of type `List<Repository>`, as illustrated in the following
    screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们关于仓库的例子，让我们假设我们的 `getRepositories()` 函数不再是一个挂起函数，而是返回一个包含类型为 `List<Repository>`
    的数据的流，如下面的截图所示：
- en: '![Figure 11.4 – Observing multiple results over time with Kotlin Flow'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – 使用 Kotlin Flow 随时间观察多个结果]'
- en: '](img/B17788_11_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_11_04.jpg]'
- en: Figure 11.4 – Observing multiple results over time with Kotlin Flow
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – 使用 Kotlin Flow 随时间观察多个结果]'
- en: Just as the Compose `State` object holds data of a certain type (for example,
    `State<Int>` emits values of type `Int`), Flow also holds data of a certain type;
    in our previous example, that type was the data we're interested in emitting—that
    is, `List<Repository>`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Compose 的 `State` 对象持有特定类型的数据（例如，`State<Int>` 发射 `Int` 类型的值）一样，Flow 也持有特定类型的数据；在我们之前的例子中，该类型是我们感兴趣发射的数据类型，即
    `List<Repository>`。
- en: But how can we observe the emitted values of a flow?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何观察流的发出值呢？
- en: 'Let''s take the previous example where the `getRepositories()` method returned
    a `Flow<List<Repository>>` instance, and let''s imagine that we''re trying to
    observe its values in a UI component, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面的例子为例，其中 `getRepositories()` 方法返回一个 `Flow<List<Repository>>` 实例，并假设我们正在尝试在一个
    UI 组件中观察其值，如下所示：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since a flow emits values asynchronously, we obtained the `Flow<List<Repository>>`
    instance inside a launched coroutine and then called the `.collect()` method,
    which in turn provided us with a block of code where we can consume the `List<Repository>`
    values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流异步发出值，我们在启动的协程中获得了 `Flow<List<Repository>>` 实例，然后调用了 `.collect()` 方法，该方法反过来提供了一个代码块，我们可以在这里消费
    `List<Repository>` 值。
- en: As opposed to obtaining such a list from a suspending function call, it's important
    to remember that the values emitted by the flow change (or, at least, should change)
    over time. In other words, for every callback that provides us with a value stored
    in the `repos` variable, the content of its value of type `List<Repository>` could
    be different, allowing us to update the UI on every new emission.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与从挂起函数调用中获取此类列表相反，重要的是要记住流发出的值会随时间变化（或者至少应该变化）。换句话说，对于每个提供存储在 `repos` 变量中的值的回调，其类型为
    `List<Repository>` 的值的内容可能不同，这允许我们在每次新的发射中更新 UI。
- en: In this section, we have explored what a flow is and how we can consume it.
    However, Kotlin Flow is a very complex subject; for example, we aren't going to
    cover the manner in which you can create a flow, or how you can modify the produced
    stream. If you're looking to find out more about Flow, check the official Android
    documentation at [https://developer.android.com/kotlin/flow](https://developer.android.com/kotlin/flow).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了流是什么以及我们如何消费它。然而，Kotlin Flow 是一个非常复杂的话题；例如，我们不会涵盖您创建流的方式或如何修改产生的流。如果您想了解更多关于
    Flow 的信息，请查看官方 Android 文档：[https://developer.android.com/kotlin/flow](https://developer.android.com/kotlin/flow)。
- en: Let's now explore the last missing piece of the puzzle—the Paging library.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索拼图中最后一块缺失的拼图——分页库。
- en: Exploring pagination with Jetpack Paging
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索使用 Jetpack Paging 的分页
- en: To implement an infinite list of repositories in our Repositories App, we must
    find a way to request more repositories as the user scrolls through the existing
    list and reaches its bottom, thereby adding new elements on the fly. Instead of
    manually deciding when the user is approaching the bottom of the current list
    of repositories and then triggering a network request to get new items, we can
    use the Jetpack Paging library, which hides all this complexity from us.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的仓库应用中实现无限列表的仓库，我们必须找到一种方法，当用户滚动现有列表并到达底部时，请求更多仓库，从而动态添加新元素。而不是手动决定用户何时接近当前仓库列表的底部，然后触发网络请求以获取新项目，我们可以使用
    Jetpack Paging 库，它将所有这些复杂性隐藏起来。
- en: '**Jetpack Paging** is a library that helps us load and display pages of data
    from a large set of data, either through network requests or from our local data
    storage, thereby allowing us to save network bandwidth and optimize the usage
    of system resources.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jetpack Paging** 是一个库，帮助我们从大量数据中加载和显示数据页，无论是通过网络请求还是从我们的本地数据存储，从而允许我们节省网络带宽并优化系统资源的利用。'
- en: In this chapter, for simplicity, we will use the Paging library to display an
    infinite list of repositories obtained from a network source (that is, the GitHub
    Search API), without involving the local cache.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为了简单起见，我们将使用 Paging 库来显示从网络源（即 GitHub 搜索 API）获取的无限列表仓库，而不涉及本地缓存。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Jetpack Paging library is now at its third implementation iteration, which
    is often referred to as Paging 3 or Paging v3\. In this chapter, we will be using
    this latest version, so even though we will simply call it Jetpack Paging, we
    are in fact referring to Jetpack Paging 3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Paging 库现在处于其第三个实现迭代，通常被称为 Paging 3 或 Paging v3。在本章中，我们将使用这个最新版本，因此尽管我们只是简单地称之为
    Jetpack Paging，但实际上我们指的是 Jetpack Paging 3。
- en: 'The Jetpack Paging library abstracts most of the complexity associated with
    requesting the correct page at the correct time, depending on the scroll position
    of the user. Practically, it brings a lot of benefits to the table, such as the
    following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Paging 库抽象了与请求正确页面的复杂性，这取决于用户的滚动位置。实际上，它带来了许多好处，例如以下内容：
- en: Avoidance of data request duplication—your app will request data only when needed;
    for example, when the user reaches the end of the list and more items must be
    rendered.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免数据请求重复——你的应用程序只有在需要时才会请求数据；例如，当用户到达列表末尾并且必须渲染更多项目时。
- en: Paged data is cached in memory out of the box. During the lifetime of the app
    process, once a page was loaded, your app will never request it again. If you
    cache the paginated data in a local database, then your application will not need
    to request a specific page for cases such as after an app restart.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页数据默认在内存中缓存。在应用程序进程的生命周期内，一旦加载了一页，你的应用程序将永远不会再次请求它。如果你在本地数据库中缓存分页数据，那么你的应用程序在应用重启后等情况下不需要请求特定的页面。
- en: 'Paginated data is exposed as a data stream of the type that fits your need:
    Kotlin Flow, LiveData, or RxJava. As you might have guessed, we will use Flow.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页数据以适合您需求的数据流类型暴露：Kotlin Flow、LiveData 或 RxJava。正如你可能猜到的，我们将使用 Flow。
- en: Out-of-the-box support for View System or Compose-based UI components that request
    data automatically when the user scrolls toward the end of the list. With such
    support, we don't have to know when to request new pages with data as the UI layer
    will trigger that for us out of the box.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对基于 View System 或 Compose 的 UI 组件的原生支持，当用户滚动到列表末尾时，这些组件会自动请求数据。有了这种支持，我们不必知道何时请求新的数据页，因为
    UI 层会为我们自动触发。
- en: Retry and refresh capabilities triggered directly by the UI components.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 UI 组件直接触发的重试和刷新功能。
- en: 'Before moving to the actual integration of the Paging library, let''s spend
    a bit of time looking over the main components part of the Paging API. To ensure
    paging in your application with the Jetpack Paging API, you must use the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际集成 Paging 库之前，让我们花点时间了解一下 Paging API 的主要组件部分。为了确保使用 Jetpack Paging API 在你的应用程序中实现分页，你必须使用以下内容：
- en: A `PagingSource` component—Defines the source of data for the paginated content.
    This object decides which page to request and loads it from your remote or local
    data source. If you're looking to have both a local and remote data source for
    your paginated content, you could use the built-in `RemoteMediator` API of the
    Paging library. Check out the *Further reading* section for more information on
    this.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `PagingSource` 组件——定义分页内容的源数据。该对象决定请求哪一页，并从你的远程或本地数据源加载它。如果你希望你的分页内容既有本地又有远程数据源，你可以使用
    Paging 库内置的 `RemoteMediator` API。有关更多信息，请参阅 *进一步阅读* 部分。
- en: A `Pager` component—Based on the defined `PagingSource` component, you can construct
    a `Pager` object that will expose a stream of `PagingData` objects. You can configure
    the `Pager` object by passing a `PagingConfig` object to its constructor and specifying
    the page size of your data, for example.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Pager` 组件——基于定义的 `PagingSource` 组件，你可以构建一个 `Pager` 对象，该对象将公开 `PagingData`
    对象的流。你可以通过将 `PagingConfig` 对象传递给其构造函数并指定数据的大小来配置 `Pager` 对象，例如。
- en: The `PagingData` class is a wrapper over your paginated data containing a set
    of items part of the corresponding page. The `PagingData` object is responsible
    for triggering a query for a new page with items that is then forwarded to the
    `PagingSource` component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`PagingData` 类是对你的分页数据的包装，包含对应页面的项目集合。`PagingData` 对象负责触发对新页面的查询，该页面包含的项目随后被转发到
    `PagingSource` 组件。'
- en: A dedicated UI component that supports pagination—To consume the stream of paginated
    content, your UI must make use of dedicated UI components that can handle paginated
    data. If your UI is based on the traditional View System, you could use the `PagingDataAdapter`
    component. Since our UI layer is based on Compose, `LazyColumn` has us covered
    as it knows how to consume paginated data (more on that in the next section).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持分页的专用 UI 组件——为了消费分页内容的流，你的 UI 必须使用能够处理分页数据的专用 UI 组件。如果你的 UI 基于传统的 View 系统，你可以使用
    `PagingDataAdapter` 组件。由于我们的 UI 层基于 Compose，`LazyColumn` 已经为我们处理了分页数据的消费（更多内容将在下一节中介绍）。
- en: 'To get a visual understanding of how all these components should fit, let''s
    take the following example of a possible implementation of the Paging library
    inside our Repositories App:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直观地了解所有这些组件应该如何配合，让我们看看以下示例，即在我们的 Repositories 应用程序中可能的 Paging 库实现：
- en: '![Figure 11.5 – Observing how Paging library APIs can be used in the Repositories
    App'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5 – 观察 Paging 库 API 在 Repositories 应用程序中的使用'
- en: '](img/B17788_11_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_11_05.jpg)'
- en: Figure 11.5 – Observing how Paging library APIs can be used in the Repositories
    App
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 观察 Paging 库 API 在 Repositories 应用程序中的使用
- en: At the UI level, our composable collects a flow that contains a stream of `PagingData<Repository>`
    objects. The `PagingData` object contains a list of `Repository` objects, and
    behind the scenes, it's responsible for forwarding requests for new pages to `PagingSource`,
    which in turn asks for new items from our REST API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 层面，我们的可组合组件收集了一个包含 `PagingData<Repository>` 对象流的流。`PagingData` 对象包含一个 `Repository`
    对象列表，在幕后，它负责将新页面的请求转发到 `PagingSource`，而 `PagingSource` 则从我们的 REST API 获取新项目。
- en: Inside `ViewModel`, we will have a `Pager` object that will use an instance
    of `PagingSource`. We will define a `PagingSource` object so that it knows which
    page to ask for and where to ask for it—that is, the GitHub Search API.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewModel` 内部，我们将有一个 `Pager` 对象，它将使用 `PagingSource` 的一个实例。我们将定义一个 `PagingSource`
    对象，以便它知道要请求哪一页以及在哪里请求——即 GitHub 搜索 API。
- en: 'Now that we have covered the theoretical aspects of our pagination integration
    with Jetpack Paging, let''s see which practical tasks we will be working on in
    this section. We will be doing the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了使用 Jetpack Paging 进行分页集成的理论方面，让我们看看在本节中我们将要完成哪些实际任务。我们将执行以下操作：
- en: Implementing pagination with Jetpack Paging
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jetpack Paging 实现分页
- en: Implementing loading and error states plus retry functionality
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现加载和错误状态以及重试功能
- en: 'Let''s proceed with the first task: integrating pagination in our Repositories
    App.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始第一个任务：将分页集成到我们的 Repositories 应用程序中。
- en: Implementing pagination with Jetpack Paging
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jetpack Paging 实现分页
- en: In this section, we will integrate paging in our Repositories App and create
    an infinite list of repositories with the help of Jetpack Paging. To achieve that,
    we will implement and add all the components described in the previous section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将集成分页到我们的 Repositories 应用程序中，并借助 Jetpack Paging 创建一个无限列表的仓库。为了实现这一点，我们将实现并添加上一节中描述的所有组件。
- en: 'Let''s get cracking! Proceed as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！按照以下步骤进行：
- en: 'First, inside the app-level `build.gradle` file, in the `dependencies` block,
    add the Compose Gradle dependency for Jetpack Paging, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在应用级别的`build.gradle`文件中，在`dependencies`块中，添加Jetpack Paging的Compose Gradle依赖项，如下所示：
- en: '[PRE9]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by pressing on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`build.gradle`文件后，请确保将项目与其Gradle文件同步。您可以通过点击**文件**菜单选项，然后选择**同步项目与Gradle文件**来完成此操作。
- en: 'Next up, let''s refactor our Retrofit `RepositoriesApiService` interface by
    removing the hardcoded page index of `1` within the `@GET()` request annotation,
    and by adding a query `page` parameter of type `Int` representing the page index
    we''re looking to acquire. The code is illustrated in the following snippet:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们重构我们的Retrofit `RepositoriesApiService`接口，通过从`@GET()`请求注解中移除硬编码的页面索引`1`，并添加一个表示我们想要获取的页面索引的`page`查询参数类型`Int`。代码如下所示：
- en: '[PRE10]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before these changes, we were always obtaining the first page of repository
    results. Now, we have updated our network request to harvest the power of paginated
    REST APIs—that is, the capability to ask for a different page index based on the
    scrolling position of the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之前，我们总是获取仓库结果的首页。现在，我们已经更新了我们的网络请求，以利用分页REST API的力量——即根据用户的滚动位置请求不同的页面索引。
- en: To achieve this, we used the Retrofit `@Query()` annotation, which basically
    will insert the value of the `page` parameter we have defined in the `getRepositories()`
    method into the `GET` request. As the GitHub Search API expects a `"page"` query
    key in the URL request, we have passed the `"page"` key to the `@Query()` annotation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用了Retrofit的`@Query()`注解，它基本上会将我们在`getRepositories()`方法中定义的`page`参数值插入到`GET`请求中。由于GitHub搜索API期望在URL请求中有一个`"page"`查询键，因此我们将`"page"`键传递给了`@Query()`注解。
- en: It's now time to build a `PagingSource` component that will request new pages
    through our `RepositoriesApiService` dependency and will keep track of which page
    to ask for, while also keeping an in-memory cache of the previously retrieved
    pages.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候构建一个`PagingSource`组件了，该组件将通过我们的`RepositoriesApiService`依赖项请求新页面，并跟踪要请求的页面，同时还要在内存中缓存之前检索到的页面。
- en: 'Inside the root package of the app, create a new class named `RepositoriesPagingSource`
    and paste the following code below it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的根包中，创建一个名为`RepositoriesPagingSource`的新类，并将其以下代码粘贴到该类下面：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s break down the code we have just added. This component is doing the
    following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析我们刚刚添加的代码。此组件正在执行以下操作：
- en: It is in charge of requesting new pages, so it has a dependency on `RepositoriesApiService`
    as the `restInterface` constructor field.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它负责请求新页面，因此它依赖于`RepositoriesApiService`作为`restInterface`构造函数字段。
- en: 'It is a `PagingSource` component, so it inherits from the `PagingSource` class
    while also defining the following:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个`PagingSource`组件，因此它继承自`PagingSource`类，同时定义了以下内容：
- en: A key as the type of the page index—in our case, the GitHub Search API requires
    an integer representing the index of the page, so we set the key as `Int`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为页面索引类型的键——在我们的例子中，GitHub搜索API需要一个表示页面索引的整数，因此我们将键设置为`Int`。
- en: Type of the loaded data—in our case, `Repository` objects.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载数据的类型——在我们的例子中，是`Repository`对象。
- en: 'Implementing the following two mandatory functions:'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现以下两个必需的函数：
- en: The `load()` suspending function, which is called automatically by the Paging
    library and should fetch more items asynchronously. This method takes in a `LoadParams`
    object that keeps track of information such as what is the key (index) of the
    page that must be requested, or the initial load size of items. Also, this method
    returns a `LoadResult` object indicating if a specific query result was successful
    or has failed.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()`挂起函数，该函数由Paging库自动调用，应异步获取更多项目。此方法接受一个`LoadParams`对象，该对象跟踪有关信息，例如必须请求的页面（索引）的键（索引）或项目的初始加载大小。此外，此方法返回一个`LoadResult`对象，指示特定查询结果是否成功或失败。'
- en: The `getRefreshKey()` function, which is called to obtain and return the most
    recent page key in case of a refresh event so that the user is returned to the
    latest known page (and not the first one). A refresh event can come from a variety
    of sources, such as a manual UI refresh triggered by the user, a database cache
    invalidation event, system events, and so on.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRefreshKey()`函数，在刷新事件发生时被调用以获取并返回最新的页面键，以便用户返回到最新的已知页面（而不是第一个页面）。刷新事件可以来自各种来源，例如用户触发的手动UI刷新、数据库缓存失效事件、系统事件等等。'
- en: For simplicity, and also because we will not implement refresh capabilities,
    we will skip implementing the `getRefreshKey()` method, so we just returned `null`
    inside the body of this method. However, if you're looking to also support such
    behavior, check out the *Further reading* section where additional resources are
    listed to help you provide an implementation for this method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，也因为我们将不会实现刷新功能，我们将跳过实现`getRefreshKey()`方法，所以我们只是在方法的主体中返回`null`。然而，如果你也想支持这种行为，请查看*进一步阅读*部分，其中列出了额外的资源，以帮助你提供此方法的实现。
- en: Now that we have covered the purpose of the two mandatory methods, let's implement
    the one we're really interested in—the `load()` function.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了两个强制方法的用途，让我们实现我们真正感兴趣的`load()`函数。
- en: 'This method should return a `LoadResult` object, so first, add a `try`-`catch`
    block, and inside the `catch` block, return an `Error()` instance of `LoadResult`
    by passing the `Exception` object that was caught, as illustrated in the following
    code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法应返回一个`LoadResult`对象，因此首先添加一个`try`-`catch`块，并在`catch`块内部，通过传递捕获到的`Exception`对象返回`LoadResult.Error`实例，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this approach, if the request for a new page fails, we let the Paging library
    know that an error event occurred by returning the `LoadResult.Error` object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，如果新页面的请求失败，我们通过返回`LoadResult.Error`对象让Paging库知道发生了错误事件。
- en: 'Next up, inside the `try` block, we must first obtain and store the next page
    we''re interested in. Store the index of the next page inside the `nextPage` variable,
    as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`try`块内部，我们首先必须获取并存储我们感兴趣的下一页。将下一页的索引存储在`nextPage`变量中，如下所示：
- en: '[PRE13]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We obtained the index for the next page by tapping into the `params` parameter
    and getting its `key` field—this field will always give us the index of the next
    page that must be loaded. If this is the first time a page is requested, the `key`
    field will be `null`, so we default to the value of `1` in that case.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过访问`params`参数并获取其`key`字段来获取下一页的索引——这个字段将始终给我们提供必须加载的下一页的索引。如果是第一次请求页面，`key`字段将是`null`，所以在这种情况下我们默认为`1`。
- en: 'Since we now know the index of the next page of repositories that we need,
    let''s query our REST API for that specific page by calling the `getRepositories()`
    method of `restInterface` and by passing in the newly defined `nextPage` parameter,
    as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在知道了我们需要加载的下一个仓库页面的索引，让我们通过调用`restInterface`的`getRepositories()`方法并传递新定义的`nextPage`参数来查询我们的REST
    API以获取该特定页面，如下所示：
- en: '[PRE14]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this step, we also store a list of `Repository` objects from within the response
    inside the `reposResponse` variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们还将在`reposResponse`变量中存储响应内的`Repository`对象列表。
- en: 'Next up, we must return a `LoadResult` object, as the request to our REST API
    is successful at this point. Let''s instantiate and return a `LoadResult.Page`
    object, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须返回一个`LoadResult`对象，因为此时我们的REST API请求是成功的。让我们实例化并返回一个`LoadResult.Page`对象，如下所示：
- en: '[PRE15]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We had to pass the following to the `LoadResult.Page()` constructor:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须传递以下内容到`LoadResult.Page()`构造函数：
- en: A list of `Repository` objects from the newly requested page to the `data` parameter.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从新请求的页面到`data`参数的`Repository`对象列表。
- en: The previous key of the newly requested page to the `prevKey` parameter. This
    key is important if, for some reason, the previous pages are invalidated and must
    be reloaded when the user starts scrolling up. Most of the time, we would deduct
    `1` from the `nextPage` value, yet we also made sure that if we had just requested
    the first page (the value of `nextPage` would be `1`), we would pass `null` to
    the `prevKey` parameter.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新请求页面的上一个键到`prevKey`参数。这个键很重要，如果由于某种原因，之前的页面被无效化，并且当用户开始向上滚动时必须重新加载，这个键就很重要。大多数情况下，我们会从`nextPage`值中减去`1`，但我们还确保，如果我们刚刚请求了第一页（`nextPage`的值将是`1`），我们将向`prevKey`参数传递`null`。
- en: The next key after `nextPage` to the `nextKey` parameter. This is a simple one
    as we have just added `1` to the value of `nextPage`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `nextPage` 之后的关键参数是 `nextKey`。这是一个简单的参数，因为我们刚刚将 `nextPage` 的值增加了 `1`。
- en: Now that we finished the `PagingSource` implementation, it's time to build the
    `Pager` component and get a stream of paginated data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了 `PagingSource` 的实现，是时候构建 `Pager` 组件并获取分页数据流了。
- en: 'Inside `RepositoriesViewModel`, replace the `RepositoriesApiService` dependency
    with the newly created `RepositoriesPagingSource` class, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RepositoriesViewModel` 内部，将 `RepositoriesApiService` 依赖项替换为新创建的 `RepositoriesPagingSource`
    类，如下所示：
- en: '[PRE16]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At the same time, we make sure to remove any existing implementation inside
    the `RepositoriesViewModel`, leaving it blank for the upcoming step.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们确保从 `RepositoriesViewModel` 中移除任何现有的实现，为即将进行的步骤留出空白。
- en: 'Still inside the `RepositoriesViewModel`, define a `repositories` variable
    that will hold our flow of paginated data, like this:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `RepositoriesViewModel` 中，定义一个 `repositories` 变量，它将保存我们的分页数据流，如下所示：
- en: '[PRE17]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The paginated content with `Repository` items is held within a `PagingData`
    container, making our stream of data to be of type `Flow<PagingData<Repository>>`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `Repository` 项的分页内容位于 `PagingData` 容器中，使我们的数据流类型为 `Flow<PagingData<Repository>>`。
- en: 'Now, we must instantiate our `repositories` variable. However, creating a flow
    is not trivial, especially when the data (the list of repositories) must grow
    as the user scrolls. The Paging library has us covered, as it will hide this complexity
    from us and will provide us with a flow that emits data as we would expect it
    to: when the user scrolls to the end of the list, new requests are made to the
    backend, and new `Repository` objects are appended to the list.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须实例化我们的 `repositories` 变量。然而，创建一个流并非易事，尤其是在数据（仓库列表）必须随着用户滚动而增长的情况下。Paging
    库为我们解决了这个问题，因为它将隐藏这种复杂性，并为我们提供一个按预期发出数据的流：当用户滚动到列表的末尾时，会向后端发出新的请求，并将新的 `Repository`
    对象附加到列表中。
- en: 'As the first step to obtaining our flow of paginated data, we must create an
    instance of the `Pager` class based on the previously created `PagingSource` object,
    like so:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取分页数据流的第一个步骤是创建一个基于之前创建的 `PagingSource` 对象的 `Pager` 类实例，如下所示：
- en: '[PRE18]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To create an instance of a `Pager`, we called the `Pager()` constructor and
    passed the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 `Pager` 实例，我们调用了 `Pager()` 构造函数并传递了以下内容：
- en: A `PagingConfig` object with a `pageSize` value of `20` (to match this value
    with the number of repositories we're requesting from the backend) to the `config`
    parameter.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `PagingConfig` 对象，其 `pageSize` 值为 `20`（将此值与从后端请求的仓库数量相匹配）传递给 `config` 参数。
- en: The `reposPagingSource` instance of type `RepositoriesPagingSource` to the `pagingSourceFactory`
    parameter. By doing so, the Paging library will know which `PagingSource` object
    to query for new pages.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `RepositoriesPagingSource` 类型的 `reposPagingSource` 实例传递给 `pagingSourceFactory`
    参数。这样做，Paging 库将知道查询新页面的 `PagingSource` 对象。
- en: 'Finally, to obtain a flow with data from the newly created `Pager` instance,
    we must simply access the `flow` field exposed by the resulted `Pager` instance,
    as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了获取来自新创建的 `Pager` 实例的数据流，我们只需访问由结果 `Pager` 实例公开的 `flow` 字段，如下所示：
- en: '[PRE19]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On the resulting flow, we also called the `cachedIn()` extension function that
    makes sure that the stream of data is kept alive as long as the passed `CoroutineScope`
    object is alive and then returns back the same flow it's called upon. Since we
    wanted the paginated content to be cached as long as the `ViewModel` is kept in
    memory, we passed the `viewModelScope` scope to this extension function. This
    makes sure that the flow is also preserved upon events where the `ViewModel` survives—for
    example, configuration change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果流上，我们还调用了 `cachedIn()` 扩展函数，确保只要传递的 `CoroutineScope` 对象保持活动状态，数据流就会保持活跃，然后返回它被调用的同一个流。由于我们希望分页内容在
    `ViewModel` 保持内存中的情况下被缓存，我们将 `viewModelScope` 范围传递给这个扩展函数。这确保了在 `ViewModel` 生存的事件中（例如，配置更改）流也会被保留。
- en: 'Now, we must obtain the flow in our Compose-based UI, so inside the `RepositoriesAppTheme()`
    composable call from within `MainActivity`, replace the `repos` variable with
    the `reposFlow` variable that holds a reference to the `repositories` flow variable
    of the `ViewModel`, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在我们的基于 Compose 的 UI 中获取流，因此，在 `MainActivity` 内部调用 `RepositoriesAppTheme()`
    可组合函数时，将 `repos` 变量替换为包含对 `ViewModel` 的 `repositories` 流变量的引用的 `reposFlow` 变量，如下所示：
- en: '[PRE20]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next up, we must use a special collection function (similar to the `collect()`
    function used in the previous section) that can consume and remember the paginated
    data from within `reposFlow` in the context of Compose.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用一个特殊的收集函数（类似于前一个部分中使用的 `collect()` 函数），它可以消费并记住在 Compose 的上下文中 `reposFlow`
    内部的分页数据。
- en: 'Declare a new variable called `lazyRepoItems` and instantiate it with the result
    returned from the `collectAsLazyPagingItems()` call on `reposFlow`, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个新的变量 `lazyRepoItems` 并使用对 `reposFlow` 的 `collectAsLazyPagingItems()` 调用的结果来实例化它，如下所示：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `collectAsLazyPagingItems()` function returned a `LazyPagingItems` object
    filled with `Repository` objects. The `LazyPagingItems` object is responsible
    for accessing `Repository` objects from the flow so that they can be consumed
    by our `LazyColumn` component later on—that's why, in the end, we passed `lazyRepoItems`
    to the `RepositoriesScreen()` composable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectAsLazyPagingItems()` 函数返回了一个填充有 `Repository` 对象的 `LazyPagingItems`
    对象。`LazyPagingItems` 对象负责从流中访问 `Repository` 对象，以便它们可以在稍后由我们的 `LazyColumn` 组件消费——这就是为什么最终我们将
    `lazyRepoItems` 传递给了 `RepositoriesScreen()` 可组合函数。'
- en: 'Moving to the last piece of the puzzle, the `RepositoriesScreen()` composable,
    make sure that it accepts the `LazyPagingItems` object returned by our flow by
    adding the `repos` parameter, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到拼图的最后一部分，`RepositoriesScreen()` 可组合函数，确保它通过添加 `repos` 参数接受我们的流程返回的 `LazyPagingItems`
    对象，如下所示：
- en: '[PRE22]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Also, while you're at this step, remove all the code inside the DSL `content`
    block exposed by `LazyColumn` as we will re-add it in a different structure in
    the next step.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在你进行此步骤的同时，移除由 `LazyColumn` 暴露的 DSL `content` 块内的所有代码，因为我们将在下一个步骤中以不同的结构重新添加它。
- en: 'Finally, still inside `RepositoriesScreen()`, pass the `repos` input parameter
    to another `itemsIndexed()` DSL function that accepts `LazyPagingItems`, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，仍然在 `RepositoriesScreen()` 内部，将 `repos` 输入参数传递给另一个接受 `LazyPagingItems` 的
    `itemsIndexed()` DSL 函数，如下所示：
- en: '[PRE23]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `LazyColumn` API knows how to consume paginated data and how to report back
    to our instances of `Pager` and `PagingSource` when a new page should be loaded,
    and that's why we made use of an overloaded variant of the `itemsIndexed()` DSL
    function that accepts `LazyPagingItems` as content.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyColumn` API 知道如何消费分页数据，并且当需要加载新页面时，如何向我们的 `Pager` 和 `PagingSource` 实例报告，这就是为什么我们使用了接受
    `LazyPagingItems` 作为内容的 `itemsIndexed()` DSL 函数的重载版本。'
- en: Also, because the returned `repo` value can be `null`, we added a null check
    before passing it to our `RepositoryItem()` composable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为返回的 `repo` 值可以是 `null`，我们在将其传递给我们的 `RepositoryItem()` 可组合函数之前添加了一个空值检查。
- en: Finally, build and run the application. Try to scroll to the bottom of the repositories
    list. This should trigger a request to get new items, and therefore you should
    be able to scroll and browse through an *endless* list of repositories.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建并运行应用程序。尝试滚动到仓库列表的底部。这应该会触发获取新项目的请求，因此你应该能够滚动并浏览一个 *无限* 的仓库列表。
- en: Note
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If you make too many requests to the GitHub Search API, you might be temporarily
    limited, and the application will stop loading new items and throw an error. To
    make our application express such an event, we will learn how to display error
    states, up next.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你向 GitHub 搜索 API 发送太多请求，你可能会暂时受限，应用程序将停止加载新项目并抛出错误。为了使我们的应用程序能够表达这种事件，我们将学习如何显示错误状态，接下来。
- en: Next up, let's improve the UI and UX of our application by adding loading and
    error states in the context of an infinite list.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过在无限列表的上下文中添加加载和错误状态来改进我们应用程序的 UI 和 UX。
- en: Implementing loading and error states plus retry functionality
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现加载和错误状态以及重试功能
- en: While our application now features an infinite list that the user can scroll
    through, it doesn't express any sort of loading or error state. The good news
    is that the Paging library tells us exactly when loading states or error states
    must be shown.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序现在具有用户可以滚动的无限列表，但它不表达任何加载或错误状态。好消息是，Paging 库告诉我们何时必须显示加载状态或错误状态。
- en: However, before jumping into the actual implementation, we should first cover
    the possible loading states and error states that emerge from interacting with
    an app that features pagination. Luckily, all these cases are already covered
    by the Paging API.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在深入实际实现之前，我们应该首先了解与具有分页功能的应用程序交互时可能出现的可能的加载状态和错误状态。幸运的是，所有这些情况都已经由 Paging
    API 覆盖。
- en: 'While the `LazyPagingItems` API provides us with several `LoadState` objects,
    the most common ones—and the ones we will need in this section—are the `refresh`
    and `append` types, as explained in more detail here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `LazyPagingItems` API 为我们提供了多个 `LoadState` 对象，但最常见的是——我们将在本节中需要的是 `refresh`
    和 `append` 类型，如以下内容更详细地解释：
- en: 'The `LoadState.refresh` instance of `LoadState` represents initial states that
    occur after the first request of paginated items or after a refresh event. The
    two values that we''re interested in for this object are these:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadState.refresh` 实例的 `LoadState` 代表在分页项的第一个请求或刷新事件之后发生的初始状态。我们对此对象感兴趣的两个值如下：'
- en: '`LoadState.Loading` — This state means that the app is expressing the initial
    loading status. When this status arrives for the first time after an app launch,
    no content would be painted on the screen at that point.'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadState.Loading` — 此状态表示应用表示初始加载状态。当此状态在应用启动后第一次到达时，屏幕上不会绘制任何内容。'
- en: '`LoadState.Error` — This state means that the app is expressing the initial
    error status. Just as with the previous state, if this status arrives for the
    first time after an app launch, no content is present.'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadState.Error` — 此状态表示应用表示初始错误状态。就像之前的状态一样，如果此状态在应用启动后第一次到达，则没有内容。'
- en: 'The `LoadState.append` instance of `LoadState` represents states that occur
    at the end of a subsequent request of paginated items. The two values we''re interested
    in for this object are similar to type `refresh` but have different significance,
    as outlined here:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadState.append` 实例的 `LoadState` 代表在后续分页项请求结束时发生的状态。我们对此对象感兴趣的两个值与 `refresh`
    类型相似，但具有不同的意义，如下所述：'
- en: '`LoadState.Loading` — This state means that the app is in a loading status
    at the end of a subsequent request for a page with repositories; in other words,
    the app has requested another page with repositories and it''s waiting for the
    results to arrive. At this point, there should be content rendered from the previous
    pages.'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadState.Loading` — 此状态表示在后续请求包含存储库的页面结束时，应用处于加载状态；换句话说，应用已请求另一个包含存储库的页面，并且正在等待结果到达。此时，应该渲染来自先前页面的内容。'
- en: '`LoadState.Error` — This state means that the app reached an error status after
    a subsequent request for a page with repositories. In other words, the app has
    requested another page with repositories but the request has failed. Just as with
    the previous state, there should be content rendered from the previous pages.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadState.Error` — 此状态表示在请求包含存储库的页面后，应用达到错误状态。换句话说，应用已请求另一个包含存储库的页面，但请求失败。就像之前的状态一样，应该渲染来自先前页面的内容。'
- en: 'Let''s listen for these states in our app and start with type `LoadState.refresh`,
    as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用中监听这些状态，并从 `LoadState.refresh` 类型开始，如下所示：
- en: 'Inside the `RepositoriesScreen()` composable, below the `itemsIndexed()` call,
    store the `refresh` load state instance inside the `refreshLoadstate` variable,
    as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RepositoriesScreen()` 可组合内部，在 `itemsIndexed()` 调用下方，将 `refresh` 加载状态实例存储在
    `refreshLoadstate` 变量中，如下所示：
- en: '[PRE24]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Every time this refreshes, `LoadState` will change; the values within `refreshLoadState`
    will be the latest ones and will correspond to the page where they occurred.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每次刷新时，`LoadState` 将会改变；`refreshLoadState` 中的值将是最新值，并且与它们发生所在的页面相对应。
- en: 'Next up, create a `when` expression and verify whether `refreshLoadState` is
    of type `LoadState.Loading`, and if it is, inside a new `item()` call, pass a
    `LoadingItem()` composable that we will define in a bit. The code is illustrated
    in the following snippet:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `when` 表达式并验证 `refreshLoadState` 是否为 `LoadState.Loading` 类型，如果是，则在新的
    `item()` 调用中传递我们将稍后定义的 `LoadingItem()` 可组合。代码如下所示：
- en: '[PRE25]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since we are adding another `item()` call below the `itemsIndexed()` DSL call,
    we are actually adding another composable below the list of composables from the
    `itemsIndexed()` call. However, since `refreshLoadState` can be of type `LoadState.Loading`
    on the first request for a page of items, this means that the screen is empty
    at this time, so we also passed a `fillParentMaxSize` modifier to the `LoadingItem()`
    composable, thus making sure that this composable will take up the entire size
    of the screen.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `itemsIndexed()` DSL 调用下方添加了另一个 `item()` 调用，因此我们实际上在 `itemsIndexed()`
    调用的可组合列表下方添加了另一个可组合。然而，由于 `refreshLoadState` 在对项目页面进行第一次请求时可以是 `LoadState.Loading`
    类型，这意味着此时屏幕是空的，因此我们还向 `LoadingItem()` 可组合传递了 `fillParentMaxSize` 修饰符，从而确保此可组合将占据整个屏幕的大小。
- en: 'Next up, at the bottom of the `RepositoriesScreen.kt` file, let''s quickly
    define a `LoadingItem()` function that will feature a `CirculatorProgressIndicator()`
    composable, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`RepositoriesScreen.kt`文件的底部，让我们快速定义一个`LoadingItem()`函数，该函数将包含一个`CirculatorProgressIndicator()`可组合项，如下所示：
- en: '[PRE26]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, run the app, and notice how the progress indicator animation is running
    before the first page of repositories is loaded and how it is occupying the entire
    screen, as illustrated in the following screenshot:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用，注意在加载第一个仓库页面之前进度指示器动画是如何运行的，以及它是如何占据整个屏幕的，如下面的截图所示：
- en: '![Figure 11.6 – Adding a loading animation for the first request of paginated
    content'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 – 为分页内容的第一次请求添加加载动画'
- en: '](img/B17788_11_06.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_11_06.jpg)'
- en: Figure 11.6 – Adding a loading animation for the first request of paginated
    content
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 为分页内容的第一次请求添加加载动画
- en: 'Now, let''s cover the case where `refreshLoadState` is of type `Loadstate.Error`.
    Back inside the `LazyColumn` component of the `RepositoriesScreen()` composable,
    below the first `when` branch, add another check for the state to be `LoadState.Loading`—and
    if that''s the case, add an `ErrorItem()` composable that we will define in a
    bit. The code that you must add is illustrated in the following snippet:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们讨论`refreshLoadState`为`Loadstate.Error`类型的情况。回到`RepositoriesScreen()`可组合组件的`LazyColumn`组件内部，在第一个`when`分支下面，添加对状态为`LoadState.Loading`的另一个检查——如果是这种情况，添加一个我们稍后将定义的`ErrorItem()`可组合项。你必须添加的代码如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `ErrorItem()` composable requires an error message to display, so we stored
    the `Throwable` object from `LoadState` in the `error` variable and passed its
    `localizedMessage` value to the `message` parameter of the composable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorItem()`可组合项需要一个要显示的错误信息，因此我们将`LoadState`中的`Throwable`对象存储在`error`变量中，并将其`localizedMessage`值传递给可组合项的`message`参数。'
- en: Similar to the `LoadState.Loading` case from before, we are adding another `item()`
    call below the `itemsIndexed()` DSL call, so we are actually adding another composable
    below the list of composables from the `itemsIndexed()` call. Also, since `refreshLoadState`
    can be of type `LoadState.Error` on the request for the first page of items, this
    means that the screen is empty at this time, so we also passed a `fillParentMaxSize`
    modifier to the `ErrorItem()` composable, thus making sure that this composable
    is taking up the entire size of the screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`LoadState.Loading`情况类似，我们在`itemsIndexed()` DSL调用下面添加了另一个`item()`调用，因此我们实际上在`itemsIndexed()`调用下面的可组合项列表中添加了另一个可组合项。此外，由于`refreshLoadState`在请求第一页项目时可以是`LoadState.Error`类型，这意味着屏幕此时是空的，所以我们还向`ErrorItem()`可组合项传递了`fillParentMaxSize`修改器，从而确保这个可组合项占据了整个屏幕的大小。
- en: 'Next up, at the bottom of the `RepositoriesScreen.kt` file, let''s quickly
    define an `ErrorItem()` function that will feature a `Text()` composable displaying
    a red error message, as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`RepositoriesScreen.kt`文件的底部，让我们快速定义一个`ErrorItem()`函数，该函数将包含一个显示红色错误信息的`Text()`可组合项，如下所示：
- en: '[PRE28]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To mimic an error state, run the app on your emulator or physical device without
    an internet connection, and you should see a similar error occupying the entire
    screen, as illustrated in the following screenshot:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟错误状态，在没有网络连接的情况下在你的模拟器或物理设备上运行应用，你应该会看到一个类似的错误占据整个屏幕，如下面的截图所示：
- en: '![Figure 11.7 – Adding an error message for the first request of paginated
    content'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 – 为分页内容的第一次请求添加错误信息'
- en: '](img/B17788_11_07.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_11_07.jpg)'
- en: Figure 11.7 – Adding an error message for the first request of paginated content
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 为分页内容的第一次请求添加错误信息
- en: Note that the error message could be different depending on the circumstances
    of the error scenario that you have created.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，错误信息可能根据你创建的错误场景的不同而不同。
- en: Before moving on to the append type of `LoadState`, let's briefly cover the
    retry functionality that is provided out of the box by the Paging library. In
    other words, we want to give the user the option to retry obtaining the data in
    case something went wrong, such as with our forced-error case of disconnecting
    the test device from the internet.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到`LoadState`的附加类型之前，让我们简要介绍Paging库提供的开箱即用的重试功能。换句话说，我们希望给用户提供重试获取数据的选择，以防出现错误，比如在我们的强制错误案例中，将测试设备从互联网断开连接。
- en: Let's do that next.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来做这件事。
- en: 'Refactor the `ErrorItem()` composable to accept an `onClick()` function parameter
    that will be triggered by the `onClick` event caused by the press of a new retry
    `Button()` composable, as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构 `ErrorItem()` 可组合函数以接受一个 `onClick()` 函数参数，该参数将由按下新的重试 `Button()` 可组合函数引起的
    `onClick` 事件触发，如下所示：
- en: '[PRE29]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, inside the `Row()` composable that was displaying the error message, we
    have now added a `Button()` composable that when pressed, forwards the event to
    its caller.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在显示错误信息的 `Row()` 可组合函数内部，我们现在添加了一个 `Button()` 可组合函数，当按下时，将事件转发给其调用者。
- en: 'Then, back inside the `LazyColumn` component of `RepositoriesScreen()`, find
    the case where `LoadState` is of type `LoadState.Error` and implement the `onClick`
    parameter of the `ErrorItem()` composable that will now trigger a reload. The
    code is illustrated in the following snippet:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，回到 `RepositoriesScreen()` 的 `LazyColumn` 组件内部，找到 `LoadState` 为 `LoadState.Error`
    类型的案例，并实现 `ErrorItem()` 可组合函数的 `onClick` 参数，该参数将触发重试。代码如下所示：
- en: '[PRE30]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To trigger a reload, we called the `retry()` function provided by our `LazyPagingItems`
    instance. Behind the scenes, when the `retry()` function is called, the Paging
    library notifies `PagingSource` to request the problematic page again—in this
    case, for us, the first page with repositories.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发重新加载，我们调用了由我们的 `LazyPagingItems` 实例提供的 `retry()` 函数。在幕后，当调用 `retry()` 函数时，分页库会通知
    `PagingSource` 再次请求有问题的页面——在这种情况下，对我们来说，是包含仓库的第一页。
- en: 'Run the app on your emulator or physical device without an internet connection.
    You should now see the error state occupying the entire screen containing the
    error message, but also a retry button. The following screenshot provides a depiction
    of this:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有互联网连接的模拟器或物理设备上运行应用。您现在应该看到错误状态占据了整个屏幕，包含错误消息，还有一个重试按钮。以下截图提供了这一情况的描述：
- en: '![Figure 11.8 – Adding error message and retry button for the first request
    of paginated content'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.8 – 为分页内容的第一次请求添加错误信息和重试按钮'
- en: '](img/B17788_11_08.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.8 – 为分页内容的第一次请求添加错误信息和重试按钮](img/B17788_11_08.jpg)'
- en: Figure 11.8 – Adding error message and retry button for the first request of
    paginated content
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 为分页内容的第一次请求添加错误信息和重试按钮
- en: Don't press the retry button just yet.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要按重试按钮。
- en: Reconnect your device to the internet and then press the retry button. As an
    effect of this action, the content should now load successfully.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的设备重新连接到互联网，然后按下重试按钮。此操作的结果是内容现在应该成功加载。
- en: Now that we have covered the possible `LoadState` values for the `refresh` state,
    it's time to also cover the values for the `append` state. As we previously stated,
    type `LoadState.append` represents states that occur at the end of a subsequent
    request of paginated items.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 `refresh` 状态下可能的 `LoadState` 值，现在是时候也涵盖 `append` 状态下的值了。正如我们之前所述，类型
    `LoadState.append` 表示在后续分页项请求结束时发生的状态。
- en: The possible states we're interested in for this scenario are the `LoadState.Loading`
    state—meaning the user has scrolled toward the end of the list and the app is
    waiting for another page with repositories—and the `LoadState.Error` state—meaning
    that the user has scrolled toward the end of the list but the request to get a
    new page with repositories has failed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此场景，我们感兴趣的可能的 `LoadState` 状态是 `LoadState.Loading` 状态——意味着用户已经滚动到列表的末尾，应用正在等待另一个包含仓库的页面——以及
    `LoadState.Error` 状态——意味着用户已经滚动到列表的末尾，但获取新页面的请求失败了。
- en: 'Inside the block of code exposed by the `itemsIndexed()` call from within the
    `RepositoriesScreen()` composable, just as we did with the `refresh` state, store
    the `append` state inside a new `appendLoadState` variable, and then add two corresponding
    branches inside the `when` expression treating the `LoadState.Loading` and the
    `LoadState.Error` cases. The code is illustrated in the following snippet:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RepositoriesScreen()` 可组合函数中 `itemsIndexed()` 调用暴露的代码块内部，就像我们对 `refresh`
    状态所做的那样，将 `append` 状态存储在一个新的 `appendLoadState` 变量中，然后在 `when` 表达式中添加两个相应的分支来处理
    `LoadState.Loading` 和 `LoadState.Error` 的情况。代码如下所示：
- en: '[PRE31]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The way we treated the possible values of `appendLoadState` is very similar
    to how we treated the possible values of `refreshLoadState`. However, the notable
    difference is that `appendLoadState` state values occur when the app has already
    loaded some pages and the user has scrolled toward the end of our list, meaning
    that our app is either waiting for a new page with repositories or failed to load
    it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理 `appendLoadState` 的可能值的方式与我们处理 `refreshLoadState` 的可能值的方式非常相似。然而，一个明显的区别是
    `appendLoadState` 状态值发生在应用程序已经加载了一些页面，并且用户已经滚动到我们列表的末尾时，这意味着我们的应用程序要么正在等待带有存储库的新页面，要么未能加载它。
- en: That's why, in the `LoadState.Loading` case, we have passed the `Modifier.fillMaxWidth()`
    modifier to the `LoadingItem()` composable, therefore making sure that the loading
    indicator item appears at the bottom of the list as a list element. In other words,
    the loading element will take only the available width and it will not cover the
    entire screen like we did when `refreshLoadState` was of type `LoadState.Loading`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `LoadState.Loading` 的情况下，我们将 `Modifier.fillMaxWidth()` 修饰符传递给 `LoadingItem()`
    可组合项，从而确保加载指示器条目作为列表元素出现在列表底部。换句话说，加载元素将仅占用可用宽度，它不会像我们在 `refreshLoadState` 为 `LoadState.Loading`
    类型时那样覆盖整个屏幕。
- en: Similarly, for the `LoadState.Error` case, we passed the `Modifier.fillMaxWidth()`
    modifier to the `ErrorItem()` composable, therefore making sure that the error
    element appears as a list element and doesn't cover the entire screen like we
    did when `refreshLoadState` was of type `LoadState.Error`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于 `LoadState.Error` 的情况，我们将 `Modifier.fillMaxWidth()` 修饰符传递给 `ErrorItem()`
    可组合项，从而确保错误元素作为列表元素出现，并且不会像我们在 `refreshLoadState` 为 `LoadState.Error` 类型时那样覆盖整个屏幕。
- en: Let's see these two cases in practice, and let's start with the case when our
    `appendLoadState` instance has a value of `LoadState.Loading`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际看看这两个案例，让我们从我们的 `appendLoadState` 实例具有 `LoadState.Loading` 值的案例开始。
- en: 'First, run the app while your test device is connected to the internet. If
    you scroll down to the bottom of the list with repositories, you should see the
    loading indicator animation displayed until a new page with repositories is loaded,
    as illustrated in the following screenshot:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在测试设备连接到互联网的情况下运行应用程序。如果你滚动到存储库列表的底部，你应该会看到加载指示器动画显示，直到加载带有存储库的新页面，如图所示：
- en: '![Figure 11.9 – Adding a loading animation for a subsequent request of paginated
    content'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.9 – 为分页内容的后续请求添加加载动画'
- en: '](img/B17788_11_09.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_11_09.jpg)'
- en: Figure 11.9 – Adding a loading animation for a subsequent request of paginated
    content
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 为分页内容的后续请求添加加载动画
- en: Unlike the loading indicator that is shown initially, this indicator appears
    as an item within the list, thereby indicating that the app is waiting for a new
    page with repositories.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与最初显示的加载指示器不同，这个指示器作为列表中的一个条目出现，从而表明应用程序正在等待带有存储库的新页面。
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your network speed is very fast, you might miss the loading spinner as you
    are scrolling through new pages. To simulate a slower connection, you can change
    the network speed of your Android emulator by going into **AVD Manager**, pressing
    the **Edit** button of your emulator, and then selecting **Show Advanced Settings**.
    Inside this menu, you can slow down the internet speed of your emulator so that
    you can see the loading spinner.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网络速度非常快，当你滚动浏览新页面时，你可能会错过加载旋转器。为了模拟更慢的连接，你可以通过进入 **AVD 管理器**，按下你的模拟器的 **编辑**
    按钮，然后选择 **显示高级设置** 来更改你的 Android 模拟器的网络速度。在这个菜单中，你可以降低模拟器的互联网速度，以便你可以看到加载旋转器。
- en: Now, let's test the case when our `appendLoadState` instance is of type `LoadState.Error`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试当我们的 `appendLoadState` 实例类型为 `LoadState.Error` 的情况。
- en: First, run the app while your test device is connected to the internet.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在测试设备连接到互联网的情况下运行应用程序。
- en: 'Then, disconnect your test device from the internet and scroll down to the
    bottom of the list with repositories. Initially, you might see the loading indicator,
    yet after a short period of time, you should see the error element appearing at
    the bottom of the list, as illustrated in the following screenshot:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将你的测试设备从互联网断开连接，并滚动到存储库列表的底部。最初，你可能会看到加载指示器，但经过一段时间后，你应该会看到错误元素出现在列表底部，如图所示：
- en: '![Figure 11.10 – Adding error element for a subsequent request of paginated
    content'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.10 – 为分页内容的后续请求添加错误元素'
- en: '](img/B17788_11_10.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_11_10.jpg)'
- en: Figure 11.10 – Adding error element for a subsequent request of paginated content
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 为分页内容的后续请求添加错误元素
- en: Unlike the error message that is shown initially, this error element appears
    as an item in the list, thereby indicating that the app has failed to obtain the
    next page with repositories.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与最初显示的错误消息不同，这个错误元素作为列表中的一个条目出现，从而表明应用未能获取到包含仓库的下一页。
- en: Optionally, you can reconnect your device to the internet and press the retry
    button—the new page with repositories should now load, so you can continue browsing
    and scrolling for more items.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你可以重新连接你的设备到互联网并按下重试按钮——新的包含仓库的页面现在应该已经加载，这样你可以继续浏览和滚动查看更多项目。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first understood what pagination is and how pagination can
    be used to expose large datasets of items to users in a more efficient manner.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了什么是分页，以及如何使用分页以更有效的方式向用户展示大量项目数据集。
- en: Then, we got to meet the Repositories App, a simple Android project where a
    fixed amount of GitHub repositories was displayed. At that point, we took the
    decision that users should be able to browse through a huge number of repositories
    that the GitHub Search API is exposing, so the only solution for that was to integrate
    paging within our app.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遇到了 Repositories App，这是一个简单的 Android 项目，其中显示了固定数量的 GitHub 仓库。在那个时刻，我们决定用户应该能够浏览
    GitHub 搜索 API 揭示的大量仓库，因此唯一的解决方案就是在我们的应用中集成分页。
- en: However, we then realized that we needed to first understand the concept of
    data streams in the context of pagination, so we learned a few things about Kotlin
    Flow and how it can be a simple solution to consume paginated content.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们随后意识到，我们首先需要理解分页背景下数据流的概念，因此我们学习了一些关于 Kotlin Flow 的知识，以及它如何成为消费分页内容的一个简单解决方案。
- en: Then, we explored how the Jetpack Paging library is an elegant solution to adding
    pagination to our apps, culminating with the practical task of integrating paging
    in our Repositories App with the help of this library. Finally, we transformed
    our Repositories App into a modern application that creates the illusion of an
    infinite list of repositories, with initial and intermediary loading or error
    states, as well as retry functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了 Jetpack Paging 库是如何为我们的应用添加分页提供了一种优雅的解决方案，最终通过在 Repositories App 中使用这个库来集成分页的实际任务。最后，我们将
    Repositories App 转换成了一个现代应用，它创建了一个看似无限列表的仓库，包括初始加载、中间加载或错误状态，以及重试功能。
- en: In the next chapter, we will tackle yet another Jetpack subject—Lifecycle components!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个 Jetpack 主题——生命周期组件！
- en: Further reading
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, we briefly covered how you can integrate Jetpack Paging into
    an Android application. However, in the context of pagination and Jetpack Paging,
    there are a couple of more advanced topics that you might end up wondering about,
    as outlined here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了如何将 Jetpack Paging 集成到 Android 应用程序中。然而，在分页和 Jetpack Paging 的背景下，还有一些更高级的主题可能会让你感到好奇，如下所述：
- en: '`RemoteMediator` API of the Paging library. You can learn more about it from
    its official documentation at [https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator](https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paging 库的 `RemoteMediator` API。更多关于它的信息，请参阅其官方文档：[https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator](https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator)。
- en: '`PagingSource` component. Learn more about this from the official documentation
    at [https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys](https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PagingSource` 组件。更多关于这个组件的信息，请参阅官方文档：[https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys](https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys)。'
- en: As you know by now, testing is very important. In the context of paging, testing
    can get a little trickier. If you're interested in learning how to test your paging
    app, check out the official documentation at [https://developer.android.com/topic/libraries/architecture/paging/test](https://developer.android.com/topic/libraries/architecture/paging/test).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，测试非常重要。在分页的背景下，测试可能会变得有些复杂。如果你对学习如何测试你的分页应用感兴趣，请查看官方文档：[https://developer.android.com/topic/libraries/architecture/paging/test](https://developer.android.com/topic/libraries/architecture/paging/test)。
