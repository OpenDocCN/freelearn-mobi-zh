- en: 'Chapter 4: Laying Out UI Elements'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：布局 UI 元素
- en: In the previous chapters, you learned how to build simple UIs. Although they
    consisted of just a few UI elements, they needed to arrange their buttons, text
    fields, and sliders in a particular order, direction, or hierarchy. `Row()`) or
    vertically (`Column()`). This chapter explores layouts in greater detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何构建简单的 UI。尽管它们只包含几个 UI 元素，但它们需要按照特定的顺序、方向或层次结构排列它们的按钮、文本字段和滑块。本章将更详细地探讨布局。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using predefined layouts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义布局
- en: Understanding the single measure pass
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单测量传递
- en: Creating custom layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义布局
- en: We will start by exploring the predefined layouts of `Row()`, `Column()`, and
    `Box()`. You will learn how to combine them to create beautiful UIs. Next, I'll
    introduce you to `ConstraintLayout`. It places composables that are relative to
    others on the screen and uses attributes to flatten the UI element hierarchy.
    This is an alternative to nesting `Row()`, `Column()`, and `Box()`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索`Row()`、`Column()`和`Box()`的预定义布局。你将学习如何将它们组合起来创建美观的 UI。接下来，我将向你介绍`ConstraintLayout`。它将相对于屏幕上的其他可组合项放置可组合项，并使用属性来简化
    UI 元素层次结构。这是嵌套`Row()`、`Column()`和`Box()`的替代方案。
- en: The second main section will explain why the layout system in Jetpack Compose
    is more performant than the traditional View-based approach. We will once again
    go under the covers and look at some of the internals of the Compose runtime.
    This will prepare you for the final main section of this chapter, *Creating custom
    layouts*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要部分将解释为什么 Jetpack Compose 中的布局系统比传统的基于 View 的方法更高效。我们还将深入 Compose 运行时的内部结构。这将为你准备本章的最后一个主要部分，*创建自定义布局*。
- en: In this final section, you will learn how to create a custom layout and thus
    gain precise control over the rendering of its children. This is helpful if the
    predefined layouts do not offer enough flexibility for a particular use case.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，你将学习如何创建自定义布局，从而对子元素的渲染有精确的控制。如果预定义的布局对于特定的用例不够灵活，这很有帮助。
- en: Now, let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter showcases three sample apps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了三个示例应用程序：
- en: '`PredefinedLayoutsDemo`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PredefinedLayoutsDemo`'
- en: '`ConstraintLayoutDemo`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstraintLayoutDemo`'
- en: '`CustomLayoutDemo`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomLayoutDemo`'
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*, for information about how to install and set
    up Android Studio, and how to get it. If you want to try the `CheckboxWithLabel()`
    composable from the *Combining basic* *building blocks* section, you can use the
    *Sandbox* app project in the top-level directory of this book's GitHub repository
    at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose).
    Open its `SandboxActivity` and copy the composable functions from `code_snippets.txt`,
    which is located in the `/chapter_04` folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[*第一章*](B17505_01_ePub.xhtml#_idTextAnchor014)的*技术要求*部分，*构建您的第一个 Compose
    应用*，了解如何安装和设置 Android Studio，以及如何获取它。如果你想尝试*组合基本构建块*部分的`CheckboxWithLabel()`可组合项，你可以使用本书
    GitHub 仓库顶级目录中的*Sandbox*应用程序项目[https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose)。打开其`SandboxActivity`，并从位于`/chapter_04`文件夹中的`code_snippets.txt`文件中复制可组合函数。
- en: Using predefined layouts
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预定义布局
- en: 'When you create a UI, you must define where its elements appear and how big
    they are. Jetpack Compose provides a couple of basic layouts, which arrange their
    content along one main axis. There are three axes to consider:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 UI 时，你必须定义其元素出现的位置以及它们的大小。Jetpack Compose 提供了一些基本的布局，它们沿着一个主要轴排列其内容。有三种轴需要考虑：
- en: Horizontal
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平
- en: Vertical
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竖直
- en: Stacked
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆叠
- en: Each axis is represented by a layout. `Row()` arranges its content horizontally,
    while `Column()` does so vertically. `Box()` and `BoxWithConstraints()` stack
    their contents on top of each other. By combining these axis-orientated building
    blocks, you can create great-looking UIs easily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轴都由一个布局表示。`Row()`水平排列其内容，而`Column()`垂直排列。`Box()`和`BoxWithConstraints()`将它们的内容堆叠在一起。通过组合这些轴定向的构建块，你可以轻松地创建外观精美的
    UI。
- en: Combining basic building blocks
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合基本构建块
- en: 'The following `PredefinedLayoutsDemo` sample app shows three checkboxes that
    toggle a red, a green, and a blue rectangle, respectively. The boxes appear only
    if the corresponding checkbox is checked:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`PredefinedLayoutsDemo`示例应用显示了三个复选框，分别切换红色、绿色和蓝色矩形。只有当相应的复选框被选中时，这些盒子才会出现：
- en: '![Figure 4.1 – The sample PredefinedLayoutsDemo app'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 示例PredefinedLayoutsDemo应用](img/B17505_04_01.jpg)'
- en: '](img/B17505_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_04_01.jpg](img/B17505_04_01.jpg)'
- en: Figure 4.1 – The sample PredefinedLayoutsDemo app
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 示例PredefinedLayoutsDemo应用
- en: 'Let''s see how this is done. First, I will show you how to create a checkbox
    with an accompanying label:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的。首先，我将向你展示如何创建一个带有伴随标签的复选框：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Jetpack Compose has a built-in `Checkbox()`. It receives the current state (`checked`)
    and a lambda expression (`onCheckedChange`), which is invoked when the checkbox
    is clicked. At the time of writing, you cannot pass a label. However, we can achieve
    something similar by putting `Checkbox()` and `Text()` inside a `Row()`. We need
    to make the row clickable because we want to change the state of the checkbox
    when the text is clicked too. To make the checkbox with a label more visually
    appealing, we can center `Checkbox()` and `Text()` vertically inside the row by
    setting `verticalAlignment` to `Alignment.CenterVertically`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose内置了一个`Checkbox()`。它接收当前状态（`checked`）和一个lambda表达式（`onCheckedChange`），当复选框被点击时，该表达式会被调用。在撰写本文时，你不能传递一个标签。然而，我们可以通过在`Row()`中放置`Checkbox()`和`Text()`来实现类似的效果。我们需要使行可点击，因为我们希望当文本被点击时也改变复选框的状态。为了使带有标签的复选框更具视觉吸引力，我们可以通过将`verticalAlignment`设置为`Alignment.CenterVertically`来在行内垂直居中`Checkbox()`和`Text()`。
- en: '`CheckboxWithLabel()` receives a `MutableState<Boolean>` because other composables
    need to be recomposed when it changes the value inside `onCheckedChange`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckboxWithLabel()`接收一个`MutableState<Boolean>`，因为当`onCheckedChange`内部值改变时，其他可组合元素需要重新组合。'
- en: 'Next, let''s see where the state is created:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看状态是如何创建的：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`PredefinedLayoutsDemo()` arranges its content vertically by putting it inside
    a `Column()`. The column fills all the available space (`fillMaxSize()`) and has
    a padding of 16 density-independent pixels on all four sides (`padding(16.dp)`).
    The three states (`red`, `green`, and `blue`) are passed to `CheckboxWithLabel()`.
    Here''s what these invocations look like:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`PredefinedLayoutsDemo()`通过将其内容放入`Column()`中来垂直排列其内容。该列填充所有可用空间（`fillMaxSize()`），并在所有四边都有16密度无关像素的填充（`padding(16.dp)`）。三个状态（`red`、`green`和`blue`）被传递给`CheckboxWithLabel()`。下面是这些调用看起来像什么：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: They are almost the same, differing only in the state (`red`, `green`, and `blue`)
    and the label string (`R.string.red`, `R.string.green`, or `R.string.blue`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它们几乎相同，只是在状态（`red`、`green`、`blue`）和标签字符串（`R.string.red`、`R.string.green`或`R.string.blue`）上有所不同。
- en: 'Now, let''s find out how the stacked colored boxes are created:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何创建堆叠的彩色盒子：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The three colored boxes are put inside another `Box()`, which fills all the
    available space. To create a gap between it and the last checkbox, I specified
    a top padding of 16 density-independent pixels.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 三个彩色盒子被放入另一个`Box()`中，该盒子填充所有可用空间。为了在它和最后一个复选框之间创建一个间隙，我指定了16密度无关像素的顶部填充。
- en: 'A colored box is only added if its corresponding state is `true` (for example,
    `if (red.value) { …)`. All colored boxes fill the available space. As they will
    be stacked on top of each other, only the last (top) one will be visible. To fix
    this, the green and blue boxes receive paddings that differ in size: the padding
    for the blue box (the last one) is 64 density-independent pixels, so in the areas
    of the padding, the green box becomes visible. The green box has a padding of
    32 density-independent pixels, so in this area, the first box (the red one) can
    be seen.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当相应的状态为`true`时，才会添加彩色盒子（例如，`if (red.value) { …)`）。所有彩色盒子都填充可用空间。由于它们将堆叠在一起，只有最后一个（顶部的）一个是可见的。为了解决这个问题，绿色和蓝色盒子接收不同大小的填充：蓝色盒子（最后一个）的填充为64密度无关像素，因此在填充区域，绿色盒子变得可见。绿色盒子有一个32密度无关像素的填充，因此在这一区域，第一个盒子（红色）可以被看到。
- en: As you have seen, by combining basic layouts such as `Box()` and `Row()`, you
    can easily create great-looking UIs. In the next section, I will introduce you
    to an alternative approach where we will define a UI based on constraints.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，通过组合基本的布局如`Box()`和`Row()`，你可以轻松地创建出看起来很棒的UI。在下一节中，我将向你介绍一种替代方法，我们将基于约束来定义UI。
- en: Creating layouts based on constraints
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于约束创建布局
- en: Defining UIs based on constraints has been the most recent preferred approach
    in Android's traditional `View` world because older layouts such as `RelativeLayout`
    or `LinearLayout` could impact performance when they're used in large, multiply-nested
    layouts. `ConstraintLayout` avoids this by flattening the `View` hierarchy. As
    you will see in the *Understanding the single measure pass* section, this is no
    issue for Jetpack Compose.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基于约束定义UIs是Android传统`View`世界中最新的首选方法，因为像`RelativeLayout`或`LinearLayout`这样的旧布局在用于大型、多层嵌套布局时可能会影响性能。`ConstraintLayout`通过简化`View`层次结构来避免这个问题。正如您将在*理解单测量传递*部分看到的那样，这对Jetpack
    Compose来说不是问题。
- en: However, for more complex layouts in a Compose app, you may still want to limit
    the nesting of `Box()`, `Row()`, and `Column()` to make your code simpler and
    clearer. This is where `ConstraintLayout()` can help.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于Compose应用程序中更复杂的布局，您可能仍然想要限制`Box()`、`Row()`和`Column()`的嵌套，以使您的代码更简单、更清晰。这就是`ConstraintLayout()`可以提供帮助的地方。
- en: 'The `ConstraintLayoutDemo` sample app is a reimplementation of `PredefinedLayoutsDemo`
    based on `ConstraintLayout()`. By comparing the two versions, you get a thorough
    understanding of how this composable function works. To use `ConstraintLayout()`
    in your app, you need to add a dependency to your module-level `build.gradle`
    file. Please note that the version number shown here is just an example. You can
    find the latest version at [https://developer.android.com/jetpack/androidx/versions/all-channel](https://developer.android.com/jetpack/androidx/versions/all-channel):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstraintLayoutDemo`示例应用程序是基于`ConstraintLayout()`的`PredefinedLayoutsDemo`的重实现。通过比较这两个版本，您可以全面了解这个可组合函数是如何工作的。要在您的应用程序中使用`ConstraintLayout()`，您需要在模块级别的`build.gradle`文件中添加一个依赖项。请注意，这里显示的版本号只是一个示例。您可以在[https://developer.android.com/jetpack/androidx/versions/all-channel](https://developer.android.com/jetpack/androidx/versions/all-channel)找到最新版本：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, how do we define a layout based on constraints? Let''s find out by examining
    the reimplementation of `CheckboxWithLabel()`. It places text next to a checkbox:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何定义基于约束的布局呢？让我们通过检查`CheckboxWithLabel()`的重实现来找出答案。它将文本放置在复选框旁边：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`ConstraintLayout()` uses a `ConstraintLayout()` must have a reference associated
    with it, which is created using `createRefs()`. Constraints are provided using
    the `constrainAs()` modifier. Its lambda expression receives a `ConstrainScope`.
    It includes properties such as `start`, `top`, and `bottom`. These are called
    `linkTo()`) to the location of another composable.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstraintLayout()`使用`ConstraintLayout()`必须与一个引用相关联，该引用是通过`createRefs()`创建的。约束是通过`constrainAs()`修饰符提供的。它的lambda表达式接收一个`ConstrainScope`。它包括`start`、`top`和`bottom`等属性。这些被称为`linkTo()`将它们链接到另一个可组合的位置。'
- en: 'Let''s look at `Text()`. Its `constrainAs()` contains `bottom.linkTo(checkbox.bottom)`.
    This means that the bottom of the text is constrained to the bottom of the checkbox.
    As the top of the text is linked to the top of the checkbox, the height of the
    text is equal to the height of the checkbox. The following line means that the
    start of the text is constrained by the end of the checkbox, with an additional
    margin of 8 density-independent pixels:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Text()`。它的`constrainAs()`包含`bottom.linkTo(checkbox.bottom)`。这意味着文本的底部被约束到复选框的底部。由于文本的顶部与复选框的顶部相关联，因此文本的高度等于复选框的高度。下一行意味着文本的起始端被复选框的末端约束，并额外增加了8个密度无关像素的边距：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, in the direction of reading, the text comes after the checkbox. Next, let''s
    look at `ConstraintLayoutDemo()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在阅读方向上，文本位于复选框之后。接下来，让我们看看`ConstraintLayoutDemo()`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have created the references that areneeded to define constraints using
    `createRefs()`, we add our first `CheckboxWithLabel()`. Its `top` is linked to
    (constrained by) the `top` of `parent`, which is `ConstraintLayout()`. So, the
    first checkbox with a label is the topmost one. Here''s how the second one, which
    toggles the green box, is invoked:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用`createRefs()`创建了定义约束所需的引用，我们就添加我们的第一个`CheckboxWithLabel()`。它的`top`与`parent`的`top`（即`ConstraintLayout()`）相关联。因此，带标签的第一个复选框是最上面的一个。下面是如何调用第二个复选框（它切换绿色框）的示例：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Its top is constrained by the bottom of the first checkbox with a label (which
    toggles the red box). Finally, here''s how we need to constrain the third `CheckboxWithLabel()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它的`top`被第一个带标签的复选框的`bottom`约束。最后，这是我们需要约束第三个`CheckboxWithLabel()`的方式：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To conclude this section, let me show you how to define the colored boxes.
    Here''s the red one:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节，让我向您展示如何定义彩色框。这是红色框的示例：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both `start` and `end` are linked to the corresponding anchors of `parent` (which
    is `ConstraintLayout()`). `top` is constrained by `bottom` of the last checkbox,
    so the red box appears below it. `bottom` of the red box is constrained by `bottom`
    of `parent`. Please note that currently, we must set `width` and `height` to the
    value that we obtained from `Dimension.fillToConstraints`. Otherwise, the box
    won't have the correct size.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`end`都与`parent`（即`ConstraintLayout()`）的相应锚点相关联。`top`由最后一个复选框的`bottom`约束，所以红色框出现在其下方。红色框的`bottom`由`parent`的`bottom`约束。请注意，目前，我们必须将`width`和`height`设置为从`Dimension.fillToConstraints`获得的值。否则，框将不会有正确的大小。'
- en: 'Next, let''s look at the constraints of the green box:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看绿色框的约束条件：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code is practically the same. One difference is that all the sides receive
    a `margin` of 32 density-independent pixels. This is necessary because we want
    the red box, which is below the green one, to be visible at the locations of the
    margin. As the red box already has a `top` margin of 16, we must add this value
    to the `top` margin. You may be wondering why I am not linking to `boxRed` instead.
    That is because the red box will not be present if its corresponding checkbox
    is not checked. In this case, the anchor would not be there.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上是一样的。一个区别是所有边都接收一个32密度无关像素的`margin`。这是必要的，因为我们希望红色框（位于绿色框下方）在边框的位置可见。由于红色框已经有一个16的`top`边距，我们必须将这个值加到`top`边距上。你可能想知道为什么我没有链接到`boxRed`。那是因为如果对应的复选框没有被勾选，红色框将不会出现。在这种情况下，锚点将不会存在。
- en: 'Here''s what the constraints for the blue box will look like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是蓝色框的约束条件将呈现的样子：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only thing I needed to change is the margin on all four sides because otherwise,
    the box below (the green one) would not be visible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要改变的是所有四边的边距，否则下面的框（绿色框）将不可见。
- en: 'In a nutshell, this is how `ConstrainLayout()` works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这就是`ConstrainLayout()`的工作方式：
- en: You constrain a composable by linking its anchors to other ones
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你通过将可组合元素的锚点链接到其他元素来约束它
- en: The linking is based on references. To setup these references, you must call
    `createRefs()`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接基于引用。为了设置这些引用，你必须调用`createRefs()`。
- en: 'The main advantage of combining `Box()`, `Row()`, and `Column()` is that you
    flatten your UI element hierarchy. Think of it like this: in `PredefinedLayoutsDemo`,
    I needed to stack the colored boxes in a parent `Box()`. In `ConstrainLayoutDemo`,
    the boxes and the three `CheckboxWithLabel()` share the same parent (a `ConstrainLayout()`).
    This reduces the number of composables and makes the code cleaner.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`Box()`、`Row()`和`Column()`的主要优势是你可以简化你的UI元素层次结构。可以这样想：在`PredefinedLayoutsDemo`中，我需要在父`Box()`中堆叠彩色框。在`ConstrainLayoutDemo`中，框和三个`CheckboxWithLabel()`共享同一个父元素（一个`ConstrainLayout()`）。这减少了可组合元素的数量，并使代码更简洁。
- en: In the next section, we will once again peek inside the internals of Jetpack
    Compose. We will learn how the layout process works and why it is more efficient
    than the traditional View-based approach.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将再次深入了解Jetpack Compose的内部结构。我们将学习布局过程是如何工作的，以及为什么它比传统的基于View的方法更高效。
- en: Understanding the single measure pass
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单测量过程
- en: 'Laying out a UI element hierarchy means determining the sizes of all the elements
    and positioning them on the screen based on the layout strategy of their parent.
    At first, getting the size of, say, some text doesn''t sound too complicated.
    After all, isn''t it determined by the font and the text to be output? Here''s
    an example, with two pieces of text laid out in a `Column()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 布局UI元素层次结构意味着确定所有元素的大小，并根据其父元素的布局策略在屏幕上定位它们。起初，获取例如一些文本的大小听起来并不太复杂。毕竟，它不是由字体和要输出的文本决定的吗？以下是一个例子，其中两行文本在一个`Column()`中布局：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you deploy the preview, you will notice that, in portrait mode, the first
    text requires more space vertically than in landscape mode. The second text always
    fits into one line. The size that a composable takes on-screen partially depends
    on the conditions that have been imposed from *outside*. Here, the maximum width
    of the column (the parent) influences the height of the first piece of text. Such
    conditions are called `ConstraintLayout()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你部署了预览，你会注意到，在纵向模式下，第一行文本在垂直方向上所需的空格比在横向模式下多。第二行文本总是适应一行。一个可组合元素在屏幕上占据的大小部分取决于从*外部*强加的条件。在这里，列的最大宽度（父元素）影响了第一行文本的高度。这样的条件被称为`ConstraintLayout()`。
- en: 'Once a layout has obtained and measured the size of its content, the layout
    will position its children (the content). Let''s see how this works by looking
    at the source code of `Column()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦布局获取并测量了其内容的尺寸，布局将定位其子元素（内容）。让我们通过查看 `Column()` 的源代码来了解这是如何工作的：
- en: '![Figure 4.2 – Source code of Column()'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – `Column()` 的源代码](img/B17505_04_02.jpg)'
- en: '](img/B17505_04_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_04_02.jpg](img/B17505_04_02.jpg)'
- en: Figure 4.2 – Source code of Column()
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – `Column()` 的源代码
- en: The composable is very short. Besides assigning a value to `measurePolicy`,
    it only invokes `Layout()`, passing `content`, `measurePolicy`, and `modifier`.
    We briefly looked at the source code of `Layout()` in the *Emitting UI elements*
    section of [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054), *Exploring the
    Key Principles of Compose*, to understand what it means to emit UI elements. Now,
    we'll focus on the layout process. The `measurePolicy` variable references an
    implementation of the `MeasurePolicy` interface. In this case, it's the result
    of a call to `columnMeasurePolicy()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合项非常短。除了为 `measurePolicy` 分配值外，它还只调用了 `Layout()`，传递了 `content`、`measurePolicy`
    和 `modifier`。我们在 [*第 3 章*](B17505_03_ePub.xhtml#_idTextAnchor054) 的 *“发射UI元素”*
    部分简要地查看过 `Layout()` 的源代码，以了解发射UI元素的含义。现在，我们将专注于布局过程。`measurePolicy` 变量引用了 `MeasurePolicy`
    接口的一个实现。在这种情况下，它是 `columnMeasurePolicy()` 调用的结果。
- en: Defining measure policies
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义测量策略
- en: Depending on the values of `verticalArrangement` and `horizontalAlignment`,
    the call to `columnMeasurePolicy()` returns either `DefaultColumnMeasurePolicy`
    (a variable) or the result of `rowColumnMeasurePolicy()`. `DefaultColumnMeasurePolicy`
    calls `rowColumnMeasurePolicy`. Therefore, this function defines the measure policy
    for any `Column()`. It returns a `MeasurePolicy`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `verticalArrangement` 和 `horizontalAlignment` 的值，对 `columnMeasurePolicy()`
    的调用将返回 `DefaultColumnMeasurePolicy`（一个变量）或 `rowColumnMeasurePolicy()` 的结果。`DefaultColumnMeasurePolicy`
    调用 `rowColumnMeasurePolicy`。因此，此函数定义了任何 `Column()` 的测量策略。它返回一个 `MeasurePolicy`。
- en: Tip
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please remember that you can look at the source code of a policy by pressing
    the *Ctrl* key and clicking on a name, such as `columnMeasurePolicy`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以通过按 *Ctrl* 键并单击名称，例如 `columnMeasurePolicy`，来查看策略的源代码。
- en: '`MeasurePolicy` belongs to the `androidx.compose.ui.layout` package. It defines
    how a layout is measured and laid out, so it is the main building block for both
    predefined (for example, `Box()`, `Row()`, and `Column()`) and custom layouts.
    Its most important function is `measure()`, which is an extension function of
    `MeasureScope`. This function receives two parameters, `List<Measurable>` and
    `Constraints`. The elements of the list represent the children of the layout.
    They can be measured using `Measurable.measure()`. This function returns an instance
    of `Placeable`, a representation of the size a child wants to span.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeasurePolicy` 属于 `androidx.compose.ui.layout` 包。它定义了布局如何进行测量和布局，因此它是预定义布局（例如，`Box()`、`Row()`
    和 `Column()`）和自定义布局的主要构建块。它的最重要的功能是 `measure()`，这是一个 `MeasureScope` 的扩展函数。此函数接收两个参数，`List<Measurable>`
    和 `Constraints`。列表中的元素代表布局的子元素。它们可以使用 `Measurable.measure()` 进行测量。此函数返回一个 `Placeable`
    实例，表示子元素想要占据的大小。'
- en: '`MeasureScope.measure()` returns an instance of `MeasureResult`. This interface
    defines the following components:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeasureScope.measure()` 返回一个 `MeasureResult` 实例。此接口定义了以下组件：'
- en: The size of a layout (`width`, `height`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局的尺寸（`width`、`height`）
- en: Alignment lines (`alignmentLines`)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐线（`alignmentLines`）
- en: Logic to position the children (`placeChildren()`)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位子元素的逻辑（`placeChildren()`）
- en: You can find an implementation of `MeasureResult` in the *Creating custom layouts*
    section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *“创建自定义布局”* 部分找到 `MeasureResult` 的实现。
- en: Alignment lines define an offset line that can be used by parent layouts to
    align and position their children. For example, text baselines are alignment lines.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐线定义了一个偏移线，父布局可以使用它来对齐和定位其子元素。例如，文本基线是对齐线。
- en: Depending on the complexity of the UI, a layout may find that its children do
    not fit nicely in its boundaries. The layout may want to remeasure the children,
    passing different measurement configurations. Remeasuring children is possible
    in the Android `View` system, but this can lead to decreased performance. Therefore,
    in Jetpack Compose, a layout may measure its content only once. If it tries again,
    an exception will be thrown.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据UI的复杂性，布局可能会发现其子元素无法很好地适应其边界。布局可能想要重新测量子元素，传递不同的测量配置。在Android `View` 系统中，重新测量子元素是可能的，但这可能会导致性能下降。因此，在Jetpack
    Compose中，布局可能只测量其内容一次。如果它再次尝试，将抛出异常。
- en: 'A layout can, however, query the `MeasurePolicy` defines four extension functions
    of `IntrinsicMeasureScope`. `minIntrinsicWidth()` and `maxIntrinsicWidth()` return
    the minimum or maximum width of a layout, given a particular height, so that the
    content of the layout can be painted completely. `minIntrinsicHeight()` and `maxIntrinsicHeight()`
    return the minimum or maximum height of a layout given a particular width so that
    the content of the layout can be painted completely. To get an idea of how they
    work, let''s briefly look at one of them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，布局可以查询 `MeasurePolicy` 定义了 `IntrinsicMeasureScope` 的四个扩展函数。`minIntrinsicWidth()`
    和 `maxIntrinsicWidth()` 返回给定特定高度的布局的最小或最大宽度，以便完全绘制布局的内容。`minIntrinsicHeight()`
    和 `maxIntrinsicHeight()` 返回给定特定宽度的布局的最小或最大高度，以便完全绘制布局的内容。为了了解它们是如何工作的，让我们简要地看看其中一个：
- en: '![Figure 4.3 – Source code of minIntrinsicWidth()'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – `minIntrinsicWidth()` 的源代码'
- en: '](img/B17505_04_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_04_03.jpg)'
- en: Figure 4.3 – Source code of minIntrinsicWidth()
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – `minIntrinsicWidth()` 的源代码
- en: '`IntrinsicMeasureScope.minIntrinsicWidth()` receives two parameters: `height`
    and a list of children (`measurables`). The `IntrinsicMeasurable` interface defines
    four functions that obtain the minimum or maximum values for a particular element
    (`minIntrinsicWidth()`, `maxIntrinsicWidth()`, `minIntrinsicHeight()`, and `maxIntrinsicHeight()`).
    Each element of `measurables` is converted into an instance of `DefaultIntrinsicMeasurable`.
    As this class implements the `Measurable` interface, it provides an implementation
    of `measure()`. It returns `FixedSizeIntrinsicsPlaceable`, which provides the
    smallest possible width for a given `height`. The converted children are measured
    by an instance of `IntrinsicsMeasureScope`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntrinsicMeasureScope.minIntrinsicWidth()` 接收两个参数：`height` 和子视图列表（`measurables`）。`IntrinsicMeasurable`
    接口定义了四个函数，用于获取特定元素的最小或最大值（`minIntrinsicWidth()`、`maxIntrinsicWidth()`、`minIntrinsicHeight()`
    和 `maxIntrinsicHeight()`）。`measurables` 的每个元素都被转换成 `DefaultIntrinsicMeasurable`
    的实例。由于该类实现了 `Measurable` 接口，它提供了一个 `measure()` 的实现。它返回 `FixedSizeIntrinsicsPlaceable`，为给定的
    `height` 提供可能的最小宽度。转换后的子视图由 `IntrinsicsMeasureScope` 的一个实例进行测量。'
- en: 'We''ll finish looking at the internals of the Compose layout process by turning
    to `Constraints`. They are, for example, passed to `MeasureScope.measure()`. The
    class belongs to the `androidx.compose.ui.unit` package. It stores four values:
    `minWidth`, `minHeight`, `maxWidth`, and `maxHeight`. They define the minimum
    and maximum values the children of a layout must honor when measuring themselves.
    So, their width must be no smaller than `minWidth` and no larger than `maxWidth`.
    Their height must lie within `minHeight` and `maxHeight`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过转向 `Constraints` 来完成对 Compose 布局过程内部结构的查看。例如，它们会被传递给 `MeasureScope.measure()`。该类属于
    `androidx.compose.ui.unit` 包。它存储四个值：`minWidth`、`minHeight`、`maxWidth` 和 `maxHeight`。它们定义了布局子视图在测量自身时必须遵守的最小和最大值。因此，它们的宽度必须不小于
    `minWidth` 且不大于 `maxWidth`。它们的高度必须在 `minHeight` 和 `maxHeight` 之间。
- en: The companion object defines the `Infinity` constant. It is used to signal that
    the constraint should be considered infinite. To create a `Constraints` instance,
    you can invoke the top-level `Constraints()` function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象定义了 `Infinity` 常量。它用于表示约束应该被视为无限。要创建 `Constraints` 实例，你可以调用顶层 `Constraints()`
    函数。
- en: This was a lot of information. Before moving on, let's recap what we have learned.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多信息。在继续之前，让我们回顾一下我们已经学到的内容。
- en: 'The `Layout()` composable receives three parameters: the content, the measure
    policy, and a modifier.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layout()` 组合函数接收三个参数：内容、度量策略和一个修饰符。'
- en: The measure policy defines how a layout is measured and laid out.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 度量策略定义了布局如何被测量和布局。
- en: The intrinsic size of a layout determines the minimum or maximum dimension for
    the corresponding input.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局的固有大小决定了对应输入的最小或最大维度。
- en: In the traditional View system, a parent view may call the `measure()` method
    more than once on its children (please refer to [https://developer.android.com/guide/topics/ui/how-android-draws](https://developer.android.com/guide/topics/ui/how-android-draws)
    for details). On the other hand, Jetpack Compose requires that children must be
    measured *exactly once* before they are positioned. This results in a more performant
    measurement.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的视图系统中，父视图可能会对其子视图多次调用 `measure()` 方法（请参阅[https://developer.android.com/guide/topics/ui/how-android-draws](https://developer.android.com/guide/topics/ui/how-android-draws)
    获取详细信息）。另一方面，Jetpack Compose 要求在子视图定位之前必须精确测量一次。这导致测量性能更优。
- en: In the next section, we will make use of this knowledge by implementing a simple
    custom layout. It will position its children from left to right and from top to
    bottom. When one row is filled, the next one will be started below it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将利用这些知识来实现一个简单的自定义布局。它将从左到右和从上到下定位其子项。当一行填满时，下一行将在其下方开始。
- en: Creating custom layouts
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义布局
- en: 'Sometimes, you may want to lay children out one after another in a row and
    start a new row when the current one has been filled. The `CustomLayoutDemo` sample
    app, as shown in the following screenshot, shows you how to do this. It creates
    43 randomly colored boxes that vary in width and height:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望在一行中依次排列子项，并在当前行填满后开始新的一行。下面的截图显示了 `CustomLayoutDemo` 示例应用程序，它展示了如何做到这一点。它创建了
    43 个随机着色的框，宽度和高度各不相同：
- en: '![Figure 4.4 – Sample CustomLayoutDemo app'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 示例 CustomLayoutDemo 应用程序'
- en: '](img/B17505_04_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_04_04.jpg](img/B17505_04_04.jpg)'
- en: Figure 4.4 – Sample CustomLayoutDemo app
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 示例 CustomLayoutDemo 应用程序
- en: 'Let''s start by looking at the composable function that creates colored boxes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看创建彩色框的组成函数开始：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A colored box consists of a `Box()` with a black, two density-independent pixels
    wide border. The `width()` and `height()` modifiers set the preferred size of
    the box. This means that the layout could override it. For simplicity, my example
    doesn''t. `randomInt123()` randomly returns either `1`, `2`, or `3`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个彩色框由一个带有黑色、宽度为两个密度无关像素的 `Box()` 组成。`width()` 和 `height()` 修饰符设置框的首选大小。这意味着布局可以覆盖它。为了简单起见，我的示例没有这样做。`randomInt123()`
    随机返回 `1`、`2` 或 `3`：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`randomColor()` randomly returns red, green, or blue:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomColor()` 随机返回红色、绿色或蓝色：'
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, I''ll show you how the colored boxes are created and set as the content
    of my custom layout:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向您展示如何创建并设置彩色框作为我自定义布局的内容：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`SimpleFlexBox()` is our custom layout. It is used like any predefined layout.
    You can even provide a modifier (which has not been done here for simplicity).
    So, how does the custom layout work? Let''s find out:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleFlexBox()` 是我们的自定义布局。它就像任何预定义布局一样使用。您甚至可以提供一个修饰符（这里为了简单起见没有这样做）。那么，自定义布局是如何工作的呢？让我们来看看：'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Custom layouts should receive at least two parameters – `content` and a `modifier`
    with a default value of `Modifier`. Additional parameters may influence the behavior
    of your custom layout. For example, you may want to make the alignment of children
    configurable. For simplicity, the example does not do so.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义布局应至少接收两个参数 – `content` 和一个默认值为 `Modifier` 的 `modifier`。其他参数可能会影响自定义布局的行为。例如，您可能希望使子项的对齐方式可配置。为了简单起见，示例没有这样做。
- en: As you know from the previous section, measurement and positioning are defined
    through a measure policy. I will show you how to implement one in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上一节所知，测量和定位是通过测量策略定义的。我将在下一节中向您展示如何实现它。
- en: Implementing a custom measure policy
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义测量策略
- en: 'At this point, I have shown you almost all the code for the custom layout.
    The only thing that''s missing is the measure policy. Let''s see how it works:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向您展示了几乎所有的自定义布局代码。唯一缺少的是测量策略。让我们看看它是如何工作的：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`MeasurePolicy` implementations must provide implementations of `MeasureScope.measure()`.
    This function returns an instance of the `MeasureResult` interface. You do not
    need to implement this on your own. Instead, you must invoke `layout()`. This
    function belongs to `MeasureScope`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeasurePolicy` 实现必须提供 `MeasureScope.measure()` 方法的实现。此方法返回 `MeasureResult`
    接口的一个实例。您不需要自己实现它。相反，您必须调用 `layout()`。此函数属于 `MeasureScope`。'
- en: We pass the measured size of the layout and a `placementBlock`, which is an
    extension function of `Placeable.PlacementScope`. This means that you can invoke
    functions such as `placeRelative()` to position a child in its parent's coordinate
    system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递布局的测量大小和一个 `placementBlock`，它是 `Placeable.PlacementScope` 的扩展函数。这意味着您可以调用
    `placeRelative()` 等函数来在父坐标系统中定位子项。
- en: A measure policy receives the content, or children, as `List<Measurable>`. As
    you know from the *Understanding the single measure pass* section, children must
    be measured exactly once before they are positioned. We can do this by creating
    a map of `placeables`, invoking `measure()` on each `measurable`. My example doesn't
    constrain child views further, instead measuring them with the given constraints.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测量策略接收内容或子项作为 `List<Measurable>`。正如你在 *理解单次测量传递* 部分所知，在定位之前，子项必须精确测量一次。我们可以通过创建一个
    `placeables` 映射，对每个 `measurable` 调用 `measure()` 来实现这一点。我的示例没有进一步约束子视图，而是使用给定的约束来测量它们。
- en: '`placementBlock` iterates over the `placeables` map, calculating the location
    of a placeable by increasing `xPos` and `yPos` along the way. Before invoking
    `placeRelative()`, the algorithm checks if a placeable completely fits into the
    current row. If this is not the case, `yPos` will be increased and `xPos` will
    be reset to `0`. How much `yPos` will be increased depends on the maximum height
    of all the placeables in the current row. This value is stored in `maxY`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`placementBlock` 遍历 `placeables` 映射，通过增加 `xPos` 和 `yPos` 来计算可放置项的位置。在调用 `placeRelative()`
    之前，算法会检查可放置项是否完全适合当前行。如果不是这种情况，`yPos` 将会增加，而 `xPos` 将重置为 `0`。`yPos` 增加的量取决于当前行中所有可放置项的最大高度。这个值存储在
    `maxY` 中。'
- en: As you have seen, implementing simple custom layouts is straightforward. Advanced
    topics such as alignment lines (which help with/are needed for X...) are beyond
    the scope of this book. You can find more information about them at [https://developer.android.com/jetpack/compose/layouts/alignment-lines](https://developer.android.com/jetpack/compose/layouts/alignment-lines).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，实现简单的自定义布局很简单。关于对齐线（有助于/需要用于 X...）等高级主题超出了本书的范围。你可以在 [https://developer.android.com/jetpack/compose/layouts/alignment-lines](https://developer.android.com/jetpack/compose/layouts/alignment-lines)
    找到更多关于它们的信息。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the predefined layouts of `Row()`, `Column()`, and `Box()`.
    You learned how to combine them to create beautiful UIs. You were also introduced
    to `ConstraintLayout`, which places composables that are relative to others on
    the screen and flattens the UI element hierarchy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了预定义的布局 `Row()`、`Column()` 和 `Box()`。你学习了如何将它们组合起来创建美观的用户界面。你还介绍了 `ConstraintLayout`，它将相对于屏幕上的其他可组合项放置可组合项并简化
    UI 元素层次结构。
- en: The second main section explored why the layout system in Jetpack Compose is
    more performant than the traditional View-based approach. We looked at some of
    the internals of the Compose runtime, which prepared us for the final main section
    of this chapter, *Creating custom layouts*, where you learned how to create a
    custom layout and thus gain precise control over the rendering of its children.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要部分探讨了为什么 Jetpack Compose 中的布局系统比传统的基于 View 的方法更高效。我们查看了一些 Compose 运行时的内部机制，这为我们学习本章的最后一部分，*创建自定义布局*，打下了基础，在那里你学习了如何创建自定义布局并因此对子元素的渲染获得精确控制。
- en: The next chapter, *Managing the State of Your Composable Functions*, will deepen
    your knowledge of state. We will examine the difference between stateless and
    stateful composable functions. Also, we will look at advanced use cases such as
    surviving configuration changes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，*管理 Composable 函数的状态*，将深化你对状态的理解。我们将研究无状态和有状态的可组合函数之间的区别。此外，我们还将探讨诸如配置更改后存活等高级用例。
