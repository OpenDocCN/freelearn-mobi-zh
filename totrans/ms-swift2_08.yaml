- en: Chapter 8. Working with XML and JSON Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For years, I used **Extensible Markup Language** (**XML**) as the format of
    choice to exchange data between systems. Its simplicity, readability, and ease
    of use made it an easy choice. The only real drawback with XML, in my opinion,
    is the large size of XML documents. Mobile devices, such as iOS devices, rely
    on exchanging data over mobile networks when they are not connected to a Wi-Fi
    network. These mobile networks are generally slower than a standard Wi-Fi or cabled
    networks. Most mobile devices also have data plans that limit the amount of data
    a user can use in a given month. That was when I really started looking at using
    **JavaScript Object Notation** (**JSON**) to exchange data between systems. Now,
    I almost exclusively use JSON to exchange data, especially with mobile devices.
    Even though, for mobile development, JSON seems to be becoming the format of choice,
    XML is still very widely used because it is generally easier to read and use than
    JSON. As a developer, it is a good idea to have a working knowledge of both formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing XML documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building XML documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building JSON documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was not that long ago that most consumer-based applications were self-contained
    and did not need to exchange data with external services. However, in today's
    age of smartphones and data-driven applications, it is now rare to develop applications
    that do not need to exchange data with external services. This makes it essential
    for application developers to know how to exchange data in standard formats.
  prefs: []
  type: TYPE_NORMAL
- en: These days, API designers tend to favor one of the two formats to exchange data—XML
    or JSON. There have been a number of other data exchange formats that have been
    promoted over the years, but XML and JSON are, by far, the current leaders. The
    primary reason for this is that the openness and interoperability of XML and JSON
    are unmatched by the other data exchange formats. It would be hard to find a public
    web API that does not offer XML and/or JSON to exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: Apple has provided simple and efficient APIs to work with both XML and JSON
    data. While there are a number of third-party libraries and frameworks that offer
    certain advantages and disadvantages over Apple's APIs, in this chapter we will
    stick with Apple's APIs. Let's look at how we will parse XML and JSON documents
    with Swift, but first let's create some common files that we will use for the
    XML and JSON examples in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Common files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a structure that will be used to define the tags that
    are valid for our XML and JSON documents. These tags will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`books`: This is the root element that encloses all the other elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book`: This element encloses all the information about a particular book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: This element contains the author''s name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publisher`: This element contains the publisher''s name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category`: This element contains the category of the book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This element contains the description of the book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is an attribute of the book element in the XML example and a standard
    element in the JSON example. This element contains the name of the book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DocTags` structure will define the seven static properties that will contain
    the names of these seven tags. This following code shows how to define this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than using a structure, we could define our document tags in an enum
    instead. Which one we use is really a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the seven properties defined in the `DocTags` structure is defined with
    the `static` and `let` keywords. The `static` keyword defines the properties as
    `static` properties. A `static` property is one that is not associated with any
    given instances of the structure, and any changes to a `static` property are reflected
    in all the instances of the structure. The advantage a `static` property has over
    an `instance` property is that we do not need to create an instance of the structure
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to create a class that will contain the information about
    each book. We will name this class `Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Apple recommends that we use value types (structs and enums) over reference
    types (classes), in the examples for this chapter a reference type is preferred
    so we can pass the actual instance of our book type as we build it rather than
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `Book` class contains five properties. These properties will
    contain information about each book.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are parsing the XML and JSON documents, we will be able to retrieve
    each element of the document and the value stored within the element; therefore,
    we will need a way to take that information and set the values of the `Book` properties.
    With this in mind, let''s create a helper function that will take the name of
    the element and the value associated with it as parameters. We will then set the
    appropriate property, based on the name of the element. Let''s name this function
    `addValue` and add it to our `Book` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `addValue` function will use a `switch` statement to compare the element
    name to each of the tags defined in the `DocTags` structure. If a match is found,
    it will set the value of the appropriate property. If no match is found, it will
    skip that element; normally, we should be able to simply ignore the extra tags.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, the parser code, which we will see next, is not too bad when we are
    dealing with one class as in this example. When you start to work with more complex
    XML and JSON documents, which might require multiple classes, having helper methods
    such as the `addValue` method can significantly clean up the parsing code and
    make it much easier to read. These helper functions can be in their own class
    or part of the data storage class (as shown in the preceding example), depending
    on what works best for your particular application. Usually, I prefer the helper
    functions separated from the data storage class.
  prefs: []
  type: TYPE_NORMAL
- en: XML and the NSXMLParser class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To parse XML documents in Swift, we will use Apple's `NSXMLParser` class. While
    there are several alternatives to `NSXMLParser`, each with its own advantages
    and disadvantages, I have always found `NSXMLParser` to be simple to understand
    and use. It is also designed in a way that is consistent with Apple's other APIs,
    which means if we are familiar with Apple's other APIs, `NSXMLParser` will seem
    pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The `NSXMLParser` class is a **Simple API for XML** (**SAX**) parser. SAX parsers
    provide a mechanism to parse XML documents sequentially. Unlike **Document Object
    Model** (**DOM**) parsers, which read the entire document into the memory and
    then parse it, a SAX parser reports on each parsing event as it happens. This
    allows for a much smaller memory footprint while parsing. It also means that we
    need to have code to handle each parsing event that is needed to parse the XML
    document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSXMLParser` class can parse XML documents from a URL, an `NSData` object,
    or through a stream. To parse XML documents from various sources, we initiate
    the `NSXMLParser` class with the appropriate initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Init(contentsOfURL:)`: This initiates the `NSXMLParser` class with the content
    referenced by the provided URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Init(data:)`: This initiates the `NSXMLParser` class with the content of the
    `NSData` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Init(stream:)`: This initiates the `NSXMLParser` class with the content from
    the supplied stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this chapter''s XML example, we will be using the `init(data:)` initializer
    to parse a string representation of an XML document. The `NSData` class is designed
    to work with binary data. The initializer can be easily replaced by any of the
    other initializers to parse an XML document from a URL or stream. The XML parsing
    example will be designed to parse the following XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the NSXMLParserDelegate protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NSXMLParserDelegate` protocol defines several optional methods that can
    be defined by the `NSXMLParser` delegate. These methods are called when certain
    parsing events occur while `NSXMLParser` is parsing XML documents. The `NSXMLParserDelegate`
    method may also define several optional methods that are used to handle the **Document
    Type Definition** (**DTD**) markup. The DTD markup defines the legal document
    structure of an XML document by defining a list of valid elements and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be implementing the following delegate methods for the XML example
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parserDidStartDocument(_:)`: This method is called when the parser begins
    parsing the XML document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parserDidEndDocument(_:)`: This method is called after the parser has successfully
    parsed the entire XML document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)`: This
    method is called when the parser encounters a start tag for an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parser(_: didEndElement: namespaceURI: qualifiedName:)`: This method is called
    when the parser encounters an end tag for an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parser(_:parseErrorOccurred:)`: This method is called when the parser encounters
    a critical error and is unable to parse the document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parser(_:foundCharacters:)`: This method is called to provide a string representation
    of all or part of the characters of the data for thecurrent element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at how we will parse XML documents with `NSXMLParser` and
    `NSXMLParserDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing XML documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To parse an XML document we begin by creating a class or struct that conforms
    to the `NSXMLParaseDelegate` protocol. In our example, we will name the class
    `MyXMLParser`. Our `MyXMLParser` class definition will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `MyXMLParser` class, we will add three properties that will be used
    by the parser while it is parsing the document. These three properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`books`: This property will be an optional array that will contain the list
    of books defined in the XML document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book`: This will be an optional instance of the `Book` class that represents
    the current book being parsed within the XML document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementData`: This will be an instance of the string class that contains the
    value of the current element that is being parsed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These properties will be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the `NSXMLParserDelegate` methods. The first one we add
    will be the `parseXmlString` method, which will be used to start the `NSXMLParser`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We begin the `parseXmlString()` method by converting the `xmlString` variable
    to an `NSData` object using the `dataUsingEncoding()` method. The `dataUsingEncoding()`
    method comes from the `NSString` class, but we can use it with our Swift string
    type because Swift automatically bridges Swift string types to the `NSString`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use the `init(data:)` initializer to initialize `NSXMLParser`. This
    initializer is called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSXMLParser(data: xmlData!)`'
  prefs: []
  type: TYPE_NORMAL
- en: We then set the `NSXMLParser` delegate to the current instance of the `MyXmlParser`
    class. We can do this because the `MyXmlParser` class conforms to the `NSXMLParserDelegate`
    protocol. This allows the current instance of the class to receive alerts as the
    document is being parsed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `parse()` method is called to begin parsing the XML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the `parserDidStartDocument()` method. This method will be called
    when `NSXMLParser` begins parsing the XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we do not need to perform any setup prior to parsing the document;
    therefore, the `parserDidStartDocument()` method just prints the `Started XML
    Parser` message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `parser(_: didStartElement: namespaceURI: qualifiedName:
    attributes:)` delegate method. Before we implement this delegate method, we need
    to figure out which elements require us to perform tasks when we encounter their
    start tags. In our example, we will need to check for the starting tags of two
    elements—`books` and `book`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `books` element is the root element that encloses all the items in the XML
    document. When we encounter the `books` element start tag, we will need to initialize
    the `books` array. This `books` array will contain a list of book instances that
    are generated as we parse the XML document.
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter the start tag for the `book` element, we will need to create
    a new instance of the `Book` class because the start tag means we are starting
    a new book. We might think that we should also save the current instance of the
    `book` property to the `books` array prior to creating a new instance, but we
    will do that when we encounter the `book` end tag rather than the start tag. The
    implementation always seems to be much cleaner when we save information based
    on an end tag rather than a start tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `parser(_: didStartElement: namespaceURI: qualifiedName:
    attributes:)` delegate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We begin this method by seeing whether the `elementName` parameter is equal
    to the `books` tag and, if so, we create a new array that will contain the books
    defined in the XML document. If the `elementName` parameter is not equal to the
    `books` tag, we check to see whether it is equal to the `Book` tag. If it is equal
    to the `book` tag, we set the `book` property to a new instance of the `book`
    class, clearing any previous saved information. We then check whether the element
    has an attribute with the `name` key (`name`) and, if so, we set the `name` property
    of the `book` instance to the value of that attribute. This instance of the `Book`
    class will contain the information about the book.
  prefs: []
  type: TYPE_NORMAL
- en: The next delegate method that we will implement is the `parser(_:foundCharacters:)`
    delegate method. This method receives the value or partial value of the element
    that is being parsed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since the value of any given element may be quite large, we may receive the
    value in pieces rather than in one chunk. This means that the `parser(_:foundCharacters:)`
    method may be called multiple times for the same element. In our example, we use
    the `elementData` property to keep track of the value of the current element;
    thus, in the `parser(_:foundCharacters:)` method, we simply append the value of
    the string parameter to the `elementData` property. We will clear the `elementData`
    property when we encounter an end tag for an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see how to use the `parser(_: didEndElement: namespaceURI: qualifiedName:)`
    delegate method when the parser encounters the end tag of an element. Before we
    implement this method, we need to figure out what elements we require to perform
    a task when we encounter their end tag. In our example, we will need to check
    whether we encountered the end tag of a `book` element. If we encountered any
    other tag besides the end of the `book` element, we will use the `addValue()`
    method of the `book` instance to determine what to do with the value.'
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter the end tag for the `book` element, we will need to add the
    current instance of the `book` property to the `books` array. If this is an end
    tag for any other element, we will call the `addValue()` method of the current
    book instance, remembering that the `addValue()` method will ignore any element
    if it does not recognize the element's name.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to clear the `elementData` property each time we encounter
    the end of an element so that the information from the previous element does not
    corrupt the next element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we will implement the `parser(_: didEndElement:
    namespaceURI: qualifiedName:)` delegate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the parser has completed parsing the document, it will call the `parser(_:parseErrorOccurred:)`
    delegate method. In our example, we will use this method to simply print the name
    of the book and author to the screen for each book in the `books` array, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If an error is encountered while parsing the document, the `parser:parseErrorOccurred:`
    delegate method is called to handle the error. In our example, we will print the
    error to the console, but normally we would need to properly handle the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse an XML document, we will use the `MyXmlParser` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to parse an XML document, let's take a look at how
    we create one.
  prefs: []
  type: TYPE_NORMAL
- en: XML and NSXMLDocument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSXMLDocument` class and its related classes make it very easy to create
    XML documents from our custom object; however, they are only available to OS X-based
    projects at the time of writing this book. Hopefully, someone at Apple will realize
    that we need a good way to build XML documents for iOS projects without using
    third-party frameworks or manually creating the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an XML document with Swift for OS X-based applications, we will need
    to use three foundation classes. These classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSNode`: This class is the superclass of the `NSXMLDocument` and `NSXMLElement`
    classes. This will be used to add attributes to an instance of the `NSXMLElement`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSXMLDocument`: This class is the top-level object for the XML document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSXMLElement`: All the elements in the XML document are instances of the `NSXMLElement`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to use these three classes to build an XML document. For this,
    we will create a function named `buildXMLString(books:)`, which takes an array
    of the `Book` objects as its only parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the `books` parameter is defined as optional, we begin the `buildXMLString()`
    function by verifying it is not null using the `if let myBooks = books` line.
    If it is null, we return an empty string; otherwise, we begin building the XML
    document.
  prefs: []
  type: TYPE_NORMAL
- en: The initializer that we are using for the `NSXMLDocument` class requires the
    root element for the XML document; therefore, we will begin by creating the `xmlRoot`
    constant using the `BOOKS_TAG` constant and then using it to create an instance
    of the `NSXMLDocument` class. Next, we loop through each instance of the `Book`
    class in the `books` array.
  prefs: []
  type: TYPE_NORMAL
- en: For each instance of the `Book` class, we create a new instance of the `NSXMLElement`
    class with the book name, which will contain the information about the book. This
    element will be the `<Book></Book>` element in our XML document. All the information
    about the book will either be an attribute of this element or a child element
    of this element.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the book is an attribute of the `book` element; therefore, we need
    to create an instance of the `NSXMLNode` class that contains the attribute's name
    and value. We do this with the `NXMLNode.attributeWithName()` function. We then
    add that attribute to the `book` element using the `addAttribute()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the remaining information about the book (`author`, `category`,
    `description`, and `publisher`) as child nodes to the `book` element using the
    `addChild()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we convert the `NSXMLDocument` class to a string using the `XMLString`
    property and return that string to the code that called the function.
  prefs: []
  type: TYPE_NORMAL
- en: XML and manually building XML documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are unable to use the `NSXMLNode`, `NSXMLDocument`, and `NSXMLElement`
    classes in iOS projects, we generally need to manually build the XML string or
    use third-party libraries. This method is error-prone and it requires us to have
    a very good knowledge of how XML documents are built but, if we are careful, we
    can create simple XML documents this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to manually create an XML document. For this, we will create
    a function named `builXMLString()`, which takes an array of `Book` objects as
    its only parameter. We will also create a helper class named `getElementString()`
    that will create a string representation of an XML element. The `getElementString()`
    function will accept two elements: the element name and value. Let''s have a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since the `books` parameter is defined as optional, we begin the `buildXMLString()`
    function by verifying it is not null with the `if let myBooks = books` line. If
    it is null, the function will return an empty string; otherwise, we begin building
    the XML document.
  prefs: []
  type: TYPE_NORMAL
- en: In this class, we simply create strings that represent the XML tags and append
    them to the `xmlString` variable. The `xmlString` variable will contain the XML
    document at the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `getElementString()` function creates a string that contains the start tag
    for the element, followed by the value of the element and the end tag for the
    element. This function is used to add most of the XML elements in this example.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, without an intimate knowledge of the syntax of XML documents,
    it would be virtually impossible to build complex documents with this method.
    We also need to be very careful to not to forget the closing tags at the end of
    an element.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and NSJSONSerialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To serialize and deserialize JSON documents, we will use the `NSJSONSerialization`
    class. As we will see, it is much easier to use the `NSJSONSerialization` class
    with JSON documents than it is to use the `NSXMLParser` class with XML documents;
    however, it can be more error-prone when we try to access the information. Just
    remember to always check values that are defined as optional for null prior to
    accessing them.
  prefs: []
  type: TYPE_NORMAL
- en: The `NSJSONSerialization` class, unlike the `NSXMLParser` class, will parse
    the entire JSON document memory and then return a JSON object; therefore, there
    is a lot less code to write but it is more memory-intensive, however.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSJSONSerialization` class can parse JSON documents from an `NSData` object
    or through a stream. To parse JSON documents from the various sources, we use
    the `NSJSONSerialization` class with the appropriate static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSONObjectWithData(_: options: error:)`: This initializer will parse a JSON
    document stored as an `NSData` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSONObjectWithStream(_: options: error:)`: This initializer will parse a JSON
    document from a stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for these two methods says that they return an optional of
    the `AnyObject` type. Generally, the results of these methods are in an instance
    of the `NSDictionary` or an `NSArray` class, depending on the JSON document. If
    you are unsure what type of object is being created, you can insert the following
    code, where the `jsonResponse` variable is the result returned from the two static
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `is` operator to check whether the response
    is of the `NSDictionary` or `NSArray` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the `NSXMLParser` class, the `NSJSONSerialization` class can be used
    to also create JSON documents from a collection object. To do this, we will use
    the `dataWithJSONObject(_: options: error:)` initializer, which will serialize
    a JSON document from a collection object. While it is possible to use other objects
    besides collection objects to create the JSON document, a proper JSON document
    is usually in the format of a dictionary or an array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JSON examples in this chapter, we will show you how to parse the following
    JSON document. This document contains the same information that was in the XML
    example, but it is stored as a JSON document now, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how to parse a JSON document that is stored as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a JSON document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will use the `NSJSONSerialization` class to parse the previously
    shown JSON documents. The `jsonString` variable in this function represents the
    JSON document that was previously shown. This function will create an array of
    `Book` objects based on the information in the JSON document. At the end of the
    function, we will print out the information about the books to show that they
    were correctly parsed from the document, as well as return the array of books,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseJson()` function starts off by converting the `jsonString` variable
    that contains the JSON document to an `NSData` object so that we can parse it
    with the `NSJSONSerialization` object. Since the conversion results in an optional
    value, we need to verify that it is not null. We do this with the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the conversion was successful, we can then use the `JSONObjectWithData()`
    method of the `NSJSONSerialization` class to create the JSON object from the `NSData`
    object we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that in our JSON document, the root tag of `books` contains an array
    of books, we use the following line to attempt to retrieve the array from the
    JSON object we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This line of code checks that the object is not null and is also an instance
    of the `NSArray` class. If the JSON object is supposed to contain an `NSDictionary`
    object, we would simply replace the `as? NSArray` with `as? NSDictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were able to successfully retrieve the `NSArray` class from the JSON
    object, then we loop through each item of the `NSArray` class. In our example,
    each item of the `NSArray` class is in an instance of the `NSDictionary` class;
    however, it is always a good idea to verify this. To verify that each item is
    an instance of the `NSDictionary` class, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the `NSDictionary` object, we use the `addValueToBook()` function
    (that we will see in just a minute) to populate the properties of the `Book` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we end the function by printing out the name and author of each book
    that we extracted from the JSON document. Let''s take a look at the `addValueToBook()`
    function that we use to populate the properties of the `Book` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we attempt to extract a value from an `NSDictionary` object where the key
    does not exist, the `NSDictionary` object will return a null object. In this case,
    we need to verify that the value is not null prior to assigning it to a property
    that does not accept a null value. The `addValueToBook()` function verifies that
    the values are not null prior to adding them to the instance of the `Book` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `NSJSONSerialization` class, it is better to have too many checks
    rather than not enough. Just remember if we try to set a non-optional variable
    to nil or use an object that is nil, our application will crash. JSON documents
    are not type-safe; therefore, it is also advisable to check the types of the values
    returned to make sure they are of the expected type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to create a JSON document with the `NSJSONSerialization`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JSON document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a JSON document using the `NSJSONSerialization` class is incredibly
    easy but, once again, we need to do several checks to make sure nothing goes wrong.
    The following code will create a valid JSON document from any object that can
    be converted to JSON data, such as dictionaries and/or arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do in the `buildJSON()` function is to verify that the `value`
    parameter is of a type that can be converted to a JSON object. We do this using
    the `isValidJSONObject()` function of the `NSJSONSerialization` class. This function
    will return a Boolean `true` value if the `value` parameter can be converted;
    otherwise, it will return a Boolean `false` value.
  prefs: []
  type: TYPE_NORMAL
- en: If the `value` parameter can be converted to a JSON object, then we use the
    `dataWithJSONObject()` function of the `NSJSONSerialization` class to convert
    the value parameter to JSON data. If there is an issue with the conversion, the
    `dataWithJSONObject()` function throws an error, which is thrown back to the code
    that called the `buildJSON()` function..
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we convert the JSON data to a `String` object and return it to the
    code that called the function. If anything goes wrong, we return an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that it takes a lot less code to parse/build JSON objects
    with the `NSJSONSerialization` class as compared to parsing/building XML objects.
    However, we do have a lot more control on how the document is parsed using the
    `NSXMLParser` class. The key thing to keep in mind with both the `NSJSONSerialization`
    class and the `NSXMLParser` class is that we need to remember to check that optional
    variables do not contain a nil value, before attempting to use them.
  prefs: []
  type: TYPE_NORMAL
- en: While it seems that the majority of newer services are using the JSON format
    over XML, it is good to have a working knowledge of both formats because there
    is still a large percentage of services that use XML.
  prefs: []
  type: TYPE_NORMAL
