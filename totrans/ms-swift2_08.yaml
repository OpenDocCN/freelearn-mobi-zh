- en: Chapter 8. Working with XML and JSON Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 处理XML和JSON数据
- en: For years, I used **Extensible Markup Language** (**XML**) as the format of
    choice to exchange data between systems. Its simplicity, readability, and ease
    of use made it an easy choice. The only real drawback with XML, in my opinion,
    is the large size of XML documents. Mobile devices, such as iOS devices, rely
    on exchanging data over mobile networks when they are not connected to a Wi-Fi
    network. These mobile networks are generally slower than a standard Wi-Fi or cabled
    networks. Most mobile devices also have data plans that limit the amount of data
    a user can use in a given month. That was when I really started looking at using
    **JavaScript Object Notation** (**JSON**) to exchange data between systems. Now,
    I almost exclusively use JSON to exchange data, especially with mobile devices.
    Even though, for mobile development, JSON seems to be becoming the format of choice,
    XML is still very widely used because it is generally easier to read and use than
    JSON. As a developer, it is a good idea to have a working knowledge of both formats.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我一直将**可扩展标记语言**（**XML**）作为首选的数据交换格式，用于系统之间的数据交换。它的简单性、可读性和易用性使其成为易选。在我看来，XML的唯一真正缺点是XML文档的大小很大。移动设备，如iOS设备，在未连接到Wi-Fi网络时，依赖于通过移动网络交换数据。这些移动网络通常比标准的Wi-Fi或有线网络慢。大多数移动设备也有数据计划，限制了用户在一个月内可以使用的数据量。那时，我开始真正考虑使用**JavaScript对象表示法**（**JSON**）在系统之间交换数据。现在，我几乎完全使用JSON来交换数据，尤其是在移动设备上。尽管对于移动开发来说，JSON似乎正在成为首选格式，但XML仍然非常广泛地被使用，因为它通常比JSON更容易阅读和使用。对于开发者来说，了解这两种格式都是很有帮助的。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Parsing XML documents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析XML文档
- en: Building XML documents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建XML文档
- en: Parsing JSON documents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析JSON文档
- en: Building JSON documents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建JSON文档
- en: XML and JSON
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML和JSON
- en: It was not that long ago that most consumer-based applications were self-contained
    and did not need to exchange data with external services. However, in today's
    age of smartphones and data-driven applications, it is now rare to develop applications
    that do not need to exchange data with external services. This makes it essential
    for application developers to know how to exchange data in standard formats.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并非很久以前，大多数基于消费者的应用程序都是自包含的，不需要与外部服务交换数据。然而，在智能手机和数据驱动应用程序的时代，现在开发不需要与外部服务交换数据的应用程序已经很少见了。这使得应用开发者了解如何以标准格式交换数据变得至关重要。
- en: These days, API designers tend to favor one of the two formats to exchange data—XML
    or JSON. There have been a number of other data exchange formats that have been
    promoted over the years, but XML and JSON are, by far, the current leaders. The
    primary reason for this is that the openness and interoperability of XML and JSON
    are unmatched by the other data exchange formats. It would be hard to find a public
    web API that does not offer XML and/or JSON to exchange data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，API设计者倾向于选择两种格式之一来交换数据——XML或JSON。多年来，已经推广了许多其他的数据交换格式，但XML和JSON无疑是当前的领导者。主要原因在于XML和JSON的开放性和互操作性是其他数据交换格式无法比拟的。很难找到一个不提供XML和/或JSON以交换数据的公共Web
    API。
- en: Apple has provided simple and efficient APIs to work with both XML and JSON
    data. While there are a number of third-party libraries and frameworks that offer
    certain advantages and disadvantages over Apple's APIs, in this chapter we will
    stick with Apple's APIs. Let's look at how we will parse XML and JSON documents
    with Swift, but first let's create some common files that we will use for the
    XML and JSON examples in the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司提供了简单高效的API来处理XML和JSON数据。虽然有一些第三方库和框架在苹果API之上提供了一定的优势和劣势，但在本章中，我们将坚持使用苹果的API。让我们看看我们将如何使用Swift解析XML和JSON文档，但首先让我们创建一些我们将用于本章中XML和JSON示例的常见文件。
- en: Common files
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见文件
- en: 'Let''s start by creating a structure that will be used to define the tags that
    are valid for our XML and JSON documents. These tags will be:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个结构，该结构将用于定义我们XML和JSON文档中有效的标签。这些标签将是：
- en: '`books`: This is the root element that encloses all the other elements'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`books`: 这是包含所有其他元素的根元素'
- en: '`book`: This element encloses all the information about a particular book'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book`: 此元素包含关于特定书籍的所有信息'
- en: '`author`: This element contains the author''s name'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`: 此元素包含作者的姓名'
- en: '`publisher`: This element contains the publisher''s name'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publisher`: 此元素包含出版者的名称'
- en: '`category`: This element contains the category of the book'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category`：此元素包含书籍的分类'
- en: '`description`: This element contains the description of the book'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：此元素包含书籍的描述'
- en: '`name`: This is an attribute of the book element in the XML example and a standard
    element in the JSON example. This element contains the name of the book'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是 XML 示例中书籍元素的属性，也是 JSON 示例中的标准元素。此元素包含书籍的名称'
- en: 'The `DocTags` structure will define the seven static properties that will contain
    the names of these seven tags. This following code shows how to define this structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocTags` 结构将定义包含这七个标签名称的七个静态属性。以下代码展示了如何定义这个结构：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rather than using a structure, we could define our document tags in an enum
    instead. Which one we use is really a matter of preference.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用结构体，我们可以在枚举中定义我们的文档标签。我们使用哪一个实际上完全取决于个人喜好。
- en: Each of the seven properties defined in the `DocTags` structure is defined with
    the `static` and `let` keywords. The `static` keyword defines the properties as
    `static` properties. A `static` property is one that is not associated with any
    given instances of the structure, and any changes to a `static` property are reflected
    in all the instances of the structure. The advantage a `static` property has over
    an `instance` property is that we do not need to create an instance of the structure
    to use it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DocTags` 结构体中定义的七个属性都是使用 `static` 和 `let` 关键字定义的。`static` 关键字将属性定义为 `static`
    属性。一个 `static` 属性是不与结构体的任何给定实例相关联的，对 `static` 属性的任何更改都会反映在结构体的所有实例中。与 `instance`
    属性相比，`static` 属性的优势在于我们不需要创建结构体的实例就可以使用它。
- en: 'Next, we will need to create a class that will contain the information about
    each book. We will name this class `Book`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个包含每本书信息的类。我们将把这个类命名为 `Book`：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While Apple recommends that we use value types (structs and enums) over reference
    types (classes), in the examples for this chapter a reference type is preferred
    so we can pass the actual instance of our book type as we build it rather than
    the value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Apple 建议我们使用值类型（结构体和枚举）而不是引用类型（类），但在本章的示例中，我们更倾向于使用引用类型，这样我们就可以在构建过程中传递我们书籍类型的实际实例，而不是值。
- en: As we can see, the `Book` class contains five properties. These properties will
    contain information about each book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Book` 类包含五个属性。这些属性将包含关于每本书的信息。
- en: 'While we are parsing the XML and JSON documents, we will be able to retrieve
    each element of the document and the value stored within the element; therefore,
    we will need a way to take that information and set the values of the `Book` properties.
    With this in mind, let''s create a helper function that will take the name of
    the element and the value associated with it as parameters. We will then set the
    appropriate property, based on the name of the element. Let''s name this function
    `addValue` and add it to our `Book` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解析 XML 和 JSON 文档时，我们将能够检索文档的每个元素及其存储在元素中的值；因此，我们需要一种方法来获取这些信息并设置 `Book` 属性的值。考虑到这一点，让我们创建一个辅助函数，该函数将接受元素的名称及其关联的值作为参数。然后，我们将根据元素的名称设置适当的属性。让我们把这个函数命名为
    `addValue` 并将其添加到我们的 `Book` 类中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `addValue` function will use a `switch` statement to compare the element
    name to each of the tags defined in the `DocTags` structure. If a match is found,
    it will set the value of the appropriate property. If no match is found, it will
    skip that element; normally, we should be able to simply ignore the extra tags.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`addValue` 函数将使用 `switch` 语句将元素名称与 `DocTags` 结构体中定义的每个标签进行比较。如果找到匹配项，它将设置相应属性的值。如果没有找到匹配项，它将跳过该元素；通常，我们应该能够简单地忽略额外的标签。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generally, the parser code, which we will see next, is not too bad when we are
    dealing with one class as in this example. When you start to work with more complex
    XML and JSON documents, which might require multiple classes, having helper methods
    such as the `addValue` method can significantly clean up the parsing code and
    make it much easier to read. These helper functions can be in their own class
    or part of the data storage class (as shown in the preceding example), depending
    on what works best for your particular application. Usually, I prefer the helper
    functions separated from the data storage class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们处理一个类时，如本例中的情况，解析器代码并不太糟糕。当你开始处理更复杂的 XML 和 JSON 文档时，可能需要多个类，拥有像 `addValue`
    方法这样的辅助方法可以显著清理解析代码，并使其更容易阅读。这些辅助函数可以放在它们自己的类中，或者作为数据存储类的一部分（如前例所示），具体取决于对特定应用程序的最佳做法。通常，我更喜欢将辅助函数与数据存储类分开。
- en: XML and the NSXMLParser class
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML 和 NSXMLParser 类
- en: To parse XML documents in Swift, we will use Apple's `NSXMLParser` class. While
    there are several alternatives to `NSXMLParser`, each with its own advantages
    and disadvantages, I have always found `NSXMLParser` to be simple to understand
    and use. It is also designed in a way that is consistent with Apple's other APIs,
    which means if we are familiar with Apple's other APIs, `NSXMLParser` will seem
    pretty straightforward.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中解析 XML 文档时，我们将使用 Apple 的 `NSXMLParser` 类。虽然 `NSXMLParser` 有几种替代方案，每种方案都有其自身的优缺点，但我一直发现
    `NSXMLParser` 简单易懂且易于使用。它还设计得与 Apple 的其他 API 保持一致，这意味着如果我们熟悉 Apple 的其他 API，`NSXMLParser`
    将显得相当直观。
- en: The `NSXMLParser` class is a **Simple API for XML** (**SAX**) parser. SAX parsers
    provide a mechanism to parse XML documents sequentially. Unlike **Document Object
    Model** (**DOM**) parsers, which read the entire document into the memory and
    then parse it, a SAX parser reports on each parsing event as it happens. This
    allows for a much smaller memory footprint while parsing. It also means that we
    need to have code to handle each parsing event that is needed to parse the XML
    document.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSXMLParser` 类是一个 **简单 XML API** (**SAX**) 解析器。SAX 解析器提供了一种按顺序解析 XML 文档的机制。与将整个文档读入内存然后进行解析的
    **文档对象模型** (**DOM**) 解析器不同，SAX 解析器在解析过程中报告每个解析事件。这允许在解析过程中占用更小的内存空间。这也意味着我们需要编写代码来处理解析
    XML 文档所需的每个解析事件。'
- en: 'The `NSXMLParser` class can parse XML documents from a URL, an `NSData` object,
    or through a stream. To parse XML documents from various sources, we initiate
    the `NSXMLParser` class with the appropriate initializer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSXMLParser` 类可以从 URL、`NSData` 对象或通过流解析 XML 文档。为了从各种来源解析 XML 文档，我们将使用适当的初始化器初始化
    `NSXMLParser` 类：'
- en: '`Init(contentsOfURL:)`: This initiates the `NSXMLParser` class with the content
    referenced by the provided URL'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init(contentsOfURL:)`：使用提供的 URL 引用的内容初始化 `NSXMLParser` 类'
- en: '`Init(data:)`: This initiates the `NSXMLParser` class with the content of the
    `NSData` object'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init(data:)`：使用 `NSData` 对象的内容初始化 `NSXMLParser` 类'
- en: '`Init(stream:)`: This initiates the `NSXMLParser` class with the content from
    the supplied stream'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init(stream:)`：使用提供的流的内容初始化 `NSXMLParser` 类'
- en: 'For this chapter''s XML example, we will be using the `init(data:)` initializer
    to parse a string representation of an XML document. The `NSData` class is designed
    to work with binary data. The initializer can be easily replaced by any of the
    other initializers to parse an XML document from a URL or stream. The XML parsing
    example will be designed to parse the following XML document:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的 XML 示例，我们将使用 `init(data:)` 初始化器来解析 XML 文档的字符串表示形式。`NSData` 类旨在与二进制数据一起使用。初始化器可以很容易地替换为其他任何初始化器，以从
    URL 或流中解析 XML 文档。XML 解析示例将被设计为解析以下 XML 文档：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the NSXMLParserDelegate protocol
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NSXMLParserDelegate 协议
- en: The `NSXMLParserDelegate` protocol defines several optional methods that can
    be defined by the `NSXMLParser` delegate. These methods are called when certain
    parsing events occur while `NSXMLParser` is parsing XML documents. The `NSXMLParserDelegate`
    method may also define several optional methods that are used to handle the **Document
    Type Definition** (**DTD**) markup. The DTD markup defines the legal document
    structure of an XML document by defining a list of valid elements and attributes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSXMLParserDelegate` 协议定义了几个可选方法，这些方法可以被 `NSXMLParser` 代理定义。当 `NSXMLParser`
    解析 XML 文档时发生某些解析事件时，会调用这些方法。`NSXMLParserDelegate` 方法还可以定义几个可选方法，用于处理 **文档类型定义**
    (**DTD**) 标记。DTD 标记通过定义一系列有效元素和属性来定义 XML 文档的合法结构。'
- en: 'We will be implementing the following delegate methods for the XML example
    in this chapter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现以下代理方法来处理 XML 示例：
- en: '`parserDidStartDocument(_:)`: This method is called when the parser begins
    parsing the XML document'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parserDidStartDocument(_:)`: 当解析器开始解析 XML 文档时，会调用此方法'
- en: '`parserDidEndDocument(_:)`: This method is called after the parser has successfully
    parsed the entire XML document'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parserDidEndDocument(_:)`: 解析器成功解析整个 XML 文档后，会调用此方法'
- en: '`parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)`: This
    method is called when the parser encounters a start tag for an element'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)`: 当解析器遇到元素的开始标签时，会调用此方法'
- en: '`parser(_: didEndElement: namespaceURI: qualifiedName:)`: This method is called
    when the parser encounters an end tag for an element'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parser(_: didEndElement: namespaceURI: qualifiedName:)`: 当解析器遇到元素的结束标签时，会调用此方法'
- en: '`parser(_:parseErrorOccurred:)`: This method is called when the parser encounters
    a critical error and is unable to parse the document'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parser(_:parseErrorOccurred:)`: 当解析器遇到一个关键错误且无法解析文档时，会调用此方法'
- en: '`parser(_:foundCharacters:)`: This method is called to provide a string representation
    of all or part of the characters of the data for thecurrent element'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parser(_:foundCharacters:)`: 当解析器需要提供当前元素的所有或部分字符的数据的字符串表示时，会调用此方法'
- en: Let's take a look at how we will parse XML documents with `NSXMLParser` and
    `NSXMLParserDelegate`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将如何使用 `NSXMLParser` 和 `NSXMLParserDelegate` 来解析 XML 文档。
- en: Parsing XML documents
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 XML 文档
- en: 'To parse an XML document we begin by creating a class or struct that conforms
    to the `NSXMLParaseDelegate` protocol. In our example, we will name the class
    `MyXMLParser`. Our `MyXMLParser` class definition will look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析一个 XML 文档，我们首先创建一个符合 `NSXMLParseDelegate` 协议的类或结构体。在我们的例子中，我们将这个类命名为 `MyXMLParser`。我们的
    `MyXMLParser` 类定义将看起来像这样：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the `MyXMLParser` class, we will add three properties that will be used
    by the parser while it is parsing the document. These three properties are:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MyXMLParser` 类内部，我们将添加三个属性，这些属性将在解析文档时被解析器使用。这三个属性是：
- en: '`books`: This property will be an optional array that will contain the list
    of books defined in the XML document'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`books`: 这个属性将是一个可选的数组，包含 XML 文档中定义的书籍列表'
- en: '`book`: This will be an optional instance of the `Book` class that represents
    the current book being parsed within the XML document'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book`: 这将是一个可选的 `Book` 类实例，代表 XML 文档中正在解析的当前书籍'
- en: '`elementData`: This will be an instance of the string class that contains the
    value of the current element that is being parsed'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementData`: 这将是一个字符串类的实例，包含正在解析的当前元素的值'
- en: 'These properties will be defined like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将定义如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we need to add the `NSXMLParserDelegate` methods. The first one we add
    will be the `parseXmlString` method, which will be used to start the `NSXMLParser`
    class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加 `NSXMLParserDelegate` 方法。我们首先添加的是 `parseXmlString` 方法，它将用于启动 `NSXMLParser`
    类：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We begin the `parseXmlString()` method by converting the `xmlString` variable
    to an `NSData` object using the `dataUsingEncoding()` method. The `dataUsingEncoding()`
    method comes from the `NSString` class, but we can use it with our Swift string
    type because Swift automatically bridges Swift string types to the `NSString`
    classes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从将 `xmlString` 变量转换为 `NSData` 对象开始 `parseXmlString()` 方法，使用 `dataUsingEncoding()`
    方法。`dataUsingEncoding()` 方法来自 `NSString` 类，但我们可以使用它与我们的 Swift 字符串类型，因为 Swift 自动将
    Swift 字符串类型桥接到 `NSString` 类。
- en: 'We then use the `init(data:)` initializer to initialize `NSXMLParser`. This
    initializer is called like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用 `init(data:)` 初始化器来初始化 `NSXMLParser`。这个初始化器调用如下：
- en: '`NSXMLParser(data: xmlData!)`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSXMLParser(data: xmlData!)`'
- en: We then set the `NSXMLParser` delegate to the current instance of the `MyXmlParser`
    class. We can do this because the `MyXmlParser` class conforms to the `NSXMLParserDelegate`
    protocol. This allows the current instance of the class to receive alerts as the
    document is being parsed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `NSXMLParser` 代理设置为当前 `MyXmlParser` 类的实例。我们可以这样做，因为 `MyXmlParser` 类符合
    `NSXMLParserDelegate` 协议。这允许类的当前实例在文档解析时接收警报。
- en: Finally, the `parse()` method is called to begin parsing the XML document.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用 `parse()` 方法开始解析 XML 文档。
- en: 'Now let''s add the `parserDidStartDocument()` method. This method will be called
    when `NSXMLParser` begins parsing the XML document:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加 `parserDidStartDocument()` 方法。当 `NSXMLParser` 开始解析 XML 文档时，会调用此方法：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our example, we do not need to perform any setup prior to parsing the document;
    therefore, the `parserDidStartDocument()` method just prints the `Started XML
    Parser` message to the console.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，在解析文档之前我们不需要进行任何设置；因此，`parserDidStartDocument()` 方法只是将 `Started XML
    Parser` 消息打印到控制台。
- en: 'Now, let''s look at the `parser(_: didStartElement: namespaceURI: qualifiedName:
    attributes:)` delegate method. Before we implement this delegate method, we need
    to figure out which elements require us to perform tasks when we encounter their
    start tags. In our example, we will need to check for the starting tags of two
    elements—`books` and `book`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们看看 `parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)`
    代理方法。在我们实现这个代理方法之前，我们需要弄清楚哪些元素在我们遇到它们的开始标签时需要我们执行任务。在我们的例子中，我们需要检查两个元素的开始标签——`books`
    和 `book`。'
- en: The `books` element is the root element that encloses all the items in the XML
    document. When we encounter the `books` element start tag, we will need to initialize
    the `books` array. This `books` array will contain a list of book instances that
    are generated as we parse the XML document.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`books` 元素是包含 XML 文档中所有项目的根元素。当我们遇到 `books` 元素的开始标签时，我们需要初始化 `books` 数组。这个
    `books` 数组将包含在解析 XML 文档时生成的书籍实例列表。'
- en: When we encounter the start tag for the `book` element, we will need to create
    a new instance of the `Book` class because the start tag means we are starting
    a new book. We might think that we should also save the current instance of the
    `book` property to the `books` array prior to creating a new instance, but we
    will do that when we encounter the `book` end tag rather than the start tag. The
    implementation always seems to be much cleaner when we save information based
    on an end tag rather than a start tag.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到 `book` 元素的开始标签时，我们需要创建 `Book` 类的新实例，因为开始标签意味着我们开始了一本新书。我们可能会认为在创建新实例之前，我们应该也将当前
    `book` 属性的实例保存到 `books` 数组中，但我们将这样做是在遇到 `book` 结束标签而不是开始标签时。基于结束标签而不是开始标签保存信息时，实现总是看起来更干净。
- en: 'Here is the code for the `parser(_: didStartElement: namespaceURI: qualifiedName:
    attributes:)` delegate method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '下面是 `parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)`
    代理方法的代码：'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We begin this method by seeing whether the `elementName` parameter is equal
    to the `books` tag and, if so, we create a new array that will contain the books
    defined in the XML document. If the `elementName` parameter is not equal to the
    `books` tag, we check to see whether it is equal to the `Book` tag. If it is equal
    to the `book` tag, we set the `book` property to a new instance of the `book`
    class, clearing any previous saved information. We then check whether the element
    has an attribute with the `name` key (`name`) and, if so, we set the `name` property
    of the `book` instance to the value of that attribute. This instance of the `Book`
    class will contain the information about the book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个方法开始，查看 `elementName` 参数是否等于 `books` 标签，如果是，我们创建一个新数组，该数组将包含 XML 文档中定义的书籍。如果
    `elementName` 参数不等于 `books` 标签，我们检查它是否等于 `Book` 标签。如果它等于 `book` 标签，我们将 `book`
    属性设置为 `book` 类的新实例，清除任何之前保存的信息。然后我们检查元素是否有具有 `name` 键（`name`）的属性，如果有，我们将 `book`
    实例的 `name` 属性设置为该属性的值。这个 `Book` 类的实例将包含关于书籍的信息。
- en: The next delegate method that we will implement is the `parser(_:foundCharacters:)`
    delegate method. This method receives the value or partial value of the element
    that is being parsed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下一个代理方法是 `parser(_:foundCharacters:)` 代理方法。此方法接收正在解析的元素的值或部分值。
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the value of any given element may be quite large, we may receive the
    value in pieces rather than in one chunk. This means that the `parser(_:foundCharacters:)`
    method may be called multiple times for the same element. In our example, we use
    the `elementData` property to keep track of the value of the current element;
    thus, in the `parser(_:foundCharacters:)` method, we simply append the value of
    the string parameter to the `elementData` property. We will clear the `elementData`
    property when we encounter an end tag for an element.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何给定元素的值可能相当大，我们可能以片段的形式接收该值而不是一次性接收。这意味着 `parser(_:foundCharacters:)` 方法可能多次为同一元素调用。在我们的例子中，我们使用
    `elementData` 属性来跟踪当前元素的值；因此，在 `parser(_:foundCharacters:)` 方法中，我们只需将字符串参数的值追加到
    `elementData` 属性。当我们遇到元素的结束标签时，我们将清除 `elementData` 属性。
- en: 'Next, let''s see how to use the `parser(_: didEndElement: namespaceURI: qualifiedName:)`
    delegate method when the parser encounters the end tag of an element. Before we
    implement this method, we need to figure out what elements we require to perform
    a task when we encounter their end tag. In our example, we will need to check
    whether we encountered the end tag of a `book` element. If we encountered any
    other tag besides the end of the `book` element, we will use the `addValue()`
    method of the `book` instance to determine what to do with the value.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，让我们看看当解析器遇到一个元素的结束标签时，如何使用`parser(_: didEndElement: namespaceURI: qualifiedName:)`代理方法。在我们实现这个方法之前，我们需要弄清楚在遇到这些元素的结束标签时，我们需要哪些元素来执行任务。在我们的例子中，我们需要检查是否遇到了`book`元素的结束标签。如果我们遇到了除了`book`元素结束标签之外的任何标签，我们将使用`book`实例的`addValue()`方法来确定如何处理这个值。'
- en: When we encounter the end tag for the `book` element, we will need to add the
    current instance of the `book` property to the `books` array. If this is an end
    tag for any other element, we will call the `addValue()` method of the current
    book instance, remembering that the `addValue()` method will ignore any element
    if it does not recognize the element's name.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到`book`元素的结束标签时，我们需要将当前`book`属性的实例添加到`books`数组中。如果这是一个其他元素的结束标签，我们将调用当前书实例的`addValue()`方法，记住`addValue()`方法将忽略任何它不认识的元素名称。
- en: We will also need to clear the `elementData` property each time we encounter
    the end of an element so that the information from the previous element does not
    corrupt the next element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们遇到一个元素的结束时，我们还需要清除`elementData`属性，以确保前一个元素的信息不会破坏下一个元素。
- en: 'The following example shows how we will implement the `parser(_: didEndElement:
    namespaceURI: qualifiedName:)` delegate method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '以下示例展示了我们将如何实现`parser(_: didEndElement: namespaceURI: qualifiedName:)`代理方法：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the parser has completed parsing the document, it will call the `parser(_:parseErrorOccurred:)`
    delegate method. In our example, we will use this method to simply print the name
    of the book and author to the screen for each book in the `books` array, as shown
    in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析器完成对文档的解析后，它将调用`parser(_:parseErrorOccurred:)`代理方法。在我们的例子中，我们将使用这个方法简单地打印出`books`数组中每本书的名称和作者到屏幕上，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If an error is encountered while parsing the document, the `parser:parseErrorOccurred:`
    delegate method is called to handle the error. In our example, we will print the
    error to the console, but normally we would need to properly handle the error:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在解析文档时遇到错误，将调用`parser:parseErrorOccurred:`代理方法来处理错误。在我们的例子中，我们将打印错误到控制台，但通常我们需要正确处理错误：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To parse an XML document, we will use the `MyXmlParser` class like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析一个XML文档，我们将使用`MyXmlParser`类，如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have seen how to parse an XML document, let's take a look at how
    we create one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何解析XML文档，让我们看看我们如何创建一个XML文档。
- en: XML and NSXMLDocument
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML和NSXMLDocument
- en: The `NSXMLDocument` class and its related classes make it very easy to create
    XML documents from our custom object; however, they are only available to OS X-based
    projects at the time of writing this book. Hopefully, someone at Apple will realize
    that we need a good way to build XML documents for iOS projects without using
    third-party frameworks or manually creating the document.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSXMLDocument`类及其相关类使得从我们的自定义对象创建XML文档变得非常容易；然而，在撰写本书时，它们仅适用于基于OS X的项目。希望苹果公司中有人会意识到我们需要一种好的方法来为iOS项目构建XML文档，而无需使用第三方框架或手动创建文档。'
- en: 'To build an XML document with Swift for OS X-based applications, we will need
    to use three foundation classes. These classes are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要为基于OS X的应用程序使用Swift构建XML文档，我们需要使用三个基础类。这些类如下：
- en: '`NSNode`: This class is the superclass of the `NSXMLDocument` and `NSXMLElement`
    classes. This will be used to add attributes to an instance of the `NSXMLElement`
    class.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSNode`：这个类是`NSXMLDocument`和`NSXMLElement`类的超类。这将用于向`NSXMLElement`类的实例添加属性。'
- en: '`NSXMLDocument`: This class is the top-level object for the XML document.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSXMLDocument`：这个类是XML文档的最高级对象。'
- en: '`NSXMLElement`: All the elements in the XML document are instances of the `NSXMLElement`
    class.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSXMLElement`：XML文档中的所有元素都是`NSXMLElement`类的实例。'
- en: 'Let''s see how to use these three classes to build an XML document. For this,
    we will create a function named `buildXMLString(books:)`, which takes an array
    of the `Book` objects as its only parameter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这三个类来构建一个XML文档。为此，我们将创建一个名为`buildXMLString(books:)`的函数，它接受一个`Book`对象数组作为其唯一参数：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the `books` parameter is defined as optional, we begin the `buildXMLString()`
    function by verifying it is not null using the `if let myBooks = books` line.
    If it is null, we return an empty string; otherwise, we begin building the XML
    document.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`books`参数被定义为可选的，我们在`buildXMLString()`函数的开始处使用`if let myBooks = books`行来验证它是否不为空。如果它是空的，我们返回一个空字符串；否则，我们开始构建XML文档。
- en: The initializer that we are using for the `NSXMLDocument` class requires the
    root element for the XML document; therefore, we will begin by creating the `xmlRoot`
    constant using the `BOOKS_TAG` constant and then using it to create an instance
    of the `NSXMLDocument` class. Next, we loop through each instance of the `Book`
    class in the `books` array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的`NSXMLDocument`类的初始化器需要XML文档的根元素；因此，我们将首先使用`BOOKS_TAG`常量创建`xmlRoot`常量，然后使用它来创建`NSXMLDocument`类的一个实例。接下来，我们将遍历`books`数组中的每个`Book`类实例。
- en: For each instance of the `Book` class, we create a new instance of the `NSXMLElement`
    class with the book name, which will contain the information about the book. This
    element will be the `<Book></Book>` element in our XML document. All the information
    about the book will either be an attribute of this element or a child element
    of this element.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Book`类的每个实例，我们创建一个新的`NSXMLElement`类实例，包含书名，这将包含关于书籍的信息。这个元素将是我们的XML文档中的`<Book></Book>`元素。关于书籍的所有信息要么是这个元素的属性，要么是这个元素的子元素。
- en: The name of the book is an attribute of the `book` element; therefore, we need
    to create an instance of the `NSXMLNode` class that contains the attribute's name
    and value. We do this with the `NXMLNode.attributeWithName()` function. We then
    add that attribute to the `book` element using the `addAttribute()` function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 书名是`book`元素的属性；因此，我们需要创建一个包含属性名称和值的`NSXMLNode`类实例。我们使用`NXMLNode.attributeWithName()`函数来完成此操作。然后我们使用`addAttribute()`函数将该属性添加到`book`元素中。
- en: Next, we add the remaining information about the book (`author`, `category`,
    `description`, and `publisher`) as child nodes to the `book` element using the
    `addChild()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`addChild()`函数将书籍的其余信息（`author`、`category`、`description`和`publisher`）作为子节点添加到`book`元素中。
- en: Finally, we convert the `NSXMLDocument` class to a string using the `XMLString`
    property and return that string to the code that called the function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`XMLString`属性将`NSXMLDocument`类转换为字符串，并将该字符串返回给调用该函数的代码。
- en: XML and manually building XML documents
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML和手动构建XML文档
- en: Since we are unable to use the `NSXMLNode`, `NSXMLDocument`, and `NSXMLElement`
    classes in iOS projects, we generally need to manually build the XML string or
    use third-party libraries. This method is error-prone and it requires us to have
    a very good knowledge of how XML documents are built but, if we are careful, we
    can create simple XML documents this way.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在iOS项目中使用`NSXMLNode`、`NSXMLDocument`和`NSXMLElement`类，我们通常需要手动构建XML字符串或使用第三方库。这种方法容易出错，并且需要我们非常了解XML文档是如何构建的，但如果我们小心，我们可以通过这种方式创建简单的XML文档。
- en: 'Let''s see how to manually create an XML document. For this, we will create
    a function named `builXMLString()`, which takes an array of `Book` objects as
    its only parameter. We will also create a helper class named `getElementString()`
    that will create a string representation of an XML element. The `getElementString()`
    function will accept two elements: the element name and value. Let''s have a look
    at the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何手动创建一个XML文档。为此，我们将创建一个名为`builXMLString()`的函数，它接受一个`Book`对象数组作为其唯一参数。我们还将创建一个名为`getElementString()`的辅助类，该类将创建一个XML元素的字符串表示形式。`getElementString()`函数将接受两个元素：元素名称和值。让我们看看以下代码：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the `books` parameter is defined as optional, we begin the `buildXMLString()`
    function by verifying it is not null with the `if let myBooks = books` line. If
    it is null, the function will return an empty string; otherwise, we begin building
    the XML document.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`books`参数被定义为可选的，我们在`buildXMLString()`函数的开始处使用`if let myBooks = books`行来验证它是否不为空。如果它是空的，函数将返回一个空字符串；否则，我们开始构建XML文档。
- en: In this class, we simply create strings that represent the XML tags and append
    them to the `xmlString` variable. The `xmlString` variable will contain the XML
    document at the end of the function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们只是创建表示XML标签的字符串，并将它们附加到`xmlString`变量。在函数结束时，`xmlString`变量将包含XML文档。
- en: The `getElementString()` function creates a string that contains the start tag
    for the element, followed by the value of the element and the end tag for the
    element. This function is used to add most of the XML elements in this example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementString()`函数创建一个包含元素开始标签、元素值和元素结束标签的字符串。此函数用于添加本例中的大多数XML元素。'
- en: As we can see, without an intimate knowledge of the syntax of XML documents,
    it would be virtually impossible to build complex documents with this method.
    We also need to be very careful to not to forget the closing tags at the end of
    an element.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，如果没有对XML文档语法的深入了解，几乎不可能使用这种方法构建复杂的文档。我们还需要非常小心，不要忘记在元素末尾的结束标签。
- en: JSON and NSJSONSerialization
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON和NSJSONSerialization
- en: To serialize and deserialize JSON documents, we will use the `NSJSONSerialization`
    class. As we will see, it is much easier to use the `NSJSONSerialization` class
    with JSON documents than it is to use the `NSXMLParser` class with XML documents;
    however, it can be more error-prone when we try to access the information. Just
    remember to always check values that are defined as optional for null prior to
    accessing them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了序列化和反序列化JSON文档，我们将使用`NSJSONSerialization`类。正如我们将看到的，使用`NSJSONSerialization`类与JSON文档相比，使用`NSXMLParser`类与XML文档相比要容易得多；然而，当我们尝试访问信息时，它可能会更容易出错。只需记住，在访问之前始终检查定义为可选的值是否为null。
- en: The `NSJSONSerialization` class, unlike the `NSXMLParser` class, will parse
    the entire JSON document memory and then return a JSON object; therefore, there
    is a lot less code to write but it is more memory-intensive, however.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与`NSXMLParser`类不同，`NSJSONSerialization`类将解析整个JSON文档内存，然后返回一个JSON对象；因此，需要编写的代码要少得多，但它的内存消耗也更大。
- en: 'The `NSJSONSerialization` class can parse JSON documents from an `NSData` object
    or through a stream. To parse JSON documents from the various sources, we use
    the `NSJSONSerialization` class with the appropriate static method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSJSONSerialization`类可以从`NSData`对象或通过流解析JSON文档。为了从各种来源解析JSON文档，我们使用`NSJSONSerialization`类和适当的静态方法：'
- en: '`JSONObjectWithData(_: options: error:)`: This initializer will parse a JSON
    document stored as an `NSData` object'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSONObjectWithData(_: options: error:)`: 此初始化器将解析存储为`NSData`对象的JSON文档'
- en: '`JSONObjectWithStream(_: options: error:)`: This initializer will parse a JSON
    document from a stream'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSONObjectWithStream(_: options: error:)`: 此初始化器将从流中解析JSON文档'
- en: 'The documentation for these two methods says that they return an optional of
    the `AnyObject` type. Generally, the results of these methods are in an instance
    of the `NSDictionary` or an `NSArray` class, depending on the JSON document. If
    you are unsure what type of object is being created, you can insert the following
    code, where the `jsonResponse` variable is the result returned from the two static
    methods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法的文档说明它们返回一个`AnyObject`类型的可选值。通常，这些方法的返回结果是在`NSDictionary`或`NSArray`类的实例中，具体取决于JSON文档。如果您不确定正在创建的对象类型，可以插入以下代码，其中`jsonResponse`变量是从两个静态方法返回的结果：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we use the `is` operator to check whether the response
    is of the `NSDictionary` or `NSArray` type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`is`运算符来检查响应是否为`NSDictionary`或`NSArray`类型。
- en: 'Unlike the `NSXMLParser` class, the `NSJSONSerialization` class can be used
    to also create JSON documents from a collection object. To do this, we will use
    the `dataWithJSONObject(_: options: error:)` initializer, which will serialize
    a JSON document from a collection object. While it is possible to use other objects
    besides collection objects to create the JSON document, a proper JSON document
    is usually in the format of a dictionary or an array.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '与`NSXMLParser`类不同，`NSJSONSerialization`类还可以用于从集合对象创建JSON文档。为此，我们将使用`dataWithJSONObject(_:
    options: error:)`初始化器，它将从集合对象序列化JSON文档。虽然可以使用除集合对象以外的其他对象来创建JSON文档，但一个合适的JSON文档通常是以字典或数组的格式。'
- en: 'In the JSON examples in this chapter, we will show you how to parse the following
    JSON document. This document contains the same information that was in the XML
    example, but it is stored as a JSON document now, as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 JSON 示例中，我们将向您展示如何解析以下 JSON 文档。该文档包含与 XML 示例中相同的信息，但现在它存储为一个 JSON 文档，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's see how to parse a JSON document that is stored as a string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何解析存储为字符串的 JSON 文档。
- en: Parsing a JSON document
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 JSON 文档
- en: 'In this section, we will use the `NSJSONSerialization` class to parse the previously
    shown JSON documents. The `jsonString` variable in this function represents the
    JSON document that was previously shown. This function will create an array of
    `Book` objects based on the information in the JSON document. At the end of the
    function, we will print out the information about the books to show that they
    were correctly parsed from the document, as well as return the array of books,
    as shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `NSJSONSerialization` 类来解析之前显示的 JSON 文档。此函数中的 `jsonString` 变量代表之前显示的
    JSON 文档。此函数将根据 JSON 文档中的信息创建一个 `Book` 对象数组。函数结束时，我们将打印出有关书籍的信息，以显示它们已正确解析自文档，以及返回书籍数组，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `parseJson()` function starts off by converting the `jsonString` variable
    that contains the JSON document to an `NSData` object so that we can parse it
    with the `NSJSONSerialization` object. Since the conversion results in an optional
    value, we need to verify that it is not null. We do this with the following line
    of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseJson()` 函数首先将包含 JSON 文档的 `jsonString` 变量转换为 `NSData` 对象，以便我们可以使用 `NSJSONSerialization`
    对象来解析它。由于转换结果是一个可选值，我们需要验证它是否不为空。我们使用以下代码来完成此操作：'
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the conversion was successful, we can then use the `JSONObjectWithData()`
    method of the `NSJSONSerialization` class to create the JSON object from the `NSData`
    object we just created.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换成功，我们就可以使用 `NSJSONSerialization` 类的 `JSONObjectWithData()` 方法从我们刚刚创建的 `NSData`
    对象中创建 JSON 对象。
- en: 'Knowing that in our JSON document, the root tag of `books` contains an array
    of books, we use the following line to attempt to retrieve the array from the
    JSON object we just created:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 知道在我们的 JSON 文档中，`books` 的根标签包含一个书籍数组，我们使用以下行尝试从我们刚刚创建的 JSON 对象中检索数组：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This line of code checks that the object is not null and is also an instance
    of the `NSArray` class. If the JSON object is supposed to contain an `NSDictionary`
    object, we would simply replace the `as? NSArray` with `as? NSDictionary`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码检查对象是否不为空，并且也是 `NSArray` 类的实例。如果 JSON 对象应该包含一个 `NSDictionary` 对象，我们只需将 `as?
    NSArray` 替换为 `as? NSDictionary`。
- en: 'If we were able to successfully retrieve the `NSArray` class from the JSON
    object, then we loop through each item of the `NSArray` class. In our example,
    each item of the `NSArray` class is in an instance of the `NSDictionary` class;
    however, it is always a good idea to verify this. To verify that each item is
    an instance of the `NSDictionary` class, we use the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够成功从 JSON 对象中检索到 `NSArray` 类，那么我们将遍历 `NSArray` 类中的每个项目。在我们的例子中，`NSArray`
    类的每个项目都是一个 `NSDictionary` 类的实例；然而，始终验证这一点是个好主意。为了验证每个项目是 `NSDictionary` 类的实例，我们使用以下代码：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once we have the `NSDictionary` object, we use the `addValueToBook()` function
    (that we will see in just a minute) to populate the properties of the `Book` class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `NSDictionary` 对象，我们就使用 `addValueToBook()` 函数（我们将在下一分钟看到）来填充 `Book` 类的属性。
- en: 'Finally, we end the function by printing out the name and author of each book
    that we extracted from the JSON document. Let''s take a look at the `addValueToBook()`
    function that we use to populate the properties of the `Book` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过打印出从 JSON 文档中提取的每本书的名称和作者来结束函数。让我们看看我们用来填充 `Book` 类属性的 `addValueToBook()`
    函数：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we attempt to extract a value from an `NSDictionary` object where the key
    does not exist, the `NSDictionary` object will return a null object. In this case,
    we need to verify that the value is not null prior to assigning it to a property
    that does not accept a null value. The `addValueToBook()` function verifies that
    the values are not null prior to adding them to the instance of the `Book` class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从一个键不存在的 `NSDictionary` 对象中提取值，`NSDictionary` 对象将返回一个空对象。在这种情况下，我们需要在将其分配给不接受空值的属性之前验证该值是否不为空。`addValueToBook()`
    函数在将值添加到 `Book` 类的实例之前验证这些值是否不为空。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `NSJSONSerialization` class, it is better to have too many checks
    rather than not enough. Just remember if we try to set a non-optional variable
    to nil or use an object that is nil, our application will crash. JSON documents
    are not type-safe; therefore, it is also advisable to check the types of the values
    returned to make sure they are of the expected type.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `NSJSONSerialization` 类时，最好进行过多的检查而不是不足。只需记住，如果我们尝试将非可选变量设置为 nil 或使用 nil
    的对象，我们的应用程序将会崩溃。JSON 文档不是类型安全的；因此，建议检查返回值的类型，以确保它们是预期的类型。
- en: Now, let's see how to create a JSON document with the `NSJSONSerialization`
    class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `NSJSONSerialization` 类创建 JSON 文档。
- en: Creating a JSON document
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 JSON 文档
- en: 'Creating a JSON document using the `NSJSONSerialization` class is incredibly
    easy but, once again, we need to do several checks to make sure nothing goes wrong.
    The following code will create a valid JSON document from any object that can
    be converted to JSON data, such as dictionaries and/or arrays:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NSJSONSerialization` 类创建 JSON 文档非常简单，但同样，我们需要进行几个检查以确保没有出错。以下代码将从任何可以转换为
    JSON 数据的对象（如字典和/或数组）创建有效的 JSON 文档：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do in the `buildJSON()` function is to verify that the `value`
    parameter is of a type that can be converted to a JSON object. We do this using
    the `isValidJSONObject()` function of the `NSJSONSerialization` class. This function
    will return a Boolean `true` value if the `value` parameter can be converted;
    otherwise, it will return a Boolean `false` value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `buildJSON()` 函数中，我们首先验证 `value` 参数是否为可以转换为 JSON 对象的类型。我们使用 `NSJSONSerialization`
    类的 `isValidJSONObject()` 函数来完成此操作。如果 `value` 参数可以转换，则该函数将返回布尔值 `true`；否则，它将返回布尔值
    `false`。
- en: If the `value` parameter can be converted to a JSON object, then we use the
    `dataWithJSONObject()` function of the `NSJSONSerialization` class to convert
    the value parameter to JSON data. If there is an issue with the conversion, the
    `dataWithJSONObject()` function throws an error, which is thrown back to the code
    that called the `buildJSON()` function..
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `value` 参数可以转换为 JSON 对象，那么我们使用 `NSJSONSerialization` 类的 `dataWithJSONObject()`
    函数将 `value` 参数转换为 JSON 数据。如果转换过程中出现问题，`dataWithJSONObject()` 函数将抛出一个错误，该错误将被抛回调用
    `buildJSON()` 函数的代码。
- en: Finally, we convert the JSON data to a `String` object and return it to the
    code that called the function. If anything goes wrong, we return an empty string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 JSON 数据转换为 `String` 对象，并将其返回给调用该函数的代码。如果发生任何错误，我们将返回一个空字符串。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that it takes a lot less code to parse/build JSON objects
    with the `NSJSONSerialization` class as compared to parsing/building XML objects.
    However, we do have a lot more control on how the document is parsed using the
    `NSXMLParser` class. The key thing to keep in mind with both the `NSJSONSerialization`
    class and the `NSXMLParser` class is that we need to remember to check that optional
    variables do not contain a nil value, before attempting to use them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到使用 `NSJSONSerialization` 类解析/构建 JSON 对象所需的代码比解析/构建 XML 对象少得多。然而，我们确实对使用
    `NSXMLParser` 类如何解析文档有更多的控制。在使用 `NSJSONSerialization` 类和 `NSXMLParser` 类时，需要记住的关键点是，在尝试使用之前，我们需要检查可选变量是否不包含
    nil 值。
- en: While it seems that the majority of newer services are using the JSON format
    over XML, it is good to have a working knowledge of both formats because there
    is still a large percentage of services that use XML.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来大多数新的服务都在使用 JSON 格式而不是 XML，但了解这两种格式都是有益的，因为仍然有大量服务使用 XML。
