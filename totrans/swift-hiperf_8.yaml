- en: Chapter 8. Discovering All the Underlying Swift Power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we covered many topics about Swift, its powerful features,
    and how to improve an application''s performance and make a solid application
    architecture. In this chapter, we will take a look at some tools and cover these
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Swift is so fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swift compiler and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the assembly code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A recap of the important information learned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Swift is so fast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's have a quick recap—that is, *why Swift is swift*—and see what is
    so special about Swift and its cool features.
  prefs: []
  type: TYPE_NORMAL
- en: Swift is a strongly typed compiled programming language. This makes it a very
    safe programming language. Swift is very strict about types, and it verifies that
    all types are used correctly in the source code. It catches a large number of
    issues at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Swift is also a static programming language. Its source code is compiled to
    the assembly code and the assembly code is compiled to the machine code using
    the LLVM tool. Running native machine code instructions is the fastest way of
    doing this. In comparison, Java and C# are compiled to a piece of intermediate
    code, and it needs a virtual machine to run it, or another tool that will translate
    it into machine instructions. Because Swift doesn't do this at runtime, it has
    a very big performance gain.
  prefs: []
  type: TYPE_NORMAL
- en: By mixing strongly typed rules and compiling to assembly code, Swift is able
    to analyze code very well and perform very good assembly code optimization. Swift
    is also built to be nice to write, with a pleasant and clean syntax and modern
    features and types. This unique combination of syntax, powerful features, safety,
    and performance makes Swift a very amazing programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Swift command line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have already worked with a terminal tool—a Swift REPL console.
    We start it by entering the `xcrun swift` command in the terminal. It starts the
    REPL, and we can enter Swift code and evaluate it.
  prefs: []
  type: TYPE_NORMAL
- en: xcrun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start a REPL, we actually used two tools: `xcrun` and `swift`. `xcrun` is
    an Xcode command-line tool runner. It helps you run a command-line tool by its
    name from the active developer directory. When you have installed many versions
    of Xcode, you can select which one to use while executing a command-line tool.
    You can do this in Xcode by going to **Xcode** | **Preference** | **Locations**
    | **Command Line Tools**, or by running the `xcode-select` command from the terminal.
    In this way, `xcrun` allows you to avoid specifying the full path in the command-line
    tool you want to run, and makes the process of running it much simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: '`xcrun` has a few more interesting options, and you should experiment with
    them. To get help, run the `xcrun -h` help command, which is usually available
    for most other command-line tools as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some command-line tools require the use of the full command notation: `–help`.
    An example of this is `xcrun --help`.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that by running the `xcrun swift` command, we are actually launching
    a `swift` command-line tool. If you run the `xcrun swift -h` command to get help,
    you will see that `swift` is actually a Swift compiler that has many options to
    choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other interesting feature that is available in `xcrun` is getting a path
    to the tool by its name. This is very useful because in this way, we can explore
    the folder in which this tool is located and find other available tools. As an
    example, let''s see the `swift` command-line tool''s location. To do this, you
    need to run the `xcrun -f swift` command, and the result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simply open this folder from the terminal by changing the directory
    with `cd` and executing the `open .` command, which will open the current directory
    from the terminal in the finder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this folder, there are more than 50 different command-line tools available,
    such as `libtool`, `otool`, `swift`, `swift-demangle`, and others. There is also
    another directory that contains many interesting tools, such as `ibtool`, `simctl`,
    and `xcrun`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are not going to cover all of them here; we will leave it as homework for
    you to play with them and explore their power.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of discovering tools that are available for running in the current
    directory through `xcrun` is by starting to type the commands and pressing the
    *Tab* key. This will show suggestions from the available commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![xcrun](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Swift compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous step, while playing with `xcrun`, we discovered that there
    are two different swift compiler tools: `swift` and `swiftc`. If you get help
    for with the `-h` command, you will notice that they are both Swift compilers
    with similar options, but there is a difference.'
  prefs: []
  type: TYPE_NORMAL
- en: swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `swift` tool compiles and executes swift code. If you run it without any
    arguments, it will launch a REPL and give you the ability to evaluate the Swift
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![swift](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also pass a Swift file that you want to run as a parameter. We can
    simply create a swift file from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass additional options, such as `-O` to enable optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: swiftc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `swiftc` compiler compiles swift code and produces the result, but it doesn't
    execute it. Depending on the option, you can get a binary file, an assembly, an
    LLVM IR representation, or something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the swift tool, `swiftc` has a one required parameter: an input swift
    file. If you try to run it without this parameter, you will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run it and pass a Swift file as a parameter, it will produce an executable
    file. Let''s use the same `main.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you get an executable file with the same name—`main`. If you run
    it, you will get the same output, `Hello World`, in the console. The interesting
    thing about `swiftc` is that it allows you to pass many Swift files as input,
    compile them together, and produce the executable. Let''s create one more swift
    file, called `file.swift`, and add this function to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will edit our `main.swift` file and the call to the `bye()` function
    in it. If we try to compile the `main.swift` file now, it will show us an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Not surprisingly, the Swift compiler can''t find the `bye` function declaration
    and so it fails. What we need to do is compile both the `file.swift` and `main.swift`
    files at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of the files that you pass to `swiftc` is not important; we could
    have called them as `swiftc file.swift main.swift` as well. If you run this executable
    file now, you will see two sentences in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you know how to use a Swift compiler, let''s move on to the fun part.
    Let''s use a swift compiler to produce different results. For simplicity, we will
    merge our swift code with the `main.swift` file and add more instructions to get
    a more interesting result. Here is the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Swift compilation process and swiftc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compilation of the Swift source code is quite an interesting process, and
    it involves several steps. The Swift compiler uses LLVM for optimization and binary
    generation. To better understand the entire process, refer to this flow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Swift compilation process and swiftc](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: First, the Swift source code is transformed into an **AST** (short for **Abstract
    Syntax Tree**). Then, it is transformed into **SIL** (short for **Swift Intermediate
    Language**), first into a raw SIL and then into a canonical SIL. After that, it
    is transformed into LLVM **IR** (short for **Intermediate Representation**). In
    this step, LLVM takes care of the rest. It takes IR, does an optimization, and
    produces an assembly and, after that, an executable for a specific architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part in preceding diagram is the steps for generating SIL. It's
    a Swift-specific optimization and it was created specifically for swift. Other
    programming languages, such as C, don't do this optimization before they generate
    LLVM IR, and they have one less optimization step.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Swift compilation process and swiftc](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With `swiftc`, it's possible to generate the results for each of those steps.
    It's incredibly useful for code optimization analysis. To see all the available
    modes, just run `xcrun swiftc -h`. Now, let's quickly take a look on them.
  prefs: []
  type: TYPE_NORMAL
- en: Swift AST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swiftc has three different options for generating AST. Each of them generates
    AST with different levels of details. The AST code representation shows us how
    the Swift compiler sees and analyzes the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `-dump-ast` contains the maximum details, and it could be hard
    to analyze. Let''s take a look at the `-dump-parse` example first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This AST code represents the `var a = 10` Swift code. Each instruction is parsed
    into a separate tree node and then put together in a tree representation. You
    can find more information about Clang's AST at [http://clang.llvm.org/docs/IntroductionToTheClangAST.html](http://clang.llvm.org/docs/IntroductionToTheClangAST.html).
  prefs: []
  type: TYPE_NORMAL
- en: SIL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Swift Intermediate Language** (**SIL**) is one of the most useful tools
    for analyzing Swift code. It contains many details and is very readable and easy
    to analyze. For generating a SIL, xcrun has two modes; `-emit-silgen` generates
    raw SIL and `-emit-sil` generates canonical SIL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Raw SIL and canonical SIL are almost the same. Raw SIL is a bit simpler and
    it doesn''t include the details of private function implementations and some global
    objects. Let''s take a look at the generated raw SIL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A really nice feature of SIL is that it contains comments that explain the
    generated code. The `let a: Int` statement would be translated into `@_Tv4main1aSi
    : $Int` and we can see this from the comment that stays above the generated SIL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The SIL represents Swift code in a mangled format. The names contain a lot of
    information about the type, the count of symbols in the name, and so on. Some
    mangled names can be very long and really hard to read, such as `_TZvOSs7Process11_unsafeArgvGVSs20UnsafeMutablePointerGS0_VSs4Int8__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demangle a name back to its normal notation with the `swift-demangle`
    tool. Let''s try to demangle `@_Tv4main1aSi` and see whether it really translates
    into `main.a : Swift.Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you want to learn more about name mangling, you can read a great post about
    it written by Mike Ash at [https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html](https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html).
  prefs: []
  type: TYPE_NORMAL
- en: LLVM IR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Intermediate Representation** (**IR**) is a more low-level code representation.
    It is not as human-friendly and readable as SIL. This is because it has more information
    for the compiler than for humans. We can use IR to compare different programming
    languages. To get Swift''s IR, use the `-emit-ir` options, and to get IR for C,
    we can use `clang -emit-llvm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Other swiftc options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `swiftc` compiler is very powerful and has many more modes and options.
    You can create an assembly, a binary, a linked library, and object files. You
    can also specify many options, such as an output file with the `-o` option, optimization
    `-O`, `-Onone`, and many others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing executable files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very difficult to analyze the assembly code generated by the swiftc compiler.
    To make our lives easier, we will use a Hopper Disassembler tool to disassemble
    executable files, generating a piece of pseudocode and analyzing it. You can download
    the free version of Hopper from [http://www.hopperapp.com](http://www.hopperapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: The Hopper Disassembler tool can work with binary, executable, and object files.
    The easiest way of using it is by generating an executable file with the `swiftc
    main.swift` command and opening it in Hopper. You can simply drag and drop the
    `main` executable file to open it in Hopper.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing executable files](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the left-hand side, you can find all the labels for functions and variables
    and navigate to them. The search feature is very useful when you are analyzing
    a big project with many functions. In the center is an assembly code; you can
    press *Alt* + *Enter* to see the pseudocode for the current procedure. It is much
    easier to analyze high-level pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compile an application in Xcode and disassemble our `SimpleApp.app`
    in Hopper. This allows us to analyze very large and complex applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an experiment, let''s compile the same swift file in two ways—with optimization
    enabled and without it—and compare the generated assembly code. Thus, you will
    see the power of the optimization option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter illustrated the Swift compiler, command-line tools, and the process
    of compilation of the Swift source code. Knowing the available tools and mastering
    them is very important because it makes you much more productive. Xcode has many
    tools, and we showed you how to find and use them.
  prefs: []
  type: TYPE_NORMAL
- en: For analyzing and optimizing Swift code, it's very useful to know and understand
    the compilation process. In this chapter, we took you through an entire journey
    of the Swift compiler, starting from the source code and ending with the executable
    file. We also showed you how to get the result for a specific complication step,
    such as getting the SIL or IR code representation.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our learning journey in this book comes to an end, and now you have mastered
    Swift's techniques for creating high-performance applications. Let's have a quick
    recap.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have learned how to use the power of Swift and optimize your Swift
    code, but you should remember the main rule of optimization—optimize only when
    needed, not upfront.
  prefs: []
  type: TYPE_NORMAL
- en: Solid architecture and well-structured and clean code are two of the most important
    characteristics of a good application. We have been expressing this throughout
    the book, and an entire chapter ([Chapter 2](part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0
    "Chapter 2. Making a Good Application Architecture in Swift"), *Making a Good
    Application Architecture in Swift*) was dedicated to it.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization doesn't always have to bring much complexity to the
    source code. Sometimes, applying small changes, such as adding the `@noescape`
    attribute, removing a few `print` statements, using the correct data structures,
    and other techniques presented in the book, could improve performance with no
    negative effect on the source code. Sometimes, the source code can become even
    cleaner and more readable; for example, by using `@noescape`, we don't need to
    explicitly specify `self.` when referencing instance members.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Swift's features and tools that are at your disposal before you start
    creating an application is very important. It is much easier to create a good
    application from the start by spending some time on planning and preparation than
    to try to refactor it and fix performance and code architecture issues later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready for the journey of creating incredible applications with
    Swift!
  prefs: []
  type: TYPE_NORMAL
