- en: Chapter 8. Discovering All the Underlying Swift Power
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 发现所有 Swift 的潜在力量
- en: 'In previous chapters, we covered many topics about Swift, its powerful features,
    and how to improve an application''s performance and make a solid application
    architecture. In this chapter, we will take a look at some tools and cover these
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了许多关于 Swift、其强大功能和如何提高应用程序性能以及构建稳固的应用程序架构的话题。在本章中，我们将探讨一些工具并涵盖以下主题：
- en: How Swift is so fast
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 为什么会这么快
- en: The Swift compiler and tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 编译器和工具
- en: Analyzing the assembly code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析汇编代码
- en: A recap of the important information learned
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾学习的重要信息
- en: Feature reading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能阅读
- en: How Swift is so fast
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 为什么会这么快
- en: First, let's have a quick recap—that is, *why Swift is swift*—and see what is
    so special about Swift and its cool features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速回顾一下——也就是*为什么 Swift 会这么快*——并看看 Swift 及其酷炫功能有什么特别之处。
- en: Swift is a strongly typed compiled programming language. This makes it a very
    safe programming language. Swift is very strict about types, and it verifies that
    all types are used correctly in the source code. It catches a large number of
    issues at compile time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种强类型编译型编程语言。这使得它成为一个非常安全的编程语言。Swift 对类型非常严格，并验证源代码中所有类型的使用是否正确。它在编译时捕捉了大量问题。
- en: Swift is also a static programming language. Its source code is compiled to
    the assembly code and the assembly code is compiled to the machine code using
    the LLVM tool. Running native machine code instructions is the fastest way of
    doing this. In comparison, Java and C# are compiled to a piece of intermediate
    code, and it needs a virtual machine to run it, or another tool that will translate
    it into machine instructions. Because Swift doesn't do this at runtime, it has
    a very big performance gain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 也是一种静态编程语言。它的源代码被编译成汇编代码，然后使用 LLVM 工具将汇编代码编译成机器代码。运行本机机器代码指令是完成这项任务最快的方式。相比之下，Java
    和 C# 被编译成一段中间代码，需要虚拟机来运行，或者另一个将其翻译成机器指令的工具。因为 Swift 在运行时不会这样做，所以它有非常大的性能提升。
- en: By mixing strongly typed rules and compiling to assembly code, Swift is able
    to analyze code very well and perform very good assembly code optimization. Swift
    is also built to be nice to write, with a pleasant and clean syntax and modern
    features and types. This unique combination of syntax, powerful features, safety,
    and performance makes Swift a very amazing programming language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过混合强类型规则和编译成汇编代码，Swift 能够很好地分析代码并执行很好的汇编代码优化。Swift 还被构建得易于编写，拥有愉快且干净的语法、现代特性和类型。这种独特的语法、强大功能、安全性和性能的组合使
    Swift 成为一个非常出色的编程语言。
- en: Swift command line tools
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 命令行工具
- en: In this book, we have already worked with a terminal tool—a Swift REPL console.
    We start it by entering the `xcrun swift` command in the terminal. It starts the
    REPL, and we can enter Swift code and evaluate it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经使用了一个终端工具——Swift REPL 控制台。我们通过在终端中输入 `xcrun swift` 命令来启动它。它启动了 REPL，然后我们可以输入
    Swift 代码并评估它。
- en: xcrun
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xcrun
- en: 'To start a REPL, we actually used two tools: `xcrun` and `swift`. `xcrun` is
    an Xcode command-line tool runner. It helps you run a command-line tool by its
    name from the active developer directory. When you have installed many versions
    of Xcode, you can select which one to use while executing a command-line tool.
    You can do this in Xcode by going to **Xcode** | **Preference** | **Locations**
    | **Command Line Tools**, or by running the `xcode-select` command from the terminal.
    In this way, `xcrun` allows you to avoid specifying the full path in the command-line
    tool you want to run, and makes the process of running it much simpler.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个 REPL，我们实际上使用了两个工具：`xcrun` 和 `swift`。`xcrun` 是一个 Xcode 命令行工具运行器。它可以帮助你通过名称从活动开发者目录中运行命令行工具。当你安装了多个版本的
    Xcode 时，你可以在执行命令行工具时选择使用哪一个。你可以在 Xcode 中通过访问**Xcode** | **偏好设置** | **位置** | **命令行工具**，或者通过在终端中运行
    `xcode-select` 命令来实现。这样，`xcrun` 允许你避免在要运行的命令行工具中指定完整路径，并使运行过程变得更加简单。
- en: '`xcrun` has a few more interesting options, and you should experiment with
    them. To get help, run the `xcrun -h` help command, which is usually available
    for most other command-line tools as well.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`xcrun` 有一些更有趣的选项，你应该尝试一下。要获取帮助，请运行 `xcrun -h` 帮助命令，这个命令通常对大多数其他命令行工具也是可用的。'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Some command-line tools require the use of the full command notation: `–help`.
    An example of this is `xcrun --help`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令行工具需要使用完整的命令表示法：`–help`。一个例子是 `xcrun --help`。
- en: This means that by running the `xcrun swift` command, we are actually launching
    a `swift` command-line tool. If you run the `xcrun swift -h` command to get help,
    you will see that `swift` is actually a Swift compiler that has many options to
    choose from.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通过运行 `xcrun swift` 命令，我们实际上是在启动一个 `swift` 命令行工具。如果你运行 `xcrun swift -h` 命令以获取帮助，你会看到
    `swift` 实际上是一个具有许多选项可供选择的 Swift 编译器。
- en: 'The other interesting feature that is available in `xcrun` is getting a path
    to the tool by its name. This is very useful because in this way, we can explore
    the folder in which this tool is located and find other available tools. As an
    example, let''s see the `swift` command-line tool''s location. To do this, you
    need to run the `xcrun -f swift` command, and the result is this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `xcrun` 中可用的另一个有趣的功能是通过名称获取工具的路径。这非常有用，因为这样我们可以探索这个工具所在的文件夹，并找到其他可用的工具。例如，让我们看看
    `swift` 命令行工具的位置。为此，你需要运行 `xcrun -f swift` 命令，结果如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can simply open this folder from the terminal by changing the directory
    with `cd` and executing the `open .` command, which will open the current directory
    from the terminal in the finder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改目录使用 `cd` 命令并执行 `open .` 命令简单地从这个终端打开这个文件夹：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this folder, there are more than 50 different command-line tools available,
    such as `libtool`, `otool`, `swift`, `swift-demangle`, and others. There is also
    another directory that contains many interesting tools, such as `ibtool`, `simctl`,
    and `xcrun`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，有超过 50 个不同的命令行工具可用，例如 `libtool`、`otool`、`swift`、`swift-demangle` 以及其他工具。还有一个包含许多有趣工具的另一个目录，例如
    `ibtool`、`simctl` 和 `xcrun`：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are not going to cover all of them here; we will leave it as homework for
    you to play with them and explore their power.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里涵盖所有这些；我们将把它们留给你作为作业去探索它们的强大功能。
- en: Another way of discovering tools that are available for running in the current
    directory through `xcrun` is by starting to type the commands and pressing the
    *Tab* key. This will show suggestions from the available commands.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种通过 `xcrun` 在当前目录中查找可运行工具的方法是开始输入命令并按 *Tab* 键。这将显示可用命令的建议。
- en: '![xcrun](img/00027.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![xcrun](img/00027.jpeg)'
- en: The Swift compiler
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 编译器
- en: 'In the previous step, while playing with `xcrun`, we discovered that there
    are two different swift compiler tools: `swift` and `swiftc`. If you get help
    for with the `-h` command, you will notice that they are both Swift compilers
    with similar options, but there is a difference.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中，当我们玩弄 `xcrun` 时，我们发现有两个不同的 Swift 编译器工具：`swift` 和 `swiftc`。如果你使用 `-h` 命令获取帮助，你会注意到它们都是具有相似选项的
    Swift 编译器，但存在一些差异。
- en: swift
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: swift
- en: The `swift` tool compiles and executes swift code. If you run it without any
    arguments, it will launch a REPL and give you the ability to evaluate the Swift
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`swift` 工具用于编译和执行 Swift 代码。如果你不带任何参数运行它，它将启动一个交互式解释器（REPL），并给你评估 Swift 代码的能力。'
- en: '![swift](img/00028.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![swift](img/00028.jpeg)'
- en: 'You can also pass a Swift file that you want to run as a parameter. We can
    simply create a swift file from the command line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递一个你想要运行的 Swift 文件作为参数。我们可以简单地从命令行创建一个 Swift 文件：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also pass additional options, such as `-O` to enable optimization:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递额外的选项，例如 `-O` 以启用优化：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: swiftc
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: swiftc
- en: The `swiftc` compiler compiles swift code and produces the result, but it doesn't
    execute it. Depending on the option, you can get a binary file, an assembly, an
    LLVM IR representation, or something else.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`swiftc` 编译器编译 Swift 代码并生成结果，但它不会执行它。根据选项的不同，你可以得到一个二进制文件、汇编、LLVM IR 表示或其它。'
- en: 'Unlike the swift tool, `swiftc` has a one required parameter: an input swift
    file. If you try to run it without this parameter, you will get an error:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `swift` 工具不同，`swiftc` 有一个必需的参数：一个输入的 Swift 文件。如果你尝试不传递此参数运行它，你会得到一个错误：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run it and pass a Swift file as a parameter, it will produce an executable
    file. Let''s use the same `main.swift` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它并传递一个 Swift 文件作为参数，它将生成一个可执行文件。让我们使用相同的 `main.swift` 文件：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a result, you get an executable file with the same name—`main`. If you run
    it, you will get the same output, `Hello World`, in the console. The interesting
    thing about `swiftc` is that it allows you to pass many Swift files as input,
    compile them together, and produce the executable. Let''s create one more swift
    file, called `file.swift`, and add this function to it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，你将得到一个与名称相同的可执行文件——`main`。如果你运行它，你将在控制台得到相同的输出，`Hello World`。关于`swiftc`的有趣之处在于，它允许你传递许多Swift文件作为输入，将它们一起编译，并生成可执行文件。让我们再创建一个Swift文件，命名为`file.swift`，并将此函数添加到其中：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will edit our `main.swift` file and the call to the `bye()` function
    in it. If we try to compile the `main.swift` file now, it will show us an error:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑我们的`main.swift`文件以及其中的`bye()`函数调用。如果我们现在尝试编译`main.swift`文件，它将显示一个错误：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Not surprisingly, the Swift compiler can''t find the `bye` function declaration
    and so it fails. What we need to do is compile both the `file.swift` and `main.swift`
    files at the same time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，Swift编译器找不到`bye`函数声明，因此它失败了。我们需要做的是同时编译`file.swift`和`main.swift`文件：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The order of the files that you pass to `swiftc` is not important; we could
    have called them as `swiftc file.swift main.swift` as well. If you run this executable
    file now, you will see two sentences in the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给`swiftc`的文件顺序并不重要；我们也可以将它们命名为`swiftc file.swift main.swift`。如果你现在运行这个可执行文件，你将在控制台看到两个句子：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that you know how to use a Swift compiler, let''s move on to the fun part.
    Let''s use a swift compiler to produce different results. For simplicity, we will
    merge our swift code with the `main.swift` file and add more instructions to get
    a more interesting result. Here is the final code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用Swift编译器，让我们继续到有趣的部分。让我们使用Swift编译器来产生不同的结果。为了简单起见，我们将我们的Swift代码与`main.swift`文件合并，并添加更多指令以获得更有趣的结果。以下是最终的代码：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Swift compilation process and swiftc
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift编译过程和swiftc
- en: 'The compilation of the Swift source code is quite an interesting process, and
    it involves several steps. The Swift compiler uses LLVM for optimization and binary
    generation. To better understand the entire process, refer to this flow diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Swift源代码的编译过程相当有趣，涉及多个步骤。Swift编译器使用LLVM进行优化和二进制生成。为了更好地理解整个过程，请参考此流程图：
- en: '![The Swift compilation process and swiftc](img/00029.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![The Swift compilation process and swiftc](img/00029.jpeg)'
- en: First, the Swift source code is transformed into an **AST** (short for **Abstract
    Syntax Tree**). Then, it is transformed into **SIL** (short for **Swift Intermediate
    Language**), first into a raw SIL and then into a canonical SIL. After that, it
    is transformed into LLVM **IR** (short for **Intermediate Representation**). In
    this step, LLVM takes care of the rest. It takes IR, does an optimization, and
    produces an assembly and, after that, an executable for a specific architecture.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Swift源代码被转换为一个**AST**（抽象语法树）。然后，它被转换为一个**SIL**（Swift中间语言），首先是一个原始SIL，然后是一个规范SIL。之后，它被转换为一个LLVM
    **IR**（中间表示）。在这一步中，LLVM负责剩下的工作。它处理IR，进行优化，并生成一个汇编，然后为特定架构生成一个可执行文件。
- en: The interesting part in preceding diagram is the steps for generating SIL. It's
    a Swift-specific optimization and it was created specifically for swift. Other
    programming languages, such as C, don't do this optimization before they generate
    LLVM IR, and they have one less optimization step.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，有趣的部分是生成SIL的步骤。这是一个Swift特有的优化，它专门为Swift创建。其他编程语言，如C，在生成LLVM IR之前不会进行这种优化，并且它们少了一个优化步骤。
- en: '![The Swift compilation process and swiftc](img/00030.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![The Swift compilation process and swiftc](img/00030.jpeg)'
- en: With `swiftc`, it's possible to generate the results for each of those steps.
    It's incredibly useful for code optimization analysis. To see all the available
    modes, just run `xcrun swiftc -h`. Now, let's quickly take a look on them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`swiftc`，可以生成每个步骤的结果。这对于代码优化分析非常有用。要查看所有可用模式，只需运行`xcrun swiftc -h`。现在，让我们快速看一下它们。
- en: Swift AST
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift AST
- en: 'Swiftc has three different options for generating AST. Each of them generates
    AST with different levels of details. The AST code representation shows us how
    the Swift compiler sees and analyzes the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Swiftc有三种不同的选项用于生成AST。每个选项都生成不同详细程度的AST。AST代码表示显示了Swift编译器如何查看和分析代码：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of `-dump-ast` contains the maximum details, and it could be hard
    to analyze. Let''s take a look at the `-dump-parse` example first:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`-dump-ast`命令的输出包含最大细节，可能难以分析。我们先来看一下`-dump-parse`的示例：'
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This AST code represents the `var a = 10` Swift code. Each instruction is parsed
    into a separate tree node and then put together in a tree representation. You
    can find more information about Clang's AST at [http://clang.llvm.org/docs/IntroductionToTheClangAST.html](http://clang.llvm.org/docs/IntroductionToTheClangAST.html).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 AST 代码代表了 `var a = 10` Swift 代码。每条指令都被解析成单独的树节点，然后组合成树形表示。你可以在 [http://clang.llvm.org/docs/IntroductionToTheClangAST.html](http://clang.llvm.org/docs/IntroductionToTheClangAST.html)
    找到更多关于 Clang 的 AST 信息。
- en: SIL
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SIL
- en: 'The **Swift Intermediate Language** (**SIL**) is one of the most useful tools
    for analyzing Swift code. It contains many details and is very readable and easy
    to analyze. For generating a SIL, xcrun has two modes; `-emit-silgen` generates
    raw SIL and `-emit-sil` generates canonical SIL:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift 中间语言**（**SIL**）是分析 Swift 代码最有用的工具之一。它包含许多细节，非常可读且易于分析。为了生成 SIL，xcrun
    有两种模式；`-emit-silgen` 生成原始 SIL，`-emit-sil` 生成规范 SIL：'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Raw SIL and canonical SIL are almost the same. Raw SIL is a bit simpler and
    it doesn''t include the details of private function implementations and some global
    objects. Let''s take a look at the generated raw SIL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 SIL 和规范 SIL 几乎相同。原始 SIL 简单一些，它不包括私有函数实现的细节和一些全局对象。让我们看看生成的原始 SIL：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A really nice feature of SIL is that it contains comments that explain the
    generated code. The `let a: Int` statement would be translated into `@_Tv4main1aSi
    : $Int` and we can see this from the comment that stays above the generated SIL:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'SIL 的一个真正不错的特性是它包含注释，解释生成的代码。`let a: Int` 语句会被翻译成 `@_Tv4main1aSi : $Int`，我们可以从位于生成的
    SIL 上方的注释中看到这一点：'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The SIL represents Swift code in a mangled format. The names contain a lot of
    information about the type, the count of symbols in the name, and so on. Some
    mangled names can be very long and really hard to read, such as `_TZvOSs7Process11_unsafeArgvGVSs20UnsafeMutablePointerGS0_VSs4Int8__`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SIL 以混淆格式表示 Swift 代码。名称包含大量关于类型、名称中符号的数量等信息。一些混淆名称可能非常长，难以阅读，例如 `_TZvOSs7Process11_unsafeArgvGVSs20UnsafeMutablePointerGS0_VSs4Int8__`。
- en: 'We can demangle a name back to its normal notation with the `swift-demangle`
    tool. Let''s try to demangle `@_Tv4main1aSi` and see whether it really translates
    into `main.a : Swift.Int`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用 `swift-demangle` 工具将名称反混淆回其正常表示。让我们尝试反混淆 `@_Tv4main1aSi` 并看看它是否真的翻译成
    `main.a : Swift.Int`：'
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you want to learn more about name mangling, you can read a great post about
    it written by Mike Ash at [https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html](https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于名称混淆的信息，你可以阅读 Mike Ash 写的一篇关于它的精彩文章，链接为 [https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html](https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html)。
- en: LLVM IR
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLVM IR
- en: '**Intermediate Representation** (**IR**) is a more low-level code representation.
    It is not as human-friendly and readable as SIL. This is because it has more information
    for the compiler than for humans. We can use IR to compare different programming
    languages. To get Swift''s IR, use the `-emit-ir` options, and to get IR for C,
    we can use `clang -emit-llvm`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间表示**（**IR**）是一种更底层的代码表示。它不如 SIL 人类友好和可读。这是因为它为编译器提供了比人类更多的信息。我们可以使用 IR
    来比较不同的编程语言。要获取 Swift 的 IR，使用 `-emit-ir` 选项，要获取 C 的 IR，我们可以使用 `clang -emit-llvm`：'
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Other swiftc options
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 swiftc 选项
- en: 'The `swiftc` compiler is very powerful and has many more modes and options.
    You can create an assembly, a binary, a linked library, and object files. You
    can also specify many options, such as an output file with the `-o` option, optimization
    `-O`, `-Onone`, and many others:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`swiftc` 编译器非常强大，拥有许多模式和选项。你可以创建汇编、二进制文件、链接库和对象文件。你还可以指定许多选项，例如使用 `-o` 选项指定输出文件、优化
    `-O`、`-Onone` 以及许多其他选项：'
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Analyzing executable files
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析可执行文件
- en: It is very difficult to analyze the assembly code generated by the swiftc compiler.
    To make our lives easier, we will use a Hopper Disassembler tool to disassemble
    executable files, generating a piece of pseudocode and analyzing it. You can download
    the free version of Hopper from [http://www.hopperapp.com](http://www.hopperapp.com).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 swiftc 编译器生成的汇编代码非常困难。为了使我们的工作更轻松，我们将使用 Hopper Disassembler 工具来反汇编可执行文件，生成伪代码并进行分析。你可以从
    [http://www.hopperapp.com](http://www.hopperapp.com) 下载 Hopper 的免费版本。
- en: The Hopper Disassembler tool can work with binary, executable, and object files.
    The easiest way of using it is by generating an executable file with the `swiftc
    main.swift` command and opening it in Hopper. You can simply drag and drop the
    `main` executable file to open it in Hopper.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Hopper 反汇编工具可以与二进制、可执行和对象文件一起工作。使用它的最简单方法是使用 `swiftc main.swift` 命令生成一个可执行文件，然后在
    Hopper 中打开它。您只需将 `main` 可执行文件拖放到 Hopper 中即可打开。
- en: '![Analyzing executable files](img/00031.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![分析可执行文件](img/00031.jpeg)'
- en: On the left-hand side, you can find all the labels for functions and variables
    and navigate to them. The search feature is very useful when you are analyzing
    a big project with many functions. In the center is an assembly code; you can
    press *Alt* + *Enter* to see the pseudocode for the current procedure. It is much
    easier to analyze high-level pseudocode.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，您可以找到所有函数和变量的标签，并导航到它们。当您分析一个具有许多函数的大项目时，搜索功能非常有用。在中间是汇编代码；您可以按 *Alt* +
    *Enter* 来查看当前过程的伪代码。分析高级伪代码要容易得多。
- en: We can also compile an application in Xcode and disassemble our `SimpleApp.app`
    in Hopper. This allows us to analyze very large and complex applications as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 Xcode 中编译应用程序，并在 Hopper 中反汇编我们的 `SimpleApp.app`。这使得我们能够分析非常庞大和复杂的应用程序。
- en: 'As an experiment, let''s compile the same swift file in two ways—with optimization
    enabled and without it—and compare the generated assembly code. Thus, you will
    see the power of the optimization option:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项实验，让我们以两种方式编译相同的 swift 文件——启用优化和不启用优化——并比较生成的汇编代码。这样，您将看到优化选项的力量：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter illustrated the Swift compiler, command-line tools, and the process
    of compilation of the Swift source code. Knowing the available tools and mastering
    them is very important because it makes you much more productive. Xcode has many
    tools, and we showed you how to find and use them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Swift 编译器、命令行工具以及 Swift 源代码的编译过程。了解可用的工具并掌握它们非常重要，因为它会使你更加高效。Xcode 有许多工具，我们向您展示了如何找到并使用它们。
- en: For analyzing and optimizing Swift code, it's very useful to know and understand
    the compilation process. In this chapter, we took you through an entire journey
    of the Swift compiler, starting from the source code and ending with the executable
    file. We also showed you how to get the result for a specific complication step,
    such as getting the SIL or IR code representation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分析和优化 Swift 代码，了解和理解编译过程非常有用。在本章中，我们带您经历了一次 Swift 编译器的完整旅程，从源代码开始，到可执行文件结束。我们还向您展示了如何获取特定编译步骤的结果，例如获取
    SIL 或 IR 代码表示。
- en: Final thoughts
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的想法
- en: Our learning journey in this book comes to an end, and now you have mastered
    Swift's techniques for creating high-performance applications. Let's have a quick
    recap.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们的学习之旅即将结束，现在您已经掌握了 Swift 创建高性能应用程序的技术。让我们快速回顾一下。
- en: By now, you have learned how to use the power of Swift and optimize your Swift
    code, but you should remember the main rule of optimization—optimize only when
    needed, not upfront.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您已经学会了如何利用 Swift 的力量并优化您的 Swift 代码，但您应该记住优化的主要规则——只在需要时优化，而不是一开始就优化。
- en: Solid architecture and well-structured and clean code are two of the most important
    characteristics of a good application. We have been expressing this throughout
    the book, and an entire chapter ([Chapter 2](part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0
    "Chapter 2. Making a Good Application Architecture in Swift"), *Making a Good
    Application Architecture in Swift*) was dedicated to it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定的架构和结构良好且干净的代码是优秀应用程序的两个最重要的特征。我们一直在本书中表达这一点，并有一个整个章节（[第 2 章](part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0
    "第 2 章. 在 Swift 中创建良好的应用程序架构"), *在 Swift 中创建良好的应用程序架构*)是专门为此而设的。
- en: Performance optimization doesn't always have to bring much complexity to the
    source code. Sometimes, applying small changes, such as adding the `@noescape`
    attribute, removing a few `print` statements, using the correct data structures,
    and other techniques presented in the book, could improve performance with no
    negative effect on the source code. Sometimes, the source code can become even
    cleaner and more readable; for example, by using `@noescape`, we don't need to
    explicitly specify `self.` when referencing instance members.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化并不总是需要给源代码带来很多复杂性。有时，通过应用一些小的改动，例如添加`@noescape`属性、移除一些`print`语句、使用正确的数据结构，以及书中提到的其他技术，可以在不负面影响源代码的情况下提高性能。有时，源代码甚至可以变得更加简洁和易读；例如，通过使用`@noescape`，在引用实例成员时我们不需要显式指定`self.`。
- en: Learning Swift's features and tools that are at your disposal before you start
    creating an application is very important. It is much easier to create a good
    application from the start by spending some time on planning and preparation than
    to try to refactor it and fix performance and code architecture issues later.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建应用程序之前，学习Swift的功能和可用的工具非常重要。通过花一些时间进行规划和准备，从一开始就创建一个良好的应用程序要比后来尝试重构和修复性能以及代码架构问题容易得多。
- en: Now, you are ready for the journey of creating incredible applications with
    Swift!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好开始使用Swift创建令人难以置信的应用程序的旅程了！
