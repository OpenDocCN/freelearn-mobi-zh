<html><head></head><body>
        

                            
                    <h1 class="header-title">Widening our Flutter Horizons</h1>
                
            
            
                
<p>In this chapter, we will first discuss networking in Flutter by building a simple application that fetches data from the server using JSON. Every app is required to have accessibility features to cater to mass users, and we will cover this in the accessibility options. In the final section, we will talk about localization for having your app grow globally, supporting multiple languages. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li class="h1">Networking in Flutter</li>
<li class="h1">Accessibility in Flutter </li>
<li class="h1">Internation­alizing Flutter apps</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Networking in Flutter</h1>
                
            
            
                
<p>Networking is the backbone of any app, and knowing how to make network calls is crucial. Working with networking calls in Flutter is simple and follows a streamline standard method. Flutter libraries and methods make it easier for developers to build apps with networking. This chapter will focus on making networking requests. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using packages</h1>
                
            
            
                
<p>Like many platforms, Flutter supports the use of shared packages that are contributed by the developers to the Flutter and Dart ecosystem. This facilitates development by making developers build apps quickly rather than worry about developing the code from scratch. Some of the most commonly used packages include, but are not limited to: making network requests (HTTP); using device APIs, such as device information (<kbd>device_info</kbd>); finding information and controlling the camera, including the support for previews of the camera feed and the captured image (camera); finding and using the location of the device using GPS coordinates (geolocator); and using third-party platform SDKs (such as Firebase). You can find the complete list of packages supported by Flutter at <a href="https://pub.dartlang.org/packages">https://pub.dartlang.org/packages</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding existing package dependency to an app</h1>
                
            
            
                
<p>Once you have decided on the set of packages that you want to include, follow these steps to include the dependency. For the purpose of this example, we have chosen HTTP package to an app. This package contains a set of high-level functions and classes, which can help developers consume HTTP resources while working on the app, and it is platform independent. It supports both the command line and the browser: </p>
<ol>
<li style="font-weight: 400">Create the dependency: Open the <kbd>pubspec.yaml</kbd> file located inside your app folder, and add <kbd>http:</kbd> under dependencies.
<p>All packages have a version number, specified in their <kbd>pubspec.yaml</kbd> file. The current version of the package is displayed next to the package name. When you mention <kbd>Plugin_Name_1:</kbd>, it is interpreted as <kbd>Plugin_Name_1: any</kbd>. This indicates that any version of the package may be used. It is advisable to use a specific version to ensure that the app doesn't break when it is updated.</p>
</li>
<li>Install the package where the dependency has been added. You can install it by running the <kbd>flutter packages get</kbd> command. If you are using Android Studio/IntelliJ, you can also click the Package Get option in the action ribbon at the top of <kbd>pubspecs.yaml</kbd>. If you are using VS code, click Get Packages located on the right-hand side of the action ribbon at the top of <kbd>pubspec.yaml</kbd></li>
<li style="font-weight: 400">Include the corresponding <kbd>import</kbd> statement in your Dart code. In this case, it is <kbd>import package:http/http.dart</kbd>. In case you have missed anything, you can always cross-check using the Installation tab option on the package page on <kbd>Pub</kbd>.</li>
<li style="font-weight: 400">At this point, it is better if you stop and restart the app to avoid errors such as <kbd>MissingPluginException</kbd> when using the package.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Upgrading existing package</h1>
                
            
            
                
<p>When you run <kbd>flutter packages get</kbd> (this will be <kbd>Packages Get</kbd> in IntelliJ) for the first time after adding a package in the <kbd>pubspec.yaml</kbd> file, Flutter will save the version found in the <kbd>pubspec.lock lockfile</kbd> file. To upgrade the package, you can run the Flutter packages upgrade (<kbd>Upgrade dependencies</kbd> in IntelliJ). Using this command, Flutter will retrieve the highest available version of the package. In case you have specified range constraint in <kbd>pubspec.yaml</kbd>, it will fetch the update as per the specification of the constraint.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a REST service</h1>
                
            
            
                
<p>One of the most prominent tasks for developers is to build REST services for the project that help you gather data in JSON format, which you can reflect on the front-end of the application. Imagine working on an application, and you want to mock up a REST web service to get the demo data for you. You could certainly build your backend server using Node.js, MongoDB, or other platforms, but one of the easiest ways is to use a JSON server. A JSON server is a simple project that stimulates REST API with CRUD operation. This project hardly consumes time for the setup, and you can swiftly process the data to ensure that everything works as expected. It is ideal for developers who are learning to build REST APIs to understand how the data is processed with a backend for prototyping and mocking.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up JSON Server</h1>
                
            
            
                
<p>The setup of this project can be found at <a href="https://github.com/typicode/json-server">https://github.com/typicode/json-server</a>. Note that this project builds a full fake REST API for demo purposes only. Before we begin the setup, ensure that the following components are ready on your system:</p>
<ol>
<li style="font-weight: 400"><strong>Node.js</strong>: JSON-Server is built on top of Node.js. If you already have it in place, please ensure to keep it updated. To find out the version of Node, run the <kbd>node -v</kbd> command. </li>
<li style="font-weight: 400"><strong>NPM package</strong>: NPM stands for Node Package Manager, and comes in handy to easily install, update, configure, and uninstall Node JS platform modules/packages. Ensure NPM is installed on the system. If not, refer to <a href="https://www.npmjs.com/get-npm">https://www.npmjs.com/get-npm</a>. At this point, it would be ideal to quote that NPM is a separate project from the Node, and gets updated frequently. To update NPM, use the <kbd>sudo npm install npm@latest -g</kbd> command.</li>
</ol>
<ol start="3">
<li><kbd>cURL</kbd>: This open source command line enables the transfer of data with URL syntax. If you have <kbd>cURL</kbd> installed, use the <kbd>curl -V</kbd>  command (Note that <kbd>V</kbd> is upper case). In case you need to install <kbd>cURL</kbd>, run the <kbd>brew install curl</kbd> command.</li>
</ol>
<p>The JSON server is available as an NPM package, so we could simply run the following command to install it:</p>
<pre><strong>$ npm install -g json-server</strong></pre>
<p>The <kbd>-g</kbd> option enables the package to be installed globally on your system. Once you have installed it successfully, run the command to cross check:</p>
<pre><strong>$ json-server -v</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a resource file</h1>
                
            
            
                
<p>A resource is anything that has data associated with it. For example, if you are working on a movie review website, movies, reviewers, users, and so on, would be resources. You could have API endpoints based on these resources. The API endpoints help you to retrieve or update the data on the server. In this case, we will use the resources as a JSON file. This JSON file will act as a config and database file for the mock server you set up using <kbd>json-server</kbd>.</p>
<p><kbd>Json-server</kbd> works in a JSON file, and creating a JSON file is simple. Create a new file as <kbd>Books.json</kbd>, populate the following content, and save it. Note that the name of the array we specified is <kbd>Movie</kbd>, so <kbd>json-server</kbd> will create the REST APIs based on this name:</p>
<pre>{<br/>  "Movie": [<br/>    {<br/>      "id": 1,<br/>      "Movie Name": "Avengers: Infinity War",<br/>      "Year": "2018",<br/>      "Category": "Science Fiction"<br/>    },<br/>    {<br/>      "id": 2,<br/>      "first_name": "Black Panther",<br/>      "Year": "2018",<br/>      "Category": "Science Fiction"<br/>    },<br/>    {<br/>      "id": 3,<br/>      "first_name": "Mission: Impossible – Fallout",<br/>      "Year": "2018",<br/>      "Category": "Action"<br/>    },<br/>    {<br/>      "id": 4,<br/>      "first_name": "Annihilation",<br/>      "Year": "2018",<br/>      "Category": "Fantasy"<br/>    }<br/>  ]<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Run the json-server</h1>
                
            
            
                
<p>The final step is to run <kbd>json-server</kbd> to ensure we have the mock server running locally. Run the following command:</p>
<pre><strong>$ json-server --watch db.json</strong></pre>
<p>Congratulations! You have now successfully set up <kbd>json-server</kbd>. Open the <kbd>http://localhost:3000/</kbd> URL to check whether you can see the following. Under the resources tag, you will be able to see the Movies JSON file we created.</p>
<p>Do not close the terminal, as that will kill <kbd>json-server</kbd>. In case your port <kbd>3000</kbd> is utilized, you can set options for the new port number in a <kbd>json-server.json</kbd> configuration file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching data from the server</h1>
                
            
            
                
<p>Fetching data from the server is a commonly used feature. It is performed using the HTTP package that we covered earlier in this chapter. The steps to follow are as follows:</p>
<ol>
<li style="font-weight: 400">Include the HTTP package and make the network request</li>
<li style="font-weight: 400">Convert the response into a custom Dart object</li>
<li style="font-weight: 400">Fetch the data and display it using the Flutter</li>
</ol>
<p>Since we have already learned about adding HTTP packages in the <em>Using packages</em> section, we will now proceed with making a network request. In our next step, we will fetch the sample JSON content using JSON-Server and the <kbd>http.get()</kbd> method.</p>
<p>We use the <kbd>Future</kbd> function, which is a core Dart class for working with async tasks and, together with <kbd>http</kbd>, it returns the data from a successful <kbd>http</kbd> call:</p>
<pre>Future&lt;http.Response&gt; fetchPost() {<br/>  return http.get('http://localhost:3000/Movie/1');<br/>}</pre>
<p>We now create a <kbd>Post</kbd> class that will contain the data from our network requests. To ensure that we create a proper <kbd>Post</kbd> from JSON, we will include a <kbd>factory</kbd> constructor. In our example, we have four categories of data for each array to fetch, namely, <kbd>id</kbd>, <kbd>movieName</kbd>, <kbd>year</kbd>, and the <kbd>category</kbd>:</p>
<pre>class Post {<br/>  final int id;<br/>  final String movieName;<br/>  final int year;<br/>  final String category;<br/><br/>  Post({this.id, this.movieName, this.year, this.category});<br/><br/>  factory Post.fromJson(Map&lt;String, dynamic&gt; json) {<br/>    return Post(<br/>      id: json['id'],<br/>      movieName: json['movieName'],<br/>      year: json['year'],<br/>      category: json['category'],<br/>    );<br/>  }<br/>}</pre>
<p>Next, we will need to update the <kbd>fetchPost</kbd> function to return a <kbd>Future&lt;Post&gt;</kbd>, for which we will follow three steps:</p>
<ol>
<li>First, convert the response body into a JSON Map using the <kbd>dart:convert</kbd> package. This package contains encoders and decoders for converting between different data representations. To use this, you will first have to add the dependency in your package's <kbd>pubspec.yaml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">dependencies: convert: ^2.1.1</pre>
<p style="padding-left: 60px">Now, use the <kbd>package:convert/convert.dart</kbd> import in your dart code.</p>
<ol start="2">
<li>If we get an <kbd>OK</kbd> response from the server with a status code of <kbd>200</kbd>, it means the data is fetched, and you can convert the JSON Map into a <kbd>Post</kbd> using the <kbd>fromJSON</kbd> factory.</li>
<li>If the response is unexpected, you can flag an error.</li>
</ol>
<p>Here is the piece of code that checks the previously-mentioned cases:</p>
<pre>Future&lt;Post&gt; fetchPost() async {<br/>  final response =<br/>  await http.get('http://localhost:3000/Movies/1');<br/><br/>  if (response.statusCode == 200) {<br/>    // If the call to the server was successful, parse the JSON<br/>    return Post.fromJson(json.decode(response.body));<br/>  } else {<br/>    // If that call was not successful, flag an error.<br/>    throw Exception('Failed to load post');<br/>  }<br/>}<br/><br/></pre>
<p>In order to fetch the data and display it, we use the <kbd>FutureBuilder</kbd> widget that is built into Flutter, and helps in working easily with async data sources. To make this happen, we will need two parameters:</p>
<ul>
<li style="font-weight: 400">The name of the future we want to work with. In our example, we call it the <kbd>fetchPost()</kbd> function.</li>
<li style="font-weight: 400">A builder function that informs Flutter what to render, based on the state of the Flutter—loading, success, or error:</li>
</ul>
<pre style="padding-left: 60px">FutureBuilder&lt;Post&gt;(<br/>            future: post,<br/>            builder: (context, snapshot) {<br/>              if (snapshot.hasData) {<br/>                return Text(snapshot.data.movieName);<br/>              } else if (snapshot.hasError) {<br/>                return Text("${snapshot.error}");<br/>              }<br/><br/>              // By default, show a loading spinner<br/>              return CircularProgressIndicator();<br/>            },<br/>);</pre>
<p>Building the code by putting a call to an API in your <kbd>build()</kbd> method is convenient, but it's not recommended. It will make Flutter call the <kbd>build()</kbd> method every time when it wants to change anything in the view, making your app slow due to it making unnecessary flooded API calls. A better way is to bit the API when the page is initially loaded, and use <kbd>StatelessWidget</kbd> for the same.</p>
<p>Using this method, you will make the parent widget responsible for calling the fetch method, storing its result and then passing it to your widget:</p>
<pre>class MyApp extends StatelessWidget {<br/>  final Future&lt;Post&gt; post;<br/><br/>  MyApp({Key key, this.post}) : super(key: key);</pre>
<p>This is the complete code that will fetch the JSON content using <kbd>json-server</kbd> by reading <kbd>Movies.json</kbd>:</p>
<pre>import 'dart:async';<br/>import 'dart:convert';<br/><br/>import 'package:flutter/material.dart';<br/>import 'package:http/http.dart' as http;<br/><br/>Future&lt;Post&gt; fetchPost() async {<br/>  final response =<br/>  await http.get('http://localhost:3000/Movies/1');<br/><br/>  if (response.statusCode == 200) {<br/>    // If the call to the server was successful, parse the JSON<br/>    return Post.fromJson(json.decode(response.body));<br/>  } else {<br/>    // If that call was not successful, throw an error.<br/>    throw Exception('Failed to load post');<br/>  }<br/>}<br/><br/>class Post {<br/>  final int id;<br/>  final String movieName;<br/>  final int year;<br/>  final String category;<br/><br/>  Post({this.id, this.movieName, this.year, this.category});<br/><br/>  factory Post.fromJson(Map&lt;String, dynamic&gt; json) {<br/>    return Post(<br/>      id: json['id'],<br/>      movieName: json['movieName'],<br/>      year: json['year'],<br/>      category: json['category'],<br/>    );<br/>  }<br/>}<br/><br/>void main() =&gt; runApp(MyApp(post: fetchPost()));<br/><br/>class MyApp extends StatelessWidget {<br/>  final Future&lt;Post&gt; post;<br/><br/>  MyApp({Key key, this.post}) : super(key: key);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      title: 'JSON Fetch Data Example',<br/>      theme: ThemeData(<br/>        primarySwatch: Colors.blue,<br/>      ),<br/>      home: Scaffold(<br/>        appBar: AppBar(<br/>          title: Text('JSON Fetch Data Example'),<br/>        ),<br/>        body: Center(<br/>          child: FutureBuilder&lt;Post&gt;(<br/>            future: post,<br/>            builder: (context, snapshot) {<br/>              if (snapshot.hasData) {<br/>                return Text(snapshot.data.movieName);<br/>              } else if (snapshot.hasError) {<br/>                return Text("${snapshot.error}");<br/>              }<br/><br/>              // By default, show a loading spinner<br/>              return CircularProgressIndicator();<br/>            },<br/>          ),<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}</pre>
<p>At the start of the chapter, we discussed what packages are and how to use them. Once the packages were set up, we discussed how to build a JSON Server to fetch data for our tests. In the final section, we glanced through an example of how to fetch the JSON data to the app, displaying the content of the JSON file we created and ran using the JSON server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessibility in Flutter </h1>
                
            
            
                
<p>Making your app accessible to many users could be a great initiative. That also includes people with disabilities, such as blindness, hearing, voice, or motor impairment. As per the reports on disability by the World Health Organization, there are over 100 million users across the globe who face physical challenges in their daily routine. Technology can be revolutionary in helping people, and that's when building apps catering to their specific needs can aid them well.</p>
<p>Not all the users use the app in a specifically defined manner, so, a focus on accessibility will not only help users to download and use the app, but will also propagate to a new level of users. </p>
<p>Google provides an app to check for accessibility support that is available as accessibility scanner on Google Play at <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor" target="_blank">https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor</a> This app enables you to find the accessibility provide that a developer can do within the app. For iOS, XCode provides Accessibility Inspector. </p>
<p>Flutter supports three components for accessibility support:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Large font</h1>
                
            
            
                
<p>With age, not many can see the content the way they used to in their youth. Some face issues in reading the text clearly, especially when developers consider using the<strong> </strong>default size without taking into considering factors such as screen size and orientation. One of the quickest ways to do this is to ensure that the text scales in their accessibility options consider the device specifications of the consumers. </p>
<p>Flutter has a feature that handles text size calculations automatically. For example, the <kbd>Text</kbd> widget has a <kbd>textScaleFactor</kbd> property that allows the scaling of the text. Font size is multiplied by the <kbd>textScaleFactor</kbd> value to determine the new font size that is rendered on the screen in logical pixels. For example, if the <kbd>textScaleFactor</kbd> is <kbd>1.5</kbd>, the text will be 50% larger than the specified font size, as follows: </p>
<pre class="mce-root">Text(<br/>  'Hello India, how are you?',<br/>  textAlign: TextAlign.center,<br/>  overflow: TextOverflow.ellipsis,<br/>  style: TextStyle(fontWeight: FontWeight.normal),<br/>  textScaleFactor: 1.5,<br/>)</pre>
<p>One point that needs to be kept in mind is that, if you manually set the scale value, the user’s accessibility settings will be overridden. You have to ensure that the scale-up value doesn't show up the text to a large extent leading to uninstall of the app. If you do not specify the value, it will check <kbd>textScaleFactor</kbd> for the nearest <kbd>MediaQuery</kbd> ancestor (<kbd>MediaQueryData.textScaleFactor</kbd>) or <kbd>1.0</kbd>, if no such ancestor exists. Ensure that you test the text displays properly at all accessibility settings.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Screen readers </h1>
                
            
            
                
<p>For those who are visually impaired, this accessiblity option can come in handy. It enables users to receive spoken feedback about the content of the screen. You could turn on VoiceOver in iOS, or TalkBack in an Android application on your device to navigate around your app. For example, when using TalkBack, users perform actions using gestures, and each action is complimented with an audible output that allows users to know that their gesture trigger was successful. There are three types of gestures in TalkBack: basic gestures, back-and-forth gestures, and angle gestures. Note that the users should use single gestures, even finger pressure, and a steady speed to have a seamless experience. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Screen contrast</h1>
                
            
            
                
<p>Specifying background and foreground colors with sufficient color contrast enables better readability for the users. This ratio ranges from 1 to 21, where 21 means the highest. </p>
<p>The W3C recommends the following:</p>
<ul>
<li>At least 4.5:1 for smaller text (below 18 point regular, or 14 point bold)</li>
<li>At least 3.0:1 for larger text (18 point and above regular, or 14 point and above bold)</li>
</ul>
<p>Accessibility is an important feature and should not be neglected. It ensures that the app is open to a larger audience, enabling the chances for better application usage. It is equally important to test the accessibility options before rolling out to the masses. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Internation­alizing Flutter apps</h1>
                
            
            
                
<p>As the name suggests, if your app will be by the international audience, you will have to think of providing <strong>locale</strong> support for the specific language of the target. That means you’ll need to write the app in a way that your app renders the values like text and layouts depending on each language or locale that the app supports. Flutter has made it simple by providing support by classes and widgets. Flutter supports the global localization classes for about 24 languages. </p>
<p>Before you start the internationalization, dependencies must be added in<strong> <kbd>pubspec.yaml</kbd></strong>:</p>
<pre class="prettyprint lang-yaml prettyprinted">dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter</pre>
<p>The next step is to import the <kbd>flutter_localizations</kbd> library and specify <kbd>localizationsDelegates</kbd> and <kbd>supportedLocales</kbd> for <kbd>MaterialApp</kbd>. Also, import <kbd>package:flutter_localizations/flutter_localizations.dart</kbd>:</p>
<pre>Widget build(BuildContext context) {<br/>  return MaterialApp(<br/>    onGenerateTitle: (BuildContext context) =&gt; DemoLocalizations.of(context).title,<br/>    localizationsDelegates: [<br/><br/>// ... app-specific localization delegate[s] here<br/><br/>      const DemoLocalizationsDelegate(),<br/>      GlobalMaterialLocalizations.delegate,<br/>      GlobalWidgetsLocalizations.delegate,<br/>    ],<br/>    supportedLocales: [<br/>      const Locale('en', ''), //Supporting English<br/>      const Locale('hi', ''), // Supporting Hindi<br/>      const Locale('es', ''), // Supporting Spanish<br/>    ],</pre>
<p>The <kbd>localizationsDelegates</kbd> list contains the elements that are factories that produce collections of localized values. <kbd>GlobalMaterialLocalizations.delegate</kbd> provides strings that are localized and other values for the material components library. The default text direction for the widget library is defined by <kbd>GlobalWidgetsLocalizations.delegate</kbd><strong>. </strong></p>
<p>There are three methods to keep an eye on:</p>
<ul>
<li><kbd>.load</kbd>: This method must return an object that contains a collection of related resources</li>
<li><kbd>.isSupported</kbd>: If the support for the locale is found, it returns <kbd>True</kbd>. Otherwise it will return <strong><kbd>False</kbd></strong></li>
<li><kbd>shouldReload</kbd>: If this method returns <kbd>True</kbd>, then all the app widgets will be rebuilt after a load of resources</li>
</ul>
<p>The complete code for your reference is as follows:</p>
<pre>import 'dart:async';<br/><br/>import 'package:flutter/material.dart';<br/>import 'package:flutter/foundation.dart' show SynchronousFuture;<br/>import 'package:flutter_localizations/flutter_localizations.dart';<br/><br/>class DemoLocalizations {<br/>  DemoLocalizations(this.locale);<br/><br/>  final Locale locale;<br/><br/>  static DemoLocalizations of(BuildContext context) {<br/>    return Localizations.of&lt;DemoLocalizations&gt;(context, DemoLocalizations);<br/>  }<br/><br/>  static Map&lt;String, Map&lt;String, String&gt;&gt; _localizedValues = {<br/>    'en': {<br/>      'title': 'Locale in English',<br/>    },<br/>    'es': {<br/>      'title': 'Local en españa',<br/>    },<br/>    'hi': {<br/>      'title': 'लोकेल हिंदी में',<br/>    },<br/>  };<br/><br/>  String get title {<br/>    return _localizedValues[locale.languageCode]['title'];<br/>  }<br/>}<br/><br/>class DemoLocalizationsDelegate extends LocalizationsDelegate&lt;DemoLocalizations&gt; {<br/>  const DemoLocalizationsDelegate();<br/><br/>  @override<br/>  bool isSupported(Locale locale) =&gt; ['en', 'es', 'hi'].contains(locale.languageCode);<br/><br/>  @override<br/>  Future&lt;DemoLocalizations&gt; load(Locale locale) {<br/>    // Returning a SynchronousFuture here because an async "load" operation<br/>    // isn't needed to produce an instance of DemoLocalizations.<br/>    return SynchronousFuture&lt;DemoLocalizations&gt;(DemoLocalizations(locale));<br/>  }<br/><br/>  @override<br/>  bool shouldReload(DemoLocalizationsDelegate old) =&gt; false;<br/>}<br/><br/>class DemoApp extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      appBar: AppBar(<br/>        title: Text(DemoLocalizations.of(context).title),<br/>      ),<br/>      body: Center(<br/>        child: Text(DemoLocalizations.of(context).title),<br/>      ),<br/>    );<br/>  }<br/>}<br/><br/>class Demo extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      onGenerateTitle: (BuildContext context) =&gt; DemoLocalizations.of(context).title,<br/>      localizationsDelegates: [<br/>        const DemoLocalizationsDelegate(),<br/>        GlobalMaterialLocalizations.delegate,<br/>        GlobalWidgetsLocalizations.delegate,<br/>      ],<br/>      supportedLocales: [<br/>        const Locale('en', ''),<br/>        const Locale('es', ''),<br/>        const Locale('hi', ''),<br/>      ],<br/><br/>      home: DemoApp(),<br/>    );<br/>  }<br/>}<br/><br/>void main() {<br/>  runApp(Demo());<br/>}</pre>
<p>After you run the code successfully, you will see the output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0b813aea-4d78-4467-b286-b5e550fb8737.png" style="width:16.33em;height:29.00em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We first discussed how networking plays an important role in the apps, along with sample code for setting up and running a local server for fetching JSON code. This section was followed by understanding why accessibility is important, and what improvements developers can provide to support accessibility in the app. The next section showed how to make app support internationalization.</p>
<p>In the next chapter, we will discuss how to use platform powers to build apps. </p>


            

            
        
    </body></html>