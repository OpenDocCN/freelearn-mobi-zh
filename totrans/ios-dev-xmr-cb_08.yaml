- en: Chapter 8. Integrating iOS Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting phone calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending text messages and e-mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using text messaging in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using e-mail messaging in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the address book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the calendar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile devices offer a handful of features to the user. Creating an app that
    interacts with these features to provide a complete experience to users can surely
    be considered as an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss some of the most common features of iOS and
    how to integrate some or all of their functionality into our apps. We will see
    how to offer the user the ability to make telephone calls and send SMS and e-mails,
    either using the native platform apps or by integrating the native user interface
    in our projects. Also, we will discuss the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MFMessageComposeViewController**: This controller is suitable for sending
    text (SMS) messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MFMailComposeViewController**: This controller is used for sending e-mails
    with or without attachments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ABAddressBook**: This class provides us access to the address book database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ABPersonViewController**: This controller displays and/or edits contact information
    from the address book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EKEventStore**: This class is responsible for managing calendar events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, we will learn how to read and save contact information, how to
    display contact details, and interact with the device's calendar.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of the examples in this chapter will require a device. For example,
    the simulator does not contain the *Messaging* app. To deploy a simulator to a
    device, you will need to enroll as an iOS Developer through Apple's Developer
    Portal.
  prefs: []
  type: TYPE_NORMAL
- en: Starting phone calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to invoke the native *Phone* app to allow
    the user to place a phone call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `PhoneCallApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The native *Phone* app is not available on the simulator. It is only available
    on an iPhone device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to allow the user to place phone calls:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button on the view of `PhoneCallAppViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Tap the **Call phone number** button
    to start the call. The following screenshot shows the *Phone* app placing a call:![How
    to do it...](img/8924OT_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Through the `UIApplication.SharedApplication` static property, we have access
    to the app''s `UIApplication` object. We can use its `OpenUrl` method that accepts
    an `NSUrl` variable to initiate a call using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Because not all iOS devices support the native *Phone* app, it would be useful
    to check for availability first. You can do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the `OpenUrl` method is called, the native *Phone* app will be executed
    and start calling the number immediately. Note that the `tel:` prefix is needed
    to initiate the call.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xamarin.iOS also supports the CoreTelephony Framework through the `MonoTouch.CoreTelephony`
    namespace. This is a simple framework that provides information on call state,
    connection, carrier information, and so on. Note that when a call starts, the
    native *Phone* app enters into the foreground, causing the app to be suspended.
    A simple usage of the CoreTelephony Framework is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the handler is assigned with an equals sign (=) instead of the common
    plus-equals (+=) combination. This is because `CallEventHandler` is a property
    and not an event. When the app enters into the background, events are not distributed
    to it. The event that occurred last, however, will be distributed when the app
    returns to the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: More information on OpenUrl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `OpenUrl` method can be used to open various native and non-native applications.
    For example, to open a web page in Safari, just create an `NSUrl` object with
    the link, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Sending text messages and e-mails* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending text messages and e-mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to invoke the native *Mail* and *Messaging*
    apps within our own app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `SendTextApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to invoke the apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two buttons on the view of `SendTextAppViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Click on one of the buttons to open the
    corresponding app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, using the `OpenUrl` method, we can send text or e-mail messages.
    Just using the `sms:` prefix from the preceding example code will open the native
    text messaging app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a cell phone number after the `sms:` prefix will open the native *Messaging*
    app, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For opening the native e-mail app, the process is similar. Pass the `mailto:`
    prefix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This opens the edit mail controller, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `mailto:` URL scheme supports various parameters for customizing an e-mail
    message. These parameters allow us to enter the sender address, subject, and message,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although iOS provides access to opening the native *Messaging* apps, predefining
    message content in the case of e-mails is where the control from inside the app
    stops. There is no way of actually sending the message through code. It is the
    user that will decide whether to send the message or not.
  prefs: []
  type: TYPE_NORMAL
- en: More information on opening external apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OpenUrl` method provides an interface for opening external apps. Opening
    external apps has one drawback, that is, the app that calls the `OpenUrl` method
    transitions to the background. Up to iOS Version 3.*, this was the only way of
    messaging through an application. Since iOS Version 4.0, Apple has provided the
    messaging controllers to the SDK. The following recipes discuss their usage.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Starting phone calls* and *Using text messaging in our application* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using text messaging in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display the text messaging controller inside
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `TextMessageApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to display the text messaging controller in our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button on the view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following `using` directive in the `TextMessageAppViewController`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ViewDidLoad` method with the following code, changing the recipient
    number and/or the message body at your discretion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Tap the **Send message** button to open
    the message controller. Tap the **Send** button to send the message, or on the
    **Cancel** button to return to the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.MessageUI` namespace contains the necessary UI elements that
    allow us to implement messaging in an iOS app. For text messaging (SMS), we need
    the `MFMessageComposeViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: We need to check for texting availability, because not all devices can send
    text messages. The `MFMessageComposeViewController` class contains a static method
    named `CanSendText`, which returns a boolean value indicating whether we can use
    this functionality. The important thing in this case is that we check if the functionality
    of sending text messages is available prior to initializing the controller. This
    is because when you try to initialize the controller on a device that does not
    support text messaging or on the simulator, you will get an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine when the user has taken action in the message UI, we subscribe
    to the `Finished` event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Finished` method, we can provide functionality according to the
    `MessageComposeResult` parameter. It can have one of the following three values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sent: This means the message was sent successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cancelled: This means the user has tapped the **Cancel** button. The message
    will not be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Failed: This means the message sending failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last thing to do is unsubscribe the event and dismiss the message controller,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing the controller, we can set the recipients and body message
    to the appropriate properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Recipients` property accepts a `string` array that allows multiple recipient
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that SDK allows the user interface to send text messages does not mean
    that it is customizable. Just like invoking the native *Messaging* app, it is
    the user who will decide whether to send the message or discard it. In fact, after
    the controller is presented on the screen, any attempts to change the actual object
    or any of its properties will simply fail. Furthermore, the user can change or
    delete both the recipients and the message body. The real benefit, though, is
    that the messaging user interface is displayed within our app instead of running
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: Attachments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with iOS 7, the `MFMessageComposeViewController` class supports attachments.
    We can attach a file to a message through the `AddAttachment` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter is the string that will appear as a filename on the UI.
    If null is passed, the actual filename will appear.
  prefs: []
  type: TYPE_NORMAL
- en: Using e-mail messaging in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the e-mail messaging interface within
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `EmailMessageApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button on the view of `EmailMessageAppViewController` and the `MonoTouch.MessageUI`
    namespace in the `EmailMessageAppViewController.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app either on the simulator or on the device. Click on the
    **Send email** button to display the mail user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send or cancel the message. The app will work on the simulator and behave just
    like the native *Mail* app on devices, except for the fact that messages will
    not actually be sent or saved.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MFMailComposeViewController` class provides the native mail composing
    interface. To determine whether the device is capable of sending e-mails, we first
    check its `CanSendMail` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we did with the `MFMessageComposeViewController` class, we subscribe
    to the `Finished` event of the `MFMailComposeViewController` class. We use this
    event to respond to user actions, without having to implement a `Delegate` object.
    We do this inside the `MailController_Finished` method based on the `MFComposeResultEventArgs.Result`
    property, which is of the `MFMailComposeResult` type. The possible values of the
    `MFMailComposeResult` enumeration will be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sent: This means the e-mail message is queued for sending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Saved: This means the user clicked on the **Cancel** button, and the **Save
    Draft** option of the action sheet automatically appears. The following screenshot
    shows the action sheet that appears when the user clicks on the **Cancel** button:![How
    it works...](img/8924OT_08_04.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cancelled: This means the user clicked on the **Cancel** button on the controller
    and selected the **Delete Draft** option on the action sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Failed: This means the e-mail message sending failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After initializing the object, we can assign a recipient list, subject, and
    message body through the corresponding set of the `Set` prefixed methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the second parameter of the `SetMessageBody` message is set to `true`, it
    informs the controller that the message should be treated as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from simple or HTML formatted text, we can also send attachments. We
    can do this with the `AddAttachmentData` method using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is of the `NSData` type and is the actual content of the
    attachment. In this case, we attach an image through the `UIImage.AsJPEG()` method,
    which returns the image contents inside an `NSData` object. The second parameter
    represents the **Multipurpose Internet Mail Extensions** (**MIME**) type of the
    attachment, and the third parameter represents its filename that will be shown
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using text messaging in our application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the address book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to access and manage the user's stored contacts
    in the device's address book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `AddressBookApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button on the view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following `using` directive in the `AddressBookAppViewController.cs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Click on the **Get contacts** button
    and either accept or deny access to the address book. The following screenshot
    displays the alert that appears when we request access to the address book:![How
    to do it...](img/8924OT_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simulator's address book contains some fake contacts that we can work with.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MonoTouch.AddressBook` namespace contains all the classes that allow us
    to manage the device''s address book. To access the address book, we first need
    to check if the user has previously granted address book access to our app and
    instantiate an `ABAddressBook` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the status is `NotDermined`, we call the `RequestAccess` method, which accepts
    an `Action<bool, NSError>` delegate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `bool` parameter informs us if the user has granted access. If it is `true`,
    we call the `ReadContacts` method so that we proceed with reading the address
    book information we want. Note that we wrap the call of the `ReadContacts` method
    with an `InvokeOnMainThread` call, although it is not accessing the UI. This is
    because the `RequestAccess` method is called on a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can access the address book from other threads other than the main one; however,
    every instance of `ABAddressBook` needs to be used on the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `ReadContacts` method, we enumerate the individual contact through
    the `GetPeople` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `ABPerson` class contains the contact information we want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a contact''s stored phone number(s), call the `GetPhones()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It returns an object of the `ABMultiValue<string>` type. `ABMultiValue<T>` is
    a generic collection, especially designed for multiple address book values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a phone number to a contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a phone number to a contact, we can use the `ABPerson` class'' `SetPhones`
    method. It accepts an `ABMultiValue<string>` object as its parameter, but we cannot
    add new values to the `ABMultiValue` objects. We can, however, write values to
    an `ABMutableMultiValue<T>` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code creates a new instance of the `ABMutableMultiValue<string>`
    object, which we then use to add the phone number(s) we want, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter of the `Add` method is the label that the phone number
    will have when it is saved to the contact. It is important to call the `ABAddressBook.Save()`
    method, or else, the changes will not be saved.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying contacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the native address book user interface
    to display contact information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `DisplayContactApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button on the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AppDelegate.cs` file, add the `DisplayContactAppViewController` to
    a navigation controller, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following namespaces in the `DisplayContactAppViewController.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. Tap the button to show the
    contact card screen. The result should be similar to the following screenshot:![How
    to do it...](img/8924OT_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.AddressBookUI` namespace contains the controllers that the native
    *Contacts* app uses to allow the user to display and manage contacts. Each contact's
    details can be viewed with `ABPersonViewController`. This controller must be pushed
    to `UINavigationController`, or else it will not display correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing it, we set the `ABPerson` object, which we want to be displayed,
    to its `DisplayedPerson` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we push it to the navigation controller''s stack using the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ABPersonViewController` class can also be used for editing. To do this,
    set the `AllowsEditing` property to `true`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that the changes are saved normally through the `ABPersonViewController`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Other address book controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `MonoTouch.AddressBookUI` namespace contains all the controllers we need
    to create our own custom contacts application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABPeoplePickerNavigationController`: This is a navigation controller that
    displays the saved contacts. The user can select a contact from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABPersonViewController`: This is described in the example given in this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABNewPersonViewController`: This is the controller that creates a new contact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABUnknownPersonViewController`: This is the controller that is displayed with
    partial data for creating a new contact. This is similar to the controller that
    is displayed when we tap on an unknown number in the list of recent calls on the
    device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing the address book* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the calendar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how create an event and save it to the device's
    calendar database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `CalendarEventsApp`.
  prefs: []
  type: TYPE_NORMAL
- en: The app we will be creating will output the calendar events of the next 30 days.
    Make sure you have some calendar events in that period.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create an event and save it to the device''s calendar database by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button on the main view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `MonoTouch.EventKit` namespace in the `CalendarEventAppViewController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Click on the **Display events** button
    to output the calendar events of the next 30 days in the **Application Output**
    pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MonoTouch.EventKit` namespace is responsible for managing the calendar
    events. To read the stored events, we first check if we have access to the calendar
    and initialize an `EKEventStore` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If the authorization status is `NotDetermined`, we call the `RequestAccessAsync`
    method so that the user is prompted for access, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If the result is `true`, it means that the user has granted calendar access
    to our app. Now, we call the `DisplayEvents` method to read and output the events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EKEventStore` class provides us access to the stored events. To retrieve
    the calendar events, we need a predicate of the `NSPredicate` type. We can create
    an instance through the `PredicateForEvents` method of the `EKEventStore` class
    using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first two parameters are of the `NSDate` type (which can be implicitly converted
    to `DateTime`) and represent the start and end dates for which to search events.
    The third parameter is of the `EKCalendar[]`type, and is an array of the calendars
    to search. To search all the available calendars, we pass the return value of
    the `GetCalendars` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `EnumerateEvents` method using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We pass the predicate we created earlier to the first parameter. The second
    parameter is a delegate of the `EKEventSearchCallback` type. To read each event's
    data, we use its `EKEvent` object. Note that the process of enumerating calendar
    events is similar to the one that is used for enumerating assets from the assets
    library, discussed in the previous chapter. This means that if the `EKEvent` object
    is not null, we must explicitly set the `stop` parameter to `false` so that the
    `EKEventStore` class continues enumerating the calendar events.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Except from enumerating events, the `EKEventStore` class also allows us to
    create new events. The following example creates and saves a new calendar event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For creating a new `EKEvent` instance, we use the `EKEvent.FromStore` static
    method. We then set the start and end dates, a title, and the calendar to which
    the event will be stored. Here, we use the default calendar that we can get with
    the `DefaultCalendarForNewEvents` property of `EKEventStore`. When we have everything
    set up, we call the `SaveEvent` method to save it.
  prefs: []
  type: TYPE_NORMAL
- en: Reminders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed the usage of the `EKEntityType` enumeration. This defines
    the entity type we want to have access to. Other than `Event`, which refers to
    the calendar events, we can also use the `Reminder` value so that we can work
    with the tasks the user has in the *Reminders* app.
  prefs: []
  type: TYPE_NORMAL
- en: We need to explicitly ask for the **Reminders** permission, even if the user
    has already granted access to the calendar.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing album items directly* recipe in [Chapter 7](ch07.html "Chapter 7. Multimedia
    Resources"), *Multimedia Resources*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
