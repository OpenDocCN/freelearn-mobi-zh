["```\npackage com.mydomain.tetris.helpers\n\nfun array2dOfByte(sizeOuter: Int, sizeInner: Int): Array<ByteArray>\n        = Array(sizeOuter) { ByteArray(sizeInner) }\n```", "```\npackage com.mydomain.tetris.models\n\nimport com.mydomain.tetris.helpers.array2dOfByte\n\nclass Frame(private val width: Int) {\n  val data: ArrayList<ByteArray> = ArrayList()\n\n  fun addRow(byteStr: String): Frame {\n    val row = ByteArray(byteStr.length)\n\n    for (index in byteStr.indices) {\n      row[index] = \"${byteStr[index]}\".toByte()\n    }\n    data.add(row)\n    return this\n  }\n\n  fun as2dByteArray(): Array<ByteArray> {\n    val bytes = array2dOfByte(data.size, width)\n    return data.toArray(bytes)\n  }\n}\n```", "```\nenum class Shape(val frameCount: Int, val startPosition: Int) {\n  Tetromino(2, 2) {\n    override fun getFrame(frameNumber: Int): Frame {\n      return when (frameNumber) {\n        0 -> Frame(4).addRow(\"1111\")\n        1 -> Frame(1)\n                     .addRow(\"1\")\n                     .addRow(\"1\")\n                     .addRow(\"1\")\n                     .addRow(\"1\")\n        else -> throw IllegalArgumentException(\"$frameNumber is an invalid \n                                                frame number.\")\n      }\n    }\n  };\n  abstract fun getFrame(frameNumber: Int): Frame\n}\n```", "```\nTetromino(2, 2) {\n  override fun getFrame(frameNumber: Int): Frame {\n    return when (frameNumber) {\n      0 -> Frame(4).addRow(\"1111\")\n      1 -> Frame(1)\n                   .addRow(\"1\")\n                   .addRow(\"1\")\n                   .addRow(\"1\")\n                   .addRow(\"1\")\n      else -> throw IllegalArgumentException(\"$frameNumber is an invalid\n                                              frame number.\")\n    }\n  }\n};\n```", "```\nenum class Shape(val frameCount: Int, val startPosition: Int) {\n```", "```\nTetromino1(1, 1) {\n    override fun getFrame(frameNumber: Int): Frame {\n      return Frame(2)\n             .addRow(\"11\")\n             .addRow(\"11\")\n    }\n  },\n```", "```\n  Tetromino2(2, 1) {\n    override fun getFrame(frameNumber: Int): Frame {\n      return when (frameNumber) {\n        0 -> Frame(3)\n                   .addRow(\"110\")\n                   .addRow(\"011\")\n        1 -> Frame(2)\n                   .addRow(\"01\")\n                   .addRow(\"11\")\n                   .addRow(\"10\")\n        else -> throw IllegalArgumentException(\"$frameNumber is an invalid \n                                                frame number.\")\n        }\n      }\n    },\n\n```", "```\n    Tetromino3(2, 1) {\n      override fun getFrame(frameNumber: Int): Frame {\n        return when (frameNumber) {\n          0 -> Frame(3)\n                     .addRow(\"011\")\n                     .addRow(\"110\")\n          1 -> Frame(2)\n                     .addRow(\"10\")\n                     .addRow(\"11\")\n                     .addRow(\"01\")\n          else -> throw IllegalArgumentException(\"$frameNumber is \n                                       an invalid frame number.\")\n        }\n      }\n    },\n```", "```\n    Tetromino4(2, 2) {\n      override fun getFrame(frameNumber: Int): Frame {\n        return when (frameNumber) {\n          0 -> Frame(4).addRow(\"1111\")\n          1 -> Frame(1)\n                       .addRow(\"1\")\n                       .addRow(\"1\")\n                       .addRow(\"1\")\n                       .addRow(\"1\")\n          else -> throw IllegalArgumentException(\"$frameNumber is an \n                                       invalid frame number.\")\n        }\n      }\n    },\n\n```", "```\n    Tetromino5(4, 1) {\n      override fun getFrame(frameNumber: Int): Frame {\n        return when (frameNumber) {\n          0 -> Frame(3)\n                     .addRow(\"010\")\n                     .addRow(\"111\")\n          1 -> Frame(2)\n                     .addRow(\"10\")\n                     .addRow(\"11\")\n                     .addRow(\"10\")\n          2 -> Frame(3)\n                     .addRow(\"111\")\n                     .addRow(\"010\")\n          3 -> Frame(2)\n                     .addRow(\"01\")\n                     .addRow(\"11\")\n                     .addRow(\"01\")\n          else -> throw IllegalArgumentException(\"$frameNumber is an \n                                       invalid frame number.\")\n        }\n      }\n    },\n```", "```\n    Tetromino6(4, 1) {\n      override fun getFrame(frameNumber: Int): Frame {\n        return when (frameNumber) {\n          0 -> Frame(3)\n                     .addRow(\"100\")\n                     .addRow(\"111\")\n          1 -> Frame(2)\n                     .addRow(\"11\")\n                     .addRow(\"10\")\n                     .addRow(\"10\")\n          2 -> Frame(3)\n                     .addRow(\"111\")\n                     .addRow(\"001\")\n          3 -> Frame(2)\n                     .addRow(\"01\")\n                     .addRow(\"01\")\n                     .addRow(\"11\")\n          else -> throw IllegalArgumentException(\"$frameNumber is \n                                       an invalid frame number.\")\n        }\n      }\n    },\n```", "```\n    Tetromino7(4, 1) {\n      override fun getFrame(frameNumber: Int): Frame {\n        return when (frameNumber) {\n          0 ->  Frame(3)\n                     .addRow(\"001\")\n                     .addRow(\"111\")\n          1 -> Frame(2)\n                     .addRow(\"10\")\n                     .addRow(\"10\")\n                     .addRow(\"11\")\n          2 -> Frame(3)\n                     .addRow(\"111\")\n                     .addRow(\"100\")\n          3 -> Frame(2)\n                     .addRow(\"11\")\n                     .addRow(\"01\")\n                     .addRow(\"01\")\n          else -> throw IllegalArgumentException(\"$frameNumber is \n                                       an invalid frame number.\")\n        }\n      }\n    };\n\n    abstract fun getFrame(frameNumber: Int): Frame\n}\n```", "```\npackage com.mydomain.tetris.models;\nimport android.graphics.Color;\nimport android.graphics.Point;\n\npublic class Block {\n  private int shapeIndex;\n  private int frameNumber;\n  private BlockColor color;\n  private Point position;\n\n  public enum BlockColor {\n    PINK(Color.rgb(255, 105, 180), (byte) 2),\n    GREEN(Color.rgb(0, 128, 0), (byte) 3),\n    ORANGE(Color.rgb(255, 140, 0), (byte) 4),\n    YELLOW(Color.rgb(255, 255, 0), (byte) 5),\n    CYAN(Color.rgb(0, 255, 255), (byte) 6);\n\n    BlockColor(int rgbValue, byte value) {\n      this.rgbValue = rgbValue;\n      this.byteValue = value;\n    }\n\n    private final int rgbValue;\n    private final byte byteValue;\n  }\n}\n```", "```\npublic class Person {\n  Person(String fullName, int age) {\n    this.fullName = fullName;\n    this.age = age;\n  }\n\n  private String fullName;\n  private int age;\n\n  public String getFullName() {\n    return fullName;\n  }\n\n  public int getAge() {\n    return age;\n  }\n}\n```", "```\npublic class Person(private var fullName: String) {\n  var name: String\n  get() = fullName\n  set(value)  {\n    fullName = value\n  }\n}\n```", "```\npublic class Person { .. }\n```", "```\npublic class Person(private var fullName: String) {\n  protected name: String\n  get() = fullName\n  set(value)  {\n    fullName = value\n  }\n}\n```", "```\ninternal class Person { }\n```", "```\npublic class Block {\n  private int shapeIndex;\n  private int frameNumber;\n  private BlockColor color;\n  private Point position;\n```", "```\n  private Block(int shapeIndex, BlockColor blockColor) {\n    this.frameNumber = 0;\n    this.shapeIndex = shapeIndex;\n    this.color = blockColor;\n    this.position = new Point(AppModel.FieldConstants\n                              .COLUMN_COUNT.getValue() / 2, 0);\n  }\n\n  public enum BlockColor {\n    PINK(Color.rgb(255, 105, 180), (byte) 2),\n    GREEN(Color.rgb(0, 128, 0), (byte) 3),\n    ORANGE(Color.rgb(255, 140, 0), (byte) 4),\n    YELLOW(Color.rgb(255, 255, 0), (byte) 5),\n    CYAN(Color.rgb(0, 255, 255), (byte) 6);\n\n    BlockColor(int rgbValue, byte value) {\n      this.rgbValue = rgbValue;\n      this.byteValue = value;\n    }\n\n    private final int rgbValue;\n    private final byte byteValue;\n  }\n}\n```", "```\npublic class Block {\n  private int shapeIndex;\n  private int frameNumber;\n  private BlockColor color;\n  private Point position;\n\n```", "```\n\n  private Block(int shapeIndex, BlockColor blockColor) {\n    this.frameNumber = 0;\n    this.shapeIndex = shapeIndex;\n</span>    this.color = blockColor;\n    this.position = new Point( FieldConstants.COLUMN_COUNT\n                               .getValue()/2, 0);\n  }\n\n  public static Block createBlock() {\n    Random random = new Random();\n    int shapeIndex = random.nextInt(Shape.values().length);\n    BlockColor blockColor = BlockColor.values() \n         [random.nextInt(BlockColor.values().length)];\n\n    Block block = new Block(shapeIndex, blockColor);\n    block.position.x = block.position.x - Shape.values()\n          [shapeIndex].getStartPosition();\n    return block;\n  }\n\n  public enum BlockColor {\n    PINK(Color.rgb(255, 105, 180), (byte) 2),\n    GREEN(Color.rgb(0, 128, 0), (byte) 3),\n    ORANGE(Color.rgb(255, 140, 0), (byte) 4),\n    YELLOW(Color.rgb(255, 255, 0), (byte) 5),\n    CYAN(Color.rgb(0, 255, 255), (byte) 6);\n\n    BlockColor(int rgbValue, byte value) {\n      this.rgbValue = rgbValue;\n      this.byteValue = value;\n    }\n\n    private final int rgbValue;\n    private final byte byteValue;\n  }\n}\n```", "```\npublic static int getColor(byte value) {\n  for (BlockColor colour : BlockColor.values()) {\n    if (value == colour.byteValue) {\n      return colour.rgbValue;\n    }\n  }\n  return -1;\n}\n\npublic final void setState(int frame, Point position) {\n  this.frameNumber = frame;\n  this.position = position;\n}\n\n@NonNull\npublic final byte[][] getShape(int frameNumber) {\n  return Shape.values()[shapeIndex].getFrame(frameNumber).as2dByteArray();\n}\n\npublic Point getPosition() {\n  return this.position;\n}\n\npublic final int getFrameCount() {\n  return Shape.values()[shapeIndex].getFrameCount();\n}\n\npublic int getFrameNumber() {\n  return frameNumber;\n}\n\npublic int getColor() {\n  return color.rgbValue;\n}\n\npublic byte getStaticValue() {\n  return color.byteValue;\n}\n```", "```\nimport android.support.annotation.NonNull;\n```", "```\nthis.position = new Point(FieldConstants.COLUMN_COUNT.getValue()/2, 0);\n```", "```\nenum class FieldConstants(val value: Int) {\n  COLUMN_COUNT(10), ROW_COUNT(20);\n}\n```", "```\nthis.position = new Point( FieldConstants.COLUMN_COUNT.getValue()/2, 0);\n```", "```\npackage com.mydomain.tetris.models\n\nimport android.graphics.Point\nimport com.mydomain.tetris.constants.FieldConstants\nimport com.mydomain.tetris.helpers.array2dOfByte\nimport com.mydomain.tetris.storage.AppPreferences\n\nclass AppModel\n```", "```\nclass AppModel {\n  enum class Statuses {\n    AWAITING_START, ACTIVE, INACTIVE, OVER\n  }\n\n  enum class Motions {\n    LEFT, RIGHT, DOWN, ROTATE\n  }\n}\n```", "```\npackage com.mydomain.tetris.models\n\nimport android.graphics.Point\nimport com.mydomain.tetris.constants.FieldConstants\nimport com.mydomain.tetris.helpers.array2dOfByte\nimport com.mydomain.tetris.storage.AppPreferences\n\nclass AppModel {\n  var score: Int = 0\n  private var preferences: AppPreferences? = null\n\n  var currentBlock: Block? = null\n  var currentState: String = Statuses.AWAITING_START.name\n\n  private var field: Array<ByteArray> = array2dOfByte(\n    FieldConstants.ROW_COUNT.value,\n    FieldConstants.COLUMN_COUNT.value\n  )\n\n  enum class Statuses {\n    AWAITING_START, ACTIVE, INACTIVE, OVER\n  }\n\n  enum class Motions {\n    LEFT, RIGHT, DOWN, ROTATE\n  }\n}\n```", "```\nfun setPreferences(preferences: AppPreferences?) {\n  this.preferences = preferences\n}\n\nfun getCellStatus(row: Int, column: Int): Byte? {\n  return field[row][column]\n}\n\nprivate fun setCellStatus(row: Int, column: Int, status: Byte?) {\n  if (status != null) {\n    field[row][column] = status\n  }\n}\n```", "```\nclass AppModel {\n\n  var score: Int = 0\n  private var preferences: AppPreferences? = null\n\n  var currentBlock: Block? = null\n  var currentState: String = Statuses.AWAITING_START.name\n\n  private var field: Array<ByteArray> = array2dOfByte(\n    FieldConstants.ROW_COUNT.value,\n    FieldConstants.COLUMN_COUNT.value\n  )\n\n  fun setPreferences(preferences: AppPreferences?) {\n    this.preferences = preferences\n  }\n\n  fun getCellStatus(row: Int, column: Int): Byte? {\n    return field[row][column]\n  }\n\n  private fun setCellStatus(row: Int, column: Int, status: Byte?) {\n    if (status != null) {\n      field[row][column] = status\n    }\n  }\n\n  fun isGameOver(): Boolean {\n    return currentState == Statuses.OVER.name\n  }\n\n  fun isGameActive(): Boolean {\n    return currentState == Statuses.ACTIVE.name\n  }\n\n  fun isGameAwaitingStart(): Boolean {\n    return currentState == Statuses.AWAITING_START.name\n  }\n\n  enum class Statuses {\n    AWAITING_START, ACTIVE, INACTIVE, OVER\n  }\n\n  enum class Motions {\n    LEFT, RIGHT, DOWN, ROTATE\n  }\n}\n```", "```\nprivate fun boostScore() {\n  score += 10\n  if (score > preferences?.getHighScore() as Int)\n    preferences?.saveHighScore(score)\n}\n```", "```\nprivate fun generateNextBlock() {\n  currentBlock = Block.createBlock()\n}\n```", "```\npackage com.mydomain.tetris.constants\n\nenum class CellConstants(val value: Byte) {\n  EMPTY(0), EPHEMERAL(1)\n}\n```", "```\nprivate fun validTranslation(position: Point, shape: Array<ByteArray>): Boolean {\n  return if (position.y < 0 || position.x < 0) {\n    false\n  } else if (position.y + shape.size > FieldConstants.ROW_COUNT.value) {\n    false\n  } else if (position.x + shape[0].size > FieldConstants\n             .COLUMN_COUNT.value) {\n    false\n  } else {\n    for (i in 0 until shape.size) {\n      for (j in 0 until shape[i].size) {\n        val y = position.y + i\n        val x = position.x + j\n\n        if (CellConstants.EMPTY.value != shape[i][j] && \n            CellConstants.EMPTY.value != field[y][x]) {\n          return false\n        }\n      }\n    }\n    true\n    }\n  }\n```", "```\nprivate fun moveValid(position: Point, frameNumber: Int?): Boolean {\n  val shape: Array<ByteArray>? = currentBlock?\n                                 .getShape(frameNumber as Int)\n  return validTranslation(position, shape as Array<ByteArray>)\n}\n```", "```\nfun generateField(action: String) {\n  if (isGameActive()) {\n    resetField()\n    var frameNumber: Int? = currentBlock?.frameNumber\n    val coordinate: Point? = Point()\n    coordinate?.x = currentBlock?.position?.x\n    coordinate?.y = currentBlock?.position?.y\n\n    when (action) {\n      Motions.LEFT.name -> {\n        coordinate?.x = currentBlock?.position?.x?.minus(1)\n      }\n      Motions.RIGHT.name -> {\n        coordinate?.x = currentBlock?.position?.x?.plus(1)\n      }\n      Motions.DOWN.name -> {\n        coordinate?.y = currentBlock?.position?.y?.plus(1)\n      }\n      Motions.ROTATE.name -> {\n        frameNumber = frameNumber?.plus(1)\n\n        if (frameNumber != null) {\n          if (frameNumber >= currentBlock?.frameCount as Int) {\n            frameNumber = 0\n          }\n        }\n      }\n    }\n\n    if (!moveValid(coordinate as Point, frameNumber)) {\n      translateBlock(currentBlock?.position as Point, \n                     currentBlock?.frameNumber as Int)\n      if (Motions.DOWN.name == action) {\n        boostScore()\n        persistCellData()\n        assessField()\n        generateNextBlock()\n\n        if (!blockAdditionPossible()) {\n          currentState = Statuses.OVER.name;\n          currentBlock = null;\n          resetField(false);\n        }\n      }\n    } else {\n      if (frameNumber != null) {\n        translateBlock(coordinate, frameNumber)\n        currentBlock?.setState(frameNumber, coordinate)\n      }\n    }\n  }\n}\n```", "```\nprivate fun resetField(ephemeralCellsOnly: Boolean = true) {\n  for (i in 0 until FieldConstants.ROW_COUNT.value) {\n    (0 until FieldConstants.COLUMN_COUNT.value)\n    .filter { !ephemeralCellsOnly || field[i][it] == \n              CellConstants.EPHEMERAL.value }\n    .forEach { field[i][it] = CellConstants.EMPTY.value }\n  }\n}\n\nprivate fun persistCellData() {\n  for (i in 0 until field.size) {\n    for (j in 0 until field[i].size) {\n      var status = getCellStatus(i, j)\n\n      if (status == CellConstants.EPHEMERAL.value) {\n        status = currentBlock?.staticValue\n        setCellStatus(i, j, status)\n      }\n    }\n  }\n}\n\nprivate fun assessField() {\n  for (i in 0 until field.size) {\n    var emptyCells = 0;\n\n    for (j in 0 until field[i].size) {\n      val status = getCellStatus(i, j)\n      val isEmpty = CellConstants.EMPTY.value == status\n      if (isEmpty)\n        emptyCells++\n    }\n    if (emptyCells == 0)\n      shiftRows(i)\n  }\n}\n```", "```\nprivate fun translateBlock(position: Point, frameNumber: Int) {\n  synchronized(field) {\n    val shape: Array<ByteArray>? = currentBlock?.getShape(frameNumber)\n\n    if (shape != null) {\n      for (i in shape.indices) {\n        for (j in 0 until shape[i].size) {\n          val y = position.y + i\n          val x = position.x + j\n\n          if (CellConstants.EMPTY.value != shape[i][j]) {\n            field[y][x] = shape[i][j]\n          }\n        }\n      }\n    }\n  }\n}\n\nprivate fun blockAdditionPossible(): Boolean {\n  if (!moveValid(currentBlock?.position as Point, \n      currentBlock?.frameNumber)) {\n    return false\n  }\n  return true\n}\n\nprivate fun shiftRows(nToRow: Int) {\n  if (nToRow > 0) {\n    for (j in nToRow - 1 downTo 0) {\n      for (m in 0 until field[j].size) {\n        setCellStatus(j + 1, m, getCellStatus(j, m))\n      }\n    }\n  }\n\n  for (j in 0 until field[0].size) {\n    setCellStatus(0, j, CellConstants.EMPTY.value)\n  }\n}\n\nfun startGame() {\n  if (!isGameActive()) {\n    currentState = Statuses.ACTIVE.name\n    generateNextBlock()\n  }\n}\n\nfun restartGame() {\n  resetModel()\n  startGame()\n}\n\nfun endGame() {\n  score = 0\n  currentState = AppModel.Statuses.OVER.name\n}\n\nprivate fun resetModel() {\n  resetField(false)\n  currentState = Statuses.AWAITING_START.name\n  score = 0\n}\n```", "```\nprivate fun assessField() {\n  for (i in 0 until field.size) {\n    var emptyCells = 0;\n\n    for (j in 0 until field[i].size) {\n      val status = getCellStatus(i, j)\n      val isEmpty = CellConstants.EMPTY.value == status\n\n      if (isEmpty)\n        emptyCells++\n    }\n\n    if (emptyCells == 0)\n      shiftRows(i)\n  }\n}\n```", "```\nprivate fun generateNextBlock() {\n  currentBlock = Block.createBlock()\n}\n```", "```\nprivate fun blockAdditionPossible(): Boolean {\n  if (!moveValid(currentBlock?.position as Point,\n      currentBlock?.frameNumber)) {\n    return false\n  }\n  return true\n}\n```", "```\npackage com.mydomain.tetris.views\n\nimport android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.graphics.RectF\nimport android.os.Handler\nimport android.os.Message\nimport android.util.AttributeSet\nimport android.view.View\nimport android.widget.Toast\nimport com.mydomain.tetris.constants.CellConstants\nimport com.mydomain.tetris.GameActivity\nimport com.mydomain.tetris.constants.FieldConstants\nimport com.mydomain.tetris.models.AppModel\nimport com.mydomain.tetris.models.Block\n\nclass TetrisView : View {\n\n  private val paint = Paint()\n  private var lastMove: Long = 0\n  private var model: AppModel? = null\n  private var activity: GameActivity? = null\n  private val viewHandler = ViewHandler(this)\n  private var cellSize: Dimension = Dimension(0, 0)\n  private var frameOffset: Dimension = Dimension(0, 0)\n\n  constructor(context: Context, attrs: AttributeSet) : \n             super(context, attrs)\n\n  constructor(context: Context, attrs: AttributeSet, defStyle: Int) :\n             super(context, attrs, defStyle)\n\n  companion object {\n    private val DELAY = 500\n    private val BLOCK_OFFSET = 2\n    private val FRAME_OFFSET_BASE = 10\n  }\n}\n```", "```\nprivate class ViewHandler(private val owner: TetrisView) : Handler() {\n\n  override fun handleMessage(message: Message) {\n    if (message.what == 0) {\n      if (owner.model != null) {\n        if (owner.model!!.isGameOver()) {\n          owner.model?.endGame()\n          Toast.makeText(owner.activity, \"Game over\", \n                         Toast.LENGTH_LONG).show();\n        }\n        if (owner.model!!.isGameActive()) {\n          owner.setGameCommandWithDelay(AppModel.Motions.DOWN)\n        }\n      }\n    }\n  }\n\n  fun sleep(delay: Long) {\n    this.removeMessages(0)\n    sendMessageDelayed(obtainMessage(0), delay)\n  }\n}\n```", "```\nprivate data class Dimension(val width: Int, val height: Int)\n```", "```\nfun setModel(model: AppModel) {\n    this.model = model\n}\n\nfun setActivity(gameActivity: GameActivity) {\n    this.activity = gameActivity\n}\n```", "```\nfun setGameCommand(move: AppModel.Motions) {\n  if (null != model && (model?.currentState == AppModel.Statuses.ACTIVE.name)) {\n    if (AppModel.Motions.DOWN == move) {\n      model?.generateField(move.name)\n      invalidate()\n      return\n    }\n    setGameCommandWithDelay(move)\n  }\n}\n\nfun setGameCommandWithDelay(move: AppModel.Motions) {\n  val now = System.currentTimeMillis()\n\n  if (now - lastMove > DELAY) {\n    model?.generateField(move.name)\n    invalidate()\n    lastMove = now\n  }\n  updateScores()\n  viewHandler.sleep(DELAY.toLong())\n}\n\nprivate fun updateScores() {\n  activity?.tvCurrentScore?.text = \"${model?.score}\"\n  activity?.tvHighScore?.text = \"${activity?.appPreferences?.getHighScore()}\"\n}\n```", "```\noverride fun onDraw(canvas: Canvas) {\n  super.onDraw(canvas)\n  drawFrame(canvas)\n\n  if (model != null) {\n    for (i in 0 until FieldConstants.ROW_COUNT.value) {\n      for (j in 0 until FieldConstants.COLUMN_COUNT.value) {\n        drawCell(canvas, i, j)\n      }\n    }\n  }\n}\n\nprivate fun drawFrame(canvas: Canvas) {\n  paint.color = Color.LTGRAY\n\n  canvas.drawRect(frameOffset.width.toFloat(),\n            frameOffset.height.toFloat(), width - frameOffset.width.toFloat(),\n            height - frameOffset.height.toFloat(), paint)\n}\n\nprivate fun drawCell(canvas: Canvas, row: Int, col: Int) {\n  val cellStatus = model?.getCellStatus(row, col)\n\n  if (CellConstants.EMPTY.value != cellStatus) {\n    val color = if (CellConstants.EPHEMERAL.value == cellStatus) {\n      model?.currentBlock?.color\n    } else {\n      Block.getColor(cellStatus as Byte)\n    }\n    drawCell(canvas, col, row, color as Int)\n  }\n}\n\nprivate fun drawCell(canvas: Canvas, x: Int, y: Int, rgbColor: Int) {\n  paint.color = rgbColor\n\n  val top: Float = (frameOffset.height + y * cellSize.height + BLOCK_OFFSET).toFloat()\n  val left: Float = (frameOffset.width + x * cellSize.width + BLOCK_OFFSET).toFloat()\n  val bottom: Float = (frameOffset.height + (y + 1) * cellSize.height - BLOCK_OFFSET).toFloat()\n  val right: Float = (frameOffset.width + (x + 1) * cellSize.width - BLOCK_OFFSET).toFloat()\n  val rectangle = RectF(left, top, right, bottom)\n\n  canvas.drawRoundRect(rectangle, 4F, 4F, paint)\n}\n\noverride fun onSizeChanged(width: Int, height: Int, previousWidth: Int, previousHeight: Int) {\n  super.onSizeChanged(width, height, previousWidth, previousHeight)\n\n  val cellWidth = (width - 2 * FRAME_OFFSET_BASE) / FieldConstants.COLUMN_COUNT.value\n  val cellHeight = (height - 2 * FRAME_OFFSET_BASE) / FieldConstants.ROW_COUNT.value\n  val n = Math.min(cellWidth, cellHeight)\n  this.cellSize = Dimension(n, n)\n  val offsetX = (width - FieldConstants.COLUMN_COUNT.value * n) / 2\n  val offsetY = (height - FieldConstants.ROW_COUNT.value * n) / 2\n  this.frameOffset = Dimension(offsetX, offsetY)\n}\n```", "```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.mydomain.tetris.GameActivity\">\n  <LinearLayout\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"match_parent\"\n         android:orientation=\"horizontal\"\n         android:weightSum=\"10\"\n         android:background=\"#e8e8e8\">\n    <LinearLayout\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"match_parent\"\n           android:orientation=\"vertical\"\n           android:gravity=\"center\"\n           android:paddingTop=\"32dp\"\n           android:paddingBottom=\"32dp\"\n           android:layout_weight=\"1\">\n      <LinearLayout\n              android:layout_width=\"wrap_content\"\n              android:layout_height=\"0dp\"\n              android:layout_weight=\"1\"\n              android:orientation=\"vertical\"\n              android:gravity=\"center\">\n        <TextView\n              android:layout_width=\"wrap_content\"\n              android:layout_height=\"wrap_content\"\n              android:text=\"@string/current_score\"\n              android:textAllCaps=\"true\"\n              android:textStyle=\"bold\"\n              android:textSize=\"14sp\"/>\n         <TextView\n              android:id=\"@+id/tv_current_score\"\n              android:layout_width=\"wrap_content\"\n              android:layout_height=\"wrap_content\"\n              android:textSize=\"18sp\"/>\n         <TextView\n              android:layout_width=\"wrap_content\"\n              android:layout_height=\"wrap_content\"\n              android:layout_marginTop=\"@dimen/layout_margin_top\"\n              android:text=\"@string/high_score\"\n              android:textAllCaps=\"true\"\n              android:textStyle=\"bold\"\n              android:textSize=\"14sp\"/>\n         <TextView\n              android:id=\"@+id/tv_high_score\"\n              android:layout_width=\"wrap_content\"\n              android:layout_height=\"wrap_content\"\n              android:textSize=\"18sp\"/>\n       </LinearLayout>\n       <Button\n               android:id=\"@+id/btn_restart\"\n               android:layout_width=\"wrap_content\"\n               android:layout_height=\"wrap_content\"\n               android:text=\"@string/btn_restart\"/>\n     </LinearLayout>\n     <View\n           android:layout_width=\"1dp\"\n           android:layout_height=\"match_parent\"\n           android:background=\"#000\"/>\n     <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_weight=\"9\">\n       <!-- Adding TetrisView -->\n       <com.mydomain.tetris.views.TetrisView\n                android:id=\"@+id/view_tetris\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\" />\n\n     </LinearLayout>\n   </LinearLayout>\n</android.support.constraint.ConstraintLayout>\n```", "```\npackage com.mydomain.tetris\n\nimport android.os.Bundle\nimport android.support.v7.app.AppCompatActivity\nimport android.view.MotionEvent\nimport android.view.View\nimport android.widget.Button\nimport android.widget.TextView\nimport com.mydomain.tetris.models.AppModel\nimport com.mydomain.tetris.storage.AppPreferences\nimport com.mydomain.tetris.views.TetrisView\n\nclass GameActivity: AppCompatActivity() {\n\n  var tvHighScore: TextView? = null\n  var tvCurrentScore: TextView? = null\n  private lateinit var tetrisView: TetrisView \n\n  var appPreferences: AppPreferences? = null\n  private val appModel: AppModel = AppModel() \n\n  public override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_game)\n    appPreferences = AppPreferences(this)\n    appModel.setPreferences(appPreferences) \n\n    val btnRestart = findViewById<Button>(R.id.btn_restart)\n    tvHighScore = findViewById<TextView>(R.id.tv_high_score)\n    tvCurrentScore = findViewById<TextView>(R.id.tv_current_score)\n    tetrisView = findViewById<TetrisView>(R.id.view_tetris) \n    tetrisView.setActivity(this) \n    tetrisView.setModel(appModel) \n\n    tetrisView.setOnTouchListener(this::onTetrisViewTouch)\n    btnRestart.setOnClickListener(this::btnRestartClick)\n\n    updateHighScore()\n    updateCurrentScore()\n  }\n\n  private fun btnRestartClick(view: View) {\n    appModel.restartGame()\n  }\n\n  private fun onTetrisViewTouch(view: View, event: MotionEvent):\n              Boolean {\n    if (appModel.isGameOver() || appModel.isGameAwaitingStart()) {\n      appModel.startGame()\n      tetrisView.setGameCommandWithDelay(AppModel.Motions.DOWN)\n\n    } else if(appModel.isGameActive()) {\n      when (resolveTouchDirection(view, event)) {\n        0 -> moveTetromino(AppModel.Motions.LEFT)\n        1 -> moveTetromino(AppModel.Motions.ROTATE)\n        2 -> moveTetromino(AppModel.Motions.DOWN)\n        3 -> moveTetromino(AppModel.Motions.RIGHT)\n      }\n    }\n    return true\n  }\n\n  private fun resolveTouchDirection(view: View, event: MotionEvent): \n              Int {\n    val x = event.x / view.width\n    val y = event.y / view.height\n    val direction: Int\n\n    direction = if (y > x) {\n      if (x > 1 - y) 2 else 0 \n    } \n    else {\n      if (x > 1 - y) 3 else 1\n    }\n    return direction\n  }\n\n  private fun moveTetromino(motion: AppModel.Motions) {\n    if (appModel.isGameActive()) {\n      tetrisView.setGameCommand(motion)\n    }\n  }\n\n  private fun updateHighScore() {\n    tvHighScore?.text = \"${appPreferences?.getHighScore()}\"\n  }\n\n  private fun updateCurrentScore() {\n    tvCurrentScore?.text = \"0\"\n  }\n}\n```"]