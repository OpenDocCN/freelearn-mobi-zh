<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Installation on the UDOO</h1></div></div></div><p>In order to continue our exploration, we will need to get a tangible system in place to work with. In this chapter, we will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build Android 4.3 for the UDOO from source</li><li class="listitem" style="list-style-type: disc">Flash an SD card with our boot images</li><li class="listitem" style="list-style-type: disc">Get the UDOO running while capturing logs</li><li class="listitem" style="list-style-type: disc">Establish an <code class="literal">adb</code> connection to the UDOO</li><li class="listitem" style="list-style-type: disc">Rebuild the kernel with SELinux support</li><li class="listitem" style="list-style-type: disc">Verify our SELinux UDOO image works as expected</li></ul></div><p>We will <a id="id97" class="indexterm"/>start with the publicly available UDOO Android 4.3 Jelly Bean source code, which can be downloaded from <a class="ulink" href="http://www.udoo.org/downloads/">http://www.udoo.org/downloads/</a>. It is assumed you have a UDOO and have verified that it is functional. It is recommended you follow the instructions on the UDOO website for getting started with the Android 4.3 prebuilt image as an initial test (for more information, refer to <a class="ulink" href="http://www.udoo.org/getting-started/">http://www.udoo.org/getting-started/</a>).</p><p>You will also need an appropriate development system for working with Android and a UDOO, but the details of this are beyond the scope of this chapter. An appendix has been provided detailing the setup of a standard Ubuntu Linux 12.04 system to ensure you have the highest probability of success duplicating the work in this book.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Retrieving the source</h1></div></div></div><p>Let's start<a id="id98" class="indexterm"/> this exercise by downloading the Android 4.3 Jellybean source code from the download links given in the preceding section, and extract the download into a workspace using the following commands:</p><div><pre class="programlisting">
<strong>$ mkdir ~/udoo &amp;&amp; cd ~/udoo</strong>
<strong>$ tar -xavf ~/Downloads/UDOO_Android_4.3_Source_v2.0.tar.gz</strong>
</pre></div><p>Once this is done, you should review the UDOO documentation and the Android <a id="id99" class="indexterm"/>source code building instructions at the following URLs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.elinux.org/UDOO_compile_android_4-2-2_from_sources">http://www.elinux.org/UDOO_compile_android_4-2-2_from_sources</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://source.android.com/source/initializing.html">http://source.android.com/source/initializing.html</a></li></ul></div><p>The<a id="id100" class="indexterm"/> instructions provided by the preceding URL discuss how to build Android with Open JDK 7. However, these instructions are for the current release of Android (L preview) and are not 100 percent relevant. For Android 4.3, you must build with Oracle Java 6, which is archived by Oracle and found at <a class="ulink" href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html"> http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html</a>.</p><p>It is assumed that you have a duplicate of the system detailed in the <a class="link" href="apa.html" title="Appendix A. The Development Environment">Appendix</a>, <em>The Development Environment</em>. That appendix, among other things, walks you through the setup of Oracle Java 6 as your only Java instance. However, for those who prefer to work from their existing systems, particularly those with multiple Java SDKs, please keep in mind you will need to ensure your system is using the Oracle Java 6 tools when working through the rest of this book.</p><p>Finish setting up your environment by changing to the root of your UDOO source tree and execute the following command:</p><div><pre class="programlisting">
<strong>$ . setup udoo-eng</strong>
</pre></div><p>Once the environment is configured, we need to build the <code class="literal">bootloader</code>:</p><div><pre class="programlisting">
<strong>$ cd bootable/bootloader/uboot-imx</strong>
<strong>$ ./compile.sh -c</strong>
</pre></div><p>A <a id="id101" class="indexterm"/>graphical menu will appear. Ensure the settings are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>DDR Size</strong>: Select 1 Giga, bus size 64, and active CS \ 1 (256Mx4)</li><li class="listitem" style="list-style-type: disc"><strong>Board Type</strong>: Select UDOO</li><li class="listitem" style="list-style-type: disc"><strong>CPU type</strong>: Select quad-core or dual-core option, dependent on which system you have. We happen to be using the quad-core system.</li><li class="listitem" style="list-style-type: disc"><strong>OS type</strong>: Select <strong>Android</strong></li><li class="listitem" style="list-style-type: disc"><strong>Environment device</strong>: Must select <strong>SD/MMC</strong></li><li class="listitem" style="list-style-type: disc"><strong>Extra options</strong>: <strong>CLEAN</strong> should be selected</li><li class="listitem" style="list-style-type: disc"><strong>Compiler options</strong>: Paths to tool chains can be selected here; just take the defaults</li></ul></div><p>The following screenshot shows the graphical menu displayed by the preceding command:</p><div><img src="img/0594OS_04_01.jpg" alt="Retrieving the source"/></div><p>When <a id="id102" class="indexterm"/>you exit, be sure to save. Then start the compilation:</p><div><pre class="programlisting">
<strong>$ ./compile.sh </strong>
<strong>Board type selected: UDOO</strong>
<strong>CPU Type: QUAD/DUAL</strong>
<strong>OS type: Android</strong>
<strong>...</strong>
<strong>/home/bookuser/udoo/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-objcopy -O srec u-boot u-boot.srec</strong>
<strong>/home/bookuser/udoo/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-objcopy --gap-fill=0xff -O binary u-boot u-boot.bin</strong>
</pre></div><p>Just to be safe, verify your build was successful by using <code class="literal">ls u-boot.bin</code> to ensure the <code class="literal">bootloader</code> image now exists. Now, build Android using the following command:</p><div><pre class="programlisting">
<strong>$ croot</strong>
<strong>$ make –j4 2&gt;&amp;1 | tee logz</strong>
</pre></div><p>The first command is something that was sourced in the setup scripts for Android and takes us back to the root of our project tree. The second command, <code class="literal">make</code>, builds the system. You should set the option for <code class="literal">j</code> to twice your CPU/core count in most cases. Because many of you might have a dual-core machine, we'll use <code class="literal">–j4</code>. One of the authors of this book uses 8 CPU cores, for example, and uses the flag <code class="literal">-j16</code>. The file redirection and <code class="literal">tee</code> commands capture the build output to a file. This is important to help and debug any build issues. This build, depending on your system can take a long, long time. On the previously mentioned 8-core system with 16GB RAM, this took a little over 35 minutes. On other systems, we've experienced build times over 3 hours.</p><p>In this case, capturing the logs proved very useful. The build terminated with an error, and by searching the logs for <code class="literal">error</code>, we found the following:</p><div><pre class="programlisting">
<strong>$ grep error logz </strong>
<strong>...</strong>
<strong>external/mtd-utils/mkfs.ubifs/mkfs.ubifs.h:48:23: fatal error: uuid/uuid.h: No such file or directory</strong>
<strong>external/mtd-utils/mkfs.ubifs/mkfs.ubifs.h:48:23: fatal error: uuid/uuid.h: No such file or directory</strong>
<strong>external/mtd-utils/mkfs.ubifs/mkfs.ubifs.h:48:23: fatal error: uuid/uuid.h: No such file or directory</strong>
<strong>...</strong>
</pre></div><p>By evaluating<a id="id103" class="indexterm"/> those errors, we discover we are missing headers for <code class="literal">uuid</code> and <code class="literal">lzo1x</code>. We can also open the Android makefile, <code class="literal">external/mtd-utils/mkfs.ubifs/Android.mk</code>, and determine the likely libraries involved from the line <code class="literal">LOCAL_LDLIBS:= -lz -llzo2 -lm -luuid -m64</code>. Searching reveals the specific Ubuntu package we're missing; we will install them and build again. The <code class="literal">$</code> character at the end of the search string ensures we only get results ending in <code class="literal">uuid/uuid.h</code>. Without it, we might match files ending in <code class="literal">.html</code> or <code class="literal">.hpp</code>:</p><p>$ sudo apt-file search -x "uuid/uuid.h$"</p><div><pre class="programlisting">
<strong>uuid-dev: /usr/include/uuid/uuid.h</strong>
<strong>$ sudo apt-get install uuid-dev</strong>
<strong>$ make –j4 2&gt;&amp;1 | tee logz</strong>
</pre></div><p>A successful build should produce some final output similar to the following:</p><div><pre class="programlisting">
<strong>...</strong>
<strong>Running: mkuserimg.sh out/target/product/udoo/system out/target/product/udoo/obj/PACKAGING/systemimage_intermediates/system.img ext4 system 293601280 out/target/product/udoo/root/file_contexts</strong>
<strong>Install system fs image: out/target/product/udoo/system.img</strong>
<strong>out/target/product/udoo/system.img+out/target/product/udoo/obj/PACKAGING/recovery_patch_intermediates/recovery_from_boot.p maxsize=299747712 blocksize=4224 total=294120167 reserve=3028608</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Flashing image on an SD card</h1></div></div></div><p>With the <code class="literal">bootloader</code>, Android userspace, and Linux kernel built, it's time to insert an SD card and <a id="id104" class="indexterm"/>flash the images. Insert an SD card into your host computer, and ensure it's unmounted. In Ubuntu, removable media are mounted automatically, so you'll need to find the <code class="literal">/dev/sd*</code> device that is your flash drive, and <code class="literal">umount</code> it. For the remainder of the text, we will use <code class="literal">/dev/sdd</code> as the flash drive, but it is important to use the correct device for your system. If you have used this SD card for installing UDOO before, the card will contain multiple partitions, so you might see <code class="literal">/dev/sdd&lt;num&gt;</code> mounted numerous times:</p><div><pre class="programlisting">
<strong>$ mount | grep sdd</strong>
<strong>/dev/sdd7 on /media/vender type ext4 (rw,nosuid,nodev,uhelper=udisks)</strong>
<strong>/dev/sdd4 on /media/data type ext4 (rw,nosuid,nodev,uhelper=udisks)</strong>
<strong>/dev/sdd5 on /media/57f8f4bc-abf4-655f-bf67-946fc0f9f25b type ext4 (rw,nosuid,nodev,uhelper=udisks)</strong>
<strong>/dev/sdd6 on /media/cache type ext4 (rw,nosuid,nodev,uhelper=udisks)</strong>
<strong>$ sudo bash -c "umount /dev/sdd4 &amp;&amp; umount /dev/sdd5 &amp;&amp; umount /dev/sdd6 &amp;&amp; umount /dev/sdd7"</strong>
</pre></div><p>Once the<a id="id105" class="indexterm"/> SD card is properly unmounted, we can flash our image:</p><div><pre class="programlisting">
<strong>$ sudo -E ./make_sd.sh /dev/sdd</strong>
</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>You must use the <code class="literal">-E</code> parameter on <code class="literal">sudo</code> to preserve all the exported variables from the Android build. You must be in the same terminal session you built Android in. Otherwise you will see the error <code class="literal">No OUT export variable found! Setup not called in advance…</code>.</p></div></div><p>Once this completes (it will take a while), it's important to flush the block device caches back to the disk with the command, <code class="literal">sudo sync</code>. Then, you can remove the SD card, insert it into the UDOO, and boot!</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>UDOO serial and Android Debug Bridge</h1></div></div></div><p>Now<a id="id106" class="indexterm"/> that the UDOO is booting into Android, we want to make<a id="id107" class="indexterm"/> sure we can access it using the serial port as well as the <strong>Android Debug Bridge</strong> (<strong>adb</strong>). You'll need the UDOO serial drivers appropriate for your system. The details of this for Mac, Linux, and Windows can be found at</p><p>
<a class="ulink" href="http://www.udoo.org/ProjectsAndTutorials/connecting-via-serial-cable/">http://www.udoo.org/ProjectsAndTutorials/connecting-via-serial-cable/</a>.</p><p>The serial port is the first form of communication that will come from the system, and it is initialized by the <code class="literal">bootloader</code>. It is a critical link for debugging any kernel or system issues that you encounter later on. It's also required in order to configure the USB port to allow <code class="literal">adb</code> connections across CN3 (the USB OTG port on the UDOO). To configure the port, we need to configure and use minicom to connect a shell to the device. Start by plugging a micro USB cable from CN6 (the micro USB port closest to the power button) to the host machine. Next, let's find the serial connection by looking through <code class="literal">dmesg</code> for the connection message of a TTY over USB.</p><div><pre class="programlisting">
<strong>$ sudo dmesg | tail -n 5</strong>
<strong>[ 9019.090058] usb 4-1: Manufacturer: Silicon Labs</strong>
<strong>[ 9019.090061] usb 4-1: SerialNumber: 0078AEDB</strong>
<strong>[ 9019.096089] cp210x 4-1:1.0: cp210x converter detected</strong>
<strong>[ 9019.208023] usb 4-1: reset full-speed USB device number 4 using uhci_hcd</strong>
<strong>[ 9019.359172] usb 4-1: cp210x converter now attached to ttyUSB0</strong>
</pre></div><p>Our<a id="id108" class="indexterm"/> TTY terminal is on the last line. Let's connect through <a id="id109" class="indexterm"/>it with <code class="literal">minicom</code>:</p><div><pre class="programlisting">
<strong>$ sudo minicom -sw</strong>
</pre></div><p>Select <strong>Serial Port Setup</strong>, type <code class="literal">a</code>, change <strong>Serial Device</strong> to <code class="literal">/dev/ttyUSB0</code>, and type <code class="literal">f</code> to toggle the hardware flow control off:</p><div><img src="img/0594OS_04_02.jpg" alt="UDOO serial and Android Debug Bridge"/></div><p>To<a id="id110" class="indexterm"/> exit, hit <em>Enter</em>, select <strong>Save Setup and DFL</strong>, then select <strong>Exit from Minicom</strong>, and press <em>Enter</em>. Now run <code class="literal">minicom</code> to connect to your UDOO, and watch it boot:</p><div><pre class="programlisting">
<strong>$ sudo minicom -w</strong>
</pre></div><p>If the device is booted and running, you'll get a friendly root shell:</p><div><img src="img/0594OS_04_03.jpg" alt="UDOO serial and Android Debug Bridge"/></div><p>If it's <a id="id111" class="indexterm"/>booting, you'll see <a id="id112" class="indexterm"/>the logs. Just wait for the root shell prompt:</p><div><img src="img/0594OS_04_04.jpg" alt="UDOO serial and Android Debug Bridge"/></div><p>Now<a id="id113" class="indexterm"/> we need to flip some GPIO pins to move the CN3 micro<a id="id114" class="indexterm"/> USB into debug mode:</p><div><pre class="programlisting">
<strong>root@udoo:/ # echo 0 &gt; /sys/class/gpio/gpio203/value </strong>
<strong>root@udoo:/ # echo 0 &gt; /sys/class/gpio/gpio128/value </strong>
</pre></div><p>Then, reset the SAM3X8E processor that was using that bus, by removing and replacing the J16 jumper. Now plug in a micro USB cable from the host to CN3. You should now see a USB device as well as <code class="literal">adb</code>:</p><div><pre class="programlisting">
<strong>$ lsusb</strong>
<strong>Bus 001 Device 009: ID 18d1:4e42 Google Inc.</strong>
<strong>$ adb devices</strong>
<strong>List of devices attached </strong>
<strong>0123456789ABCDEF  offline</strong>
</pre></div><p>You need to select <strong>Allow USB debugging</strong> when the prompt appears on the UDOO Android side. When you do this, the device should go from offline to online; this way you can use <code class="literal">adb</code>.</p><p>Now test the connection and grab the screenshot over <code class="literal">adb</code>:</p><div><pre class="programlisting">
<strong>$ adb shell</strong>
<strong>root@udoo:/ # </strong>
<strong>$ adb shell screencap -p | perl -pe 's/\x0D\x0A/\x0A/g' &gt; screen.png</strong>
</pre></div><p>This<a id="id115" class="indexterm"/> is the screenshot:</p><div><img src="img/0594OS_04_05.jpg" alt="UDOO serial and Android Debug Bridge"/></div><p>At this <a id="id116" class="indexterm"/>point, we have a working development system. We have early boot logs and a rescue shell through the serial console. We also have an <code class="literal">adb</code> bridge with which we can use the standard Android debugging tools! There's nothing left to do but get this system secured with SELinux!</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Flipping the switch</h1></div></div></div><p>Now that <a id="id117" class="indexterm"/>we are enabling SELinux on the UDOO, we need to verify it isn't turned on. The way to do this is to check the known <code class="literal">filesystem</code> types in the <code class="literal">/proc</code> filesystem. SELinux has its own psuedo-filesystem, so if it's enabled, we should see it in the list:</p><div><pre class="programlisting">
<strong>$ adb shell cat /proc/filesystems</strong>
<strong>nodev  sysfs</strong>
<strong>nodev  rootfs</strong>
<strong>nodev  bdev</strong>
<strong>nodev  proc</strong>
<strong>nodev  cgroup</strong>
<strong>nodev  cpuset</strong>
<strong>nodev  tmpfs</strong>
<strong>nodev  debugfs</strong>
<strong>nodev  sockfs</strong>
<strong>nodev  pipefs</strong>
<strong>nodev  anon_inodefs</strong>
<strong>nodev  rpc_pipefs</strong>
<strong>nodev  devpts</strong>
<strong>  ext3</strong>
<strong>  ext2</strong>
<strong>  ext4</strong>
<strong>  cramfs</strong>
<strong>nodev  ramfs</strong>
<strong>  vfat</strong>
<strong>  msdos</strong>
<strong>nodev  nfs</strong>
<strong>nodev  jffs2</strong>
<strong>nodev  fuse</strong>
<strong>  fuseblk</strong>
<strong>nodev  fusectl</strong>
<strong>nodev  mtd_inodefs</strong>
<strong>nodev  ubifs</strong>
</pre></div><p>There <a id="id118" class="indexterm"/>is no evidence of SELinux here, so let's find the kernel configuration and turn it on. Execute this command from the <code class="literal">~/udoo/kernel_imx</code> directory, and eventually you will be greeted with a graphical editing screen:</p><div><pre class="programlisting">
<strong>$ make menuconfig</strong>
</pre></div><p>First, you will need to enable <strong>Auditing support</strong>, as this is a dependency of SELinux. Under <strong>General setup</strong> | <strong>Auditing Support</strong>, enable <strong>Audit Support</strong> and <strong>Enable system-call auditing</strong>. Use the up and down arrow keys to highlight an entry, and press the spacebar to enable it. When an item is enabled, you will see an asterisk (<strong>*</strong>) next to it:</p><div><img src="img/0594OS_04_06.jpg" alt="Flipping the switch"/></div><p>Go back <a id="id119" class="indexterm"/>to the main menu by selecting <strong>Exit</strong>... it's not very intuitive. Enter the <strong>File systems</strong> menu, and for each of the three filesystems, <strong>Ext2</strong>, <strong>Ext3</strong>, and <strong>Ext4</strong>, ensure that <strong>Extended attributes</strong> and <strong>Security Labels</strong> are enabled. Then, go back to the main menu by selecting <strong>Exit</strong>:</p><div><img src="img/0594OS_04_07.jpg" alt="Flipping the switch"/></div><p>From that screen, exit back to the main menu and go to <strong>Security Options</strong>. Once in the <strong>Security Options</strong> submenu, enable the <strong>Enable different security models</strong> and <strong>Socket and Networking Security Hooks</strong> options:</p><div><img src="img/0594OS_04_08.jpg" alt="Flipping the switch"/></div><p>Once <a id="id120" class="indexterm"/>these are enabled, more options will appear. Enable <strong>NSA SELinux Support</strong> and ensure the other selections and values from the following screenshot are duplicated:</p><div><img src="img/0594OS_04_09.jpg" alt="Flipping the switch"/></div><p>Finally, set <strong>Default security module</strong> to SELinux:</p><div><img src="img/0594OS_04_10.jpg" alt="Flipping the switch"/></div><p>Once you select <strong>Default security module</strong>, a new window will appear from which you can select <strong>SELinux</strong>. Exit the configuration menus by selecting <strong>Exit</strong> until you are asked to save your new configuration:</p><div><img src="img/0594OS_04_11.jpg" alt="Flipping the switch"/></div><p>Save the <a id="id121" class="indexterm"/>new configuration and write these changes to the originating kernel configuration file. Otherwise, it will be overwritten on subsequent builds. To do this, we'll need to discover which configuration file was used in the default build, which we built earlier before we made our own configuration with <code class="literal">make menuconfig</code>:</p><div><pre class="programlisting">
<strong>$ grep defconfig logz make -C kernel_imx imx6_udoo_android_defconfig ARCH=arm CROSS_COMPILE=`pwd`/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-</strong>
</pre></div><p>You can see that <code class="literal">imx6_udoo_android_defconfig</code> was used as the default configuration. Copy your custom configuration and build again:</p><div><pre class="programlisting">
<strong>$ cp .config arch/arm/configs/imx6_udoo_android_defconfig</strong>
<strong>$ croot</strong>
<strong>$ make –j4 bootimage 2&gt;&amp;1 | tee logz</strong>
</pre></div><p>A quick sanity check of the log file is always a good idea to verify SELinux was actually built into the kernel:</p><div><pre class="programlisting">
<strong>$ grep -i selinux logz </strong>
<strong>HOSTCC scripts/selinux/mdp/mdp</strong>
<strong>HOSTCC scripts/selinux/genheaders/genheaders</strong>
<strong>GEN security/selinux/flask.h security/selinux/av_permissions.h</strong>
<strong>CC security/selinux/avc.o</strong>
<strong>...</strong>
</pre></div><p>Now, with a built kernel supporting SELinux, insert the SD card into the host and run the following commands:</p><div><pre class="programlisting">
<strong>$ sudo -E ./make_sd.sh /dev/sdd</strong>
<strong>$ sudo sync</strong>
</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Don't forget to umount any automounted partitions from the SD card as we did before.</p></div></div><p>Plug <a id="id122" class="indexterm"/>the SD card into the UDOO, and fire it up. You should see logs over the serial console as we did before:</p><div><img src="img/0594OS_04_12.jpg" alt="Flipping the switch"/></div><p>Eventually, the serial connection should take us to a root shell.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>It's alive</h1></div></div></div><p>How <a id="id123" class="indexterm"/>do we know that we have successfully enabled SELinux<a id="id124" class="indexterm"/> in the kernel? Earlier in this chapter, you ran the command, <code class="literal">adb shell cat /proc/filesystems</code>. We're going to do the same thing and look for a new filesystem called <code class="literal">selinuxfs</code>. If that is present, it indicates we have enabled SELinux successfully. Run the following command in the serial terminal:</p><div><pre class="programlisting">
<strong># cat /proc/filesystems | grep selinux </strong>
<strong>nodev selinuxfs</strong>
</pre></div><p>We can see that <code class="literal">selinuxfs</code> is present! Another common practice is to check <code class="literal">dmesg</code> for any SELinux output. To do this, execute the following command via the serial terminal:</p><div><pre class="programlisting">
<strong># dmesg | grep -i selinux</strong>
<strong>&lt;6&gt;SELinux: Initializing.</strong>
<strong>&lt;7&gt;SELinux: Starting in permissive mode</strong>
<strong>&lt;7&gt;SELinux: Registering netfilter hooks</strong>
<strong>&lt;3&gt;SELinux: policydb version 26 does not match my version range 15-23</strong>
<strong>&lt;4&gt;SELinux: Could not load policy: Invalid argument</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Summary</h1></div></div></div><p>This was a very exciting chapter. You learned how to enable SELinux in the kernel configuration, boot the "secured" system, and how to verify its presence. We also learned how to flash and build images for the UDOO in general and how to connect to it via serial and <code class="literal">adb</code> connections. In the next chapters, we will focus on how to make the UDOO usable with SE for Android capabilities.</p></div></body></html>