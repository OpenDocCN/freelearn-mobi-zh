<html><head></head><body>
<div id="_idContainer082" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor084" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-76" class="calibre6"><a id="_idTextAnchor085" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Network Calls with Kotlin Coroutines</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.3.1">Most of the apps we use on our phones fetch data that is hosted online on a server. </span><span class="kobospan" id="kobo.3.2">As such, we developers have to understand how to request and send data to the servers too. </span><span class="kobospan" id="kobo.3.3">In this chapter, we will learn how to send and request data that is hosted online and display it in </span><span><span class="kobospan" id="kobo.4.1">our apps.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.5.1">In this chapter, we will learn how to perform network calls with a networking library, </span><strong class="bold"><span class="kobospan" id="kobo.6.1">Retrofit</span></strong><span class="kobospan" id="kobo.7.1">. </span><span class="kobospan" id="kobo.7.2">We will learn how to consume </span><strong class="bold"><span class="kobospan" id="kobo.8.1">application programming interfaces</span></strong><span class="kobospan" id="kobo.9.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.10.1">APIs</span></strong><span class="kobospan" id="kobo.11.1">) using this library. </span><span class="kobospan" id="kobo.11.2">Moreso, we will learn how to take advantage of </span><strong class="bold"><span class="kobospan" id="kobo.12.1">Kotlin coroutines</span></strong><span class="kobospan" id="kobo.13.1"> to perform asynchronous network requests in </span><span><span class="kobospan" id="kobo.14.1">our app.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.15.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.16.1">main topics:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.17.1">Setting </span><span><span class="kobospan" id="kobo.18.1">up Retrofit</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.19.1">Introduction to </span><span><span class="kobospan" id="kobo.20.1">Kotlin coroutines</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.21.1">Using Kotlin coroutines for </span><span><span class="kobospan" id="kobo.22.1">network calls</span></span></li>
</ul>
<h1 id="_idParaDest-77" class="calibre6"><a id="_idTextAnchor086" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.23.1">Technical requirements</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.24.1">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (</span><a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.25.1">https://developer.android.com/studio</span></span></a><span><span class="kobospan" id="kobo.26.1">) downloaded.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.27.1">You can find the code for this chapter </span><span><span class="kobospan" id="kobo.28.1">at </span></span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix" class="calibre3 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.29.1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix</span></span></a><span><span class="kobospan" id="kobo.30.1">.</span></span></p>
<h1 id="_idParaDest-78" class="calibre6"><a id="_idTextAnchor087" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.31.1">Setting up Retrofit</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.32.1">Retrofit is a type-safe REST client for Android, Java, and Kotlin developed by Square. </span><span class="kobospan" id="kobo.32.2">The library provides a </span><a id="_idIndexMarker274" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.33.1">powerful framework for authenticating and interacting with APIs and sending network requests with OkHttp. </span><span class="kobospan" id="kobo.33.2">In this book, we will be using Retrofit to perform our </span><span><span class="kobospan" id="kobo.34.1">network requests.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.35.1">To begin with, we will add the Retrofit dependencies using our newly created version catalog. </span><span class="kobospan" id="kobo.35.2">Let’s define the versions in the </span><strong class="source-inline"><span class="kobospan" id="kobo.36.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.37.1"> file </span><span><span class="kobospan" id="kobo.38.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.39.1">
retrofit = "2.9.0"
retrofitSerializationConverter = "1.0.0"
serializationJson = "1.5.1"
coroutines = "1.7.3"
okhttp3 = "4.11.0"</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.40.1">Next, let’s define the </span><a id="_idIndexMarker275" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.41.1">libraries in the </span><strong class="source-inline"><span class="kobospan" id="kobo.42.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.43.1"> file in the libraries section of our versions catalog </span><span><span class="kobospan" id="kobo.44.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.45.1">
retrofit = { module = "com.squareup.retrofit2:retrofit" , version.ref = "retrofit" }
retrofit-serialization = { module = "com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter", version.ref = "retrofitSerializationConverter" }
coroutines = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core" , version.ref = "coroutines" }
coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android" , version.ref = "coroutines" }
serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "serializationJson" }
okhttp3 = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp3" }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.46.1">We are adding these dependencies to </span><span><span class="kobospan" id="kobo.47.1">our project:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.48.1">Retrofit</span></strong><span class="kobospan" id="kobo.49.1">: As mentioned earlier, we will use Retrofit to perform our </span><span><span class="kobospan" id="kobo.50.1">network requests.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.51.1">Retrofit serialization</span></strong><span class="kobospan" id="kobo.52.1">: This is a converter</span><a id="_idIndexMarker276" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.53.1"> that uses </span><strong class="bold"><span class="kobospan" id="kobo.54.1">Kotlinx serialization</span></strong><span class="kobospan" id="kobo.55.1"> to convert Kotlin objects to and </span><span><span class="kobospan" id="kobo.56.1">from JSON.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.57.1">Coroutines</span></strong><span class="kobospan" id="kobo.58.1">: We will use Kotlin coroutines to perform our network requests asynchronously. </span><span class="kobospan" id="kobo.58.2">We will be learning more about </span><span><span class="kobospan" id="kobo.59.1">coroutines shortly.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.60.1">Kotlinx serialization JSON</span></strong><span class="kobospan" id="kobo.61.1">: This is a Kotlin serialization library for JSON. </span><span class="kobospan" id="kobo.61.2">We will use this to parse our JSON responses. </span><span class="kobospan" id="kobo.61.3">We have other serialization libraries, such as Moshi and Gson, but we </span><a id="_idIndexMarker277" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.62.1">used the Kotlinx serialization library for the </span><span><span class="kobospan" id="kobo.63.1">following reasons:</span></span><ul class="calibre17"><li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.64.1">Kotlin-centric development</span></strong><span class="kobospan" id="kobo.65.1">: Kotlinx serialization is designed with Kotlin in mind, providing seamless integration and native support for </span><span><span class="kobospan" id="kobo.66.1">Kotlin serialization.</span></span></li><li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.67.1">Declarative syntax</span></strong><span class="kobospan" id="kobo.68.1">: Kotlinx serialization uses a declarative syntax, leveraging Kotlin’s language features for concise and readable </span><span><span class="kobospan" id="kobo.69.1">serialization code.</span></span></li><li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.70.1">Compile-time safety</span></strong><span class="kobospan" id="kobo.71.1">: Compile-time safety is a key feature, catching serialization-related errors during the compilation phase and reducing the likelihood of </span><span><span class="kobospan" id="kobo.72.1">runtime errors.</span></span></li><li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.73.1">Custom serialization strategies</span></strong><span class="kobospan" id="kobo.74.1">: We have the flexibility to define custom serialization strategies for specific types or scenarios, offering fine-grained control over the </span><span><span class="kobospan" id="kobo.75.1">serialization process.</span></span></li><li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.76.1">Seamless integration with Kotlin ecosystem</span></strong><span class="kobospan" id="kobo.77.1">: Being part of the Kotlin ecosystem, Kotlinx serialization integrates seamlessly with other Kotlin libraries and frameworks, contributing to a cohesive </span><span><span class="kobospan" id="kobo.78.1">development experience.</span></span></li></ul></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.79.1">OkHttp</span></strong><span class="kobospan" id="kobo.80.1">: This is an HTTP client that is used to make network requests. </span><span class="kobospan" id="kobo.80.2">It provides some utilities for working </span><span><span class="kobospan" id="kobo.81.1">with Retrofit.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.82.1">All these dependencies will be added together, so this is a chance for us to group them in our </span><strong class="bold"><span class="kobospan" id="kobo.83.1">bundles</span></strong><span class="kobospan" id="kobo.84.1"> section. </span><span class="kobospan" id="kobo.84.2">In our </span><strong class="source-inline"><span class="kobospan" id="kobo.85.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.86.1"> file, add this bundle below our </span><span><span class="kobospan" id="kobo.87.1">Koin bundle:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.88.1">
networking = ["retrofit", "retrofit-serialization", "serialization-json", "coroutines", "coroutines-android"]</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.89.1">Here, we create a new bundle called </span><strong class="source-inline"><span class="kobospan" id="kobo.90.1">networking</span></strong><span class="kobospan" id="kobo.91.1"> and add all the dependencies that we specified earlier on. </span><span class="kobospan" id="kobo.91.2">We have to sync the project for our changes to be added to the project. </span><span class="kobospan" id="kobo.91.3">Tap on </span><strong class="bold"><span class="kobospan" id="kobo.92.1">Sync Now</span></strong><span class="kobospan" id="kobo.93.1"> in the notification that appears at the top when you edit the </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.95.1"> file. </span><span class="kobospan" id="kobo.95.2">After</span><a id="_idIndexMarker278" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.96.1"> syncing, let us start setting up the plugins </span><span><span class="kobospan" id="kobo.97.1">and dependencies.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.98.1"> First, in our project-level </span><strong class="source-inline"><span class="kobospan" id="kobo.99.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.100.1"> file, we need to add the Kotlinx serialization plugin. </span><span class="kobospan" id="kobo.100.2">Open the project-level </span><strong class="source-inline"><span class="kobospan" id="kobo.101.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.102.1"> file and on the plugins block add </span><span><span class="kobospan" id="kobo.103.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.104.1">
id("org.jetbrains.kotlin.plugin.serialization") version "1.8.20" apply false</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.105.1">We define the Kotlinx serialization plugin and specify the version to use. </span><span class="kobospan" id="kobo.105.2">This will set up the Kotlinx serialization plugin for us. </span><span class="kobospan" id="kobo.105.3">The plugin generates Kotlin code for serializable classes. </span><span class="kobospan" id="kobo.105.4">We will use this plugin to generate our models. </span><span class="kobospan" id="kobo.105.5">Next, let us set up the plugin in our app module. </span><span class="kobospan" id="kobo.105.6">Open the app-level </span><strong class="source-inline"><span class="kobospan" id="kobo.106.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.107.1"> file and add the following in the </span><span><span class="kobospan" id="kobo.108.1">plugins block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.109.1">
id("kotlinx-serialization")</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.110.1">This ensures our module is set up to use the Kotlinx serialization plugin. </span><span class="kobospan" id="kobo.110.2">Next, we will add our </span><strong class="source-inline"><span class="kobospan" id="kobo.111.1">networking</span></strong><span class="kobospan" id="kobo.112.1"> bundle to our app module. </span><span class="kobospan" id="kobo.112.2">In the app-level </span><strong class="source-inline"><span class="kobospan" id="kobo.113.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.114.1"> file, add </span><span><span class="kobospan" id="kobo.115.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.116.1">
implementation(libs.bundles.networking)</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.117.1">This will add all the dependencies that we have specified in our </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">networking</span></strong><span class="kobospan" id="kobo.119.1"> bundle. </span><span class="kobospan" id="kobo.119.2">Having done all these, our project is set up to use Retrofit. </span><span class="kobospan" id="kobo.119.3">We will be using Koin to create a Retrofit instance</span><a id="_idIndexMarker279" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.120.1"> that will be injected into classes that need it. </span><span class="kobospan" id="kobo.120.2">Let us head over to the </span><strong class="source-inline"><span class="kobospan" id="kobo.121.1">Module.kt</span></strong><span class="kobospan" id="kobo.122.1"> file and add the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.123.1">PetsViewModel</span></strong></span><span><span class="kobospan" id="kobo.124.1"> definition:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.125.1">
single {
    Retrofit.Builder()
        .addConverterFactory(
            Json.asConverterFactory(contentType = "application/json".toMediaType())
        )
        .baseUrl("https://cataas.com/api/")
        .build()
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.126.1">In the preceding code, we created a Retrofit instance using the Retrofit builder. </span><span class="kobospan" id="kobo.126.2">We also added a converter factory that uses Kotlinx serialization to convert Kotlin objects to and from JSON. </span><span class="kobospan" id="kobo.126.3">We also specified the base URL for our API. </span><span class="kobospan" id="kobo.126.4">We are using the </span><strong class="bold"><span class="kobospan" id="kobo.127.1">Cat as a Service API</span></strong><span class="kobospan" id="kobo.128.1"> (</span><a href="https://cataas.com/" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.129.1">https://cataas.com/</span></a><span class="kobospan" id="kobo.130.1">), which </span><a id="_idIndexMarker280" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.131.1">returns cat images. </span><span class="kobospan" id="kobo.131.2">We will use this instance to create our API class, which is a class with methods that will be used to make network requests. </span><span class="kobospan" id="kobo.131.3">Let us create this class. </span><span class="kobospan" id="kobo.131.4">Create a new Kotlin interface inside the data package called </span><strong class="source-inline"><span class="kobospan" id="kobo.132.1">CatsAPI.kt</span></strong><span class="kobospan" id="kobo.133.1"> and add the </span><span><span class="kobospan" id="kobo.134.1">following method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.135.1">
@GET("cats")
suspend fun fetchCats(
    @Query("tag") tag: String,
): Response&lt;List&lt;Cat&gt;&gt;</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.136.1">In the preceding code, we use the </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">@GET</span></strong><span class="kobospan" id="kobo.138.1"> annotation to specify that we will be using the </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">GET</span></strong><span class="kobospan" id="kobo.140.1"> HTTP method for this request. </span><span class="kobospan" id="kobo.140.2">Inside the method, we are also specifying a path that will be appended to our</span><a id="_idIndexMarker281" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.141.1"> base URL to make the full URL for our request. </span><span class="kobospan" id="kobo.141.2">Using the </span><strong class="source-inline"><span class="kobospan" id="kobo.142.1">GET</span></strong><span class="kobospan" id="kobo.143.1"> method means our method will only request data. </span><span class="kobospan" id="kobo.143.2">We have the following built-in </span><span><span class="kobospan" id="kobo.144.1">HTTP annotations:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.145.1">POST</span></strong><span class="kobospan" id="kobo.146.1">: This is used when we want to send data to </span><span><span class="kobospan" id="kobo.147.1">the server</span></span></li>
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.148.1">PUT</span></strong><span class="kobospan" id="kobo.149.1">: This is used when we want to update data on </span><span><span class="kobospan" id="kobo.150.1">the server</span></span></li>
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.151.1">DELETE</span></strong><span class="kobospan" id="kobo.152.1">: This is used when we want to delete data from </span><span><span class="kobospan" id="kobo.153.1">the server</span></span></li>
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.154.1">HEAD</span></strong><span class="kobospan" id="kobo.155.1">: This method asks for a response identical to the one that would correspond to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.156.1">GET</span></strong><span class="kobospan" id="kobo.157.1"> request but without the </span><span><span class="kobospan" id="kobo.158.1">response body</span></span></li>
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.159.1">PATCH</span></strong><span class="kobospan" id="kobo.160.1">: This is used when we want to update data partially on </span><span><span class="kobospan" id="kobo.161.1">the server</span></span></li>
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.162.1">OPTIONS</span></strong><span class="kobospan" id="kobo.163.1">: This method requests permitted communication options for the </span><span><span class="kobospan" id="kobo.164.1">target resource</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.165.1">Back to our </span><strong class="source-inline"><span class="kobospan" id="kobo.166.1">fetchCats()</span></strong><span class="kobospan" id="kobo.167.1"> function, you can notice that we use the </span><strong class="source-inline"><span class="kobospan" id="kobo.168.1">@Query</span></strong><span class="kobospan" id="kobo.169.1"> annotation to specify the query parameter for our request. </span><span class="kobospan" id="kobo.169.2">We use the </span><strong class="source-inline"><span class="kobospan" id="kobo.170.1">tag</span></strong><span class="kobospan" id="kobo.171.1"> query parameter to specify the type of cat we want to fetch. </span><span class="kobospan" id="kobo.171.2">We also use the </span><strong class="source-inline"><span class="kobospan" id="kobo.172.1">suspend</span></strong><span class="kobospan" id="kobo.173.1"> keyword to specify that this method will be called from a coroutine or another </span><strong class="source-inline"><span class="kobospan" id="kobo.174.1">suspend</span></strong><span class="kobospan" id="kobo.175.1"> function. </span><span class="kobospan" id="kobo.175.2">We will learn more about coroutines shortly in the </span><em class="italic"><span class="kobospan" id="kobo.176.1">Introduction to Kotlin coroutines</span></em><span class="kobospan" id="kobo.177.1"> section of this chapter. </span><span class="kobospan" id="kobo.177.2">We also use the </span><strong class="source-inline"><span class="kobospan" id="kobo.178.1">Response</span></strong><span class="kobospan" id="kobo.179.1"> class to wrap up our response. </span><span class="kobospan" id="kobo.179.2">This class is provided by Retrofit and it contains the HTTP response metadata such as response code, headers, and the raw response body. </span><span class="kobospan" id="kobo.179.3">We also specify that the response will be a list of </span><strong class="source-inline"><span class="kobospan" id="kobo.180.1">Cat</span></strong><span class="kobospan" id="kobo.181.1"> objects. </span><span class="kobospan" id="kobo.181.2">Retrofit will map the response to a list of </span><strong class="source-inline"><span class="kobospan" id="kobo.182.1">Cat</span></strong><span class="kobospan" id="kobo.183.1"> objects. </span><span class="kobospan" id="kobo.183.2">To resolve the error for the </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">Cat</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.185.1">data class</span></strong><span class="kobospan" id="kobo.186.1">, let us create it. </span><span class="kobospan" id="kobo.186.2">Create a new Kotlin data class inside the data package called </span><strong class="source-inline"><span class="kobospan" id="kobo.187.1">Cat.kt</span></strong><span class="kobospan" id="kobo.188.1"> and add </span><span><span class="kobospan" id="kobo.189.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.190.1">
@Serializable
data class Cat(
    @SerialName ("createdAt")
    val createdAt: String,
    @SerialName("_id")
    val id: String,
    @SerialName("owner")
    val owner: String,
    @SerialName("tags")
    val tags: List&lt;String&gt;,
    @SerialName("updatedAt")
    val updatedAt: String
)</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.191.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">Cat</span></strong><span class="kobospan" id="kobo.193.1"> data class has the fields that correspond to the JSON response from the Cat as a Service API. </span><span class="kobospan" id="kobo.193.2">It is also annotated with the </span><strong class="source-inline"><span class="kobospan" id="kobo.194.1">@Serializable</span></strong><span class="kobospan" id="kobo.195.1"> annotation. </span><span class="kobospan" id="kobo.195.2">This annotation is provided by Kotlinx Serialization and it is used to mark a class as serializable. </span><span class="kobospan" id="kobo.195.3">This annotation is required for all the classes that we want to serialize or deserialize. </span><span class="kobospan" id="kobo.195.4">We have used</span><a id="_idIndexMarker282" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.196.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.197.1">@SerialName</span></strong><span class="kobospan" id="kobo.198.1"> annotation before each variable in our data class. </span><span class="kobospan" id="kobo.198.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">@SerialName</span></strong><span class="kobospan" id="kobo.200.1"> is an annotation used to customize the mapping between Kotlin property names and the corresponding names used in the serialized form, such as JSON or other data interchange formats. </span><span class="kobospan" id="kobo.200.2">This annotation allows you to specify a different name for a property when it is serialized or deserialized, providing flexibility in handling </span><span><span class="kobospan" id="kobo.201.1">naming conventions.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.202.1">In our project, we are using Koin for dependency injection. </span><span class="kobospan" id="kobo.202.2">So, we now need to create an instance of our </span><strong class="source-inline"><span class="kobospan" id="kobo.203.1">CatsAPI</span></strong><span class="kobospan" id="kobo.204.1"> class in our Koin modules. </span><span class="kobospan" id="kobo.204.2">Let us head back to the </span><strong class="source-inline"><span class="kobospan" id="kobo.205.1">Module.kt</span></strong><span class="kobospan" id="kobo.206.1"> file and below the Retrofit instance add </span><span><span class="kobospan" id="kobo.207.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.208.1">
single { get&lt;Retrofit&gt;().create(CatsAPI::class.java) }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.209.1">Here, we get our Retrofit instance and use it to create an instance of our </span><strong class="source-inline"><span class="kobospan" id="kobo.210.1">CatsAPI</span></strong><span class="kobospan" id="kobo.211.1"> class, which we use to make the actual network requests. </span><span class="kobospan" id="kobo.211.2">With that, our project is ready to make the network</span><a id="_idIndexMarker283" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.212.1"> requests. </span><span class="kobospan" id="kobo.212.2">But before that, let us learn more about Kotlin coroutines as we are going to modify our repository to </span><span><span class="kobospan" id="kobo.213.1">use coroutines.</span></span></p>
<h1 id="_idParaDest-79" class="calibre6"><a id="_idTextAnchor088" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.214.1">Introduction to Kotlin coroutines</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.215.1">Coroutines, introduced by JetBrains </span><a id="_idIndexMarker284" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.216.1">for Kotlin, provide a way to write asynchronous code in a more readable and synchronous manner. </span><span class="kobospan" id="kobo.216.2">We can use them to perform background tasks and they are a great way to perform network requests and long-running tasks such as reading and writing to a database. </span><span class="kobospan" id="kobo.216.3">They do these tasks off the main thread and ensure that we don’t block our main thread while performing these operations. </span><span class="kobospan" id="kobo.216.4">The main benefits of using coroutines are </span><span><span class="kobospan" id="kobo.217.1">as follows:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.218.1">They are lightweight and easy </span><span><span class="kobospan" id="kobo.219.1">to use.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.220.1">They have built-in </span><span><span class="kobospan" id="kobo.221.1">cancellation support.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.222.1">They lower the chances of apps having </span><span><span class="kobospan" id="kobo.223.1">memory leaks.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.224.1">As mentioned in earlier chapters, Jetpack libraries also support and </span><span><span class="kobospan" id="kobo.225.1">use coroutines.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.226.1">We have already added the core and Android coroutines libraries in our app. </span><span class="kobospan" id="kobo.226.2">Let us understand some coroutines basics before proceeding to use coroutines in </span><span><span class="kobospan" id="kobo.227.1">our project.</span></span></p>
<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor089" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.228.1">Coroutine basics</span></h2>
<p class="calibre4"><span class="kobospan" id="kobo.229.1">In this section, we will be</span><a id="_idIndexMarker285" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.230.1"> looking at different terms and concepts used in </span><span><span class="kobospan" id="kobo.231.1">Kotlin coroutines:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.232.1">suspend</span></strong><span class="kobospan" id="kobo.233.1">: This is a keyword that is used to mark a function. </span><span class="kobospan" id="kobo.233.2">A </span><strong class="source-inline1"><span class="kobospan" id="kobo.234.1">suspend</span></strong><span class="kobospan" id="kobo.235.1"> function is a function that can be paused and resumed at a later time. </span><span class="kobospan" id="kobo.235.2">We have already used this keyword in our </span><strong class="source-inline1"><span class="kobospan" id="kobo.236.1">CatsAPI</span></strong><span class="kobospan" id="kobo.237.1"> class to mark the </span><strong class="source-inline1"><span class="kobospan" id="kobo.238.1">fetchCats()</span></strong><span class="kobospan" id="kobo.239.1"> function as a </span><strong class="source-inline1"><span class="kobospan" id="kobo.240.1">suspend</span></strong><span class="kobospan" id="kobo.241.1"> function. </span><span class="kobospan" id="kobo.241.2">A </span><strong class="source-inline1"><span class="kobospan" id="kobo.242.1">suspend</span></strong><span class="kobospan" id="kobo.243.1"> function can only be called from another </span><strong class="source-inline1"><span class="kobospan" id="kobo.244.1">suspend</span></strong><span class="kobospan" id="kobo.245.1"> function or from </span><span><span class="kobospan" id="kobo.246.1">a coroutine.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.247.1">Coroutine builders</span></strong><span class="kobospan" id="kobo.248.1">: These are functions that are used to create coroutines. </span><span class="kobospan" id="kobo.248.2">We have the </span><strong class="source-inline1"><span class="kobospan" id="kobo.249.1">launch</span></strong><span class="kobospan" id="kobo.250.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.251.1">async</span></strong><span class="kobospan" id="kobo.252.1"> coroutine builders. </span><strong class="source-inline1"><span class="kobospan" id="kobo.253.1">launch</span></strong><span class="kobospan" id="kobo.254.1"> is used to create a coroutine that does not return a result while </span><strong class="source-inline1"><span class="kobospan" id="kobo.255.1">async</span></strong><span class="kobospan" id="kobo.256.1"> is used to create a coroutine that returns a result. </span><span class="kobospan" id="kobo.256.2">The result is a </span><strong class="source-inline1"><span class="kobospan" id="kobo.257.1">Deferred</span></strong><span class="kobospan" id="kobo.258.1"> object and we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.259.1">await()</span></strong><span class="kobospan" id="kobo.260.1"> method to get the result. </span><span class="kobospan" id="kobo.260.2">Both of these builders return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.261.1">Job</span></strong><span class="kobospan" id="kobo.262.1"> object that we can use to check if the coroutine is still active or if it has been canceled. </span><span class="kobospan" id="kobo.262.2">We can also use the job to wait for the coroutine to finish. </span><span class="kobospan" id="kobo.262.3">A job ends when it’s completed </span><span><span class="kobospan" id="kobo.263.1">or canceled.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.264.1">Jobs</span></strong><span class="kobospan" id="kobo.265.1">: A job is a coroutine instance with a </span><strong class="bold"><span class="kobospan" id="kobo.266.1">life cycle</span></strong><span class="kobospan" id="kobo.267.1"> and can be canceled. </span><span class="kobospan" id="kobo.267.2">We can use the job to check if the coroutine is still active or if it has been canceled. </span><span class="kobospan" id="kobo.267.3">We can also use the </span><a id="_idIndexMarker286" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.268.1">job to wait for the coroutine to finish. </span><span class="kobospan" id="kobo.268.2">A job ends when it’s completed or canceled. </span><span class="kobospan" id="kobo.268.3">As mentioned earlier, both the </span><strong class="source-inline1"><span class="kobospan" id="kobo.269.1">launch</span></strong><span class="kobospan" id="kobo.270.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">async</span></strong><span class="kobospan" id="kobo.272.1"> coroutine builders return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">Job</span></strong><span class="kobospan" id="kobo.274.1"> object which we use to manage the coroutine life cycle. </span><span class="kobospan" id="kobo.274.2">We have a normal </span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">Job</span></strong><span class="kobospan" id="kobo.276.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.277.1">SupervisorJob</span></strong><span class="kobospan" id="kobo.278.1">. </span><span class="kobospan" id="kobo.278.2">A normal </span><strong class="source-inline1"><span class="kobospan" id="kobo.279.1">Job</span></strong><span class="kobospan" id="kobo.280.1"> is canceled when any of its children fail. </span><strong class="source-inline1"><span class="kobospan" id="kobo.281.1">SupervisorJob</span></strong><span class="kobospan" id="kobo.282.1"> is not canceled when any of its children fail. </span><span class="kobospan" id="kobo.282.2">It is recommended to use </span><strong class="source-inline1"><span class="kobospan" id="kobo.283.1">SupervisorJob</span></strong><span class="kobospan" id="kobo.284.1"> when we have multiple coroutines </span><span><span class="kobospan" id="kobo.285.1">running concurrently.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.286.1">Coroutine scope</span></strong><span class="kobospan" id="kobo.287.1">: This keeps track of all the coroutines we create using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.288.1">launch</span></strong><span class="kobospan" id="kobo.289.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.290.1">async</span></strong><span class="kobospan" id="kobo.291.1"> builders. </span><span class="kobospan" id="kobo.291.2">It is responsible for knowing how long a coroutine will live. </span><span class="kobospan" id="kobo.291.3">Every coroutine builder is defined as an extension function of scope. </span><span class="kobospan" id="kobo.291.4">Coroutines cannot be launched without a scope. </span><span class="kobospan" id="kobo.291.5">We have </span><strong class="source-inline1"><span class="kobospan" id="kobo.292.1">GlobalScope</span></strong><span class="kobospan" id="kobo.293.1">, which is a scope that is not tied to any life cycle. </span><span class="kobospan" id="kobo.293.2">It is not recommended to use this scope as it can lead to memory leaks. </span><span class="kobospan" id="kobo.293.3">In Android, the KTX libraries provide </span><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">viewModelScope</span></strong><span class="kobospan" id="kobo.295.1">, which is a scope that is tied to </span><strong class="source-inline1"><span class="kobospan" id="kobo.296.1">ViewModel</span></strong><span class="kobospan" id="kobo.297.1">. </span><span class="kobospan" id="kobo.297.2">We can use this scope to launch coroutines that will be canceled when </span><strong class="source-inline1"><span class="kobospan" id="kobo.298.1">ViewModel</span></strong><span class="kobospan" id="kobo.299.1"> is destroyed. </span><span class="kobospan" id="kobo.299.2">We also have </span><strong class="source-inline1"><span class="kobospan" id="kobo.300.1">lifecycleScope</span></strong><span class="kobospan" id="kobo.301.1">, which is a scope that is tied to an activity or fragment life cycle. </span><span class="kobospan" id="kobo.301.2">We can use this scope to launch coroutines that will be canceled when the life cycle is destroyed. </span><span class="kobospan" id="kobo.301.3">We can also create our own custom scopes if we want to launch coroutines that will be canceled when a custom life cycle </span><span><span class="kobospan" id="kobo.302.1">is destroyed.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.303.1">Coroutine context</span></strong><span class="kobospan" id="kobo.304.1">: This is a collection </span><a id="_idIndexMarker287" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.305.1">of many elements. </span><strong class="source-inline1"><span class="kobospan" id="kobo.306.1">CoroutineContext</span></strong><span class="kobospan" id="kobo.307.1"> defines the behavior of our coroutines using elements such as </span><span><span class="kobospan" id="kobo.308.1">the following:</span></span><ul class="calibre17"><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.309.1">Job</span></strong><span class="kobospan" id="kobo.310.1">: This manages the life cycle of </span><span><span class="kobospan" id="kobo.311.1">the coroutine.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.312.1">CoroutineDispatcher</span></strong><span class="kobospan" id="kobo.313.1">: This defines the thread on which the coroutine </span><span><span class="kobospan" id="kobo.314.1">will run.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.315.1">CoroutineName</span></strong><span class="kobospan" id="kobo.316.1">: This defines the name of </span><span><span class="kobospan" id="kobo.317.1">the coroutine.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.318.1">CoroutineExceptionHandler</span></strong><span class="kobospan" id="kobo.319.1">: This handles uncaught exceptions in </span><span><span class="kobospan" id="kobo.320.1">the coroutine.</span></span></li></ul></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.321.1">Dispatchers</span></strong><span class="kobospan" id="kobo.322.1">: These specify which thread the coroutines will run on. </span><span class="kobospan" id="kobo.322.2">We have the </span><span><span class="kobospan" id="kobo.323.1">following dispatchers:</span></span><ul class="calibre17"><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.324.1">Dispatchers.Main</span></strong><span class="kobospan" id="kobo.325.1">: This is the main thread. </span><span class="kobospan" id="kobo.325.2">It is used when we need to interact with the UI in </span><span><span class="kobospan" id="kobo.326.1">our coroutines.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.327.1">Dispatchers.IO</span></strong><span class="kobospan" id="kobo.328.1">: This is a thread pool that is optimized for IO tasks such as reading and writing to a database or making </span><span><span class="kobospan" id="kobo.329.1">network requests.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.330.1">Dispatchers.Default</span></strong><span class="kobospan" id="kobo.331.1">: This is a thread pool that is optimized for </span><span><span class="kobospan" id="kobo.332.1">CPU-intensive tasks.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.333.1">Dispatchers.Unconfined</span></strong><span class="kobospan" id="kobo.334.1">: This is a dispatcher that is not confined to any thread. </span><span class="kobospan" id="kobo.334.2">It is used to create a coroutine that inherits the context of the </span><span><span class="kobospan" id="kobo.335.1">parent coroutine.</span></span></li></ul><p class="calibre4"><span class="kobospan" id="kobo.336.1">Inside coroutines, we can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.337.1">withContext()</span></strong><span class="kobospan" id="kobo.338.1"> function to switch between different dispatchers. </span><strong class="source-inline"><span class="kobospan" id="kobo.339.1">withContext()</span></strong><span class="kobospan" id="kobo.340.1"> is a </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">suspend</span></strong><span class="kobospan" id="kobo.342.1"> function that switches the context of </span><span><span class="kobospan" id="kobo.343.1">the coroutine.</span></span></p></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.344.1">Flows</span></strong><span class="kobospan" id="kobo.345.1">: Suspend functions only return single values. </span><span class="kobospan" id="kobo.345.2">Flows are a type of asynchronous data stream that can return multiple values. </span><span class="kobospan" id="kobo.345.3">We can use flows to return multiple values from a </span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">suspend</span></strong><span class="kobospan" id="kobo.347.1"> function. </span><span class="kobospan" id="kobo.347.2">We can also use flows to perform asynchronous operations. </span><span class="kobospan" id="kobo.347.3">Flows are </span><strong class="bold"><span class="kobospan" id="kobo.348.1">cold streams</span></strong><span class="kobospan" id="kobo.349.1">. </span><span class="kobospan" id="kobo.349.2">This means that they only start emitting values </span><a id="_idIndexMarker288" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.350.1">when they are collected. </span><span class="kobospan" id="kobo.350.2">We can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.351.1">collect()</span></strong><span class="kobospan" id="kobo.352.1"> function to collect values from a flow. </span><span class="kobospan" id="kobo.352.2">We have </span><strong class="source-inline1"><span class="kobospan" id="kobo.353.1">StateFlow</span></strong><span class="kobospan" id="kobo.354.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.355.1">SharedFlow</span></strong><span class="kobospan" id="kobo.356.1">, which are types of flows. </span><strong class="source-inline1"><span class="kobospan" id="kobo.357.1">StateFlow</span></strong><span class="kobospan" id="kobo.358.1"> is a flow that emits the current value to new collectors and emits new values to existing collectors. </span><strong class="source-inline1"><span class="kobospan" id="kobo.359.1">SharedFlow</span></strong><span class="kobospan" id="kobo.360.1"> is a flow that emits new values to all collectors. </span><span class="kobospan" id="kobo.360.2">We will be learning more about flows in the next </span><a id="_idIndexMarker289" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.361.1">chapter. </span><span class="kobospan" id="kobo.361.2">In Android, we will normally use the two types of flows to emit data to our UI. </span><span class="kobospan" id="kobo.361.3">We will see the usage of </span><strong class="source-inline1"><span class="kobospan" id="kobo.362.1">StateFlow</span></strong><span class="kobospan" id="kobo.363.1"> in </span><strong class="source-inline1"><span class="kobospan" id="kobo.364.1">ViewModel</span></strong><span class="kobospan" id="kobo.365.1"> as we refactor it to </span><span><span class="kobospan" id="kobo.366.1">use coroutines.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.367.1">With this understanding of the basics, in the next section, we will be refactoring our repository to </span><span><span class="kobospan" id="kobo.368.1">use coroutines.</span></span></p>
<h1 id="_idParaDest-81" class="calibre6"><a id="_idTextAnchor090" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.369.1">Using Kotlin coroutines for network calls</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.370.1">In this section, we will refactor our repository to use coroutines. </span><span class="kobospan" id="kobo.370.2">We will use </span><strong class="source-inline"><span class="kobospan" id="kobo.371.1">StateFlow</span></strong><span class="kobospan" id="kobo.372.1"> to emit data </span><a id="_idIndexMarker290" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.373.1">from </span><strong class="source-inline"><span class="kobospan" id="kobo.374.1">ViewModel</span></strong><span class="kobospan" id="kobo.375.1"> to the view layer. </span><span class="kobospan" id="kobo.375.2">We will also use the </span><strong class="source-inline"><span class="kobospan" id="kobo.376.1">Dispatchers.IO</span></strong><span class="kobospan" id="kobo.377.1"> dispatcher to perform our network requests on a </span><span><span class="kobospan" id="kobo.378.1">background thread.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.379.1">Let us start by creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.380.1">NetworkResult</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.381.1">sealed class</span></strong><span class="kobospan" id="kobo.382.1">, which will represent the different states of our </span><span><span class="kobospan" id="kobo.383.1">network request:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.384.1">
sealed class NetworkResult&lt;out T&gt; {
    data class Success&lt;out T&gt;(val data: T) : NetworkResult&lt;T&gt;()
    data class Error(val error: String) : NetworkResult&lt;Nothing&gt;()
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.385.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.386.1">NetworkResult</span></strong><span class="kobospan" id="kobo.387.1"> class is a sealed class that has two subclasses. </span><span class="kobospan" id="kobo.387.2">We have the </span><strong class="source-inline"><span class="kobospan" id="kobo.388.1">Success</span></strong><span class="kobospan" id="kobo.389.1"> data class that will be used to represent a successful network request. </span><span class="kobospan" id="kobo.389.2">It has a data property that will be used to hold the data returned from the network request. </span><span class="kobospan" id="kobo.389.3">We also have the </span><strong class="source-inline"><span class="kobospan" id="kobo.390.1">Error</span></strong><span class="kobospan" id="kobo.391.1"> class, which will be used to represent a failed network request. </span><span class="kobospan" id="kobo.391.2">It has an </span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">error</span></strong><span class="kobospan" id="kobo.393.1"> property that will be used to hold the error message returned from the network request. </span><span class="kobospan" id="kobo.393.2">The sealed class encapsulates a generic data type </span><strong class="source-inline"><span class="kobospan" id="kobo.394.1">T</span></strong><span class="kobospan" id="kobo.395.1">, which makes it easier for us to</span><a id="_idIndexMarker291" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.396.1"> reuse the class in all our network calls. </span><span class="kobospan" id="kobo.396.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.397.1">Success</span></strong><span class="kobospan" id="kobo.398.1"> data class also has a generic parameter for the </span><span><span class="kobospan" id="kobo.399.1">same purpose.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.400.1">Next, let us modify </span><strong class="source-inline"><span class="kobospan" id="kobo.401.1">PetsRepository</span></strong> <span><span class="kobospan" id="kobo.402.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.403.1">
interface PetsRepository {
    suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt;
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.404.1">We have updated the interface to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.405.1">NetworkResult</span></strong><span class="kobospan" id="kobo.406.1"> class. </span><span class="kobospan" id="kobo.406.2">We have also marked the </span><strong class="source-inline"><span class="kobospan" id="kobo.407.1">getPets()</span></strong><span class="kobospan" id="kobo.408.1"> function as a </span><strong class="source-inline"><span class="kobospan" id="kobo.409.1">suspend</span></strong><span class="kobospan" id="kobo.410.1"> function. </span><span class="kobospan" id="kobo.410.2">We will use this method to fetch the cats from the API. </span><span class="kobospan" id="kobo.410.3">Next, let us modify </span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">PetsRepositoryImpl</span></strong><span class="kobospan" id="kobo.412.1"> to add the changes </span><span><span class="kobospan" id="kobo.413.1">from </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.414.1">PetsRepository</span></strong></span><span><span class="kobospan" id="kobo.415.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.416.1">
class PetsRepositoryImpl(
    private  val catsAPI: CatsAPI,
    private val dispatcher: CoroutineDispatcher
): PetsRepository {
    override suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt; {
        return withContext(dispatcher) {
            try {
                val response = catsAPI.fetchCats("cute")
                if (response.isSuccessful) {
                    NetworkResult.Success(response.body()!!)
                } else {
                    NetworkResult.Error(response.errorBody().toString())
                }
            } catch (e: Exception) {
                NetworkResult.Error(e.message ?: "Unknown error")
            }
        }
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.417.1">We have changed a number of </span><span><span class="kobospan" id="kobo.418.1">things here:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.419.1">First, we added a constructor that takes in an instance of our </span><strong class="source-inline1"><span class="kobospan" id="kobo.420.1">CatsAPI</span></strong><span class="kobospan" id="kobo.421.1"> class, which we will use to </span><a id="_idIndexMarker292" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.422.1">make our network requests. </span><span class="kobospan" id="kobo.422.2">It also has a </span><strong class="source-inline1"><span class="kobospan" id="kobo.423.1">dispatcher</span></strong><span class="kobospan" id="kobo.424.1"> parameter, which will be used to specify the dispatcher that we will use to perform our network requests. </span><span class="kobospan" id="kobo.424.2">We will use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.425.1">Dispatchers.IO</span></strong><span class="kobospan" id="kobo.426.1"> dispatcher to perform our network requests on a </span><span><span class="kobospan" id="kobo.427.1">background thread.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.428.1">We have also changed the return type of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.429.1">getPets()</span></strong><span class="kobospan" id="kobo.430.1"> function to </span><strong class="source-inline1"><span class="kobospan" id="kobo.431.1">NetworkResult&lt;List&lt;Cat&gt;&gt;</span></strong><span class="kobospan" id="kobo.432.1">. </span><span class="kobospan" id="kobo.432.2">This is because we will return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.433.1">NetworkResult</span></strong><span class="kobospan" id="kobo.434.1"> object from </span><span><span class="kobospan" id="kobo.435.1">this method.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.436.1">We use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.437.1">withContext()</span></strong><span class="kobospan" id="kobo.438.1"> function to switch the context of the coroutine to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.439.1">Dispatchers.IO</span></strong><span class="kobospan" id="kobo.440.1"> dispatcher. </span><span class="kobospan" id="kobo.440.2">This ensures that the network request is performed on a </span><span><span class="kobospan" id="kobo.441.1">background thread.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.442.1">We have also wrapped our network request in a </span><strong class="source-inline1"><span class="kobospan" id="kobo.443.1">try-catch</span></strong><span class="kobospan" id="kobo.444.1"> block. </span><span class="kobospan" id="kobo.444.2">This is to ensure we catch all the </span><a id="_idIndexMarker293" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.445.1">errors that might occur during the </span><span><span class="kobospan" id="kobo.446.1">network request.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.447.1">Inside our </span><strong class="source-inline1"><span class="kobospan" id="kobo.448.1">try</span></strong><span class="kobospan" id="kobo.449.1"> block, we are making the network request using our </span><strong class="source-inline1"><span class="kobospan" id="kobo.450.1">CatsAPI</span></strong><span class="kobospan" id="kobo.451.1"> instance. </span><span class="kobospan" id="kobo.451.2">We use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.452.1">fetchCats()</span></strong><span class="kobospan" id="kobo.453.1"> method to make the request. </span><span class="kobospan" id="kobo.453.2">We pass in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.454.1">cute</span></strong><span class="kobospan" id="kobo.455.1"> tag to specify the type of cats we want to fetch. </span><span class="kobospan" id="kobo.455.2">We check if the response is successful. </span><span class="kobospan" id="kobo.455.3">If it is, we return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.456.1">NetworkResult.Success</span></strong><span class="kobospan" id="kobo.457.1"> object with the response body. </span><span class="kobospan" id="kobo.457.2">If it is not, we return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.458.1">NetworkResult.Error</span></strong><span class="kobospan" id="kobo.459.1"> object with the </span><span><span class="kobospan" id="kobo.460.1">error message.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.461.1">Lastly, we catch all the exceptions that might occur during the network request and return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.462.1">NetworkResult.Error</span></strong><span class="kobospan" id="kobo.463.1"> object with the </span><span><span class="kobospan" id="kobo.464.1">error message.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.465.1">In our Koin modules, we also need to change how we instantiate our repository. </span><span class="kobospan" id="kobo.465.2">Let us head over to </span><strong class="source-inline"><span class="kobospan" id="kobo.466.1">Module.kt</span></strong><span class="kobospan" id="kobo.467.1"> and update the </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">PetsRepository</span></strong><span class="kobospan" id="kobo.469.1"> definition </span><span><span class="kobospan" id="kobo.470.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.471.1">
single&lt;PetsRepository&gt; { PetsRepositoryImpl(get(), get()) }
single { Dispatchers.IO }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.472.1">We inject the </span><strong class="source-inline"><span class="kobospan" id="kobo.473.1">CatsAPI</span></strong><span class="kobospan" id="kobo.474.1"> instance and the </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">dispatcher</span></strong><span class="kobospan" id="kobo.476.1"> into our repository. </span><span class="kobospan" id="kobo.476.2">We also declare the dispatcher as a single instance. </span><span class="kobospan" id="kobo.476.3">Now we need to modify our </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.478.1"> to accommodate these changes. </span><span class="kobospan" id="kobo.478.2">To begin with, we need to create a state class that holds the state of our network request and exposes it to our view. </span><span class="kobospan" id="kobo.478.3">Create a new Kotlin data class inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">view</span></strong><span class="kobospan" id="kobo.480.1"> package </span><span><span class="kobospan" id="kobo.481.1">called </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.482.1">PetsUIState.kt</span></strong></span><span><span class="kobospan" id="kobo.483.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.484.1">
data class PetsUIState(
    val isLoading: Boolean = false,
    val pets: List&lt;Cat&gt; = emptyList(),
    val error: String? </span><span class="kobospan1" id="kobo.484.2">= null
)</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.485.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.486.1">PetsUIState</span></strong><span class="kobospan" id="kobo.487.1"> class is a data class that holds the state of our network request. </span><span class="kobospan" id="kobo.487.2">It has </span><span><span class="kobospan" id="kobo.488.1">three properties:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.489.1">isLoading</span></strong><span class="kobospan" id="kobo.490.1">: This is a</span><a id="_idIndexMarker294" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.491.1"> Boolean that is used to indicate whether the network request is loading </span><span><span class="kobospan" id="kobo.492.1">or not.</span></span></li>
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.493.1">pets</span></strong><span class="kobospan" id="kobo.494.1">: This is a list of cats that will be returned from the </span><span><span class="kobospan" id="kobo.495.1">network request.</span></span></li>
<li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.496.1">error</span></strong><span class="kobospan" id="kobo.497.1">: This is a string that will be used to hold the error message returned from the </span><span><span class="kobospan" id="kobo.498.1">network request.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.499.1">Next, in </span><strong class="source-inline"><span class="kobospan" id="kobo.500.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.501.1">, let us create a variable that will hold the state of our </span><span><span class="kobospan" id="kobo.502.1">network request:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.503.1">
val petsUIState = MutableStateFlow(PetsUIState())</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.504.1">We use the </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">MutableStateFlow</span></strong><span class="kobospan" id="kobo.506.1"> class to hold the state of our network request. </span><strong class="source-inline"><span class="kobospan" id="kobo.507.1">MutableStateFlow</span></strong><span class="kobospan" id="kobo.508.1"> allows us to update the value of the state. </span><span class="kobospan" id="kobo.508.2">We initialize it with an empty </span><strong class="source-inline"><span class="kobospan" id="kobo.509.1">PetsUIState</span></strong><span class="kobospan" id="kobo.510.1"> object. </span><span class="kobospan" id="kobo.510.2">Next, let us update the </span><strong class="source-inline"><span class="kobospan" id="kobo.511.1">getPets()</span></strong><span class="kobospan" id="kobo.512.1"> method </span><span><span class="kobospan" id="kobo.513.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.514.1">
private fun getPets() {
    petsUIState.value = PetsUIState(isLoading = true)
    viewModelScope.launch {
        when (val result = petsRepository.getPets()) {
            is NetworkResult.Success -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, pets = result.data)
                }
            }
            is NetworkResult.Error -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, error = result.error)
                }
            }
        }
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.515.1">Here, we will break down the </span><a id="_idIndexMarker295" class="calibre3 pcalibre pcalibre1"/><span><span class="kobospan" id="kobo.516.1">preceding code:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.517.1">We update the value of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.518.1">petsUIState</span></strong><span class="kobospan" id="kobo.519.1"> variable to indicate that the network request </span><span><span class="kobospan" id="kobo.520.1">is loading.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.521.1">We use </span><strong class="source-inline1"><span class="kobospan" id="kobo.522.1">viewModelScope</span></strong><span class="kobospan" id="kobo.523.1"> to launch a coroutine. </span><span class="kobospan" id="kobo.523.2">This ensures that the coroutine is canceled when the </span><strong class="source-inline1"><span class="kobospan" id="kobo.524.1">ViewModel</span></strong> <span><span class="kobospan" id="kobo.525.1">is destroyed.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.526.1">There is a </span><strong class="source-inline1"><span class="kobospan" id="kobo.527.1">when</span></strong><span class="kobospan" id="kobo.528.1"> statement, which is a Kotlin pattern-matching feature to check the result of the network request. </span><span class="kobospan" id="kobo.528.2">If the result is a </span><strong class="source-inline1"><span class="kobospan" id="kobo.529.1">NetworkResult.Success</span></strong><span class="kobospan" id="kobo.530.1"> object, we update the value of </span><strong class="source-inline1"><span class="kobospan" id="kobo.531.1">petsUIState</span></strong><span class="kobospan" id="kobo.532.1"> to indicate that the network request was successful and passed in the list of cats. </span><span class="kobospan" id="kobo.532.2">If the result is a </span><strong class="source-inline1"><span class="kobospan" id="kobo.533.1">NetworkResult.Error</span></strong><span class="kobospan" id="kobo.534.1"> object, we update the value of </span><strong class="source-inline1"><span class="kobospan" id="kobo.535.1">petsUIState</span></strong><span class="kobospan" id="kobo.536.1"> to indicate that the network request failed and pass in the </span><span><span class="kobospan" id="kobo.537.1">error message.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.538.1">In </span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.540.1">, let us add a new </span><strong class="source-inline"><span class="kobospan" id="kobo.541.1">init</span></strong><span class="kobospan" id="kobo.542.1"> block that will call the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.543.1">getPets()</span></strong></span><span><span class="kobospan" id="kobo.544.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.545.1">
init {
    getPets()
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.546.1">This will ensure that the </span><strong class="source-inline"><span class="kobospan" id="kobo.547.1">getPets()</span></strong><span class="kobospan" id="kobo.548.1"> function is called when </span><strong class="source-inline"><span class="kobospan" id="kobo.549.1">ViewModel</span></strong><span class="kobospan" id="kobo.550.1"> is created. </span><span class="kobospan" id="kobo.550.2">We now need to update our </span><strong class="source-inline"><span class="kobospan" id="kobo.551.1">PetList</span></strong><span class="kobospan" id="kobo.552.1"> composable to accommodate these changes, too. </span><span class="kobospan" id="kobo.552.2">We will also add more UI components since we need to show the loading state, images, and error messages. </span><span class="kobospan" id="kobo.552.3">Let</span><a id="_idIndexMarker296" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.553.1"> us start by adding a library that allows us to load images from a URL. </span><span class="kobospan" id="kobo.553.2">We will use Coil (</span><a href="https://coil-kt.github.io/coil/" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.554.1">https://coil-kt.github.io/coil/</span></a><span class="kobospan" id="kobo.555.1">), which is an image-loading library. </span><span class="kobospan" id="kobo.555.2">In the versions catalog, let’s add </span><span><span class="kobospan" id="kobo.556.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.557.1">
coil-compose = "io.coil-kt:coil-compose:2.4.0"</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.558.1">We will also add the </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">coil-compose</span></strong><span class="kobospan" id="kobo.560.1"> dependency to our </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">compose</span></strong><span class="kobospan" id="kobo.562.1"> bundle so that it can be provided alongside other compose libraries. </span><span class="kobospan" id="kobo.562.2">The updated compose bundle will be </span><span><span class="kobospan" id="kobo.563.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.564.1">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose"]</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.565.1">Let us now create a new composable that displays an image and tags for each cat inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.566.1">view</span></strong><span class="kobospan" id="kobo.567.1"> package called </span><strong class="source-inline"><span class="kobospan" id="kobo.568.1">PetListItem.kt</span></strong><span class="kobospan" id="kobo.569.1"> and add </span><span><span class="kobospan" id="kobo.570.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.571.1">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(cat: Cat) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
                repeat(cat.tags.size) {
                    SuggestionChip(
                        modifier = Modifier
                            .padding(start = 3.dp, end = 3.dp),
                        onClick = { },
                        label = {
                            Text(text = cat.tags[it])
                        }
                    )
                }
            }
        }
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.572.1">This composable takes in a </span><strong class="source-inline"><span class="kobospan" id="kobo.573.1">Cat</span></strong><span class="kobospan" id="kobo.574.1"> object and displays the image and tags for the cat. </span><span class="kobospan" id="kobo.574.2">We use the </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">AsyncImage</span></strong><span class="kobospan" id="kobo.576.1"> composable from the Coil library to load the image from the URL. </span><span class="kobospan" id="kobo.576.2">We also use the </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">FlowRow</span></strong><span class="kobospan" id="kobo.578.1"> composable to</span><a id="_idIndexMarker297" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.579.1"> display the tags for the cat. </span><span class="kobospan" id="kobo.579.2">We use the </span><strong class="source-inline"><span class="kobospan" id="kobo.580.1">SuggestionChip</span></strong><span class="kobospan" id="kobo.581.1"> composable to display each tag. </span><span class="kobospan" id="kobo.581.2">We display the image and tags in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.582.1">ElevatedCard</span></strong></span><span><span class="kobospan" id="kobo.583.1"> composable.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.584.1">Next, let us update our </span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">PetList</span></strong><span class="kobospan" id="kobo.586.1"> composable to accommodate these changes. </span><span class="kobospan" id="kobo.586.2">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.587.1">PetList.kt</span></strong><span class="kobospan" id="kobo.588.1"> file, update the </span><strong class="source-inline"><span class="kobospan" id="kobo.589.1">PetList</span></strong><span class="kobospan" id="kobo.590.1"> composable </span><span><span class="kobospan" id="kobo.591.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.592.1">
@Composable
fun PetList(modifier: Modifier) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    Column(
        modifier = modifier
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AnimatedVisibility(
            visible = petsUIState.isLoading
        ) {
            CircularProgressIndicator()
        }
        AnimatedVisibility(
            visible = petsUIState.pets.isNotEmpty()
        ) {
            LazyColumn {
                items(petsUIState.pets) { pet -&gt;
                    PetListItem(cat = pet)
                }
            }
        }
        AnimatedVisibility(
            visible = petsUIState.error != null
        ) {
            Text(text = petsUIState.error ?: "")
        }
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.593.1">The following is the breakdown of the </span><span><span class="kobospan" id="kobo.594.1">preceding code:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.595.1">Same as before, we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.596.1">koinViewModel()</span></strong><span class="kobospan" id="kobo.597.1"> function to get an instance </span><span><span class="kobospan" id="kobo.598.1">of </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.599.1">PetsViewModel</span></strong></span><span><span class="kobospan" id="kobo.600.1">.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.601.1">We use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.602.1">collectAsStateWithLifecycle()</span></strong><span class="kobospan" id="kobo.603.1"> function to collect the state of our network request. </span><span class="kobospan" id="kobo.603.2">This function is provided by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.604.1">lifecycle-runtime-compose</span></strong><span class="kobospan" id="kobo.605.1"> library. </span><span class="kobospan" id="kobo.605.2">It is used to collect the state of a flow and automatically cancel the</span><a id="_idIndexMarker298" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.606.1"> collection when the life cycle is destroyed. </span><span class="kobospan" id="kobo.606.2">We use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.607.1">petsUIState</span></strong><span class="kobospan" id="kobo.608.1"> property of </span><strong class="source-inline1"><span class="kobospan" id="kobo.609.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.610.1"> to get the state of our </span><span><span class="kobospan" id="kobo.611.1">network request.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.612.1">We have a </span><strong class="source-inline1"><span class="kobospan" id="kobo.613.1">Column</span></strong><span class="kobospan" id="kobo.614.1"> composable that contains three </span><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">AnimatedVisibility</span></strong><span class="kobospan" id="kobo.616.1"> composables. </span><span class="kobospan" id="kobo.616.2">The first one is used to display a </span><strong class="source-inline1"><span class="kobospan" id="kobo.617.1">CircularProgressIndicator</span></strong><span class="kobospan" id="kobo.618.1"> when the network request is loading. </span><span class="kobospan" id="kobo.618.2">The second one is used to display the list of cats when the network request is successful. </span><span class="kobospan" id="kobo.618.3">The last one is used to display an error message when the network </span><span><span class="kobospan" id="kobo.619.1">request fails.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.620.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">collectAsStateWithLifecycle()</span></strong><span class="kobospan" id="kobo.622.1"> shows an error since we have not added its dependency. </span><span class="kobospan" id="kobo.622.2">Let us add it to our libraries section in the versions catalog </span><span><span class="kobospan" id="kobo.623.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.624.1">
compose-lifecycle = { module = "androidx.lifecycle:lifecycle-runtime-compose", version.ref = "lifecycle" }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.625.1">We will also add it to our </span><strong class="source-inline"><span class="kobospan" id="kobo.626.1">compose</span></strong><span class="kobospan" id="kobo.627.1"> bundle so that it can be provided alongside other compose libraries. </span><span class="kobospan" id="kobo.627.2">The updated compose bundle will be </span><span><span class="kobospan" id="kobo.628.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.629.1">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose", "compose-lifecycle"]</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.630.1">Do a Gradle sync and the IDE will prompt you to add imports for the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.631.1">collectAsStateWithLifecycle()</span></strong></span><span><span class="kobospan" id="kobo.632.1"> function.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.633.1">We have completed updating all</span><a id="_idIndexMarker299" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.634.1"> our layers to use the new coroutines approach. </span><span class="kobospan" id="kobo.634.2">Good work so far! </span><span class="kobospan" id="kobo.634.3">One last thing: since our app is now fetching these items from an API hosted online, we need to add the </span><strong class="source-inline"><span class="kobospan" id="kobo.635.1">INTERNET</span></strong><span class="kobospan" id="kobo.636.1"> permission to our app. </span><span class="kobospan" id="kobo.636.2">Open the </span><strong class="source-inline"><span class="kobospan" id="kobo.637.1">AndroidManifest.xml file</span></strong><span class="kobospan" id="kobo.638.1"> and add </span><span><span class="kobospan" id="kobo.639.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.640.1">
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.641.1">Run the app and see if everything is working as expected. </span><span class="kobospan" id="kobo.641.2">We can see a list of cute cats with their tags being displayed. </span><span class="kobospan" id="kobo.641.3">We can also see the loading indicator when the network request is loading and the error message when the network request fails. </span><span class="kobospan" id="kobo.641.4">We have successfully refactored our app to </span><span><span class="kobospan" id="kobo.642.1">use coroutines.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer081">
<span class="kobospan" id="kobo.643.1"><img alt="Figure 6.1 – Cute cats" src="image/B19779_06_01.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.644.1">Figure 6.1 – Cute cats</span></p>
<h1 id="_idParaDest-82" class="calibre6"><a id="_idTextAnchor091" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.645.1">Summary</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.646.1">In this chapter, we learned how to perform network calls with Retrofit. </span><span class="kobospan" id="kobo.646.2">Moreso, we learned how to take advantage of Kotlin coroutines to perform asynchronous network requests in our app and refactored our app to fetch some cute cats with </span><span><span class="kobospan" id="kobo.647.1">Kotlin coroutines.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.648.1">In the next chapter, we will be looking at another Jetpack library, </span><strong class="bold"><span class="kobospan" id="kobo.649.1">Jetpack Navigation</span></strong><span class="kobospan" id="kobo.650.1">, to handle navigation in </span><span><span class="kobospan" id="kobo.651.1">our app.</span></span></p>
</div>
</body></html>