<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor084" class="calibre3 pcalibre pcalibre1"/>6</h1>
<h1 id="_idParaDest-76" class="calibre6"><a id="_idTextAnchor085" class="calibre3 pcalibre pcalibre1"/>Network Calls with Kotlin Coroutines</h1>
<p class="calibre4">Most of the apps we use on our phones fetch data that is hosted online on a server. As such, we developers have to understand how to request and send data to the servers too. In this chapter, we will learn how to send and request data that is hosted online and display it in our apps.</p>
<p class="calibre4">In this chapter, we will learn how to perform network calls with a networking library, <strong class="bold">Retrofit</strong>. We will learn how to consume <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) using this library. Moreso, we will learn how to take advantage of <strong class="bold">Kotlin coroutines</strong> to perform asynchronous network requests in our app.</p>
<p class="calibre4">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre16">
<li class="calibre15">Setting up Retrofit</li>
<li class="calibre15">Introduction to Kotlin coroutines</li>
<li class="calibre15">Using Kotlin coroutines for network calls</li>
</ul>
<h1 id="_idParaDest-77" class="calibre6"><a id="_idTextAnchor086" class="calibre3 pcalibre pcalibre1"/>Technical requirements</h1>
<p class="calibre4">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio</a>) downloaded.</p>
<p class="calibre4">You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix" class="calibre3 pcalibre pcalibre1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix</a>.</p>
<h1 id="_idParaDest-78" class="calibre6"><a id="_idTextAnchor087" class="calibre3 pcalibre pcalibre1"/>Setting up Retrofit</h1>
<p class="calibre4">Retrofit is a type-safe REST client for Android, Java, and Kotlin developed by Square. The library provides a <a id="_idIndexMarker274" class="calibre3 pcalibre pcalibre1"/>powerful framework for authenticating and interacting with APIs and sending network requests with OkHttp. In this book, we will be using Retrofit to perform our network requests.</p>
<p class="calibre4">To begin with, we will add the Retrofit dependencies using our newly created version catalog. Let’s define the versions in the <code>libs.versions.toml</code> file as follows:</p>
<pre class="source-code">
retrofit = "2.9.0"
retrofitSerializationConverter = "1.0.0"
serializationJson = "1.5.1"
coroutines = "1.7.3"
okhttp3 = "4.11.0"</pre> <p class="calibre4">Next, let’s define the <a id="_idIndexMarker275" class="calibre3 pcalibre pcalibre1"/>libraries in the <code>libs.versions.toml</code> file in the libraries section of our versions catalog as follows:</p>
<pre class="source-code">
retrofit = { module = "com.squareup.retrofit2:retrofit" , version.ref = "retrofit" }
retrofit-serialization = { module = "com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter", version.ref = "retrofitSerializationConverter" }
coroutines = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core" , version.ref = "coroutines" }
coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android" , version.ref = "coroutines" }
serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "serializationJson" }
okhttp3 = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp3" }</pre> <p class="calibre4">We are adding these dependencies to our project:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Retrofit</strong>: As mentioned earlier, we will use Retrofit to perform our network requests.</li>
<li class="calibre15"><strong class="bold">Retrofit serialization</strong>: This is a converter<a id="_idIndexMarker276" class="calibre3 pcalibre pcalibre1"/> that uses <strong class="bold">Kotlinx serialization</strong> to convert Kotlin objects to and from JSON.</li>
<li class="calibre15"><strong class="bold">Coroutines</strong>: We will use Kotlin coroutines to perform our network requests asynchronously. We will be learning more about coroutines shortly.</li>
<li class="calibre15"><strong class="bold">Kotlinx serialization JSON</strong>: This is a Kotlin serialization library for JSON. We will use this to parse our JSON responses. We have other serialization libraries, such as Moshi and Gson, but we <a id="_idIndexMarker277" class="calibre3 pcalibre pcalibre1"/>used the Kotlinx serialization library for the following reasons:<ul class="calibre17"><li class="calibre15"><strong class="bold">Kotlin-centric development</strong>: Kotlinx serialization is designed with Kotlin in mind, providing seamless integration and native support for Kotlin serialization.</li><li class="calibre15"><strong class="bold">Declarative syntax</strong>: Kotlinx serialization uses a declarative syntax, leveraging Kotlin’s language features for concise and readable serialization code.</li><li class="calibre15"><strong class="bold">Compile-time safety</strong>: Compile-time safety is a key feature, catching serialization-related errors during the compilation phase and reducing the likelihood of runtime errors.</li><li class="calibre15"><strong class="bold">Custom serialization strategies</strong>: We have the flexibility to define custom serialization strategies for specific types or scenarios, offering fine-grained control over the serialization process.</li><li class="calibre15"><strong class="bold">Seamless integration with Kotlin ecosystem</strong>: Being part of the Kotlin ecosystem, Kotlinx serialization integrates seamlessly with other Kotlin libraries and frameworks, contributing to a cohesive development experience.</li></ul></li>
<li class="calibre15"><strong class="bold">OkHttp</strong>: This is an HTTP client that is used to make network requests. It provides some utilities for working with Retrofit.</li>
</ul>
<p class="calibre4">All these dependencies will be added together, so this is a chance for us to group them in our <code>libs.versions.toml</code> file, add this bundle below our Koin bundle:</p>
<pre class="source-code">
networking = ["retrofit", "retrofit-serialization", "serialization-json", "coroutines", "coroutines-android"]</pre> <p class="calibre4">Here, we create a new bundle called <code>networking</code> and add all the dependencies that we specified earlier on. We have to sync the project for our changes to be added to the project. Tap on <code>libs.versions.toml</code> file. After<a id="_idIndexMarker278" class="calibre3 pcalibre pcalibre1"/> syncing, let us start setting up the plugins and dependencies.</p>
<p class="calibre4"> First, in our project-level <code>build.gradle.kts</code> file, we need to add the Kotlinx serialization plugin. Open the project-level <code>build.gradle.kts</code> file and on the plugins block add the following:</p>
<pre class="source-code">
id("org.jetbrains.kotlin.plugin.serialization") version "1.8.20" apply false</pre> <p class="calibre4">We define the Kotlinx serialization plugin and specify the version to use. This will set up the Kotlinx serialization plugin for us. The plugin generates Kotlin code for serializable classes. We will use this plugin to generate our models. Next, let us set up the plugin in our app module. Open the app-level <code>build.gradle.kts</code> file and add the following in the plugins block:</p>
<pre class="source-code">
id("kotlinx-serialization")</pre> <p class="calibre4">This ensures our module is set up to use the Kotlinx serialization plugin. Next, we will add our <code>networking</code> bundle to our app module. In the app-level <code>build.gradle.kts</code> file, add the following:</p>
<pre class="source-code">
implementation(libs.bundles.networking)</pre> <p class="calibre4">This will add all the dependencies that we have specified in our <code>networking</code> bundle. Having done all these, our project is set up to use Retrofit. We will be using Koin to create a Retrofit instance<a id="_idIndexMarker279" class="calibre3 pcalibre pcalibre1"/> that will be injected into classes that need it. Let us head over to the <code>Module.kt</code> file and add the <code>PetsViewModel</code> definition:</p>
<pre class="source-code">
single {
    Retrofit.Builder()
        .addConverterFactory(
            Json.asConverterFactory(contentType = "application/json".toMediaType())
        )
        .baseUrl("https://cataas.com/api/")
        .build()
}</pre> <p class="calibre4">In the preceding code, we created a Retrofit instance using the Retrofit builder. We also added a converter factory that uses Kotlinx serialization to convert Kotlin objects to and from JSON. We also specified the base URL for our API. We are using the <code>CatsAPI.kt</code> and add the following method:</p>
<pre class="source-code">
@GET("cats")
suspend fun fetchCats(
    @Query("tag") tag: String,
): Response&lt;List&lt;Cat&gt;&gt;</pre> <p class="calibre4">In the preceding code, we use the <code>@GET</code> annotation to specify that we will be using the <code>GET</code> HTTP method for this request. Inside the method, we are also specifying a path that will be appended to our<a id="_idIndexMarker281" class="calibre3 pcalibre pcalibre1"/> base URL to make the full URL for our request. Using the <code>GET</code> method means our method will only request data. We have the following built-in HTTP annotations:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1">POST</strong>: This is used when we want to send data to the server</li>
<li class="calibre15"><strong class="source-inline1">PUT</strong>: This is used when we want to update data on the server</li>
<li class="calibre15"><strong class="source-inline1">DELETE</strong>: This is used when we want to delete data from the server</li>
<li class="calibre15"><strong class="source-inline1">HEAD</strong>: This method asks for a response identical to the one that would correspond to a <strong class="source-inline1">GET</strong> request but without the response body</li>
<li class="calibre15"><strong class="source-inline1">PATCH</strong>: This is used when we want to update data partially on the server</li>
<li class="calibre15"><strong class="source-inline1">OPTIONS</strong>: This method requests permitted communication options for the target resource</li>
</ul>
<p class="calibre4">Back to our <code>fetchCats()</code> function, you can notice that we use the <code>@Query</code> annotation to specify the query parameter for our request. We use the <code>tag</code> query parameter to specify the type of cat we want to fetch. We also use the <code>suspend</code> keyword to specify that this method will be called from a coroutine or another <code>suspend</code> function. We will learn more about coroutines shortly in the <em class="italic">Introduction to Kotlin coroutines</em> section of this chapter. We also use the <code>Response</code> class to wrap up our response. This class is provided by Retrofit and it contains the HTTP response metadata such as response code, headers, and the raw response body. We also specify that the response will be a list of <code>Cat</code> objects. Retrofit will map the response to a list of <code>Cat</code> objects. To resolve the error for the <code>Cat</code> <code>data class</code>, let us create it. Create a new Kotlin data class inside the data package called <code>Cat.kt</code> and add the following:</p>
<pre class="source-code">
@Serializable
data class Cat(
    @SerialName ("createdAt")
    val createdAt: String,
    @SerialName("_id")
    val id: String,
    @SerialName("owner")
    val owner: String,
    @SerialName("tags")
    val tags: List&lt;String&gt;,
    @SerialName("updatedAt")
    val updatedAt: String
)</pre> <p class="calibre4">The <code>Cat</code> data class has the fields that correspond to the JSON response from the Cat as a Service API. It is also annotated with the <code>@Serializable</code> annotation. This annotation is provided by Kotlinx Serialization and it is used to mark a class as serializable. This annotation is required for all the classes that we want to serialize or deserialize. We have used<a id="_idIndexMarker282" class="calibre3 pcalibre pcalibre1"/> the <code>@SerialName</code> annotation before each variable in our data class. The <code>@SerialName</code> is an annotation used to customize the mapping between Kotlin property names and the corresponding names used in the serialized form, such as JSON or other data interchange formats. This annotation allows you to specify a different name for a property when it is serialized or deserialized, providing flexibility in handling naming conventions.</p>
<p class="calibre4">In our project, we are using Koin for dependency injection. So, we now need to create an instance of our <code>CatsAPI</code> class in our Koin modules. Let us head back to the <code>Module.kt</code> file and below the Retrofit instance add the following:</p>
<pre class="source-code">
single { get&lt;Retrofit&gt;().create(CatsAPI::class.java) }</pre> <p class="calibre4">Here, we get our Retrofit instance and use it to create an instance of our <code>CatsAPI</code> class, which we use to make the actual network requests. With that, our project is ready to make the network<a id="_idIndexMarker283" class="calibre3 pcalibre pcalibre1"/> requests. But before that, let us learn more about Kotlin coroutines as we are going to modify our repository to use coroutines.</p>
<h1 id="_idParaDest-79" class="calibre6"><a id="_idTextAnchor088" class="calibre3 pcalibre pcalibre1"/>Introduction to Kotlin coroutines</h1>
<p class="calibre4">Coroutines, introduced by JetBrains <a id="_idIndexMarker284" class="calibre3 pcalibre pcalibre1"/>for Kotlin, provide a way to write asynchronous code in a more readable and synchronous manner. We can use them to perform background tasks and they are a great way to perform network requests and long-running tasks such as reading and writing to a database. They do these tasks off the main thread and ensure that we don’t block our main thread while performing these operations. The main benefits of using coroutines are as follows:</p>
<ul class="calibre16">
<li class="calibre15">They are lightweight and easy to use.</li>
<li class="calibre15">They have built-in cancellation support.</li>
<li class="calibre15">They lower the chances of apps having memory leaks.</li>
<li class="calibre15">As mentioned in earlier chapters, Jetpack libraries also support and use coroutines.</li>
</ul>
<p class="calibre4">We have already added the core and Android coroutines libraries in our app. Let us understand some coroutines basics before proceeding to use coroutines in our project.</p>
<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor089" class="calibre3 pcalibre pcalibre1"/>Coroutine basics</h2>
<p class="calibre4">In this section, we will be<a id="_idIndexMarker285" class="calibre3 pcalibre pcalibre1"/> looking at different terms and concepts used in Kotlin coroutines:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1">suspend</strong>: This is a keyword that is used to mark a function. A <strong class="source-inline1">suspend</strong> function is a function that can be paused and resumed at a later time. We have already used this keyword in our <strong class="source-inline1">CatsAPI</strong> class to mark the <strong class="source-inline1">fetchCats()</strong> function as a <strong class="source-inline1">suspend</strong> function. A <strong class="source-inline1">suspend</strong> function can only be called from another <strong class="source-inline1">suspend</strong> function or from a coroutine.</li>
<li class="calibre15"><strong class="bold">Coroutine builders</strong>: These are functions that are used to create coroutines. We have the <strong class="source-inline1">launch</strong> and <strong class="source-inline1">async</strong> coroutine builders. <strong class="source-inline1">launch</strong> is used to create a coroutine that does not return a result while <strong class="source-inline1">async</strong> is used to create a coroutine that returns a result. The result is a <strong class="source-inline1">Deferred</strong> object and we can use the <strong class="source-inline1">await()</strong> method to get the result. Both of these builders return a <strong class="source-inline1">Job</strong> object that we can use to check if the coroutine is still active or if it has been canceled. We can also use the job to wait for the coroutine to finish. A job ends when it’s completed or canceled.</li>
<li class="calibre15"><strong class="bold">Jobs</strong>: A job is a coroutine instance with a <strong class="bold">life cycle</strong> and can be canceled. We can use the job to check if the coroutine is still active or if it has been canceled. We can also use the <a id="_idIndexMarker286" class="calibre3 pcalibre pcalibre1"/>job to wait for the coroutine to finish. A job ends when it’s completed or canceled. As mentioned earlier, both the <strong class="source-inline1">launch</strong> and <strong class="source-inline1">async</strong> coroutine builders return a <strong class="source-inline1">Job</strong> object which we use to manage the coroutine life cycle. We have a normal <strong class="source-inline1">Job</strong> and <strong class="source-inline1">SupervisorJob</strong>. A normal <strong class="source-inline1">Job</strong> is canceled when any of its children fail. <strong class="source-inline1">SupervisorJob</strong> is not canceled when any of its children fail. It is recommended to use <strong class="source-inline1">SupervisorJob</strong> when we have multiple coroutines running concurrently.</li>
<li class="calibre15"><strong class="bold">Coroutine scope</strong>: This keeps track of all the coroutines we create using the <strong class="source-inline1">launch</strong> or <strong class="source-inline1">async</strong> builders. It is responsible for knowing how long a coroutine will live. Every coroutine builder is defined as an extension function of scope. Coroutines cannot be launched without a scope. We have <strong class="source-inline1">GlobalScope</strong>, which is a scope that is not tied to any life cycle. It is not recommended to use this scope as it can lead to memory leaks. In Android, the KTX libraries provide <strong class="source-inline1">viewModelScope</strong>, which is a scope that is tied to <strong class="source-inline1">ViewModel</strong>. We can use this scope to launch coroutines that will be canceled when <strong class="source-inline1">ViewModel</strong> is destroyed. We also have <strong class="source-inline1">lifecycleScope</strong>, which is a scope that is tied to an activity or fragment life cycle. We can use this scope to launch coroutines that will be canceled when the life cycle is destroyed. We can also create our own custom scopes if we want to launch coroutines that will be canceled when a custom life cycle is destroyed.</li>
<li class="calibre15"><strong class="bold">Coroutine context</strong>: This is a collection <a id="_idIndexMarker287" class="calibre3 pcalibre pcalibre1"/>of many elements. <strong class="source-inline1">CoroutineContext</strong> defines the behavior of our coroutines using elements such as the following:<ul class="calibre17"><li class="calibre15"><strong class="source-inline1">Job</strong>: This manages the life cycle of the coroutine.</li><li class="calibre15"><strong class="source-inline1">CoroutineDispatcher</strong>: This defines the thread on which the coroutine will run.</li><li class="calibre15"><strong class="source-inline1">CoroutineName</strong>: This defines the name of the coroutine.</li><li class="calibre15"><strong class="source-inline1">CoroutineExceptionHandler</strong>: This handles uncaught exceptions in the coroutine.</li></ul></li>
<li class="calibre15"><code>withContext()</code> function to switch between different dispatchers. <code>withContext()</code> is a <code>suspend</code> function that switches the context of the coroutine.</p></li>
<li class="calibre15"><strong class="bold">Flows</strong>: Suspend functions only return single values. Flows are a type of asynchronous data stream that can return multiple values. We can use flows to return multiple values from a <strong class="source-inline1">suspend</strong> function. We can also use flows to perform asynchronous operations. Flows are <strong class="bold">cold streams</strong>. This means that they only start emitting values <a id="_idIndexMarker288" class="calibre3 pcalibre pcalibre1"/>when they are collected. We can use the <strong class="source-inline1">collect()</strong> function to collect values from a flow. We have <strong class="source-inline1">StateFlow</strong> and <strong class="source-inline1">SharedFlow</strong>, which are types of flows. <strong class="source-inline1">StateFlow</strong> is a flow that emits the current value to new collectors and emits new values to existing collectors. <strong class="source-inline1">SharedFlow</strong> is a flow that emits new values to all collectors. We will be learning more about flows in the next <a id="_idIndexMarker289" class="calibre3 pcalibre pcalibre1"/>chapter. In Android, we will normally use the two types of flows to emit data to our UI. We will see the usage of <strong class="source-inline1">StateFlow</strong> in <strong class="source-inline1">ViewModel</strong> as we refactor it to use coroutines.</li>
</ul>
<p class="calibre4">With this understanding of the basics, in the next section, we will be refactoring our repository to use coroutines.</p>
<h1 id="_idParaDest-81" class="calibre6"><a id="_idTextAnchor090" class="calibre3 pcalibre pcalibre1"/>Using Kotlin coroutines for network calls</h1>
<p class="calibre4">In this section, we will refactor our repository to use coroutines. We will use <code>StateFlow</code> to emit data <a id="_idIndexMarker290" class="calibre3 pcalibre pcalibre1"/>from <code>ViewModel</code> to the view layer. We will also use the <code>Dispatchers.IO</code> dispatcher to perform our network requests on a background thread.</p>
<p class="calibre4">Let us start by creating a <code>NetworkResult</code> <code>sealed class</code>, which will represent the different states of our network request:</p>
<pre class="source-code">
sealed class NetworkResult&lt;out T&gt; {
    data class Success&lt;out T&gt;(val data: T) : NetworkResult&lt;T&gt;()
    data class Error(val error: String) : NetworkResult&lt;Nothing&gt;()
}</pre> <p class="calibre4">The <code>NetworkResult</code> class is a sealed class that has two subclasses. We have the <code>Success</code> data class that will be used to represent a successful network request. It has a data property that will be used to hold the data returned from the network request. We also have the <code>Error</code> class, which will be used to represent a failed network request. It has an <code>error</code> property that will be used to hold the error message returned from the network request. The sealed class encapsulates a generic data type <code>T</code>, which makes it easier for us to<a id="_idIndexMarker291" class="calibre3 pcalibre pcalibre1"/> reuse the class in all our network calls. The <code>Success</code> data class also has a generic parameter for the same purpose.</p>
<p class="calibre4">Next, let us modify <code>PetsRepository</code> as follows:</p>
<pre class="source-code">
interface PetsRepository {
    suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt;
}</pre> <p class="calibre4">We have updated the interface to use the <code>NetworkResult</code> class. We have also marked the <code>getPets()</code> function as a <code>suspend</code> function. We will use this method to fetch the cats from the API. Next, let us modify <code>PetsRepositoryImpl</code> to add the changes from <code>PetsRepository</code>:</p>
<pre class="source-code">
class PetsRepositoryImpl(
    private  val catsAPI: CatsAPI,
    private val dispatcher: CoroutineDispatcher
): PetsRepository {
    override suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt; {
        return withContext(dispatcher) {
            try {
                val response = catsAPI.fetchCats("cute")
                if (response.isSuccessful) {
                    NetworkResult.Success(response.body()!!)
                } else {
                    NetworkResult.Error(response.errorBody().toString())
                }
            } catch (e: Exception) {
                NetworkResult.Error(e.message ?: "Unknown error")
            }
        }
    }
}</pre> <p class="calibre4">We have changed a number of things here:</p>
<ul class="calibre16">
<li class="calibre15">First, we added a constructor that takes in an instance of our <strong class="source-inline1">CatsAPI</strong> class, which we will use to <a id="_idIndexMarker292" class="calibre3 pcalibre pcalibre1"/>make our network requests. It also has a <strong class="source-inline1">dispatcher</strong> parameter, which will be used to specify the dispatcher that we will use to perform our network requests. We will use the <strong class="source-inline1">Dispatchers.IO</strong> dispatcher to perform our network requests on a background thread.</li>
<li class="calibre15">We have also changed the return type of the <strong class="source-inline1">getPets()</strong> function to <strong class="source-inline1">NetworkResult&lt;List&lt;Cat&gt;&gt;</strong>. This is because we will return a <strong class="source-inline1">NetworkResult</strong> object from this method.</li>
<li class="calibre15">We use the <strong class="source-inline1">withContext()</strong> function to switch the context of the coroutine to the <strong class="source-inline1">Dispatchers.IO</strong> dispatcher. This ensures that the network request is performed on a background thread.</li>
<li class="calibre15">We have also wrapped our network request in a <strong class="source-inline1">try-catch</strong> block. This is to ensure we catch all the <a id="_idIndexMarker293" class="calibre3 pcalibre pcalibre1"/>errors that might occur during the network request.</li>
<li class="calibre15">Inside our <strong class="source-inline1">try</strong> block, we are making the network request using our <strong class="source-inline1">CatsAPI</strong> instance. We use the <strong class="source-inline1">fetchCats()</strong> method to make the request. We pass in the <strong class="source-inline1">cute</strong> tag to specify the type of cats we want to fetch. We check if the response is successful. If it is, we return a <strong class="source-inline1">NetworkResult.Success</strong> object with the response body. If it is not, we return a <strong class="source-inline1">NetworkResult.Error</strong> object with the error message.</li>
<li class="calibre15">Lastly, we catch all the exceptions that might occur during the network request and return a <strong class="source-inline1">NetworkResult.Error</strong> object with the error message.</li>
</ul>
<p class="calibre4">In our Koin modules, we also need to change how we instantiate our repository. Let us head over to <code>Module.kt</code> and update the <code>PetsRepository</code> definition as follows:</p>
<pre class="source-code">
single&lt;PetsRepository&gt; { PetsRepositoryImpl(get(), get()) }
single { Dispatchers.IO }</pre> <p class="calibre4">We inject the <code>CatsAPI</code> instance and the <code>dispatcher</code> into our repository. We also declare the dispatcher as a single instance. Now we need to modify our <code>PetsViewModel</code> to accommodate these changes. To begin with, we need to create a state class that holds the state of our network request and exposes it to our view. Create a new Kotlin data class inside the <code>view</code> package called <code>PetsUIState.kt</code>:</p>
<pre class="source-code">
data class PetsUIState(
    val isLoading: Boolean = false,
    val pets: List&lt;Cat&gt; = emptyList(),
    val error: String? = null
)</pre> <p class="calibre4">The <code>PetsUIState</code> class is a data class that holds the state of our network request. It has three properties:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1">isLoading</strong>: This is a<a id="_idIndexMarker294" class="calibre3 pcalibre pcalibre1"/> Boolean that is used to indicate whether the network request is loading or not.</li>
<li class="calibre15"><strong class="source-inline1">pets</strong>: This is a list of cats that will be returned from the network request.</li>
<li class="calibre15"><strong class="source-inline1">error</strong>: This is a string that will be used to hold the error message returned from the network request.</li>
</ul>
<p class="calibre4">Next, in <code>PetsViewModel</code>, let us create a variable that will hold the state of our network request:</p>
<pre class="source-code">
val petsUIState = MutableStateFlow(PetsUIState())</pre> <p class="calibre4">We use the <code>MutableStateFlow</code> class to hold the state of our network request. <code>MutableStateFlow</code> allows us to update the value of the state. We initialize it with an empty <code>PetsUIState</code> object. Next, let us update the <code>getPets()</code> method as follows:</p>
<pre class="source-code">
private fun getPets() {
    petsUIState.value = PetsUIState(isLoading = true)
    viewModelScope.launch {
        when (val result = petsRepository.getPets()) {
            is NetworkResult.Success -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, pets = result.data)
                }
            }
            is NetworkResult.Error -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, error = result.error)
                }
            }
        }
    }
}</pre> <p class="calibre4">Here, we will break down the <a id="_idIndexMarker295" class="calibre3 pcalibre pcalibre1"/>preceding code:</p>
<ul class="calibre16">
<li class="calibre15">We update the value of the <strong class="source-inline1">petsUIState</strong> variable to indicate that the network request is loading.</li>
<li class="calibre15">We use <strong class="source-inline1">viewModelScope</strong> to launch a coroutine. This ensures that the coroutine is canceled when the <strong class="source-inline1">ViewModel</strong> is destroyed.</li>
<li class="calibre15">There is a <strong class="source-inline1">when</strong> statement, which is a Kotlin pattern-matching feature to check the result of the network request. If the result is a <strong class="source-inline1">NetworkResult.Success</strong> object, we update the value of <strong class="source-inline1">petsUIState</strong> to indicate that the network request was successful and passed in the list of cats. If the result is a <strong class="source-inline1">NetworkResult.Error</strong> object, we update the value of <strong class="source-inline1">petsUIState</strong> to indicate that the network request failed and pass in the error message.</li>
</ul>
<p class="calibre4">In <code>PetsViewModel</code>, let us add a new <code>init</code> block that will call the <code>getPets()</code> function:</p>
<pre class="source-code">
init {
    getPets()
}</pre> <p class="calibre4">This will ensure that the <code>getPets()</code> function is called when <code>ViewModel</code> is created. We now need to update our <code>PetList</code> composable to accommodate these changes, too. We will also add more UI components since we need to show the loading state, images, and error messages. Let<a id="_idIndexMarker296" class="calibre3 pcalibre pcalibre1"/> us start by adding a library that allows us to load images from a URL. We will use Coil (<a href="https://coil-kt.github.io/coil/" class="calibre3 pcalibre pcalibre1">https://coil-kt.github.io/coil/</a>), which is an image-loading library. In the versions catalog, let’s add the following:</p>
<pre class="source-code">
coil-compose = "io.coil-kt:coil-compose:2.4.0"</pre> <p class="calibre4">We will also add the <code>coil-compose</code> dependency to our <code>compose</code> bundle so that it can be provided alongside other compose libraries. The updated compose bundle will be as follows:</p>
<pre class="source-code">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose"]</pre> <p class="calibre4">Let us now create a new composable that displays an image and tags for each cat inside the <code>view</code> package called <code>PetListItem.kt</code> and add the following:</p>
<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(cat: Cat) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
                repeat(cat.tags.size) {
                    SuggestionChip(
                        modifier = Modifier
                            .padding(start = 3.dp, end = 3.dp),
                        onClick = { },
                        label = {
                            Text(text = cat.tags[it])
                        }
                    )
                }
            }
        }
    }
}</pre> <p class="calibre4">This composable takes in a <code>Cat</code> object and displays the image and tags for the cat. We use the <code>AsyncImage</code> composable from the Coil library to load the image from the URL. We also use the <code>FlowRow</code> composable to<a id="_idIndexMarker297" class="calibre3 pcalibre pcalibre1"/> display the tags for the cat. We use the <code>SuggestionChip</code> composable to display each tag. We display the image and tags in the <code>ElevatedCard</code> composable.</p>
<p class="calibre4">Next, let us update our <code>PetList</code> composable to accommodate these changes. In the <code>PetList.kt</code> file, update the <code>PetList</code> composable as follows:</p>
<pre class="source-code">
@Composable
fun PetList(modifier: Modifier) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    Column(
        modifier = modifier
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AnimatedVisibility(
            visible = petsUIState.isLoading
        ) {
            CircularProgressIndicator()
        }
        AnimatedVisibility(
            visible = petsUIState.pets.isNotEmpty()
        ) {
            LazyColumn {
                items(petsUIState.pets) { pet -&gt;
                    PetListItem(cat = pet)
                }
            }
        }
        AnimatedVisibility(
            visible = petsUIState.error != null
        ) {
            Text(text = petsUIState.error ?: "")
        }
    }
}</pre> <p class="calibre4">The following is the breakdown of the preceding code:</p>
<ul class="calibre16">
<li class="calibre15">Same as before, we use the <strong class="source-inline1">koinViewModel()</strong> function to get an instance of <strong class="source-inline1">PetsViewModel</strong>.</li>
<li class="calibre15">We use the <strong class="source-inline1">collectAsStateWithLifecycle()</strong> function to collect the state of our network request. This function is provided by the <strong class="source-inline1">lifecycle-runtime-compose</strong> library. It is used to collect the state of a flow and automatically cancel the<a id="_idIndexMarker298" class="calibre3 pcalibre pcalibre1"/> collection when the life cycle is destroyed. We use the <strong class="source-inline1">petsUIState</strong> property of <strong class="source-inline1">PetsViewModel</strong> to get the state of our network request.</li>
<li class="calibre15">We have a <strong class="source-inline1">Column</strong> composable that contains three <strong class="source-inline1">AnimatedVisibility</strong> composables. The first one is used to display a <strong class="source-inline1">CircularProgressIndicator</strong> when the network request is loading. The second one is used to display the list of cats when the network request is successful. The last one is used to display an error message when the network request fails.</li>
</ul>
<p class="calibre4">The <code>collectAsStateWithLifecycle()</code> shows an error since we have not added its dependency. Let us add it to our libraries section in the versions catalog as follows:</p>
<pre class="source-code">
compose-lifecycle = { module = "androidx.lifecycle:lifecycle-runtime-compose", version.ref = "lifecycle" }</pre> <p class="calibre4">We will also add it to our <code>compose</code> bundle so that it can be provided alongside other compose libraries. The updated compose bundle will be as follows:</p>
<pre class="source-code">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose", "compose-lifecycle"]</pre> <p class="calibre4">Do a Gradle sync and the IDE will prompt you to add imports for the <code>collectAsStateWithLifecycle()</code> function.</p>
<p class="calibre4">We have completed updating all<a id="_idIndexMarker299" class="calibre3 pcalibre pcalibre1"/> our layers to use the new coroutines approach. Good work so far! One last thing: since our app is now fetching these items from an API hosted online, we need to add the <code>INTERNET</code> permission to our app. Open the <code>AndroidManifest.xml file</code> and add the following:</p>
<pre class="source-code">
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</pre> <p class="calibre4">Run the app and see if everything is working as expected. We can see a list of cute cats with their tags being displayed. We can also see the loading indicator when the network request is loading and the error message when the network request fails. We have successfully refactored our app to use coroutines.</p>
<div><div><img alt="Figure 6.1 – Cute cats" src="img/B19779_06_01.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Cute cats</p>
<h1 id="_idParaDest-82" class="calibre6"><a id="_idTextAnchor091" class="calibre3 pcalibre pcalibre1"/>Summary</h1>
<p class="calibre4">In this chapter, we learned how to perform network calls with Retrofit. Moreso, we learned how to take advantage of Kotlin coroutines to perform asynchronous network requests in our app and refactored our app to fetch some cute cats with Kotlin coroutines.</p>
<p class="calibre4">In the next chapter, we will be looking at another Jetpack library, <strong class="bold">Jetpack Navigation</strong>, to handle navigation in our app.</p>
</div>
</body></html>