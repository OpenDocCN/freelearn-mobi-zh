- en: Chapter 3. User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A video game is not going to be a whole lot of fun to play if the user has
    no way of controlling the events that happen, so in this chapter we will be looking
    at the various ways in which we can add interactivity to our programs by using
    Marmalade. By the end of this chapter you will know how to detect the following
    types of input:'
  prefs: []
  type: TYPE_NORMAL
- en: Key presses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch screen and pointer inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of gestures such as swipes and pinches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in device orientation using accelerometers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting key input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start our journey into the world of player input methods with the simplest
    method possible—pressing keys, which we detect by using the s3eKeyboard API. To
    use these functions in our code, we just need to include the `s3eKeyboard.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: While the touch screen may now rule supreme as the primary method of interacting
    with many modern devices, it is still worthwhile to know how to detect key presses.
    Android devices, in particular, have keys that are intended to be used for quick
    access to menus and for navigation around a program. Quite often these are not
    even physical buttons, just an area at the bottom of the touch screen, but they
    are still reported as key presses.
  prefs: []
  type: TYPE_NORMAL
- en: Key press detection is also extremely useful when debugging your code in the
    Windows simulator, as Marmalade allows full access to your computer's keyboard
    too. This makes it really easy to add a debugging functionality triggered by a
    key press.
  prefs: []
  type: TYPE_NORMAL
- en: The s3eKeyboard API allows us to detect key input either by key state or by
    character input. It also provides functionality that allows us to determine what
    kind of keyboard support the device we are running on has available.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization and update of key information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a function called `s3eKeyboardGetInt` that allows us to find out what
    kind of keyboard our device has. We can use this information to provide different
    input methods to our program should we want to. For example, entering a user's
    name on a high score might allow the user to enter their name directly if the
    device has a full alphabetic keyboard, but could fall back to a method using arrow
    keys to cycle through characters if the device does not feature a full keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `s3eKeyboardGetInt` function call takes a single parameter from the `s3eKeyboardProperty`
    enumeration, and returns an integer value. Details of the available properties
    are provided in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEYBOARD_HAS_NUMPAD` | Returns `1` if the device has a numeric keypad,
    otherwise returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEYBOARD_HAS_ALPHA` | Returns `1` if the device has an alphabetic keypad,
    otherwise returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEYBOARD_HAS_DIRECTION` | Returns `1` if the device has directional
    controls (up, down, left, right, and a **Select** or **OK** button), otherwise
    returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEYBOARD_NUMPAD_ORIENTATION` | If the device has a numeric keypad, this
    property will return the orientation of the keypad relative to how the user is
    holding the device (if this is possible to detect). |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEYBOARD_GET_CHAR` | Returns `1` if the device supports the character
    code input method or `0` if it does not. |'
  prefs: []
  type: TYPE_TB
- en: 'The final value in this table can also be used with the function `s3eKeyboardSetInt`
    to show and hide the virtual keyboard on Android and iOS devices, which will then
    allow us to use the character code input method on these types of devices. The
    following function call will display the virtual keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To hide the virtual keyboard, pass in `0` instead of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Given that this feature is limited to just Android and iOS, and there is no
    way of determining whether the functionality is supported at runtime, this approach
    is probably best avoided if you intend to support a wide range of devices.
  prefs: []
  type: TYPE_NORMAL
- en: In order for our program to keep receiving updates on key presses, we must call
    the function `s3eKeyboardUpdate` in our code, once per game frame. The s3eKeyboard
    API keeps its own internal cache of the current key press states, which is updated
    when calling this function; so if we don't call `s3eKeyboardUpdate` frequently,
    we risk missing key press events.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting key state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most useful method of key detection for most arcade style games is to be
    able to discover the up or down state of any key on the device. The s3eKeyboard
    API provides two ways in which we can do this, these being polling the current
    key state and by registering a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting key state changes using polling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll start with the simplest approach of polling for the current state of a
    key. It may be the simplest approach, but in most cases it is also the best approach
    as far as game coding is concerned, since often all we want to know is whether
    a key is currently pressed or released so that we can update our game state accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect the current state of any key on our device we make a call to `s3eKeyboardGetState`,
    which takes a value from the `s3eKey` enumeration (take a look at the `s3eKeyboard.h`
    file for a full list, but you can normally guess the name of the enumeration fairly
    easily—for example, `s3eKeyUp` is the up arrow key, `s3eKey4` is the number *4*
    key, and so on) to identify the key we are interested in. The function returns
    an integer value that is a bit mask representing the current state of that key.
    The following key states can be detected by performing a bitwise AND operation
    on the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit mask name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEY_STATE_DOWN` | The key is currently being held down. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEY_STATE_PRESSED` | The key went from being up to down in the last
    call to `s3eKeyboardUpdate`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_KEY_STATE_RELEASED` | The key went from being down to up in the last
    call to `s3eKeyboardUpdate`. |'
  prefs: []
  type: TYPE_TB
- en: If the value returned from the function is zero, then the key can be assumed
    to currently be in the up position (that is, not being held) and has not just
    been released either.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we would detect whether the number *3*
    key has just been pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Detecting key state changes using callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to be informed whenever a key is pressed or released by
    using a callback function. Callbacks are preferred by many coders since they force
    us into writing smaller, more manageable functions that often yield a more concise
    and reusable solution. The polled approach to key detection may seem easier at
    first glance but it is easy to end up with a codebase that has key state checking
    logic spread across many source files. Using the callback approach will tend to
    ensure key handling code is implemented in a more structured way.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a callback function that detects key state changes, we use the `s3eKeyboardRegister`
    function. We provide this function with the enumeration value `S3E_KEYBOARD_KEY_EVENT`
    to identify the type of callback we are setting up, a pointer to a function that
    will be the callback, and a void pointer that can be used to pass in our own custom
    data to the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: When a key is pressed or released, the function we specified will be called.
    The callback function is passed a pointer to an `s3eKeyboardEvent` structure,
    which details the key press or release and is also provided with the custom data
    pointer we specified when registering the callback.
  prefs: []
  type: TYPE_NORMAL
- en: When we no longer wish to receive key state notifications, we can call `s3eKeyboardUnRegister`
    to disable the callback mechanism. We just need to pass the `S3E_KEYBOARD_KEY_EVENT`
    enumeration and the pointer to our callback method to stop the callbacks from
    occurring any more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a code snippet to illustrate how we might detect state changes to the
    number *3* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The method of key press detection to be used is really down to project requirements
    and personal preference. Since a call to `s3eKeyboardUpdate` will cache the state
    of every key for us, a polled approach may be best if we need to detect the current
    state of several keys at any time. A callback approach may be better if we just
    want to respond immediately to a key press and are less interested in tracking
    the key's state beyond this.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting character code input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The s3eKeyboard API also provides support for reading character codes from the
    keyboard. With this approach, we don't receive any notification of when a key
    was pressed or released. Instead, we receive a stream of character codes which
    automatically take into account any special modifier keys; so if a user pressed
    the *Shift* key, followed by the *A* key, then released both these keys, we would
    only receive the character code for a capital letter A.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is probably less useful for most games due to it not being an
    immediate form of notification, especially since fewer and fewer devices now feature
    physical keys that can be pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Not all devices support this input method, so you should use a call to `s3eKeyboardGetInt(S3E_KEYBOARD_GET_CHAR)`
    to determine if it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of completeness though, let us look at how we can receive character
    codes using either polling or callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting character code input using polling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out if a key that generates a character code has been pressed, all
    we have to do is call the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `s3eWChar` type is just an alternate type definition for the standard C++
    type `wchar_t`, a wide character. While this type can vary in size, it is assumed
    to be a 16-bit value in Marmalade. When a key is pressed, its character code will
    be added to the back of a queue. Calling this function will return the character
    to the front of the queue, or `S3E_WEOF` if the queue is empty. We often call
    this function in a loop in order to try and keep the queue empty and not risk
    losing key presses.
  prefs: []
  type: TYPE_NORMAL
- en: The character codes returned will depend on the device you are running on, but
    in most cases the standard alphabet A through Z, numbers, and punctuation characters
    will be ASCII codes, just stored in a 16-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting character code input using callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the callback method of receiving character codes takes the same approach
    as the callback method for receiving key state changes.
  prefs: []
  type: TYPE_NORMAL
- en: We again use `s3eKeyboardRegister` and `s3eKeyboardUnRegister` to start and
    stop notifications from occurring, but we use the enumeration value `S3E_KEYBOARD_CHAR_EVENT`
    to indicate that it is a character code event we want to receive.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function we provide will now be sent a pointer to an `s3eKeyboardCharEvent`
    structure that contains a single member of type `s3eWChar` named `m_Char`. This
    member will contain the character code that was generated by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Character code input is really only recommended if you are running on a device
    with a physical keyboard, as using virtual keyboards on touch screen devices can
    be unreliable with many key presses going unnoticed, particularly when characters
    outside the normal ASCII character set are entered (for example, Chinese or Japanese
    text entry).
  prefs: []
  type: TYPE_NORMAL
- en: Inputting strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already seen how we can use the s3eKeyboard functionality to read character
    codes, but if we want to allow the user to enter a string and we don't mind our
    program forsaking its own user interface in favor of a standard modal string entry
    dialog, then we have a shortcut available to us.
  prefs: []
  type: TYPE_NORMAL
- en: The `s3eOSReadString` API makes string entry really simple; but it is not actually
    supported on every platform. To use this API we include the file `s3eOSReadString.h`,
    and then make a call to the function `s3eOSReadStringAvailable` to see if string
    entry functionality is available for use.
  prefs: []
  type: TYPE_NORMAL
- en: If we are able to use the API, then we have two functions at our disposal. The
    first is `s3eOSReadStringUTF8`, which will display a string entry dialog and return
    a UTF-8 encoded string as a `const char` pointer. The second method is `s3eOSReadStringUTF8WithDefault`,
    which allows us to also specify a UTF-8 string that will be used to populate the
    string dialog when it appears.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UTF-8 is a widely used character format that allows full multilingual character
    support. It is often used when memory concerns are foremost, as single-byte characters
    such as the standard ASCII character set can still be represented in a single
    byte. Characters from outside the ASCII set (for example, Japanese Kanji) are
    encoded with two, three, or more bytes of information. One big advantage of UTF-8
    is that you can continue to use null-terminated strings since it is guaranteed
    that a zero byte will never form part of a valid character code.
  prefs: []
  type: TYPE_NORMAL
- en: Both functions otherwise work in the same way. They both return a pointer to
    the string entered by the user (the API will take care of freeing this memory),
    or NULL if the user canceled the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'They both also take an optional last parameter that can customize the layout
    of the string entry dialog. If the parameter is omitted or the value zero is passed,
    no restrictions are applied. The following table shows the other values that can
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_OSREADSTRING_FLAG_EMAIL` | Indicates that we are expecting an e-mail
    address to be entered. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_OSREADSTRING_FLAG_NUMBER` | Indicates that we are expecting a numeric
    value to be entered. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_OSREADSTRING_FLAG_PASSWORD` | Indicates that the application will use
    the OS method for entering a password, possibly hiding characters as they are
    entered. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_OSREADSTRING_FLAG_URL` | Indicates that we are expecting a URL to be
    entered. |'
  prefs: []
  type: TYPE_TB
- en: When using these functions in an application, it is possible that the user may
    enter characters that we are then unable to process or display; this should be
    kept in mind, as generic string input may not always be a good choice (for example,
    you may be unable to display every possible character that can be entered using
    your game's font!).
  prefs: []
  type: TYPE_NORMAL
- en: Using this API will also likely break the look and feel of the game as its super
    whizzy UI is suddenly overlaid or replaced by a drab and boring system dialog.
  prefs: []
  type: TYPE_NORMAL
- en: These reasons, combined with the fact that it is not supported by all platforms,
    may mean that it is a better decision to implement our own in-game string entry
    routines. That being said, it is still a useful API to know about, if only for
    debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting touch screen and pointer input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There aren't many devices released these days that don't feature a touch screen.
    Most new devices have adopted this as the primary input method and have dropped
    physical buttons almost entirely.
  prefs: []
  type: TYPE_NORMAL
- en: In Marmalade we detect touch screen events using the **s3ePointer** API, which
    I have to admit is perhaps not the most obvious name for an API that handles touch
    screen input. To use this API in our own program we just need to include the `s3ePointer.h`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this slightly bizarre naming is that when this API was first
    developed, touch screens were not commonplace. Instead, some devices had little
    joystick-style nubs that were able to move a pointer around the screen, much like
    a mouse on a computer.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that touch screen input is primarily concerned with a screen
    coordinate and that it was unlikely that a device would arrive that had both touch
    screen and pointer inputs, the Marmalade SDK simply adapted the existing s3ePointer
    API to accommodate touch screens as well, since your finger or stylus is effectively
    a pointer anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this chapter, whenever we talk about a position being "pointed
    at", we mean either an on-screen cursor has been moved to that position or a touch
    screen has had a contact made at that position. Positions are always returned
    as pixel positions relative to the top-left corner of the screen, as shown in
    the following diagram that shows what to expect on a device with a portrait HVGA
    screen size, such as a non-retina display iPhone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting touch screen and pointer input](img/3363_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following sections, we will learn how to discover the capabilities available
    for use on the device we are running on and how to handle both single and multi-touch
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: Determining available pointer functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the function `s3ePointerGetInt` to determine the properties of the hardware
    we are running on. We pass in one of the values in the following table, and we
    can then use the result to tailor our input methodology accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_AVAILABLE` | Returns `1` if we can use the s3ePointer API on
    the device, or `0` if we can''t. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_HIDE_CURSOR` | If the system has some kind of mouse pointer-like
    cursor displayed on screen, this property will return 1 if the pointer is currently
    visible, otherwise it returns `0`. This property can also be used in the `s3ePointerSetInt`
    function to show and hide the cursor. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_TYPE` | This will return the type of pointer we have at our
    disposal. See the next sub-section for more information on this. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_STYLUS_TYPE` | This will return the type of stylus our device
    uses. See the next sub-section for more information on this. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_MULTI_TOUCH_AVAILABLE` | If the device supports multi-touch
    (being able to detect more than one press on the touch screen at a time) the value
    `1` will be returned. Single touch devices will return `0`. |'
  prefs: []
  type: TYPE_TB
- en: For most game code, it is usually enough to first use the `S3E_POINTER_AVAILABLE`
    property to see if we have pointer capability available and the `S3E_POINTER_MULTI_TOUCH_AVAILABLE`
    property to configure our input methodology appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the type of pointer input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When supplying the property type `S3E_POINTER_TYPE` to `s3ePointerGetInt`, the
    return value is one from the `s3ePointerType` enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: '| Return Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_TYPE_INVALID` | Invalid request. The most likely cause is that
    the s3ePointer API is not available on this device. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_TYPE_MOUSE` | Pointer input is coming from a device that features
    an on-screen cursor to indicate position. The cursor may be controlled by a mouse
    or some other input device, such as a joystick. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_TYPE_STYLUS` | Pointer input is from a stylus-based input method,
    most likely a touch screen of some sort. |'
  prefs: []
  type: TYPE_TB
- en: In the majority of cases this distinction is not normally that important, but
    it might be relevant if you need to track the movement of the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: With a mouse, our code will receive events whenever the pointer is moved across
    the screen, whether a mouse button is held or not. On a touch screen, we will
    obviously only receive movement events when the screen is being touched.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is most notable when running on the simulator, as we will receive pointer
    events whenever the mouse pointer is moved within the bounds of the simulator
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the type of stylus input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we use `s3ePointerGetInt` with the property `S3E_POINTER_TYPE` and get the
    return type `S3E_POINTER_TYPE_STYLUS`, we can interrogate a little further to
    find out what type of stylus we will be using by calling `s3ePointerGetInt` again
    with the property `S3E_POINTER_STYLUS_TYPE`. The return values possible are in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Return Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_STYLUS_TYPE_INVALID` | Call was invalid; most likely because we are
    not running on a hardware that uses a stylus. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_STYLUS_TYPE_STYLUS` | Inputs are made by touching a stylus to the input
    surface. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_STYLUS_TYPE_FINGER` | Inputs are made by touching a finger to the input
    surface. |'
  prefs: []
  type: TYPE_TB
- en: This is probably not a distinction that we will need to worry about in most
    cases, but it might be useful to know so that games can be made more forgiving
    about inputs when they are made with a finger, since a stylus has a much smaller
    contact surface and should therefore allow for a far more accurate input.
  prefs: []
  type: TYPE_NORMAL
- en: Updating current pointer input status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to keep the s3ePointer API up-to-date with current touch screen inputs,
    it is necessary to call the `s3ePointerUpdate` function once per frame. This will
    update the cache of the current pointer status that is maintained within the s3ePointer
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting single touch input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the s3ePointer API is available on our device, we are guaranteed to be able
    to detect and respond to the user touching the screen and moving their stylus
    or finger about, or moving an on-screen cursor around and pressing some kind of
    selection button.
  prefs: []
  type: TYPE_NORMAL
- en: Even if our hardware supports multi-touch, we can still make use of single touch
    input if our game has no need to know about multiple simultaneous touch points.
    This may make it a little simpler to code our game, as we don't need to worry
    about issues such as two buttons on our user interface being pressed at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: As with key input, we can choose to use either a polled or callback-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting single touch input using polling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can determine the current on-screen position being pointed at (either by
    the on-screen cursor or a touch on the screen) by using the `s3ePointerGetX` and
    `s3ePointerGetY` functions, which will return the current horizontal and vertical
    pixel positions being pointed at.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a touch screen, the current position returned by these functions
    will be the last known position pointed at if the user is not currently making
    an input. The default value before any touches have been made will be (0,0)—the
    top-left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether an input is currently in progress, we can use the function
    `s3ePointerGetState`, which takes an element from the `s3ePointerButton` enumeration
    and returns a value from the `s3ePointerState` enumeration. The following table
    shows the values that make up the `s3ePointerButton` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_BUTTON_SELECT` | Returns the status of either the left mouse
    button or a touch screen tap. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_BUTTON_LEFTMOUSE` | An alternative name for `S3E_POINTER_BUTTON_SELECT`,
    which you may prefer to use if detecting other mouse buttons as well. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_BUTTON_RIGHTMOUSE` | Returns the status of the right mouse button.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_BUTTON_MIDDLEMOUSE` | Returns the status of the middle mouse
    button. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_BUTTON_MOUSEWHEELUP` | Used to determine if the user has scrolled
    the mouse wheel upwards. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_BUTTON_MOUSEWHEELDOWN` | Used to determine if the user has scrolled
    the mouse wheel downwards. |'
  prefs: []
  type: TYPE_TB
- en: 'The next table shows the members of the `s3ePointerState` enumeration, which
    indicate the current status of the requested pointer button or touch screen tap:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_STATE_UP` | The button is not depressed or contact is not currently
    made with the touch screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_STATE_DOWN` | The button is being held down or contact has been
    made with the touch screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_STATE_PRESSED` | The button or touch screen has just been pressed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_STATE_RELEASED` | The button or touch screen has just been released.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_POINTER_STATE_UNKNOWN` | Current status of this button is not known.
    For example, the middle mouse button status was requested but there is no middle
    mouse button present on the hardware. |'
  prefs: []
  type: TYPE_TB
- en: With this information we now have the ability to track the pointer or touch
    screen position and determine when the user has touched or released the touch
    screen or pressed a mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting single touch input using callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to keep track of pointer events using a callback-based system.
    For single touch input, there are two event types that we can register callback
    functions for; these are button and motion events.
  prefs: []
  type: TYPE_NORMAL
- en: We can start receiving pointer events by calling the `s3ePointerRegister` function,
    and we can stop them by calling `s3ePointerUnRegister`. Both functions take a
    value to identify the type of event we are concerned with, and a pointer to a
    callback function.
  prefs: []
  type: TYPE_NORMAL
- en: When registering a callback function, we can also provide a pointer to our own
    custom data structure that will be passed into the callback function whenever
    an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can register a callback function that
    will be executed whenever the touch screen or a mouse button is pressed or released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The button event callback's first parameter is a pointer to an `s3ePointerEvent`
    structure that contains four members. The button that was pressed is stored in
    a member called `m_Button` that is of the type `s3ePointerButton` (see the table
    in the *Detecting single touch input using polling* section earlier in this chapter
    for more details on this enumerated type).
  prefs: []
  type: TYPE_NORMAL
- en: The `m_Pressed` member will be `0` if the button was released and `1` if it
    was pressed. You might expect this to be of type `bool` rather than an integer
    but it isn't, because this is a C-based API, not C++-based and `bool` is not a
    part of the standard C language.
  prefs: []
  type: TYPE_NORMAL
- en: We can also discover the screen position where the event occurred by using the
    structure's `m_x` and `m_y` members.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to register a callback that will inform us when the user
    has performed a pointer motion. We again use the `s3ePointerRegister`/`s3ePointerUnRegister`
    functions, but this time use `S3E_POINTER_MOTION_EVENT` as the callback type.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function we register will be passed a pointer to an `s3ePointerMotionEvent`
    structure that consists of just `m_x` and `m_y` members containing the screen
    coordinate that is now being pointed at.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting multi-touch input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A multi-touch capable display allows us to detect more than one touched point
    on the screen at a time. Every time the screen is touched, the device's OS will
    assign that touch point an ID number. As the user moves their finger around the
    screen, the coordinates associated with that ID number will be updated until the
    user removes their finger from the screen, whereupon that touch will become inactive
    and the ID number becomes invalid.
  prefs: []
  type: TYPE_NORMAL
- en: While Marmalade does provide a polling-based approach to handling multi-touch
    events, the callback approach is possibly the better choice as it leads to slightly
    more elegant code and is a little more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting multi-touch input using polling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Marmalade provides us with a set of functions to allow multi-touch detection.
    The functions `s3ePointerGetTouchState`, `s3ePointerGetTouchX`, and `s3ePointerGetTouchY`
    are equivalent to the single touch functions `s3ePointerGetState`, `s3ePointerGetX`,
    and `s3ePointerGetY`, except that the multi-touch versions take a single parameter—the
    touch ID number.
  prefs: []
  type: TYPE_NORMAL
- en: The s3ePointer API also declares a preprocessor define `S3E_POINTER_TOUCH_MAX`
    that indicates the maximum possible value for the touch ID number (plus one!).
    As the user touches and releases the display, the touch ID numbers will be re-used.
    It is important to bear this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a loop that will allow us to process the currently
    active touch points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The biggest issue with this approach is that Marmalade never sends us an explicit
    notification that a touch event has just occurred. The `s3ePointerGetTouchState`
    function never returns `S3E_POINTER_STATE_PRESSED`, so instead we need to keep
    track of all touch IDs we have seen active so far when handling `S3E_POINTER_STATE_DOWN`.
    If a new touch ID is seen, we have detected the just-pressed condition.
  prefs: []
  type: TYPE_NORMAL
- en: While this code will work, I hope you will find that the callback-based approach
    that we are about to consider leads to a slightly more elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-touch input using callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the polling approach, multi-touch detection using callbacks is almost
    exactly the same as the single touch callback method. We still use `s3ePointerRegister`
    and `s3ePointerUnRegister` to start and stop events being sent to our code, but
    instead we use `S3E_POINTER_TOUCH_EVENT` to receive notifications of the user
    pressing or releasing the screen, and `S3E_POINTER_TOUCH_MOTION_EVENT` to find
    out when the user has dragged their finger across the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function registered to `S3E_POINTER_TOUCH_EVENT` will be sent a
    pointer to an `s3ePointerTouchEvent` structure. This structure contains the screen
    coordinates where the event occurred (the `m_x` and `m_y` members), whether the
    screen was touched or released (the `m_Pressed` member, which will be set to `1`
    if the screen was touched), and most importantly the ID number for this touch
    event (the `m_TouchID` member), which we can use to keep track of this touch as
    the user moves their finger around the display.
  prefs: []
  type: TYPE_NORMAL
- en: The `S3E_POINTER_TOUCH_MOTION_EVENT` callback will receive a pointer to an `s3ePointerTouchMotionEvent`
    structure. This structure contains the ID number of the touch event that has been
    updated and the new screen coordinate values. These structure members have the
    same names as their equivalent members in the `s3ePointerTouchEvent` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Marmalade provides us with no way of adjusting the frequency of touch events.
    Instead, it is really just dependant on how often the underlying operating system
    code dispatches such events.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully you can see that the callback-based method is a little neater than
    the polled method. Firstly, we can say goodbye to the truly nasty loop needed
    in the polled method to detect all currently active touches.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, with careful coding we can use the same code path to handle both single
    and multi-touch input. If we code first for multi-touch input, then making single
    touch work is simply a case of adding a fake touch ID to incoming single touch
    events and passing them through to the multi-touch code.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing gesture inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arrival of the touch screen to mobile devices brought with it a new set
    of terminology related to making inputs to our programs. For years we have been
    using a mouse, clicking and dragging to interact with programs, and now with touch
    screens we have quickly become comfortable with the idea of swiping and pinching.
  prefs: []
  type: TYPE_NORMAL
- en: These methods of interaction have become known as **gestures** and users have
    become so used to them now that if your application doesn't respond as they expect,
    they may get quickly frustrated with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Marmalade does not provide any support for detecting these gestures,
    so instead we have to code for them ourselves. The following sections aim to provide
    some guidance on how to easily detect both swipes and pinches.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a swipe gesture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A swipe occurs when the user touches the screen and then slides that touch point
    quickly across the screen before releasing the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To detect a swipe we must therefore first keep track of the screen coordinates
    where the user touched the screen and the time at which this occurred. When this
    touch event comes to an end due to the user releasing the screen, we first check
    the time it lasted for. If the length of time is not too long (say less than a
    quarter of a second), we check the distance between the start and end points.
    If this distance is large enough (perhaps a hundred pixels in length, or a fraction
    of the screen display size), then we have detected a swipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often we only want to respond to a swipe if it is in a certain direction. We
    can determine this by using the dot product, the formula for which is shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting a swipe gesture](img/3363_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dot product is calculated by multiplying the x and y components of the two
    vectors together and summing the results, or by multiplying the length of the
    two vectors together and then multiplying by the cosine of the angle between the
    two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the user's swipe lies in a particular direction, we first make the
    direction of the swipe into a unit vector, then dot product this with a unit vector
    in the desired swipe direction. By using unit vectors we reduce the formula on
    the left-hand side of the previous diagram to just the cosine of the angle between
    the vectors, so it is now very simple to see if our swipe lies along the desired
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: If the dot product value is very close to 1, then our two direction vectors
    are close to being parallel, since *cos(0°) = 1*, and we've detected a swipe in
    the required direction. Similarly, if the dot product is close to -1, we've detected
    a swipe in the opposite direction, as *cos(180°) = -1*.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a pinch gesture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pinch gestures can only be used on devices featuring multi-touch displays, since
    they require two simultaneous touch points. A pinch gesture is often used to allow
    zooming in and out to occur and is performed by placing two fingers on the screen
    and then moving them together or apart. This is most easily achieved using the
    thumb and index finger.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a pinch gesture in code is actually quite simple. As soon as we have
    detected two touch points on the screen, we calculate a vector from one point
    to the other and find the distance of this vector. This is stored as the initial
    distance and will represent no zooming.
  prefs: []
  type: TYPE_NORMAL
- en: As the user moves their fingers around the screen, we just keep calculating
    the new distance between the two touch points, and then divide this distance by
    the original distance. The end result of this calculation is a zoom scale factor.
    If the user moves their fingers together, the zoom factor will be less than one;
    if they move them apart, the zoom value will be greater than one.
  prefs: []
  type: TYPE_NORMAL
- en: The pinch gesture is complete once the user removes at least one finger from
    the display.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting accelerometer input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final input method we will be considering in this chapter is the **accelerometer**,
    which allows us to detect the orientation that the user is currently holding the
    device at. An accelerometer is a sensor that can measure the forces applied to
    a device, be they static forces such as gravity, or dynamic forces generated by
    waving the device around.
  prefs: []
  type: TYPE_NORMAL
- en: Most devices will have three accelerometers aligned perpendicularly to each
    other, as shown in the following diagram. This configuration allows us to discover
    exactly how the user is holding the device at any time and so provides a method
    of controlling our game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting accelerometer input](img/3363_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The directions of the arrows in the previous diagram show the directions in
    which acceleration will yield a positive value. This means that if you hold the
    device level with the display upwards in front of you, tipping it to the right
    will yield a positive value on the x axis accelerometer, tipping it away from
    you will generate positive y axis values and moving the device vertically upwards
    will generate a positive z axis value.
  prefs: []
  type: TYPE_NORMAL
- en: The Marmalade SDK provides us with access to the accelerometers of a device
    using the s3eAccelerometer API, which we can use in our code by including the
    `s3eAccelerometer.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping accelerometer input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before attempting to use the accelerometer in our program, we must first check
    to see if accelerometer input is available on our device. If support is available,
    then we can start receiving accelerometer input. We do this with the following
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we have finished using the accelerometers, we just make a call to `s3eAccelerometerStop`
    and we will receive no further inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is good practice on mobile devices to ensure that we only enable parts of
    the hardware when we are actually using them, since this helps to conserve battery
    power. In the case of accelerometers, the power use is probably so small that
    it is insignificant, but this is an area of mobile game programming that is always
    worth keeping in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Reading accelerometer input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding the current accelerometer input values is really very simple. Marmalade
    provides three functions which return the current accelerometer value for each
    axis. These functions are called `s3eAccelerometerGetX`, `s3eAccelerometerGetY`,
    and `s3eAccelerometerGetZ`. Unsurprisingly, they return the current value of the
    accelerometer for the specified axis.
  prefs: []
  type: TYPE_NORMAL
- en: The values returned by these functions use a value of 1000 (though we should
    use the handy definition `S3E_ACCELEROMETER_1G` to avoid magic numbers in our
    code!) to represent an acceleration equivalent to normal Earth gravity.
  prefs: []
  type: TYPE_NORMAL
- en: When a sharp, quick movement is made to the device, the forces being applied
    to it will be greater than the normal gravitational force. In this case, the magnitude
    of the vector formed from the accelerometer values will be greater than `S3E_ACCELEROMETER_1G`.
    This can be a useful way of detecting whether the user has been shaking the device.
  prefs: []
  type: TYPE_NORMAL
- en: If the device were to be horizontally on a table, we should get a value of `0`
    returned for both the X and Y axes, and `-1000` for the z axis, since gravity
    acts downwards! As we rotate the device, the values returned will form a vector
    showing the direction in which gravity is acting, and we can then use this to
    determine the orientation of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Using some trigonometry, we can work out the angle of tip around the x axis
    (forward/backward) and Y-axis (left/right). The angle around the X-axis can be
    found by taking the arc tan of the Y-accelerometer value divided by the Z value.
  prefs: []
  type: TYPE_NORMAL
- en: The angle around the y axis is a little trickier. First we have to find the
    length of the accelerometer vector projected onto the YZ plane, then we can find
    the arc tan of the X-accelerometer value divided by the projected length.
  prefs: []
  type: TYPE_NORMAL
- en: If all this sounds like too much scary math, the following code snippet does
    it all for us. Note than when calculating the rotation around the x axis using
    the `IwGeomAtan2` function, we negate both the Y- and Z-accelerometer values in
    order to yield a more usable result range, with 0 degrees returned when the device
    is level and increasing values when tipped away from the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Smoothing accelerometer input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One problem we will encounter when using the accelerometer for input is that
    the values returned from it tend to be a bit "jumpy". Even the steadiest hand
    will be unable to hold the device still enough to see a steady value being returned
    from the accelerometer. This can cause your game to register movements when you
    don't want it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common approach for solving this problem is to smooth the accelerometer values
    by combining the current readings with the previous readings. The easiest way
    of doing this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The variables `accX`, `accY`, and `accZ` are the smoothed accelerometer values
    that we will use in our program for input. The `lSmoothFactor` value determines
    how much smoothing we are applying to the inputs. If it is set to `IW_GEOM_ONE`,
    no smoothing will be applied and the results will be exactly what is coming in
    from the accelerometers.
  prefs: []
  type: TYPE_NORMAL
- en: Lower values for the smoothing factor will generate less jittery input values,
    but this will be at the expense of adding a certain amount of lag to the inputs.
    The degree of lag depends on how often the smoothing code is executed, which in
    turn depends on the frame rate of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Working out a good value to use for the smoothing factor is really just a case
    of trial and error. You just need to keep tweaking the value until you achieve
    a suitable result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`IW_FIXED_MUL` is a useful function provided by Marmalade for doing fixed point
    multiplication where `IW_GEOM_ONE` (4096) is equivalent to one. It multiplies
    the two parameters together and then shifts the result back down to be in the
    correct range.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing accelerometer input on the Windows simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that computers don't tend to feature accelerometer inputs of any kind,
    testing this form of input in the Windows simulator may appear to be impossible.
    Fortunately, Marmalade does provide us with a way of doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running an application in the simulator, select the menu item **Configuration**
    | **Accelerometer…** and a window showing a small 3D representation of a mobile
    device will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing accelerometer input on the Windows simulator](img/3363_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By clicking and dragging on this virtual device, we can alter the accelerometer
    inputs being fed into the simulator. It's a little tricky to use for playing a
    game but it normally suffices, so you can at least test applications that rely
    solely on accelerometer inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The window also provides some edit boxes that show the current values of the
    accelerometer inputs as you rotate the 3D device about. These can also be used
    to enter exact values should you have need to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code package for this chapter contains three projects that demonstrate the
    things we've learnt in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Gesture project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project demonstrates the use of the s3ePointer API by showing the screen
    coordinates pointed at by the user. If a multi-touch display is available, it
    will show multiple touch points.
  prefs: []
  type: TYPE_NORMAL
- en: The project also demonstrates a simple approach for detecting swipes and pinches
    and how it is possible to use the same gesture detection code with both single-
    and multi-touch capable displays.
  prefs: []
  type: TYPE_NORMAL
- en: The Slide project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Slide project shows how to use the s3eAccelerometer API to read the current
    accelerometer values, apply a smoothing algorithm to them, and generate the angles
    of tip around the X- and Y-axes.
  prefs: []
  type: TYPE_NORMAL
- en: It also demonstrates something a little more game-like by allowing you to move
    a little red box around the screen by tipping the device.
  prefs: []
  type: TYPE_NORMAL
- en: The Skiing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our skiing game becomes interactive in this chapter, allowing you to rotate
    the skier left and right and have him move across the screen and affect the speed
    of scrolling. The skier can be controlled either by key presses and touch screen
    or accelerometer input.
  prefs: []
  type: TYPE_NORMAL
- en: We also have more of a game-like flow with the addition of a title screen mode
    that allows the input method to be selected, and a game over mode, which is triggered
    when the player goes into the trees at the edge of the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections highlight some of the new classes added to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Player rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rotation of the player has been achieved by including a number of different
    animation frames, each showing the player at a different angle of rotation. This
    makes it easy to slot into our existing `GameObject` code, which expects to draw
    a square image that is not rotated.
  prefs: []
  type: TYPE_NORMAL
- en: While this solution is very simple, it is perhaps not the best option. We could
    instead have extended `GameObject` to support rotated images, which would have
    both saved memory (we would not have needed to store all the extra animation frames)
    and yielded smoother rotation results, as the skier currently steps between frames
    at 10-degree rotation increments.
  prefs: []
  type: TYPE_NORMAL
- en: The ModeTitle and ModeGameOver classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These classes implement the title screen and game over modes of the game. These
    have been added to make the project feel a little more like a game, although they
    are very basic to look at.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, these classes show how we can switch between game modes by
    making them active and visible. Take particular note of the `ModeGameOver` class,
    which stops the normal game mode from updating, but still allows it to render
    so we can see the game world along with the game over message.
  prefs: []
  type: TYPE_NORMAL
- en: The Camera class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Camera` class has been added to the project to allow us to specify a viewing
    point in the world. When rendering, we now use the camera position as the origin's
    location on the screen. So when we move the camera, the entire screen display
    will move relative to it. This makes it possible to do a horizontal scrolling
    effect without having to update the x coordinate of everything in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for making this change is to make our life easier when we upgrade
    the game to use 3D models in the next chapter, since this is closer to the way
    3D graphics are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The Input Manager classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Three new singleton classes have also been added to the project to make access
    to key, touch screen, and accelerometer inputs a little tidier. They are called
    `KeyManager`, `TouchManager`, and `AccelerometerManager` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: These classes wrap the functionality provided by Marmalade into a simpler interface,
    which makes our game code easier to read. It also means that we can make changes
    to the inputs at a later date without having to change the game code. For example,
    the `KeyManager` class provides methods to indicate if the left or right arrow
    keys have been held. If we want to remap those keys or provide alternate possible
    keys, we can do so in the `KeyManager` code and our game code will work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: The SkierController class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to add a layer of abstraction between the `Skier` class and the various
    input managers, the `SkierController` class has been added. This class provides
    a "steering" value, which is an integer number ranging from—`IW_GEOM_ONE` to +`IW_GEOM_ONE`
    that indicates how much the user is attempting to steer left (a negative value)
    or right (a positive value). The `Skier` class can just use this value to rotate
    the skier without needing to consider how this value is derived.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the `SkierController` class generates the steering value using the
    selected input method from the title screen.
  prefs: []
  type: TYPE_NORMAL
- en: For keyboard input, the left and right arrow keys modify the current steering
    value a little bit each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Touch screen input uses the horizontal position of the player's finger on the
    screen to generate the value; so it is -1 when the player is touching the left-hand
    side of the screen and +1 when they are touching the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, accelerometer input just scales the x axis accelerometer value into
    the required range.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered how to make our programs interactive by detecting
    key and touch screen presses and by using the accelerometers of modern mobile
    devices. We've also seen how we can build on the basic functionality provided
    in order to detect swipe and pinch gestures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be returning to things more graphical by showing
    how we can use Marmalade to render 3D graphics in our games.
  prefs: []
  type: TYPE_NORMAL
