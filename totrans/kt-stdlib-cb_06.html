<html><head></head><body>
        

                            
                    <h1 class="header-title">Friendly I/O Operations</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Reading the contents of a file</li>
<li>Ensuring stream closing with the <kbd>use</kbd> function</li>
<li>Reading the contents of a file line by line</li>
<li>Writing the contents to a file</li>
<li>Appending a file</li>
<li>Easy files copying</li>
<li>Traversing files in a directory</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p class="p1">This chapter focuses on explaining the Kotlin approach to working with JVM  <kbd>File</kbd>, <kbd>InputStream</kbd>, and <kbd>OutputStream</kbd> types. We are going to explore the group of extension functions offered by the standard library under the <kbd>kotlin.io</kbd> package, which focus on enhancing support for I/O operations. Note that at the moment, with the Kotlin version 1.2, the following recipes are applicable only to code targeting the JVM platform. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the contents of a file</h1>
                
            
            
                
<p>In this recipe, we are going to retrieve the contents of a file as text and print it to the console. We are going to use the standard library <kbd>File.readText()</kbd> extension function, returning a <kbd>String</kbd> representing the text content of the given <kbd>File</kbd> instance. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">Make sure you have a sample non-empty file included in your project to read its contents. You can clone the sample project provided with the book's GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>. In this recipe, we are going to use the <kbd>file1.txt</kbd> file located in the <kbd>src/main/resources</kbd> directory in the sample project. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Import the <kbd>File.separator</kbd> constant and assign an alias to it:</li>
</ol>
<pre style="padding-left: 60px">import java.io.File.separator as SEPARATOR</pre>
<ol start="2">
<li>Declare a <kbd>String</kbd> storing a path to the file we are going to read:</li>
</ol>
<pre style="padding-left: 60px"><strong>val filePahtName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/></strong></pre>
<ol start="3">
<li>Instantiate a <kbd>File</kbd> using the specified path:</li>
</ol>
<pre style="padding-left: 60px">val filePahtName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/><strong>val file = File(filePahtName)</strong></pre>
<ol start="4">
<li>Read the text from the file and print it to the console:</li>
</ol>
<pre style="padding-left: 60px">val filePahtName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/>val file = File(filePahtName)<br/><strong>val fileText: String = file.readText()</strong><br/><strong>println(fileText)</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>readText()</kbd> extension function is returning the <kbd>String</kbd> value representing the text of the given file. This is a convenient way of reading the file contents since it wraps the low-level logic of reading bytes from the <kbd>FileInputStream</kbd> class. Under the hood, before reading the bytes of the file, the function checks whether the file has the proper size to be stored in memory.</p>
<p>Keep in mind that, if the file size is too large, <kbd>OutOfMemoryError</kbd> is thrown. Whenever the file is too big to be processed at once, you should access its content using <kbd>BufferedReader</kbd>. You can easily obtain the <kbd>BufferedReader</kbd> instance by calling the <kbd>File.bufferedReader()</kbd> extension function.</p>
<p>The <kbd>readText()</kbd> function can also take the <kbd>charset: Charset</kbd> argument, which by default is set to the <kbd>Charsets.UTF_8</kbd> value. If you'd like to use another <kbd>charset</kbd>, you can specify it by passing a proper one as the <kbd>charset</kbd> argument. You can find the available charset types inside the <kbd>kotlin.text.Charsets</kbd> object. You can also find them listed in the official documentation: <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets</a>.<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets"/></p>
<p>You may have noticed we are using the <kbd>File.separator</kbd> constant instead of the hardcoded <kbd>"/"</kbd> char. Thanks to that, we can be sure the correct directory-separating character will be used on different platforms. For the sake of brevity, you can import <kbd>File.separator</kbd> with an alias, for example <kbd>import java.io.File.separator as separator</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can also check out the <em>Reading the contents of a file line by line</em> recipe, which explains how to read the text content of a file line by line effectively</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Ensuring stream closing with the use function</h1>
                
            
            
                
<p>Whenever we are accessing the contents of a <kbd>File</kbd> via <kbd>FileInputStream</kbd> or <kbd>FileOutputStream</kbd>, we should remember to close them once we've finished working on the file. Unclosed streams may lead to memory leaks and a significant decrease in performance. In this recipe, we are going to explore how to employ the <kbd>use()</kbd> extension function offered by the standard library under the <kbd>kotlin.io</kbd> package for automatic stream closing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have a sample non-empty file included in your project to read its contents. You can clone the sample project provided with the book's GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>. In this recipe, we are going to use the <kbd>file1.txt</kbd> file located in the <kbd>src/main/resources</kbd> directory in the sample project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li> Import the <kbd>File.separator</kbd> constant and assign an alias to it:</li>
</ol>
<pre style="color: black;padding-left: 60px">import java.io.File.separator as SEPARATOR</pre>
<ol start="2">
<li>Declare a <kbd>String</kbd> storing a path to the file we are going to read:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>val filePahtName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/></strong></pre>
<ol start="3">
<li>Instantiate a <kbd>FileInputStream</kbd> for the <kbd>file1.txt</kbd> file:</li>
</ol>
<pre style="color: black;padding-left: 60px">val filePahtName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/><strong>val stream = File(filePahtName).inputStream()</strong></pre>
<ol start="4">
<li>Read the bytes from the stream inside the <kbd>use()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/>val stream = File(fileName).inputStream()<br/><strong>stream.use {<br/>    it.readBytes().also { println(String(it)) }<br/>}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, we create the <kbd>FileInputStream</kbd> instance using the <kbd>File.inputStream()</kbd> extension function. Next, we invoke the <kbd>use()</kbd> extension function on our stream instance, passing a lambda block containing operations we want to perform on the stream as the argument.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Under the hood, after invoking the lambda expression, the <kbd>use()</kbd> function calls the <kbd>close()</kbd> function on the stream variable. We can check that, when we try to access the file using the <kbd>stream</kbd> variable once again, we will get a <kbd>java.io.IOException: Stream Closed</kbd> exception thrown. </p>
<p>The <kbd>use()</kbd> function extends any type that implements the <kbd>Closeable</kbd> interface. It takes a lambda block as the argument, passing an instance of the closeable resource to the lambda as the parameter. The <kbd>use</kbd> function returns the value returned by the lambda block. Under the hood, there is a <kbd>try…catch</kbd> block being used where the <kbd>close()</kbd> function of the resource is invoked inside the <kbd>finally</kbd> block.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the contents of a file line by line</h1>
                
            
            
                
<p>In this recipe, we are going to retrieve the contents of a file as a set of consecutive text lines. We are going to use the standard library extension function, <kbd>File.readLines()</kbd>, to return a <kbd>List</kbd> of a <kbd>String</kbd> type representing the next lines of the given <kbd>File</kbd> instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have a sample non-empty file included in your project to read its contents. You can clone the sample project provided with the book at the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>. In this recipe, we are going to use the <kbd>file1.txt</kbd> file located in the <kbd>src/main/resources</kbd> directory in the sample project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Import the <kbd>File.separator</kbd> constant and assign an alias to it:</li>
</ol>
<pre style="padding-left: 60px">import java.io.File.separator as SEPARATOR</pre>
<ol start="2">
<li>Declare a <kbd>String</kbd> storing a path to the file we are going to read:</li>
</ol>
<pre style="padding-left: 60px"><strong>val filePahtName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/></strong></pre>
<ol start="3">
<li>Instantiate a <kbd>File</kbd> using the specified path:</li>
</ol>
<pre style="padding-left: 60px">val filePahtName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/><strong>val file = File(filePahtName)</strong></pre>
<ol start="4">
<li>Read the text from the file and print it to the console:</li>
</ol>
<pre style="padding-left: 60px">val filePathName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file1.txt"<br/>val file = File(fileName)<br/><strong>val fileLines = file.readLines()</strong><br/><strong>fileLines.forEach { println(it) }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>readLines()</kbd> extension function returns the <kbd>List&lt;String&gt;</kbd> instance representing the lines of text of the given file. This is a convenient way of reading the file contents since it wraps the low-level logic of reading bytes from the <kbd>FileInputStream</kbd> class.</p>
<p>Keep in mind that, if the file size is too large, <kbd>OutOfMemoryError</kbd> is thrown. Whenever the file is too big to be processed at once, you should access its content using <kbd>BufferedReader</kbd>. You can easily obtain the <kbd>BufferedReader</kbd> instance by calling the <kbd>File.bufferedReader()</kbd> extension function.</p>
<p>The <kbd>readLines()</kbd> function can also take the <kbd>charset: Charset</kbd> argument, which by default is set to the <kbd>Charsets.UTF_8</kbd> value. If you'd like to use another charset, you can specify it by passing a proper one as the <kbd>charset</kbd> argument. You can find the available charset types inside the <kbd>kotlin.text.Charsets</kbd> object. You can also find them listed in the official documentation: <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets</a>.</p>
<p>You may have noticed we are using the <kbd>File.separator</kbd> constant instead of the hardcoded <kbd>"/"</kbd> char. Thanks to that, we can be sure the correct directory-separating character will be used on different platforms. For the sake of brevity, you can import <kbd>File.separator</kbd> with an alias, for example <kbd>import java.io.File.separator as separator</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can also check out the <em>Reading the contents of a file</em> recipe, which explains how to retrieve the text contents of the file at once as the <kbd>String</kbd> value</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the contents to a file</h1>
                
            
            
                
<p>In this recipe, we are going to learn how to easily create a new <kbd>File</kbd> and write text to it. We are going to use the <kbd>File.writeText()</kbd> extension function offered by the standard library. Then, we are going to verify whether the file was successfully created and whether it contains the proper contents by printing it to the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Import the <kbd>File.separator</kbd> constant and assign an alias to it:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File.separator as SEPARATOR</pre>
<ol start="2">
<li>Specify the path to the new file we are going to create:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"</pre>
<ol start="3">
<li>Instantiate the file using the specified file path:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"<br/><strong>val file = File(fileName)</strong></pre>
<ol start="4">
<li>Write the text to the file using the <kbd>writeText()</kbd> function inside the <kbd>apply</kbd> block:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"<br/>val file = File(fileName)<br/><strong>file.apply {<br/>    val text =</strong><br/><strong>        "\"No one in the brief history of computing " +</strong><br/><strong>          "has ever written a piece of perfect software. " +</strong><br/><strong>          "It's unlikely that you'll be the first.\" - Andy Hunt"<br/></strong></pre>
<p class="mce-root"/>
<pre style="padding-left: 60px"><strong>    writeText(text) </strong><br/><strong>}</strong></pre>
<ol start="5">
<li>Print the contents of <kbd>temp_file</kbd> to the console:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"<br/>val file = File(fileName)<br/>file.apply {<br/>    val text =<br/>        "\"No one in the brief history of computing " +<br/>          "has ever written a piece of perfect software. " +<br/>          "It's unlikely that you'll be the first.\" - Andy Hunt"<br/>    writeText(text)<br/>}<br/><strong>file.readText().apply { println(this) }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As the result of executing the preceding code, a new <kbd>temp_file</kbd> file is going to be created under the <kbd>src/main/resources</kbd> directory. Keep in mind that in case the <kbd>temp_file</kbd> already exists it is going to be overridden. Next, with the help of the <kbd>writeText()</kbd> function its contents are going to be printed to the console:</p>
<pre><strong>"No one in the brief history of computing has ever written a piece of perfect software. It's unlikely that you'll be the first." - Andy Hunt</strong></pre>
<p>The <kbd>writeText()</kbd> function wraps the <kbd>java.io.FileOutputStream</kbd> API, providing a neat way of writing content to the file. Under the hood, it accesses <kbd>FileOutputStream</kbd> inside the <kbd>use()</kbd> function, so you can be sure that it autocloses any streams that are opened during the write operation.</p>
<p>If the text you want to write to the file is too large to be processed at once, you can use the <kbd>BufferedWriter</kbd> API to allow you to write and append the file. You can easily obtain an instance of <kbd>BufferedWriter</kbd> using the <kbd>File.bufferedWriter()</kbd> extension function.</p>
<p class="mce-root"/>
<p>You can also pass the additional <kbd>charset: Charset</kbd> argument to <kbd>writeText()</kbd>, which by default is equal to the <kbd>Charsets.UTF_8</kbd> value. If you'd like to use another charset, you can specify it by passing a proper one as the <kbd>charset</kbd> argument. You can find the available charset types inside the <kbd>kotlin.text.Charsets</kbd> object. You can also find them listed in the official documentation at <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Check out the <em>Appending a file</em> recipe to learn how to modify a file's content in a flexible way by appending it</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Appending a file</h1>
                
            
            
                
<p>In this recipe, we are going to learn how to easily create a new <kbd>File</kbd> and write text to it by appending its content a number of times. We are going to use the <kbd>File.appendText()</kbd> extension function offered by the standard library. Then, we are going to verify whether the file was successfully created and whether it contains the proper content by printing it to the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Import the <kbd>File.separator</kbd> constant and assign an alias to it:</li>
</ol>
<pre style="color: black;padding-left: 60px" class="mce-root">import java.io.File.separator as SEPARATOR</pre>
<ol start="2">
<li>Specify the path to the new file we are going to create:</li>
</ol>
<pre style="color: black;padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"</pre>
<ol start="3">
<li>Instantiate the file using the specified file path:</li>
</ol>
<pre style="color: black;padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"<br/><strong>val file = File(fileName)</strong></pre>
<ol start="4">
<li>Delete the file if it already exists:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"<br/>val file = File(fileName)<br/><strong>if (file.exists()) file.delete()</strong></pre>
<ol start="5">
<li>Append the file with the next String values:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"<br/>val file = File(fileName)<br/>if (file.exists()) file.delete()<br/><br/><strong>file.apply {<br/>    appendText("\"A language that doesn't affect the way you think ")</strong><br/><strong>    appendText("about programming ")</strong><br/><strong>    appendText("is worth knowing.\"")</strong><br/><strong>    appendText("\n")</strong><br/><strong>    appendBytes("Alan Perlis".toByteArray())</strong><br/><strong>}</strong></pre>
<ol start="6">
<li>Print the file's contents to the console:</li>
</ol>
<pre style="padding-left: 60px">val fileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}temp_file"<br/>val file = File(fileName)<br/>if (file.exists()) file.delete()<br/><br/>file.apply {<br/>    appendText("\"A language that doesn’t affect the way you think ")<br/>    appendText("about programming ")<br/>    appendText("is worth knowing.\"")<br/>    appendText("\n")<br/>    appendBytes("Alan Perlis".toByteArray())<br/>}<br/><br/><strong>file.readText().let { println(it) }</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As a result of executing the preceding code, a new <kbd>temp_file</kbd> file is going to be created under the <kbd>src/main/resources</kbd> directory, and its content is going to be printed out to the console:</p>
<pre><strong>"A language that doesn’t affect the way you think about programming is worth knowing."</strong><br/><strong>Alan Perlis</strong></pre>
<p>The <kbd>appendText()</kbd> and <kbd>appendBytes()</kbd> functions wrap the <kbd>java.io.FileOutputStream</kbd> API, providing a neat way of appending content to the file. Under the hood, they access <kbd>FileOutputStream</kbd> inside the <kbd>use()</kbd> function, so you can be sure that it autocloses any streams that are opened during the write operation. </p>
<p>If the text you want to write to the file is too large to be processed at once, you can use the <kbd>BufferedWriter</kbd> API, which allows you to write and append the file. You can easily obtain an instance of <kbd>BufferedWriter</kbd> using the <kbd>File.bufferedWriter()</kbd> extension function.</p>
<p>You can also pass the additional <kbd>charset: Charset</kbd> argument to the <kbd>appendText()</kbd> function, which by default is equal to the <kbd>Charsets.UTF_8</kbd> value. If you'd like to use another charset, you can specify it by passing a proper one as the <kbd>charset</kbd> argument. You can find the available charset types inside the <kbd>kotlin.text.Charsets</kbd> object. You can also find them listed in the official documentation at <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Easy file copying</h1>
                
            
            
                
<p>In this recipe, we are going to explore a neat way of copying a file's contents into a new file. We are going to obtain a sample <kbd>File</kbd> instance from the specified path and copy its content into the new file. Finally, we are going to print the contents of both files to the console to verify the operation.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have a sample non-empty file included in your project to read its contents. You can clone the sample project provided with the book at the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>. In this recipe, we are going to use the <kbd>file2.txt</kbd> file located in the <kbd>src/main/resources</kbd> directory in the sample project. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Import the <kbd>File.separator</kbd> constant and assign an alias to it:</li>
</ol>
<pre style="color: black;padding-left: 60px" class="mce-root">import java.io.File.separator as SEPARATOR</pre>
<ol start="2">
<li>Instantiate a <kbd>File</kbd> instance for the specified <kbd>file2.txt</kbd> path:</li>
</ol>
<pre style="padding-left: 60px"><strong>val sourceFileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2.txt"<br/>val sourceFile = File(sourceFileName)</strong></pre>
<ol start="3">
<li>Create a new <kbd>File</kbd> called <kbd>file2_copy.txt</kbd>:</li>
</ol>
<pre style="padding-left: 60px">val sourceFileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2.txt"<br/>val sourceFile = File(sourceFileName)<br/><br/><strong>val targetFileName =         "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2_copy.txt"<br/>val targetFile = File(targetFileName)</strong></pre>
<ol start="4">
<li>If <kbd>file2_copy.txt</kbd> exists, delete it:</li>
</ol>
<pre style="padding-left: 60px">val sourceFileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2.txt"<br/>val sourceFile = File(sourceFileName)<br/><br/>val targetFileName =     "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2_copy.txt"<br/>val targetFile = File(targetFileName)<br/><br/><strong>if (targetFile.exists()) targetFile.delete()</strong></pre>
<p class="mce-root"/>
<ol start="5">
<li>Copy the contents of <kbd>file2.txt</kbd> to the <kbd>file2_copy.txt</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">val sourceFileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2.txt"<br/>val sourceFile = File(sourceFileName)<br/><br/>val targetFileName =     "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2_copy.txt"<br/>val targetFile = File(targetFileName)<br/><br/>if (targetFile.exists()) targetFile.delete()<br/><br/><strong>sourceFile.copyTo(targetFile)</strong></pre>
<ol start="6">
<li>Print both files to the console for verification:</li>
</ol>
<pre style="padding-left: 60px">val sourceFileName = "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2.txt"<br/>val sourceFile = File(sourceFileName)<br/><br/>val targetFileName =     "src${SEPARATOR}main${SEPARATOR}resources${SEPARATOR}file2_copy.txt"<br/>val targetFile = File(targetFileName)<br/><br/>if (targetFile.exists()) targetFile.delete()<br/><br/>sourceFile.copyTo(targetFile)<br/><br/><strong>File(sourceFileName).readText().apply { println(this) }<br/>File(targetFileName).readText().apply { println(this) }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You can run the sample code to verify that, after invoking the <kbd>copyTo()</kbd> extension function, both files contain the same text content. In our case, we get the following output:</p>
<pre><strong>"Testing can show the presence of errors, but not their absence." - E. W. Dijkstra</strong><br/><strong>"Testing can show the presence of errors, but not their absence." - E. W. Dijkstra</strong></pre>
<p class="mce-root"/>
<p>Under the hood, the <kbd>copyTo()</kbd> function reads <kbd>InputStream</kbd> in the source file to the buffer and writes it to the <kbd>OutputStream</kbd> target file. Internally, streams are being accessed inside the <kbd>use()</kbd> function block, which closes them automatically after the operation finishes.</p>
<p>Apart from the target <kbd>File</kbd> instance, the <kbd>copyTo()</kbd> function takes two optional parameters—<kbd>overwrite: Boolean</kbd>, which is set to false by default, and <kbd>bufferSize: Int</kbd>, which is assigned to the default value. Keep in mind that, whenever some directories on a way to the target file are missing, they will be created. Also, if the target file already exists, the <kbd>copyTo()</kbd> function will fail, unless the override argument is set to <kbd>true</kbd>. </p>
<div><ul>
<li>When the <kbd>overwrite</kbd> parameter is set to <kbd>true</kbd> and <kbd>target</kbd> points to a directory, it will be replaced only if it is empty. </li>
<li>If you invoke <kbd>copyTo()</kbd> on a <kbd>File</kbd> instance that points to a directory, it will be copied without its content. Only an empty directory will be created under the target path. </li>
<li>The <kbd>copyTo()</kbd> function doesn't preserve copied file attributes, that is, the creation/modification date and permissions.</li>
</ul>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Traversing files in a directory</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to traverse files in a given directory. We are going to obtain a <kbd>FileTreeWalk</kbd> class instance from a given <kbd>File</kbd> pointing to the directory. We are going to iterate through all the files inside the given directory, including any nested subdirectories. We will also filter the files to exclude those without the <kbd>.txt</kbd> extension and print their paths and contents to the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have the sample files with the <kbd>.txt</kbd> extension included in your project. You can clone the sample project provided with the book at the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>. In this recipe, we are going to use the <kbd>src/main/resources</kbd> directory and its contents from the sample project.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Import the <kbd>File.separator</kbd> constant and assign an alias to it:</li>
</ol>
<pre style="color: black;padding-left: 60px" class="mce-root">import java.io.File.separator as SEPARATOR</pre>
<ol start="2">
<li>Obtain the <kbd>FileTreeWalk</kbd> instance from the <kbd>File</kbd> pointing to the <kbd>src/main/resources</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px">val directoryPath = "src${SEPARATOR}main${SEPARATOR}resources"<br/><strong>val fileTreeWalk: FileTreeWalk = File(directoryPath).walk()</strong></pre>
<ol start="3">
<li>Iterate through the all non-empty <kbd>.txt</kbd> files and print:</li>
</ol>
<pre style="padding-left: 60px">val directoryPath = "src${SEPARATOR}main${SEPARATOR}resources"<br/><br/>val fileTreeWalk: FileTreeWalk = File(directoryPath).walk()<br/><strong>fileTreeWalk</strong><br/><strong>        .filter { it.isFile }<br/>        .filter { it.extension == "txt" }<br/>        .filter { it.readBytes().isNotEmpty() }<br/>        .forEach {<br/>            it.apply {<br/>                println(path)</strong><br/><strong>                println(readText())</strong><br/><strong>                println()</strong><br/><strong>            }<br/>        }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We start by instantiating the <kbd>File</kbd> type instance that references the <kbd>src/main/resources</kbd> directory and invoking the <kbd>walk()</kbd> function on it. <kbd>walk()</kbd> returns the <kbd>FileTreeWalk</kbd> instance, which is a high-level abstraction layer over the filesystem and allows us to iterate through the files and subdirectories of the original <kbd>File</kbd> object.</p>
<div><kbd>FileTreeWalk</kbd> extends a <kbd>Sequence&lt;File&gt;</kbd> interface and provides an <kbd>Iterator&lt;File&gt;</kbd> implementation, which allows us to iterate through the files and apply any transforming operations to them, in the same way we do while working with collections. </div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Next, we apply a few filtering operations—removing the <kbd>File</kbd> objects referencing directories, removing files that don't contain the <kbd>.txt</kbd> extension, and removing any empty files from the sequence. Finally, we use the <kbd>forEach()</kbd> function to print the paths of the consecutive files together with their contents.</p>
<p>As you can observe, the default order provided by the <kbd>FileTreeWalk</kbd> sequence is from top to bottom. We can define a reversed sequence by calling the <kbd>walk()</kbd> function with a <kbd>direction</kbd> parameter set to <kbd>FileWalkDirection.BOTTOM_UP</kbd>.</p>
<p>There are also two out-of-the-box specialized variants of the <kbd>walk()</kbd> function available—<kbd>File.walkTopDown()</kbd> and <kbd>File.walkBottomUp()</kbd>. The first one returns the <kbd>FileTreeWalk</kbd> instance with the direction property set to <kbd>FileWalkDirection.TOP_DOWN</kbd>, and the second one sets <kbd>direction</kbd> to <kbd>FileWalkDirection.BOTTOM_UP</kbd>.</p>


            

            
        
    </body></html>