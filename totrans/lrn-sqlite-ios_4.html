<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Essentials of SQL"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Essentials of SQL</h1></div></div></div><p>In this chapter, you will learn all about the essentials of SQL. It will outline what the major possibilities with SQL are and how it can be used properly on SQLite. SQL is fundamental to using SQLite and is mandatory for utilizing the benefits of SQL. It is relevant in many ways, because it is the way data is passed through, interrogated, and displayed, using variables.</p><p>We will discuss how the language is used with subclauses like "having", for example. Once you come to know and learn the essentials of how SQL is used in SQLite, it will make the whole subject easier.</p><p>SQL is also pronounced <span class="emphasis"><em>sequel</em></span> in the industry and is the de facto standard for data retrieval using these commands and syntaxes. The instruction in this chapter will use a style and format that is easy to understand and follow. It makes use of the idea of replaying the code, repeating it, and remembering it well, for your knowledge and experience.</p><p>You will also see what data retrieval options and techniques are available to sort, collate, and order information as required. The examples shown in this chapter will provide easy-to-follow and useful instructions with advanced SQL commands. The results will be quick, or even instantaneous and can be practiced over and over again to gain the necessary knowledge. There will be tables such as <code class="literal">customers</code> or <code class="literal">salary</code> and different trigger names and SQL statements in this chapter.</p><p>The examples in this chapter will be ANSI<a class="indexterm" id="id172"/> compliant and should work with SQL databases such as SQLite, Oracle, Ingres, SQL Server, mySQL, MS Access, Informix, Sybase, and other ANSI SQL compliant databases. This chapter aims to give you that critical information, which will advance your skills as well. It will also act as a simple refresher and reminder of when you first learned them.</p><p>To start off, the <code class="literal">SELECT</code> statement is the easiest of the general commands, but it is also the core one of the pact. It allows the data inside the system to be visible by the end user in the choice of format and style requested, assuming it is syntactically correct.</p><p>There are many subcommands and clauses with the <code class="literal">SELECT</code> statement and some of those clauses are discussed in this chapter. The <code class="literal">SELECT</code> statement will have more focus due to its importance, and many options for data selection. As a developer or a DBA, it is always good to have the knowledge of possible options, which enable efficient queries to be written. This chapter will enable that knowledge and, for experts, refresh it. Although SQLite commands work and look the same for Oracle or MySQL, some of the SQLite ones are actually different.</p><p>Let's get started!</p><div class="section" title="Transactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Transactions</h1></div></div></div><p>A database <span class="strong"><strong>transaction</strong></span><a class="indexterm" id="id173"/> is a logical unit of work that contains several operations within. By definition, it will have four <a class="indexterm" id="id174"/>
<span class="strong"><strong>ACID</strong></span> properties: <span class="strong"><strong>atomic</strong></span>, <span class="strong"><strong>consistent</strong></span>, <span class="strong"><strong>isolated</strong></span>, and <span class="strong"><strong>durable</strong></span>.</p><p>A transaction must provide a sense of a full commitment to performing the work, or a way to rollback and not complete the work. It must also keep each transaction separate and isolated from the others, and ensure that transactions are completed, and information is written to the database. It must also reduce any amounts of database inconsistency and allow the best and proper way to recover from any failures.</p></div></div>
<div class="section" title="Query plan"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Query plan</h1></div></div></div><p>When a query is to be<a class="indexterm" id="id175"/> executed, a query plan is used by the database to forge a data path where the best and the most efficient types of routes are created. If there are table join, indexes, and a number of rows in the tables, a variety of mathematical calculations using different algorithms are prepared. Having an execution plan is useful when there are issues with SQL, and to debug multiple table joins and index setups, and follow a path to solve a data or programming issue.</p><p>Apart from the straightforward SQL statements in a plain format, there will be those statements that will be used within iOS and wrapped in one of the languages such as Objective-C or Swift.</p><p>When the query execution plan is executed, the data, the information, is geared for debugging only and should be used as guidance. Every SQLite release will have different updates that affect the product. The whole idea of a plan is to outline the strategy path an SQL command takes.</p><p>A keyword called <a class="indexterm" id="id176"/>
<span class="strong"><strong>EXPLAIN</strong></span>, or a phrase, namely, <span class="strong"><strong>EXPLAIN QUERY PLAN</strong></span>,<a class="indexterm" id="id177"/> is required to be used for obtaining the details of a table. These commands are for debugging and analysis only. These commands <a class="indexterm" id="id178"/>are partially <a class="indexterm" id="id179"/>documented and the behavior is not always 100%:</p><div class="mediaobject"><img alt="Query plan" src="graphics/4725_04_01.jpg"/></div><p>Next, we see what an SQL statement with a <code class="literal">salary</code> selection will look like. Using the <code class="literal">EXPLAIN QUERY PLAN</code> command with the <code class="literal">SELECT</code> statement, the basic plan outlines the order of the table with its name. By learning the query execution plans effectively, you get a view of how SQLite accesses your data and see how it is committed:</p><div class="mediaobject"><img alt="Query plan" src="graphics/4725_04_02.jpg"/></div><p>The <code class="literal">EXPLAIN QUERY PLAN</code> command exists as a guidance and plan for executing the SQL Query. It will report and provide information that relates to how the database indices are effectively used to access the data.</p><p>The <span class="strong"><strong>system catalog</strong></span><a class="indexterm" id="id180"/> is also <a class="indexterm" id="id181"/>the master place where all tables and indexes are listed. For example, the <code class="literal">sqlite_master</code> table is the, as shown here:</p><div class="mediaobject"><img alt="Query plan" src="graphics/4725_04_03.jpg"/></div></div>
<div class="section" title="SQL basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>SQL basics</h1></div></div></div><p>SQLite also<a class="indexterm" id="id182"/> has some other features for using SQL, such as finding the greatest <code class="literal">id</code> from a column, and also the last insert and its <code class="literal">id</code>, as shown in the following:</p><div class="mediaobject"><img alt="SQL basics" src="graphics/4725_04_04.jpg"/></div><div class="section" title="Insert with a subselect clause"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Insert with a subselect clause</h2></div></div></div><p>The <code class="literal">INSERT</code> statement<a class="indexterm" id="id183"/> is the one used to add data into the database. However, the example to date has only shown data from fixed information or program variables. There is another way to insert data, which comes from another table based on the select criteria and data/column matching. This is an insert with a <a class="indexterm" id="id184"/>
<span class="strong"><strong>subselect</strong></span> clause; see the following example:</p><div class="informalexample"><pre class="programlisting">SQLite&gt; Insert into Salary values (Select id, name, salary from salary_import where name='Smith');

SQLite&gt; Select * from Salary where name like '%smith%';</pre></div><p>There are several variations available on the format, as shown in the preceding example. The SQL is flexible and there <a class="indexterm" id="id185"/>are options to select different data and offer computations on the last row of IDs.</p></div><div class="section" title="Update with a subselect clause"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Update with a subselect clause</h2></div></div></div><p>As discussed in the<a class="indexterm" id="id186"/> previous chapters, the <code class="literal">UPDATE</code> statement is used to change existing data in a table from variables in a program or from fixed data. However, there is another way to update data to the destination table from a source table where there is a match and link, as shown in the following. The <code class="literal">UPDATE</code> statement will modify more than one column. The <code class="literal">Where</code> clause will identify which column(s) are to be updated. This is one of the simplest and easiest SQL commands to understand:</p><div class="informalexample"><pre class="programlisting">SQLite&gt; Update salary = 15000
Where name='John Smith';

SQLite&gt; Select * from Salary where name like '%smith%';</pre></div></div><div class="section" title="Select with a subselect clause"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Select with a subselect clause</h2></div></div></div><p>As discussed in the<a class="indexterm" id="id187"/> previous chapters, the <code class="literal">SELECT</code> statement is used to retrieve and display information from the core of the database to the user. The <code class="literal">SELECT</code> statement is a very popular and powerful command with a variety of options and choices to retrieve the data. A <span class="strong"><strong>subselect</strong></span><a class="indexterm" id="id188"/> or <span class="strong"><strong>subquery</strong></span><a class="indexterm" id="id189"/> is a nested piece of SQL within the original SQL, that is embedded near a <code class="literal">WHERE</code> clause. The subquery or subselect will only be used to retrieve information that links up to the main select query using the specific column names.</p><p>These subselect clauses can be used within the <code class="literal">DELETE</code>, <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, and <code class="literal">SELECT</code> SQL commands, with operators such as <code class="literal">=</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&gt;=</code>, <code class="literal">&lt;=</code>, <code class="literal">IN</code>, or <code class="literal">BETWEEN</code>, for example. There are some rules that apply to subqueries, for example, the subcommand must only have one column in the <code class="literal">SELECT</code> clause, unless multiple columns are selected in the main SQL statement.</p><p>The subselect queries must use parentheses as part of their syntax, to outline the subquery itself. The main part of the query can have the <code class="literal">ORDER BY</code> syntax, but it cannot be in the subquery. If multiple rows are returned using these types of queries, then operators such as <code class="literal">IN</code> must be used. The <code class="literal">BETWEEN</code> word can be used in a subquery as long as it is not the <code class="literal">BETWEEN</code> operator itself:</p><div class="informalexample"><pre class="programlisting">sqlite&gt; SELECT * FROM PERSONNEL WHERE ID IN (SELECT ID FROM SALARY WHERE SALARY &gt; 15000);</pre></div></div></div>
<div class="section" title="Data integrity"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Data integrity</h1></div></div></div><p><span class="strong"><strong>Data integrity</strong></span> <a class="indexterm" id="id190"/>is very important in maintaining how tables and data relationships are defined and protected. There are four types of integrity: user defined, referential, entity, and domain.</p><p>The mastering of data manipulation, database design, development, and administration is key to ensure that applications built using SQLite perform well, and are kept free from data crashes, data corruptions, and security issues.</p><p>When a column's datatype is set, it is a form of data integrity. Data integrity can be enhanced by only allowing certain values.</p><p>When a mechanism is designed to maintain the primary keys in a table by a unique tuple or row identifier, it is known as entity integrity.</p><p>Referential integrity occurs when, for example, two tables are linked by a common column datatype and no new data can be added to one table without being added to the second. Referential integrity ensures that data is cleaned and linked properly.</p></div>
<div class="section" title="Default values"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Default values</h1></div></div></div><p>The <span class="strong"><strong>default values</strong></span><a class="indexterm" id="id191"/> for columns is valuable because it enforces data integrity and ensures that a value is entered on the database. It also means that some SQL statements are smaller than others. A standard type of statement without its column being added is an <code class="literal">id</code> field, where the primary key is defined, and when an <code class="literal">INSERT</code> statement is used, the <code class="literal">id</code> field is not required, as shown in the following.</p><p>The DBA can create columns to store <code class="literal">current_timestamp</code> in the database automatically, which is good for logging and time stamping.</p><div class="informalexample"><pre class="programlisting">sqlite&gt; INSERT into salary (name, salary, bonus) values ('John Smith',15000,2000); sqlite&gt; SELECT * FROM salary;

id            name         salary    bonus
-----       --------     ---------  --------
1           Peter Jones   10000      3000
2           Sam Smith     15000      1000
3           John Smith    15000      2000</pre></div><div class="section" title="Constraint checking"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Constraint checking</h2></div></div></div><p>To ensure that the<a class="indexterm" id="id192"/> right data is inputted into <a class="indexterm" id="id193"/>columns on a table, certain rules are imposed, and these are called constraints. These rules enforce data accuracy, limit corruption, and format issues and data reliability are increased and maintained.</p><p>At table level, it will apply to the whole table, but at column level, it will apply only to one certain column level. How they can be used is given as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">.UNIQUE</code> constraint will make sure column data information is not the same</li><li class="listitem" style="list-style-type: disc">The <code class="literal">.PRIMARY</code> key, each data row in the table is identified in SQLite</li><li class="listitem" style="list-style-type: disc"><code class="literal">.NOT NULL</code> makes sure that no column has a NULL value stored</li><li class="listitem" style="list-style-type: disc"><code class="literal">DEFAULT</code> will sets up a<a class="indexterm" id="id194"/> default value, when no value is <a class="indexterm" id="id195"/>specified or entered</li></ul></div></div><div class="section" title="Foreign keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Foreign keys</h2></div></div></div><p>When two or more tables need to link together on a common column, it is known as a <span class="strong"><strong>referencing key</strong></span><a class="indexterm" id="id196"/> or <a class="indexterm" id="id197"/>
<span class="strong"><strong>foreign key</strong></span>. SQLite supports relation<a class="indexterm" id="id198"/> integrity and supports foreign key constraints, like other databases. It is usually designed by the DBA and involves a column ID, for example, to match an ID on the second or third table.</p><p>There must be a logical reference between the table columns and actual data for it to perform well. SQLite will use the foreign key as part of the create table statement; an example is shown in the following:</p><div class="informalexample"><pre class="programlisting">CREATE Table Salary (
id integer primary key,
name text,
salary
};</pre></div></div></div>
<div class="section" title="Updating Views"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Updating Views</h1></div></div></div><p>A <span class="strong"><strong>VIEW</strong></span> is a <a class="indexterm" id="id199"/>command that can use a combination of tables and joins to show the user or program a set of predefined data, as required. Effectively, it gives you a view of the data. You cannot <code class="literal">DELETE</code>, <code class="literal">UPDATE</code>, or <code class="literal">INSERT</code> from a view.</p><p>As a view is defined with a specific name, which is stored in the database, it can be effectively referenced as a table to another SQL statement, as part of a statement to be manipulated.</p><p>If a keyword such as <code class="literal">Temporary</code> or <code class="literal">Temp</code> exists within the <code class="literal">create</code> and <code class="literal">view</code> words, then that view is only seen by that database connection and is removed upon the connection closing, hence the <code class="literal">temp/temporary</code> name.</p><p>If a database name is referenced when the view is created, it will reside within that specific database.</p></div>
<div class="section" title="Index use"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Index use</h1></div></div></div><p>After a table is created with its column and datatypes, it is almost ready to use. The primary columns for data linking are done, but it is not quite ready as defined by a DBA. Instead, an index can be created to speed up SQL queries and act as special lookup tables that SQLite will use as a way of getting information faster.</p><p>An <span class="strong"><strong>index</strong></span><a class="indexterm" id="id200"/> has a data pointer, which will quickly reference the data and bring it back, thus making access quicker without much overhead generally. By definition, indexes do have an overhead in their own right, but the overheads of the index are dwarfed by the performance and efficiency gained. This could be useful for mobile applications because of their limited resource and network access.</p><p>A database index as an example is similar to the one located in a book, where you can find what you want because you know what it is, and just opens the book to right page, after reading the index.</p><p>The index is slow on data input but fast on the <code class="literal">SELECT</code> queries, with or without the <code class="literal">WHERE</code> clause. Once an index is created, it can also be dropped without affecting the core data of a table. The following is a simple example of an index called <code class="literal">table_index_name</code> being created on the <code class="literal">customer</code> table:</p><div class="informalexample"><pre class="programlisting">CREATE INDEX table_index_name ON customer;</pre></div><p>A second example shows how an index is created to reference a column called <code class="literal">salary</code>, which is used multiple times in many queries:</p><div class="informalexample"><pre class="programlisting">CREATE INDEX table_index_salary ON customer (salary);</pre></div><p>Here, an index will speed up access. An index called <code class="literal">table_index_salary</code> is created on the <code class="literal">customer</code> table, which is created on the <code class="literal">salary</code> column.</p><p>There are also indexes called <a class="indexterm" id="id201"/>
<span class="strong"><strong>composite indexes</strong></span>, which actually index more than one column on a database for further performance gains, but also an overhead on data input. As shown in the following, an index is created and is linked to two columns: <code class="literal">salary</code> and <code class="literal">bonus</code>. Rather than having two indexes with more overhead issues, a composite index maybe better, since it is one index with a reference to two columns:</p><div class="informalexample"><pre class="programlisting">CREATE INDEX table_index_salary ON customer (salary, bonus);</pre></div><p>When creating indexes, the database server will also create implicit indexes that are automatic. If, as a DBA, you wish to see them, use the following example:</p><div class="informalexample"><pre class="programlisting">sqlite&gt; .indices customer;</pre></div></div>
<div class="section" title="Triggers"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Triggers</h1></div></div></div><p><span class="strong"><strong>Triggers</strong></span> are <a class="indexterm" id="id202"/>an efficient way of using SQL commands to interact efficiently with the database. They are quick, and are embedded within the create <code class="literal">trigger</code> command.</p><p>A trigger is made up of a trigger name, references to the tables involved, an event of time (like before, or after value changes), the type of operation (like insert, update, or delete), with a variety of tables and columns to complete the operation.</p><p>The syntax has to be right and the tests should ensure that the updates and changes are correct to ensure data concurrency and stability with no corruptions.</p><p>This trigger is called <code class="literal">update_customer_trigger</code>, which performs an <code class="literal">UPDATE</code> query on the <code class="literal">customers</code> table. The update is going to affect the <code class="literal">tel_no</code> column. So, the current telephone column <code class="literal">tel_no</code> is going to be updated, where it will equal the value from the new table, and its column <code class="literal">tel_no</code>—(<code class="literal">tel_no = new.tel_no</code>), where the link of customer name (<code class="literal">customer_name</code>), equals the <code class="literal">old.name</code> column.</p><p>Updated triggers must use specific columns for a table, which are predefined, unlike the <code class="literal">insert</code> or <code class="literal">delete</code> ones</p><div class="informalexample"><pre class="programlisting">sqlite&gt; select sql from sqlite_master where name='update_customer_trigger';

CREATE TRIGGER update_customer_trigger UPDATE OF tel_no ON customers    BEGIN     UPDATE orders SET tel_no = new.tel_no WHERE customer_name = old.name;   END</pre></div></div>
<div class="section" title="Synchronous writes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Synchronous writes</h1></div></div></div><p><span class="strong"><strong>Synchronous writes</strong></span> <a class="indexterm" id="id203"/>are part of the SQL engine, which will ensure that data changes are written to the disk area, as required, for transaction reasons and the way databases work. In the case of SQLite, these operate under different statuses or settings of <code class="literal">NORMAL</code>, <code class="literal">FULL</code>, or <code class="literal">OFF</code>. For performance reasons, SQLite commits can be switched off by the DBA as required.</p><p>The <code class="literal">OFF</code> setting carries on its tasks quickly without much slowing down, minimal interruptions, and increased performance. However, in the case of a database crash, the data integrity will remain okay, but in the case of system crash and power loss, there is a good chance that corruption of the database itself may occur. There are performance gains to be made, but there are also risks associated with this move.</p><p>The <code class="literal">FULL</code> setting has to ensure that data is saved to disk properly and in good time before carrying on. This method is not good for performance, but is the most robust and the safest. If there are data corruptions or system crashes, users can be assured that no database corruption will occur.</p><p>The <code class="literal">NORMAL</code> setting<a class="indexterm" id="id204"/> will slow down at intervals to protect the data and commit transactions to disk. A database crash or a power failure could damage the database, but a more serious hardware error could be worse.</p></div>
<div class="section" title="Database locking and deadlocks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Database locking and deadlocks</h1></div></div></div><p>A <span class="strong"><strong>deadlock</strong></span><a class="indexterm" id="id205"/> occurs when one or many actions or SQL statements compete for data access and table updates or manipulation at the same time as another process or action. Since it works with a transaction, one process can't move forward or complete because the other process or action holds, and is waiting for a resource, hence a deadlock.</p><p>So, in a database, records of <a class="indexterm" id="id206"/>process one would attempt to update, but process two would like to update some of the same rows, or a conflict of another table in which the transaction occurs. Some form of data locking mechanism to manage and reduce conflict must happen. Code around the transaction can be added with a retry indicator of three, for example, so if there is a deadlock, it will retry, and after the third attempt, it would roll back or give the user an opportunity to retry.</p><p>Deadlocking is a common occurrence in multithreaded and multiprocessing operating systems, which are performing a variety of tasks and attempting to complete with positive results.</p><p>See the following example on how SQL transactions will end up in a deadlock. In this case, both transactions/sessions will be in a deadlock state. <span class="strong"><strong>Session 2</strong></span> will try to insert/write to the database and create a locking to get exclusive rights to protect, and ensure it can insert the record without any problem. <span class="strong"><strong>Session 1</strong></span> tries to write as well, which also causes a deadlock situation. Effectively, we have a situation where <span class="strong"><strong>Session 1</strong></span> and <span class="strong"><strong>Session 2</strong></span> do not want to lose access or control until the other leaves, which lets the deadlock continue, as shown here:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Session 1</p>
</th><th style="text-align: left" valign="bottom">
<p>Session 2</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">sqlite3&gt;</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">sqlite3&gt;</code></p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><code class="literal">sqlite3&gt;insert into temp(name,address) values('Gene','London');</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">sqlite3&gt; select * from temp;</code></p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><code class="literal">sqlite3&gt; commit;</code></p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><code class="literal">SQL Error Message: database locked</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">sqlite3&gt; insert into temp(name,address) values('Gene','London');</code></p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">SQL Error Message: database locked</code></p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div></div>
<div class="section" title="FMDB SQLite wrapper"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>FMDB SQLite wrapper</h1></div></div></div><p>In addition to using standard SQL, the<a class="indexterm" id="id207"/> FMDB SQLite wrapper, written in Objective-C, can be of assistance to those who prefer an alternative and easier way to work with SQLite.</p><p>For more information on the FMDB specification<a class="indexterm" id="id208"/> and code examples, refer to <a class="ulink" href="https://github.com/ccgus/fm">https://github.com/ccgus/fmdb</a>.</p><p>There are three <a class="indexterm" id="id209"/>main classes in FMDB:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FMDatabase</strong></span>: This is<a class="indexterm" id="id210"/> the single SQLite database that executes your SQL statements</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FMResultSet</strong></span>: This will <a class="indexterm" id="id211"/>hold and display the output and results from the <code class="literal">FMDatabase</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FMDatabaseQueue</strong></span>: This <a class="indexterm" id="id212"/>will enable you to update and use many threads within this class if you want to perform queries and updates on multiple threads</li></ul></div></div>
<div class="section" title="Database creation and opening"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Database creation and opening</h1></div></div></div><p>The database is<a class="indexterm" id="id213"/> defined and allocated to a location and directory:</p><div class="informalexample"><pre class="programlisting">FMDatabase *db = [FMDatabase databaseWithPath:@"/tmp/atmp.db"];</pre></div><p>To engage with the <a class="indexterm" id="id214"/>database, you must connect and open it up, as shown in the following:</p><div class="informalexample"><pre class="programlisting">if (![db open]) {     [db release];     return; }</pre></div></div>
<div class="section" title="SQL in iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>SQL in iOS</h1></div></div></div><p>To select data, methods <a class="indexterm" id="id215"/>like <code class="literal">executeQuery</code> can be used to return the <code class="literal">FMResultSet</code> object if successful, or <code class="literal">0</code> upon failure. There are methods, such as <code class="literal">lastErrorMessage</code> or <code class="literal">lastErrorcode</code>, to find out if the query has worked or failed:</p><div class="informalexample"><pre class="programlisting">FMResultSet *s = [db executeQuery:@"SELECT * FROM aTable"]; while ([s next]) {     //retrieve values for each record }</pre></div><p>For multiple rows, <code class="literal">[FMResultSet next]</code> must be used to see or read the values returned from the query, even if the recordset is one, for example.</p><p>The following command shows how to use <code class="literal">FMResultSet</code> to select multiple queries as required:</p><div class="informalexample"><pre class="programlisting">FMResultSet *s = [db executeQuery:@"SELECT COUNT(*) FROM aTable"]; if ([s next]) {     int totalCount = [s intForColumnIndex:0]; }</pre></div><p><code class="literal">FrmresultSet</code> offers several methods to the programmer to retrieve; some examples are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">intForColumn:</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">longForColumn:</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">longLongIntForColumn:</code></li></ul></div><p>Some of the aforementioned <a class="indexterm" id="id216"/>methods by default will have the <code class="literal">{type}ForColumnIndex:</code> variant, which will be used to get the data based on the position of the column in the rows and not the name itself.</p><p>The preceding code using <code class="literal">FMDatabase</code> comes from GitHub and is the standard code used for these types of operations. It has been used to improve the ease of interacting with SQLite, instead of the conventional standard method.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, you learned about the essentials of SQL in relation to the SQLite database, and also what you need to be aware of, and the knowledge required, to build SQL statements and interactions with SQLite and iOS as a basic start.</p><p>In the next chapter, you will learn all about exposing the C API, its impact and uses within IOS, and how it works as part of SQLite. The next chapter will also mention how the C API is at the core of SQLite and how it is used.</p></div></body></html>