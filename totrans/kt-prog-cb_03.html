<html><head></head><body><div><h1 class="header-title">Classes and Objects</h1>
                
            
            
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Initializing body of constructor</li>
</ul>
<ul>
<li>Converting one data type into another</li>
</ul>
<ul>
<li>How to type check an object</li>
</ul>
<ul>
<li>How to work with an abstract class in Kotlin</li>
</ul>
<ul>
<li>How to iterate over a class's properties in Kotlin</li>
</ul>
<ul>
<li>How to work with inline properties</li>
</ul>
<ul>
<li>How to work with nested class</li>
</ul>
<ul>
<li>Getting class in Kotlin</li>
</ul>
<ul>
<li>Working with delegated properties</li>
</ul>
<ul>
<li>Working with enums</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, you will be introduced to recipes related to object-oriented programming in Kotlin. Using an OOP approach, you can divide complex problems into smaller problems by creating objects. There are a few differences in Kotlin's style of OOP as compared to Java—for example, in Kotlin, all the classes are closed (final) by default, and if you want them to be extensible, you need to make them open by using an <kbd>open</kbd> keyword. Not only for classes—even the methods are final by default, and you need an <kbd>open</kbd> keyword for them as well. With Kotlin much less code is needed to work with classes and objects. Oh! By the way, did I tell you that we don't even need to use the new keyword while creating the object? So, creating a new object in Kotlin is as simple as this:</p>
<pre style="padding-left: 60px">var person=Person()</pre>
<p>The preceding code will create a mutable object of type <kbd>Person</kbd>, because we have used <kbd>var</kbd> as a modifier. A mutable object means that it can change its value. If you want to create an immutable object, you do it using the <kbd>val</kbd> keyword. So the same example will look as follows:</p>
<pre style="padding-left: 60px">val person=Person()</pre>
<p>So, let's begin looking at some recipes that will help you with object-oriented programming in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Initializing body of constructor</h1>
                
            
            
                
<p>In the Java world, we used to initialize fields of the class in the constructor, as shown in this code:</p>
<pre style="padding-left: 60px">class Student{<br/> int roll_number;<br/> String name;<br/> Student(int roll_number,String name){<br/>     this.roll_number =roll_number;<br/>     this.name = name;<br/> }<br/>}</pre>
<p>So, if the argument's name was similar to that of the property (which was usually the case for making the code more readable), we needed to use this keyword. In this recipe, we will see how to implement the same thing in Kotlin (obviously with much less code).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need an IDE to write and execute your code. I'll be using IntelliJ IDEA. We will create a <kbd>Student</kbd> class with <kbd>name</kbd> and <kbd>roll_number</kbd> as properties.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's look at the mentioned steps to initialize a constructor:</p>
<ol>
<li>Kotlin provides a syntax that can initialize the properties with much less code. Here's what class initialization looks like in Kotlin:</li>
</ol>
<pre style="padding-left: 60px">class Student(var roll_number:Int, var name:String)</pre>
<ol start="2">
<li>You don't even need to define the body of the class, and the initialization of properties takes place in the primary constructor only (the primary constructor is part of the class header). Obviously, you can either choose <kbd>var</kbd> or <kbd>val</kbd>, based on whether you need to keep your properties mutable or not. Now, if you try to create an object, you can do so with this:</li>
</ol>
<pre style="padding-left: 60px">var student_A=Student(1,"Rashi Karanpuria")</pre>
<ol start="3">
<li>Just to confirm, let's try to print its properties to see whether we were able to initialize it or not:</li>
</ol>
<pre style="padding-left: 60px">println("Roll number: ${student_A.roll_number} Name: ${student_A.name}")</pre>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px"> Roll number: 1 Name: Rashi Karanpuria</pre>
<ol start="4">
<li>However, if you want, you can also put default values in the constructor:</li>
</ol>
<pre style="padding-left: 60px">class Student constructor(var roll_number:Int, var name:String="Sheldon")</pre>
<ol start="5">
<li>Then, you can create objects such as this:</li>
</ol>
<pre style="padding-left: 60px">var student_sheldon= Student(25)   // Object with name Sheldon and age 25<br/><br/>var student_amy=Student(25, "Amy")     // Object with name Amy and age 25</pre>
<ol start="6">
<li>If the class has a primary constructor, each secondary constructor needs to be delegated to the primary constructor, either directly or indirectly through another secondary constructor(s).</li>
<li>We use this keyword to delegate to another constructor of the same class:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">class Person(val name: String) {<br/>     constructor(name: String, lastName: String) : this(name) {<br/>         // Do something maybe<br/>     }<br/> }</pre>
<ol start="8">
<li>We can also have a situation where we have to initialize other things in the class, not necessarily just the class's properties. That situation could be opening database connections, for example. In Java, that was done in the constructor itself, but in Kotlin, we have an <kbd>init</kbd> block. The initialization code can be put into an <kbd>init</kbd> block:</li>
</ol>
<pre style="padding-left: 60px">class Student(var roll_number:Int,var name: String) {<br/> init {<br/>         logger.info("Student initialized")<br/>     }<br/> }</pre>
<ol start="9">
<li>Sometimes, we also initialize properties of a class by dependency injection. If you've worked with Dagger2, you must be familiar with objects being directly injected into the constructors of a class. To do so, we append the <kbd>@Inject</kbd> annotation before the constructor keyword. Whenever a constructor has an annotation or visibility modifier, we need to have the <kbd>constructor</kbd> keyword. An example of the constructor keyword is given below:</li>
</ol>
<pre style="padding-left: 60px">class Student @Inject constructor(compositeDisposable: CompositeDisposable) { ... }</pre>
<ol start="10">
<li>Here, we are injecting an object of the <kbd>CompositeDisposable</kbd> type into the constructor and, since we are using an annotation (<kbd>@Inject</kbd>) to do so, we need to apply the constructor keyword.</li>
<li>When you extend a class, you need to initialize the superclass. This is also very simple in Kotlin. If your class has a primary constructor, the base type must be initialized there, using the parameters of the primary constructor. Here's an example of the same:</li>
</ol>
<pre style="padding-left: 60px">class Student constructor(var roll_number:Int, var name:String):Person(name)</pre>
<ol start="12">
<li>However, sometimes a class may not have the primary constructor. In that case, each secondary constructor has to initialize the base type using the <kbd>super</kbd> keyword or can delegate to another constructor that does that. Also, different secondary constructors can call different constructors of the base type:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">class Student: Person {<br/> constructor(name: String) : super(name)<br/>constructor(name: String, roll_number: Inte) :super(name)<br/> }</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting one data type into another</h1>
                
            
            
                
<p>In Java, we used to typecast by appending the desired type in front of variables like this:</p>
<pre style="padding-left: 60px">String a = Integer.toString(10)</pre>
<p>Also, in Java, numeric is directly converted to larger numeric types, but in Kotlin, this feature is not there for type safety—so how can we change one type of object to another in Kotlin? We will see it in this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need Kotlin compiler installed, along with JDK. I am using the online IDE available at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's understand how to convert one data type into another by following the steps below:</p>
<ol>
<li>Let's try a very basic example—trying to convert an <kbd>Int</kbd> to <kbd>Long</kbd> and <kbd>Float</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var a = 1<br/>    var b: Float = a.toFloat()<br/>    var c = a.toLong()<br/>    println("$a is Int while $b is Float and $c is Long")<br/>}</pre>
<ol start="2">
<li>Similarly, <kbd>Long</kbd> can be converted to <kbd>Float</kbd> and <kbd>Int</kbd>, like this:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var a = 1000000000000000000L<br/>    var b: Float = a.toFloat()<br/>    var c = a.toInt()<br/>    println("$a is Long while $b is Float and $c is Integer")<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">The output of this code is as shown:</p>
<pre style="padding-left: 60px" class="mce-root">1000000000000000000 is Long while 9.9999998E17 is Float and -1486618624 is Integer</pre>
<ol start="3">
<li class="mce-root">Let's try a more interesting conversion with <kbd>Byte</kbd>, <kbd>Int</kbd>, and <kbd>Strings</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var a = 15623<br/>    var b: Byte = a.toByte()<br/>    var c = a.toString()<br/>    println("$a is Int while $b is Byte and $c is String")<br/>}</pre>
<p>Here's a list of methods that can be used for type conversion in Kotlin:</p>
<ul>
<li class="mce-root"><kbd>toByte()</kbd>: Byte</li>
<li class="mce-root"><kbd>toShort()</kbd>: Short</li>
<li class="mce-root"><kbd>toInt()</kbd>: Int</li>
<li class="mce-root"><kbd>toLong()</kbd>: Long</li>
<li class="mce-root"><kbd>toFloat()</kbd>: Float</li>
<li class="mce-root"><kbd>toDouble()</kbd>: Double</li>
<li class="mce-root"><kbd>toChar()</kbd>: Char</li>
<li class="mce-root"><kbd>toString()</kbd>: String</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">Basically, Kotlin is a type-safe language and ensures that types cannot be directly converted in the language. Also, <kbd>String</kbd> is not the same as <kbd>String</kbd>? As expected, there is no method to convert a variable to a Boolean type. Conversion from a larger type to a smaller type is possible, but it might truncate the resulting values.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to type check an object</h1>
                
            
            
                
<p>One often needs to check if an object is of a particular type at runtime. With Java, we used an instance of a keyword; with Kotlin, it is the <kbd>is</kbd> keyword.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for the purpose, for which you need Kotlin compiler installed along with JDK. I am using online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's see how to type check an object in these steps:</p>
<ol>
<li>Let's try a very basic example, trying <kbd>is</kbd> with string and integer. In this example, we will type check a string and an integer:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var a : Any = 1<br/>    var b : Any = "1"<br/>    if (a is String) {<br/>        println("a = $a is String")<br/>    }<br/>    else {<br/>        println("a = $a is not String")<br/>    }<br/>    if (b is String) {<br/>        println("b = $b is String")<br/>    }<br/>    else {<br/>        println("b = $b is not String")<br/>    }<br/>}<br/><br/></pre>
<ol start="2">
<li>Similarly, we can use <kbd>!is</kbd> to check whether the object is not of type <kbd>String</kbd>, like this:</li>
</ol>
<div><pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var b : Any = 1<br/>    if (b !is String) {<br/>        println("$b is not String")<br/>    }<br/>    else {<br/>        println("$b is String")<br/>    }<br/>}</pre></div>
<p>If you remember how <kbd>when</kbd> works in Kotlin, we do not need to put in the <kbd>is</kbd> keyword, because Kotlin has a feature of smart cast and throws an error if the compared objects are not of the same type.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Basically, the <kbd>is</kbd> operator is used to check the type of the object in Kotlin and <kbd>!is</kbd> is the negation of the <kbd>is</kbd> operator.</p>
<p>Kotlin compiler tracks immutable values and safe casts them wherever needed. This is how smart casts work; <kbd>is</kbd> is a safe cast operator, whereas an unsafe cast operator is the <kbd>as</kbd> operator.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Let's try an example with the <kbd>as</kbd> operator, which is used for casting in Kotlin. It is an unsafe cast operator. The following code example throws <kbd>ClassCastException</kbd>, because we cannot convert an integer to string:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   var a : Any = 1<br/>   var b = a as String<br/>}</pre>
<p>On the other hand, the following code runs successfully because of variable <kbd>a</kbd>, which, being of <kbd>Any</kbd> type, can be cast to <kbd>String</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    var a : Any = "1"<br/>    var b = a as String<br/>    println(b.length)<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to work with an abstract class in Kotlin</h1>
                
            
            
                
<p class="mce-root">Abstract classes are classes that cannot be instantiated, which means that we cannot create objects of an abstract class. The main inspiration behind using abstract classes is that we can inherit from them. When a class inherits from an abstract class, it implements all abstract methods of the parent class.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for the purpose, for which you need Kotlin compiler installed along with JDK. I am using online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's now see how to work with an <kbd>abstract</kbd> class in these steps:</p>
<ol>
<li class="mce-root">The <kbd>abstract</kbd> keyword is used to declare an <kbd>abstract</kbd> class. Let's create an abstract class and try to inherit from it:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">abstract class Mammal {<br/>    abstract fun move(direction: String)<br/>}</pre>
<ol start="2">
<li class="mce-root">For a class to be a subclass of the <kbd>Mammal</kbd> class, we use the <kbd>:</kbd> operator, as in the following example. Pay attention to the <kbd>override</kbd> keyword used before the method implementation of the superclass:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">class Dog : Mammal() {<br/>    override fun move(direction: String) {<br/>        println(direction)<br/>    }<br/>}</pre>
<ol start="3">
<li class="mce-root">If we do not want a method to be implemented by the subclass, we do not declare it as <kbd>abstract</kbd> or <kbd>open</kbd>, as demonstrated in this example:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var x = Dog()<br/>    x.move("North")<br/>    println(x.show(123))<br/>}<br/>class Dog : Mammal() {<br/>    override fun move(direction: String) {<br/>        println(direction)<br/>    }<br/>}<br/>abstract class Mammal {<br/>    fun show(y: Int): String {<br/>        return y.toString()<br/>    }<br/>    abstract fun move(direction: String)<br/>}</pre>
<ol start="4">
<li class="mce-root">If we declare <kbd>init</kbd> blocks in each class, as follows, we get an output where superclass’s <kbd>init</kbd> block is called first:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var x = Dog()<br/>    x.move("North")<br/>    println(x.show(123))<br/>}<br/>class Dog : Mammal() {<br/>    init {<br/>        println ("Hey from Dog")<br/>    }<br/>    override fun move(direction: String) {<br/>        println(direction)<br/>    }<br/>}<br/>abstract class Mammal {<br/>    init {<br/>        println ("Hey from Mammal")<br/>    }<br/>    fun show(y: Int): String {<br/>        return y.toString()<br/>    }<br/>    abstract fun move(direction: String)<br/>}</pre>
<p class="mce-root">The output of the final program is this:</p>
<pre class="mce-root">Hey from Mammal<br/>Hey from Dog<br/>North<br/>123</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">The <kbd>Dog</kbd> class is a subclass of <kbd>Mammal</kbd> and inherits all its methods. The methods declared <kbd>abstract</kbd> are supposed to be implemented by the <kbd>Dog</kbd> class. The <kbd>show()</kbd> method is in <kbd>Mammal</kbd> but can be called by the <kbd>Dog</kbd> object, because the object created is of the <kbd>Mammal</kbd> type.</p>
<p class="mce-root">The <kbd>init</kbd> block of superclass is called before subclass.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to iterate over a class's properties in Kotlin</h1>
                
            
            
                
<p>Reflections in Kotlin allows us introspection of the structure of our program at runtime. This also enables us to introspect the class modifiers, methods, and properties.<br/>
In this recipe, we will see how we can iterate over the properties of a Kotlin class. So let’s get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We’ll be using IntelliJ IDEA IDE for coding purposes. We will create a <kbd>Student</kbd> class, which will have the <kbd>roll_number</kbd> and <kbd>name</kbd> properties. We will then see how we can iterate over its properties.</p>
<p>If you are not using IntelliJ IDE or Android Studio, you might need to include reflection library in your classpath. Head on over to <a href="https://kotlinlang.org/docs/reference/reflection.html">https://kotlinlang.org/docs/reference/reflection.html</a> to learn more about this.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the following steps, we will see how to iterate over a class's properties:</p>
<ol>
<li>Here's our <kbd>Student</kbd> class with the <kbd>roll_number</kbd> and <kbd>full_name</kbd> attributes:</li>
</ol>
<pre style="padding-left: 60px">class Student constructor(var roll_number:Int, var full_name:String)</pre>
<ol start="2">
<li>Now, we will be using a <kbd>for</kbd> statement, because we want to iterate over multiple properties that a class can have:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var student=Student(2013001,"Aanand Shekhar Roy")<br/>    for (property in Student::class.memberProperties) {<br/>        println("${property.name} = ${property.get(student)}")<br/>    }<br/>}</pre>
<p>This is the output:</p>
<pre style="padding-left: 60px">full_name = Aanand Shekhar Roy<br/>roll_number = 2013001</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">The implementation is quite straightforward. We are able to achieve the introspection into the class’s properties because we are using reflections and <kbd>memberProperties</kbd> is just one of the many functions of <kbd>KClass</kbd>.</p>
<p class="mce-root">One thing to note is that <kbd>memberProperties</kbd> returns all the non-extension properties declared in this class and all of its superclasses. Consider that we have a <kbd>Person</kbd> class, as follows:</p>
<pre class="mce-root">open class Person{<br/>     val isHuman:Boolean=true<br/>}</pre>
<p class="mce-root">Also, we extend our <kbd>Student</kbd> class with the <kbd>Person</kbd> class, and then the same code used earlier with the <kbd>memberProperties</kbd> method will result in an output as shown:</p>
<pre class="mce-root">full_name = Aanand Shekhar Roy<br/>roll_number = 2013001<br/>isHuman = true</pre>
<p class="mce-root">So, if you want to just iterate over the declared fields in the <kbd>Student</kbd> class, you will need the <kbd>declaredMemberProperties</kbd> method. Here's an example with <kbd>declaredMemberProperties</kbd>:</p>
<pre class="mce-root">for (property in Student::class.declaredMemberProperties) {<br/>    println("${property.name} = ${property.get(student)}")<br/>}</pre>
<p class="mce-root">This is the output:</p>
<pre class="mce-root">full_name = Aanand Shekhar Roy<br/>roll_number = 2013001</pre>
<p class="mce-root">The preceding examples were for Kotlin <kbd>KClass</kbd>. Suppose you want to iterate over properties for a <kbd>Java Class&lt;T&gt;</kbd>—you can use a Kotlin extension property to get the Kotlin <kbd>KClass&lt;T&gt;</kbd>, from which you can proceed, for example, <kbd>something.javaClass.kotlin.memberProperties</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p class="mce-root">Check out the list (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html</a>) of methods provided by Kotlin’s Reflection library, with the help of which you can perform a lot of introspection at runtime.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to work with inline properties</h1>
                
            
            
                
<p class="mce-root">A great thing about Kotlin is high-order functions that let us use functions as parameters to other functions. However, they are objects, so they present memory overhead (because every instance is allocated space in heap, and we need methods for calling the functions too). We can improve the situation using inline functions. Inline annotation means that the specific function, along with the function parameters, will be expanded at the call site; this helps reduce call overhead.</p>
<p class="mce-root">Similarly, the inline keyword can be used with properties and property accessors that do not have the backing field. Let's see how in this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for the purpose, for which you need Kotlin compiler installed along with JDK. I am using online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA as the development environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's see how to work with inline properties in these steps:</p>
<ol>
<li class="mce-root">Let's try an example where we <kbd>inline</kbd> an accessor of a property in Kotlin:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">var x.valueIsMaxedOut: Boolean<br/>inline get() = x.value == CONST_MAX</pre>
<ol start="2">
<li class="mce-root">In this example, we just used the <kbd>inline</kbd> keyword with the <kbd>get</kbd> accessor. We can also declare both the <kbd>get</kbd> and <kbd>set</kbd> accessors as inline by making the whole property inline, as shown in this code snippet:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">inline var x.valueIsMaxedOut: Boolean<br/>get() = x.value == CONST_MAX<br/>set(value) {<br/>    // set field here<br/>    println(“Value set!”)<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">In the preceding snippet, both accessors are inlined.</p>
<ol start="3">
<li class="mce-root">One thing to keep in mind, though, is that inline does not work with property or accessor if the property has a backing field or the assessor does not reference the backing field. The code here is an example of a scenario where we cannot use <kbd>inline</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">var x.valueIsMaxedOut: Boolean = true<br/>get() = x.value == CONST_MAX<br/>set(value) {<br/>    // set field here<br/>    println(“Value set!”)<br/>}</pre>
<p class="mce-root">Another thing to keep in mind is that, although inline properties reduce call overhead by getting expanded only at the call site, they also increase the overall bytecode, so inline should not be used with large functions or accessors.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">So, basically, we use inline when we wish to reduce memory overhead. Like the inline function, we can also declare properties as inline or the accessors of properties as inline. However, one thing to keep in mind is that inlining increases bytecode considerably, so it is suggested to not inline functions or accessors that have a large code logic.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to work with nested class</h1>
                
            
            
                
<p>In this recipe, we will see how to use nested classes in Kotlin. A nested class is a member of its enclosing class.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for the purpose, for which you need Kotlin compiler installed along with JDK. I am using online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Now we will see how to work with a nested class in the following steps:</p>
<ol>
<li>Let's try an example of a nested class in Kotlin:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var a1 = outCl()<br/>    a1.printAB()<br/>    outCl.inCl().printB()<br/>}<br/>class outCl {<br/>var a = 6<br/>    fun printAB () {<br/>    var b_ = inCl().b<br/>    println ("a = $a and b = $b_ from inside outCl")<br/>}<br/> <br/>class inCl {<br/>    var b = "9"<br/>        fun printB() {<br/>            println ("b = $b from inside inCl")<br/>        }<br/>    }<br/>}<br/><br/></pre>
<p style="padding-left: 60px" class="mce-root">Here's the output:</p>
<pre style="padding-left: 60px" class="mce-root">a = 6 and b = 9 from inside outCl<br/>b = 9 from inside inCl</pre>
<ol start="2">
<li class="mce-root">Now, let's try an example of the <kbd>inner</kbd> class. To declare a nested class as <kbd>inner</kbd>, we use the <kbd>inner</kbd> keyword. An <kbd>inner</kbd> class can access members of the outer class, as they carry a reference to the outer class:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var a = outCl()<br/>    a.printAB()<br/>    a.inCl().printAB()<br/>}<br/>class outCl {<br/>    var a = 6<br/>    fun printAB () {<br/>        var b_ = inCl().b<br/>        println ("a = $a and b = $b_ from inside outCl")<br/>    }<br/>    inner class inCl {<br/>        var b = "9"<br/>        fun printAB() {<br/>            println ("a = $a and b = $b from inside inCl")<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">The output of the preceding code is this:</p>
<pre style="padding-left: 60px" class="mce-root">a = 6 and b = 9 from inside outCl<br/>a = 6 and b = 9 from inside inCl</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">A nested class can be created by just declaring the nested class inside another class. In this case, to access the nested class, you make a static reference that is like <kbd>outerClass.innerClass()</kbd>, and you can also make an object of inner class using this.<br/>
An <kbd>inner</kbd> class, on the other hand, is created by adding the <kbd>inner</kbd> keyword to a nested class. In that case, we access the inner class as though it was a member or the outer class, that is, using an object of the outer class like this:</p>
<pre style="padding-left: 60px" class="mce-root">var outerClassObject = outerClass()<br/>outerClassObject.innerClass().memberVar</pre>
<p class="mce-root">A nested class does not have access to members of the outer class, as it does not have any reference to an object of the outer class. On the other hand, the inner class can access all of the outer class’s members, as it has a reference to an object of outer class.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p class="mce-root">We can also create anonymous inner classes in Kotlin using the <kbd>object</kbd> keyword, like this:</p>
<pre style="padding-left: 60px" class="mce-root">val customTextTemplateListener = object:ValueEventListener{<br/>    override fun onCancelled(p0: DatabaseError?) {<br/>    }<br/>    override fun onDataChange(dataSnapshot: DataSnapshot?) {<br/>    }<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting class in Kotlin</h1>
                
            
            
                
<p>In this recipe, we will look into the ways by which we can get the class reference in Kotlin. Primarily, we will be working with reflection. Reflection is a library that provides the ability to inspect code at runtime instead of compile time. In Java, we can get a variable's class through <kbd>getClass()</kbd>, like <kbd>something.getClass()</kbd>. Let’s see how to resolve a variable’s class in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Java’s equivalent of resolving a variable's name is with the <kbd>.getClass()</kbd> method, for example, <kbd>something.getClass()</kbd>. In Kotlin, we can achieve the same thing with <kbd>something.javaClass</kbd>.</li>
<li>To get a reference to the reflection class, we used to do <kbd>something.class</kbd> in Java, whose Kotlin equivalent is <kbd>something::class</kbd>. This returns a <kbd>KClass</kbd>. The special features of this <kbd>KClass</kbd> is that it provides introspection capabilities quite similar to the abilities provided to Java’s reflection class.<br/>
Note that the KClass is different from Java’s <kbd>Class</kbd> object. If you want to obtain a Java <kbd>Class</kbd> object from Kotlin's <kbd>KClass</kbd>, use the <kbd>.java</kbd> extension property:</li>
</ol>
<pre style="padding-left: 60px">val somethingKClass: KClass&lt;Something&gt; = Something::class<br/>val a: Class&lt;Something&gt; = somethingKClass.java<br/>val b: Class&lt;Something&gt; = Something::class.java</pre>
<ol start="3">
<li>The latter example will be optimized by the compiler to not allocate an intermediate KClass instance.<br/>
If you use Kotlin 1.0, you can convert the obtained Java class to a KClass instance by calling the <kbd>.kotlin</kbd> extension property, for example, <kbd>something.javaClass.kotlin</kbd>.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>As was just described, <kbd>KClass</kbd> provides you with introspection capabilities. Here are a few methods of <kbd>KClass</kbd>:</p>
<ul>
<li><kbd>isAbstract</kbd>: True if this class is abstract</li>
<li><kbd>isCompanion</kbd>: True if this class is a companion object</li>
<li><kbd>isData</kbd>: True if this class is a data class</li>
<li><kbd>isFinal</kbd>: True if this class is final</li>
<li><kbd>isInner</kbd>: True if this class is an inner class</li>
<li><kbd>isOpen</kbd>: True if this class is open</li>
</ul>
<p>Follow this link (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/</a>) for the complete list of functions provided by KClass.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with delegated properties</h1>
                
            
            
                
<p>Kotlin 1.1 brought many updates; one of the important ones was delegated properties. There are three types of delegated properties:</p>
<ul>
<li><kbd>lazy</kbd>: Lazy properties are the ones evaluated first and the same instance is returned after them, much like a cache</li>
<li><kbd>observable</kbd>: The listener is notified whenever a change is made</li>
<li><kbd>map</kbd>: Properties are stored in the map instead of in every field</li>
</ul>
<p> In this recipe, we will see how to work with these delegates. So let's get started.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be working on Android code, so we will require Android Studio 3.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's see a simple example of a delegated property:</p>
<ol>
<li>First, we will work with the lazy delegate property. Simply put, this delegate can suspend the object creation until we first access it. This is really important when you are working with heavy objects; they take a long time to be created—for example, when creating a database instance or maybe dagger components. Not only this, the result is remembered and the same value is returned for subsequent calls for <kbd>getValue()</kbd> on this kind of delegated property. Let's take a look at an example:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>     val button by lazy { findViewById&lt;Button&gt;(R.id.submit_button) }                                              setContentView(R.layout.activity_main)<br/>     button.text="Submit"<br/>}</pre>
<ol start="2">
<li>The preceding is a standard <kbd>onCreate</kbd> method of an activity. If you look carefully, we have set the <kbd>button</kbd> variable before the <kbd>setContentView(..)</kbd> method. When you run it, it runs perfectly. If you hadn't used lazy, it would have given a <kbd>NullPointerException</kbd>, something like this:</li>
</ol>
<pre style="padding-left: 60px">Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setText(java.lang.CharSequence)' on a null object reference</pre>
<ol start="3">
<li>The button variable was null, as we called it before the <kbd>setContentView</kbd>. However, this wasn't a problem with lazily created <kbd>button</kbd> object, because although we had declared it before <kbd>setContentView</kbd>, the <kbd>button</kbd> object wasn't created. It was created after its first access, that is, when we tried to set a property on it.</li>
<li>So, with a lazy construct, you don't need to think about where to place your code for initialization, and initialization of an object is deferred till its first use.</li>
</ol>
<p>Another key thing to note is that, by default, the evaluation of lazy properties will be synchronized, which means the value is computed in one thread, and the rest of the threads will see the same value. There are three types of initialization:</p>
<ul>
<li><kbd>LazyThreadSafetyMode.SYNCHRONIZED</kbd>: This is the default mode and ensures that only a single thread can initialize the instance.</li>
<li><kbd>LazyThreadSafetyMode.PUBLICATION</kbd>: In this mode, multiple threads can execute the initialization.</li>
<li><kbd>LazyThreadSafetyMode.NONE</kbd>: This mode is used when we are sure that initialization will happen only on one thread. For example, in the case of Android, we can be sure that views will be initialized by the UI thread only. Since this doesn't guarantee thread-safety, it has much less overhead.</li>
</ul>
<p>Another useful delegate is the observable delegate. This delegate helps us observe any changes to the property. For example, let's take a look at a very basic implementation of the <kbd>observable</kbd> delegate:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val paris=Travel()<br/>     paris.placeName="Paris"<br/>     paris.placeName="Italy"<br/>}<br/>class Travel {<br/>     var placeName:String by Delegates.observable("&lt;&gt;"){<br/>         property, oldValue, newValue -&gt;<br/>         println("oldValue = $oldValue, newValue = $newValue")<br/>    }<br/>}</pre>
<p>This is the output:</p>
<pre style="padding-left: 60px">oldValue = &lt;&gt;, newValue = Paris<br/>oldValue = Paris, newValue = Italy</pre>
<p>As we can see, the <kbd>observable</kbd> delegate takes in two things: a default value (which we specified as <kbd>&lt;&gt;</kbd>) and a handler, which gets called whenever that property is modified.</p>
<p>Let's now work with the <kbd>vetoable</kbd> delegate. It's a lot like the <kbd>observable</kbd> delegate, but with it, we can "veto" the modification. Let's look at an example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val paris=Travel()<br/>    paris.placeName="Paris"<br/>    paris.placeName="Italy"<br/>    println(paris.placeName)<br/>}<br/>class Travel {<br/>    var placeName:String by Delegates.vetoable("&lt;&gt;"){<br/>        property, oldValue, newValue -&gt;<br/>            if(!newValue.equals("Paris")){<br/>                return@vetoable false<br/>            }<br/>            true<br/>    }<br/>}</pre>
<p>This is the output:</p>
<pre style="padding-left: 60px">Paris</pre>
<p>As you can see in the preceding example, if <kbd>newValue</kbd> isn't equal to <kbd>"Paris"</kbd>, we will return <kbd>false</kbd>, and the modification will be aborted. If you want the modification to take place, you need to return <kbd>true</kbd> from the construct.</p>
<p>Sometimes, you create an object based on values dynamically, for example, in the case of parsing JSON. For those applications, we can use the <kbd>map</kbd> instance itself as the delegate for a delegated property. Let's see an example here:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val paris=Travel(mapOf(<br/>        "placeName" to "Paris"<br/>    ))<br/>    println(paris.placeName)<br/>}<br/>class Travel(val map:Map&lt;String,Any?&gt;) {<br/>    val placeName: String by map<br/>}</pre>
<p>Here's the output:</p>
<pre>Paris</pre>
<p>To make it work for <kbd>var</kbd> properties, you need to use a <kbd>MutableMap</kbd>, so the preceding example might look something like this:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val paris=Travel(mutableMapOf(<br/>        "placeName" to "Paris"<br/>    ))<br/>    println(paris.placeName)<br/>}<br/>class Travel(val map:MutableMap&lt;String,Any?&gt;) {<br/>    var placeName: String by map<br/>}</pre>
<p>Of course, the output will be the same.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The observable delegated property can be used extensively in adapters. Adapters are used to populate data in some sort of list. Usually, when data is updated, we just update the member variable list in the adapter and then call <kbd>notifyDatasetChanged()</kbd>. With the help of observable and <kbd>DiffUtils</kbd>, we can just update the things that are actually changed, rather than changing everything. This results in much more efficient performance.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with enums</h1>
                
            
            
                
<p>Enums are used when a variable can only take one of a small set of possible values. An example would be the case of type constants (direction: "North", "South", "East", and “West”). With the help of enums, you can avoid errors from passing in invalid constants, and you also document which values are acceptable for use.</p>
<p>In this recipe, we will see how to use enums in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We’ll be using an IntelliJ IDEA for writing and running the code. First, we will be creating a simple type-safe enum, <kbd>Direction</kbd>, with the members NORTH, SOUTH, EAST, and WEST (representing four directions).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's see an example of the <kbd>enum</kbd> class:</p>
<ol>
<li>In this example, we will create an enum of directions. We will assume that there are only four of them:</li>
</ol>
<pre style="padding-left: 60px">enum class Direction {<br/>    NORTH,SOUTH,EAST,WEST<br/>}<br/>fun main(args: Array&lt;String&gt;) {<br/>    var north_direction=Direction.NORTH<br/>    if(north_direction==Direction.NORTH){<br/>        println("Going North")<br/>    }else{<br/>        println("No idea where you're going!")<br/>    }<br/>}</pre>
<ol start="2">
<li>As you can see, the variable (<kbd>north_direction</kbd>) can just take values among the predefined constants in the <kbd>enum</kbd> class.</li>
</ol>
<ol start="3">
<li>We can also initialize enums with default values:</li>
</ol>
<pre style="padding-left: 60px">enum class Direction(var value:Int) {<br/>    NORTH(1),SOUTH(2),EAST(3),WEST(4)<br/>}<br/>fun main(args: Array&lt;String&gt;) {<br/>    var north_direction=1<br/>    if(north_direction==Direction.NORTH.value){<br/>        println("Going North")<br/>    }else{<br/>        println("No idea where you're going!")<br/>    }<br/>}<br/><br/>//Output: Going North</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It is strongly recommended that you don’t use enums in your Android projects. According to Google engineers, adding a single enum will increase the size to approximately 13 times that of the final DEX file. It also generates the problem of runtime overhead and your app will require more space.</p>
<p>The Android documentation says this:</p>
<p>"Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android."</p>
<p>However, if you want the comfort of enums, you can use Android’s annotation library, which has <kbd>TypeDef</kbd> annotations—but sadly, this isn’t supported by Kotlin at the time of this book being written, so we hope it gets added in future versions of Kotlin.</p>


            

            
        
    </div>



  </body></html>