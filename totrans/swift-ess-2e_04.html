<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Storyboard Applications with Swift and iOS</h1></div></div></div><p class="calibre8">Storyboards were originally introduced in Xcode 4.2 with iOS 5.0. Storyboards solved the problem of being able to graphically present the flow of screens in an iOS application, and they also provided a way to edit the content of these screens in one place instead of many separate <code class="literal">xib</code> files. Storyboards work in the same way with Swift as with Objective-C, and the <em class="calibre11">Swift and storyboards</em> section shows how to integrate Swift code with storyboard transitions.</p><p class="calibre8">This chapter will present the following topics:</p><div><ul class="itemizedlist"><li class="listitem">How to create a storyboard project</li><li class="listitem">Creating multiple scenes</li><li class="listitem">Using segues to navigate between scenes</li><li class="listitem">Writing custom view controllers</li><li class="listitem">Connecting views to outlets in Swift</li><li class="listitem">Laying out views with Auto Layout</li><li class="listitem">Using constraints to build resizable views</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec27" class="calibre1"/>Storyboards, scenes, and segues</h1></div></div></div><p class="calibre8">By <a id="id176" class="calibre1"/>default, Xcode 7 creates a <code class="literal">Main.storyboard</code> file instead of a <code class="literal">MainWindow.xib</code> file for newly-created iOS projects. The <code class="literal">UIMainStoryboardFile</code> key in the <code class="literal">Info.plist</code> file points to the application's main storyboard name (without the extension). When the application starts up, the <code class="literal">Main.storyboard</code> file is loaded instead of the <code class="literal">NSMainNib</code> entry. Prior versions of Xcode allowed developers to opt in or out of storyboards, but with Xcode 7, storyboards are the default and developers cannot easily opt out. It is still possible to use the <code class="literal">xib</code> files for individual sections of an application or to use them to load custom classes for prototype table cells. In addition, Xcode 7 creates a <code class="literal">LaunchScreen.storyboard</code> to display as a splash screen (on iOS 8 and higher) while the application is loading, in preference to prerendered screens at fixed resolutions. This allows devices with many different resolutions (including future unannounced ones) to render pixel-perfect splash screens without having to be rendered at different resolutions for each new device size.</p><p class="calibre8">A <em class="calibre11">storyboard</em> is <a id="id177" class="calibre1"/>a collection <a id="id178" class="calibre1"/>of <em class="calibre11">scenes</em> (separate screens) that are connected <a id="id179" class="calibre1"/>with <em class="calibre11">segues</em> (pronounced <em class="calibre11">seg-ways</em>). Each scene is represented by a <em class="calibre11">view controller</em>, which has an associated <em class="calibre11">view</em>. Segues transition between different scenes with a customizable user-interface transition, such as a slide or fade, and they can be triggered from a UI control or programmatically.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec50" class="calibre1"/>Creating a storyboard project</h2></div></div></div><p class="calibre8">As the <a id="id180" class="calibre1"/>default templates with Xcode 7 use storyboards by default, any of the templates will work. In fact, each of the application templates set up a specific type of view controller and template code. The simplest template to work with and customize is the <strong class="calibre2">Single View Application</strong>, which can be selected by navigating to <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> | <strong class="calibre2">Project…</strong>. Create a project called <code class="literal">Storyboards</code>, which uses a single-view application, for experimentation with this chapter. (Refer to the <em class="calibre11">Creating a single view iOS application</em> section in <a class="calibre1" title="Chapter 3. Creating an iOS Swift App" href="part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b">Chapter 3</a>, <em class="calibre11">Creating an iOS Swift App</em>, for more details on how to create a new application.)</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec51" class="calibre1"/>Scenes and view controllers</h2></div></div></div><p class="calibre8">Standard view controllers <a id="id181" class="calibre1"/>can be used to build up an application, which includes the following:</p><div><ul class="itemizedlist"><li class="listitem">Split views using a <code class="literal">UISplitViewController</code> class, which can contain any of the following but may not be embedded in any other view controller</li><li class="listitem">Tabbed views using a <code class="literal">UITabBarController</code> class, which can contain any of the following but may only be embedded in a split view or used as the root controller</li><li class="listitem">Navigational controls can be added to existing controllers with a <code class="literal">UINavigationController</code> class, which can contain any of the following and may be embedded in any of the preceding or used as a root view controller</li><li class="listitem">Paginated views using a <code class="literal">UIPageViewController</code> class, which provide both sliding and page curling display options</li><li class="listitem">Tabular views using a <code class="literal">UITableViewController</code> class</li><li class="listitem">Grid views using a <code class="literal">UICollectionViewController</code> class</li><li class="listitem">Audio-visual content using a <code class="literal">AVPlayerViewController</code> class</li><li class="listitem">OpenGL ES content using a <code class="literal">GLKViewController</code> class</li><li class="listitem">Custom controller content using a <code class="literal">UIViewController</code> class or a custom subclass</li></ul></div><p class="calibre8">These classes can<a id="id182" class="calibre1"/> be mixed, but there is an explicit ordering that must be followed to satisfy the <a id="id183" class="calibre1"/>Apple <strong class="calibre2">Human Interface Guidelines</strong> (also known as the <strong class="calibre2">HIG</strong>). These are all optional, but if combined, they need to obey this ordering:</p><div><img src="img/00037.jpeg" alt="Scenes and view controllers" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">In addition to the standard view controller classes, custom subclasses can be used as well. This is covered in more detail in the <em class="calibre11">Custom view controllers</em> section later in this chapter.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec52" class="calibre1"/>Adding views to the scene</h2></div></div></div><p class="calibre8">The <code class="literal">Main.storyboard</code> file <a id="id184" class="calibre1"/>can be opened by clicking on the file in the project navigator. An editor will open, which shows the storyboard as a set of scenes along with the document outline on the left. In a single-page application, only one view controller will exist.</p><div><img src="img/00038.jpeg" alt="Adding views to the scene" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The arrow to<a id="id185" class="calibre1"/> the left of the view controller indicates that this scene is the <em class="calibre11">initial view controller</em>. This can also be set with the <strong class="calibre2">Is Initial View Controller</strong> checkbox, which can be seen by selecting the <strong class="calibre2">View Controller</strong> from the scene and navigating to the <em class="calibre11">attributes inspector</em> (go to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Attributes Inspector</strong>, or press <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">4</em>). The initial view controller can also be changed to a different scene by dragging and dropping the arrow to point to a different scene.</p><p class="calibre8">Views are added by dragging and dropping them from the <em class="calibre11">object library</em> at the bottom-right of Xcode. The object library can be shown by navigating to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Object Library</strong>, or by pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">Control</em> + <em class="calibre11">3</em>. Click on a view, such as the <strong class="calibre2">Label</strong>, and drag it into the view:</p><div><img src="img/00039.jpeg" alt="Adding views to the scene" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The label's text <a id="id186" class="calibre1"/>content can be modified by double-clicking on the label in the view and typing or by selecting the object and editing the text attribute in the attributes inspector:</p><div><img src="img/00040.jpeg" alt="Adding views to the scene" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When the element is dragged, blue guide lines may be shown. They suggest locations for the views; the standard is to have a 20pt gap between the views and the edge of the screen and an 8pt gap between adjacent views.</p><p class="calibre8">Drag the <strong class="calibre2">Welcome to Swift</strong> label to the top-left of the scene and then drag a <strong class="calibre2">Button</strong> from the object library into the scene. Rename the button's title to <strong class="calibre2">Press Me</strong>. This button should be a standard space (8pt) away from the label and aligned at the baseline (the level at which the text naturally sits).</p><div><img src="img/00041.jpeg" alt="Adding views to the scene" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="note30" class="calibre1"/>Note</h3><p class="calibre8">At this point, the text in the views is hardcoded in the user interface file and the alignment is manual, which means that the views will not resize if the parent view is modified. These problems will be addressed in the <em class="calibre11">Connecting views to outlets in Swift</em> and <em class="calibre11">Using Auto Layout</em> sections later in this chapter.</p></div><p class="calibre8">To view the <a id="id187" class="calibre1"/>storyboard in the simulator, click on the <strong class="calibre2">Play</strong> button at the top or press <em class="calibre11">Command</em> + <em class="calibre11">R</em> to run the application. A window should be shown with <strong class="calibre2">Welcome to Swift</strong> and <strong class="calibre2">Press Me</strong>. At this stage, pressing the button will have no effect, which will be fixed in the next section.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec53" class="calibre1"/>Segues</h2></div></div></div><p class="calibre8">A <em class="calibre11">segue</em> is a <a id="id188" class="calibre1"/>transition to a different scene in a storyboard. Segues can be hooked up to views on the screen or can be triggered via code. The most common transitions are when the user has selected a view in the user interface, such as a button, a table row, or a details icon, and a new scene is displayed.</p><p class="calibre8">To demonstrate a segue, a <a id="id189" class="calibre1"/>new scene is required. Drag a <strong class="calibre2">View Controller</strong> from the object library and drop it onto the storyboard. The exact location of the view controller doesn't matter, but conventionally, scenes are organized from left to right in the order in which they will be viewed, so dropping it on the right-hand side of the existing view controller is recommended, as shown in the following screenshot:</p><div><img src="img/00042.jpeg" alt="Segues" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Once the <strong class="calibre2">View Controller</strong> has been added, drop a label onto the top-left and change the text to <strong class="calibre2">Please do not press this button again</strong>. This will present a visual clue that the screen has changed when the segue is followed.</p><p class="calibre8">Now, select the <strong class="calibre2">Press Me</strong> button <a id="id190" class="calibre1"/>and press the <em class="calibre11">Control</em> key while dragging the mouse to the newly created view controller. When the mouse button is released, a pop-up menu will be shown with a number of options that are grouped into <strong class="calibre2">Action Segue</strong> and <strong class="calibre2">Non-Adaptive Action Segue</strong>. The former is preferred; the latter is only there for backward compatibility and might be removed in the future.</p><div><img src="img/00043.jpeg" alt="Segues" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip34" class="calibre1"/>Tip</h3><p class="calibre8">Alternatively, the object can be selected from the <em class="calibre11">document outline</em> on the left, and dragged to the object below in the document outline. It is possible to drag from the view in the editor area to an object in the document outline and vice versa. Dragging to the document outline is sometimes faster and more accurate, especially when there are multiple scenes in a storyboard. The document outline can be displayed by navigating to <strong class="calibre2">Editor</strong> | <strong class="calibre2">Show Document Outline</strong>, if it is not visible, or by clicking on the icon at the bottom-left of the editor.</p></div><p class="calibre8">Choose the <strong class="calibre2">Show</strong> option and a segue will be created between the two views. This is represented as an arrow connecting them and another object in the document outline. The icon inside the <a id="id191" class="calibre1"/>circular-segue line shows what kind of transition will occur; a <strong class="calibre2">push</strong> will have an arrow pointing to the left, while <strong class="calibre2">present modally</strong> will be represented as a square box. The <strong class="calibre2">popover</strong> type will show a small popover icon in the segue.</p><div><img src="img/00044.jpeg" alt="Segues" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Run the application in the simulator and click the <strong class="calibre2">Press Me</strong> button. A window should slide up and display the second message.</p><div><h3 class="title2"><a id="note31" class="calibre1"/>Note</h3><p class="calibre8">There will be no way to dismiss or exit the second screen. This is intentional and will be fixed in the next section.</p></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec28" class="calibre1"/>Adding a navigation controller</h1></div></div></div><p class="calibre8">When <a id="id192" class="calibre1"/>there are multiple screens to be displayed, a parent controller is required to keep track of which screen is currently being shown and what the next step (or previous step) is. This is the purpose of a <em class="calibre11">navigation controller</em>; although it has no direct visual representation, it is represented as a scene in a storyboard and can affect the layout of the individual elements in the storyboard.</p><p class="calibre8">To embed the initial scene into a navigation controller, select the initial view and navigate to <strong class="calibre2">Editor</strong> | <strong class="calibre2">Embed In</strong> | <strong class="calibre2">Navigation Controller</strong>. This will create a new navigation controller view and place it to the left-hand side of the first scene. It will also change the initial view controller to the navigation controller and set up a <em class="calibre11">relationship segue</em> with the <a id="id193" class="calibre1"/>name <strong class="calibre2">root view controller</strong> between the navigation controller and the first scene that is represented by an icon that is similar to a percent symbol but with the line rotated the other way:</p><div><img src="img/00045.jpeg" alt="Adding a navigation controller" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">It will be necessary to move the label and button below the newly added navigation bar so that they are still visible. This can either be done before the navigation controller is introduced or by selecting through overlapping objects.</p><p class="calibre8">To temporarily hide the navigation bar, delete the relationship segue between the navigation controller and the welcome scene, and the navigation bar will disappear. This will allow the objects to be selected and moved elsewhere temporarily in order to be repositioned. To add it back again, press the <em class="calibre11">Control</em> key and drag the mouse cursor from the navigation controller to the welcome scene and choose <strong class="calibre2">root view controller</strong> under <strong class="calibre2">Relationship Segue</strong>; or alternatively, set the <strong class="calibre2">Top Bar</strong> attribute to <strong class="calibre2">None</strong> in the attribute inspector.</p><p class="calibre8">Alternatively, to select through overlapping objects, first select the object in the document outline so that the location is shown with the drag boxes. Then, press the <em class="calibre11">Shift</em> key and right-click it for a pop-up menu of the objects under the mouse position at any depth. From here, the object can be selected and then moved with the arrow keys to reposition them elsewhere.</p><div><img src="img/00046.jpeg" alt="Adding a navigation controller" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Now when <a id="id194" class="calibre1"/>the application is run and the <strong class="calibre2">Press Me</strong> button is tapped, the message will be shown again but with a <strong class="calibre2">&lt; Back</strong> navigation menu item as well, as shown here:</p><div><img src="img/00047.jpeg" alt="Adding a navigation controller" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec54" class="calibre1"/>Naming scenes and views</h2></div></div></div><p class="calibre8">When<a id="id195" class="calibre1"/> working with many scenes, calling all of them <strong class="calibre2">View Controller Scene</strong> is not helpful. To distinguish between them, the controllers can be renamed in the storyboard editor.</p><p class="calibre8">To change <a id="id196" class="calibre1"/>the name of a scene, select its view controller in the document outline and go to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Attributes Inspector</strong> or press <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">3</em>, and then drill down to the <strong class="calibre2">Document</strong> section where the label hint will read <strong class="calibre2">Document Label</strong>. Typing in another value, such as <code class="literal">Press</code> <code class="literal">Me</code>, <code class="literal">Message</code>, or <code class="literal">Initial</code> will rename both the view controller and the scene in the document outline:</p><div><img src="img/00048.jpeg" alt="Naming scenes and views" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip35" class="calibre1"/>Tip</h3><p class="calibre8">By default, the name of the element in the document outline is taken from the text value of the element or the type if no text value is present. This means that updates to the label or button text will be automatically reflected in the outline. However, it is possible to add document labels to any view in the document outline.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec29" class="calibre1"/>Swift and storyboards</h1></div></div></div><p class="calibre8">So far in <a id="id197" class="calibre1"/>this chapter, the storyboard content does not involve any Swift or other programming content—it used the drag and drop capabilities of the storyboard editor. Fortunately, it is easy to integrate Storyboard and Swift using a <em class="calibre11">custom view controller</em>.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec55" class="calibre1"/>Custom view controllers</h2></div></div></div><p class="calibre8">Each<a id="id198" class="calibre1"/> standard view controller has a corresponding superclass (listed in the <em class="calibre11">Scenes and view controllers</em> section previously in this chapter). This can be replaced with a custom subclass, which then has the ability to influence and change what happens in the user interface. To replace the message in the <strong class="calibre2">Message Scene</strong>, create a new file named <code class="literal">MessageViewCotroller.swift</code> with the following content:</p><div><pre class="programlisting">import UIKit
class MessageViewController: UIViewController {
}</pre></div><p class="calibre8">Having created this class, it can be associated with the view controller by selecting it in the storyboard and then switching to the identity inspector by navigating to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Identity Inspector</strong> or pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">3</em>. In the <strong class="calibre2">Custom Class</strong> section, the <strong class="calibre2">Class</strong> will show <code class="literal">UIViewController</code> as a hint. Entering <code class="literal">MessageViewController</code> here will associate the custom controller with the view controller<a id="id199" class="calibre1"/>:</p><div><img src="img/00049.jpeg" alt="Custom view controllers" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">This will have no visible impact to the message scene; running the application will be the same as before. To show a difference, create a <code class="literal">viewDidLoad</code> method with an <code class="literal">override</code> keyword and then create a random color for the background as follows:</p><div><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()
  let red = CGFloat(drand48())
  let green = CGFloat(drand48())
  let blue = CGFloat(drand48())
  view.backgroundColor = UIColor(
    red:red,
    green:green,
    blue:blue,
    alpha:1.0
  )
}</pre></div><p class="calibre8">Running the application and pressing the <strong class="calibre2">Press Me</strong> button results in a differently colored view being<a id="id200" class="calibre1"/> created each time.</p><div><h3 class="title2"><a id="tip36" class="calibre1"/>Tip</h3><p class="calibre8">This does not demonstrate good user experience, but is used here to demonstrate the fact that <code class="literal">viewDidLoad</code> is called each time the segue occurs. It is typically used to set up view state just before showing the view to the user.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec56" class="calibre1"/>Connecting views to outlets in Swift</h2></div></div></div><p class="calibre8">Each <a id="id201" class="calibre1"/>view controller has an implicit relationship with its view, and each view has its own <code class="literal">backgroundColor</code> property. This example will work regardless of what the view happens to be. What if the view controller needs to interact with the view's content in some way? The view controller could walk the view programmatically, looking for a certain type of view or for a view with a particular identifier, but there is a better way to do this.</p><p class="calibre8">Both the interface builder and storyboard have the concept of <em class="calibre11">outlets</em>, which are a predefined point in a class that can be exposed and can have connections between the UI and the code. In Objective-C, this was done with an <code class="literal">IBOutlet</code> qualifier. In Swift, this is done with a <code class="literal">@IBOutlet</code> attribute. In effect, they are variables that can be bound to the UI.</p><div><h3 class="title2"><a id="note32" class="calibre1"/>Note</h3><p class="calibre8">When defining a class with a <code class="literal">@IBOutlet</code> attribute, the <code class="literal">@objc</code> attribute is also implicitly added marking this Swift class as using the Objective-C runtime. As all the <code class="literal">UIKit</code> classes are already Objective-C types, this doesn't matter; but for types where the Objective-C runtime should not be used, care should be taken when adding attributes, such as <code class="literal">@IBOutlet</code>. The <code class="literal">@objc</code> attribute can also be used for non-UI classes that need to use the Objective-C runtime.</p></div><p class="calibre8">The following steps are required to create an outlet in a Swift view controller:</p><div><ol class="orderedlist"><li class="listitem" value="1">Define an outlet in the view controller code with <code class="literal">@IBOutlet</code> <code class="literal">weak</code> <code class="literal">var</code> of an optional type of the connected view.</li><li class="listitem" value="2">Connect the outlet in the view controller to the view by pressing <em class="calibre11">Control</em> and dragging the mouse cursor<em class="calibre11"> </em>from the view to the outlet.</li></ol><div></div><p class="calibre8">To do this, open the <strong class="calibre2">assistant editor</strong>
<a id="id202" class="calibre1"/> by pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">Enter</em> or by going to <strong class="calibre2">View</strong> | <strong class="calibre2">Assistant Editor</strong> | <strong class="calibre2">Show Assistant Editor</strong>. This will show a side-by-side view of the associated source file. This is useful to display the associated custom view controller for a selected view in the storyboard (or the interface file).</p><p class="calibre8">Once the assistant editor is displayed, open the <strong class="calibre2">Message Scene</strong> from the storyboard and press <em class="calibre11">Control</em> while dragging the mouse cursor<em class="calibre11"> </em>from the message label to the assistant editor and dropping it just after the class declaration:</p><div><img src="img/00050.jpeg" alt="Connecting views to outlets in Swift" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">A pop-up dialog <a id="id203" class="calibre1"/>will ask what to call the field and present some other information; ensure <strong class="calibre2">Outlet</strong> is selected, name it <code class="literal">message</code>, and ensure that it has a <strong class="calibre2">Weak</strong> storage type:</p><div><img src="img/00051.jpeg" alt="Connecting views to outlets in Swift" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">This will result in the following line being added to the <code class="literal">MessageViewController</code> class, and it will wire up the label to the property as follows:</p><div><pre class="programlisting">class MessageViewController: UIViewController {
  @IBOutlet weak var message: UILabel!
  … 
}</pre></div><p class="calibre8">The <code class="literal">@IBOutlet</code> attribute (defined in <code class="literal">UIKit</code>) allows interface builder to bind to the property. The <strong class="calibre2">Weak</strong> storage type—which can be changed in the pop-up dialog—indicates that this class will not hold a strong reference to the object so that when the view is dismissed, the controller will not own it.</p><div><h3 class="title2"><a id="tip37" class="calibre1"/>Tip</h3><p class="calibre8">Generally, all <code class="literal">@IBOutlet</code> connections should be marked as <code class="literal">weak</code>, because the storyboard or the <code class="literal">xib</code> file is the owner of the object, not the controller. Ownership does not pass when assigning properties from interface builder. Changing it to something other than <code class="literal">weak</code> may lead to circular references. As Swift uses a reference counting approach to determine when an object is no longer referenced, a circular reference between strong references can cause memory leaks.</p></div><p class="calibre8">The exclamation mark<a id="id204" class="calibre1"/> on the end of the type <code class="literal">UILabel!</code> indicates that it is an <em class="calibre11">implicitly unwrapped optional</em>. This property is stored as an optional type, but the accessor code will automatically unwrap it at the point of use. As the view controller will not have a reference to the <code class="literal">message</code> at the point of initialization, it will be <code class="literal">nil</code>, so it must be stored as an optional. However, as the value is known to not be <code class="literal">nil</code> after the view has been loaded, the implicitly unwrapped optional saves the <code class="literal">?.</code> calls that would otherwise be used each time it is used.</p><div><h3 class="title2"><a id="note33" class="calibre1"/>Note</h3><p class="calibre8">An implicitly unwrapped optional is still an optional value under the covers; it is syntactic sugar to unwrap it at the point of use each time the value is accessed. When the view is loaded, but before the <code class="literal">viewDidLoad</code> method is called, the outlet's value will be wired to the instantiated view on screen.</p></div><p class="calibre8">The connections can be seen in the connections inspector, which can be displayed by selecting the message label and pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">6</em> or by navigating to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Connections Inspector</strong>. The inspector can also be used to remove existing connections or add new ones.</p><div><img src="img/00052.jpeg" alt="Connecting views to outlets in Swift" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Now that the connection has been made between the message view and the custom controller, instead of changing the background color of the view, change the background color of the <code class="literal">message</code> instead, as follows:</p><div><pre class="programlisting">message.backgroundColor = UIColor(...)</pre></div><p class="calibre8">Run the <a id="id205" class="calibre1"/>application and the message will have the background color changed each time the scene is displayed:</p><div><img src="img/00053.jpeg" alt="Connecting views to outlets in Swift" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec57" class="calibre1"/>Calling actions from interface builder</h2></div></div></div><p class="calibre8">In the <a id="id206" class="calibre1"/>same way that outlets are variables for interface builder to assign to (or read from), <em class="calibre11">actions</em> are methods/functions that can be triggered from a view in interface builder. The <code class="literal">@IBAction</code> attribute is used to annotate a method or function that can be wired up.</p><div><h3 class="title2"><a id="note34" class="calibre1"/>Note</h3><p class="calibre8">As with <code class="literal">@IBOutlet</code>, using <code class="literal">@IBAction</code> on a function causes the compiler to implicitly add a <code class="literal">@objc</code> attribute to the class in order to force it to use the Objective-C runtime.</p></div><p class="calibre8">To change the message when a button is invoked, a suitable <code class="literal">changeMessage</code> is required. Historically, the signature for an action method was one that returned <code class="literal">void</code>, marked with <code class="literal">IBAction</code>, and took a <code class="literal">sender</code> argument, which could be any object. In Swift, this signature translates to the following:</p><div><pre class="programlisting">@IBAction func changeMessage(sender:AnyObject) { … }</pre></div><p class="calibre8">However, with Swift, the <code class="literal">sender</code> is no longer a required argument. It is, therefore, possible to bind an action with the following signature:</p><div><pre class="programlisting">@IBAction func changeMessage() { … }</pre></div><p class="calibre8">If the signature is changed, any existing bindings must be deleted and recreated, as an error will be reported otherwise.</p><div><h3 class="title2"><a id="tip38" class="calibre1"/>Tip</h3><p class="calibre8">It is difficult to convert from a <code class="literal">func</code> that doesn't take an argument to one that takes an argument. It is easier to have a <code class="literal">func</code> that takes an argument that isn't required. If not sure, choose the function signature that takes a sender object and then just ignore it.</p></div><p class="calibre8">The <code class="literal">changeMessage</code> function <a id="id207" class="calibre1"/>can randomly select a message and set the text on the label, as follows:</p><div><pre class="programlisting">let messages = [
  "Ouch, that hurts",
  "Please don't do that again",
  "Why did you press that?",
]
@IBAction func changeMessage() {
  message.text = messages[
    Int(arc4random_uniform(
      UInt32(messages.count)))]
}</pre></div><p class="calibre8">When the function is invoked, the message text will change to a value that is defined in the array. To call the function, it needs to be wired up in the storyboard editor. Add a new <strong class="calibre2">Button</strong> from the object library to the message scene, with a <code class="literal">Change Message</code> label. To connect it to the action, press <em class="calibre11">Control </em>and drag the mouse cursor from the <strong class="calibre2">Change Message</strong> button in <strong class="calibre2">Message Scene</strong> and drop it on the <strong class="calibre2">Message</strong> view controller at the top:</p><div><img src="img/00054.jpeg" alt="Calling actions from interface builder" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">A pop-up menu will then display the outlets and actions that this can be connected to. Select the <strong class="calibre2">changeMessage</strong> from the list:</p><div><img src="img/00055.jpeg" alt="Calling actions from interface builder" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip39" class="calibre1"/>Tip</h3><p class="calibre8">If <strong class="calibre2">changeMessage</strong> isn't listed, check that the view controller is defined to be <code class="literal">MessageViewController</code> and verify that the <code class="literal">@IBAction</code> attribute is added to the <code class="literal">changeMessage</code> function.</p></div><p class="calibre8">Now when<a id="id208" class="calibre1"/> the application is run and the <strong class="calibre2">Change Message</strong> button is pressed, the label will change to one of the hardcoded values.</p><div><h3 class="title2"><a id="note35" class="calibre1"/>Note</h3><p class="calibre8">The message label will not change in size because the view has no automatic layout associated with it. The <em class="calibre11">Using Auto Layout</em> section in this chapter explains how to fix this problem.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec58" class="calibre1"/>Triggering a segue with code</h2></div></div></div><p class="calibre8">A <a id="id209" class="calibre1"/>segue can be triggered programmatically from code if additional setup is required or if there are data parameters that need to be passed from one view controller to another (such as the currently-selected object).</p><p class="calibre8">Segues have named <em class="calibre11">segue identifiers</em>, which are used in code to trigger specific segues. To test this out, drag a new <strong class="calibre2">View Controller</strong> from the library (by pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">Control</em> + <em class="calibre11">3</em> or by navigating to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Object Library</strong>) onto the main storyboard and name it <code class="literal">About</code>. Drag a <strong class="calibre2">Label</strong> and give it the text: <code class="literal">About</code> <code class="literal">this</code> <code class="literal">App</code>.</p><p class="calibre8">Next, create <a id="id210" class="calibre1"/>a segue by pressing <em class="calibre11">Control</em> and dragging the mouse cursor between the <strong class="calibre2">Message</strong> scene to the new scene. The named identifier can be set as <code class="literal">about</code> through the attributes inspector (shown by pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">4</em> or by navigating to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Attributes Inspector</strong>):</p><div><img src="img/00056.jpeg" alt="Triggering a segue with code" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Finally, drag a new <strong class="calibre2">Button</strong> to the <strong class="calibre2">Change Message</strong> scene and call it <code class="literal">About</code>. Instead of directly calling the segue, create a new <code class="literal">@IBAction</code> called <code class="literal">about</code>. When this button is pressed, the following code will be run:</p><div><pre class="programlisting">@IBAction func about(sender: AnyObject) {
  performSegueWithIdentifier("about", sender: sender)
}</pre></div><p class="calibre8">When the <strong class="calibre2">About</strong> button is pressed, the <strong class="calibre2">About</strong> screen will be displayed.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec59" class="calibre1"/>Passing data with segues</h2></div></div></div><p class="calibre8">Typically, in a <a id="id211" class="calibre1"/>master-detail application, data needs to be passed from one scene to the next. This may be the currently selected object, or it may require additional information to be processed. When the segue is called, the view controller's <code class="literal">prepareForSegue</code> method is called, with the destination segue and the sending object. This allows any internal state of the view controller to be passed to the new segue.</p><p class="calibre8">The <code class="literal">UIStoryboardSegue</code> contains an identifier, which was set in the previous section. As the <code class="literal">prepareForSegue</code> method may be called on the <code class="literal">MessageViewController</code> for any number of segues, it is common for a <code class="literal">switch</code> statement to be used on the identifier so that the <a id="id212" class="calibre1"/>right action can be taken. For a single segue, an <code class="literal">if</code> statement can be used as follows:</p><div><pre class="programlisting">override func prepareForSegue(segue: UIStoryboardSegue,
  sender: AnyObject?) {
  if segue.identifier == "about" {
      let dest = segue.destinationViewController as UIViewController
      dest.view.backgroundColor = message.backgroundColor
  }
}</pre></div><p class="calibre8">Here, the <code class="literal">prepareForSegue</code> method is called with <code class="literal">segue</code>, which contains the destination (the scene) and the identifier. The <code class="literal">if</code> statement ensures that the correct identifier is matched. In this case, the background color of the message label (which is chosen randomly when the view is loaded) is passed to the destination view's background color; however, any property on either the view controller or the view can be set here.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Using Auto Layout</h1></div></div></div><p class="calibre8">
<strong class="calibre2">Auto Layout</strong> has<a id="id213" class="calibre1"/> been part of Xcode for the last few releases, and it was added to support an evolution from the previous springs-and-struts approach that <a id="id214" class="calibre1"/>predated Mac OS X. First released on iOS 6.0, it has evolved to the point where size-independent displays can now be created as the default.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec60" class="calibre1"/>Understanding constraints</h2></div></div></div><p class="calibre8">In Xcode 5, interface builder <a id="id215" class="calibre1"/>enabled Auto Layout by default for the first time. When a label was dragged to the top or bottom of the parent view, a dotted blue line would indicate that the label was correctly spaced, and a <em class="calibre11">constraint</em> would be generated.</p><p class="calibre8">However, in many cases, the constraints weren't created correctly or had undesired effects. For example, positioning a button in the center at the top may not maintain the location depending on whether the constraint being added was absolute (200px from the right) or relative (in the center of the screen). In both cases, the button may look like it was positioned correctly, only to fail when the device's screen orientation rotates or it is run on a screen of different size.</p><p class="calibre8">In Xcode 6, although the guidelines are still displayed as views are moved around, relative constraints are not created. Instead, each view is given an exact hardcoded position that does not change with screen rotation or with a change of display size.</p><p class="calibre8">In Xcode 7, Auto Layout is<a id="id216" class="calibre1"/> the preferred way of creating applications, and views are implicitly selected for Auto Layout. In addition, separate user interfaces can be created for different <em class="calibre11">size classes</em>, which allows applications such as Calculator and Mail to provide different user interfaces that are based on the device's rotation. On larger screen devices that have the ability to dock applications next to each other, the size classes are used to determine how each application looks and behaves.</p><p class="calibre8">Constraints must be added manually to the views in order to restore the right behavior, and as manual constraints are added, absolute constraints are removed.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec61" class="calibre1"/>Adding constraints</h2></div></div></div><p class="calibre8">In the <a id="id217" class="calibre1"/>example application, the <strong class="calibre2">Welcome to Swift</strong> label and the <strong class="calibre2">Press Me</strong> button are next to each other, a small distance from the top. However, when the screen is rotated in the simulator, by pressing <em class="calibre11">Command</em> and the left or right arrow keys, the spacing between the labels and the top doesn't change, so the labels look further away.</p><p class="calibre8">The desired outcome is that the label remains a standard distance away from the top-left edge and the button remains aligned to the label's baseline.</p><p class="calibre8">There are two separate constraints that need to be applied to the label:</p><div><ul class="itemizedlist"><li class="listitem">Be a standard vertical distance away from the top of the parent view</li><li class="listitem">Be a standard horizontal distance away from the left of the parent view</li></ul></div><p class="calibre8">There are also two constraints that need to be applied to the button:</p><div><ul class="itemizedlist"><li class="listitem">Be aligned with the label's baseline</li><li class="listitem">Be a standard vertical distance away from the label</li></ul></div><p class="calibre8">There are different ways of adding a constraint, which are covered in the following sections.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec06" class="calibre1"/>Adding a constraint with drag and drop</h3></div></div></div><p class="calibre8">A <a id="id218" class="calibre1"/>quick way to add a constraint is to press <em class="calibre11">Control</em> and drag the mouse cursor from the view to the top of the container. Depending on the direction of the drag, different options will be displayed. Dragging vertically upwards presents the vertical alignment options:</p><div><img src="img/00057.jpeg" alt="Adding a constraint with drag and drop" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The <strong class="calibre2">Vertical Spacing to Top Layout Guide</strong> option will insert a recommended break between the <a id="id219" class="calibre1"/>navigation bar and the label. There is a <strong class="calibre2">Center Horizontally in Container</strong> option, which is also a vertical separation but not appropriate in this case.</p><p class="calibre8">The other types that are active—<strong class="calibre2">Equal Widths</strong>, <strong class="calibre2">Equal Heights</strong>, and <strong class="calibre2">Aspect Ratio</strong>—allow multiple views to be sized relative to each other.</p><p class="calibre8">Dragging horizontally will show a different set of options at the top, including <strong class="calibre2">Leading Space to Container Margin</strong> and <strong class="calibre2">Center Vertically in Container</strong>:</p><div><img src="img/00058.jpeg" alt="Adding a constraint with drag and drop" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If the mouse is dragged at an angle, both sets of options will be displayed, as follows:</p><div><img src="img/00059.jpeg" alt="Adding a constraint with drag and drop" class="calibre9"/></div><p class="calibre10"> </p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec07" class="calibre1"/>Adding constraints to the Press Me scene</h3></div></div></div><p class="calibre8">To set the <a id="id220" class="calibre1"/>constraints for the welcome label, press <em class="calibre11">Control</em> and drag the mouse cursor from the label to the left, and select <strong class="calibre2">Leading Space to Container Margin</strong>. An orange line will appear, and an orange outline will be displayed:</p><div><img src="img/00060.jpeg" alt="Adding constraints to the Press Me scene" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="note36" class="calibre1"/>Note</h3><p class="calibre8">The orange line indicates an <em class="calibre11">ambiguous constraint</em>, which means that some constraints have been added to the view but are not enough to uniquely position the label. In this case, the label is positioned from the left of the container, but it could be anywhere with respect to the top or bottom of the screen. The red dotted lines show where the Auto Layout algorithm will place the view with the constraints that are currently specified.</p></div><p class="calibre8">To resolve this problem, press <em class="calibre11">Control</em> and drag the mouse pointer from the label to the top and select <strong class="calibre2">Vertical Spacing to Top Layout Guide</strong>. Once this is done, two constraints will be displayed in blue, which represent the constraints about the object:</p><div><img src="img/00061.jpeg" alt="Adding constraints to the Press Me scene" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip40" class="calibre1"/>Tip</h3><p class="calibre8">If there is an orange box surrounding the label along with a warning that says <strong class="calibre2">Frame for label will be different at run-time</strong>, this can be fixed with the <strong class="calibre2">Update Frames</strong> option that is discussed in the next section.</p></div><p class="calibre8">The constraints <a id="id221" class="calibre1"/>can also be seen in the document outline on the left-hand side:</p><div><img src="img/00062.jpeg" alt="Adding constraints to the Press Me scene" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If the application is run now and rotated, the label is correctly repositioned, but the button is not:</p><div><img src="img/00063.jpeg" alt="Adding constraints to the Press Me scene" class="calibre9"/></div><p class="calibre10"> </p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec08" class="calibre1"/>Adding missing constraints</h3></div></div></div><p class="calibre8">To find<a id="id222" class="calibre1"/> out which views have no constraints, click through the views one by one in the document outline and check the size inspector (which can be seen by pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">5</em> or by navigating to <strong class="calibre2">View</strong> | <strong class="calibre2">Utilities</strong> | <strong class="calibre2">Show Size Inspector</strong>). For views that have constraints set, there will be content shown <a id="id223" class="calibre1"/>under the <strong class="calibre2">Constraints</strong> section:</p><div><img src="img/00064.jpeg" alt="Adding missing constraints" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If a view has no constraints associated with it, then this section will be empty. Interface builder has an option to create missing constraints for selected views, which can be accessed by navigating to <strong class="calibre2">Editor</strong> | <strong class="calibre2">Resolve Auto Layout Issues</strong> | <strong class="calibre2">Add Missing Constraints</strong> or from the <strong class="calibre2">Resolve Auto Layout Issues</strong> menu at the bottom-right, which looks like a triangle between two vertical lines.</p><p class="calibre8">When selected, the options in the top-half apply to selected views only, while the options in the bottom-half work on all the views in the selected view controller:</p><div><img src="img/00065.jpeg" alt="Adding missing constraints" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The options <a id="id224" class="calibre1"/>include:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Update Frames</strong>: This is based on the current constraints; it automatically repositions and resizes the views to correspond to what will happen at runtime</li><li class="listitem"><strong class="calibre2">Update Constraints</strong>: This is based on the current positions of the objects and attempts to recalculate the existing constraints (but not create new ones)</li><li class="listitem"><strong class="calibre2">Add Missing Constraints</strong>: This is based on the approximate positioning of the components and adds constraints that creates the same result</li><li class="listitem"><strong class="calibre2">Reset to Suggested Constraints</strong>: This is equivalent to clearing all the constraints associated with the views and then reading missing constraints</li><li class="listitem"><strong class="calibre2">Clear Constraints</strong>: This removes all the constraints associated with the views</li></ul></div><p class="calibre8">To add constraints to the <strong class="calibre2">Press Me</strong> button, click on the view and then navigate to <strong class="calibre2">Editor</strong> | <strong class="calibre2">Resolve Auto Layout Issues</strong> | <strong class="calibre2">Selected Views</strong> | <strong class="calibre2">Add Missing Constraints</strong>. There should be two constraints added: a baseline alignment with the label, and a horizontal space to the label.</p><p class="calibre8">To see the effect of the <strong class="calibre2">Update Frames</strong> operation, move the label and the button to different places in the view controller. Orange lines and dotted outlines will be shown, indicating that there is an ambiguous constraint. Navigate to <strong class="calibre2">Choose Editor</strong> | <strong class="calibre2">Resolve Auto Layout Issues</strong> | <strong class="calibre2">All Views in View Controller</strong> | <strong class="calibre2">Update Frames</strong>, and the views will automatically move to the right places and resize.</p><div><h3 class="title2"><a id="note37" class="calibre1"/>Note</h3><p class="calibre8">The views are sized to their <em class="calibre11">intrinsic size</em>, which is the size that just fits the content. For example, a label's intrinsic size is the size in which the text can fit into the space in the current font. This can be used to fix the size of the label in the <strong class="calibre2">Message Scene</strong>; by adding constraints, the changing text will result in the intrinsic size being recalculated, and the background color will be correctly sized.</p></div><p class="calibre8">Now, run the <a id="id225" class="calibre1"/>application and rotate the device, by pressing <em class="calibre11">Command</em> and the left and right arrow keys to see the view resize itself correctly.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter introduced the concept of storyboards as a sequence of scenes that are connected with segues, which can either be wired with the GUI or driven programmatically. Finally, Auto Layout can be used to build applications that respond to differences in screen orientation or size, as well as respond to changes in view size or other properties.</p><p class="calibre8">The next chapter will present how to create custom views in Swift.</p></div></body></html>