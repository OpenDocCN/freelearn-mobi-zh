- en: Part 1. Module 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Learning Java by Building Android Games***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Get ready for a fun-filled experience of learning Java by developing games
    for the Android platform*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Chapter 1. Why Java, Android, and Games?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to *Learning Java by Building Android Games*, which I hope is just
    the beginning of your exciting journey into designing and writing games. By the
    end of this book, we will have made four complete games: a math quiz with dynamically
    increasing difficulty, a memory game in the style of the classic Simon toy, a
    pong-style squash game, and a clone of the classic *Snake* game.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides these games, we will build more than a dozen working apps to practice
    and demonstrate individual concepts to aid our learning of Java, Android, and
    games. Our games and apps will feature sound FX, graphics, and animations. We
    will learn everything from using the standard Android **User Interface** (**UI**)
    designer to creating smooth animations by plotting individual pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Although I will encourage you to work with me and implement the specific projects
    that are detailed step by step throughout the book, I fully expect that once you
    grasp the different concepts, you will want to use them in your own unique creations
    without delay. This is exactly what I hope you will be inspired to do.
  prefs: []
  type: TYPE_NORMAL
- en: The game projects themselves are not the objective of the book but the means
    to a much loftier goal. By the end of the book, you will be able to design and
    implement your own 2D Android games, to sell or just to give away, on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a bit of ground work to cover first, but I promise it won't take long
    and it won't be complicated either. Anyone can learn to program.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are so many differing opinions among experts, which breeds confusion
    among beginners concerning the best ways of learning to program. So it is a good
    idea to look at why learning Java, Android, and games is an ideal pathway for
    beginners. This will be the first thing we will discuss in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Is this book for me?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should I use games to learn to program?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should I learn Java and Android?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is this book for me?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have already decided that Java, Android, or games are what you want to
    learn, then the next question might be, "Is this specific book for me?".
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of Java books for beginners and books by much more accomplished
    authors and programmers than myself. I have read many of them and admire the authors.
    However, when these books drift away—which they all do—to topics such as Java-native
    interfaces, web browser applets, or server-side remote communication, I sometimes
    find myself questioning their immediate relevance to me.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, at least subconsciously, my commitment would wane and the learning
    process would slow or stop.
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to learn pure Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you just want to learn Java on its own, this book will be a solid start.
    Although the Android stuff might be considered overhead to your pure Java learning,
    this is much less than the multitude of potentially unnecessary topics that would
    be introduced in any other Java book. The only caveat with this book is that the
    necessary overhead is all at the beginning. But once this minimal overhead is
    cleared, we can focus quite intently on Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to the amount of overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: It will take about six pages to set up our programming environment in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will take [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to get familiar with the Android tools, create
    your first working project, and glimpse your first real Java code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From then on, it will be nearly pure Java and building games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will soon see that the tiny amount of overhead is not excessive and is well
    worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: If Android is your focus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If it was Android itself that made you look at this book, then I am proud to
    say this is the first book that will teach you Android without assuming you have
    any prior Java or programming knowledge whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Where this book will take you
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this book, you will be able to easily take one of many paths
    including these:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning Java at a higher level for any platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate level Android learning including pure game frameworks (which will
    be covered in more detail in [Chapter 9](ch09.html "Chapter 9. Making Your Game
    the Next Big Thing"), *Making Your Game the Next Big Thing*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A higher level of games development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much easier tackling of any modern object-oriented language for things such
    as iOS, Windows, or web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So if you know you want to learn Android or Java, hopefully, I have gone some
    way to make you commit to the way this book will help you. But why games, Android,
    or Java at all?
  prefs: []
  type: TYPE_NORMAL
- en: Why build games to learn to program?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fun, of course! But there are other reasons too. Successfully running any program
    we have written is immensely satisfying, even more so when it involves using some
    code that we previously didn't understand.
  prefs: []
  type: TYPE_NORMAL
- en: But making our own games, as you will soon realize, creates a feeling of pleasure
    that is not easy to describe—it has to be experienced. Then there are added bonuses
    of sharing our creations with friends on a phone or tablet or even sharing them
    publicly on the Google Play Store, and you might realize that once you start making
    games, you can't stop.
  prefs: []
  type: TYPE_NORMAL
- en: As we create more complex games steadily, you'll realize that all techniques
    and pieces of code can be rehashed to create other games, and you can then start
    planning your very own unique masterpieces. This is exhilarating to say the least.
  prefs: []
  type: TYPE_NORMAL
- en: And as with many subjects, the more we practice the better we get. So games
    are a perfect way to start learning to program Java. However, most beginners'
    books for Android games require a fairly high level of Java knowledge. But as
    we will see, it is perfectly possible to keep the practical examples as fun game
    projects and still start with the very basics of Java.
  prefs: []
  type: TYPE_NORMAL
- en: There is a slight trade-off in doing things this way. We will not always approach
    the working game examples in a "by-the-book" manner. This is to avoid the problem
    of doing cartwheels before mastering the forward roll.
  prefs: []
  type: TYPE_NORMAL
- en: The learning outcome priority will always be the Java programming concept, followed
    by understanding the Android environment and game design principles. Having said
    that, we will closely examine and practice plenty of Android and game programming
    fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, from what we have just discussed, you can probably surmise that it
    would have been possible to teach a bit more Java in the same number of pages
    if we hadn't been making games.
  prefs: []
  type: TYPE_NORMAL
- en: This is true, but then we lose all the benefits that come with using games as
    the subject matter. Making games really can be a joy, and when our brains are
    open and eager for information, we will learn much faster. The minimal overhead
    of learning this way is negated a hundred times over. If games don't interest
    you in the slightest, then there are plenty of Java beginners' guides out there
    that take the traditional approach. Just don't expect quite the same thrill as
    when you publish your first game with online leaderboards and achievements.
  prefs: []
  type: TYPE_NORMAL
- en: Why Android and Java?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A part of successful learning is the commitment by the student, not just to
    do the work, but in their belief that they are doing the right thing in the right
    way. So many technology-based courses and books don't get that commitment from
    the reader, not subconsciously anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is the students' belief that they might be, partly at least, wasting
    their time with something that is or will soon become outdated or perhaps is not
    quite right for them. This can be true to a large extent with programming. So
    why should you spend your finite time learning Java, on Android?
  prefs: []
  type: TYPE_NORMAL
- en: Android is the fastest evolving and growing OS ever
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At one time, Android updates emerged almost every two months. Even now, they
    emerge about once in six months. By comparison, Windows takes years between versions
    and even iOS updates come only yearly and usually change relatively little between
    versions. Android is obviously evolving and improving at an unprecedented rate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the history of Android versions since Version 1 at [http://www.cnet.com/news/history-of-android/](http://www.cnet.com/news/history-of-android/).
  prefs: []
  type: TYPE_NORMAL
- en: The first humble version of Android was released in 2008, around the same time
    when consumers were already quite excited about the then much flashier iPhone.
    News stories were also reporting that developers were getting rich by selling
    apps in the iTunes app store.
  prefs: []
  type: TYPE_NORMAL
- en: But in the last full year before this book was written, Samsung alone shipped
    more Android units than Apple sold all iOS devices combined. I am not joining
    the war on whose devices are best. I enjoy aspects of both Android and Apple,
    but purely in terms of picking a platform to learn on, you are probably in the
    right place at the right time with Android.
  prefs: []
  type: TYPE_NORMAL
- en: Android developers have great prospects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you might have picked up this book just for the fun and satisfaction that
    comes with learning to program games. But if you decide to develop your learning
    further, you will find that the demand for Android programmers is enormous and
    therefore very lucrative too.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some data suggests salaries in excess of 100,000 US dollars. For more information,
    go to [http://www.indeed.com/salary?q1=Android+Developer&l1=United+States](http://www.indeed.com/salary?q1=Android+Developer&l1=United+States).
  prefs: []
  type: TYPE_NORMAL
- en: Android is open source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What open source means is that although Google develops all the flavors of Android
    that are used on the newest devices, once the code is released, anybody can do
    whatever they like with it. Google only exerts control for a limited amount of
    time.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, most Android users have the pure Google OS or the modified versions
    turned out by big manufacturers such as Samsung and HTC, but there is nothing
    to stop anybody taking the OS and changing, adapting, or converting it into whatever
    they like. In short, Android could never be taken away from the programming community.
  prefs: []
  type: TYPE_NORMAL
- en: Java is here to stay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, so we see Android isn't likely to disappear but could Java become redundant?
    And will your significant time investment be wasted? On Android, as with most
    platforms, you can use many languages and tools. Android, however, was designed
    from the ground up to facilitate Java development. All other languages and tools
    are not invalid but tend to serve a fairly specific purpose, rather than be a
    real alternative to Java. In fact, as far as games are concerned, many of the
    alternatives to a pure Java development environment are also Java-based and require
    a good level of skill in Java to use. For example, the popular LibGDX game development
    library, which allows you to simultaneously make games for Android, iOS, Windows,
    Linux, Mac and even the Web, still uses Java! We will talk more about this in
    [Chapter 9](ch09.html "Chapter 9. Making Your Game the Next Big Thing"), *Making
    Your Game the Next Big Thing*. The point is that Java and Android are tied together
    and will likely thrive together.
  prefs: []
  type: TYPE_NORMAL
- en: Java is not just for Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java has been around a lot longer than Android, since the beginning of the 1990s
    in fact. Although what Java has been used for has evolved and diversified over
    more than two decades, the originally implemented strengths of the language itself
    remain the same today.
  prefs: []
  type: TYPE_NORMAL
- en: Java was designed to be platform- or computer-independent. This is achieved
    by the use of a **virtual machine** (**VM**). This is a program written in another
    language that decodes the Java program that we write and interacts with the computer
    platform it is running on. So as long as there is a VM for the computer you want
    to run your Java program on, with a few caveats, your Java program will work.
    So if you learn Java, you are learning a language that is used everywhere from
    the smart fridge to the Web and most places in between.
  prefs: []
  type: TYPE_NORMAL
- en: It is true, however, that the VM on each platform can and usually does implement
    features to specifically suit the uses it is likely to be put to. A clear example
    of this would be mobile-device-specific features such as sensors, GPS, or the
    built-in camera on many Android devices. Using Java with Android, you can take
    photos, detect the air pressure, and work out exactly where in the world you are.
    Most fridge VMs probably will not do this. So you can't always just run a Java
    program designed for device x on device y, but the language and syntax is the
    same. Learning Java on Android prepares you in a large part for Java in any situation.
    So rest assured that Java isn't going away any time soon.
  prefs: []
  type: TYPE_NORMAL
- en: Java is fast and easy to use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a decades-long debate over which language is the best overall or which
    language is the best to learn programming. Critics of Java will likely say things
    about Java's speed. It is true that the Java memory management along with the
    VM interpretation process does have some speed cost. However, these things have
    benefits; they significantly improve our productivity and the way that the Android
    VM interacts with a device largely negates the minor speed penalty. And since
    Android 4.4, it does so completely with **Android Run Time** (**ART**), which
    installs apps written in Java as fully native applications. Now Java programmers
    can build games in a friendly, interpreted language and have them run as if they
    were written in a more challenging natively compiled language.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of Java and Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a rapidly changing world, if you are worried about where to invest your precious
    learning time, it is hard to have more confidence. Here we have a language (Java)
    whose fundamentals have remained almost the same for nearly a quarter of a century,
    and a platform (Android) that is backed by the biggest names in hardware, software,
    and retail, and though it's admittedly hugely influenced, it's not actually owned
    by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: I am not an evangelist of any technology over another although it is true that
    I love doing stuff on Android. But you can be sure in your mind that if you are
    considering the best path to begin learning programming, there is a very strong
    argument that Java and Android are the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn Java for any of its numerous uses, then this is a very
    good place to start. If you want to develop for Android or get into Android development
    of any sort, then Java is the absolute fundamental way to start, and making games
    has the enormous benefits we have already discussed.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the book, you will be able to write Java code for almost any Java-supported
    platform. You will be able use almost everything you learn in this book, away
    from the Android environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning to pursue a career or business by making Android games or
    any Android apps, then this book is possibly the only place to start for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: If you are completely new to Java and want the easiest possible path to mastering
    it—the fastest growing platform on the planet—then *Learning Java by Building
    Android Games* will probably be just right for you.
  prefs: []
  type: TYPE_NORMAL
- en: So hopefully you are assured that the path this book will take to learn Java
    is as easy, fun, and thorough as learning Java can be. Let's get set up so we
    can start building games.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is prepare our PC to develop for Android using
    Java. Fortunately, this is made quite simple for us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are learning on Mac or Linux, everything in this book will still work.
    The next two tutorials have Windows-specific instructions and screenshots. However,
    it shouldn't be too difficult to vary the steps slightly to suit Mac or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Install a software package called the **Java Development Kit** (**JDK**), which
    allows us to develop in Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Android Studio, a program designed to make Android development fast
    and easy. Android Studio uses the JDK and some other Android-specific tools that
    automatically get installed when we install Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is get the latest version of the JDK. To complete
    this guide, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to be on the Java website, so visit [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the three buttons shown in the following screenshot and click on the one
    that says **JDK** (highlighted). They are on the right-hand side of the web page.
    Click on the **DOWNLOAD** button under the **JDK** option:![Installing the JDK](img/8859OS_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be taken to a page that has multiple options to download the JDK. In
    the **Product/File description** column, you need to click on the option that
    matches your operating system. Windows, Mac, Linux and some other less common
    options are all listed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common question here is, "do I have 32- or 64-bit windows?". To find out,
    right-click on your **My Computer** (This PC on Windows 8) icon, click on the
    **Properties** option, and look under the **System** heading in the **System type**
    entry, as shown in the following screenshot:![Installing the JDK](img/8859OS_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the somewhat hidden **Accept** **License Agreement** checkbox:![Installing
    the JDK](img/8859OS_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the download option for your OS and system type as previously determined.
    Wait for the download to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your `Downloads` folder, double-click on the file you just downloaded. The
    latest version at time of writing this for a 64-bit Windows PC was `jdk-8u5-windows-x64`.
    If you are using Mac/Linux or have a 32-bit OS, your filename will vary accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first of several install dialogs, click on the **Next** button and you
    will see the next dialog box:![Installing the JDK](img/8859OS_01_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the defaults shown in the previous screenshot by clicking on **Next**.
    In the next dialog box, you can accept the default install location by clicking
    on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next is the last dialog of the Java installer. Click on **Close**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JDK is now installed. Next we will make sure that Android Studio is able
    to use the JDK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on your **My Computer** (This PC on Windows 8) icon and navigate
    to **Properties** | **Advanced system settings** | **Environment variables** |
    **New** (under **System variables,** not under **User variables**). Now you can
    see the **New** **System Variable** dialog, as shown in the following screenshot:![Installing
    the JDK](img/8859OS_01_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `JAVA_HOME` for **Variable name** and enter `C:\Program Files\Java\jdk1.8.0_05`
    for the **Variable value** field. If you installed the JDK somewhere else, then
    the file path you enter in the **Variable value:** field will need to point to
    wherever you put it. Your exact file path will likely have a different ending
    to match the latest version of Java at the time you downloaded it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to save your new settings. Now click on **OK** again to clear
    the **Advanced system settings** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have the JDK installed on our PC. We are about half way towards starting
    to learn Java programming, but we need a friendly way to interact with the JDK
    and to help us make Android games in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned that Android Studio is a tool that simplifies Android development
    and uses the JDK to allow us to write and build Java programs. There are other
    tools you can use instead of Android Studio. There are pros and cons in them all.
    For example, another extremely popular option is Eclipse. And as with so many
    things in programming, a strong argument can be made as to why you should use
    Eclipse instead of Android Studio. I use both, but what I hope you will love about
    Android Studio are the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a very neat and, despite still being under development, a very refined
    and clean interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is much easier to get started compared to Eclipse because several Android
    tools that would otherwise need to be installed separately are already included
    in the package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio is being developed by Google, based on another product called
    IntelliJ IDEA. There is a chance it will be the standard way to develop Android
    in the not-too-distant future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use Eclipse, that's fine; all of the code in this book will work.
    However, some the keyboard shortcuts and user interface buttons will obviously
    be different. If you do not have Eclipse installed already and have no prior experience
    with Eclipse, then I even more strongly recommend you to go ahead with Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Android Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So without any delay, let's get Android Studio installed and then we can begin
    our first game project. To do this, let's visit [https://developer.android.com/sdk/installing/studio.html](https://developer.android.com/sdk/installing/studio.html).
  prefs: []
  type: TYPE_NORMAL
- en: Click on the button labeled **Download Android Studio** to start the Android
    studio download. This will take you to another web page with a very similar-looking
    button to the one you just clicked on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the license by checking in the checkbox, commence the download by clicking
    on the button labeled **Download Android Studio for Windows**, and wait for the
    download to complete. The exact text on the button will probably vary depending
    on the current latest version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder in which you just downloaded Android Studio, right-click on the
    `android-studio-bundle-135.12465-windows.exe` file and click on **Run as administrator**.
    The end of your filename will vary depending upon the version of Android Studio
    and your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked if you want to **Allow the following program from an unknown publisher
    to make changes to your computer**, click on **Yes**. On the next screen, click
    on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the screen shown in the following screenshot, you can choose which users
    of your PC can use Android Studio. Choose whatever is right for you as all options
    will work, and then click on **Next**:![Installing Android Studio](img/8859OS_01_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next dialog, leave the default settings and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then on the **Choose start menu folder** dialog box, leave the defaults and
    click on **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Installation complete** dialog, click on **Finish** to run Android
    Studio for the first time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next dialog is for users who have already used Android Studio, so assuming
    you are a first time user, select the **I do not have a previous version of Android
    Studio or I do not want to import my settings** checkbox, and then click on **OK**:![Installing
    Android Studio](img/8859OS_01_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That was the last piece of software we needed. The simple nine-step process
    we just went through has actually set up a whole range of Android tools that we
    will begin to use in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed why games, Java, and Android are not only extremely exciting but
    also arguably the best way to learn to program. This is because games can be an
    extremely motivating subject matter and Java and Android have enormous strengths
    with regards to popularity and longevity, and are open to all of us to use for
    free.
  prefs: []
  type: TYPE_NORMAL
- en: We also set up the Java development kit and installed Android Studio, getting
    ready for the next chapter where we will actually create a part of a working game
    and take our first look at some Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Getting Started with Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a roller coaster ride through all the Android
    topics that you need to learn in order to get started with Java. It won't just
    be theoretical though. We will be designing a **user interface** (**UI**) of a
    game menu and we will see and edit our first Java code as well.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will see how we can run our apps in either an Android emulator
    on our PC/Mac or on a real Android device if we have one.
  prefs: []
  type: TYPE_NORMAL
- en: Some of what we will cover in this chapter will be the tip of the iceberg. That
    is, there is a lot more below the surface to some of the topics we discuss than
    would be appropriate for the second chapter of a learning Java book. Sometimes,
    we might need to take a bit of information on faith.
  prefs: []
  type: TYPE_NORMAL
- en: This will then enable us to actually design and run our very own Android app
    by the end of this chapter. Then we can start learning Java for real at the beginning
    of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If this chapter seems a little tough, then don't worry; keep going because each
    subsequent chapter lifts the lid a bit more from some of the less clear topics.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter and the next two, we will be building a math game. We will
    start simply and by the end of [Chapter 4](ch04.html "Chapter 4. Discovering Loops
    and Methods"), *Discovering Loops and Methods*, we will scale to game features
    that use significant Java skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Start our first game project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Android Studio visual designer to make our game UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about structuring our code for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take our first look at some Java code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and install our game on an emulator and a real device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first game project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will get straight down to actually doing something with Android Studio.
    Run Android Studio by double-clicking on the Android Studio icon either on your
    desktop's start menu or in the folder where you installed it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get any errors in a dialog box mentioning **Privilege elevation**, then
    try running Android Studio with administrator privileges. To do this, find the
    Android Studio icon by clicking on the Windows **Start** button and searching
    for **Android Studio**. Now right-click on the icon and click on **Run as administrator**.
    Do this every time you run Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So with Android Studio and Java installed, we just need to add the latest versions
    of the Android API that we will use to make our first game. Here is what to do
    to install the API:'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu bar at the top of the Android Studio UI, navigate to **Tools**
    | **Android** | **SDK Manager**. Scroll down in the **Android SDK Manager** window
    and select the checkbox for **Android 4.4.2 (API 19)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that because Android is evolving so quickly, by the time you read this
    chapter, there might be APIs newer than 19—20, 21, and so on. If this is the case
    for you, select the newer (higher numbered) API instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Preparing Android Studio](img/8859OS_02_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on **Install Packages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, click on the **Accept license** checkbox and then click
    on the **Install** button. Android Studio will download and install the appropriate
    packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we just did was setting up Android Studio to make available the latest,
    prewritten code called an API that we will interact with throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Click on **New Project...** as indicated in the following screenshot:![Building
    the project](img/8859OS_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field with `Math Game Chapter 2` and **Company Domain** with `packtpub.com`
    (or you could use your own company website name here), as shown in the following
    screenshot:![Building the project](img/8859OS_02_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on the **Next** button. On the next screen, check that the **Phone
    and Tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater is the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select, the fewer are the cutting-edge
    Android features available in our apps. A good balance is to select **API 8: Android
    2.2 (Froyo)**. Go ahead and do that now as shown in the next screenshot:![Building
    the project](img/8859OS_02_19.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next**. Now select **Blank Activity** as shown in the next screenshot
    and click on **Next** again:![Building the project](img/8859OS_02_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Android Studio shows a **Tip of the day** dialog every time it starts.
    Some of the tips might not make sense while you are still learning Java but many
    of them are really useful and reveal great shortcuts and other time savers. It
    is well worth taking a few seconds to read them when they show up. As already
    discussed, Android Studio is built from IntelliJ IDEA, and you can find a complete
    list of keyboard shortcuts at [http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html](http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clear **Tip of the day** by clicking on **Close**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are completely new to programming, then the code, options, and files
    might seem a bit daunting. Don't worry; stick to them as we don't need to concern
    ourselves with most of them in order to learn Java. When the time does come to
    interact with the finer details, we will do things one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: It might be hard to believe that at this stage, but we have just created our
    first working app. We could build and run it on an Android device, and soon we
    will.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a deeper look at Android Studio before we progress with our game.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio is a very deep tool, but it is only necessary to learn one part
    at a time in order to get started. What might be useful for us is naming a few
    parts of the UI so that we can refer to them easily as we progress through the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at this numbered diagram and a quick explanation of some of the
    key parts of Android Studio. If you can, try and memorize the parts to make future
    discussions of them easier for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Android Studio](img/8859OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here is a handy table that you can quickly refer to and remember which part
    of Android Studio we are referring to. What follows is a more detailed explanation
    of each area.
  prefs: []
  type: TYPE_NORMAL
- en: '| Number | Name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Project Explorer |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | The editor |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Menu bar |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Toolbar |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Navigation bar |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Important tool windows |'
  prefs: []
  type: TYPE_TB
- en: '**Project Explorer** (**1**): This is shown as **1** in the screenshot and
    is a bit like Windows Explorer. It shows us all the files and folders that have
    been generated for our project. We will do a number of things from here as the
    book continues. Actually, if you delve into the files and folders that Android
    Studio creates, the Project Explorer is not an exact mapping. It is slightly simplified
    and highlighted to make managing and exploring our project easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Editor** (**2**): As the name suggests, we will edit our Java code files
    here in the editor. However, as we will soon see, the **Editor** window changes
    depending on the type of file we are editing. We will also be viewing and editing
    UI designs here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Menu bar** (**3**): Like most programs, the **Menu** bar gives us access
    to the full functionality of Android Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tool bar** (**4**): This contains lots of really useful one-click options
    to do things such as deploying and debugging our games. Hover the mouse cursor
    over an icon to get a pop-up tip and gain greater insight into each toolbar icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation bar** (**5**): Like a file path, this shows exactly where the
    file that is currently in the editor is located within the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Important tool windows** (**6**): These are a number of tabs that can be
    popped up and popped down again by clicking on them. If you like, try some of
    them now to see how they work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's talk a bit more about the parts of the Android Studio UI and how the editor
    window can transform itself into a visual UI designer. After that, when we are
    familiar enough, we will look at building a simple menu screen for our math game.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Android Studio visual designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android Studio editor window is a very dynamic area. It presents different
    file types in the most useful way possible. A little earlier, when we created
    our project, it also made a basic UI for us. UIs in Android can be built-in Java
    code or, as we will see, in a visual designer without the need for a single line
    of Java. However, as we will investigate after we have built the UI of our game
    menu, to get the UI to do anything useful, we need to interact with it. This interaction
    is always done with Java code. The visual designer also generates the UI code
    for us. We will take a very quick look at that too.
  prefs: []
  type: TYPE_NORMAL
- en: As the book progresses, we will mainly shy away from Android UI development,
    as that is a staple of more non-game apps. We will instead spend more time looking
    at directly drawing pixels and images to make our games. Nonetheless, the regular
    Android UI has its uses, and the Android Studio visual designer is the quickest
    way to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at that now:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android Studio Project Explorer, double-click on the `layout` folder
    to reveal the `activity_main.xml` file within it. This should be easy to see unless
    you have collapsed the directories. If you can't see the `layout` folder, navigate
    to it using the Project Explorer. It can be found at `Math Game Chapter2/src/main/res/layout`
    via the Android Studio Project Explorer, as shown in the following screenshot:![Using
    the Android Studio visual designer](img/8859OS_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now double-click on **activity_main.xml** to open it in the editor window. After
    a brief loading time, you will see something very similar to the next screenshot.
    The following screenshot shows the entire contents of what previously contained
    just our code. As you can see, what was just a text window now has multiple parts.
    Let's take a closer look at this screenshot:![Using the Android Studio visual
    designer](img/8859OS_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding screenshot labeled (**1**), called **Palette**, you can choose
    from the available Android UI elements and simply click and drag them onto your
    UI design. Area (2) is the visual view of the UI you are building, where you will
    click and drag elements from the palette. To the right of the visual UI view,
    you will see the **Component Tree** area (3). The component tree allows you to
    examine the structure of the complex UI and select specific elements more easily.
    Under this tree is the **Properties** panel (4). Here you can adjust the properties
    of the currently selected UI element. These can be simple things such as color
    and size or much more advanced properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the tabs labelled (**5**). These tabs allow you to switch between the two
    main views that Android Studio provides for this type of layout file. These views,
    as you can see, are **Design** and **Text**. The design view is the default view
    and is shown in the previous screenshot. The text view also shows your under-construction
    UI, but it shows the code that has been autogenerated for us instead of the **Palette**
    element and the component tree.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We don't need to worry about this code as it is all handled for us. It can be
    good to look on this tab from time to time so that we can begin to understand
    what the design tool generates for us. But it is not necessary to do this to learn
    Java. This code is called **eXtensible Markup Language** (**XML**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take a quick look at the **Text** tab, click on the **Design** tab when you're
    done, and we will move on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have seen an overview of the visual designer and an even briefer glimpse
    of the automatically generated code that it generates for us. We can take a closer
    look at some of the actual UI elements that we will be using in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Android UI types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now take a whirlwind tour of some really useful Android UI elements,
    a few key properties, and how to add them together to make a UI. These will introduce
    us to some of the possibilities as well as how to use them. We will then quickly
    use what we know to make our menu.
  prefs: []
  type: TYPE_NORMAL
- en: TextView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the visual UI area, click on the words **Hello world!**. What we have just
    selected is a widget known as a TextView. TextViews can be small text like this
    one or large heading type text, which might be useful in our game menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try dragging and dropping another TextView onto our visual UI:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly under the **Widgets** heading in our palette, you can see there are
    multiple types of TextView. They are presented in the palette as **Plain TextView**,
    **Large Text**, **Medium Text** and **Small Text**. Drag and drop a **Large Text**
    widget onto our visual design. Don't let go straightaway. As you drag it around
    the image of the phone, notice how Android Studio graphically shows you different
    positioning options. In the following screenshot, you can see what the designer
    looks like when the widget being dragged is positioned at the center:![TextView](img/8859OS_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let go of the left mouse button where you want the widget to go. If you let
    go when it is positioned as shown in the previous screenshot, then the text will
    appear in the center as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can play with the properties. In the **Properties** window, click just
    to the right of **textSize**. You might need to scroll to find it. Type `100sp`
    as the value and press the *Enter* key. Notice that the text gets much larger.
    We can refine the size of our text by increasing and decreasing the value entered
    here. The unit `sp` stands for scaled pixels, and is simply a measuring system
    that attempts to scale the text to an appropriate equivalent actual size across
    different screen densities.![TextView](img/8859OS_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play with some more properties if you like and when you're done, click on the
    TextView we just created in the visual designer to highlight it. Then tap on the
    *Delete* key to get rid of it. Now delete the TextView that was present when we
    started—the one that says **Hello world!**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Layout elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you have an apparently empty screen. However, if you click anywhere on the
    design preview, you will see that we still have some options in the **Properties**
    window. This element is called a RelativeLayout. It is one of several layout element
    types provided as a base to control and align the layout widgets such as buttons,
    text, and so on. If you look at the top of the **Palette** window, you will see
    the main layout options. We will use this layout element when we actually build
    our game menu in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: ImageView widgets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ImageViews unsurprisingly are for displaying images. In the standard Android
    UI, this is a really quick way to add our designers'' artwork to our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop an **ImageView** element onto the design in the same way as you
    positioned the TextView a moment ago. The **ImageView** element can be found below
    the **Widgets** heading. Now position it centrally as before or play with the
    options by dragging it around the design. We will delete it in a minute; we are
    just having a bit of an exploration before we do this for real.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** window, select the **src** property in the same way as
    you selected the **textSize** property previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that after you select it, you have the option to click on **...** to
    give you more options. Click on **...** and scroll to the bottom of the list of
    options. These are all the image files that we can display in this ImageView.
    Just for fun, scroll to the bottom of the list, choose **ic_launcher**, and click
    on **OK**. We can make any image we like available and this is a simple, powerful
    way to build an attractive game menu screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **layout:width** property to `150dp` and the **layout:height** property
    to `150dp`. The unit **dp** is a way of sizing elements and widgets that remains
    relatively constant across devices with screens that have very different numbers
    of pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the ImageView in exactly the same way as you deleted the other views
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ButtonView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of ButtonView is probably given away by its name. Try to click and drag
    a few buttons onto our layout. Notice that there are a few types of ButtonView,
    such as **Small Button**, **Button**, and, if you look further down the **Widget**
    list, **ImageButton**. We will be using the regular ButtonView, labelled simply
    as **Button**.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will do something with each of these Android UI elements combined to
    make our game menu.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the entire sample from the code download section of the book's
    companion website.
  prefs: []
  type: TYPE_NORMAL
- en: Using the sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the code in this book is organized in projects. If a project spans more
    than one chapter, a project is provided for each chapter in its finished state.
    This helps you see the progression and not just the end result. All you need to
    do to open the project in Android Studio is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the code for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Android Studio** from the menu bar, navigate to **File** | **Close project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create a new blank project as we did previously. Browse to where you downloaded
    the code for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `Chapter2` folder. Here you will find the code for all the files
    we create in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the code files using a plain text editor such as the free Notepad++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste in your Android Studio project or just compare the code as you
    see it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although every line of code required in this book is supplied for your convenience,
    you still need to create each project for yourself through Android Studio. You
    can then simply copy and paste either the code in its entirety in the file with
    the matching name, or just the part of the code that you might be struggling with.
    Keep in mind that if you create a project with a different package name, then
    you must *omit* the line of code that is the package name from the supplied code
    files. The reasons for this will be clearer when we talk more about packages later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's actually see how to do it all for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Making our game menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For now we will just make our game menu functional. Later in [Chapter 5](ch05.html
    "Chapter 5. Gaming and Java Essentials"), *Gaming and Java Essentials*,we will
    see how we can make it look good by adding some cool animation to make the menu
    more visually interesting and fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we are aiming for in this tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making our game menu](img/8859OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before you start coding, you should design your layouts on paper first. However,
    the Android Studio designer is so friendly there is a strong argument, especially
    for simple layouts, to refine your design actually in the layout designer. Perform
    the following steps to create the game menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete all widgets from your designer by clicking on them one at a time and
    then tapping the *Delete* key on each in turn. Be careful not to delete the **RelativeLayout**
    layout element as we are going to use it as a base for all the other elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag a **Large Text** element from the palette to the top center of
    the design area and give it the following properties. Remember that you can change
    properties in the **Properties** panel by clicking to the right of the property
    to be changed. Change the **text** property to `My Math Game` and **size** to
    `30sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag an **ImageView** element from the palette to the center of the
    design, slightly below the previous TextView. Change the **layout:width** property
    to `150dp` and the **layout:height** property to `150dp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click and drag three buttons for **Play**, **High Scores** and **Quit**.
    Center them vertically, below the previous ImageView and one below the other,
    as per our design shown previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the top button, configure the **text** property, and enter the value
    `Play`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the middle button, configure the **text** property, and enter the value
    `High Scores`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the lowest button, configure the **text** property, and enter the value
    `Quit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the buttons now contain different amounts of text relative to each other,
    they will be of slightly different sizes. You can even them up to match the intended
    layout by clicking and dragging the edges of the smaller buttons to match the
    larger ones. This is done in mostly the same way as you might resize an application
    window in Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project with *Ctrl* + *S* or by navigating to **File** | **Save All**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to be testing your games on a much larger or much smaller screen
    than the Nexus 4 shown in the designer, then you might like to adjust the values
    of the `sp` and `dp` units used in this tutorial.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A full discussion of Android UI on multiple devices is beyond the scope of this
    book and is not necessary to make any of the games in this book. If you want to
    start designing for different screens right away, take a look at [http://developer.android.com/training/multiscreen/index.html](http://developer.android.com/training/multiscreen/index.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can view what your menu looks like on other devices simply by selecting
    the device from the drop-down menu shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making our game menu](img/8859OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we make our menu come to life on an actual device, let's take a look
    at the structure of an Android app and how we can use that structure when writing
    our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our code for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever used an Android device, you have probably noticed that it works
    quite differently from many other operating systems. For example, you are using
    an application—say you're checking what people are doing on Facebook. Then you
    get an e-mail notification and you tap the e-mail icon to read it. Midway through
    reading the e-mail, you might get a Twitter notification and because you're waiting
    on important news from someone you follow, you interrupt your e-mail reading and
    change the app to Twitter with a touch.
  prefs: []
  type: TYPE_NORMAL
- en: After reading the tweet, you fancy a game of Angry Birds, but midway through
    the first daring fling, you suddenly remember that Facebook post. So you quit
    Angry Birds and tap the Facebook icon.
  prefs: []
  type: TYPE_NORMAL
- en: Then you resume Facebook, probably at the same point you left it. You could
    have resumed reading the e-mail, decided to reply to the tweet, or started an
    entirely new app. All this backwards and forwards takes quite a lot of management
    on the part of the operating system, apparently independent from the individual
    apps themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a Windows PC and Android in the context we have just
    discussed is that with Android, although the user decides which app they are using,
    the Android OS decides if and when to actually close down (destroy) an application.
    We just need to consider this when coding our games.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle phases – what we need to know
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android system has different **phases** that any given app can be in. Depending
    on the phase, the Android system determines how the app is viewed by the user
    or whether it is viewed at all. Android has these phases so that it can decide
    which app is in current use and then allocate the right amount of resources such
    as memory and processing power. But also allow us as game developers to interact
    with these phases. What if someone quits our game to answer a phone call? Will
    they lose their progress?
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has a fairly complex system that, when simplified a little for the
    purpose of explanation, ensures that every app on an Android device is in one
    of the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Being created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resuming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being destroyed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of phases will hopefully appear fairly logical. As an example, the
    user presses the Facebook app icon and the app is **created**. Then it is *started*.
    All are fairly straightforward so far but next in the list is **resuming**! It
    is not as illogical as it might first appear if, for a moment, we can just accept
    that the app resumes after it starts, and then all will become clear as we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: After **resuming,** the app is *running*. This is when the Facebook app has
    control over the screen and probably the greater share of system memory and processing
    power. Now what about our example where we switched from the Facebook app to the
    e-mail app?
  prefs: []
  type: TYPE_NORMAL
- en: As we tap to go to read our e-mail, the Facebook app will probably have entered
    the **paused** phase, and the e-mail app will enter the **being created** phase
    followed by **resuming** and then **running**. If we decide to revisit Facebook,
    as in the scenario earlier, the Facebook app will probably then go straight to
    the **resume** phase and then **running** again, most likely exactly on the post
    where we left it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that at any time, Android can decide to *stop* or *destroy* an app, in
    which case, when we run the app again, it will need to be *created* all over again.
    So had the Facebook app been inactive long enough or had Angry Birds required
    so many system resources that Android would have *destroyed* the Facebook app,
    then our experience of finding the exact post we were previously reading might
    have been different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if all this phase stuff is starting to get confusing, then you will be
    pleased to know that the only reasons to mention are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You know it exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We occasionally need to interact with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take things step by step when we do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycle phases – what we need to do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are making games, how do we possibly interact with this complexity?
    The good news is that the Android code that was autogenerated when we created
    our first project does most of the interaction for us.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do as game developers is make sure that Android knows what to
    do with our app in each phase when it happens. Even more good news is that all
    of these phases are handled by default, unless we override the default handling.
  prefs: []
  type: TYPE_NORMAL
- en: This means we can go ahead with learning Java and making games until we come
    to one of the few instances where we need to do something in our game, specifically
    in one of the phases.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing our game into activities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java code that we write will be divided into sections or parts called **activities**.
    We can think of activities as different screens for our game. For example, during
    the book, we will often create an activity for a home screen, an activity for
    the game screen and an activity for the high score screen.
  prefs: []
  type: TYPE_NORMAL
- en: Each activity will have its own life cycle and will be further divided into
    parts that will correspond to (go into) one of the Android phases we just discussed.
    The parts in Java are known as **methods**. Methods are a significant concept
    in Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, however, all we need to know is that methods are used to compartmentalize
    the Java code we write and that some methods are provided by the Android system
    so that we can easily handle the otherwise complex Android life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The forthcoming list is a quick explanation of the methods provided by Android
    for our convenience, to manage the phases of the life cycle. To clarify our discussion
    of life cycle phases methods are listed next to their corresponding phases that
    we have been discussing. However, as you will see, the method names make it fairly
    clear on their own where they fit in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the list, there is also a brief explanation or suggestion about when we
    should use a given method and thereby interact during a specific phase. We will
    meet most of these methods as we progress through the book. We will see the `onCreate`
    method later in this chapter. Here is the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreate`: This method is executed when the activity is being created. Here
    we get everything ready for the game, including graphics, sound, and perhaps the
    high scores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStart`: This method is executed when the app is in the starting phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResume`: This method runs after `onStart` but can also be entered, perhaps
    most logically, after our activity is resumed after being previously paused. We
    might reload a previously saved game situation when the app had been interrupted,
    perhaps by a phone call or the user running another app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPause`: This occurs when our app is pausing. Here we might want to save
    the current game. You are probably getting the hang of these methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStop`: This relates to the stopping phase. This is where we might undo everything
    we did in `onCreate`. If we reach here, our activity will probably get destroyed
    sometime soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDestroy`: This is when our activity is finally being destroyed—our last
    chance to dismantle our game. If we reach here, we will definitely be going through
    the phases of the life cycle from the beginning again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the method descriptions and their related phases should appear straightforward.
    Perhaps, the only real question is about the running phase. As we will see, when
    we write our code in other methods/phases, the `onCreate`, `onStart`, and `onResume`
    methods will prepare the game, which persists, forming the running phase. The
    `onPause`, `onStop`, and `onDestroy` methods will occur afterwards. Now we can
    actually take a look at one of these methods and some other methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: Our first look at Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what about all that code that Android Studio generated when we created our
    new project earlier? This is the code that will bring our game menu to life. Let''s
    take a closer look. The very first line of code in the editor window is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This line of code defines the package that we named when we first created the
    project. As the book progresses, we will write more complex code that spans more
    than one file. All the code files we create will need the package they belong
    to, clearly defined like the previous line of code, at the top. The code doesn't
    actually *do* anything in our game. Notice also that the line ends with a semicolon
    (`;`). This is a part of the Java syntax and it denotes the end of a line of code.
    Remove a semicolon and you will get an error because Android Studio tries to make
    sense of two lines together. Try it if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that if you are going to be copying and pasting the code from the download
    bundle, this is the one line of code that might vary depending on how you set
    up your project. If the package name in the code file is different from the package
    name you created, always use the package name from when you created the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the next four lines of code, you might need to click on the small **+**
    icon to reveal them. Android Studio tries to be helpful by simplifying our view
    of the code. Notice that there are several little **-** icons as well down the
    side of the editor window. You can expand and collapse them to suit yourself without
    affecting the functionality of the program. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first look at Java](img/8859OS_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have expanded the code, you will see these four lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all the preceding lines start with the word `import`. This is an
    instruction to include other packages in our game, not just our own. This is very
    significant because it makes available to us all of the hard work of other programmers,
    the Android development team in this case. It is precisely these imports that
    give us the ability to use the methods we discussed earlier, and allow us to interact
    with the Android life cycle phases. Notice again that all the lines end with a
    semicolon (`;`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line introduces a fundamental building block of Java known as a **class**.
    Classes are something that we will continually expand our knowledge and understanding
    of throughout the book. For now, take a look at this line of code, then we will
    discuss it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Word by word, here is what is going on. The preceding line is saying: make
    me a new `public class` called `MainActivity` and base it upon (`extends`) `ActionBarActivity`.'
  prefs: []
  type: TYPE_NORMAL
- en: You might remember that `MainActivity` is the name we chose while creating this
    project. `ActionBarActivity` is the code (known as a class) written by the Android
    development team that enables us to put our Java into Android.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a keen eye, you might notice there is no semicolon at the end of
    this line. There is, however, an opening curly brace (`{`). This is because `MainActivity`
    encompasses the rest of the code. In effect, everything is part of our `MainActivity`
    class, which is built based on the `ActionBarActivity` class/code. If you scroll
    down to the bottom of the editor window, you will see a closing curly brace (`}`).
    This denotes the end of our class called `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to know how a class works yet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use classes to access some methods contained within its code and without
    doing any more, we are already, by default, taking advantage of the Android life
    cycle methods we discussed earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now pick and choose if, when, and which methods defined in these classes
    we wish to override or leave as default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, it is the `ActionBarActivity` class that contains the methods that enable
    us to interact with the Android life cycle. Actually, there are a number of different
    classes that enable us to do this and in a moment, we will change from using `ActionBarActivity`
    to a more appropriate class that also does all the things just mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not important at this point to properly understand Java classes; just
    understand that you can import a package and a package can contain one or more
    classes that you can then use the functionality of or base your own Java programs
    on.
  prefs: []
  type: TYPE_NORMAL
- en: We will bump into classes regularly in the next few chapters. Think of them
    as programming black boxes that do stuff. In [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*, we
    will open the black box and really get to grips with them and we will even start
    making our own classes.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on with the code, let's look at what the code that is contained within
    our class actually does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code chunk directly after the crucial line we have just been discussing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, some of this code will start to make sense now and tie in with what
    we have already discussed. Although the precise syntax will still feel a little
    alien, we can continue learning Java as long as we are aware of what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we notice in the preceding code is the word `@override`. Remember
    when we said that all the methods that interact with the Android life cycle were
    implemented by default and we can pick and choose if and when to override them?
    This is what we are doing here with the `onCreate` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `@override` word says that the method that follows next is being overridden.
    The `protected void onCreate(Bundle savedInstanceState) {` line contains the method
    we are overriding. You might be able to guess that the action starts with the
    opening `{` at the end of the line in question and ends with the closing `}` three
    lines later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The somewhat odd-looking `protected void` before the method name `onCreate`
    and `(Bundle savedInstanceState)` after the method name are unimportant at this
    time because they are handled for us. It is to do with the data that travels between
    various parts of our program. We just need to know that what happens here will
    take place in the creating phase of the Android lifecycle. The rest will become
    clear in [Chapter 4](ch04.html "Chapter 4. Discovering Loops and Methods"), *Discovering
    Loops and Methods*. Let''s move on to the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `super` keyword is referencing the code in the original `onCreate`
    method, which is still there even though we can''t see it. The code is saying:
    even though I am overriding you, I want you to set things up, just like you normally
    do first. Then, after `onCreate` has done loads of work that we don''t see and
    don''t need to see, the method continues and we actually get to do something ourselves
    with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we are telling Android to set the main content view (our users screen),
    which is the cool game menu we created earlier. To be specific, we are stating
    it is an `R` or resource in the `layout` folder and the file is called `activity_main`.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next two blocks of code were created by Android Studio on the assumption
    that we would want to override another two methods. We don''t, because they are
    methods more often used in non-gaming apps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the entire content shown in the following code. Be careful not to delete
    the closing curly brace of our `MainActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can delete a couple of the `@import` statements. The reason for this
    is that we just deleted the overridden methods of classes (imported earlier) we
    no longer need. Notice that the following lines in the editor window are grey.
    Note that the program would still work if you leave them in. Delete them both
    now to make your code as clear as possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some final amendments before our code is done: at this point, you might be
    thinking that we have deleted and changed so much of our code that we might as
    well have started from an empty page and typed it in. This is almost true. But
    the process of having Android Studio create a new project for us and then making
    these amendments is more thorough and also avoids quite a few steps. Here are
    the last code changes. Change the `import android.support.v7.app.ActionBarActivity;`
    line to `import android.support.app.Activity;`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you will get several red lines underlining our code and indicating errors.
    This is because we are attempting to use a class we have not yet imported. Simply
    amend the `public class MainActivity extends ActionBarActivity {` line to `public
    class MainActivity extends Activity {`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did with those last two changes was using a slightly more appropriate
    version of the `Activity` class. To do this, we also had to change what we imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done, your editor window should look exactly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know what's going on and our code is clean and lean, we can actually
    take a look at the beginnings of our game in action!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If any of what we have just discussed seemed complicated, there is no need for
    concern. Android forces us to work within the Activity lifecycle, so the previous
    steps were unavoidable. Even if you didn't follow all the explanations about classes
    and methods and so on, you are still perfectly placed to learn Java from here.
    All the classes and methods will seem much more straightforward as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Building and installing our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Soon, we will actually see our menu in action. But before we do that, we need
    to find out how to use the Android emulators and how to build our game. Then we
    will put these together and put our game into an emulator or real device to see
    it as our players would.
  prefs: []
  type: TYPE_NORMAL
- en: Emulators and devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have the first part of our game ready to run. We need to test it to check
    for any errors, crashes, or anything else unintended. It is also important to
    ensure that it looks good and runs correctly on the device types/sizes and that
    you want to target.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will not go into any details about handling different device types. All our
    games are fullscreen and we will later lock the orientation and dynamically calculate
    aspects such as screen resolution. So we can get away with writing for a single
    device type and focus on learning Java.
  prefs: []
  type: TYPE_NORMAL
- en: It might be useful to know for now that you can create a different layout file
    for any screen size categorization or pixel density. All you need to do is place
    the layout file using exactly the same filename in the appropriate folder. The
    Android device will then *know* the most appropriate layout for it to use. For
    a detailed discussion, see the Google developers website at [http://developer.android.com/guide/practices/screens_support.html](http://developer.android.com/guide/practices/screens_support.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note that you do not need to understand any of the information at the preceding
    link to learn Java and publish your first games.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few options to do this and we will look at two. First, we will use
    Android Studio and the Android Development Tools to make a device emulator so
    that we can use, test, and debug our games on a wide range of device emulators
    on the same PC/Mac we are developing on. So we don't need to own a device. This
    will allow us to get crash reports from our games.
  prefs: []
  type: TYPE_NORMAL
- en: Then we will install the game directly to a real device so that we can see exactly
    what the owner of that device will see when they download our app.
  prefs: []
  type: TYPE_NORMAL
- en: There are more options. For example, you can connect a real device via USB and
    debug directly on the device with the errors and syntactical feedback in Android
    Studio. The process for this might vary for different devices and since we won't
    be focusing on anything but basic debugging, we will not cover that in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an emulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s get our emulator up and emulating:'
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side of the Android Studio quick launch bar, find the AVD
    manager icon:![Creating an emulator](img/8859OS_02_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the icon to start the Android Virtual Device Manager. Then click on
    the **Create Virtual Device...** button on the bottom-left side to bring up the
    **Virtual Device Configuration** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the **Nexus 4** option and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to choose the version of Android we will use to build and test our
    games on. The latest version (at time of writing) is **Lollipop - 21 - x86**.
    It is the only option where we don't need to complete a download to continue.
    So select it (or whatever the default is at the time you are reading this) and
    then click on **Next** to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen we can leave all the default settings. So click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a ready-to-run Android emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Running the emulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will launch (switch on) our virtual device then actually run our game
    that we made earlier by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Nexus 4 API 21** under the **Name** column. Now click on the triangular
    play icon to the right of the description of our emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Android emulators take a long time to start. Even on a high-specification PC.
    Expect to wait at least a few minutes or even 10.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once it has started, unlock the device by clicking and dragging anywhere on
    the screen of the emulated device. This is analogous to swiping to unlock a real
    Nexus 4\. Here is what our Nexus 4 virtual device looks like when it is running
    and unlocked:![Running the emulator](img/8859OS_02_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can play with this emulator in almost the same way as you can a real Android
    device. However, you cannot download apps from Google Play. You might notice that
    the emulator is a bit slow compared to a real device, even compared to an old
    one. Shortly, we will look at running our apps on a real device.
  prefs: []
  type: TYPE_NORMAL
- en: Running our game on the emulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the emulator is running, it''s usually best to leave it running so that
    each time we want to use it, we don''t have to wait for it to start. Let''s use
    the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the emulator if it is not already running and make sure the device is
    unlocked as described previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the run icon in the toolbar (shown next) to run your app. You can achieve
    the same thing by navigating to **Run** | **Math Game Chapter 2** from the menu
    bar:![Running our game on the emulator](img/8859OS_02_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a pause while Android Studio builds our application, a pop-up dialog will
    ask you which device you want to run the app on. Choose the device with **Nexus
    4 API 21** in the description. This is the already running device that we created
    earlier. Now press **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice at this point that the useful Android window appears at the bottom section
    of Android Studio. In the unlikely event of you having any problems, just check
    for typos in the code. If things really don't work out, just go back to the *Using
    the sample code* section to compare with or copy and paste the supplied code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After another pause, our game menu screen will appear on the emulator. Of course,
    it doesn't do anything yet, but it is running and the buttons can be pressed.
  prefs: []
  type: TYPE_NORMAL
- en: When you're done, you can press the back or home icons to quit the application,
    just as you would on a real Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have seen one of the ways we can test our app by running it in the Android
    emulator. Let's find out how to make our code into an app we can distribute and
    use on a real device.
  prefs: []
  type: TYPE_NORMAL
- en: Building our game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run our game on a real Android device, we need to create a `.apk` file,
    that is, a file that ends with the extension `.apk`. A `.apk` file is a compressed
    archive of files and folders that the Android system uses to run and install our
    app. These are the steps to use Android Studio to make a `.apk` of our game:'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu bar, navigate to **Build** | **Generate Signed APK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A slightly verbose window will pop up and say: **For Gradle-based projects,
    the signing configuration should be specified in the Gradle build scripts**. You
    can safely dismiss this window by clicking on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next up is the **Generate Signed APK Wizard** dialog. Here, we are creating
    a key that identifies the key holder as authorized to distribute the APK. At the
    end of this process, you will have a `.keys` file that you can use each time you
    build a `.apk` file. So this step can be missed out in future. Click on the **Create
    new** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Key Store Path** field, type or go to a location on your hard drive
    where you would like to store your key. You will then be prompted to choose a
    filename for the keystore. This is arbitrary. Type `MyKeystore` and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type a password in the **Password** field and then retype it in the **Confirm**
    field. This is the password to a store that will help protect your key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the **Alias** field, type a memorable alias. You can think of this
    as a kind of username for your key. Again type a password in the **Password**
    field and then retype it in the **Confirm** field. This is the password to your
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the **Validity Years** dropdown at the default of **25**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then fill out your Name and organization details (if any) and click
    on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now our key and keystore are complete, and we can click on **OK** on the **Generate
    Signed APK wizard** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are then prompted to select **Run Proguard**. Encrypting and optimizing our
    `.apk` is unnecessary at this time. So just click on **Finish** to generate our
    app's `.apk` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generated `.apk` file will be put in the same directory that you chose to
    put the project files. For example, `MathGameChapter2/app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now built a `.apk` file that can be run on any Android device that was
    specified when we first created the project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the setup to a device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So we have our `.apk` file and we know were to find it. Here is how we will
    run it on our Android device.
  prefs: []
  type: TYPE_NORMAL
- en: We can use one of a number of methods to get the `.apk` file into the device.
    The method I find one of the easiest is the use of a cloud storage service such
    as Dropbox. You can then simply click and drag the `.apk` file to your Dropbox
    folder and you're done. Alternatively, your Android device probably came with
    PC synchronization software that allows you to drag and drop files to and from
    your device. After you have placed the `.apk` file on your Android device, continue
    with the tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Android phones are set not to install apps from anywhere except the Google
    Play Store. So we need to change this. The exact menus you will navigate to might
    vary very slightly on your device but the following options tend to be almost
    the same on most devices, old and new:'
  prefs: []
  type: TYPE_NORMAL
- en: Find and tap the **Settings** app. Most Android phones also have a **Settings**
    menu option. Either will do. Now select **Security** and scroll down to the **Unknown
    sources** option. Tap the **Unknown sources** checkbox to allow apps to be installed
    from unknown sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the file on your Android device using the Dropbox app or your devices
    file browser depending on the method you chose to put the APK on your device.
    Tap the `MathGameChapter2.apk` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now install the app just like any other. When prompted, press **Install**
    and then **Open**. The game will now be running on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold your device in a portrait orientation as this is how the UI was designed.
    Congratulations on running your very own Android app on your own device. In a
    later version of the math game, we will lock the orientation to make this more
    user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Future projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the book, we will test and run our game projects. It is entirely
    up to you which of the methods we discussed you prefer. If you are getting crashes
    or unexplained bugs, then you will need to use an emulator. If all is working
    well, then the quickest and probably most pleasing way will be to run it on a
    device you own.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What should you do if all this talk of life cycles, classes, and methods
    is a bit bemusing?
  prefs: []
  type: TYPE_NORMAL
- en: Q2) What exactly is a Java class?
  prefs: []
  type: TYPE_NORMAL
- en: Q3) What is the difference between a method and a class?
  prefs: []
  type: TYPE_NORMAL
- en: Q4) Take a look at the Android developer site and its more technical explanation
    of the phases of the life cycle at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html).
    Can you see the phase and its related method that we haven't discussed? When would
    it be triggered in an app? What is the precise pathway an activity takes from
    creation to destruction?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed that so far, it has not been not important to completely understand
    exactly how the code works. This is because it will act just as a container for
    the code we write in the rest of the book. However, as we cover in detail topics
    such as methods in [Chapter 4](ch04.html "Chapter 4. Discovering Loops and Methods"),
    *Discovering Loops and Methods*, and classes in [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*, we
    will begin to make sense of all of the code in our games.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the somewhat complex Android life cycle in detail. We learned that
    all we need to understand at this stage is that we must write our code within
    the correct methods that relate to different phases of the life cycle. Then we
    will have no trouble making good progress with learning Java. As with classes
    and methods, all will be explained along the way and become clearer with practice.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned the key areas of the Android Studio UI. We built our start menu
    for our math game using the Android Studio designer. Furthermore, we created the
    Java code necessary to make the game appear on the player's device. This was achieved
    mainly by modifying the code that was automatically generated for us.
  prefs: []
  type: TYPE_NORMAL
- en: This was probably the most difficult chapter of the book because it was necessary
    to introduce a few things such as Java classes, Java methods, and the Android
    life cycle. We did this because we need to know what is going on around us as
    we learn Java.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, however, we can take things a step at a time in a very logical
    manner. If you have reached this point, you will have no problem completing the
    toughest of the projects in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If this chapter made your brain ache a little, rest assured that the fact that
    you have made it this far is a very good indication that you are going to be a
    Java ace someday soon. Starting from the basics, let's learn some Java now.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Speaking Java – Your First Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start writing our very own Java code at the same time
    as we begin understanding Java syntax. We will learn how to store, retrieve, and
    manipulate different types of values stored in the memory. We will also look at
    making decisions and branching the flow of our code based on the values of this
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this order, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn some Java syntax and see how it is turned into a running app by the compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store data and use it with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to express yourself in Java with expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue with the math game by asking a question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about decisions in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue with the math game by getting and checking the answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acquiring the preceding Java skills will enable us to build the next two phases
    of our math game. This game will be able to ask the player a question on multiplication,
    check the answer and give feedback based on the answer given, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Speaking Java – Your First Game](img/8859OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Java syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we will use plain English to discuss some fairly technical
    things. You will never be asked to read a technical explanation of a Java or Android
    concept that has not been previously explained in a non-technical way.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, I might ask or imply that you accept a simplified explanation
    in order to offer a fuller explanation at a more appropriate time, like the Java
    class as a black box; however, you will never need to scurry to Google in order
    to get your head around a big word or a jargon-filled sentence.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, the Java and Android communities are full of people who speak
    in technical terms and to join in and learn from these communities, you need to
    understand the terms they use. So the approach this book takes is to learn a concept
    or appreciate an idea using an entirely plain speaking language, but at the same
    time, it introduces the jargon as part of the learning.
  prefs: []
  type: TYPE_NORMAL
- en: Then, much of the jargon will begin to reveal its usefulness, usually as a way
    of clarification or keeping the explanation/discussion from becoming longer than
    it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: The very term, "Java syntax," could be considered technical or jargon. So what
    is it? The Java syntax is the way we put together the language elements of Java
    in order to produce code that works in the Java/Dalvik virtual machine. Syntax
    should also be as clear as possible to a human reader, not least ourselves when
    we revisit our programs in the future. The Java syntax is a combination of the
    words we use and the formation of those words into sentence like structures.
  prefs: []
  type: TYPE_NORMAL
- en: These Java elements or words are many in number, but when taken in small chunks
    are almost certainly easier to learn than any human-spoken language. The reason
    for this is that the Java language and its syntax were specifically designed to
    be as straightforward as possible. We also have Android Studio on our side, which
    will often let us know if we make a mistake and will even sometimes think ahead
    and prompt us.
  prefs: []
  type: TYPE_NORMAL
- en: I am confident that if you can read, you can learn Java; because learning Java
    is very easy. What then separates someone who has finished an elementary Java
    course from an expert programmer? The same things that separate a student of language
    from a master poet. Mastery of the language comes through practice and further
    study.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, I will show you the right direction if you want to go on
    to master Java yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler is what turns our human-readable Java code into another piece of
    code that can be run in a virtual machine. This is called **compiling**. The Dalvik
    virtual machine will run this compiled code when our players tap on our app icon.
    Besides compiling Java code, the compiler will also check for mistakes. Although
    we might still have mistakes in our released app, many are discovered when our
    code is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Making code clear with comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you become more advanced in writing Java programs, the solutions you use
    to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Java was designed to manage complexity by having
    us divide our code into separate chunks, very often across multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments** are a part of the Java program that do not have any function in
    the program itself. The compiler ignores them. They serve to help the programmer
    to document, explain, and clarify their code to make it more understandable to
    themselves at a later date or to other programmers who might need to use or modify
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a good piece of code will be liberally sprinkled with lines like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding comment begins with the two forward slash characters, `//`. The
    comment ends at the end of the line. It is known as a single-line comment. So
    anything on that line is for humans only, whereas anything on the next line (unless
    it''s another comment) needs to be syntactically correct Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use multiple single-line comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Recall this code, which tells Android to load our menu UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding situation, the menu will not be loaded and the app will have
    a blank screen when run, as the entire line of code is ignored by the compiler.
    There is another type of comment in Java—the multiline comment. This is useful
    for longer comments and also to add things such as copyright information at the
    top of a code file. Also like the single-line comment, it can be used to temporarily
    disable code, in this case usually multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything in between the leading `/*` signs and the ending `*/` signs is ignored
    by the compiler. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no limit to the number of lines in a multiline comment. Which type
    of comment is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly but you will often find liberally
    sprinkled comments within the code itself that add further explanation, insight
    or clarification. So it''s always a good idea to read all of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the best Java programmers liberally sprinkle their code with comments.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data and using it with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can think of a variable as a labeled storage box. They are also like a programmer's
    window to the memory of the Android device, or whatever device we are programming.
    Variables can store data in memory (the storage box), ready to be recalled or
    altered when necessary by using the appropriate label.
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory has a highly complex system of addressing that we, fortunately,
    do not need to interact with in Java. Java variables allow us to make up convenient
    names for all the data that we want our program to work with; the JVM will handle
    all the technicalities that interact with the operating system, which in turn,
    probably through several layers of buck passing, will interact with the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: So we can think of our Android device's memory as a huge warehouse. When we
    assign names to our variables, they are stored in the warehouse, ready when we
    need them. When we use our variable's name, the device knows exactly what we are
    referring to. We can then tell it to do things such as "get box A and add it to
    box C, delete box B," and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In a game, we will likely have a variable named as something along the lines
    of `score`. It would be this `score` variable that we use to manage anything related
    to the user's score, such as adding to it, subtracting or perhaps just showing
    it to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the following situations that might arise:'
  prefs: []
  type: TYPE_NORMAL
- en: The player gets a question right, so add 10 to their existing `score`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player views their stats screen, so print `score` on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player gets the best score ever, so make `hiScore` the same as their current
    `score`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are fairly arbitrary examples of names for variables and as long as you
    don't use any of the characters keywords that Java restricts, you can actually
    call your variables whatever you like. However, in practice, it is best to adopt
    a naming convention so that your variable names will be consistent. In this book,
    we will use a loose convention of variable names starting with a lowercase letter.
    When there is more than one word in the variable's name, the second word will
    begin with an uppercase letter. This is called "camel casing."
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of camel casing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`score`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hiScore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playersPersonalBest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we look at some real Java code with some variables, we need to first
    look at the types of variables we can create and use.
  prefs: []
  type: TYPE_NORMAL
- en: Types of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not hard to imagine that even a simple game will probably have quite a
    few variables. In the previous section, we introduced the `hiScore` variable as
    an example. What if the game has a high score table that remembers the names of
    the top 10 players? Then we might need variables for each player.
  prefs: []
  type: TYPE_NORMAL
- en: And what about the case when a game needs to know if a playable character is
    dead or alive, or perhaps has any lives/retries left? We might need code that
    tests for life and then ends the game with a nice blood spurt animation if the
    playable character is dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common requirement in a computer program, including games, is the right
    or wrong calculation: true or false.'
  prefs: []
  type: TYPE_NORMAL
- en: To cover these and many other types of information you might want to keep track
    of, Java has **types**. There are many types of variables and, as we will see
    in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP
    – Using Other People's Hard Work*, we can also invent our own types or use other
    people's types. But for now, we will look at the built-in Java types. To be fair,
    they cover just about every situation we are likely to run into for a while. Some
    examples are the best way to explain this type of stuff.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed the hypothetical but highly likely `score` variable.
    The variable `score` is likely to be a number, so we have to convey this (that
    the score is a number) to the Java compiler by giving the score an appropriate
    type. The hypothetical but equally likely `playerName` will, of course, hold the
    characters that make up the player's name. Jumping ahead a couple of paragraphs,
    the type that holds a regular number is called `int`, and the type that holds
    name-like data is called `String`. And if we try and store a player name, perhaps
    "Ada Lovelace" in `score`, which is meant for numbers, we will certainly run into
    trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler says no! Actually, the error would say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Types of variables](img/8859OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, Java was designed to make it impossible for such errors to make
    it to a running program. Did you also spot in the previous screenshot that I had
    forgotten the semicolon at the end of the line? With this compiler identifying
    our errors, what could possibly go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main types in Java. Later, we will see how to start using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`: This type is used to store integers. It uses 32 pieces (**bits**) of
    memory and can therefore store values with a magnitude a little in excess of 2
    billion, including negative values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: As the name hints at, this data type can be used when even larger numbers
    are required. A `long` data type uses 64 bits of memory and 2 to the power of
    63 is what we can store in this type. If you want to see what that looks like,
    try this: `9,223,372,036,854,775,807`. Perhaps surprisingly, there are uses for
    `long` variables but if a smaller variable will do, we should use it so that our
    program uses less memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering when you might use numbers of this magnitude. The obvious
    examples would be math or science applications that do complex calculations but
    another use might be for timing. When you time how long something takes, the Java
    `Date` class uses the number of milliseconds since January 1, 1970\. The `long`
    data type could be useful to subtract a start time from an end time to determine
    an elapsed time. We will use `long` in [Chapter 5](ch05.html "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`float`: This is for floating-point numbers, that is, numbers where there is
    precision beyond the decimal point. As the fractional part of a number takes memory
    space just as the whole number portion, the range of numbers possible in a float
    is therefore decreased compared to non-floating-point numbers. So, unless our
    variable will definitely use the extra precision, float would not be our data
    type of choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: When the precision in `float` is not enough we have `double`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: When even an `int` data type is overkill, the super-skinny short fits
    into the tiniest of storage boxes, but we can only store around 64,000 values,
    from -32,768 to 32,767.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`: This is an even smaller storage box than a short type. There is plenty
    of room for these in memory but a byte can only store values from -128 to 127.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`: We will be using plenty of Booleans throughout the book. A Boolean
    variable can be either true or false—nothing else. Perhaps Booleans answer questions
    such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the player alive?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a new high score been reached?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Are two examples for a Boolean variable enough?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: This stores a single alphanumeric character. It''s not going to change
    anything on its own but it could be useful if we put lots of them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: I have kept this discussion of data types to a practical level that is useful
    in the context of this book. If you are interested in how a data type's value
    is stored and why the limits are what they are, visit the Oracle Java tutorials
    site at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html).
    Note that you do not need any more information than we have already discussed
    to continue with this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we just learned, each type of data that we might want to store will require
    a specific amount of memory. So we must let the Java compiler know the type of
    the variable before we begin to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding variables are known as the **primitive** types. They use predefined
    amounts of memory and so, using our storage analogy, fit into predefined sizes
    of the storage box.
  prefs: []
  type: TYPE_NORMAL
- en: As the "primitive" label suggests, they are not as sophisticated as the reference
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we didn't cover the `String` variable type that
    we previously used to introduce the concept of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are a special type of variable known as a reference type. They quite
    simply refer to a place in memory where the storage of the variable begins, but
    the reference type itself does not define a specific amount of memory. The reason
    for this is fairly straightforward: we don''t always know how much data will need
    to be stored until the program is actually run.'
  prefs: []
  type: TYPE_NORMAL
- en: We can think of strings and other reference types as continually expanding and
    contracting storage boxes. So won't one of these `String` reference types bump
    into another variable eventually? If you think about the devices memory as a huge
    warehouse full of racks of labeled storage boxes, then you can think of the Dalvik
    virtual machine as a super-efficient forklift truck driver that puts the different
    types of storage boxes in the most appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: And if it becomes necessary, the virtual machine will quickly move stuff around
    in a fraction of a second to avoid collisions. It will even incinerate unwanted
    storage boxes when appropriate. This happens at the same time as constantly unloading
    new storage boxes of all types and placing them in the best place, for that type
    of variable. Dalvik tends to keep reference variables in a part of the warehouse
    that is different from the part for the primitive variables, and we will learn
    more details about this in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*.
  prefs: []
  type: TYPE_NORMAL
- en: So strings can be used to store any keyboard character, like a `char` data type
    but of almost any length. Anything from a player's name to an entire book can
    be stored in a single string. We will be using strings regularly including in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple more reference types we will explore. Arrays are a way to
    store lots of variables of the same type, ready for quick and efficient access.
    We will look at arrays in [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"),
    *Gaming and Java Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Think of an array as an aisle in our warehouse with all the variables of a certain
    type lined up in a precise order. Arrays are reference types, so Dalvik keeps
    these in the same part of the warehouse as strings.
  prefs: []
  type: TYPE_NORMAL
- en: The other reference type is the mysterious object or class that we will look
    at in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP –* *Using Other People's Hard Work*.
  prefs: []
  type: TYPE_NORMAL
- en: So we know that each type of data that we might want to store will require an
    amount of memory. Hence, we must let the Java compiler know the type of the variable
    before we begin to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That's enough of theory. Let's see how we would actually use our variables and
    types. Remember that each primitive type requires a specific amount of real device
    memory. This is one of the reasons that the compiler needs to know what type a
    variable will be of. So we must first **declare** a variable and its type before
    we attempt to do anything with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a variable of type `int` with the name `score`, we would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Simply state the type, in this case `int`, then leave a space, and
    type the name you want to use for this variable. Also note the semicolon on the
    end of the line as usual to show the compiler that we are done with this line
    and what follows, if anything, is not part of the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For almost all the other variable types, declaration would occur in the same
    way. Here are some examples. The variable names are arbitrary. This is like reserving
    a labeled storage box in the warehouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, for each type, we initialize a value to the variable. Think about placing
    a value inside the storage box, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `char` variable uses single quotes (`'`) around the initialized
    value while the `String` uses double quotes (`"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also combine the declaration and initialization steps. In the following
    snippet of code, we declare and initialize the same variables as we did previously,
    but in one step each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whether we declare and initialize separately or together is probably dependent
    upon the specific situation. The important thing is that we must do both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would cause the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There is a significant exception to this rule. Under certain circumstances variables
    can have **default values**. We will see this in [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. But
    it is good practice to both declare and initialize variables.
  prefs: []
  type: TYPE_NORMAL
- en: Changing variables with operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, in almost any program, we are going to need to do something with
    these values. Here is a list of perhaps the most common Java operators that allow
    us to manipulate variables. You do not need to memorize them as we will look at
    every line of code when we use them for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The assignment operator (=)**: This makes the variable to the left of the
    operator the same as the value to the right. For example, `hiScore = score;` or
    `score = 100;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The addition operator (+)**: This adds the values on either side of the operator.
    It is usually used in conjunction with the assignment operator, such as `score
    = aliensShot + wavesCleared;` or `score = score + 100;`. Notice that it is perfectly
    acceptable to use the same variable simultaneously on both sides of an operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The subtraction operator (-)**: This subtracts the value on the right side
    of the operator from the value on the left. It is usually used in conjunction
    with the assignment operator, such as `lives = lives - 1;` or `balance = income
    - outgoings;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The division operator (/)**: This divides the number on the left by the number
    on the right. Again, it is usually used in conjunction with the assignment operator,
    as shown in `fairShare = numSweets / numChildren;` or `recycledValueOfBlock =
    originalValue / .9;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The multiplication operator (*)**: This multiplies variables and numbers,
    such as `answer = 10 * 10;` or `biggerAnswer = 10 * 10 * 10;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The increment operator (++)**: This is a really neat way to add `1` to the
    value of a variable. The `myVariable = myVariable + 1;` statement is the same
    as `myVariable++;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The decrement operator (--)**: You guessed it: a really neat way to subtract
    `1` from something. The `myVariable = myVariable -1;` statement is the same as
    `myVariable--;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The formal names for these operators are slightly different from the names used
    here for explanation. For example, the division operator is actually one of the
    multiplicative operators. But the preceding names are far more useful for the
    purpose of learning Java and if you used the term "division operator", while conversing
    with someone from the Java community, they would know exactly what you mean.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually many more operators than these in Java. We will see a whole
    bunch later in this chapter when we learn about decisions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are curious about operators there is a complete list of them on the Java
    website at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
    All the operators required to complete the projects in this book will be fully
    explained in this book. The link is provided for the curious among us.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing yourself in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try using some declarations, assignments and operators. When we bundle
    these elements together into some meaningful syntax, we call it an expression.
    So let's write a quick app to try some out.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will make a little side project so we can play with everything we have
    learned so far. We will need to create a new project, just as we did in the previous
    chapter but we will not need a UI this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will simply write some Java code and examine its effects by outputting
    the values of variables to the Android console, called **logcat**. We will see
    exactly how this works by building the simple project and examining the code and
    the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is a quick reminder of how to create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Start a** **new Android Studio project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com` or you could use your
    own company website name here instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on the **Next** button. On the next screen, make sure the **Phone
    and Tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater is the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select fewer cutting-edge Android features
    will be available in our apps. A good balance is to select **API 8: Android 2.2
    (Froyo)**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements. However, this is not necessary
    for the example to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.html "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  prefs: []
  type: TYPE_NORMAL
- en: As with all the examples and projects in this book, you can copy or review the
    code from the download bundle. You will find the code for this tutorial in the
    `Chapter3/ExpressionsInJava/MainActivity.java` file. Just create the project as
    described previously and paste the code from `MainActivity.java` file from the
    download bundle to the `MainActivity.java` file that was generated when you created
    the project in Android Studio. Just ensure that the package name is the same as
    the one you chose when the project was created. However, I strongly recommend
    going along with the tutorial so that we can learn how to do everything for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this app uses the logcat console to show its output, you should run this
    app on the emulator only and not on a real Android device. The app will not harm
    a real device, but you just won't be able to see anything happening.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank project called `Expressions In Java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the `onCreate` method just after the line where we use the `setContentView`
    method, add this code to declare and initialize some variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the following code. This code simply outputs the value of our variables
    in a form where we can closely examine them in a minute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s change our variables using the addition operator and another new
    operator. See if you can work out the output values for variables `a`, `b`, and
    `c` before looking at the output and the code explanation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s output the values once more in the same way we did in step 3, but this
    time, the output should be different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on an emulator in the usual way. You can see the output by clicking
    on the **Android** tab from our "useful tabs" area below the Project Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output, with some of the unnecessary formatting stripped off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s discuss what happened. In step 2, we declared and initialized three
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a`: This is an int that holds the value 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: This is a string that holds the name of an eminent computer scientist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: This is a Boolean that holds the value false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So when we output the values in step 3, it should be no surprise that we get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 4, all the fun stuff happens. We add 1 to the value of our int `a`
    using the increment operator like this: `a++;`. Remember that `a++` is the same
    as `a = a + 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add 10 to `a`. Note we are adding 10 to `a` after having already added
    1\. So we get this output for a 10 + 1 + 10 operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now let's examine our string, `b`. We appear to be using the addition operator
    on our eminent scientist. What is happening is what you could probably guess.
    We are adding together two strings `"Alan Turing"` and `"was smarter than the
    average bear Booboo."` When you add two strings together it is called **concatenating**
    and the `+` symbol doubles as the concatenation operator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for our string, we appear to be adding `int a` to it. This is allowed
    and the value of `a` is concatenated to the end of `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This does not work the other way round; you cannot add a string to an `int`.
    This makes sense as there is no logical answer.
  prefs: []
  type: TYPE_NORMAL
- en: '`a = a + b`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expressing yourself in Java](img/8859OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s look at the code that changes our Boolean, `c`, from true to
    false: `c = (1+1=3);`. Here, we are assigning to `c` the value of the expression
    contained within the brackets. This would be straightforward, but why the double
    equals (`==`)? We have jumped ahead of ourselves a little. The double equals sign
    is another operator called the **comparison** operator.'
  prefs: []
  type: TYPE_NORMAL
- en: So we are really asking, *does* 1+1 equal 3? Clearly the answer is false. You
    might ask, "why use `==` instead of `=`?" Simply to make it clear to the compiler
    when we mean to assign and when we mean to compare.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inadvertently using `=` instead of `==` is a very common error.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator (`=`) assigns the value on the right to the value on
    the left, while the comparison operator (`==`) compares the values on either side.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will warn us with an error when we do this but at first glance
    you might swear the compiler is wrong. We will learn more on this comparison operator
    and others later in the chapter and throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's use everything we know and a bit more to make our math game project.
  prefs: []
  type: TYPE_NORMAL
- en: Math game – asking a question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all that knowledge under our belts, we can use it to improve
    our math game. First, we will create a new Android activity to be the actual game
    screen as opposed to the start menu screen. We will then use the UI designer to
    lay out a simple game screen so that we can use our Java skills with variables,
    types, declaration, initialization, operators, and expressions to make our math
    game generate a question for the player. We can then link the start menu and game
    screens together with a push button.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to save typing and just review the finished project, you can use
    the code downloaded from the Packt Publishing website. If you have any trouble
    getting any of the code to work, you can review, compare, or copy and paste the
    code from the already completed code provided in the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed code is in the following files that correspond to the filenames
    we will be using in this tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/java/MainActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/java/GameActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/layout/activity_main.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/layout/activity_game.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, I recommend following this tutorial to see how we can create all of
    the code for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new game activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first need to create a new Java file for the game activity code and
    a related layout file to hold the game activity UI.
  prefs: []
  type: TYPE_NORMAL
- en: Run Android Studio and select your `Math Game Chapter 2` project that we built
    in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*. It might have been opened by default. Now we will create
    the new Android activity that will contain the actual game screen, which will
    run when the player taps the **Play** button on our main menu screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a new activity, we now need another layout file and another Java file.
    Fortunately Android Studio will help us do this. To get started with creating
    all the files we need for a new activity, right-click on the `src` folder in the
    Project Explorer and then go to **New** | **Activity**. Now click on **Blank Activity**
    and then on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to tell Android Studio a little bit about our new activity by entering
    information in the above dialog box. Change the **Activity Name** field to `GameActivity`.
    Notice how the **Layout Name** field is automatically changed for us to `activity_game`
    and the **Title** field is automatically changed to `GameActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish**. Android Studio has created two files for us and has also
    registered our new activity in a manifest file, so we don't need to concern ourselves
    with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you look at the tabs at the top of the editor window, you will see that `GameActivity.java`
    has been opened up ready for us to edit, as shown in the following screenshot:![Creating
    the new game activity](img/8859OS_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that `GameActivity.java` is active in the editor window by clicking on
    the **GameActivity.java** tab shown previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, we talked about how Android overrides some methods for
    us by default, and that most of them were not necessary. Here again, we can see
    the code that is unnecessary. If we remove it, then it will make our working environment
    simpler and cleaner. You might also remember from [Chapter 2](ch02.html "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*, that the process of deleting
    and amending sections of code, although not complex, is a fairly long process.
    To avoid this here, we will simply use the code from `MainActivity.java` as a
    template for `GameActivity.java`. We can then make some minor changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **MainActivity.java** tab in the editor window. Highlight all of
    the code in the editor window using *Ctrl* + *A* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy all of the code in the editor window using the *Ctrl* + *C* on the
    keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the **GameActivity.java** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Highlight all of the code in the editor window using *Ctrl* + *A* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now paste the copied code and overwrite the currently highlighted code using
    *Ctrl* + *V* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that there is an error in our code denoted by the red underlining as
    shown in the following screenshot. This is because we pasted the code referring
    to `MainActivity` in our file that is called `GameActivity`.![Creating the new
    game activity](img/8859OS_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simply change the text **MainActivity** to **GameActivity** and the error will
    disappear. Take a moment to see if you can work out what other minor change is
    necessary, before I tell you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that `setContentView` loads our UI design. Well what we need to do
    is change `setContentView` to load the new design (that we will build next) instead
    of the home screen design. Change `setContentView(R.layout.activity_main);` to
    `setContentView(R.layout.activity_game);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work and we are ready to move on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the Project Explorer where Android Studio puts the two new files it created
    for us. I have highlighted two folders in the next screenshot. In future, I will
    simply refer to them as our `java` code folder or `layout` files folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the new game activity](img/8859OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might wonder why we didn't simply copy and paste the `MainActivity.java`
    file to begin with and saved going through the process of creating a new activity?
    The reason is that Android Studio does things behind the scenes. Firstly, it makes
    the layout template for us. It also registers the new activity for use through
    a file we will see later, called `AndroidManifest.xml`. This is necessary for
    the new activity to be able to work in the first place. All things considered,
    the way we did it is probably the quickest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code at this stage is exactly the same as the code for the home menu screen.
    We state the package name and import some useful classes provided by Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new activity, this time called `GameActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we override the `onCreate` method and use the `setContentView` method
    to set our UI design as the contents of the player''s screen. Currently, however,
    this UI is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can now think about the layout of our actual game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the game screen UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, our math game will ask questions and offer the player some multiple
    choices to choose answers from. There are lots of extra features we could add,
    such as difficulty levels, high scores, and much more. But for now, let's just
    stick to asking a simple, predefined question and offering a choice of three predefined
    possible answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the UI design to the bare minimum suggests a layout. Our target UI
    will look somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Laying out the game screen UI](img/8859OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The layout is hopefully self-explanatory, but let''s ensure that we are really
    clear; when we come to building this layout in Android Studio, the section in
    the mock-up that displays **2 x 2** is the question and will be made up of three
    text views (both numbers, and the **=** sign is also a separate view). Finally,
    the three options for the answer are made up of **Button** layout elements. We
    used all of these UI elements in the previous chapter, but this time, as we are
    going to be controlling them using our Java code, there are a few extra things
    we need to do to them. So let''s go through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file that will hold our game UI in the editor window. Do this by double-clicking
    on `activity_game.xml`. This is located in our UI `layout` folder, which can be
    found in the project explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **Hello World** TextView, as it is not required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Large Text** element on the palette. It can be found under the **Widgets**
    section. Drag three elements onto the UI design area and arrange them near the
    top of the design as shown in the next screenshot. It does not have to be exact;
    just ensure that they are in a row and not overlapping, as shown in the following
    screenshot:![Laying out the game screen UI](img/8859OS_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice in the **Component Tree** window that each of the three TextViews has
    been assigned a name automatically by Android Studio. They are **textView** ,
    **textView2**, and **textView3**:![Laying out the game screen UI](img/8859OS_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio refers to these element names as an **id**. This is an important
    concept that we will be making use of. So to confirm this, select any one of the
    textViews by clicking on its name (id), either in the component tree as shown
    in the preceding screenshot or directly on it in the UI designer shown previously.
    Now look at the **Properties** window and find the **id** property. You might
    need to scroll a little to do this:![Laying out the game screen UI](img/8859OS_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the value for the **id** property is **textView**. It is this `id`
    that we will use to interact with our UI from our Java code. So we want to change
    all the IDs of our TextViews to something useful and easy to remember.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you look back at our design, you will see that the UI element with the **textView**
    id is going to hold the number for the first part of our math question. So change
    the id to `textPartA`. Notice the lowercase `t` in `text`, the uppercase `P` in
    `Part`, and the uppercase `A`. You can use any combination of cases and you can
    actually name the IDs anything you like. But just as with naming conventions with
    Java variables, sticking to conventions here will make things less error-prone
    as our program gets more complicated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select **textView2** and change **id** to `textOperator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the element currently with id **textView3** and change it to `textPartB`.
    This TextView will hold the later part of our question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add another **Large Text** from the palette. Place it after the row of the
    three TextViews that we have just been editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This **Large Text** will simply hold our equals to sign and there is no plan
    to ever change it. So we don't need to interact with it in our Java code. We don't
    even need to concern ourselves with changing the ID or knowing what it is. If
    this situation changed, we could always come back at a later time and edit its
    ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, this new TextView currently displays **Large Text** and we want it
    to display an equals to sign. So in the **Properties** window, find the **text**
    property and enter the value **=**. We have changed the **text** property before
    in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, and you might also like to change the text property for
    `textPartA`, `textPartB`, and `textOperator`. This is not absolutely essential
    because we will soon see how we can change it via our Java code; however, if we
    change the **text** property to something more appropriate, then our UI designer
    will look more like it will when the game runs on a real device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So change the text property of **textPartA** to `2`, **textPartB** to `2`, and
    **textOperator** to `x`. Your UI design and Component tree should now look like
    this:![Laying out the game screen UI](img/8859OS_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the buttons to contain our multiple choice answers, drag three buttons in
    a row, below the **=** sign. Line them up neatly like our target design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just as we did for the TextViews, find the **id** properties of each button,
    and from left to right, change the **id** properties to `buttonChoice1`, `buttonChoice2`,
    and `buttonChoice3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why not enter some arbitrary numbers for the **text** property of each button
    so that the designer more accurately reflects what our game will look like, just
    as we did for our other TextViews? Again, this is not absolutely essential as
    our Java code will control the button appearance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now actually ready to move on. But you probably agree that the UI elements
    look a little lost. It would look better if the buttons and text were bigger.
    All we need to do is adjust the textSize property for each TextView and for each
    Button. Then, we just need to find the textSize property for each element and
    enter a number with the sp syntax. If you want your design to look just like our
    target design from earlier, enter `70sp` for each of the TextView textSize properties
    and `40sp` for each of the Buttons textSize properties. When you run the game
    on your real device, you might want to come back and adjust the sizes up or down
    a bit. But we have a bit more to do before we can actually try out our game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project and then we can move on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As before, we have built our UI. This time, however, we have given all the important
    parts of our UI a unique, useful, and easy to identify ID. As we will see we are
    now able to communicate with our UI through our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a question in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our current knowledge of Java, we are not yet able to complete our math
    game but we can make a significant start. We will look at how we can ask the player
    a question and offer them some multiple choice answers (one correct and two incorrect).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we know enough of Java to declare and initialize some variables
    that will hold the parts of our question. For example, if we want to ask the times
    tables question *2 x 2*, we could have the following variable initializations
    to hold the values for each part of the question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares and initializes two variables of the `int` type,
    each to the value of 2\. We use `int` because we will not be dealing with any
    decimal fractions. Remember that the variable names are arbitrary and were just
    chosen because they seemed appropriate. Clearly, any math game worth downloading
    is going to need to ask more varied and advanced questions than *2 x 2*, but it
    is a start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know that our math game will offer multiple choices as answers. So,
    we need a variable for the correct answer and two variables for two incorrect
    answers. Take a look at these combined declarations and initializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the initialization of the variables for the wrong answers depends
    on the value of the correct answer, and the variables for the wrong answers are
    initialized after initializing the `correctAnswer` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to put these values, held in our variables, into the appropriate
    elements on our UI. The question variables (`partA` and `partB`) need to be displayed
    in our UI elements, `textPartA` and `textPartB`, and the answer variables (`correctAnswer`,
    `wrongAnswer1`, and `wrongAnswer2`) need to be displayed in our UI elements with
    the following IDs: `buttonChoice1`, `buttonChoice2`, and `buttonChoice3`. We will
    see how we do this in the next step-by-step tutorial. We will also implement the
    variable declaration and initialization code that we discussed a moment ago:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open `GameActivity.java` in the editor window. Remember that you can
    do this by double-clicking on **GameActivity** in our `java` folder or clicking
    on its tab above the editor window if `GameActivity.java` is already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of our code will go into the `onCreate` method. It will go after the `setContentView(R.layout.activity_game);`
    line but before the closing curly brace `}` of the `onCreate` method. Perhaps,
    it''s a good idea to leave a blank line for clarity and a nice explanatory comment
    as shown in the following code. We can see the entire `onCreate` method as it
    stands after the latest amendments. The parts in bold are what you need to add.
    Feel free to add helpful comments like mine if you wish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to add the values contained within the variables to the `TextView`
    and `Button` of our UI. But first, we need to get access to the UI elements we
    created. We do that by creating a variable of the appropriate class and linking
    it via the ID property of the appropriate UI element. We already know the class
    of our UI elements: `TextView` and `Button`. Here is the code that creates our
    special class variables for each of the necessary UI elements. Take a close look
    at the code, but don''t worry if you don''t understand all of it now. We will
    dissect the code in detail once everything is working. Enter the code immediately
    after the code entered in the previous step. You can leave a blank line for clarity
    if you wish. Just before you proceed, note that at two points while typing in
    this code, you will be prompted to import another class. Go ahead and do so on
    both occasions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code, if you read the multiline comment, you will see that
    I used the term **object**. When we create a variable type based on a class, we
    call it an object. Once we have an object of a class, we can do anything that
    that class was designed to do. This is very powerful and is explored thoroughly
    in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP
    – Using Other People's Hard Work*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we have five new objects linked to the elements of our UI that we need
    to manipulate. What precisely are we going to do with them? We need to display
    the values of our variables in the text of the UI elements. We can use the objects
    we just created combined with a method provided by the class, and use our variables
    as values for that text. As usual, we will dissect this code further at the end
    of this tutorial. Here is the code to enter directly after the code in the previous
    step. Try and work out what is going on before we look at it together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play with the assignment values for `partA` and `partB`, you can make
    them whatever you like and the game adjusts the answers accordingly. Obviously,
    we shouldn't need to reprogram our game each time we want a new question and we
    will solve that problem soon. All we need to do now is link the game section we
    have just made to the start screen menu. We will do that in the next tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's explore the trickier and newer parts of our code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 2, we declared and initialized the variables required so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in step 3, we got a reference to our UI design through our Java code.
    For the TextViews, it was done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For each of the buttons, a reference to our UI design was obtained like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In step 4, we did something new. We used a the `setText` method to show the
    values of our variables on our UI elements (`TextView` and `Button`) to the player.
    Let's break down one line completely to see how it works. Here is the code that
    shows the `correctAnswer` variable being displayed on `buttonObjectChoice1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By typing `buttonObjectChoice1` and adding a period, as shown in the following
    line of code, we have access to all the preprogrammed methods of that object''s
    class type that are provided by Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The power of Button and the Android API**'
  prefs: []
  type: TYPE_NORMAL
- en: There are actually lots of methods that we can perform on an object of the Button
    type. If you are feeling brave, try this to get a feeling of just how much functionality
    there is in Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to type the period on the end. Android Studio will pop up a list of
    possible methods to use on this object. Scroll through the list and get a feel
    of the number and variety of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding a question in Java](img/8859OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a mere button can do all of this, think of the possibilities for our games
    once we have mastered all the classes contained in Android. A collection of classes
    designed to be used by others is collectively known as an **Application Programming
    Interface(API)**. Welcome to the Android API!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we just want to set the button''s text. So, we use `setText`
    and concatenate the value stored in our `correctAnswer` variable to the end of
    an empty string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We do this for each of the UI elements we require to show our variables.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Playing with autocomplete**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tried the previous tip, *The power of Button and the Android API*, and
    explored the methods available for objects of the Button type, you will already
    have some insight into autocomplete. Note that as you type, Android Studio is
    constantly making suggestions for what you might like to type next. If you pay
    attention to this, you can save a lot of time. Simply select the correct code
    completion statement that is suggested and press *Enter*. You can even see how
    much time you saved by selecting **Help** | **Productivity Guide** from the menu
    bar. Here you will see statistics for every aspect of code completion and more.
    Here are a few entries from mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding a question in Java](img/8859OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, if you get used to using shortcuts early on, you can save a
    lot of time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Linking our game from the main menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the moment, if we run the app, we have no way for the player to actually
    arrive at our new game activity. We want the game activity to run when the player
    clicks on the **Play** button on the main `MainActivity` UI. Here is what we need
    to do to make that happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file `activity_main.xml`, either by double-clicking on it in the Project
    Explorer or by clicking on its tab in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just like we did when building the game UI, assign an ID to the **Play**
    button. As a reminder, click on the **Play** button either on the UI design or
    in the component tree. Find the **id** property in the **Properties** window.
    Assign the `buttonPlay` value to it. We can now make this button do stuff by referring
    to it in our Java code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file `MainActivity.java`, either by double-clicking on it in the Project
    Explorer or clicking on its tab in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `onCreate` method, just after the line where we `setContentView`, add
    the following highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will dissect this code in detail once we have got this working. Basically
    we are making a connection to the **Play** button by creating a reference variable
    to a `Button` object. Notice that both words are highlighted in red indicating
    an error. Just as before, we need to import the Button class to make this code
    work. Use the *Alt* + *Enter* keyboard combination. Now click on **Import class**
    from the popped-up list of options. This will automatically add the required import
    directive at the top of our `MainActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now for something new. We will give the button the ability to *listen* to the
    user clicking on it. Type this immediately after the last line of code we entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. This
    introduces another Java feature that will be more thoroughly explored in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People''s Hard Work"),*OOP – Using
    Other People''s Hard Work*. Setting that aside, we need to make a modification
    to our code now in order to allow the use of an interface that is a special code
    element that allows us to add a functionality, such as listening for button clicks.
    Edit the line as follows. When prompted to import another class, click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have the entire line underlined in red. This indicates an error but it's
    where we should be at this point. We mentioned that by adding `implements View.OnClickListener`,
    we have implemented an interface. We can think of this like a class that we can
    use but with extra rules. The rules of the `OnClickListener` interface state that
    we *must* implement/use one of its methods. Notice that until now, we have optionally
    overridden/used methods as and when they have suited us. If we wish to use the
    functionality this interface provides, namely listening for button presses, then
    we have to add/implement the `onClick` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is how we do it. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty and it doesn''t do anything, but an empty method is enough to
    comply with the rules of the `OnClickListener` interface, and the red line indicating
    that our code has an error has gone. The syntax of these methods we have been
    using, as promised, will be explained in the next chapter when we start to write
    our own methods. Make sure that you type the following code, outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `MainActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that we have an empty line between `{` and `}` of the `onClick` method.
    We can now add code in here to make the button actually do something. Type the
    following highlighted code between `{` and `}` of `onClick`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OK, so that code is a bit of a mouthful to comprehend all at once. See if you
    can guess what is happening. The clue is in the method named `startActivity` and
    the hopefully familiar term, `GameActivity`. Notice that we are assigning something
    to `i`. We will quickly get our app working and then diagnose the code in full.
    Its understanding will be complete when we explore how classes work in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that we have an error: all instances of the word `Intent` are red. We
    can solve this by importing the classes required to make `Intent` work. As before
    press *Alt* + *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game in the emulator or on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our app will now work. This is what the new game screen looks like after pressing
    **Play** on the menu screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking our game from the main menu](img/8859OS_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Almost every part of our code has changed a little and we have added a lot
    to it as well. Let''s go over the contents of `MainActivity.java` and look at
    it line by line. For context, here it is in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen much of this code before, but let''s just go over it a chunk at
    a time before moving on so that it is absolutely clear. The code works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You would probably remember that this first block of code defines what our package
    is called and makes available all the Android API stuff we need for Button, TextView,
    and Activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our `MainActivity.java` file, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Our `MainActivity` declaration with our new bit of code implements `View.OnClickListener`
    that gives us the ability to detect button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next in our code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This previous bit of code hasn't changed since [Chapter 2](ch02.html "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*. It is at the start of
    our `onCreate` method where we first ask the hidden code of `onCreate` to do its
    stuff using `super.onCreate(savedInstanceState);`. Then we set our UI to the screen
    with `setContentView(R.layout.activity_main);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we get a reference to our button with an ID of `buttonPlay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our `onClick` method uses the `Intent` class to send the player to
    our `GameActivity` class and the related UI when the user clicks on the **Play**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you run the app, you will notice that we can now click on the **Play** button
    and our math game will ask us a question. Of course, we can't answer it yet. Although
    we have very briefly looked at how to deal with button presses, we need to learn
    more of Java in order to intelligently react to them. We will also reveal how
    to write code to handle presses from several buttons. This will be necessary to
    receive input from our multiple-choice-centric `game_activity` UI.
  prefs: []
  type: TYPE_NORMAL
- en: Decisions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now summon enough of Java prowess to ask a question but a real math game
    must obviously do much more than this. We need to capture the player's answer,
    and we are nearly there with that—we can detect button presses. From there, we
    need to be able to **decide** whether their answer is right or wrong. Then, based
    on this decision, we have to **choose** an appropriate course of action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's leave the math game aside for now and look at how Java might help us by
    learning some more fundamentals and syntax of the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: More operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at some more operators: we can already add (+), take away (-),
    multiply (*), divide (/), assign (=), increment (++), compare (==), and decrement
    (--) with operators. Let''s introduce some more super-useful operators, and then
    we will go straight to actually understanding how to use them in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry about memorizing every operator given here. Glance at them and their
    explanations and then move quickly on to the next section. There, we will put
    some operators to use and they will become much clearer as we see a few examples
    of what they allow us to do. They are presented here in a list just to make the
    variety and scope of operators plain from the start. The list will also be more
    convenient to refer back to when not intermingled with the discussion about implementation
    that follows it.
  prefs: []
  type: TYPE_NORMAL
- en: '**==**: This is a comparison operator we saw this very briefly before. It tests
    for equality and is either true or false. An expression like `(10 == 9);`, for
    example, is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**!**: The logical NOT operator. The expression, `! (2+2==5)`.`)`, is true
    because 2+2 is NOT 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**!=**: This is another comparison operator, which tests if something is NOT
    equal. For example, the expression, `(10 != 9);)`, is true, that is, 10 is not
    equal to 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**>**: This is another comparison operator, which tests if something is greater
    than something else. The expression, `(10 > 9);)`, is true. There are a few more
    comparison operators as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<**: You guessed it. This tests whether the value to the left is less than
    the value to the right or not. The expression, `(10 < 9);`, is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**>=**: This operator tests whether one value is greater than or equal to the
    other, and if either is true, the result is true. For example, the expression,
    `(10 >= 9);`, is true. The expression, `(10 >= 10);`, is also true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<=**: Like the preceding operator, this operator tests for two conditions
    but this time, less than and equal to. The expression, `(10 <= 9);`, is false.
    The expression, `(10 <= 10);`, is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**&&**: This operator is known as logical AND. It tests two or more separate
    parts of an expression and all parts must be true in order for the result to be
    true. Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression, `((10 > 9) && (10 < 11));`, is true because
    both parts are true. The expression, `((10 > 9) && (10 < 9));`, is false because
    only one part of the expression is true and the other is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**||**: This operator is called logical OR. It is just like logical AND except
    that only one of two or more parts of an expression need to be true for the expression
    to be true. Let''s look at the last example we used but replace the && sign with
    ||. The expression, `((10 > 9) || (10 < 9));`, is now true because one part of
    the expression is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these operators are virtually useless without a way of properly using
    them to make real decisions that affect real variables and code. Let's look at
    how to make decisions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Decision 1 – If they come over the bridge, shoot them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw, operators serve hardly any purpose on their own but it was probably
    useful to see just a part of the wide and varied range available to us. Now, when
    we look at putting the most common operator, `==`, to use, we can start to see
    the powerful yet fine control that operators offer us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make the previous examples less abstract using the Java `if` keyword and
    a few conditional operators with a fun story and some code.
  prefs: []
  type: TYPE_NORMAL
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Java program to convey his last orders after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command the captain wants to make sure his troops understand is this:
    If they come over the bridge, shoot them.'
  prefs: []
  type: TYPE_NORMAL
- en: So how do we simulate this situation in Java? We need a Boolean variable `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If the `isComingOverBridge` Boolean is true, the code inside the opening and
    closing curly braces will run. If not, the program continues after the `if` block
    without running it.
  prefs: []
  type: TYPE_NORMAL
- en: Decision 2 – Else, do this
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The captain also wants to tell his troops what to do (stay put) if the enemy
    is not coming over the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Now we introduce another Java keyword, `else`. When we want to explicitly do
    something and the `if` block does not evaluate to true, we can use `else`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we use `else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge and has more troops? His squad will be
    overrun. So, he came up with this code (we''ll use some variables as well this
    time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the captain''s last concern was that if the enemy came over the bridge
    waving the white flag of surrender and were promptly slaughtered, then his men
    would end up as war criminals. The Java code needed was obvious. Using the `wavingWhiteFlag`
    Boolean variable he wrote this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'But where to put this code was less clear. In the end, the captain opted for
    the following nested solution and changing the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that we can nest `if` and `else` statements inside of one
    another to create even deeper decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We could go on making more and more complicated decisions but what we have seen
    is more than sufficient as an introduction. Take the time to reread this if anything
    is unclear. Who knows, there might even be a tricky logic question in the self-test
    at the end of the chapter. It is also important to point out that very often,
    there are two or more ways to arrive at the solution. The *right* way will usually
    be the way that solves the problem in the clearest and simplest manner.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to make decisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the vast and virtually limitless possibilities of combining the
    Java operators with `if` and `else` statements. But sometimes a decision in Java
    can be better made in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: When we have to make a decision based on a clear list of possibilities that
    doesn't involve complex combinations, then **switch** is usually the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start a `switch` decision like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, an argument could be an expression or a variable.
    Then within the curly braces, we can make decisions based on the argument with
    case and break elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can see that in the previous example, each case states a possible result
    and each break denotes the end of that case as well as the point at which no further
    case statements should be evaluated. The first break encountered takes us out
    of the switch block to proceed with the next line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use **default** without a value to run some code if none of the
    case statements evaluate to true, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Supposing we are writing an old-fashioned text adventure game—the kind of game
    where the player types commands such as `"Go East"`, `"Go West"`, `"Take Sword"`,
    and so on. In this case, switch could handle that situation like this example
    code and we could use `default` to handle the case of the player typing a command
    that is not specifically handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will use `switch` so that our `onClick` method can handle
    the different multiple-choice buttons of our math game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java has even more operators than we have covered here. We have looked at all
    the operators we are going to need in this book and probably the most used in
    general. If you want the complete lowdown on operators, take a look at the official
    Java documentation at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
  prefs: []
  type: TYPE_NORMAL
- en: Math game – getting and checking the answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will detect the right or wrong answer and provide a pop-up message to
    the player. Our Java is getting quite good now, so let's dive in and add these
    features. I will explain things as we go and then, as usual, dissect the code
    thoroughly at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The already completed code is in the download bundle, in the following files
    that correspond to the filenames we will create/autogenerate in Android Studio
    in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/java/MainActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/java/GameActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/layout/activity_main.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/layout/activity_game.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, I recommend following this tutorial step by step to see how we can
    create all of the code for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `GameActivity.java` file visible in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add the click detection functionality to our `GameActivity`,
    just as we did for our `MainActivity`. However, we will go a little further than
    the last time. So let''s do it step by step as if it is totally new. Once again,
    we will give the buttons the ability to *listen* to the user clicking on them.
    Type this immediately after the last line of code we entered in the `onCreate`
    method but before the closing `}`. This time of course, we need to add some code
    to listen to three buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. Again,
    we need to make a modification to our code in order to allow the use of an interface,
    the special code element that allows us to add functionalities such as listening
    to button clicks. Edit the line as follows. When prompted to import another class,
    click on **OK**. Consider this line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change it to the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have the entire preceding line underlined in red. This indicates an error
    but it is where we should be at this point. We mentioned that by adding `implements
    View.OnClickListener`, we have implemented an interface. We can think of this
    like a class that we can use, but with extra rules. One of the rules of the `OnClickListener`
    interface is that we must implement one of its methods, as you might remember.
    Now we will add the `onClick` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following code. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty; it doesn''t do anything but an empty method is enough to comply
    with the rules of the `OnClickListener` interface and the red line that indicated
    an error has gone. Make sure that you type the following code outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `GameActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that we have an empty line between the `{` and `}` braces of our `onClick`
    method. We can now put some code in here to make the buttons actually do something.
    Type the following in between `{` and `}` of `onClick`. This is where things get
    different from our code in `MainActivity`. We need to differentiate between the
    three possible buttons that could be pressed. We will do this with the `switch`
    statement that we discussed earlier. Look at the `case` criteria; they should
    look familiar. Here is the code that uses the switch statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each `case` element handles a different button. For each button case, we need
    to get the value stored in the button that was just pressed and see if it matches
    our `correctAnswer` variable. If it does, we must tell the player they got it
    right, and if not, we must tell them they got it wrong. However, there is still
    one problem we have to solve. The `onClick` method is separate from the `onCreate`
    method and the Button objects. In fact, all the variables are declared in the
    `onCreate` method. If you try typing the code from step 9 now, you will get lots
    of errors. We need to make all the variables that we need in `onClick` available
    in `onClick`. To do this, we will move their declarations from above the `onCreate`
    method to just below the opening `{` of `GameActivity`. This means that these
    variables become variables of the `GameActivity` class and can be seen anywhere
    within `GameActivity`. Declare the following variables like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now change the initialization of these variables within `onCreate` as follows.
    The actual parts of code that need to be changed are highlighted. The rest is
    shown for context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the top of our `onClick` method as well as the first `case` statement
    for our `onClick` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are the rest of the `case` statements that do the same steps as the code
    in the previous step except handling the last two buttons. Enter the following
    code after the code entered in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program, and then we will look at the code carefully, especially that
    odd-looking `Toast` thing. Here is what happens when we click on the leftmost
    button:![Math game – getting and checking the answer](img/8859OS_03_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how we did it: In steps 1 through 6, we set up handling for our multi-choice
    buttons, including adding the ability to listen to clicks using the `onClick`
    method and a `switch` block to handle decisions depending on the button pressed.'
  prefs: []
  type: TYPE_NORMAL
- en: In steps 7 and 8, we had to alter our code to make our variables available in
    the `onClick` method. We did this by making them member variables of our `GameActivity`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we make a variable a member of a class, we call it a **field**. We will
    discuss exactly when a variable should be a field and when it shouldn't in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 9 and 10, we implemented the code that actually does the work in our
    switch statement in `onClick`. Let's take a line-by-line look at the code that
    runs when `button1` is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the `case` statement is true when the button with an id of `buttonChoice1`
    is pressed. Then the next line of code to execute is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line gets the value on the button using two methods. First, `getText`
    gets the number as a string and then `Integer.parseInt` converts it to an integer.
    The value is stored in our `answerGiven` variable. The following code executes
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement tests to see if the `answerGiven` variable is the same as
    `correctAnswer` using the `==` operator. If so, the `makeText` method of the `Toast`
    object is used to display a congratulatory message. If the values of the two variables
    are not the same, the message displayed is a bit more negative one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Toast` line of code is possibly the most evil thing we have seen thus
    far. It looks exceptionally complicated and it does need a greater knowledge of
    Java than we have at the moment to understand. All we need to know for now is
    that we can use the code as it is and just change the message, and it is a great
    tool to announce something to the player. By the end of [Chapter 6](ch06.html
    "Chapter 6. OOP – Using Other People''s Hard Work"), *OOP – Using Other People''s
    Hard Work*, the code for `Toast` will be clear. If you really want an explanation
    now, you can think of it like this: when we made button objects, we got to use
    all the button methods. But with Toast, we used the class directly to access its
    `makeText` method without creating an object first. We can do this process when
    the class and its methods are designed to allow it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we break out of the whole `switch` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have improved the project as far as we can with what we learned
    in this chapter, why not test your understanding of everything you've learned
    so far?
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What does this code do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Q2) Which of these lines causes an error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Q3) We talked a lot about operators and how different operators can be used
    together to build complicated expressions. Expressions, at a glance, can sometimes
    make the code look complicated. However, when looked at closely, they are not
    as tough as they seem. Usually, it is just a case of splitting the expressions
    into smaller pieces to work out what is going on. Here is an expression that is
    more convoluted than anything else you will ever see in this book. As a challenge,
    can you work out: what will `x` be?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot in this chapter. We went from knowing nothing about Java syntax
    to learning about comments, variables, operators, and decision making.
  prefs: []
  type: TYPE_NORMAL
- en: As with any language, mastery of Java can be achieved by simply practicing,
    learning, and increasing our vocabulary. At this point, the temptation might be
    to hold back until mastery of the current Java syntax has been achieved, but the
    best way is to move on to new syntax at the same time as revisiting what we have
    already begun to learn.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally finish our math game by adding random questions
    of multiple difficulties as well as using more appropriate and random wrong answers
    for the multiple choice buttons.
  prefs: []
  type: TYPE_NORMAL
- en: To enable us to do this, we will first learn some more Java.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Discovering Loops and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to repeatedly execute portions of our code
    in a controlled and precise way by looking at different types of loops in Java.
    These include `while` loops, `do-while` loops, and `for` loops. We will learn
    about the best occasions to use the different types of loops.
  prefs: []
  type: TYPE_NORMAL
- en: Then we will briefly cover the topic of random numbers. We will also see how
    the Java `Random` class can be used. This will obviously be of great help in enhancing
    our math game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at **methods**. They allow us to compartmentalize our code
    into more manageable blocks. We will then see how to share data between methods
    and divide programming tasks to simplify problems.
  prefs: []
  type: TYPE_NORMAL
- en: We will then use all that we have learned about loops, random numbers and methods
    on our math game project. For example, we will make the game change the question
    after each time we attempt the answer.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add question difficulty levels and random questions within a range
    appropriate for a given difficulty level. We will show and update our score. The
    score goes up faster depending upon the difficulty level of the question answered
    (correctly). Eventually, even the best mathematicians among us should be beaten
    by the game. Nevertheless, most of us will hopefully get a bit further than what
    is shown in the next screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero. This is what the game will look like when we are
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering Loops and Methods](img/8859OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about looping in multiple types of loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to generate random numbers in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn everything about Java methods, including how to write and call them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significantly enhance our math game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be completely reasonable to ask what loops have to do with programming,
    but they are exactly what the name implies. They are a way of performing the same
    part of the code more than once, or looping over the same part of code, but potentially
    for a different outcome each time.
  prefs: []
  type: TYPE_NORMAL
- en: This can simply mean doing the same thing until the code being looped over prompts
    the loop to end. It could prompt the loop after a predetermined number of times
    as specified by the loop code itself. It could also prompt the loop when a predetermined
    situation or **condition** is met. Or there could be a combination of more than
    one of these ways of prompting the loop to end. Along with `if`, `else`, and `switch`,
    loops are part of the Java **control flow statements**.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at all the major types of loop that Java offers us to control our
    code, and after we have looked at methods, we will use some of them to implement
    the enhancements to our math game. Let's proceed to our first type of loop.
  prefs: []
  type: TYPE_NORMAL
- en: While loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `while` loop has the simplest syntax. Recollect the `if` statements in [Chapter
    3](ch03.html "Chapter 3. Speaking Java – Your First Game"), *Speaking Java – Your
    First Game*. We can put virtually any combination of operators and variables in
    the conditional expression of the `if` statement. If the expression evaluated
    to `true`, then the code in the body of the `if` block is executed. Similarly,
    in the `while` loop, we put an expression that can evaluate to `true` or `false`,
    as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here is that outside the `while` loop, an integer, `x`, is
    declared and initialized to `10`. Then the `while` loop begins. Its condition
    is `x > 0`, so it will continue looping through the code in its body until the
    condition evaluates to `false`. Hence, the code will execute 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: On the first pass, `x` is equal to `10`, then `9`, then `8`, and so on. But
    once `x` becomes equal to `0`, it is obviously no longer greater than `0`. So
    the program will exit the `while` loop and continue with the first line of code
    after the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Take a look at this example of a `while` loop that never executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, there is no limit to the complexity of the condition expression or
    the amount of code that can be written in the loop body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `while` loop would continue to execute until either `playerLive`s
    or `alienShips` becomes equal to or less than zero. As soon as one of these conditions
    occurs, the expression evaluates to `false` and the program continues to execute
    from the first line of code after the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete, even if the expression evaluates to `false` somewhere in between,
    as the condition is not checked again until the code tries to start another pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever (which is unsurprisingly called an **infinite loop**),
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Breaking out of a loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might use an infinite loop like the loop in the preceding example so that
    we can decide when to exit the loop from within its body. We would do this using
    the `break` keyword when we are ready to leave the loop body, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have been able to guess that we can combine any of the decision making
    tools like `if`, `else`, and `switch` within our `while` loops and the rest of
    the loops we will look at in a minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: It would be simple to go on for many more pages demonstrating the versatility
    of `while` loops, but at some point, we want to get back to doing some real programming.
    So here is one last concept, combined with `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The continue keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `continue` keyword acts in a way similar to `break`—up to a point. The
    `continue` keyword will break out of the loop body but will also check the condition
    expression afterwards, so the loop *could* run again. The following example will
    show the use of `continue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Do-while loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `do-while` loop is very much the same as a `while` loop with the exception
    that it evaluates its expression after the body. This means that a `do-while`
    loop will always execute at least once, as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `break` and `continue` keywords can also be used in `do-while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `for` loop has a slightly more complicated syntax than a `while` and `do-while`
    loop as it take three parts to initialize. Take a look at the following `for`
    loop first. Then we will break it apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The apparently obscure form of the `for` loop is clearer when put like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'To clarify further, we have the following in a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaration and initialization**: We create a new `int` variable, `i`, and
    initialize it to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition**: Just like the other loops, this refers to the condition that
    must be evaluated to true for the loop to continue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change after each pass through loop**: In the preceding example, `i++` means
    that 1 is added to `i` on each pass. We could also use `i--` to reduce/decrement
    `i` on each pass, which is shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `break` and `continue` can also be used in `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop essentially takes control of initialization, condition evaluation,
    and the control variable on itself. We will be using a `for` loop to enhance our
    math game right after we take a look at random numbers and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into methods, we will first take a look at how we can create
    random numbers because this is how we will generate our random questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the hard work is done for us by the `Random` class. First we need to create
    an object of the `Random` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use our new object''s `nextInt` method to generate a random number
    within a certain range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The range for the number that we enter starts from zero. So the preceding line
    of code will generate a random number between 0 and 9\. If we want a random number
    between 1 and 10, we just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often in these early chapters, we need to accept there is a bit of magic going
    on in objects like Random. In [Chapter 6](ch06.html "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*, we will be ripping
    open the black boxes and even making our own. We will be able to write our own
    classes and our own methods within those classes.
  prefs: []
  type: TYPE_NORMAL
- en: A good start is a look at regular vanilla methods, which we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what exactly are Java methods? A method is a collection of variables, expressions,
    and control flow statements. We have already been using lots of methods; we just
    haven't looked inside any yet.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Java methods will be the last topic for this chapter before we
    get practical and use what we have learned to enhance our math game.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of a method that we write is called the **signature**. Here
    is a made-up example of a signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an opening and closing pair of curly braces with some code that the method
    performs, and we have a complete method, or a **definition**. Here is a made-up
    but syntactically correct method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then use our new method from another part of our code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: At the point where we call `setCoordinates`, our program's execution would branch
    to the code contained within that method, which would run until it reaches its
    end or is told to return. Then the code would continue running from the first
    line after the method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a method, complete with the code to make the method
    return to the code that called it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to use the preceding method could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, we don't need to write methods to add two `int` variables together,
    but the preceding example helps us see a little more of the working of methods.
    First, we pass the values `2` and `4`. In the signature of the method, the value,
    `2`, is assigned to `int a` and the value, `4`, is assigned to `int b`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the method body, the `a` and `b` variables are added and used to initialize
    a new variable, which is the `int` answer. The `return answer` line does just
    that. It returns the value stored in `answer` to the calling code, causing `myAnswer`
    to be initialized with the value of `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each of the method signatures in the preceding examples varies a
    little. The reason for this is that the Java method signature is quite flexible,
    allowing us to build exactly the methods we require.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how the method signature defines how the method must be called and how
    a method must return a value, if it must, deserves further discussion. Let's give
    each part of that signature a name so that we can break it into chunks and learn
    about the parts separately.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a method signature with its parts labeled and ready for discussion.
    You can also take a look at the following table to further identify which part
    of the signature is which. This will make the rest of our discussion on methods
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifier** | **return type** | **name of the method** (**parameters**)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples that we have used so far so that you can clearly identify
    the part of the signature under discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Part of signature | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Modifier | `public`, `private`, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Return type | `int`, `boolean`, `float`, and so on, or any Java type, expression,
    or object |'
  prefs: []
  type: TYPE_TB
- en: '| Name of the method | `shootLazers`, `setCoordinates`, `addAToB`, and so on
    |'
  prefs: []
  type: TYPE_TB
- en: '| Parameters | (`int number`, `string type`), (`int x`, `int y`), (`int a`,
    `int b`), and so on |'
  prefs: []
  type: TYPE_TB
- en: Modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our previous examples, we only used a modifier twice, partly because the
    method doesn''t have to use the modifier. The modifier is a way of specifying
    which code can use your method. Some of the types of modifiers are `public` and
    `private`. Actually, regular variables can have modifiers too, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Modifiers (for methods and variables) are an essential Java topic but they are
    best dealt with when we discuss the other vital Java topic we have skirted around
    a few times so far—objects and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously promised, these mysterious objects will be revealed in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*. However, as we can see from our example methods and
    from the fact that all the examples we have written so far work just fine, modifiers
    are not necessary to facilitate our learning so far.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next up is the `return` type. Like a modifier, a `return` type is also optional,
    although it is more immediately useful to us. So let''s look a bit closer. We
    have seen that our methods can get anything done. But what if we need the result
    from what they have done? The simplest example of a return type we have seen so
    far was this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `return` type in the signature is highlighted. So the `return`
    type is `int`. The `addAToB` method sends back (returns) to the code that called
    it a value that will fit in an `int` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `return` type can be any Java type we have seen so far. The method, however,
    does not have to return a value at all. In this case, the signature must use the
    `void` keyword as the `return` type. When the `void` keyword is used, the method
    body must not attempt to return a value as this will cause a compiler error. It
    can, however, use the `return` keyword without a value. Here are some combinations
    of return type and uses of the `return` keyword that are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Another combination of `return` and `void` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is yet another combination of `return` and `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call each of the preceding methods one by one, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code would execute all the code statements in each method one
    by one. If the method signature had parameters, the code that calls the method
    would look slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: Name of a method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we design our own methods, the method name is arbitrary, but there is
    a convention to use verbs that clearly explain what the method will do. Another
    convention is of the first letter of the first word in the name being lower case,
    and the first letter of each of the subsequent words being uppercase. This is
    called **camel case** because the shape the name can form has a hump in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This name is perfectly legitimate and will work. However, let''s take a look
    at a much clearer example that uses the conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: These are much clearer method names.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We know that a method can return a result to the calling code. What if we need
    to share some data values from the calling code with the method? Parameters allow
    us to share values with the method. We have already seen an example with parameters
    when looking at return types. We will look at the same example but a little more
    closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters in this code are highlighted. Notice that in the first line
    of the method body, we use `a + b` as if they are already declared and initialized.
    Well, that''s because they are. The parameters of the method signature is their
    declaration, and the code that calls the method initializes them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as we have partly seen in previous examples, we don''t have to use `int`
    in our parameters. We can use any Java type, including types we design ourselves.
    We can mix and match types as well. We can also use as many parameters as necessary
    to solve our problem. An example of mixed Java types might help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: It's now time to get serious about our body.
  prefs: []
  type: TYPE_NORMAL
- en: Getting things done in the method body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The body is the part we have been avoiding so far with comments like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: But actually, we know exactly what to do here already. Any Java syntax we have
    learned so far will work in the body of a method. In fact, if we look back, all
    of the code we have written so far has been in a method, albeit somebody else's
    method. For example, we wrote code in the `onCreate` and `onClick` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing we can do next is write some methods that actually do something
    in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Using methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don't have to mess around with our math game project. We will quickly create
    a new blank project for each of the next two explorations into methods.
  prefs: []
  type: TYPE_NORMAL
- en: We also don't need to spend time making a UI. We will use the Android console
    to view the results and discuss the implications of our examples of methods. As
    we are using the Android console to view the results of our work with methods,
    we will need to run all of these examples on the Android emulator, not on a real
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to set up a real device to output to the console, but we have
    not covered that in this book. If you want to find out more about using your actual
    device for debugging, take a look at the article at [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can open the already typed code files in the usual way. The next
    two examples on methods can be found in the Packt Publishing code download in
    the `Chapter4` folder and the `AWorkingMethod` and `ExploringMethodOverloading`
    subfolders.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is a quick reminder on how to create a new blank project.
  prefs: []
  type: TYPE_NORMAL
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New Project...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com`, or you could use your
    own company website's name here instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on the **Next** button. On the next screen, ensure that the **Phone
    and tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select, the fewer cutting-edge Android
    features we can have in our apps. A good balance is to select **API 8: Android
    2.2 (Froyo)**. Go ahead and do that now as shown in the next screenshot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements, but this is not necessary
    for the example to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.html "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  prefs: []
  type: TYPE_NORMAL
- en: A working method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let's make ourselves a simple working method, complete with return types
    and a fully functioning body.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method will take three numbers as parameters and return a `true` or `false`
    value to the calling code depending upon whether one of the three numbers was
    randomly generated within the method or not:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank project called `A Working Method`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this method, we will use the `Random` class we saw earlier and its `randInt`
    method as a part of the demonstration. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we declare a Boolean variable called `found` and initialize it to `false`.
    We will change `found` to `true` if and when we guess the random number correctly.
    Next, we declare our random number and print some useful values to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last portion of code in our method tests to see whether there is a match
    for any of our passed-in parameters, prints some output, and then returns `true`
    or `false` using the `found` variable to the calling code in the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the code and print some values to the Android console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Launch an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app on the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All our console messages have a tag called **info**. The console window will
    already have appeared underneath the editor window. We can filter its contents
    to only show our messages by typing `info` in the search box, as shown in the
    following screenshot:![A working method](img/8859OS_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the search filter and the console output.
    We will now run through the code and explain the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, here is the precise console output, without the extraneous date,
    time, and package name added to the beginning of each line. Remember that we are
    dealing with a random number, so your output may vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what is happening. In step 2, we started writing our first method.
    We called it `guessANumber`. It has three `int` parameters and will return a Boolean.
    Remember that these three `int` parameters become fully initialized variables.
    First of all, however, in our method, we simply output the values of the new variables
    passed in as parameters as well as a message confirming that the code in our method
    is currently being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 3, we added more code to our method. We declared and initialized a
    Boolean variable called `found`, which we will use to return a value to the calling
    code and let the calling code know whether one of the parameters passed in was
    the same as the random number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Next (still in step 3), we generated a random number in the same way as we
    did earlier in the chapter. We also used `Log` to output the random number so
    that we can examine what went on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 4, we used an `if` statement with the logical OR operator to detect
    whether any of the passed-in parameters matches the random number we just generated,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition is true, that is, if any of `try1`, `try2`, or `try3` equals
    `randNum`, then the following code is run. Our `found` Boolean value is set to
    `true` and a message is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition is not true, the `else` statement is executed, a different
    message is printed, and the `found` variable is left the same as it was—`false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our method, we return the `found` variable, which will be either
    `true` or `false`, to the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we look at step 5, which is the code in the `onCreate` method, which calls
    our `guessANumber` method in the first place. We start by simply printing a message
    saying that we are in `onCreate` at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we make the call to `guessANumber` with the three parameters. In this
    case, we use 1, 2, and 3, but any `int` values would have worked. However, we
    wrap the call in an `if` statement. This means that the `return` value from the
    method will be used to evaluate the `if` statement. Simply put, if `true` is returned,
    the `if` statement will be executed and "**Found It**!" will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'On the contrary, if `false` is returned, the `else` statement gets executed
    and "**Can''t find it**" is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we are dealing with random numbers, so you might need to run
    it a few times before you see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A working method](img/8859OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, you should note that the guesses sent to the function as parameters
    are arbitrary. As long as all the numbers are between 0 and 5 and are not duplicated,
    they will together have a 50 percent chance of finding the random number.
  prefs: []
  type: TYPE_NORMAL
- en: On a closing note, if you've to read only one tip in this whole book, it should
    be this one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Printing variable values to the console is a great way to examine what is going
    on inside your game and to find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example of methods.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring method overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we are learning, methods are really diverse and deep as a topic, but hopefully,
    taking a step at a time, we will see they are not daunting in any way. We will
    be using what we have learned about methods when we enhance our math game. We
    will be exploring methods even more deeply in [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. For
    now, however, it will serve us well to look at one more topic on methods. Let's
    create a new project to explore **method** **overloading**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will now see, we can create more than one method with the same name,
    provided the parameters are different. The code in this project is vastly simpler
    than that of the last project. It is how this code works that might appear slightly
    curious until we analyze it later:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank project called `Exploring Method Overloading`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the first method, we will simply call it `printStuff` and pass an `int`
    variable via a parameter to be printed. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also call the second method `printStuff` but pass a `string` variable
    to be printed. Copy the code for this method after the closing bracket of `onCreate`
    but before the closing bracket of `MainActivity`. Again, when you are prompted
    to import any classes, simply click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Yet again, we will call this third method `printStuff` but pass a `string`
    variable and an `int` variable to be printed. As before, copy the code for this
    method after the closing bracket of `onCreate` but before the closing bracket
    of `MainActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the methods and print some values to the Android console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Launch an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app on the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Java has treated three methods with the same name as totally
    different methods. This, as we have just demonstrated, can be really useful. It
    is called **method overloading**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Method overloading and overriding confusion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloading and overriding are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading occurs when we have more than one method with the same name but
    different parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding occurs when we essentially replace a method with the same name and
    the same parameter list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know enough about overloading and overriding to complete this book, but if
    you are brave and your mind is wandering, you can override an overloaded method.
    However, that is something for another time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the preceding code works. In each of the three steps (2, 3, and
    4), we create a method called `printStuff`, but each `printStuff` method has different
    parameters, so each is a different method that can be called individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The body of each of the methods is simple. It just prints the passed-in parameters
    and confirms which version of the method is being called currently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important part of our code is when we make it plain which method we
    want to call, using the appropriate parameters. In step 5, we call each of them
    in turn, using the appropriate parameters so that Java knows the exact method
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Now we know more than enough about methods, loops, and random numbers to make
    some improvements to our math game.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our math game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add some features to our math game using what we have just learned
    about methods and loops.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the code is available for copying in the `Chapter4` folder of the
    code download. The project is in the `MathGameChapter4` subfolder and encompasses
    all the remaining phases of improvement covered in this chapter, including enhancing
    the UI, amending our game activity, `setQuestion`, `updateScoreAndLevel`, `isCorrect`,
    and calling our new methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will make the game change the question after each time we attempt the answer.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add difficulty levels to questions and random questions but within
    a range appropriate for that difficulty level.
  prefs: []
  type: TYPE_NORMAL
- en: We will show and update our score. The score goes up faster depending on the
    difficulty level of the question answered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get on with modifying our math game UI to incorporate our new game features.
    We will be adding a TextView to display the score and another TextView to display
    the level.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_game.xml` file in the editor window. We will add a new TextView
    to the very bottom of our UI for our score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Large Text** element from **Palette** and place it to the left, below
    our three answer buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to change the **id** property so that we can access our new TextView
    from our Java code. Ensure that the new TextView is selected by clicking on it.
    Now, in the **Properties** window, change the **id** property to `textScore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the sake of clarity (although this step serves no use in programming), change
    the **text** property to `Score:999`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now put another **Large Text** element to the right of the one we just configured
    and change the **id** property to `textLevel`. The lower part of our UI should
    now look like this:![Enhancing the UI](img/8859OS_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, for the sake of clarity (although this step serves no use in programming),
    change the **text** property to `Level:4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have just added two new TextView elements and assigned them both an ID that
    we can refer to in our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have probably realized by now that the precise layout and size of our UI
    elements are unimportant as far as getting the game to work is concerned. This
    gives us a lot of flexibility in designing layouts for different screen sizes.
    As long as each layout for each screen size contains the same element types with
    the same IDs, the same Java code will work for different layouts. If you want
    to know more about designing for multiple screen sizes, take a look at [http://developer.android.com/training/multiscreen/screensizes.html](http://developer.android.com/training/multiscreen/screensizes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our enhanced UI and an understanding of how the Java `Random`
    class works, we can add the Java code to implement our new features.
  prefs: []
  type: TYPE_NORMAL
- en: The new Java code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously explained, the project code is available in the `Chapter4` folder
    of the downloadable code. The project is called `MathGameChapter4` and encompasses
    all the improvements covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this phase, we will be adding lots of new code, moving some existing code,
    and modifying some existing code too. As so much is changing, we are going to
    approach the code from the very beginning. The new code will be explained completely,
    the code that has moved will be pointed out with a reason, and the code that has
    stayed the same and in the same place will have the least explanation.
  prefs: []
  type: TYPE_NORMAL
- en: We will first make some modifications and deletions to our existing code. We
    will then look at designing and implementing each of our new methods to improve
    our code and add our new features.
  prefs: []
  type: TYPE_NORMAL
- en: Amending GameActivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s perform the necessary amendments and deletions to our current
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `GameActivity.java` file in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to consider the scope of the objects that represent our UI elements.
    Both `textObjectPartA` and `textObjectPartB` need to be accessible from the methods
    we will be creating soon. So let''s move their declarations, as we did with the
    multi-choice buttons in the previous chapter, out of the `onCreate` method so
    that they are accessible everywhere in our `GameActivity` class. The following
    code shows all our declarations so far. They are present immediately after the
    start of the `GameActivity` class. The recently added (or moved) declarations
    are highlighted. Notice that we have also added declarations for our two new TextViews
    and for the score and level displays. In addition, there are two new `int` variables
    that we can manipulate for our score and to keep track of our level. They are
    `currentScore` and `currentLevel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All of the code that assigns text to our Buttons or TextViews objects, and
    the code that initializes the parts of our question and assigns the values for
    our wrong answers, are now going to change and move, so we need to delete it all.
    Everything shown in the following code is to be deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code snippet needs to be deleted too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For clarity and context, here is the entire `onCreate` method as it currently
    stands. There is nothing new here, but you can see your code, which links our
    Button and TextView objects that we declared in step 2\. Again, this code includes
    our two new TextViews, which are highlighted, but everything else, which is described
    in steps 3 and 4, is deleted. As before, there is a piece of code that makes our
    game listen to button clicks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will delete some more code that we don''t need because we are going
    to make it more efficient by compartmentalizing it into our new methods and adding
    our new features at the same time. So in our `onClick` method, in each case of
    our `switch` statement, we want to delete the `if` and the `else` statements.
    We will be completely rewriting these, but we will leave in place the code that
    initializes our `answerGiven` variable. Our `onClick` method will now look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wow! That was a lot of code, but as we saw along the way, there were no new
    concepts. In step 2, we simply moved the initialization of our Button and TextView
    objects to a place where they will now be visible from anywhere within our class.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 3 and 4, we did a fair bit of deletion because we will no longer be
    making the question or populating the multi-choice buttons in `onCreate`, as this
    is not flexible enough. We will soon see how we improve on this.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we deleted the code that tested whether the answer was correct or
    incorrect. However, as we saw, we still initialized the `answerGiven` variable
    in the same way—in the appropriate case of our `switch` statement in the `onClick`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now we are ready to consider and design some new methods to compartmentalize
    our code, avoid repetitions in it, and add our extra features. Consider the following
    methods that we will soon implement.
  prefs: []
  type: TYPE_NORMAL
- en: The methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now walk through writing some methods. As we will see, the methods
    will compartmentalize our code and prevent the implementation of our new features
    from causing the code to become too long and sprawling:'
  prefs: []
  type: TYPE_NORMAL
- en: We will write a `setQuestion` method to prepare a question of appropriate difficulty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write an `updateScoreAndLevel` method that will do just that. We will
    also write an `isCorrect` method that one of our other methods will use to evaluate
    the correctness of the answer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we will strategically place the code that calls our new methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will do each of these tasks one at a time and explain the code along the
    way, as leaving the explanation to the end will make referring to individual steps
    cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use many of the features of Java that we learned in this chapter and
    the previous chapter. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The switch control structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get started with our first method.
  prefs: []
  type: TYPE_NORMAL
- en: The setQuestion method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We determined that we needed a method to prepare a question for us; `setQuestion`
    seems like a decent name for such a method. Every time our player gives an answer
    by tapping one of the three multi-choice buttons, a new question will need to
    be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: This method will need to generate values for our `partA` and `partB` variables
    as well as show them in our TextViews referenced by the `textObjectPartA` and
    `textObjectPartB` objects. In addition, the method will need to assign the new
    correct answer to our `correctAnswer` variable, which will then be used to calculate
    some suitable incorrect answers. Finally, the method will show both the correct
    and incorrect answers on our multi-choice buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, our `setQuestion` method will need to take into account the level
    held in `currentLevel` to determine the range or difficulty of the question it
    will ask. Let''s go through the code. If you want to type this code as we go,
    then just make sure you place it after the closing bracket of `onClick` but before
    the closing bracket of our `GameActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have the method signature and the opening curly brace before
    the body of our method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This tells us that the return type is `void`, so `setQuestion` will not return
    a value to the code that calls it. Also, there are no parameters here, so it does
    not need any value passed for it to work. Let''s see what it does. Now we enter
    the code to generate the two parts of the question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous step, we declared a new `int` variable, `numberRange`, and
    initialized it by multiplying the player''s `currentLevel` value by `3`. Then
    we got a new `Random` object called `randInt` and used it to generate new values
    based on `numberRange`. We did this to the `partA` and `partB` variables. As the
    value of `currentLevel` increases, so potentially does the difficulty of the question.
    Now, just as we have written in the past, we write this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We assigned the answer of our new multiplication question to `correctAnswer`.
    Then we declared and assigned two incorrect answers to the new `int` variables,
    `wrongAnswer1` and `wrongAnswer2`. We also used the `setText` method of our TextView
    objects to display the question to the player. Notice that we have not yet displayed
    the correct and incorrect answers. Here it is. Try to work out what is happening
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we used our `Rando`m object, `randInt`, to generate
    a number between 0 and 2, and assigned the value to a new `int` variable called
    `buttonLayou`t. We then used `buttonLayou`t to switch between all its possible
    values: 0, 1, or 2\. Each `case` statement sets the correct and incorrect answers
    to the multi-choice buttons in a slightly different order, so the player can''t
    just keep tapping the same button over and over to achieve a massive score. Notice
    the extra closing bracket after the closing bracket of the switch. This is the
    end of our `setQuestion` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We explained the code fairly thoroughly as we went through it but it might be
    worthwhile to just take a closer look at some parts again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, we saw our method signature with a `void` return type and no parameters.
    In step 2, we generated some random numbers that will be within a certain range.
    This range isn''t as obvious as it might seem at first. First, we assigned, declared,
    and initialized `numberRange` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'So if the player is at the first question, then `currentLevel` will hold the
    value `1` and `numberRange` will be initialized as `3`. Then we made a new `Random`
    object as previously discussed and entered this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'What occurs here is that the `nextInt` method of the `Random` object, `randInt`,
    will return a value of either 0, 1, or 2 because we have given it a seed of 3\.
    We don''t want any zeros in our game because they result in very easy multiplication,
    so we enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This operator, which you probably remember from [Chapter 3](ch03.html "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*, when we discussed
    operators, adds 1 to `partA`. We then do exactly the same to our `partB` variable,
    which means that assuming that the player is still on level 1, they will have
    a question that will be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 1, 1 x 2, 1 x 3, 2 x 1, 2 x 2, 2 x 3, 3 x 1, 3 x 2, or 3 x 3
  prefs: []
  type: TYPE_NORMAL
- en: As the level increases, the potential range of the question increases significantly.
    So at level 2, the options are that either part of the question could be from
    1 to 6; for level 3, from 1 to 9; and so on. It is still possible to get an easy
    question on a higher level but it becomes less likely as the levels advance. Finally
    in this step, we display the question to the player using the `setText` method.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we have seen before but this time we varied it slightly. We calculate
    and assign a value for `correctAnswer`, and declare and assign values to `wrongAnswer1`
    and `wrongAnswer2`, which will hold the wrong answer choices for our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 varies very slightly from what we did in `onCreate` in the previous chapter
    because we subtract and add 2 to `wrongAnswer1` and `wrongAnswer2`, respectively.
    This makes guessing the answer to multiplication questions a little harder because
    you can't eliminate answers based on whether they are odd or even.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 simply randomizes which buttons the correct and incorrect answers will
    be placed on. We don't need to keep track of this because when the time comes
    to compare the value on the button pressed with the correct answer, we can simply
    use our Java code to discover it as we did in [Chapter 3](ch03.html "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*.
  prefs: []
  type: TYPE_NORMAL
- en: The updateScoreAndLevel method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of this method speaks for itself. Because the keeping of the score
    is not simple and because we want higher levels to yield higher scores, we will
    compartmentalize the code to keep our program readable. If we then want to make
    modifications to the scoring system, they can all take place in there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code can go anywhere within the opening and closing braces of `GameActivity
    {}`, but it is good practice to place them in the approximate order they will
    be used. So why not start adding your code after the closing brace of `setQuestion`
    but obviously before the closing brace of `GameActivity`? Here is the method signature
    with the opening brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This tells us that our method does not return a value but that it does receive
    an `int`, which it will require to do its stuff. The name of the parameter is
    a big clue to what we will be passing. We will see that in action in the body
    in a minute, but if passing the player''s answer to this method instead of the
    `isCorrect` method is a bit confusing, we will see things become clearer in the
    next chunk of code. Here is the next part of the code to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is a lot happening here, so we will dissect it more once we have the
    method completed. Basically, it calls the `isCorrect` method (which we will write
    soon) and if the response is `true`, adds to the player''s score in a `for` loop.
    After that, the method adds 1 to `currentLevel`. Here comes the `else` part of
    the code in case the response from `isCorrect` is `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the response is `false`, that is, if the player got the answer wrong, the
    `currentScore` variable is set to `0` and the level back to `1`. Finally for this
    method, we type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous step, we updated the actual TextViews that the player sees with
    the newly determined score and level. The method then ended and the control of
    the program returned to the code that called `updateScoreAndLevel` to begin with.
    Save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We explained most of the code as we went but it might be good to quickly review
    it and dig a bit deeper into certain parts, especially the call to `isCorrect`
    in that odd-looking `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, we began with the method signature. Then in step 2, we began with
    the aforementioned curious `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: We have seen this type of statement before in the *A working method* example
    in the *Methods* section of this chapter. What is happening here is that the call
    to `isCorrect` is replacing the statement to be evaluated, or rather it *is* the
    statement to be evaluated. So `isCorrect` is called with the `answerGiven` variable.
    The `answerGiven` variable, as you might remember, was passed to `updateScoreAndLevel`.
    This time, it is passed to the `isCorrect` method, which will do some work with
    it and perhaps a few other things. Then it will return to the `if` statement a
    value of `true` or `false`. The value will be true if the question is answered
    correctly and false if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the `if` statement evaluates to true, the program runs this bit of
    code (also from step 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The code enters a `for` loop where the starting variable `i` is initialized
    to 1 like this: `int i = 1;`. Furthermore, the loop is instructed to continue
    as long as `i` is less than or equal to our `currentLevel` variable. Then within
    the `for` loop, we add `i` to the current score. As an example, let''s assume
    that the player has just got a question correct and we enter the `for` loop with
    `currentLevel` at 1\. The player''s score is still at 0 because this is their
    first correct answer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At pass 1, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i = 1`, so it is equal to `currentLevel`, which is also 1\. So we enter the
    `for` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 1`, so `currentScore` equals 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `i`, which is `1`, to `currentScore`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `currentScore` variable is now equal to `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At pass 2, the following steps take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` is incremented to 2, so it is now greater than `currentLevel`, which is
    1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop condition evaluates to `false` and we continue with the code
    after the `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentLevel` is increased by 1 to 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at that `for` loop again assuming that the player gets the next
    question correct as well, and we are back in `updateScoreAndLevel`. This time,
    `isCorrect` has evaluated true and we enter the `for` loop but with a slightly
    different situation than the last time.
  prefs: []
  type: TYPE_NORMAL
- en: 'At pass 1, the following steps take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i = 1`, so `i` is less than `currentLevel` is 2 and we enter the `for` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 1`, `currentScore` `= 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `i`, which is equal to 1, to `currentScore`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `currentScore` variable is now equal to 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At pass 2, we have the following steps happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` is incremented to 2 and it is now equal to `currentLevel`, which is also
    2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 2`, `currentScore = 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `i`, which is now equal to 2, to `currentScore`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `currentScore` variable is now equal to 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At pass 3, the following steps take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` is incremented to 3 and it is now greater than `currentLevel`, which is
    2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop condition evaluates to false and we continue with the code after
    the `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `currentLevel` is increased by 1 to 3\. So the next time, we will
    have an extra pass through our `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is happening is that with each level, the player is being rewarded with
    another pass through the `for` loop, and each pass through the `for` loop adds
    a greater value to their score. To summarize what happens in the `for` loop, here
    is a brief table of values showing how the player''s score is increased based
    on the `currentLevel` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| currentLevel | Added to currentScore | currentScore after for loop |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 (1 + 2) | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 6 (1 + 2 + 3) | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 10 (1 + 2 + 3 + 4) | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 15 (1 + 2 + 3 + 4 + 5) | 35 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we could have kept it really simple and not used a `for` loop. We
    could just use `currentScore = currentScore + level` perhaps, but that doesn't
    offer an ever increasing reward in the same way as our current solution does and
    we wouldn't have been able to practice our `for` loops either.
  prefs: []
  type: TYPE_NORMAL
- en: If `if(isCorrect(answerGiven))` evaluates to `false`, it simply resets the score
    to 0 and the level to 1 in step 3\. Step 4 then updates our TextViews for the
    score and the level using the variables we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have just one more method to write. Of course, this is the `isCorrect`
    method, which we just called.
  prefs: []
  type: TYPE_NORMAL
- en: The isCorrect method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is nice and simple because we have seen all of the relevant code
    before. It is just the method signature and the return value that we need to look
    at carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code just after the closing brace of the `updateScoreAndLevel` method
    but before the closing brace of the `GameActivity` class. Type the method signature
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here we can see that the method must return a Boolean value, `true` or `false`.
    If it doesn''t, then the program won''t compile. This guarantees that when we
    use this method as the evaluation expression in the `updateScoreAndLevel` method,
    we will definitely get a result. It can be true or false. The signature also shows
    us the `answerGiven` variable passed in, ready for us to use. Type this code,
    which will determine that result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have seen almost all of the preceding code before. The exception is that
    we declare a Boolean variable, `correctTrueOrFalse`, which we assign to `true`
    if the player answers correctly and to `false` if not. We know whether the player
    is correct or not because we compare `answerGiven` to `correctAnswer` in the `if`
    statement. Notice that we have also triggered the appropriate Android pop-up toast
    message as we did before. Finally, we do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We just returned whatever value is contained within `correctTrueOrFalse`. So
    the critical `if` statement in `updateScoreAndLevel`, which we discussed in detail,
    will know what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure we understand what is happening in `isCorrect`, let's go through
    the sequence of events in our code. In step 1 we have the method signature. We
    see that we will return a `true` or `false` value and receive `int`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we declare a Boolean variable called `correctTrueOrFalse` to hold
    the value we will soon return. Then we test for a right or wrong answer with `if(answerGiven
    == correctAnswer)`. If the two compared values match, a congratulatory message
    pops up and we assign `true` to our Boolean variable. Of course, if the `if` statement
    is `false`, we offer commiserations to the player and assign `false` to our important
    Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Finally in step 3, we send back `true` or `false` so that the `updateScoreAndLevel`
    method can proceed with its work.
  prefs: []
  type: TYPE_NORMAL
- en: We have now implemented all our methods. It's time to put them to work.
  prefs: []
  type: TYPE_NORMAL
- en: Calling our new methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, our shiny new methods won''t do anything until we call them. So
    here is the plan to call these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we want to set a new question for the player. Therefore,
    as the last line of code in our `onCreate` method, we can call our `setQuestion`
    method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we turn our attention to the `onClick` method, which already detects which
    button has been pressed and loads the player''s answer into our `answerGiven`
    variable. So at the end of the `onClick` method, after the closing brace of the
    `switch` statement, we just call this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This sends our player''s attempted answer to `updateScoreAndLevel`, which evaluates
    the answer using `isCorrect`, adds points, and increments the score if the answer
    is correct or resets the score and level if not. All that we need now is another
    question. Add this line. It will ask another question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So now what happens is that the player starts our math game by clicking on
    its icon on their Android device. Our `GameActivity` class declares a few variables
    that we need access to throughout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Then `onCreate` initializes some variables and gets our buttons ready to receive
    clicks from the player before asking the first question by calling `setQuestion`.
    The game then waits for the player to attempt an answer. When the player attempts
    an answer, it is dealt with by `onClick`, `updateScoreAndLevel`, and `isCorrect`.
    Then the program control comes back to `onClick` again, `setQuestion` is called
    again, and we wait for the player's answer once more.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our math game is coming along nicely. Unfortunately, we have to move on soon.
    The project has served its purpose to demonstrate some fundamentals of Java programming
    as well as some key Android features. Now we need to start introducing some more
    game-related topics.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on, there are two really easy things to make our game a bit more
    cool and complete. In case you are wondering about the High Scores button, we
    will see how that can be implemented when we look at our next game project in
    [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"), *Gaming and Java
    Essentials*. You will then have enough information to easily come back and implement
    high scores on your own.
  prefs: []
  type: TYPE_NORMAL
- en: The other feature that would really round off our game and make it more playable
    is an overall or per question time limit. Perhaps even increasing the score based
    on how quickly the correct answer is given will help. We need some new Java tricks
    up our sleeves before we can do that, but we will see how we can measure and respond
    to time in [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"), *Gaming
    and Java Essentials*, when we talk about threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will quickly learn two improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: Locking the screen orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the home screen image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going full screen and locking orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that if you rotate your device while the app is running,
    not only does your game UI get distorted but the game progress is also lost. What
    goes wrong is that when the device is rotated, the `onPause` and `onStop` methods
    are called. Then the app is restarted. We could handle this by overriding the
    `onPause` method and saving our data. We will do this later. For now we don't
    want the screen to rotate anyway, so if we stop it we solve two problems in one.
  prefs: []
  type: TYPE_NORMAL
- en: 'While adding code to this file, Android Studio may try to "help" by adding
    extra formatting. If you get red error indicators, you can compare your `AndroidManifest.xml`
    file with the one in the code download in the `Chapter4/MathGameChapter4` folder.
    Alternatively, you can simply replace the contents of your file with the contents
    of the file in the download. The step-by-step changes are detailed in this guide
    just to highlight what is changing:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the first step in locking the app to portrait. Open the `AndroidManifest.xml`
    file. It is located directly below the `res` folder in the Project Explorer. Find
    the first opening `<activity` in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a new line as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat step 2 after the second instance of `<activity`. We have now locked both
    the menu and game screens in portrait mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the game full screen, in the same file, find the following text and
    add the line in bold after it but before the closing `>` sign:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the same change to the `GameActivity` activity like this. Again, here
    is the code in context in order to avoid mistakes with these `>` signs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you rotate the device during gameplay, the portrait orientation will
    be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom image (instead of the Android icon)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We probably don''t want to have the Android image on our finished game home
    screen, so here is the procedure to change it. This quick guide relies on you
    having an image you would like to use:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add the required image to the layout folder. Copy your image
    file by clicking on it in **Windows Explorer** and using *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now find the `drawable-mdpi` folder in the Android Studio Project Explorer.
    Click on the folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the image to the folder using *Ctrl* + *V*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the image is a part of our project. We simply need to choose it in the same
    way as we chose the image of the Android robot previously. Open `activity_main.xml`
    in the editor window and click on **ImageView** (currently an Android robot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** window, find the **src** property. Click on it and then
    on **...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for your image and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have the image of your choice on the home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Q1) Guess what is wrong with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Q2) What will `x` be equal to at the end of this code snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We came a really long way in this chapter. You got a serious handle on Java
    loops and took your first, fairly deep look into Java methods and how to use them.
    You learned how to generate random numbers and significantly enhanced your math
    game using all of the knowledge you gained.
  prefs: []
  type: TYPE_NORMAL
- en: As the chapters proceed, the games will get more and more real-game-like. In
    the next chapter, we will make a game to test the player's memory. It will have
    sound, animation and will actually save the player's high scores too.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on your progress so far but let's keep going.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Gaming and Java Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover a diverse and interesting range of topics. We
    will learn about Java arrays, which allow us to manipulate a potentially huge
    amount of data in an organized and efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will look at the role threads can play in games, in order to do more
    than one thing apparently simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: If you thought that our math game was a bit on the quiet side, then we will
    look at adding sound effects to our games as well as introducing a cool open source
    app to generate authentic sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: The last new thing we will learn will be persistence. This is what happens when
    the player quits our game or even turns off their Android device. What happens
    to the score then? How will we load the right level the next time they play?
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done all this, we will use all the new techniques and knowledge
    along with what we already know to create a neat memory game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Java arrays—an array of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing with threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using beeps 'n' buzzes—Android sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A look at life after destruction—persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the memory game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java arrays – an array of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be wondering what happens when we have a game with lots of variables
    to keep track of. How about a table of high scores with the top 100 scores? We
    could declare and initialize 100 separate variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Straightaway, this can seem unwieldy, and what about the case when someone
    gets a new top score and we have to shift the scores in every variable down one
    place? A nightmare begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: There must be a better way to update the scores. When we have a large set of
    variables, what we need is a Java **array**. An array is a reference variable
    that holds up to a fixed maximum number of elements. Each element is a variable
    with a consistent type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code declares an array that can hold `int` type variables,
    even a high score table perhaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare arrays of other types, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these arrays would need to have a fixed maximum amount of storage space
    allocated before it is used, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code allocates up to a maximum of 100 integer-sized storage
    spaces. Think of a long aisle of 100 consecutive storage spaces in our variable
    warehouse. The spaces would probably be labeled `intArray[0]`, `intArray[1]`,
    `intArray[2]`, and so on, with each space holding a single `int` value. Perhaps
    the slightly surprising thing here is that the storage spaces start off at 0,
    not 1\. Therefore, in an array of size 100, the storage spaces would run from
    0 to 99.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually initialize some of these storage spaces like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can only put the declared type into an array and the type that
    an array holds can never change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'So when we have an array of `int` types, what are each of the `int` variables
    called? The array notation syntax replaces the name. We can do anything with a
    variable in an array that we could do with a regular variable with a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of array variables being used like normal variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also assign a value from an array to a regular variable of the same
    type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that `myNamedInt` is a separate and distinct primitive variable,
    so any changes made to it do not affect the value stored in the `intArray` reference.
    It has its own space in the warehouse and is not connected to the array.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said that arrays are reference variables. Think of an array variable as an
    address to a group of variables of a given type. Perhaps, using the warehouse
    analogy, `someArray` is an aisle number. So each of `someArray[0]`, `someArray[1]`,
    and so on is the aisle number followed by the position number in the aisle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are also objects. This means that they have methods and properties that
    we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: In the previous line of code, we assigned the length of `someArray` to the `int`
    variable called `lengthOfSomeArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even declare an array of arrays. This is an array that, in each of its
    elements, stores another array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding array, we could hold a list of cities within each country.
    Let''s not go array-crazy just yet. Just remember that an array holds up to a
    predetermined number of variables of any predetermined type and their values are
    accessed using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Let's actually use some arrays to try and get an understanding of how to use
    them in real code and what we might use them for.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s write a really simple working example of an array by performing the
    following steps. You can get the complete code for this example in the downloadable
    code bundle. It''s at `Chapter5/SimpleArrayExample/MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we declare our array, allocate five spaces, and initialize some values
    to each of the elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We output each of the values to the **logcat** console. Notice that when we
    add the array elements together, we are doing so over multiple lines. This is
    fine because we have omitted a semicolon until the last operation, so the Java
    compiler treats the lines as one statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example on an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember that nothing will happen on the emulator display because the entire
    output will be sent to our **logcat** console window in Android Studio. Here is
    the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: In step 2, we declared an array called `ourArray` to hold `int` variables, and
    allocated space for up to five variables of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we assigned a value to each of the five spaces in our array. Remember
    that the first space is `ourArray[0]` and the last space is `ourArray[4]`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we simply printed the value in each array location to the console.
    From the output, we can see that they hold the value we initialized in the previous
    step. Then we added each of the elements in `ourArray` and initialized their value
    to the `answer` variable. We then printed `answer` to the console and saw that
    all the values where added together, just as if they were plain old `int` types
    stored in a slightly different manner, which is exactly what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Getting dynamic with arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed at the beginning of all this array stuff, if we need to declare
    and initialize each element of an array individually, there isn't a huge amount
    of benefit in an array over regular variables. Let's look at an example of declaring
    and initializing arrays dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic array example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s make a really simple dynamic array by performing the following steps.
    You can find the working project for this example in the download bundle. It is
    at `Chapter5/DynamicArrayExample/MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"),*Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following between the opening and closing curly braces of `onCreate`.
    See if you can work out what the output will be before we discuss it and analyze
    the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the example on an emulator. Remember that nothing will happen on the emulator
    display because the entire output will be sent to our **logcat** console window
    in Android Studio. Here is the output of the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I have removed 994 iterations of the loop for brevity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the action happened in step 2\. We declared and allocated an array called
    `ourArray` to hold up to 1,000 `int` values. This time, however, we did the two
    steps in one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we used a `for` loop that was set to loop 1,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialized the spaces in the array from 0 to 999 with the value of `i`
    multiplied by `5`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the value of `i` and the value held in each position of the
    array, we output the value of `i` followed by the value held in the corresponding
    position in the array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: All of this happened 1,000 times, producing the output we saw.
  prefs: []
  type: TYPE_NORMAL
- en: Entering the nth dimension with arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We very briefly mentioned that an array can even hold other arrays at each of
    its positions. Now, if an array holds lots of arrays that hold lots of some other
    type, how do we access the values in the contained arrays? And why would we ever
    need this anyway? Take a look at the next example of where multidimensional arrays
    can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a multidimensional array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a really simple multidimensional array by performing the following
    steps. You can find the working project for this example in the download bundle.
    It is at `Chapter5/MultidimensionalArrayExample/MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary methods, but this isn't essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the call to `setContentView`, declare and initialize a two-dimensional
    array, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we output the contents of the array using a `for` loop and a `Random` class
    object. Note how we ensure that although the question is random, we can always
    pick the correct answer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the example on an emulator. Once again, nothing will happen on the emulator
    display because the output will be sent to our **logcat** console window in Android
    Studio. Here is the output of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: What just happened? Let's go through this chunk by chunk so that we know exactly
    what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a new object of the `Random` type, called `randInt`, ready to generate
    random numbers later in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a simple `int` variable to hold a question number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we declare `countriesAndCities`, our array of arrays. The outer array
    holds arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we allocate space within our arrays. The first outer array will be able
    to hold five arrays and each of the inner arrays will be able to hold two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize our arrays to hold countries and their corresponding capital
    cities. Notice that with each pair of initializations, the outer array number
    stays the same, indicating that each country/capital pair is within one inner
    array (a string array). Of course, each of these inner arrays is held in one element
    of the outer array (which holds arrays):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the upcoming `for` loop clearer, we declare and initialize `int` variables
    to represent the country and the capital from our arrays. If you glance back at
    the array initialization, all the countries are held in position `0` of the inner
    array and all the corresponding capital cities are held at position `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create a `for` loop that will run three times. Note that this number
    does not mean we access the first three elements of our array. It is rather the
    number of times we go through the loop. We could make it loop one time or a thousand
    times, but the example would still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we actually determine which question to ask, or more specifically, which
    element of our outer array. Remember that `randInt.nextInt(5)` returns a number
    between 0 and 4\. This is just what we need as we have an outer array with five
    elements, from 0 to 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can ask a question by outputting the strings held in the inner array,
    which in turn is held by the outer array that was chosen in the previous line
    by the randomly generated number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: For the record, we will not be using any multidimensional arrays in the rest
    of this book. So if there is still a little bit of murkiness around these arrays
    inside arrays, then that doesn't matter. You know they exist and what they can
    do, so you can revisit them if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Array-out-of-bounds exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An array-out-of-bounds exception occurs when we attempt to access an element
    of an array that does not exist. Whenever we try this, we get an error. Sometimes,
    the compiler will catch it to prevent the error from going into a working game,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Guess what happens if we write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: The only way we can avoid this problem is to know the rule. The rule is that
    arrays start at zero and go up to the number obtained by subtracting one from
    the allocated number. We can also use clear, readable code where it is easy to
    evaluate what we have done and spot the problems.
  prefs: []
  type: TYPE_NORMAL
- en: Timing with threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what is a thread? You can think of threads in Java programming just like
    threads in a story. In one thread of a story, we have the primary character battling
    the enemy on the front line, and in another thread, the soldier's family are getting
    by, day to day. Of course, a story doesn't have to have just two threads. We could
    introduce a third thread. Perhaps the story also tells of the politicians and
    military commanders making decisions. These decisions subtly, or not so subtly,
    affect what happens in the other threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Threads in programming are just like this. We create parts/threads in our program
    and they control different aspects for us. We introduce threads to represent these
    different aspects because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They make sense from an organizational point of view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are a proven way of structuring a program that works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the system we are working on forces us to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Android, we use threads for all of these reasons simultaneously. It makes
    sense, it works, and we have to use it because of the design of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In gaming, think about a thread that receives the player's button taps for "left",
    "right", and "shoot", a thread that represents the alien thinking where to move
    next, and yet another thread that draws all the graphics on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Programs with multiple threads can have problems. Like the threads of a story,
    if proper synchronization does not occur, then things go wrong. What if our soldier
    went into battle before the battle or even the war existed? Weird!
  prefs: []
  type: TYPE_NORMAL
- en: What if we have a variable, `int x`, that represents a key piece of data that
    say three threads of our program use? What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two? This problem is
    the problem of **correctness**, caused by multiple threads racing to completion,
    oblivious of each other—because they are just dumb code after all.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of correctness can be solved by close oversight of the threads and
    **locking**. Locking means temporarily preventing execution in one thread to ensure
    that things are working in a synchronized manner. It's like freezing the soldier
    from boarding a ship to war until the ship has actually docked and the plank has
    been lowered, avoiding an embarrassing splash.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem with programs with multiple threads is the problem of **deadlock**,
    where one or more threads become locked, waiting for the right moment to access
    `x`, but that moment never comes and the entire program eventually grinds to a
    halt.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock). Now consider all that we have
    just been discussing and mix it in with the Android Activity lifecycle. It's possible
    that you start to feel a little nauseous with the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the problem has been solved for us. Just as we use the `Activity`
    class and override its methods to interact with the Android lifecycle, we can
    also use other classes to create and manage our threads. Just as with `Activity`,
    we only need to know how to use them, not how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why tell me all this stuff about threads when I didn''t need to know, you
    would rightly ask. It''s simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. We will have no sweat writing our Java
    code to create and work within our threads if we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept that the new concepts we will introduce are what we need to work with
    in order to create an Android-specific solution to the problems related to working
    with threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the general concept of a thread, which is mostly the same as a story
    thread that happens almost simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the few rules of using some of the Android thread classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that I said classes, plural, in the third bullet. Different thread classes
    work best in different situations. You could write a whole book on just threads
    in Android. We will use two thread classes in this book. In this chapter, we will
    use `Handler`. In [Chapter 7](ch07.html "Chapter 7. Retro Squash Game"), *Retro
    Squash Game*, and [Chapter 8](ch08.html "Chapter 8. The Snake Game"), *The Snake
    Game*, we will use the `Runnable` class. All we need to remember is that we will
    be writing parts of our program that run at almost the same time as each other.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What do I mean by "almost"? What is actually happening is that the CPU switches
    between threads in turn. However, this happens so fast that we will not be able
    to perceive anything but simultaneity.
  prefs: []
  type: TYPE_NORMAL
- en: A simple thread timer example with the Handler class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After this example, we can heave a sigh of relief when we realize that threads
    are not as complicated as first feared. When using threads in a real game, we
    will have to add a bit of extra code alongside the code in this simple example,
    but it's not much, and we will talk about it when we get to it.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can simply use the complete code from the download bundle. This
    project is located in `Chapter5`/`SimpleThreadTimer/MainActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, we will be creating a timer—quite a useful feature in
    a lot of games:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Immediately after the class declaration, enter the three highlighted lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter this code inside the `onCreate` method. It will create a thread with
    something else going on in the `if(gameOn)` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app. Quit with the home or back button on the emulator. Notice that
    it is still printing to the console. We will deal with this anomaly when we implement
    our memory game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the example on an emulator, remember that nothing will happen
    on the emulator display because all of the output will be sent to our **logcat**
    console window in Android Studio. Here is the output of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: So what just happened? After 1-second intervals, the number of seconds elapsed
    was printed to the console. Let's learn how this happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare a new object, called `myHandler`, of the `Handler` type.
    We then declare a Boolean variable called `gameOn`. We will use this to keep track
    of when our game is running. Finally, the last line of this block of code declares
    a variable of the `long` type. You might remember the `long` type from [Chapter
    3](ch03.html "Chapter 3. Speaking Java – Your First Game"), *Speaking Java – Your
    First Game*. We can use `long` variables to store very large whole numbers, and
    this is what we do here with `startTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Next, we initialized `startTime` using `currentTimeMillis`, a method of the
    `System` class. This method holds the number of milliseconds since January 1,
    1970\. We will see how we use this value in the next line of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Next is the important code. Everything up to `if(gameOn)` marks the code to
    define our thread. Certainly, the code is a bit of a mouthful, but it is not as
    bad as it looks at first glance. Also, remember that we only need to use the threads;
    we don't need to understand every aspect of how they do their work.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dissect the preceding code to demystify it a bit. The `myHandler = new
    Handler()` line simply initializes our `myHandler` object. What is different from
    what we have seen before is that we go on to customize the object immediately
    afterwards. We override the `handleMessage` method (which is where we put our
    code that runs in the thread) and then we call `super.handleMessage`, which calls
    the default version of `handleMessage` before it runs our custom code. This is
    much like we do for the `onCreate` method every time we call `super.onCreate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the `if(gameOn)` block. Everything in that `if` block is the code
    that we want to run in the thread. The `if(gameOn)` block simply gives us a way
    to control whether we want to run our code at all. For example, we might want
    the thread up and running but only sometimes run our code. The `if` statement
    gives us the power to easily choose. Take a look at the code now. We will analyze
    what is happening in the `if` block later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `if` block, we declare and initialize another `long` variable called
    `seconds`, and do a little bit of math with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we get the current number of milliseconds since January 1, 1970, and
    then subtract `startTime` from it. This gives us the number of milliseconds since
    we first initialized `startTime`. Then we divide the answer by 1000 and get a
    value in seconds. We print this value to the console with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, just after our `if` block, we have this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: The previous line tells the Android system that we want to run the code in the
    `handleMessage` method once every 1000 milliseconds (once a second).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `onCreate`, after the closing curly braces of the `handleMessage` method
    and the `Handler` class, we finally set `gameOn` to `true` so that it is possible
    to run the code in the `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, this last line of the code starts the flow of messages between our thread
    and the Android system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that the code inside the `if` block can be as minimal
    or as extensive as we need. When we implement our memory game, we will see much
    more code in our `if` block.
  prefs: []
  type: TYPE_NORMAL
- en: All we really need to know is that the somewhat elaborate setup we have just
    seen allows us to run the contents of the `if` block in a new thread. That's it!
    Perhaps apart from brushing over that `System` class a bit quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System` class has many uses. In this case, we use it to get the number
    of milliseconds since January 1, 1970\. This is a common system used to measure
    time in a computer. It is known as Unix time, and the first millisecond of January
    1, 1970, is known as the Unix Epoch. We will bump into this concept a few more
    times throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Enough on threads, let's make some noise!
  prefs: []
  type: TYPE_NORMAL
- en: Beeps n buzzes – Android sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will be divided into two parts—creating and using sound FX. So
    let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sound FX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Years ago, whenever I made a game, I would spend many hours trawling websites
    offering royalty-free sound FX. Although there are many good ones out there, the
    really great ones are always costly, and no matter how much you pay, they are
    never exactly what you want. Then a friend pointed out a simple open source app
    called Bfxr, and I have never wasted another moment looking for sound effects
    since. We can make our own.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a very fast guide to making your own sound effects using Bfxr. Grab
    a free copy of Bfxr from [www.bfxr.net](http://www.bfxr.net).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the simple instructions on the website to set it up. Try out a few of
    these examples to make cool sound effects:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a seriously condensed tutorial. You can do much more with Bfxr. To learn
    more, read the tips on the website at the previous URL.
  prefs: []
  type: TYPE_NORMAL
- en: Run `bfxr.exe`:![Creating sound FX](img/8859OS_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out all the preset types, which generate a random sound of that type. When
    you have a sound that is close to what you want, move to the next step:![Creating
    sound FX](img/8859OS_05_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Creating sound FX](img/8859OS_05_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see, we can save in formats other than `.wav`.![Creating
    sound FX](img/8859OS_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file, use the `.ogg` extension on the end of whatever you decide to call it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 to 5 as often as required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every project in this book that requires sound samples comes with the sound
    samples provided, but as we have seen, it is much more fun to make our own samples.
    All you need to do is to save them with the same filename as the provided samples.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds in Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To complete this brief example, you will need three sound effects saved in
    the `.ogg` format. So if you don''t have them to hand, go back to the *Creating
    sound FX* section to make some. Alternatively, you can use the sounds provided
    in the `Chapter5/ PlayingSounds/assets` folder of the code bundle. As usual, you
    can view or use the already completed code at `Chapter5/PlayingSounds/java/MainActivity.java`
    and `Chapter5/PlayingSounds/layout/activity_main.xml`. Now perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, although this isn't essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three sound files and save them as `sample1.ogg`, `sample2.ogg`, and
    `sample3.ogg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` folder in the Project Explorer window, we need to add a folder
    called `assets`. So in the Project Explorer window, right-click on the **main**
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy and paste the three sound files to the newly created `assets` folder.
    Alternatively, select the three files, right-click on them, and click on **Copy**.
    Then click on the **assets** folder in the Android Studio Project Explorer. Now
    right-click on the **assets** folder and click on **Paste**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the editor window and drag three button widgets
    onto your UI. It doesn't matter where they are or how they are aligned. When you
    look at the **id** property in the **Properties** window for any of our three
    new buttons, you will notice that they have automatically been assigned **id**
    properties. They are `button`, `button2`, and `button3`. As we will see, this
    is just what we need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s enable our activity to listen to the buttons being clicked by implementing
    `onClickListener` as we have done in all our other examples with buttons. Open
    **MainActivity.java** in the editor window. Replace the `public class MainActivity
    extends Activity {` line with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As before, we get an unsightly red underline on our new line of code. The last
    time this happened, we typed in the empty body of the `onClick` method that we
    must implement and all was well. This time, because we already know what is going
    on here, we will learn a shortcut. Hover your mouse cursor over the error and
    right-click on it. Now click on **Generate...** and then select **Implement methods...**.
    In the **Select** **Methods To Implement** dialog box, **onClick(View):void**
    will already be selected:![Playing sounds in Android](img/8859OS_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select this option by clicking on **OK**. Now scroll to the bottom of your code
    and see that Android Studio has very kindly implemented the `onClick` method for
    you and the error is also gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type this code after the `MainActivity` declaration to declare some variables
    for our sound effects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type this code in the `onCreate` method to load our sounds into memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the code to grab a reference to the buttons in our UI and listen to
    clicks on them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, type this code in the `onClick` method that we autogenerated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example on an emulator or on a real Android device. Notice that by clicking
    on a button, you can play any of your three sound samples at will. Of course,
    sounds can be played at almost any time, not just on button presses. Perhaps they
    can be played from a thread as well. We will see more sound samples when we implement
    the memory game later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the code works. We started off by setting up a new project in the
    usual way. In steps 2 to 5, however, we created some sounds with Bfxr, created
    an `assets` folder, and placed the files within it. This is the folder where Android
    expects to find sound files. So when we write the code in the next steps that
    refers to the sound files, the Android system will be able to find them.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 6 to 8, we enabled our activity to listen to button clicks as we have
    done several times before. Only this time, we got Android Studio to autogenerate
    the `onClick` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we saw this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an object of the `SoundPool` type, called `soundPool`. This
    object will be the key to making noises with our Android device. Next, we have
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very simple; we declared three `int` variables. However,
    they serve a slightly deeper purpose than a regular `int` variable. As we will
    see in the next block of code we analyze, they will be used to hold a reference
    to a sound file that is loaded into memory. In other words, the Android system
    will assign a number to each variable that will refer to a place in memory where
    our sound file will reside.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of this as a location in our variable warehouse. So we know the
    name of the `int` variable, and contained within it is what Android needs to find
    our sound. Here is how we load our sounds into memory and use the references we've
    just been discussing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break the code in step 10 into a few parts. Take a close look and then
    we will examine what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initialize our `soundPool` object and request up to 10 simultaneous
    streams of sound. We should be able to really mash the app buttons and get a sound
    every time. `AudioManager.STREAM_MUSIC` describes the type of stream. This is
    typical for applications of this type. Finally, the `0` argument indicates we
    would like default quality sound.
  prefs: []
  type: TYPE_NORMAL
- en: Now we see something new. Notice that the next chunk of code is wrapped into
    two blocks, `try` and `catch`. This means that if the code in the `try` block
    fails, we want the code in the `catch` block to run. As you can see, there is
    nothing but a comment in the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: We must do this because of the way the `SoundPool` class is designed. If you
    try to write the code without the `try` and `catch` blocks, it won't work. This
    is typical of Java classes involved in reading from files. It is a fail-safe process
    to check whether the file is readable or even whether it exists. You could put
    a line of code to output to the console that an error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to experiment with `try/catch`, then put a line of code to output
    a message in the `catch` block and remove one of the sound files from the assets
    folder. When you run the app, the loading will fail and the code in the `catch`
    block will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will throw caution to the wind because we are quite sure that the files
    will be there and will work . Let''s examine what is inside the `try` block. Take
    a close look at the following code and then we will dissect it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an object called `assetManager` of the `AssetManager` type
    and an `AssetFileDescriptor` object called `descriptor`. We then use these two
    objects combined to load our first sound sample like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: We now have a sound sample loaded in memory and its location saved in our `int`
    variable called `sample1`. The first sound file, `sample1.ogg`, is now ready to
    use. We perform the same procedure for `sample2` and `sample3` and we are ready
    to make some noise!
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 11, we set up our buttons, which we have seen several times before.
    In step 12, we have our switch block ready to perform a different action depending
    upon which button is pressed. You can probably see that the single action each
    button takes is the playing of a sound. For example, **Button1** does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: This line of code plays the sound that is loaded in memory at the location referred
    to by `int sample1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The arguments of the method from left to right define the following: the sample
    to play, left volume, right volume, priority over other playing sounds, loop or
    not, rate of playback. You can have some fun with these if you like. Try setting
    the loop argument to `3` and the rate argument to perhaps `1.5`.'
  prefs: []
  type: TYPE_NORMAL
- en: We handle each button in the same way. Now let's learn something serious.
  prefs: []
  type: TYPE_NORMAL
- en: Life after destruction – persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, this is not as heavy as it sounds, but it is an important topic when making
    games. You have probably noticed that the slightest thing can reset our math game,
    such as an incoming phone call, a battery that ran flat, or even tilting the device
    to a different orientation.
  prefs: []
  type: TYPE_NORMAL
- en: When these events occur, we might like our game to remember the exact state
    it was in so that when the player comes back, it is in exactly the same place
    as they left off. If you were using a word-processing app, you would definitely
    expect this type of behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to go to that extent with our game, but as a bare minimum,
    shouldn't we at least remember the high score? This gives the player something
    to aim for, and most importantly, a reason to come back to our game.
  prefs: []
  type: TYPE_NORMAL
- en: An example of persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android and Java have many different ways to achieve persistence of data, from
    reading and writing to files to setting up and using whole databases through our
    code. However, the neatest, simplest, and most suitable way for the examples in
    this book is by using the `SharedPreferences` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use the `SharedPreferences` class to save data. Actually,
    we will be reading and writing to files, but the class hides all of the complexity
    from us and allows us to focus on the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a somewhat abstract example of persistence so that we are familiar
    with the code before we use something similar to save the high score in our memory
    game. The complete code for this example can be found in the code bundle at `Chapter5/Persistence/java/MainActivity.java`
    and `Chapter5/Persistence/layout/activity_main.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the editor window and click and drag one button
    from the palette to the design. The default ID of the button that is assigned
    is perfect for our uses, so no further work is required on the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainActivity.java` in the editor window. Implement `View.OnClickListener`
    and autogenerate the required `onClick` method, just as we did in steps 6 and
    7 of the *Playing sound in Android* example previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following code just after the `MainActivity` declaration. This declares
    our two objects that will do all the complex stuff behind the scenes: a bunch
    of strings that will be useful and a button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next block of code to the `onCreate` method after the call to `setContentView`.
    We initialize our objects and set up our button. We will look closely at this
    code once the example is done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now the action takes place in our `onClick` method. Add this code, which generates
    a random number and adds it to the end of `currentString`. Then it saves the string
    and sets the value of the string to the button as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example on an emulator or a device. Notice that each time you press
    the button, a random number is appended to the text of the button. Now quit the
    app, or even shut down the device if you like. When you restart the app, our cool
    `SharedPreferences` class simply loads the last saved string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the code works. There is nothing we haven''t seen several times
    before until step 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare two types of `SharedPreferences` objects called `prefs` and
    `editor`. We will see exactly how we use them in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare the `dataName` and `stringName` strings. We do this because
    to use the facilities of `SharedPreferences`, we need to refer to our collection
    of data, as well as any individual pieces of data within it, using a consistent
    name. By initializing `dataName` and `stringName`, we can use them as a name for
    our data store as well as a specific item within that data store, respectively.
    The sad face in `defaultString` gets used any time the `SharedPreferences` object
    needs a default because either nothing has been previously saved or the loading
    process fails for some reason. The `currentString` variable will hold the value
    of the string we will be saving and loading as well as displaying to the user
    of our app. Our buttonis `button1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 5, the real action starts with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: The previous code does stuff that would take a lot more code if we didn't have
    the useful `SharedPreferences` class. The first two lines initialize the objects
    and the third loads the value from our data store item, whose name is contained
    in `stringName`, to our `currentString` variable. The first time this happens,
    it uses the `defaultString` value because nothing is stored there yet, but once
    there is a value stored, this single line of code that will load up our saved
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of step 5, we set up our button as we have done many times before.
    Moving on to step 6 in the `onClick` method, there is no `switch` block because
    there is only one button. So if a click is detected, it must be our button. Here
    are the first three lines from `onClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'We generate a random number and append it to the `currentString` variable.
    Next, still in `onClick`, we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: This is like the opposite of the code that loaded our string in `onCreate`.
    The first of the previous two lines identifies the place in the data store to
    write the value to (`stringName`) and the value to be written there (`currentString`).
    The next line, `editor.commit();`, simply says, "go ahead and do it."
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line displays `currentString` as text on our button so that we
    can see what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more on persistence, take a look at the second question of the *Self-test
    questions* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The memory game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in the memory game shouldn't challenge us too much because we have
    done the background research on threads, arrays, sound, and persistence. There
    will be some new-looking code and we will examine it in detail when it crops up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of our finished game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The memory game](img/8859OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the home screen. It shows the high score, which persists between play
    sessions and when the device is shut down. It also shows a **Play** button, which
    will take the player to the main game screen. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The memory game](img/8859OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The game screen itself will play a sequence of sounds and numbers. The corresponding
    button will *wobble* in time with the corresponding sound. Then the player will
    be able to interact with the buttons and attempt to copy the sequence. For every
    part of the sequence that the player gets right, they will be awarded points.
  prefs: []
  type: TYPE_NORMAL
- en: If the sequence is copied in its entirety, then a new and longer sequence will
    be played and again the player will attempt to repeat the sequence. This continues
    until the player gets a part of a sequence wrong.
  prefs: []
  type: TYPE_NORMAL
- en: As the score increases, it is displayed in the relevant TextView, and when a
    sequence is copied correctly, the level is increased and displayed below the score.
  prefs: []
  type: TYPE_NORMAL
- en: The player can start a new game by pressing the **Replay** button. If a high
    score is achieved, it will be saved to a file and displayed on the home screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the game is divided into five phases. The end of a phase
    would be a good place to take a break. Here are the different phases of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 1**: This implements the UI and some basics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 2**: This prepares our variables and presents the pattern (to be copied)
    to the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 3**: In this phase, we will handle the player''s response when they
    try to copy the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 4**: Here, we will use what we just learned about persistence to maintain
    the player''s high score when they quit the game or turn off their device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 5**: At the end of phase 4, we will have a fully working memory game.
    However, to add to our repertoire of Android skills, after we have discussed Android
    UI animations near the end of this chapter, we will complete this phase, which
    will enhance our memory game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the files containing the complete code and the sound files after all five
    stages can be found in the download bundle in the `Chapter5/MemoryGame` folder.
    In this project, however, there is a lot to be learned from going through each
    of the stages.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 1 – the UI and the basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will lay out a home menu screen UI and a UI for the game itself. We
    will also configure some IDs for some of the UI elements so that we can control
    them in our Java code later:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application called `Memory Game` and clean up the code if you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we create a new activity and call it `GameActivity`. So right-click on the
    `java` folder in Project Explorer, navigate to **New** | **Activity**, then click
    on **Next**, name the activity as `GameActivity`, and click on **Finish**. For
    clarity, clean up this activity in the same way as we cleaned up all our others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the game fullscreen and lock the orientation as we did in the *Going fullscreen
    and locking orientation* tutorial at the end of [Chapter 4](ch04.html "Chapter 4. Discovering
    Loops and Methods"), *Discovering Loops and Methods*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file from the `res/layout` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s quickly create our home screen UI by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the editor and delete the **Hello World** TextView.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click and drag the following: **Large Text** to the top center (to create our
    title text), **Image** just below that, another **LargeText** below that (for
    our high score), and a **Button** (for our player to click to play). Your UI should
    look a bit like what is shown in the following screenshot:![Phase 1 – the UI and
    the basics](img/8859OS_05_04.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the **text** properties of the two TextViews and the Button element to
    make it plain what each will be used for. As usual, you can replace the Android
    icon in the **ImageView** with any image you choose (as we did in [Chapter 4](ch04.html
    "Chapter 4. Discovering Loops and Methods"), *Discovering Loops and Methods*,
    in the *Adding a custom image* tutorial).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tweak the sizes of the elements in the usual way to suit the emulator or device
    you will be running the game on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make the ID for our **Hi Score** TextView more relevant to its purpose.
    Left-click to select the **Hi Score** TextView, find its **id** property in the
    **Properties** window, and change it to `textHiScore`. The IDs of the image and
    the title are not required, and the existing ID of the play button is `button`,
    which seems appropriate already. So there is nothing else to change here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s wire up the **Play** button to create a link between the home and the
    game screens, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainActivity.java` in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `implements View.onClickListener` to the end of the `MainActivity` declaration
    so that it now looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method we must implement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of our `onCreate` method, before the closing curly brace, enter
    the following code to get a reference to our **Play** button and listen to clicks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Scroll down to our `onClick` method and enter the following code in its body
    to have the **Play** button take the player to our `GameActivity`, which we will
    design soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, the app will run and the player can click on the **Play** button
    to take them to our game screen. So let''s quickly create our game screen UI:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `activity_game.xml` in the editor and delete the **Hello World** TextView.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag three **Large Text** elements one below the other and center them horizontally.
    Below them, add four buttons stacked one on top of the other, and finally, add
    another button below that but offset it to the right-hand side so that it looks
    like what is shown in the next screenshot. I have also adjusted the text properties
    for the UI elements to make it clear what each will be used for, but this is optional
    because our Java code will do all of the work for us. You can also tweak the sizes
    of the elements in the usual way to suit the emulator or device you will be running
    the game on.![Phase 1 – the UI and the basics](img/8859OS_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s assign some useful IDs to our UI elements so that we can do some
    Java magic with them in the next tutorial. Here is a table that matches the UI
    elements shown in the last screenshot with the **id** property value that you
    need to assign. Assign the following **id** property values to the corresponding
    UI elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Purpose | Default id property | New id to assign |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Score indicator | textView | textScore |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Difficulty indicator | textView2 | textDifficulty |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Watch/go indicator | textView3 | textWatchGo |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Button 1 | button | Leave at default |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Button 2 | button2 | Leave at default |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Button 3 | button3 | Leave at default |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Button 4 | button4 | Leave at default |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Replay button | button5 | buttonReplay |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Now that we have our game menu and actual game UI ready to go, we can start
    to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 2 – preparing our variables and presenting the pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will set up a whole load of variables and objects for us to use, both
    in this phase and in the later phases. We will also implement the parts of the
    code that present a pattern to the player. We will add code that enables the player
    to respond in a later phase:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GameActivity.java` in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I made the sounds by finding a pleasing one then slowly increasing the **Frequency**
    slider for each subsequent sample. You can use my sound from the `assets` folder
    in the `MemoryGame` project or create your own sound using Bfxr.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` folder in the project explorer window, we need to add a folder
    called `assets`. So in the project explorer window, right-click on the `main`
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now copy and paste the four sound files to the newly created `assets` folder.
    You can do so like this: select the files, right-click on them, and then click
    on **Copy**. Then click on the `assets` folder in the Android Studio project explorer.
    Now right-click on the `assets` folder and click on **Paste**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s prepare `GameActivity` to listen to button clicks just as we did for
    `MainActivity`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `implementsView.onClickListener` to the end of the `GameActivity` declaration
    so that it now looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method that we will use shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s declare some objects that we need to reference our UI and our `int`
    references for the sound effects we will load soon. Write the code just after
    the declaration for `GameActivity`. By putting them here, they will be available
    to all parts of our code in `GameActivity.java`. Here is the code in context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, after the last line of code from the previous step, enter the following
    code snippet, which will declare and initialize some variables for use in our
    thread. Notice that at the end, we also declare `myHandler`, which will be our
    thread, and `gameOn` to control whether our code within the thread is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just after our call to `setContentView` in the `onCreate` method, we make our
    sound effects ready to be played:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just after the code in the last step and still within the `onCreate` method,
    we initialize our objects and set click listeners for the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, after the last line of the code from the previous step, enter the code
    that will create our thread. We will add the details in the next step within the
    `if(playSequence)` block. Notice that the thread is run every nine-tenths of a
    second (900 milliseconds). Notice that we start the thread but do not set `playSequence`
    to `true`. So it will not do anything yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we look at the code that will run in our thread, we need a way to generate
    a random sequence appropriate for the difficulty level. This situation sounds
    like a candidate for a method. Enter this method just before the closing curly
    brace of the `GameActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need a method to prepare and start our thread. Type the following method
    after the closing curly brace of `createSequence`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, the order of implementation of the methods is unimportant. However,
    following along in order will mean our code will look the same. Even if you are
    referring to the downloaded code, the order will be the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just before we look at the details of the thread code, we need a method to
    tidy up our variables after the sequence has been played. Enter this method after
    the closing curly brace of `playASequence`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will implement our thread. There is some new code in this part,
    which we will go through in detail after we finish this phase of the project.
    Enter this code between the opening and closing curly braces of the `if(playSequence){
    }` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just before the closing curly brace of `onCreate`, we could initiate a sequence
    by calling our `playASequence` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: We could then run our app, click on **Play** on the home screen, and watch as
    a sequence of four random buttons and their matching sounds begins, with the sounds
    being played. In the next phase, we will wire up the **Replay** button so that
    the player can start the sequence when they are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Phew! That was a long one. Actually, there is not much new there, but we did
    cram in just about everything we ever learned about Java and Android into one
    place, and we used it in new ways too. So we will look at it step by step and
    give extra focus to the parts that might seem tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each new piece of code in turn.
  prefs: []
  type: TYPE_NORMAL
- en: From steps 1 to 7, we initialized our variables, set up our buttons, and loaded
    our sounds as we have done before. We also put in the outline of the code for
    our thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 8, we implemented the `createSequence` method. We used a `Random` object
    to generate a sequence of random numbers between 1 and 4\. We did this in a `for`
    loop, which loops until a sequence the length of `difficultyLevel` has been created.
    The sequence is stored in an array called `sequenceToCopy`, which we can later
    use to compare to the player''s response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 9, we implemented `playASequence`. First, we call `createSequence`
    to load our `sequenceToCopy` array. Then we set `isResponding` to `false` because
    we don''t want the player to bash buttons while the sequence is still playing.
    We set `elementToPlay` to `0` as this is the first element of our array. We also
    set `playerResponses` to `0`, ready to count the player''s responses. Next, we
    set some text on the UI to `"WATCH!"` to make it clear to the player that the
    sequence is playing. Finally, we set `playSequence` to `true`, which allows the
    code in our thread to run once every 900 milliseconds. Here is the code we have
    just analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 10, we handle `sequenceFinished`. We set `playSequence` to `false`,
    which prevents the code in our thread from running. We set all the buttons back
    to visible because, as we will see in the thread code, we set them to invisible
    to emphasize which button comes next in the sequence. We set our UI text to **GO!**
    to make it clear. It is time for the player to try and copy the sequence. For
    the code in the `checkElement` method to run, we set `isResponding` to `true`.
    We will look at the code in the `checkElement` method in the next phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 11, we implement our thread. It''s quite long but not too complicated.
    First, we set all the buttons to visible as this is quicker than checking which
    one of them is currently invisible and setting just that one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we switch based on what number is next in our sequence, hide the appropriate
    button, and play the appropriate sound. Here is the first case in the `switch`
    block for reference. The other case elements perform the same function but on
    a different button and with a different sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we increment `elementToPlay`, ready to play the next part of the sequence
    when the thread runs again in approximately 900 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check whether we have played the last part of the sequence. If we
    have, we call our `sequenceFinished` method to set things up for the player to
    attempt their answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we tell the thread when we would like to run our code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: When you ran a sequence (see the previous tip), did you notice an imperfection/bug
    with our game operation? This has to do with the way the last element of the sequence
    is animated. It is because our `sequenceFinished` method makes all the buttons
    visible so soon after the button has just been made invisible that looks like
    the button is never made invisible at all. We will solve the problem of the button
    that doesn't stay invisible long enough when we learn about UI animation in phase
    5.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's handle the player's response.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 3 – the player's response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have an app that plays a random sequence of button flashes and matching
    sounds. It also stores that sequence in an array. So what we have to do now is
    enable the player to attempt to replicate the sequence and score points if successful.
  prefs: []
  type: TYPE_NORMAL
- en: We can do all of this in two phases. First, we need to handle the button presses,
    which can pass all the hard work to a method that will do everything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the code and look at it as we go. Afterwards, we will closely
    examine the less obvious parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we handle the button presses. We have the empty body of the `switch`
    statement with an extra `if` statement that checks whether there is a sequence
    currently being played. If there is a sequence, then no input is accepted. We
    will start to fill the code in the empty body in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, here is the code that handles `button1`. Notice that it just plays the
    sound related to `button1` and then calls the `checkElement` method, passing a
    value of 1\. This is all we have to do for the buttons 1 through 4: play a sound
    and then tell our new method (`checkElement`) which numbered button was pressed,
    and `checkElement` will do the rest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the near-identical code for buttons 2 through 4\. Notice that the value
    passed to `checkElement` and the sound sample that is played are the only differences
    from the previous step. Enter this code directly after the code in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the last part of the code in our `onClick` method. This handles the
    **Restart** button. The code just resets the score and the difficulty level and
    then calls our `playASequence` method, which does the rest of the work of starting
    the game again. Enter this code directly after the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, here is our do-everything method. This is quite a long method compared
    to most of our previous methods, but it helps to see its entire structure. We
    will break this down line by line in a minute. Enter the following code, after
    which you will actually be able to play the game and get a score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We covered the methods fairly comprehensively as we went through the tutorial.
    The one elephant in the room, however, is the apparent sprawl of code in the `checkElement`
    method. So let's go through all of the code in step 6, line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the method signature. Notice that it does not return a value
    but it receives an `int` value. Remember that it is the `onClick` method that
    calls this method and it passes a `1`, `2`, `3`, or `4`, depending upon which
    button was clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we wrap the rest of this code into an `if` statement. Here is the `if`
    statement. We enter the block when the `isResponding` Boolean is `true`, and `isResponding`
    is set to `true` when the `sequenceFinnished` method completes, which is just
    what we need so that the player can''t mash the buttons until it is time to do
    so and our game is ready to listen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what happens inside the `if` block. We increment the number of the
    player''s responses received in the `playerResponses` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we check whether the number passed to the `checkElement` method and stored
    in `thisElement` matches the appropriate part of the sequence the player is trying
    to copy. If it matches, we increase `playerScore` by an amount relative to the
    number of correctly matched parts of the sequence so far. Then we set the score
    on the screen. Notice that if the response does not match, there is an `else`
    block to go with this `if` block that we will explain soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have another `if` block. Note that this `if` block is nested inside
    the `if` block we just described. So it will only be tested and potentially run
    if the player''s response was correct. This `if` statement checks whether it is
    the last part of the sequence, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is the last part of the sequence, it executes the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'What is happening inside the nested `if` statement, which checks whether the
    whole sequence has been correctly copied, is the following: It sets `isResponding`
    to `false`, so the player gets no response from the buttons. It then raises the
    difficulty level by 1 so that the sequence is a bit tougher next time. Finally,
    it calls the `playSequence` method to play another sequence and the whole process
    starts again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `else` block, which runs if the player gets part of the sequence
    wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set some text on the screen and set `isResponding` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's use what we learned about the `SharedPreferences` class to preserve
    the high scores.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 4 – preserving the high score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This phase is nice and short. We will use what we learned earlier in the chapter
    to save the player''s score if it is a new high score, and then display the best
    score in the **hi-score** TextView in our `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainActivity.java` in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we declare our objects used to read from a file just after the class declaration,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, just after our call to `setContentView` in the `onCreate` method, we initialize
    our objects, read from our file, and set the result to our `hiScore` variable.
    We then display it to the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to go back to the `GameActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We declare our objects to edit our file, this time like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just after the call to `setContentView` in the `onCreate` method, we instantiate
    our objects and assign a value to `hiScore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only thing that is different to what we have already learned is that we
    need to consider where we put the code to test for a high score and where to write
    to our file if appropriate. Consider this: eventually, every player must fail.
    Furthermore, the point at which they fail is the point when their score is at
    its highest, yet before it is reset when they try again. Place the following code
    in the `else` block, which handles a wrong answer from the player. The highlighted
    code is the new code; the rest is there to help you with the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Play the game and get a high score. Now quit the app or even restart the phone.
    When you come back to the app, your high score is still there.
  prefs: []
  type: TYPE_NORMAL
- en: The code we added in this phase is nearly the same as the code we wrote in our
    previous example of persistence, the only difference being that we wrote to the
    data store when a new high score was achieved instead of when a button was pressed.
    In addition, we used the `editor.putInt` method because we were saving an integer
    instead of `editor.putString` when we were saving a string.
  prefs: []
  type: TYPE_NORMAL
- en: Animating our game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go ahead, let's just think about animation. What is it exactly? The
    word probably conjures up images of moving cartoon characters and in-game characters
    of a video game.
  prefs: []
  type: TYPE_NORMAL
- en: We need to animate our buttons (make them move) to make it clear when they are
    part of the sequence. We saw that simply making one disappear and then reappear
    was inadequate.
  prefs: []
  type: TYPE_NORMAL
- en: The thought of controlling the movement of UI elements might make us imagine
    complex `for` loops and per-pixel calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Android provides us with the `Animation` class, which allows us
    to animate UI objects without any such per-pixel awkwardness. Here is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, to fully control the shape and size of in-game objects, we must eventually
    learn to manipulate individual pixels and lines. We will do so from [Chapter 7](ch07.html
    "Chapter 7. Retro Squash Game"), *Retro Squash Game*, onwards, when we make a
    retro pong-style squash game.
  prefs: []
  type: TYPE_NORMAL
- en: UI animation in Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Animations in the Android UI can be divided into three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing the animation in a file using a special syntax we will see shortly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing that animation by creating an object of it in our Java code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the animation to a UI element when the animation is required to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at some code that describes an animation. We will soon be
    reusing this same code in our memory game. The purpose of showing it is not so
    much that we understand each and every line of it. After all, learning Java should
    be enough of an accomplishment without mastering this too. Moreover, the purpose
    is to demonstrate that whatever animation you can describe can then be used in
    our games using the same Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly search the Web to find the code to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fading in and out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sliding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding or shrinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphing color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is some code that causes a wobble effect. We will use it on a button,
    but you can also use it on any UI element or even the whole screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: The first line simply states that this is a file written in XML format. The
    next states that we will be performing a rotation. Then we state that the duration
    will be 100 milliseconds, the rotation will be from -5 degrees, the pivot will
    be on the *x* and *y* axes by 50 percent, repeat eight times, and reverse to positive
    5 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a mouthful, but the point is that it is easy to grab a template
    that works and then customize it to fit our situation. We could save the preceding
    code with a filename like `wobble.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we could simply reference it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can play the animation like this on our chosen UI object, in this case
    our `button1` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Phase 5 – animating the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add an animation that causes a button to wobble when a button sound
    is played. At the same time, we can remove the code that makes the button invisible
    and the code that makes it reappear. That wasn''t the best way to do it, but it
    served a purpose while developing the game:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to add a new folder to our project, called `anim`. So right-click on
    the `res` folder in the Project Explorer window. Navigate to **New** | **Android
    resource directory** and click on **OK** to create the new `anim` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the `anim` folder and navigate to **New** | **Animation resource
    file**. Enter `wobble` in the **File name** field and click on **OK**. We now
    have a new file called **wobble.xml** open in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace all but the first line of `wobble.xml` with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now switch to `GameActivity.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code just after the declaration of our `GameActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just after the call to `setContentView` in our `onCreate` method, add this
    piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, near the start of our thread code, find the calls to make our buttons
    reappear. Comment them out like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, directly after our code in the previous step, within each of the four
    `case` statements, we need to comment out the lines that call `setVisibility`
    and replace them with our wobble animation. The following code is slightly abbreviated
    but shows exactly where to comment and where to add the new lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in our `sequenceFinished` method, we can comment out all the `setVisibility`
    calls, just as we did in our thread, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That was not too tough. We added the wobble animation to the `anim` folder,
    declared an animation object, and initialized it. Then we used it whenever it
    was required on the appropriate button.
  prefs: []
  type: TYPE_NORMAL
- en: There are obviously loads of improvements we could make to this game, especially
    to its appearance. I'm sure you can think of more. And certainly, if this was
    to be your app, you were trying to make it big on the Play Store. That is exactly
    what you should do.
  prefs: []
  type: TYPE_NORMAL
- en: Constantly improve all aspects and strive to be the best in your genre. If you
    feel the urge, then why not improve upon it?
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few self-test questions that look at ways we could do more with some
    of the examples from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) Suppose that we want to have a quiz where the question could be to name
    the president as well as capital city. How can we do this with multidimensional
    arrays?
  prefs: []
  type: TYPE_NORMAL
- en: Q2) In our *Persistence example* section, we saved a continually updating string
    to a file so that it persisted after the app had been shut down and restarted.
    This is like asking the user to click on a Save button. Summoning all your knowledge
    of [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, can you think of a way to save the string without saving
    it in the button click but just when the user quits the app?
  prefs: []
  type: TYPE_NORMAL
- en: Q3) Other than increasing the difficulty level, how could we increase the challenge
    of our memory game for our players?
  prefs: []
  type: TYPE_NORMAL
- en: Q4) Using the plain Android UI with the dull grey buttons isn't very exciting.
    Take a look at the UI elements in the visual designer and try and work out how
    we could quickly improve the visual appearance of our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a bit of a hefty chapter, but we learned lots of new techniques such
    as storing and manipulating with arrays, creating and using sound effects, and
    saving important data such as a high score, in our game. We also took a very brief
    look at the powerful but simple-to-use `Animation` class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a more theoretical approach, but we will
    have plenty of working samples too. We will finally be opening the black box of
    Java classes so that we can gain an understanding of what is going on when we
    declare and use objects of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. OOP – Using Other People's Hard Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP stands for **object-oriented programming**. In this chapter, you don't need
    to even try and remember everything. Why do I say this? Surely, that's what learning
    is. The more important thing is to grasp the concepts and begin to understand
    the *why* of OOP rather than memorize rules, syntax, and jargon.
  prefs: []
  type: TYPE_NORMAL
- en: The more important thing is to actually start to use some of the concepts, even
    though you might have to keep referring back and your code might not properly
    adhere to every OOP principal that we discuss. Neither does the code in this book.
    The code in this chapter is here to help you explore and grasp the concepts of
    OOP.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to memorize this chapter, you will have to make a lot of room in
    your brain, and you will probably forget something really important in its place
    such as going to work or thanking the author for telling you not to try and memorize
    this stuff.
  prefs: []
  type: TYPE_NORMAL
- en: A good goal will be to try and almost get it. Then we will start to recognize
    examples of OOP in action so that our understanding becomes more rounded. You
    can then often refer back to this chapter for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: So what is all this OOP stuff we will learn about? Actually, we have already
    learned loads about OOP. Until now, we have been using classes such as `Button`,
    `Random`, and `Activity`, overriding methods of classes (mainly `onCreate`) and
    using an **interface** as well; remember implementing `onClickListener` a few
    times in the first five chapters?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter just helps to make sense of OOP and expands our understanding,
    and finally, we will make our own classes.
  prefs: []
  type: TYPE_NORMAL
- en: Then we will be in a good position in the next two chapters to make two cool
    retro arcade games using lots of other people's hard work. This chapter will be
    mainly theory, but with a few practical console examples using LogCat so that
    we can see OOP in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at what OOP is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write our first class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at what encapsulation is and how we achieve it as well as look more deeply
    at variables and the different types. We will also take a short break to throw
    out the garbage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about inheritance and how we can extend and even improve upon a class
    before we use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at polymorphism, which is a way of being more than one thing at
    a time and is really useful in programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is OOP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  prefs: []
  type: TYPE_NORMAL
- en: Each chunk is self-contained yet potentially reusable by other programs while
    working together as a whole with the other chunks.
  prefs: []
  type: TYPE_NORMAL
- en: These chunks are what we have been referring to as objects. When we plan an
    object, we do so with a class. A class can be thought of as the blueprint of an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint. You can''t live in it, but you can build a house
    from it, which means you build an instance of it. However, OOP is more than this.
    It is also a methodology that defines best practices such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**: This means keeping the internal workings of your code safe
    from interference from the programs that use it, and allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still accessed in the same way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: Just like it sounds, inheritance means we can harness all
    the features and benefits of other people''s hard work, including encapsulation
    and polymorphism, while refining their code specifically for our situation. Actually,
    we have done this already every time we used the `extends` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: This allows us to write code that is less dependent on the
    types we are trying to manipulate, making our code clearer and more efficient.
    Some examples later in the chapter will make this clear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we talk about using other people's hard work, we are not talking about
    a magical way to abuse copyright and get away with it. Some code is plain and
    simple, someone else's property. What we are taking about is the vast array of
    free-to-use code, particularly in the context of this book, in the Java and Android
    APIs. If you want some code that does a certain thing, it has probably been done
    before. We just have to find it, then use it or modify it.
  prefs: []
  type: TYPE_NORMAL
- en: Java was designed from the start with all of this in mind, so we are fairly
    significantly constrained to using OOP. However, this is a good thing because
    we learn how to use the best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Why do it like this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When written properly, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained nature means less, or perhaps zero, consequences for
    other parts of the program. This is the encapsulation part.
  prefs: []
  type: TYPE_NORMAL
- en: You can use other people's code without knowing or perhaps even caring how it
    works. Think about the Android lifecycle, buttons, threads, and so on. The `Button`
    class is quite complicated, with nearly 50 methods—do we really want to write
    all that just for a button?
  prefs: []
  type: TYPE_NORMAL
- en: OOP allows you to write apps for highly complex situations without breaking
    a sweat. You can create multiple similar yet different versions of a class without
    starting the class from scratch using inheritance, and you can still use the methods
    intended for the original type of object with your new object because of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Makes sense, really! Let's write some classes and then make some objects out
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Our first class and first object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what exactly is a class? A class is a bunch of code that can contain methods,
    variables, loops, and all other types of Java syntax. A class is part of a package
    and most packages will normally have multiple classes. Usually, but not always,
    each new class will be defined in its own `.java` code file with the same name
    as the class.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have written a class, we can use it to make as many objects from it
    as we need. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the blueprint just as the object isn't the class;
    it is an object made from the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for a class. We call it a class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet of code is a class implementation for a class called `Soldier`.
    There are two variables, an `int` variable called `health` and a `string` variable
    called `soldierType`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a method called `shootEnemy`. The method has no parameters and
    a `void return` type, but class methods can be of any shape or size that we discussed
    in [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"), *Gaming and
    Java Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare variables in a class, they are known as **fields**. When the
    class is instantiated into a real object, the fields become variables of the object
    itself, so we call them **instance** variables. Whichever fancy name they are
    referred to by, they are just variables of the class. However, the difference
    between fields and variables declared in methods (called the **local** variables)
    becomes more important as we progress. We will look at all types of variables
    again in the *Variables revisited* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, this is just a class, not an object. It is a blueprint for a soldier,
    not an actual `soldier` object. This is how we make an object of the `Soldier`
    type from our `Soldier` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first part of the code, `Soldier mySoldier` declares a new reference
    type variable of type `Soldier`, called `mySoldier`, and in the last part of the
    code, `new Soldier()` creates an actual `Soldier` object. Of course, the assignment
    operator, `=`, in the middle of the two parts assigns the result of the second
    part to that of the first. Just like regular variables, we could also have performed
    the preceding steps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we would assign and use the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the dot operator, `.`, is used to access the
    variables of the class, and this is how we would call the method. Again, we use
    the object name and not the class name, followed by the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a rough guide, a class's methods are what it can *do* and its instance variables
    are what it *knows* about itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also go ahead by making another `Soldier` object and accessing its methods
    and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: It is important to realize that `mySoldier2` is a totally separate object with
    totally separate instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that everything is done on the object itself. We must create objects
    of classes in order to make them useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, there are exceptions to this rule, but they are in the minority,
    and we will look at the exceptions later in the chapter. In fact, we have already
    seen an exception way back in [Chapter 3](ch03.html "Chapter 3. Speaking Java
    – Your First Game"), *Speaking Java – Your First Game*. Think of `Toast`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore basic classes a little more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Basic classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens when we want an army of `Soldier` objects? We will instantiate
    multiple objects. We will also demonstrate the use of the dot operator on variables
    and methods, and show that different objects have different instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the working project for this example in the code download. It is
    in the `chapter6` folder and is called simply `BasicClasses`. Or read on to create
    your own working example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Clean
    up the code by deleting the unnecessary parts, but this isn't essential. Call
    the application `BasicClasses`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we create a new class called `Soldier`. Right-click on the `com.packtpub.basicclasses`
    folder in the Project Explorer window. Click on **New**, then on **Java Class**.
    In the **Name** field, type `Soldier` and click on **OK**. The new class is created
    for us, with a code template ready to put our implementation within, just like
    what is shown in the following screenshot:![Basic classes](img/8859OS_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that Android Studio has put the class in the same package as the rest
    of our app. Now we can write its implementation. Write the following class implementation
    code within the opening and closing curly braces of the `Soldier` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have a class, a blueprint for our future objects of the `Soldier`
    type, we can start to build our army. In the editor window, click on the tab of
    **MainActivity.java**. We will write this code, as so often, within the `onCreate`
    method just after the call to `setContentView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a really good time to start taking advantage of the autocomplete feature
    in Android Studio. Notice that after you have declared and created a new object,
    all you have to do is begin typing the object's name and all the autocomplete
    options will present themselves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our extremely varied and somewhat unlikely army, we can use
    it and also verify the identity of each object. Type the following code below
    the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can run our app on an emulator. Remember, all the output will be in the
    **LogCat** console window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how the preceding pieces of code work. In step 2, Android Studio created
    a template for our new `Soldier` class. In step 3, we implemented our class in
    quite the same way that we have before—two variables, an `int` and a `string`,
    called `health` and `soldierType`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a method in our class called `shootEnemy`. Let''s look at it again
    and examine what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: In the body of the method, we print the `soldierType` string to the console
    first, and then the arbitrary `" is shooting"` string. What's neat here is that
    the `soldierType` string will be different depending on which object we call the
    `shootEnemy` method on.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we declared, created, and assigned three new objects of type `Soldier`.
    They where `rambo`, `vassily`, and `wellington`. In step 5, we initialized each
    with a different value for `health` as well as `soldierType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Notice that each time we access the `health` variable of each `Soldier` object,
    it is printed to the value we assigned it, demonstrating that although the three
    objects are of the same type, they are completely separate individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps more interesting are the three calls to `shootEnemy`. One call by each
    of our `Soldier` objects' `shootEnemy` method is made, and we print the `soldierType`
    variable to the console. The method has the appropriate value for each individual
    object, further demonstrating that we have three distinct objects, albeit created
    from the same `Soldier` class.
  prefs: []
  type: TYPE_NORMAL
- en: More things we can do with our first class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can treat a class much like other variables. Assuming we have already implemented
    our `Soldier` class, we can make an array of `Soldier` objects like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use an object from an array using the same style of array notation
    as we did for regular variables, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use a class as an argument in a method call. Here is a hypothetical
    call to a `healSoldier` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, the preceding example might raise questions like should the `healSoldier`
    method be a method of a class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: It could be or not (as shown in the previous example). It would depend upon
    what is the best solution for the situation. We will look at more OOP, and then
    the best solution for lots of similar conundrums should present themselves more
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have come to expect by now, we can use an object as the return
    value of a method. Here is what the hypothetical `healSoldier` method might look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: All of this information will likely raise a few questions. OOP is like that,
    so to try and consolidate all this class stuff with what we already know, let's
    take another look at variables and encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, what we have really seen is what amounts to a kind of code-organizing
    convention, although we did discuss the wider goals of all this OOP stuff. Now
    we will take things further and begin to see how we actually manage to achieve
    encapsulation with OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Definition of encapsulation**'
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned encapsulation means keeping the internal workings of your
    code safe from interference from the programs that use it, allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still made available in the same way. It also allows the code
    that uses your encapsulated code to be much simpler and easier to maintain because
    much of the complexity of the task is encapsulated in your code.
  prefs: []
  type: TYPE_NORMAL
- en: But didn't I say that we don't have to know what is going on inside? So you
    might question what we have seen so far. If we are constantly setting the instance
    variables like this `rambo.health = 100;`, isn't it possible that eventually things
    could start to go wrong, perhaps like the following line of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Encapsulation protects your class from being used in a way that it wasn''t
    meant to be. By strictly controlling the way that your code is used, it can only
    ever do what you want it to do, with values you can control. It can''t be forced
    into errors or crashes. Also, you are then free to make changes to the way your
    code works internally, without breaking any programs that are using an older version
    of the code or the rest of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: We can encapsulate our classes to avoid this, and here is how.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the use of classes with access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The designer of the class controls what can be seen and manipulated by any
    program that uses their class. We can add an **access modifier** before the `class`
    keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two class access modifiers. Let''s briefly look at each in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: This is straightforward. A class declared as `public` can be seen
    by all other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: A class has default access when no access modifier is specified.
    This will make it public but only to classes in the same package, and inaccessible
    to all others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can make a start with this encapsulation thing. However, even at a glance,
    the access modifiers described are not very fine-grained. We seem to be limited
    to complete lockdown to anything outside the package or a complete free-for-all.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the benefits here are easily taken advantage of. The idea would be
    to design a package that fulfills a set of tasks. Then all the complex inner workings
    of the package, the stuff that shouldn't be messed with by anybody but our package,
    should have default access (only accessible to classes within the package). We
    can then provide a careful selection of public classes that can be used by others
    (or other distinct parts of our program).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the size and complexity of the games in this book, multiple packages are
    almost certainly overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Class access in a nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to class-level privacy controls, Java gives us very fine-grained
    controls, but to use these controls, we have to look at variables in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the use of variables with access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build on class visibility controls, we have variable access modifiers. Here
    is a variable with the private access modifier being declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that all of our discussion of variable access modifiers applies to
    object variables too. For example, here is an instance of our `Soldier` class
    being declared, created, and assigned. As you can see, the access specified in
    this case is public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Before you apply a modifier to a variable, you must first consider the class
    visibility. If class `a` is not visible to class `b`, say because class `a` has
    default access and class `b` is in another package, then it doesn't make any difference
    what access modifiers you use on the variables in class `a`; class `b` still can't
    see it.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it makes sense to show a class to another class when necessary, but you
    should only expose the variables that are needed—not everything.
  prefs: []
  type: TYPE_NORMAL
- en: We have a bit more to cover on access modifiers, and then we will look at a
    few examples to help clarify things. For now, here is an explanation of the different
    variable access modifiers. They are more numerous and fine-grained than the class
    access modifiers. Most of the explanations are straightforward, and the ones that
    might raise questions will become clearer when we look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The depth and complexity of access modification is not so much in the range
    of modifiers, but by using them in smart ways, we can combine them to achieve
    the worthy goals of encapsulation. Here are the variable access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: You guessed it! Any class or method from any package can see this
    variable. Use `public` only when you are sure that this is what you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: This is the next least restrictive modifier after `public`. `protected`
    Variables set as protected can be seen by any class and any method as long as
    they are in the same package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This doesn''t sound as restrictive as `protected`, but it is more
    so. A variable has default access when no access is specified. The fact that `default`
    is restrictive perhaps implies that we should be thinking on the side of hiding
    our variables rather than exposing them. At this point, we need to introduce a
    new concept. Do you remember that we briefly discussed inheritance, and how we
    can quickly take on the attributes of a class and yet refine it using the `extends`
    keyword? Just for the record, default access variables are not visible to subclasses.
    This means that when we extend a class like we did with `Activity`, we cannot
    see its default variables. We will look at inheritance in more detail later in
    the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: These variables can only be seen within the class they are declared.
    Like default access, they cannot be seen by subclasses (inherited classes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable access in a nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes. Within these classes, variables will
    have carefully chosen and most likely varied access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: There's one more twist in all this access modification stuff before we get practical
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Methods have access modifiers too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It makes sense that methods are the things that our classes can do. We will
    want to control what users of our class can and can't do. The general idea here
    is that some methods will do things internally only and are therefore not needed
    by users of the class, and some methods will be fundamental to how users use your
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The access modifiers for methods are the same as those for the class variables.
    This makes things easy to remember but suggests again that successful encapsulation
    is a matter of design rather than any specific set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the method in the following code snippet, provided in a public
    class, can be used by any other class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following method can only be used internally by the class that
    created it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method has default visibility with no access specified. It can be
    used only by other classes in the same package. If we extend the class containing
    this default access method, the class will not have access to this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a last example before we move on. It contains a `protected` method,
    only visible to the package, but usable by our classes that extend it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Method access in a nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Method access should be chosen to best enforce the principles we have already
    discussed. It should provide the users of your class with just the access they
    need, and preferably nothing more. Thereby, we achieve our encapsulation goals
    such as keeping the internal workings of your code safe from interference from
    the programs that use it, for all the reasons we have discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing private variables with the getter and setter methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So if it is best practice to hide our variables away as private, how do we allow
    access to them without spoiling our encapsulation? What if an object of the `Hospital`
    class wanted access to the `health` member variable from an object of type `Soldier`
    so that it could increase it? The `health` variable should be private, right?
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to make as many member variables as possible private and
    yet allow some kind of limited access to some of them, we use **getters** and
    **setters**. Getters and setters are methods that just get and set variable values.
  prefs: []
  type: TYPE_NORMAL
- en: This is not some special or new Java thing we have to learn. It is just a convention
    for the use of what we already know. Let's take a look at getters and setters
    using the example of our `Soldier` and `Hospital` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, each of our two classes are created in their own file but
    the same package. First of all, here is our hypothetical `Hospital` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation of the `Hospital` class has just one method, `healSoldier`.
    It receives a reference to a `Soldier` object as a parameter, so this method will
    work on whichever `Soldier` object is passed in: `vassily`, `wellington`, `rambo`,
    or whoever.'
  prefs: []
  type: TYPE_NORMAL
- en: It also has a `health` variable. It uses this variable to temporarily hold and
    increase the soldier's health. In the same line, it initializes the `health` variable
    to the `Soldier` object's current health. The `Soldier` object's `health` is private,
    so the public getter method is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Then `health` is increased by 10 and the `setHealth` setter method loads the
    new `health` value back to the `Soldier` object.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that although a `Hospital` object can change a `Soldier` object's
    health, it does so within the bounds of the getter and setter methods. The getter
    and setter methods can be written to control and check for potentially erroneous
    or harmful values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes our hypothetical `Soldier` class, with the simplest implementation
    possible of it''s getter and setter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: We have one instance variable called `health` and it is private. Private means
    it can only be changed by methods of the `Soldier` class. We then have a public
    `getHealth` method, which unsurprisingly returns the value held in the private
    `health` variable of the `int` type. As this method is public, anyone with access
    to the `Soldier` class can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `setHealth` method is implemented. Again it is public, but this time,
    it takes `int` as a parameter and assigns whatever value is passed to the private
    `health` variable. In a more life-like example, we would write some more code
    here to ensure that the value passed is within the bounds we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will declare, create, and assign to make an object of each of our two
    new classes and see how our getters and setters work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: We see that we can call our public `setHealth` and `getHealth` methods directly
    on our object of type `Soldier`. Not only that, we can also call the `healSoldier`
    method of the `Hospital` object, passing in a reference to the `Soldier` object,
    which can use the public getters and setters to manipulate the private `health`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: We see that the private `health` variable is simply accessible, yet totally
    within the control of the designer of the `Soldier` class.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play around with this example, there is a working app in the
    code bundle in the `Chapter6` folder, called `Getters And Setters`. I have added
    a few lines of code to print to the console. We deliberately covered this the
    way we did to keep the key parts of the code as clear as possible. We will soon
    build some real working examples that explore class, variable, and method access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getters and setters are sometimes referred to by their more correct names, **Accessors**
    and **Mutators**. We will stick to getters and setters. Just thought you might
    like to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet again, our example and the explanation are probably raising more questions.
    That''s good! Previously, I said that:'
  prefs: []
  type: TYPE_NORMAL
- en: There are two access modifiers for a class, default and public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects of classes are a type of reference variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables (including objects) have even more access possibilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to look more closely at reference and primitive variables as well as
    local and instance variables. We will do so in a moment in the *Variables revisited*
    section. In that section, we will consolidate our information further to get a
    tighter grip on this OOP stuff. First let's remind ourselves of a bit about encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Using encapsulation features (such as access control) is like signing a really
    important deal about how to use and access a class, its methods, and its variables.
    The contract is not just an agreement about the present but an implied guarantee
    for the future. We will see that as we proceed through this chapter, there are
    more ways that we refine and strengthen this contract.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is perfectly possible to rewrite every example in this book without thinking
    or caring about encapsulation. In fact, the projects in this book outside of this
    chapter are quite lax about encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Use encapsulation where it is needed or, of course, if you are being paid to
    use it by an employer. Often encapsulation is overkill on small learning projects,
    such as the games in this book, except when the topic you are learning is encapsulation
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: We are learning this Java OOP stuff under the assumption that you will one day
    want to write much more complex apps, whether on Android or some other platform
    that uses OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our objects with constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of these private variables and their getters and setters, does it
    mean that we need a getter and a setter for every private variable? What about
    a class with lots of variables that need initializing at the start? Think about
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: We could go on like this. Some of these variables might need getters and setters,
    but what if we just want to set things up when the object is first created to
    make the object function correctly? Do we need two methods (a getter and a setter)
    for each?
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we have a special method called a constructor. Here, we create an
    object of type `Soldier` and assign it to an object called `mySoldier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing new here, but look at the last part of that line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: This looks suspiciously like a method.
  prefs: []
  type: TYPE_NORMAL
- en: We have called a special method called a constructor that has been supplied
    automatically for us by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'However (and this is getting to the point now), like a method, we can override
    it, which means we can do really useful things to set up our new object *before*
    it is used and any of its methods are placed on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: This is a constructor. It has a lot of syntactical similarities to a method.
    It can only be run with the use of the `new` keyword. It is created for us automatically
    by the compiler unless we create our own like in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They have no return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the same name as the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can have parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be overloaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will play with constructors in the next demo.
  prefs: []
  type: TYPE_NORMAL
- en: Variables revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably remember, back in the math game project, that we kept changing
    where we declared our variables. First, we declared some in `onCreate`, then we
    moved them to just below the class declaration, and then we were making them member
    or instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Because we didn't specify the access, they were of default access and visible
    to the whole class, and as everything took place in the one class, we could access
    them everywhere. For example, we could update our TextView type objects from `onClick`,
    but why couldn't we do that when they were declared in `onCreate`? Further explanation
    about when and how we can access different variables is probably going to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The stack and the heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The VM inside every Android device takes care of memory allocation to our games.
    In addition, it stores different types of variables in different places.
  prefs: []
  type: TYPE_NORMAL
- en: Variables that we declare and initialize in methods are stored on the area of
    memory known as the `stack`. We can stick to our warehouse analogy when talking
    about the stack—almost. We already know how we can manipulate the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about the heap and what is stored there. All reference type objects,
    which include objects (of classes) and arrays, are stored in the heap. Think of
    the heap as a separate area of the same warehouse. The heap has lots of floor
    space for odd-shaped objects, racks for smaller objects, lots of long rows with
    smaller sized cube-shaped holes for arrays, and so on. This is where our objects
    are stored. The problem is that we have no direct access to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look again at what exactly a reference variable is. It is a variable that
    we refer to and use via a reference. A reference can be loosely (but usefully)
    defined as an address or location. The reference (address or location) of the
    object is on the stack. When we use the dot operator, we are asking Dalvik to
    perform a task at a specific location as stored in the reference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reference variables are just that—a reference. They are a way to access and
    manipulate the object (variables or methods), but they are not the actual variable.
    An analogy might be that primitives are right there (on the stack) but references
    are an address, and we say what to do at the address. In this analogy, all addresses
    are on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we ever want a system like this? Just give me my objects on the stack
    already!
  prefs: []
  type: TYPE_NORMAL
- en: A quick break to throw out the trash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember way back in the first chapter when I said Java was easier to learn
    than some languages because it helps us manage the memory? Well, this whole stack
    and heap thing does that for us.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the VM keeps track of all our objects for us and stores them in
    the heap—a special area of our warehouse. Periodically, the VM will scan the stack,
    or the regular racks of our warehouse, and match references to objects. If it
    finds any objects without a matching reference, it destroys them. In Java terminology,
    it performs garbage collection. Think of a very discriminating refuse vehicle
    driving through the middle of our heap, scanning objects to match to references.
    No reference? You're garbage now! After all, if an object has no reference variable,
    we can't possibly do anything with it anyway. This system of garbage collection
    helps our games run more efficiently by freeing unused memory.
  prefs: []
  type: TYPE_NORMAL
- en: So variables declared in a method are local, on the stack, and only visible
    within the method they were declared. A member variable is on the heap and can
    be referenced from any place where there is a reference to it, provided the access
    specification allows the referencing.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can take a closer look at the variable scope—what can be seen from where.
  prefs: []
  type: TYPE_NORMAL
- en: There are more twists and turns to be learned with regard to variables. In the
    next demo, we will explore all we have learned so far in this chapter and some
    new ideas too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Static variables that are consistent (the same) across every instance of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods of a class where you can use the methods of a class without an
    object of that class type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will demonstrate the scope of class and local variables, and where they can
    and can't be seen by different parts of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at the `this` keyword, which allows us to write code that refers
    to variables that belong to a specific instance of a class, but without keeping
    track of which instance we are currently using
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is the demo.
  prefs: []
  type: TYPE_NORMAL
- en: Access, scope, this, static, and constructors demo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have looked at the intricate way by which access to variables and their
    scope is controlled, and it would probably serve us well to look at an example
    of them in action. These will not be very practical real-world examples of variable
    use, but more of a demonstration to help understand access modifiers for classes,
    methods, and variables, alongside the different types of variables such as reference
    (or primitive) and local (or instance). Then we will cover the new concepts of
    static and final variables and the `this` keyword. The completed project is in
    the `Chapter6` folder of the code download. It is called `AccessScopeThisAndStatic`.
    We will now perform the following steps to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank activity project and call it `AccessScopeThisAndStatic`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the existing `MainActivity` class in
    the Project Explorer and navigating to **New** | **Class**. Name the new class
    `AlienShip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we declare our new class and some member variables. Note that `numShips`
    is private and static. We will soon see how this variable is the same across all
    instances of the class. The `shieldStrength` variable is `private` and `shipName`
    is `public`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is the constructor. We can see that the constructor is public, has no
    return type, and has the same name as the class, as per the rules. In it, we increment
    the private static `numShips` variable. Remember that this will happen each time
    we create a new object of the `AlienShip` type. The constructor also sets a value
    for the `shieldStrength` private variable using the private `setShieldStrength`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the public static getter method that classes outside `AlienShip` can
    use to find out how many `AlienShip` objects are there. We will also see the unusual
    way in which we use static methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code shows our private `setShieldStrength` method. We could have
    just set `shieldStrength` directly from within the class, but this code shows
    how we can distinguish between the `shieldStrength` local variable/parameter and
    the `shieldStrength` member variable using the `this` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This next method is the getter, so other classes can read but not alter the
    shield strength of each `AlienShip` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have a public method that can be called every time an `AlienShip` object
    is hit. It just prints to the console and then checks whether that particular
    object''s `shieldStrength` is zero. If it is zero, it calls the `destroyShip`
    method, which we look at next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will look at the `destroyShip` method for our `AlienShip` class.
    We print a message that indicates which ship has been destroyed, based on its
    `shipName`, as well as increment the `numShips` static variable so that we can
    keep track of the number of objects of the `AlienShip` type we have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we switch over to our `MainActivity` class and write some code that uses
    our new `AlienShip` class. All of the code goes in the `onCreate` method after
    the call to `setContentView`. First, we create two new `AlienShip` objects called
    `girlShip` and `boyShip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look how we get the value in `numShips`. We use the `getNumShips` method as
    we might expect. However, look closely at the syntax. We are using the class name
    and not an object. We can also access static variables with methods that are not
    static. We did it this way to see a static method in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we assign names to our public `shipName` string variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we attempt to assign a value directly to a private variable, it won''t work.
    Therefore, we use the public `getShieldStrength` getter method to print the value
    of `shieldStrength`, which was assigned to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we get to blow some stuff up by playing with the `hitDetected` method
    and occasionally checking the shield strength of our two objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we think we have destroyed a ship, we again use our static `getNumShips`
    method to check whether our static variable `numShips` was changed by the `destroyShip`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the demo and look at the console output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output of the preceding blocks of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we saw that we can distinguish between local and member
    variables of the same name using the `this` keyword. We can also use the `this`
    keyword to write code that refers to the current object being acted upon.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a static variable, in this case `numShips`, is consistent across
    all instances. Moreover, by incrementing it in the constructor and decrementing
    it in our `destroyShip` method, we can keep track of the number of `AlienShip`
    objects we created.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that we can use static methods by writing the class name with the
    dot operator instead of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we demonstrated how we could hide and expose certain methods and variables
    using an access specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a quick review of the stack and the heap before we move
    on to something new.
  prefs: []
  type: TYPE_NORMAL
- en: A quick summary on stack and heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at what we learned about the stack and the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't delete objects but the VM sends the garbage collector when it thinks
    it is appropriate. This is usually done when there is no active reference to the
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables and methods are on the stack, and local variables are local
    to the specific method within which they were declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance or class variables are on the heap (with their objects) but the reference
    to the object (address) is a local variable on the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We control what goes inside the stack. We can use the objects on the heap but
    only by referencing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heap is maintained by the garbage collector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object is garbage collected when there is no longer a valid reference to
    it. Therefore, when a reference variable, local or instance, is removed from the
    stack, then its related object becomes viable for garbage collection, and when
    the virtual machine decides the time is right (usually very promptly), it will
    free the RAM memory to avoid running out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we try to reference an object that doesn't exist, we will get a **null pointer
    exception** and the game will crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use other people's hard work by instantiating/creating
    objects from the classes of an API such as that of Android, but this whole OOP
    thing goes even further than that.
  prefs: []
  type: TYPE_NORMAL
- en: What if there is a class that has loads of useful functionality in it but not
    quite what we want? We can inherit from the class and then further refine or add
    to how it works and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single game and demo we looked at. When we use the `extends`
    keyword, we are inheriting, for example, in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are inheriting the `Activity` class along with all its functionality,
    or more specifically, all of the functionality that the class designers want us
    to have access to. Here are some of the things we can do to classes we have extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can override a method and still rely in part on the overridden method in
    the class we inherit from. For example, we overrode the `onCreate` method every
    time we extended the `Activity` class, but we also called the default implementation
    provided by the class designers when we did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we will also be overriding some more methods of the `Activity`
    class. Specifically, we'll override the methods that handle the lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: If we or the designer of a class wants to force us to inherit before we use
    their class, they can declare a class as **abstract**. Then we cannot make an
    object from it. Therefore, we must extend it first and make an object from the
    subclass. We will do this in our inheritance example and discuss it further when
    we look at polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare a method abstract, and that method must be overridden in
    any class that extends the class with the abstract method. We will do this as
    well in our inheritance example.
  prefs: []
  type: TYPE_NORMAL
- en: In our game projects, we will not be designing any classes that we will be extending.
    We have no need of that in the context of learning about building simple games.
    However, we will be extending classes designed by others in every future game.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss inheritance mainly so that we understand what is going on around
    us and as the first step towards being able to eventually design useful classes
    that we or others can extend. With this in mind, let's make some simple classes
    and see how we can extend them, just to play around with the syntax as a first
    step, and also to be able to say we have done it. When we look at the last major
    topic of this chapter, polymorphism, we will also dig a little deeper into inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: An example of inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have looked at the way we can create hierarchies of classes to model the
    system that fits our game or software project, so let''s try out some simple code
    that uses inheritance. The completed project is in the `Chapter6` folder of the
    code download. It is called `InheritanceExample`. We will now perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create three new classes in the usual way. Call one `AlienShip`, another `Fighter`,
    and the last one `Bomber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for the `AlienShip` class. It is very similar to our previous
    `AlienShip` class demo. The differences are that the constructor now takes an
    `int` parameter, which it uses to set the shield strength. The constructor also
    outputs a message to the console so that we can see when it is being used. The
    `AlienShip` class also has a new method, `fireWeapon`, that is declared `abstract`.
    This guarantees that any class that subclasses `AlienShip` must implement their
    own version of `fireWeapon`. Notice that the class has the `abstract` keyword
    as part of its declaration. We have to do this because one of its methods also
    uses the keyword `abstract`. We will explain the `abstract` method when discussing
    this demo and the `abstract` class when we talk about polymorphism:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will implement the `Bomber` class. Notice the call to `super(100)`.
    This calls the constructor of the superclass with the value for `shieldStrength`.
    We could do further specific `Bomber` initialization in this constructor, but
    for now, we just print the location so that we can see when the `Bomber` constructor
    is being executed. We also implement a `Bomber` class-specific version of the
    abstract `fireWeapon` method because we must do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will implement the `Fighter` class. Notice the call to `super(400)`.
    This calls the constructor of the superclass with the value of `shieldStrength`.
    We could do further `Fighter` class-specific initialization in this constructor,
    but for now, we just print the location so that we can see when the `Fighter`
    constructor is being executed. We also implement a `Fighter` specific version
    of the abstract `fireWeapon` method because we must do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is our code in the `onCreate` method of `MainActivity`. As usual, we enter
    this code after the call to `setContentView`. This is the code that uses our three
    new classes. It looks quite ordinary, but there''s nothing new; it is the output
    that is interesting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output of the preceding snippets of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the constructor of the subclass can call the constructor of the
    superclass. We can also clearly see that the individual implementations of the
    `fireWeapon` method work exactly as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As if OOP where not useful enough already! We can now model real-world objects
    and design them to interact with each other. We have also seen how we can make
    OOP even more useful by subclassing/extending/inheriting from other classes. The
    terminology we might like to learn here is that the class that is extended from
    is the **superclass** and the class that inherits from the superclass is the **subclass**.
    We can also call them parent and child classes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, we might find ourselves asking this question about inheritance: Why?
    We can write common code once, in the parent class, and we can update that common
    code. All the classes that inherit from it are also updated. Furthermore, a subclass
    only inherits public instance variables and methods. When designed properly, this
    further enhances the goals of encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism roughly means different forms. But what does it mean to us?
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest words possible, any subclass can be used as a part of the code
    that uses the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have an array of animals, we could put any object that is
    of a type that is a subclass of `Animal` in the `Animal` array, perhaps cats and
    dogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can write code that is simpler and easier to understand
    and modify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write code for the superclass and rely on the fact that no matter
    how many times it is subclassed, within certain parameters, the code will still
    work. Let''s continue our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also write methods with polymorphic return types and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: So you can even write code *today* and make another subclass in a week, month,
    or year, and the very same methods and data structures will still work.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we can enforce on our subclasses a set of rules as to what they can
    and cannot do, and also how they should do it. Thus, good design in one stage
    can influence our subclasses at other stages.
  prefs: []
  type: TYPE_NORMAL
- en: If you do suddenly find yourself with a flappy-bird-sized phenomenon, and you
    have a lot of OOP in your code, right from the start, it will be much easier to
    bring in hired help to move the project forward and still maintain control of
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: What if you have an idea for a game with lots of features but you want to get
    a simple version of the game out as soon as possible? Smart, object-oriented design
    would certainly be the solution. It could enable you to write the working bare
    bones of a game and then gradually extend it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, let''s look at another OOP concept: abstract classes. We can now
    get to the bottom of what was going on with that `AlienShip` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An abstract class is a class that cannot be instantiated, or cannot be made
    into an object. We mentioned that `AlienShip` was abstract in the previous example.
    So is it a blueprint that will never be used then? But that's like paying an architect
    to design your home and then never building it! I kind of got the idea of an abstract
    method but this is just silly!
  prefs: []
  type: TYPE_NORMAL
- en: 'It might seem like this at first. We make a class abstract by declaring it
    with the `abstract` keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: But why?
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want a class that can be used as a polymorphic type but we need
    to ensure that it can never be used as an object. For example, `Animal` doesn't
    really make sense on its own.
  prefs: []
  type: TYPE_NORMAL
- en: We don't talk about animals; we talk about types of animals. We don't say, "Ooh,
    look at that lovely, fluffy, white animal", or "Yesterday, we went to the pet
    shop and got an animal and an animal bed." It's just too abstract.
  prefs: []
  type: TYPE_NORMAL
- en: So an abstract class is like a template to be used by any class that extends
    it (inherits from it).
  prefs: []
  type: TYPE_NORMAL
- en: We might want a `Worker` class and extend to make classes such as `Miner`, `Steelworker`,
    `OfficeWorker`, and of course `Programmer`. But what exactly does a plain `Worker`
    class do? Why would we ever want to instantiate one?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we wouldn't want to instantiate it, but we might want to
    use it as a polymorphic type so that we can pass multiple worker subclasses between
    methods and have data structures that can hold all types of workers.
  prefs: []
  type: TYPE_NORMAL
- en: We call this type of class an abstract class, and when a class has even one
    abstract method, like `AlienShip` did, it must be declared abstract itself. As
    we saw, all abstract methods must be overridden by any class that extends the
    abstract class. This means that the abstract class can provide some of the common
    functionality that would be available in all its subclasses. For example, the
    `Worker` class might have the `height`, `weight`, and `age` member variables.
  prefs: []
  type: TYPE_NORMAL
- en: It might have the `getPayCheck` method, which is the same in all the subclasses,
    and the `doWork` method, which is abstract and must be overridden because all
    the different types of worker do work very differently.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us neatly on to another area of polymorphism that deserves an honorable
    mention because we have been using it in every game so far.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface is like a class. Phew! Nothing complicated here then. However,
    it's like a class that is always abstract and with only abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of an interface as an entirely abstract class with all its methods
    abstract too. Okay, so you can just about wrap your head round an abstract class
    because it can at least pass on some functionality in its methods that are not
    abstract and serve as a polymorphic type.
  prefs: []
  type: TYPE_NORMAL
- en: But seriously, this interface seems a bit pointless. Bear with me.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an interface, we type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: The methods of an interface have no body because they are abstract, but they
    can still have return types and parameters, or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an interface, we use the `implements` keyword after the class declaration.
    Yes, we already did this for `onClickListener` a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. As long as it implements an
    interface, the whole thing can be passed along as if it is that thing, which it
    is. We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface and list them after the `implements`
    keyword. Just be sure to implement all the necessary methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the `onClickListener` interface. Any thing might like to know
    when it is being clicked on; a Button, a TextView, and so on. We don't want different
    `onClick` methods for every type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Android, for games or for more regular GUI-based apps (a bit like
    ours so far), 9 times out of 10, you will be implementing interfaces rather than
    writing your own. However, knowing what is happening is quite important, not so
    much from a point of view of technical awareness, as we have just seen that the
    interface specifies a contract and the compiler enforces it, but more as a matter
    of sanity in knowing what is actually happening when you use the `implements`
    keyword and write a method (or methods) with a name that you didn't choose.
  prefs: []
  type: TYPE_NORMAL
- en: More about OOP and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to write a whole book on OOP, and many authors have already done
    so, but the best way to learn OOP is probably to practice it; practice it *before*
    we have learned all of the theory. Anyway, before we get on with some more practical
    examples, here is one more slightly theoretical OOP example that will leave us
    scratching our heads later if not mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Inner classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we looked at our basic classes demo app, we declared and implemented the
    class in a separate file to our `MainActivity` class. That file had the same name
    as the class.
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare and implement a class within a class. The only question
    remaining, of course, is why would we do this? When we implement an inner class,
    the inner class can access the member variables of the enclosing class and the
    enclosing class can access the members of the inner class. We will see this in
    action in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not modeling deep or real-world systems, then inner classes are often
    the way to go. In fact, all the classes we will write ourselves in the rest of
    this book will be extended inner classes. This means that we will extend a type
    to make our own class within our `Activity` class. This makes our code nice and
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Q1) Find out what is wrong with this class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Q2) What is encapsulation?
  prefs: []
  type: TYPE_NORMAL
- en: Q3) I don't get it all, and actually, I have more questions now than I had at
    the start of the chapter. What should I do?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered more theory than in any other chapter. If you haven't
    memorized everything, then you have succeeded completely. If you just understand
    that OOP is about writing reusable, extendable, and efficient code through encapsulation,
    inheritance, and polymorphism, then you have the potential to be a Java master.
    Simply put, OOP enables us to use other people's hard work even when those people
    were not aware of exactly what we would be doing at the time they did the work.
    All you have to do is keep practicing, so let's make a retro game in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Retro Squash Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is where the fun starts. Although a retro squash game is obviously
    a step or two down from the latest big-budget game, it is the point when we start
    to look at some fundamentals—drawing, detecting when objects we have drawn bump
    into each other, and having animation that is actually controlled by us.
  prefs: []
  type: TYPE_NORMAL
- en: Once you can draw a pixel and move it, it only needs a bit of imagination and
    work and you have the potential to draw anything. Then, when we combine this knowledge
    with some really simple math to simulate the physics of collision and gravity,
    we will be close to being able to implement our squash game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sadly, this book does not have the time to go into the mathematics of turning
    a dot on the screen into realistic three-dimensional characters moving around
    in a three-dimensional world. Certainly, the technology and math behind big-budget
    titles is very advanced and complicated. However, the basics of turning pixels
    into lines and lines into triangles, texturing a triangle, building objects out
    of triangles, and positioning them in a three-dimensional world are within the
    grasp of anybody who has learned high-school-level math. Often, we hear that great
    graphics don''t make a great game, which is true, but great graphics (at least
    for me) are one of the most exciting aspects of video games, even when they are
    displayed on a game that could be more fun to play by itself. If you want to see
    how to turn pixels into magical worlds, and start to appreciate what goes on behind
    the scenes of the top game engines and graphics libraries, you could start with
    *Computer Graphics: Mathematical First Steps*, *P.A. Egerton and W.S Hall*, *Prentice
    Hall*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the Android `Canvas` class, which makes drawing easy and fun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a simple Canvas demo app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about detecting touches on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the retro squash game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the retro squash game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing with Android Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the Android UI designer to implement all our graphics.
    This is fine when all we need are objects such as buttons and text.
  prefs: []
  type: TYPE_NORMAL
- en: It is true that there is more to the Android UI elements than we have explored
    so far. For example, we know we can do a lot more with the `Animation` class,
    and we very briefly saw that we can assign any image we like to represent one
    of the UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we could assign game characters such as spaceships to UI elements
    and animate them.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we want smoothly moving spaceships with accurate collision detection,
    cute characters, and gruesome baddies with multiframe, cartoon-like animation,
    then we are going to need to move away from predefined UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to need to start looking at and designing with individual pixels,
    lines, bitmaps, and sprite sheets. Fortunately, as you might have guessed, Android
    has some classes to make this nice and easy for us. We will be learning how to
    get started with the `Canvas` and `Paint` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Bitmaps and sprite sheets will be covered in the next chapter. In this chapter,
    we will learn how to draw pixels and lines to make a simple, smoothly moving pong-style
    game of squash.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will learn about the coordinate system we use to draw our
    pixels and lines. Then we will look at the `Paint` and `Canvas` classes themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The Android coordinate system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pixel is the smallest graphical element we can manipulate using the `Paint`
    and `Canvas` classes. It is essentially a dot. If your device resolution is 1920
    x 1080, like some of the newer Google-branded tablets or high-end Samsung phones,
    then we have 1920 pixels across the longest length of the device and 1080 pixels
    across the width.
  prefs: []
  type: TYPE_NORMAL
- en: We can therefore think of our screen on which we will be drawing as a grid.
    We draw using the `Canvas` and `Paint` classes on a virtual canvas. We will do
    so by plotting points (pixels), lines, shapes, and text using coordinates on this
    grid.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate system starts in the top-left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, take a look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'In this, we would plot a single pixel in the top-left corner of the screen.
    Now look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: If we use it like this, we could draw a point in the bottom-right corner of
    one of these high-end devices (while in the landscape position).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also draw lines by specifying a start and end coordinate position,
    a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: This would draw a line from the top-left corner of the screen to the bottom
    right.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed some potential problems. Firstly, not all Android devices
    have such a high resolution; in fact, most are significantly lower. Even devices
    with high resolution will have totally different coordinates when held in landscape
    or portrait positions. How will we write code that adapts to these devices regardless
    of the screen resolution? We will see the solution soon.
  prefs: []
  type: TYPE_NORMAL
- en: Animating our pixels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Drawing shapes, lines, and pixels is all very well, but how do we make them
    appear to move? We will be using the same animation trick used in cartoons, movies,
    and other video games:'
  prefs: []
  type: TYPE_NORMAL
- en: Draw an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rub it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the object in its new position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat fast enough to trick the player's brain that the game objects are moving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The theory makes all of this sound more complicated than it is. Let's take a
    quick look at the `Paint` and `Canvas` classes and a quick introductory demo app.
    Then we can implement our retro squash game for real.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Canvas and Paint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aptly named `Canvas` class provides just what you would expect—a virtual
    canvas to draw our graphics on.
  prefs: []
  type: TYPE_NORMAL
- en: We can make a virtual canvas using the `Canvas` class from any Android UI element.
    In our demo app, we will draw on an ImageView, and when we make our game, we will
    draw straight on a special type of view, which will bring some extra advantages,
    as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need a view to draw on. We already know how to get a view
    from our UI layout using Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: This line of code grabs a reference to an ImageView placed in the UI design
    and assigns it to our object in our Java code. As we have seen, the ImageView
    in the UI design has an assigned ID of `imageView`, and our controllable ImageView
    object in our Java code is called `ourView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a bitmap. A bitmap itself has a coordinate system like the screen.
    We are creating a bitmap to turn it into a canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code declares and creates an object of the `Bitmap` type.
    It will have a size of 300 by 600 pixels. We will keep this in mind when we draw
    on it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last argument in the `createBitmap` method, `Bitmap.Config.ARGB_8888`, is
    simply a format, and we can create some great games without getting into the different
    options for bitmap formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can prepare our bitmap for drawing by creating a `Canvas` object from
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get ourselves an object of the `Paint` type. We can think of this
    object as the brush and the paint for our virtual canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are ready to use our `Paint` and `Canvas` objects to do some
    drawing. The actual code to draw a pixel in the top-left corner of the screen
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at a working example.
  prefs: []
  type: TYPE_NORMAL
- en: Android Canvas demo app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make an app that uses the `Canvas` and `Paint` classes and do a bit of
    drawing. This example will be completely static (no animation), so we can clearly
    see how to use `Canvas` and `Paint` without cluttering the code with things we
    will learn later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this demo app, we use some conceptually helpful variable names to help us
    grasp the role that each object is playing, but we will go through the whole thing
    at the end to make sure we know exactly what is going on at each stage. Of course,
    you don''t have to type all of this. You can open the completed code files from
    the `CanvasDemo` folder in the `Chapter7` folder of the download bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project and call it `CanvasDemo`. Tidy up the unnecessary imports
    and overrides if you want to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the editor. Drag an **ImageView** from the palette
    to the layout. The ImageView has an ID by default, which is `imageView`. Now we
    will use this ID in our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to `MainActivity.java` in the editor. First, we will create our `Bitmap`,
    `Canvas`, and `Paint` objects as we discussed earlier. Here is the first part
    of the code. Enter it directly after the call to the `setContentView` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we try out some of the cool things we can draw. Enter the code directly
    after the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the demo on an emulator or a device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your output will look like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Canvas demo app](img/8859OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's go through the code again. In steps 1 and 2, we created a new project
    and placed an ImageView object with an ID of `imageView` on our UI layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 3, we started by getting a reference to the `ImageView` object in our
    layout. However, we have done this often, usually with TextViews and Buttons.
    We named our ImageView `ourFrame` because it will hold our canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we created a bitmap to be used to make a canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we created our new `Paint` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 4, we were ready to draw, and we did so in a few different ways. First,
    we painted the entire canvas black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we chose the color with which we will be painting. `(255, 255, 255, 255)`
    is a numerical representation of white with full opacity (no transparency):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: Now we see something new, but it is quite easy to understand. We can also draw
    strings of text to the screen and position that text at precise screen coordinates,
    just like we can with a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that with the `drawText` method and all other drawing methods
    of the `Canvas` class, we always pass our `Paint` object as an argument. Just
    to make what is going on in the next line of code absolutely clear, I am stating
    that `"Score: 42 Lives:3 Hi: 97`" is the string that will be drawn on the screen,
    `10, 10` are the screen coordinates, and `paint` is our `Paint` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we draw a line. The argument list here can be described as follows: (start
    *x* coordinate, start *y* coordinate, end *x* coordinate, end *y* coordinate,
    our `Paint` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see that we can draw circles. We can also draw other shapes. The argument
    list here can be described as follows: (start *x* coordinate, start *y* coordinate,
    radius of circle, our `Paint` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we draw a humble, lonely pixel (point). The arguments we use are in this
    format: (*x* coordinate, *y* coordinate, `Paint` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we place our bitmap canvas on our ImageView frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: We still need to get smarter with managing screen resolution and orientation,
    and we will do so in our retro squash game. Also, we need to look for a system
    that will allow us to rub out and redraw our images at a set interval to create
    the illusion of movement. Actually, we already know one such system. Think about
    how we might use threads to achieve this illusion. First of all, let's take a
    look at how the player will control the game. After all, we are not going to have
    any handy UI buttons to press for this game.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting touches on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our retro squash game, we will have no UI buttons, so we cannot use the `OnClickListener`
    interface and override the `onClick` method. This is not a problem, however. We
    will just use another interface to suit our situation. We will use `OnTouchListener`
    and override the `onTouchEvent` method. It works a bit differently, so let's take
    a look at implementing it before we dive into the game code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must implement the `OnTouchListener` interface for the activity we want
    to listen to touches in, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Then we can override the `onTouchEvent` method, perhaps a bit like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: The `x` variable will hold the horizontal value of the position on the screen
    that was touched, and `y` will hold the vertical position. It is worth noting
    that the `motionEvent` object parameter contains lots of information as well as
    the *x* and *y* location, for example, whether the screen was touched or released.
    We can make some really useful switch statements with this information, as we
    will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing exactly how we use this to achieve our goals in the squash game requires
    us to first consider the design of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to make the retro squash game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are ready to discuss the making of our next game. We actually know everything
    we need to. We just need to think about how to use the different techniques we
    have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at exactly what we want to achieve so that we have something
    to aim for.
  prefs: []
  type: TYPE_NORMAL
- en: The design of the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a screenshot of the game as a good starting point. When you design
    your own games, drawing sketches of the in-game objects and mechanics of the game
    will be an invaluable part of the design process. Here, we can cheat a bit by
    taking a look at the end result.
  prefs: []
  type: TYPE_NORMAL
- en: '![The design of the game](img/8859OS_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting from the top, we have **Score**. Every time the player successfully
    hits the ball, a point is added. Next, we have **Lives**. The player starts with
    three lives, and every time they let a ball go past their racket, they lose one
    life. When the player has zero lives, their score is set to zero, lives are set
    back to three, and the game begins again. Next to this, we have **FPS**. FPS stands
    for frames per second. It would be nice if we monitor on the screen the number
    of times our screen is being redrawn every second, as this is the first time we
    are animating our very own graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Approximately in the middle of the previous screenshot is the ball. It is a
    square ball, in keeping with the traditional pong style. Squares are also easier
    when you have to perform realistic-looking collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Physics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will detect when the ball hits any of the four sides of the screen as well
    as when it hits the racket. Depending on what the ball hits and its current direction
    at the time of the collision, we will determine what happens to the ball. Here
    is a rough outline of what each type of collision will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hit the top of the screen**: The ball will maintain the same horizontal (*x*)
    direction of travel but reverse the vertical (*y*) direction of travel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hit either side of the screen**: The ball will maintain its *y* direction
    of travel but reverse its *x* direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hit the bottom of the screen**: The ball will disappear and restart at the
    top of the screen with a downward *y* direction of travel and a random *x* direction
    of travel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hit the player''s racket**: We will check whether the ball has hit the left
    or the right of the racket and alter the *x* direction of travel to match. We
    will also reverse the *y* direction of travel to send the ball back to the top
    again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By enforcing these crude virtual rules of physics, we can simply create a ball
    that behaves almost as we would expect a real ball to do. We will add a few properties
    such as slightly increasing the ball speed after hitting the racket. These rules
    will work just as well in portrait or landscape orientations.
  prefs: []
  type: TYPE_NORMAL
- en: The player's racket will be a simple rectangle that the player can slide left
    by holding anywhere on the left half of the screen, and right by holding anywhere
    on the right of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, we will not be making a main menu screen to implement high scores.
    In our final game, which we start in the next chapter, we will go ahead and have
    an animated menu screen, online high scores, and achievements. However, this squash
    game will simply restart when the player reaches zero lives.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will take a quick theoretical look at some aspects of the implementation
    that might be raising questions. When we finally get down to the implementation,
    we should find most of the code quite straightforward, with only a few bits that
    might need extra explanation.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed everything we need to know, and we will also discuss specifics
    in the code as we go through the implementation. We will go over the trickier
    parts of the code at the end of each phase of implementation.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, all the completed code files can be found in the download bundle.
    The files encompassing all the phases of this project are in the `Chapter7/RetroSquash`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that in an application using classes and their methods, different
    parts of the code will be dependent on other parts. Therefore, rather than jumping
    back and forth in the code, we will lay it out from the first line to the last
    in order. Of course, we will also refer to the related parts of code as we go
    along. I definitely recommend studying the code in its entirety to fully grasp
    what is going on and which parts of the code call which other parts.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this implementation from spreading into an enormous to-do list, it
    has been broken into four phases. This should provide convenient places to stop
    and take a break.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no layout file and only one `.java` file. This file is called `MainActivity.java`.
    The `MainActivity.java` file has a structure as indicated in the following overview
    of the code. I have indented some parts to show what parts are enclosed within
    others. This is a high-level view, and it omits quite a lot of detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: As previously stated, we can see that everything is in the `MainActivity.java`
    file. As usual, at the top of our file, we will have a package name and a load
    of imports for the different classes we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: Next, as per all our other projects, we have the `MainActivity` class. It encompasses
    everything else, even the `SquashCourtView` class. This makes the `SquashCourtView`
    class an inner class and will therefore be able to access the member variables
    of the `MainActivity` class, which will be essential in this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Before the `SquashCourtView` class, however, comes the declaration of all the
    member variables in the `MainActivity` class, followed by a fairly in-depth `onCreate`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We could implement the other Android lifecycle methods next, and you are welcome
    to do so. However, the code within the other Android lifecycle methods will make
    more sense once we have seen the code in the `SquashCourtView` class methods.
  prefs: []
  type: TYPE_NORMAL
- en: After `onCreate`, we will implement the `SquashCourtView` class. This has some
    fairly long methods in it, so we will break it into phases 2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will implement the remaining Android lifecycle methods. They are
    short but important.
  prefs: []
  type: TYPE_NORMAL
- en: The four implementation phases in detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take an even closer look at the implementation before we actually get
    to it. Here is how we will divide the implementation into the four phases, this
    time with a bit more detail as to what to expect in each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 1 – MainActivity and onCreate**: In this phase, we will create the
    project itself as well as implement the following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will add our imports and create the body of our `MainActivity` class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Within this, we will declare the member variables that the game needs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement our `onCreate` method, which does loads of setup work but
    nothing that is hard to understand
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 2 – SquashCourtView part 1**: In this phase, we will start work on
    our key class, `SquashCourtView`. Specifically, we will:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the declaration of the `SquashCourtView` class and its member variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a simple constructor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `run` method to control the flow of the game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the lengthy but fairly easy-to-understand `updateCourt` method. This
    is the method that handles collision detection and keeps track of our ball and
    racket.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 3 – SquashCourtView part 2**: In this phase, we will finish the `SquashCourtView`
    class by implementing the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drawCourt` method, which unsurprisingly does all the drawing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `controlFPS` method, which makes the game run at similar speeds on devices
    that have different CPUs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will quickly write a couple of methods that help the Android lifecycle
    methods with similar names—the `pause` and `resume` methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally for this phase, we will easily handle the touch controls of the game
    by overriding the `onTouchEvent` method we looked at earlier
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 4 – Remaining lifecycle methods**: In this short phase we will add
    the finishing touches:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly implement what happens in the `onPause`, `onResume`, and `onStop` methods
    by overriding them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also handle what happens when the player presses the back button on
    their phone or tablet
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Phase 1 – MainActivity and onCreate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have seen what we will do in each of the phases, let''s actually
    get started with building our game by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project, just as we have before, but with one slight difference.
    This time, on the **New Project** dialog, change **Minimum required SDK** to **API
    13: Android 3.2 (Honeycomb)**. Call the project `RetroSquash`. Delete the unnecessary
    overridden methods if you like.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `AndroidManifest.xml` file, just as we did at the end of [Chapter
    4](ch04.html "Chapter 4. Discovering Loops and Methods"), *Discovering Loops and
    Methods*, to make the app use the full screen. Check back for full details if
    needed. Note that we are *not* locking orientation because this game is fun in
    both portrait and landscape. Here is the line of code to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make some sound effects using Bfxr, as we did in [Chapter 5](ch05.html "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials*. Four will be enough, but
    there is nothing stopping you from adding more sounds. For authentic 1970s-style
    sounds, try the **Blip/Select** button shown in the following screenshot. Name
    the samples `sample1.ogg`, `sample2.ogg`, `sample3.ogg`, and `sample4.ogg`. Or
    you can just use my samples. They are in the `assets` folder of the folder named
    `RetroSquash` in the code bundle.![Phase 1 – MainActivity and onCreate](img/8859OS_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Project Explorer, create a directory called `assets` within the `main` directory.
    Copy the four sound files you created in the previous step to the newly created
    `assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following import statements at the top of the `MainActivity.java`
    file but just after your package name, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now type your class declaration and declare the following member variables.
    We will discuss the member variables in detail at the end of this phase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will enter the `onCreate` method in its entirety. We are initializing
    many of the member variables that we declared in the previous step, as well as
    creating an object from our `SquashCourtView` class, which we will begin to implement
    in the next phase. Perhaps the most notable line in this block of code is the
    somewhat different call to `setContentView`. Look at the argument for `setContentView`.
    We will learn more about this argument at the end of this phase. This phase also
    sets up `SoundPool` and loads the sound samples. Type the first part of the `onCreate`
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we initialize the variables we created earlier. Notice that there are some
    good potential candidates for a bit of encapsulation. However, to keep the code
    readable, we will not do so at this stage. Enter this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Phase 1 code explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at what we did. From steps 1 to 4, we simply created a project and
    some sound files. Then we added the sound files to the `assets` folder as we have
    done before on other projects. In step 5, we added all the necessary imports for
    the classes we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we created a whole load of member variables. Let's take a closer
    look at them. We declared an object of the `Canvas` type called `canvas`. We will
    use this object to set up our drawing system. We also declared an instance of
    `SquashCourtView` called `squashCourtView`. This will be underlined as an error
    because we haven't implemented the class yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we declared and initialized variables to be references to our sound files,
    just as we did in other projects. After this, we did something new:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: We declared a `Display` object and a `Point` object. We see these in action
    in our `onCreate` method in a minute, alongside the two `int` variables, `screenWidth`
    and `screenHeight`. We use them to get the screen size in pixels so that we can
    make our game work on a screen with any resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we declared some variables whose purpose is plain from their names. Their
    actual usage becomes clearer when we initialize them in step 8 and use them throughout
    our `SquashCourtView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a bunch of Boolean variables to control the logic of the movement
    of both the racket and the ball. Notice that there is a variable for each possible
    direction for both the racket and the ball. Notice also that the racket can move
    in two directions—left and right—and the ball in four. Of course, the ball can
    travel in two directions at the same time. All will become clear when we write
    the `updateCourt` method in phase 2\. Here is that code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: In the last part of step 6, we declared two fairly obvious variables, `lives`
    and `score`. But what about `lastFrameTime` and `fps`? These will be used in the
    `controlFPS` method, which we will write in phase 3\. They will be used along
    with some local variables to measure how fast our game loop runs. We can then
    lock it to run at a consistent rate so that players on devices with different
    CPU speeds get a similar experience.
  prefs: []
  type: TYPE_NORMAL
- en: In step 7, we entered the `onCreate` method, but this time, things are different.
    We initialize `squashCourtView` as a new `SquashCourtView` object. It's fine so
    far, but then we seem to be telling `setContentView` to make this the entire view
    that the player will see, instead of the usual view created in the Android Studio
    designer, which we have become used to. We are not using any Android UI components
    in this game, so the visual designer and all of its generated XML are of no use
    to us. As you will see right at the start of phase 2, our `SquashCourtView` class
    extends (inherits from) `SurfaceView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created an object with all the facilities of a `SurfaceView`. We will just
    customize it to play our squash game. Neat! Therefore, it is perfectly acceptable
    and logical to set our `squashCourtView` object as the entire view that the player
    will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: We then set up our sound effects as we have done before.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, we initialized many of the variables that we declared in step 6\.
    Let's look at the values and the order in which we initialized them. You might
    have noticed that we don't initialize every variable here; some will be initialized
    later. Remember that we don't have to initialize member variables and that they
    also have default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we get the number of pixels (wide and high) for the
    device. The `display` object holds the details of the display after the first
    line has been executed. Then we create a new object called `size` of the `Point`
    type. We send `size` as an argument to the `display.getSize` method. The `Point`
    type has an `x` and `y` member variable, and so does the `size` object, which
    now holds the width and height (in pixels) of the display. These values are then
    assigned to `screenWidth` and `screenHeight` respectively. We will use `screenWidth`
    and `screenHeight` quite extensively in the `SquashCourtView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize the variables that determine the size and position of the
    ball and racket. Here, we initialize our `racketPosition` object, which is of
    the `Point` type. Remember that it has an `x` and a `y` member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize `racketPosition.x` to be whatever the current screen width in
    pixels might be, but divided by two, so the racket will start in a horizontal
    and central position regardless of the resolution of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line of code, `racketPosition.y` is put at the bottom of the screen
    with a small 20-pixel gap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'We make the width of the racket to one-eighth the width of the screen. We will
    see when we get to run the game that this is a fairly effective size, but we could
    make it bigger by dividing it by a lower number, or smaller by dividing it by
    a larger number. The point is that it will be the same fraction of `screenWidth`
    regardless of the resolution of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following line of code, we choose an arbitrary height for our racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we make our ball as small as 1/35th of the screen. Again, we could make
    it larger or smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line of code, we will create a new point object to hold the position
    of the ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did with the racket, we start the ball in the center of the screen, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we set it to start at the top of the screen just far enough to see
    the top of the ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'The player starts the game with three lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Phew! That was a fairly chunky section. Take a break if you like, and then we
    will move on to phase 2.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 2 – SquashCourtView part 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we get to the secret weapon of our game—the `SquashCourtView` class.
    The first three methods are presented here, and explained more fully once we have
    implemented them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a class declaration that extends `SurfaceView`, giving our class all
    the methods and properties of `SurfaceView`. It also implements `Runnable`, which
    allows it to run in a separate thread. As you will see, we will put the bulk of
    the functionality in the `run` method. After the declaration, we have a constructor.
    Remember that the constructor is a method that has the same name as the class
    and is called when we initialize a new object of its type. The code in the constructor
    initializes some objects and then sends the ball off in a random direction. We
    will look at that part in detail after we have implemented this phase. Enter the
    following code before the closing curly brace of the `MainActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have this short and sweet overriding of the `run` method. Remember that
    the `run` method contains the functionality of the thread. In this case, it has
    three calls, one to each of `updateCourt`, `drawCourt`, and `controlFPS`, the
    three key methods of our class. Enter this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will implement just one more method in this phase (`updateCourt`), but it
    is quite long. We will split it into chunks and briefly mention what is going
    on in each chunk before we type the code. We will perform a closer examination
    of how it works when the phase is implemented. In this next chunk of code, we
    handle the left and right movement of the racket as well as detecting and reacting
    when the ball hits either the left or the right of the screen. Enter the following
    code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this next chunk of code, we check whether the ball has hit the bottom of
    the screen, that is, the player has failed to return the ball. Enter this code
    directly after the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this chunk of code, we handle whether the ball has hit the top of the screen.
    We also calculate all the possible movements of the ball for this frame. Now type
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we handle collision detection and the reaction of the racket and the
    ball. We also close the `updateCourt` method, and this is the last chunk of code
    for this phase. Enter the following after your code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Phase 2 code explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code in this phase was lengthy, but there is nothing too challenging when
    we break it down. Possibly, the only challenge is in unravelling some of those
    nested `if` statements. We will do this now.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we declare our `SquashCourView` class. This implements the `Runnable`
    interface. You might remember from [Chapter 5](ch05.html "Chapter 5. Gaming and
    Java Essentials"), *Gaming and Java Essentials*, that `Runnable` provides us with
    a thread. All we need to do is override the `run` method, and whatever is within
    it will work in a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: Then we created a new `Thread` object called `ourThread`, and a `SurfaceHolder`
    object to hold our surface and enable us to control or lock our surface for use
    within our thread. Next, we have `playingSquash` of the `boolean` type. This wraps
    the inside of our overridden `run` method to control when the game is running.
    The odd-looking `volatile` modifier means that we will be able to change its value
    from the outside and inside of our thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, for the currently discussed block of code, we declare an object of
    the `Paint` type, called `paint`, to do our painting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we implemented the constructor of our class, so that when we initialized
    a new `SquashCourtView` object back in `onCreate`, this is the code that runs.
    First, we see that we run the constructor of the superclass. Then we initialize
    `ourHolder` using the `getHolder` method. Next, we initialize our `paint` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, still within the constructor, we get things moving. We set our `ballIsMovingDown`
    variable to `true`. At the start of each game, we always want the ball to be moving
    down. We will see soon that the `updateCourt` method will perform the ball movement.
    Next, we send the ball in a random horizontal direction. This is achieved by getting
    a random number between 0 and 2\. We then switch for each possible case: 0, 1,
    or 2\. In each case statement, we set the Boolean variables that control horizontal
    movement differently. In `case 0`, the ball moves left, and in `case 1` and `case
    3`, the ball will move right and straight down, respectively. Then we close our
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 2, we have some really simple code, but this is the code that runs
    everything else. The overridden `run` method is what `ourThread` calls at defined
    intervals. As you can see, the code is wrapped in a `while` block controlled by
    our `playingSquash` variable of the `boolean` type. Then the code simply calls
    `updateCourt`, which controls movement and collision detection; `drawCourt`, which
    will draw everything; and `controlFPS`, which will lock our game to a consistent
    frame rate. That''s it for `run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in step 3, we begin the `updateCourt` method. It was quite long, so we
    broke it down into a few manageable chunks. The first two `if` blocks check to
    see whether either the `racketIsMovingRight` or the `racketIsMovingLeft` Boolean
    variables is true. If one of them is true, the blocks add `10` to or subtract
    `10` from `racketPosition.x`. The effect of this will be seen by the player when
    the racket is drawn in the `drawCourt` method. How the Boolean variables are manipulated
    in the `onTouchEvent` method will be discussed soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, still in the `updateCourt` method, we detect and handle collisions with
    the left and right side of the screen. Checking whether `ballPosition.x` is larger
    than `screenWidth` would be enough to see whether the ball bounces back the other
    way. However, by being a bit more precise and testing for `ballPosition.x + ballWidth
    > screenWidth`, we are testing whether the right edge of the ball hits the right
    side of the screen. This creates a much more pleasing effect as it looks more
    *real*. When a collision occurs with the right side, we simply reverse the direction
    of our ball and play a sound. The reason that the `if` code for the left-side
    detection is simpler is because we have drawn the ball using `drawRect`, so `ballPosition.x`
    is the precise left side of the ball. When the ball collides with the left side,
    we simply reverse its direction and play a beep sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 4, we implemented what happens when the ball hits the bottom of the
    screen. This occurs when the player fails to return the ball, so a fair few things
    need to happen here. However, there is nothing overly complicated in this section.
    First comes the collision test. We check whether the underside of the ball has
    hit the bottom of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'If it has hit, we deduct a life. Then we check whether the player has lost
    all their lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: 'If all lives are lost, we start the game again by resetting lives to 3 and
    score to 0\. We also play a low beep sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'As of now, we are still within the `if` block because the ball hit the bottom
    of the screen, but outside the `if` block for the player who has zero lives. Whether
    the player has zero lives or still has some lives left, we need to put the ball
    back at the top of the screen and send it in a downward trajectory and a random
    horizontal direction. This code is similar to but not the same as the code we
    have seen in the constructor to start the ball moving at the beginning of the
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 5, we handle the event of the ball hitting the top of the screen. Reverse
    the values held by `ballIsMovingDown` and `ballIsMovingUp` to reverse the direction
    of the ball. Tweak the ball position with `ballPosition.y = 1`. This stops the
    ball from getting stuck and plays a nice beep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after all this collision detection and switching around of our Boolean
    variables, we actually move the ball. For each direction that is true, we add
    to or subtract from the `ballPosition.x` and `ballPosition.y` accordingly. Notice
    that the ball travels up faster than it travels down. This is done to shorten
    the time the player is waiting to get back into the action, and also crudely simulates
    the act of acceleration after the ball is hit by the racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that by hardcoding the number of pixels the ball moves,
    we create an inconsistent speed for the ball between high-resolution and low-resolution
    screens. Take a look at the self-test questions at the end of the chapter to see
    how we can solve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one last bit of collision detection to do. Has the ball hit the racket?
    This detection is done in a couple of stages. First, we check whether the underside
    of the ball has reached or gone past the top side of the racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'If this condition is true, we perform some more tests. First, we declare and
    initialize an `int` variable called `halfRacket` to hold half the width of the
    racket. We will use this in the upcoming tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'The next `if` block checks whether the right-hand side of the ball is greater
    than the far left corner of the racket, and whether it is touching it. Using the
    AND operator (`&&`), the block verifies that the ball''s left edge is not past
    the far right of the racket. If this condition is true, we definitely have a hit
    and can think about how to handle the rebound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'The first bit of code inside the `if` block, which determined a definite hit,
    is simple. Play a sound, increase the score, and set the ball on an upwards trajectory,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an `if`-`else` condition, which simply checks whether the left-hand
    edge of the ball is past the center of the racket. If it is, we send the ball
    to the right. Otherwise, we send the ball to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Phase 3 – SquashCourtView part 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this phase, we will complete our `SquashCourtView` class. There are two
    methods remaining that are called from the `run` method, `drawCourt` and `controlFPS`.
    Then there are a few short methods to interact with the Android lifecycle methods
    that we will implement in the fourth and final phase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that draws, in the following order, the text at the top of
    the screen, the ball, and the bat. All is contained within the `drawCourt` method,
    which is called from the `run` method, right after the call to `updateCourt`.
    Here is the code for `drawCourt`. Type the following code before the closing curly
    brace of the `SquashCourtView` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now the `controlFPS` method locks our frame rate to something smooth and
    consistent. We will soon go through its exact working. Type the following code
    after the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we write the code for `pause` and `resume`. These are called by their
    related Android lifecycle methods (`onPause` and `onResume`). We ensure that our
    thread is ended or started safely when the player has finished or resumed our
    game, respectively. Now type this code after the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have the method that controls what happens when the player touches
    our customized `SurfaceView`. Remember that when we discussed the design of the
    game, we said that a press anywhere on the left of the screen would move the racket
    to the left, and a press anywhere on the right will move the racket to the right.
    Type the following code after the code in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Phase 3 code explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In step 1, we do all the drawing. We have seen what all the different drawing
    methods of the `Canvas` class can do, and their names are self-explanatory as
    well. However, the manner in which we arrived at the coordinates needs some explanation.
    First, inside `drawCourt`, we use `ourHolder` to get a drawing surface, and we
    check its validity (usability). Then we initialize our `canvas` and `paint` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we clear the screen from the previous frame of drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set the paint color to white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'This is new but simple to explain—we set a size for our text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can draw a line of text at the top of the screen. It shows the `score`
    and `lives` variables. We have already seen how to control their values. It also
    shows the value of the `fps` variable. We will see how we can assign a value to
    that when we look at the next method, `controlFPS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we draw the racket. Notice that we calculate the `x` start position by
    subtracting half the racket width from `racketPosition.x`, and the `x` end position
    by adding the width to `x`. This makes our collision detection code simple because
    `racketPosition.x` refers to the center of the racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we draw the ball. Notice that the starting *x* and *y* coordinates are
    the same as the values held in `ballPosition.x` and `ballPosition.y`. Therefore,
    these coordinates correspond to the top-left corner of the ball. This is just
    what we need for our simple collision detection code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'This final line draws what we have just done to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: In step 2, we essentially pause the game. We want to decide the number of times
    we recalculate the position of our objects and redraw them. Here is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we enter the `controlFPS` method when it is called from the `run` method.
    We declare and initialize a `long` variable with the time in milliseconds, and
    then take away the time that the last frame took in milliseconds. The time is
    calculated in the previous run through this method, at the end, as we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'We then calculate how long we want to pause between frames, and initialize
    that value to `timeToSleep`, a new long variable. Here is how the calculation
    works: 15 milliseconds of pause gives us around 60 frames per second, which works
    well for our game and provides a very smooth animation. Therefore, `15 - timeThisFrame`
    equals the number of milliseconds we should pause for to make the frame last for
    15 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, some devices will not cope with this speed. Neither do we want to
    pause for a negative number, nor do we want to calculate the frames per second
    when `timeThisFrame` is equal to zero. Next, we wrap the calculation of frames
    per second within an `if` statement that prevents us from dividing by zero or
    a negative number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we wrap the instruction to our thread to pause within a similar cautionary
    `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we see how we initialize `lastFrameTime`, ready for the next time
    `controlFPS` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 3, we quickly implement two methods. They are `pause` and `resume`.
    These are not to be confused with the Android Activity lifecycle methods called
    `onPause` and `onResume`. However, the `pause` and `resume` methods are called
    from their near-namesakes. They handle stopping and starting `ourThread`, respectively.
    We should always clean up our threads. Otherwise, they can keep running even after
    the activity has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: In step 4, we handle touches on the screen. This is how we initialize our `racketIsMovingLeft`
    and `racketIsMovingRight` Boolean variables, which the `updateCourt` method uses
    to decide whether to slide the player's racket left or right, or to keep it still.
    We have talked about the `onTouchEvent` method before, but let's see how we set
    the values in those variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we override the method and switch to get the type of event and the *x*,
    *y* coordinates of the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'If the event type is `ACTION_DOWN`, that is, the screen has been touched, we
    enter this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we handle the coordinates. If the player has touched a position on the
    screen with an x coordinate greater than `screenWidth / 2`, then it means they
    have touched the right-hand side of the screen, so we set `isMovingRight` to `true`
    and `isMovingLeft` to `false`. The `updateCourt` method will handle changes in
    the necessary coordinates, and the `drawCourt` method will draw the racket in
    the appropriate place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: 'The `else` statement sets our two Boolean variables in the opposite manner
    because a touch must have occurred on the left of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we handle the case for the `ACTION_UP` event. But why do we care about
    two events? With the buttons, we just cared about a click and that was all, but
    by handling the `ACTION_UP` event, we can enable the functionality that allows
    our player to hold the screen to slide left or right, just as we discussed in
    the section *The design of the game* of this chapter. Thus, the `ACTION_DOWN`
    case sets the racket moving one way or the other, and the `ACTION_UP` case simply
    stops the slide completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we don't care about the *y* coordinate. Anywhere on the left we
    go left, anywhere on the right we go right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice also that all of the code will work whether a device is held in the portrait
    or landscape form, and will function the same regardless of the resolution of
    the device. However (and it is quite an important "however"), the game will be
    slightly harder on low-resolution screens. The solution to this problem is quite
    complicated and will not be discussed until the final chapter, but it might well
    help us make some decisions about the future path to learn Android, gaming, and
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 4 – Remaining lifecycle methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are nearly there; just a few more steps and we will have a working retro
    squash game. I can almost smell the nostalgia! As these remaining methods are
    quite straightforward, we will explain them as we write them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we previously learned, the `onStop` method is called by the Android system
    when the app is stopped. It is implemented for us already. The only reason we
    override it here is to ensure that our thread is stopped. We do so with the line
    highlighted. Enter the following code before the closing curly brace of the `MainActivity`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `onPause` method is called by the Android system when the app is paused.
    This too is implemented for us already, and the only reason we override it here
    is to ensure that our thread is stopped. We do so with the line highlighted. Enter
    this code after the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `onResume` method is called by the Android system when the app is resumed.
    Again, this method is implemented for us already. The only reason we override
    it here is to ensure that our thread is resumed, and we do so with the line highlighted.
    Enter the following code after the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we do something completely new. We handle what happens should the
    player press the back button on their device. As you might have guessed, there
    is a method we can override to achieve this— `onKeyDown`. We pause our thread,
    just as we did in the overridden lifecycle methods, and then call `finish()`,
    which ends the activity and our app. Enter this code after the code in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We covered the code in this phase as we went through it, and this was the shortest
    phase so far. So why didn't we encapsulate everything?
  prefs: []
  type: TYPE_NORMAL
- en: Good object-oriented design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps simple games are not the best way to demonstrate good object-oriented
    design in action, but a simple code design with fewer private variables actually
    enhances the project. It certainly makes the teaching aspects of coding games
    simpler to explain.
  prefs: []
  type: TYPE_NORMAL
- en: However, when a game becomes more complex and more people work on the code,
    principles of object-oriented programming become more necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) Can you explain how to make ball speed relative between different screen
    resolutions?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you enjoyed animating your first game. You achieved a lot to get to this
    point. You learned not only all the Java topics but also the way the different
    classes of Android can be used to make games relatively simple.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to a new, more complex game. I hope you
    are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. The Snake Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get straight down to designing and implementing a clone
    of the highly addictive *Snake* game. We will look at the design of the game and
    learn how to animate some bitmaps. Then we will look at a few aspects of the code
    that are new, such as our coordinate system. After that, we will whiz through
    the implementation of the game. Finally, we will look at how we could enhance
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the design of our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the coordinate system of our *Snake* game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the code structure so that when we come to implement the game, it will
    be more straightforward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about animation with sprite sheets at the same time as implementing the
    home screen of our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break the code for the *Snake* game into manageable chunks and run through its
    full implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance the game a little
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you haven''t played the excellent *Snake* game before, here is an explanation
    of how it works. You control a very small snake. In our version, there is just
    a head, one body segment, and a tail. Here is a screenshot of our snake, made
    out of three segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the three segments individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, here is the thing; our snake is very hungry and also a very quick grower.
    Every time he eats an apple, he grows a body segment. This is a screenshot of
    the apple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Life is great! Our snake just eats and grows! The problem that the player of
    our game needs to solve is that the snake is a little hyperactive. It never stops
    moving! What exacerbates this problem is that if the snake touches the side of
    the screen, it dies.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, this doesn''t seem like too much of a problem, but as he grows longer
    and longer, he can''t just keep going around in circles because he will bump inevitably
    into himself. This would again result in his demise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For each apple eaten, we add an increasingly large amount to the score. Here
    is a sneak peek at what the game will look like after the basic implementation
    and before the enhancements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The player controls the snake by tapping on the left or the right side of the
    screen. The snake will respond by turning left or right. The turn directions are
    relative to the direction the snake is traveling, which adds to the challenge
    because the player needs to think like a snake—kind of!
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will also take a brief look at enhancing the game,
    use that enhanced version in the next chapter to publish it to the Google Play
    Store, and add leaderboards and achievements.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we drew all our game objects directly to points on
    the screen, and we used real screen coordinates to detect collisions, bounces,
    and so on. This time, we will be doing things slightly differently. This is partly
    out of necessity, but as we will see, collision detection and keeping track of
    our game objects will also get simpler. This might be surprising when we think
    about the potential of our snake to be many blocks long.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of the snake segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep track of all the snake segments, we will first define a block size
    to define a portion of a grid for the entire game area. Every game object will
    reside at an (x,y) coordinate, based not on the pixel resolution of the screen
    but on a position within our virtual grid. In the game, we define a grid that
    is 40 blocks wide, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'So we know that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'The height of the game screen in blocks will then simply be calculated by dividing
    the height of the screen in pixels by the previously determined value of `blockSize`
    minus a bit of space at the top for the score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'This then allows us to keep track of our snake using two arrays for *x* and
    *y* coordinates, where element zero is the head and the last used element is the
    tail, a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as we have a system for moving the head, perhaps something similar
    to the squash ball but based on our new game grid, we can do the following to
    make the body follow the head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: The previous code simply starts at the back section of the snake and creates
    its location in the grid irrespective of what the section in front of it was.
    It proceeds up the body doing the same until everything has been moved to the
    location of the section that used to be just ahead of it.
  prefs: []
  type: TYPE_NORMAL
- en: This also makes collision detection (even for a very long snake) nice and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using our grid based on `blockSize`, we can detect a collision, for example,
    with the right side of the screen, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: The previous code simply checks whether the first element of our array, which
    holds the *x* coordinate of the snake, is equal to or greater than the width of
    our game grid in blocks. Try to work out the code for collision with the left,
    top, and bottom before we see it during the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detecting the event of the snake bumping into itself is quick too. We just
    need to check whether the first element of our array (the head) is in exactly
    the same position as any of the other sections, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the snake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We simply draw every section of the snake relative to its grid location multiplied
    by the size in pixels of a block. The `blockSize` variable handles the entire
    challenge of making the game work on different screen sizes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, there are probably more questions about how our implementation will
    work, but they are probably best answered by actually building the game.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can easily follow along by either writing the code or just reading
    from the completed project. Let's take a look at the overall structure of our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will have two activities, one for the menu screen and one for the game screen.
    The menu screen activity will be called `MainActivity`, and the game screen activity
    will be called `GameActivity`. You can find all the completed code files as well
    as all the assets such as images, sprite sheets, and sound files in the `Chapter8/Snake`
    folder in the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: MainActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast to our other projects, the menu screen will not have a UI designed
    in the Android Studio UI designer. It will consist of an animated snake head,
    a title, and a high score. The player will proceed to `GameActivity` by tapping
    anywhere on the screen. As we need to accomplish animations and user interactions,
    even the home screen will have a thread, a view object, and methods normally associated
    with our game screens, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: We will not go deeper into the menu screen for now because at the end of this
    section, we will implement it line by line.
  prefs: []
  type: TYPE_NORMAL
- en: GameActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game screen structure has many similarities to our Squash game and to the
    structure of the menu screen, although the internals of this structure vary a
    lot (as we have discussed and as we will see). There are some differences towards
    the end of the structure, most notably, a `loadSound` method and a `configureDisplay`
    method. Here is the structure (we will see afterwards why the two extra methods
    are there):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: Tidying up onCreate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the first things you might notice when you examine the code from the
    `GameActivity` class we will soon implement is just how short the `onCreate` method
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: We have written two methods, `loadSound` and `configureDisplay`. They do most
    of the initialization and setup present in our squash game. This makes our code
    less cluttered. All that is left in `onCreate` is the initialization of our `SnakeView`
    object and a call to `setContentView`.
  prefs: []
  type: TYPE_NORMAL
- en: We will look in detail at our `loadSound` and `configureDisplay` methods when
    we implement them.
  prefs: []
  type: TYPE_NORMAL
- en: As we have had advanced sight of the structure as well as previous experience
    of this type of implementation, we will just go through all of the implementation
    of our game activity in one phase.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly implement the menu screen.
  prefs: []
  type: TYPE_NORMAL
- en: Animation, sprite sheets, and the Snake home screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used a bitmap to draw text, a circle, a line, and
    a single pixel on the blank bitmap we created in Java code. We then displayed
    the bitmap with all of its doodling using the `Canvas` class. Now we will look
    at a technique to draw two dimensional images, sometimes referred to as sprites.
    These are made from predrawn images. The images can be as simple as a plain pong
    ball or as complex as a glorious two-dimensional character with muscle definition,
    elaborate clothing, weapons, and hair.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have animated with unchanging objects, that is, we have moved a static
    unchanging image around the screen. In this section, we will see how to not only
    display a predrawn bitmap image on the screen but also continually alter it to
    create the illusion of on-the-spot animation.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the ultimate combination would be to animate the bitmap both by changing
    its image and moving it around at the same time. We will see that briefly when
    we look at an enhanced version of this chapter's *Snake* game, but will not be
    analyzing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this on-the-spot bitmap animation, we need some bitmaps, as you might
    expect. For example, to draw a snake''s tail swishing back and forth, we would
    need at least two frames of animation, showing the tail in different positions.
    In the following screenshot, the flower''s head is towards the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, the flower has been flipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the two bitmaps were shown one after the other, repeatedly, they would create
    the basic effect of a flower blowing in the wind. Of course, two frames of animation
    aren't going to contest for any animation awards, and there is another problem
    with these images as well, as we will learn, so we should add in more frames to
    make the animation as life-like as is practical.
  prefs: []
  type: TYPE_NORMAL
- en: We have just one more thing to discuss before we make an animated snake head
    for our game's home screen. How do we get Android to switch between these bitmaps?
  prefs: []
  type: TYPE_NORMAL
- en: Animating with sprite sheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we need to present the frames in a manner that is easy to manipulate
    in code. This is where sprite sheets come in. The following image shows some frames
    from a basic snake head animation that we will use on our game home screen. This
    time, they are presented in a strip of frames. All of them are parts of the same
    image, a bit like a series of images in a film. Also, notice in the following
    image that the frames are centered relative to each other and are exactly equal
    in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating with sprite sheets](img/8859OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we were to actually show the two previous flower images consecutively, they
    would not only would they sway but also jump around from one side to another on
    their stems, which is probably not the effect we were looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, with regard to the snake sprite sheet, as long as we show one frame after
    another, we will create a basic animation.
  prefs: []
  type: TYPE_NORMAL
- en: So how do we make our code jump from one part of the sprite sheet to the next?
    Each frame is exactly the same size, 64 x 64 pixels in this case, so we just need
    a way to display pixels from 0 to 63, then 64 to 127, then 128 to 192, and so
    on. As each frame of the sprite sheet image is subtly different, it allows us
    to use one image file with multiple frames to create our animation. Fortunately,
    we have a class to handle this, which is nothing quite as luxurious as a specific
    sprite sheet class but almost.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regarding sprite sheet classes, such a thing does exist, although not in the
    regular Android classes. An API specifically designed for two-dimensional games
    will usually contain classes for sprite sheets. We will look at examples of this
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Rect` class holds the coordinates of a rectangle. Here, we create a new
    object of the `Rect` type, and initialize it to start at 0, 0 and end at 63, 63:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Canvas` class can then actually use our `Rect` object to define a portion
    of a previously loaded bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is much simpler than it looks. First, we see `canvas.drawBitmap`.
    We are using the `drawBitmap` method of the `Canvas` class just as we have before.
    Then we pass `headAnimBitmap`, which is our sprite sheet containing all the frames
    we want to animate, as an argument. Rect `rectToBeDrawn` represents the coordinates
    of the currently relevant frame within `headAnimationBitmap`. `destRect` simply
    represents the screen coordinates at which we want to draw the current frame,
    and of course, `paint` is our object of the `Paint` class.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do now is change the coordinates of `rectToBeDrawn` and control
    the frame rate with a thread and we are done! Let's do that and create an animated
    home screen for our *Snake* game.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Snake home screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the background information we just covered and our detailed look at the
    structure of the code we are about to write, there shouldn''t be any surprises
    in this code. We will break things up into chunks just to make sure we follow
    exactly what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project of API level 13\. Call it `Snake`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the activity full screen as we have done before, and put your graphics
    into the `drawable/mdpi` folder. Of course, you can use my graphics as usual.
    They are supplied in the code download in the `graphics` folder of the `Snake`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, you will find our `MainActivity` class declaration and member variables.
    Notice the variables for our `Canvas` and `Bitmap` class as well, we are declaring
    variables to hold frame size (width and height) as well as the number of frames.
    We also have a `Rect` object to hold the coordinates of the current frame of the
    sprite sheet. We will see these variables in action soon. Type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the implementation of the overridden `onCreate` method. We
    get the screen dimensions in the usual way. We load our sprite sheet into the
    `headAnimBitmap` Bitmap. Finally, we create a new `SnakeAnimView` and set it as
    the content view. Type the following code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the declaration of our `SurfaceView` class, called `SnakeAnimView`,
    along with its member variables. Notice that it extends `SurfaceView` and implements
    `Runnable`. All its methods follow in the next steps. Type this code after the
    code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the constructor that gets the `frameWidth` value by dividing the bitmap
    width by the number of frames, and the `frameHeight` value using the `getHeight`
    method. Type this code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we implement the short but crucial `run` method. It calls each of the key
    methods of this class one after the other. These three methods are implemented
    in the following three steps after this step. Type the following code after the
    code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the `update` method. It tracks and chooses the frame number that needs
    to be displayed. Each time through the `update` method, we calculate the coordinates
    of the sprite sheet to be drawn using `frameWidth`, `frameHeight`, and `frameNumber`.
    If you are wondering why we subtract `1` from each horizontal coordinate, it is
    because like the screen coordinates, bitmaps start their coordinates at 0, 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is the `draw` method, which does nothing new until the end, when it calculates
    the place on the screen to draw the bitmap by dividing the `screenHeight` and
    `screenWidth` variables by 2\. These coordinates are then saved in `destRect`.
    Both `destRect` and `rectToDraw` are then passed to the `drawBitmap` method, which
    draws the frame required at the location required. Type this code after the code
    from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our trusty old `controlFPS` method ensures that our animation appears at a
    sensible rate. The only change in this code is that the initialization of `timeTosleep`
    is changed to create a 500-millisecond pause between each frame. Type the following
    code after the code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next are our `pause` and `resume` methods, which work with the Android lifecycle
    methods to start and stop our thread. Type this code after the code from the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our `SnakeAnimView` class and our `onTouchEvent` method, which simply starts
    the game when the screen is touched anywhere, we enter the following code. Obviously,
    we don''t have a `GameActivity` yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, back in the `MainActivity` class, we handle some Android lifecycle
    methods. We also handle what happens when the player presses the back button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you must temporarily comment out this line from step 4 to test the animation.
    The reason for this is that it causes an error until we implement the `GameActivity`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment the line from step 14 when we have implemented the `GameActivity`
    class. Here is our completed home screen:![Implementing the Snake home screen](img/8859OS_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we set up a class that extended `SurfaceView`, just like we
    did for our squash game. We had a `run` method, which controlled the thread, as
    well as an `update` method, which calculated the coordinates of the current animation
    within our sprite sheet. The `draw` method simply drew to the screen using the
    coordinates calculated by the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: As in the squash game, we had an `onTouchUpdate` method, but the code this time
    was very simple. As a touch of any type in any location was all we needed to detect,
    we added just one line of code to the method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Snake game activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all of this code is new. In fact, we have either used most of it before
    or discussed it earlier in the chapter. However, I wanted to present every line
    to you in order and in context with at least a brief explanation, even when we
    have seen it before. Having said that, I haven't included the long list of imports
    as we will either be prompted to add them automatically or we can just press *Alt*
    + *Enter* when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we can remind ourselves how the whole thing comes together without
    any blanks in our understanding. As usual, I will summarize as we proceed through
    the implementation, and go into a few bits of extra depth at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an activity called `GameActivity`. Select a blank activity when asked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the activity full screen as we have done before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, create some sound effects or use mine. Create an `assets` directory
    in the `main` directory in the usual way. Copy and paste the sound files (`sample1.ogg`,
    `sample2.ogg`, `sample3.ogg`, and `sample4.ogg`) into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create individual non-sprite-sheet versions of graphics or use mine. Copy and
    paste them in the `res/drawable-mdpi` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the `GameActivity` class declaration with the member variables. There
    is nothing new here until we declare our arrays for our snake (`snakeX` and `snakeY`).
    Also, notice our variables used to control our game grid (`blockSize`, `numBlocksHigh`,
    and `numBlocksWide`). Now type this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As explained previously, our new, small `onCreate` method has very little to
    do because much of the work is done in the `loadSound` and `configureDisplay`
    methods. Type this code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the class declaration, member variables, and constructor for our `SnakeView`
    class. We allocate 200 `int` variables to the `snakeX` and `snakeY` arrays, and
    call the `getSnake` and `getApple` methods, which will place an apple and our
    snake on the screen. This is just what we want when the class is constructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is how we spawn a snake and an apple in our coordinate system. In the
    `getSnake` method, we place the snake''s head in the approximate center of the
    screen by initializing `snakeX[0]` and `snakeY[0]` to the number of blocks high
    and wide divided by 2\. We then place a body segment and the tail segment immediately
    behind. Notice that we don''t need to make any special arrangement for the different
    types of segments. As long as the drawing code *knows* that the first segment
    is a head, the last segment is a tail, and everything in between is a body, then
    that will do. In the `getApple` method, the integer variables `appleX` and `appleY`
    are initialized to random locations within our game grid. This method is called
    from the constructor, as we saw in the previous step. It will also be called to
    place a new apple every time our snake manages to eat an apple, as we will see.
    Type this code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next comes the `run` method, which controls the flow of the game. Type the
    following code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will look at `updateGame`, the most complex method of the entire app.
    Having said that, it is probably slightly less complex than the same method in
    our squash game. This is because of our coordinate system, which leads to simpler
    collision detection. Here is the code for `updateGame`. Study it carefully, and
    we will dissect it line by line at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have worked out where our game objects are on the screen, so now we can
    draw them. This code is easy to understand as we have seen most of it before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the `controlFPS` method, unchanged from our squash game''s `controlFPS`
    method, except that we have a different target frame rate. Type this code after
    the code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are our unchanged `pause` and `resume` methods. Type the following code
    after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we have the `onTouchEvent` method, similar to that of our squash game.
    There are no new concepts here, but the way it works in this game is as follows.
    We switch on the `ACTION_UP` event. This is broadly the same as detecting a click.
    We then check whether the press was on the left or the right. If it was on the
    right, we increment `directionOfTravel`. If it was on the left, we decrement `directionOfTravel`.
    If you looked carefully at the `updateGame` method, you would have seen that `directionOfTravel`
    indicates the direction in which to move the snake. Remember, the snake never
    stops. This is why we did it differently from our squash game. Type this code
    after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the `GameActivity` class, we now handle the Android lifecycle methods
    and the "back" button functionality. Type this code after the code from the preceding
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is our `loadSound` method, which simply tidies up the `onCreate` method
    by moving all of the sound initialization to here. Type this code after the code
    from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we have the `configureDisplay` method, which is called from `onCreate`
    and does the entire setup of bitmaps and screen size calculations. We will look
    at this in more detail later. Type the following code after the code from the
    previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run the app. The game is much more playable on an actual device than it
    is on the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We covered the code as we progressed, but as usual, here is a piece-by-piece
    dissection of a few of the more complicated methods, starting with the `updateGame`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check whether the player has eaten an apple. More specifically, is
    the snake''s head in the same grid location as the apple? The `if` statement checks
    whether this has occurred, and then does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Increases the length of the snake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puts another apple on the screen by calling `getApple`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a value to the player's score, relative to the length of the snake, making
    each apple worth more than the previous one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plays a beep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code for the actions that we have just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we simply move each segment of the snake, starting from the back, to the
    position of the segment in front of it. We do this with a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we better move the head too! We move the head last because the leading
    section of the body would move to the wrong place if we move the head earlier.
    As long as the entire move is made before any drawing is done, all will be well.
    Our `run` method ensures that this is always the case. Here is the code to move
    the head in the direction determined by `directionOfTravel`. As we saw, `directionOfTravel`
    is manipulated by the player in the `onTouchEvent` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check for a collision with a wall. We saw this code when we looked
    at collision detection earlier. Here is the complete solution, starting with the
    left wall, then right, then top, and then bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we check whether the snake has collided with itself. Initially, this seemed
    awkward, but as we previously saw, we just loop through our snake array to check
    whether any of the segments are in the same place as the head, in both *x* and
    *y* coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: 'If any part of our collision detection code sets `dead` to `true`, we simply
    play a sound, set the `score` to `0`, and get a new baby snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we take a closer look at the `drawGame` method. First, we get ready to
    draw by clearing the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we draw the text for the player''s score, just above `topGap` that we define
    in `configureDisplay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using `drawLine`, we draw a visible border around our game grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we draw the snake''s head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: 'The snake''s head will be followed by all the body segments. Look at the condition
    of the `for` loop. This starts at `1`, which means it is not redrawing the head
    position, and ends at `snakeLength - 1`, which means it is not drawing the tail
    segment. Here is the code used to draw the body section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we draw the tail of the snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we draw the apple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will go through the `configureDisplay` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the screen resolution and store the results in `screenWidth`
    and `screenHeight` as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a gap called `topGap`. It will be a space at the top of the
    screen and will not be a part of the game area. This gap is used for the score.
    We saw `topGap` used fairly extensively in the `drawGame` method. After this,
    we calculate the width and height of the remaining area in blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following part of the code, we load all our image files into `Bitmap`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we scale each bitmap to be the same width and height as `blockSize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Now we can take a quick look at a few different ways we can improve the game.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a series of questions and answers to lead us to an improved version
    of our *Snake* game. It doesn't matter if you can't answer some (or even all)
    of the questions. Just take a look at the questions and answers, after which you
    can take a look at the new game and the code.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What can be used to provide a visual improvement for our game screen? Can
    we use a nice light green, grassy background instead of just black?
  prefs: []
  type: TYPE_NORMAL
- en: Q2) How about some nice flowers?
  prefs: []
  type: TYPE_NORMAL
- en: Q3) If you're feeling brave, make the flowers sway. Think about what we have
    learned about sprite sheets. The theory is exactly the same as that of the animated
    snake head. We just need a few lines of code to control the frame rate separately
    from the game frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Q4) We could set up another counter and use our snake head animation in `GameActivity`,
    but it wouldn't be that useful because the subtle tongue movements would be barely
    visible at the smaller size. But could we swish the tail segment?
  prefs: []
  type: TYPE_NORMAL
- en: Q5) Here is a slightly trickier enhancement. You can't help notice that when
    the snake sprites are headed in three out of the four possible directions, they
    don't look right. Can you fix this?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the end of yet another successful game project. You now know how to
    create and animate sprite sheets to add more realism to our games. Now we have
    an enhanced *Snake* game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how simple it is to add leaderboards and achievements.
    This will make our game social and compelling by letting the player see the high
    scores and achievements of their friends and compare them with their own.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Making Your Game the Next Big Thing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The day has finally come when we can publish our first game. This chapter, despite
    being shorter than others, is probably the longest chapter to complete. It would
    be a good idea to scan through the different exercises to see what is involved
    before actually diving into them. Most of these tutorials are not suitable to
    do during the advertisements of your favorite TV program or when you get in from
    work and you are really tired.
  prefs: []
  type: TYPE_NORMAL
- en: Read the chapter and make a plan of when to perform each stage. The stages are
    arranged so you should be able to leave the project in between each of them. If
    you are really determined, have understood all the code until now, are confident
    with files and folders, and have no interruptions, you can probably get the work
    in this chapter completed in about a day.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the completed code is in the relevant folder in the download bundle,
    in this case the `Chapter9` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that because I cannot share the login credentials for my developer account,
    had to mask some ID numbers within the code with a series of black lines. You
    will see these in the code in this chapter when talking about the `ids.xml` file
    which is NOT in the code bundle because of its confidential nature. However, as
    you will see in the *Setting up the Snake project ready for implementation* section,
    it is easy to get your own ID codes. Also note that a lot of the work in this
    chapter involves set up that takes place in your developer console. The leaderboards
    and achievements will not function until you have completed the necessary steps.
    However, you can review the entire code in the `Chapter9` folder and download
    the enhanced version of the game from [Chapter 8](ch08.html "Chapter 8. The Snake
    Game"), *The Snake Game*, complete with working leaderboards and achievements
    from [Chapter 9](ch09.html "Chapter 9. Making Your Game the Next Big Thing"),
    *Making Your Game the Next Big Thing*, from [https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to implement everything yourself and also want to start with the
    enhanced version of the game, including all the improvements from the self-test
    questions from the previous chapter, then grab the `EnhancedSnakeGame` code from
    the `Chapter8` folder, and update your working project from `Chapter8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to publish your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marketing your app, including making it social with leaderboards and public
    achievements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing leaderboards and achievements with the Google Play Game Services
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at what to do next depending on what you want to achieve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to publish your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the steps in this guide involve writing descriptions and supplying
    screenshots, so you might like to read through the entire guide before implementing
    any of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an icon. Exactly how to design an icon is beyond the scope of this book,
    but simply put, you need to create a nice image for each of the Android screen
    density categories. This is easier than it sounds. Using a simple image, such
    as the snake head bitmap, you can customize and download a set from [http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html](http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html).
    There are many sites that offer a similar free service. Of course, you can just
    use the images in the enhanced snake project, and skip this step and the next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have downloaded your `.zip` file from the preceding link, you can simply
    copy the `res` folder from within the download to the `main` folder within the
    project explorer. All icons at all densities will now be updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we proceed further, optionally you will need to prepare some screenshots
    of the game. You will be prompted to upload a screenshot for several screen types,
    but since the game is nearly identical on all screen types, one image should do
    fine. You will also need an image of dimension 512 x 512 for a high-resolution
    icon and an image of dimension 1024 x 500 for a feature graphic. They don't need
    to be great, but you do need them to proceed. Create your own or grab a copy of
    my very simple graphics in the `Chapter9` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, unfortunately, you will need to spend $ 25 to open a Google Play account.
    You can sign up at [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have signed up, you can log in to your developer console at the same
    URL as mentioned in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once in your console, click on the **+ Add new application** button:![How to
    publish your app](img/8859OS_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add New Application** dialog, type a name for your application, such
    as `Snake Game`. Now click on **Upload APK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to make our app into the release version. Open the `AndroidManifest.xml`
    file and add the highlighted line of code in the location shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rebuild your signed APK for the latest version of the *Snake* game, as discussed
    in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on **Upload your first APK to production**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to your Snake game APK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the APK to finish uploading. You can now see your game summary screen.
    Notice the highlighted progress indicator to the top-left corner of the next image.
    We have a green tick, indicating that the APK has been uploaded successfully:![How
    to publish your app](img/8859OS_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we need to do is configure our Store Listing, so click on the
    **Store Listing** link, just below the APK link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short description and a long description. Also upload your screenshots,
    feature graphics, and high-resolution icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Application Type** drop-down menu, select **Games**. In the **Category**
    drop-down menu, **Arcade** is probably most appropriate. For **Content Rating**,
    select **Everyone**, and for **Privacy Policy**, click on the checkbox for **Not
    submitting a privacy policy at this time**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your website and email address to the relevant boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back at the top of the web page, click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we are at the final stage of this guide. Click on the **Pricing and distribution**
    link. It is just underneath the **Store Listing** link from step 13.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Free** button at the top of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the checkbox of all the countries you want your game to be listed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the bottom of the page and click on the checkboxes for **Content
    guidelines** and **US Export laws**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save** at the top of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, from the **Ready to publish** drop-down menu at the top right corner
    of the page, click on **Publish this app** and you are done.![How to publish your
    app](img/88590S_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! Your game will be live on Google Play somewhere between the
    next 5 minutes and 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Marketing your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The temptation at this stage is to sit back and wait for our game to hit the
    top position in the best-selling apps. This never happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that our app achieves its full potential, we need to do the following
    continuously:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improve it**'
  prefs: []
  type: TYPE_NORMAL
- en: We have already made quite a few improvements to the *Snake* game but there
    are many more, such as difficulty settings, music, debugging (did you see the
    occasionally wonky body segments?), settings menu, and so on. You can pay a professional
    to design backgrounds and sprites, or add more sound effects. When you have improved
    your Android and Java skills further, you can rewrite the entire game using a
    smoother engine and call it Version 2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Promote it**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This could be the subject of another book but there are so many ways we can
    spread the word about our app. We can create a page/profile on all the social
    media sites—Facebook, Twitter, Flickr, and so on. Add regular updates, announcements,
    challenges (see compulsion). We can create a website to promote our app and promote
    it in all the ways we would promote any other website. We can add a message in
    the app itself asking players to rate it, perhaps pop up a message just after
    they have got a high score or achievement. We can ask everyone we know and everyone
    who visits our social media/website to give a rating and leave a review. There
    are many more ways to promote an app as well. The secret to all of them is this:
    keep doing it. For example, don''t create a Facebook page and then expect it to
    grow in popularity on its own. Keep adding to all of your channels of promotion.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep the players'' level of compulsion**'
  prefs: []
  type: TYPE_NORMAL
- en: Besides improving the game in the ways we have briefly mentioned, we need to
    give players a compelling reason to keep coming back to our game. One way might
    be to add new levels. For example, it won't be hard to implement levels in our
    *Snake* game. Each level could have walls in different places and the layouts
    could get progressively more challenging. All we would need to do is make an array
    of obstacles, draw them on the screen, and detect collisions. Then set a target
    for the snake length for each level and move on to the next level when it is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: We could offer different snake designs to be be unlocked for certain challenges.
    How about the player saving all the apples they collect as a form of currency,
    and then strategically spending that currency to get a chance to continue after
    they have died?
  prefs: []
  type: TYPE_NORMAL
- en: How about offering time-limited challenges? For example, complete level 10 by
    the end of the month to receive a thousand bonus apples. Perhaps, we could come
    up with more things the apples could be spent on. Cool snake accessories or levels
    that can only be unlocked with apples. The point is that all of this compulsion
    can be added and updated at the same time as we upload our improvements. Nothing
    mentioned in this discussion about compulsion would be unachievable with the skills
    we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Probably, the most compelling aspect we can add to our game is online leaderboards
    and achievements so that players can compare themselves to their friends and the
    rest of the world. Google is aware of this and have done a lot of work to make
    it as easy as possible to add leaderboards and achievements to games. We will
    see how we can yet again take advantage of other people's hard work.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s more, all the achievements that players of your game earn are fed into
    their overall Google Play profile. Here is a screenshot of my rather poor Google
    Play achievements profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Marketing your app](img/88590S_09_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might have noticed a few *Snake* achievements in that lot. This feature
    makes your game potentially even more compelling.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's do a quick reality check—I am not actually suggesting that you spend significant
    amounts of time trying to make a real business out of our humble Snake game. It
    just serves as a useful example for discussion. Also, if we can come up with so
    many ideas for a game this old and simple, then we can surely come up with some
    really amazing stuff for a game we are passionate about. When you have an idea
    you are passionate about, then that would be the time to go for it and expand
    the brief marketing plan we have discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding leaderboards and achievements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we know why leaderboards and achievements are a good thing. The first thing
    we need to do here is plan our achievements. A leaderboard is a high score table,
    and that's it! There isn't a great deal of things we can do to make them different.
    The achievements, however, deserve some discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the Snake achievements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first, it might seem that a really simple implementation of a really simple
    game, like our *Snake* game, isn''t deep enough to have many, or even any, achievements.
    So what follows is a quick brainstorming session of achievement ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Score 10, 25, 50, 100, and so on**: Simply unlock achievements at different
    levels of high score.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snake length**: Simply unlock achievements at different snake lengths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cannibal**: Unlock an achievement the first time the player collides with
    their own tail segment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collect x apples in total**: Keep a tally of all the apples ever collected,
    and unlock achievements at significant milestones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play 10, 25, 50, 100 games**: Reward the player for keeping on going. Whether
    they win or lose, achievements are unlocked for effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Treasure hunt**: What if there was a hidden spot in every game? It could
    give the player a reason to explore each level. They could be rewarded with points
    and apples. They could then unlock real achievements, perhaps for every 5, 10,
    or 20 hidden spots that they find.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the achievements suggest that we would be required to keep a record
    of the player's progress. Surprisingly, Google Play Game Services can actually
    do this for us. These are known as incremental achievements. The number of apples
    collected in total is a good example of an incremental achievement. Others, such
    as snake length, are just dependent on the player's performance in any one game.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement the total number of apples and the snake length achievements
    so that we can see how to implement both types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have five achievements for reaching each of the following snake lengths:
    5, 10, 20, 35, and 50\. There can also be five incremental achievements for the
    total number of apples collected. Specifically, the player will get an achievement
    at 10, 25, 50, 100, 150, and 250 apples collected. Soon, we will see how to do
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to decide how many points each achievement will be worth,
    out of the 1,000-point limit per game. As I might come back and add some more
    achievements later I am going to allocate 250 points to the apples'' achievements,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Number of eaten apples | Achievement points |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 40 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 70 |'
  prefs: []
  type: TYPE_TB
- en: '| 250 | 100 |'
  prefs: []
  type: TYPE_TB
- en: 'I will also allocate 250 points to the snake length achievements, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Length of snake | Achievement points |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | 40 |'
  prefs: []
  type: TYPE_TB
- en: '| 35 | 70 |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 100 |'
  prefs: []
  type: TYPE_TB
- en: Once you see how to implement these achievements in both the code and the developer
    console, it will be fairly simple to design and implement your own different achievements.
  prefs: []
  type: TYPE_NORMAL
- en: Step-by-step leaderboards and achievements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably the longest part of the book to complete. However, once you
    have been through this process, it will be significantly easier the next time
    you do it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Google Play Services API on your PC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need to add the tools and the libraries needed to use the Game Services
    classes. This is nice and easy with Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the SDK Manager icon in the Android Studio toolbar:![Installing the
    Google Play Services API on your PC](img/88590S_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SDK manager will start. It looks a bit like this:![Installing the Google
    Play Services API on your PC](img/88590S_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll to the very bottom and underneath **Extras**, you will see **Google Play
    Services**. Check the box that is shown as highlighted in the following screenshot
    by clicking on it:![Installing the Google Play Services API on your PC](img/88590S_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the checkbox for **Google Repository**, just below **Google Play
    Services**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Install packages** and wait for the packages to download and install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project and restart Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the tools installed to start developing Google Play Game Services
    apps. Next, we need to set up our developer console to communicate with our app,
    ready for the features we will soon write code for.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Google Play developer console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we will prepare your developer console by creating a new Game Services
    application. This might sound a little counterintuitive; surely, Snake is our
    application, isn''t it? Yes, but Google Play is structured in such a way that
    you create a Game Services application, and it is with this application that your
    actual games (Snake in this case) will communicate. It is the Game Services application
    that will have the achievements and leaderboards that we will award and display
    from our Snake Game:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your Google Play developer console at [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Game services** tab on the left of the web page.![Configuring
    the Google Play developer console](img/88590S_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the **Add a new game** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Snake` as the name of your game and choose **Arcade** from the **Category**
    drop-down menu. Now click on **Continue**. All of this is shown in the next screenshot:![Configuring
    the Google Play developer console](img/88590S_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can configure our game. Type a game description in the **Description**
    field, and add the same high-resolution icon and feature graphic that we added
    when we uploaded the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button at the top of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will link our Snake Game Services app with our actual *Snake* game. On
    the left of the web page, click on the **Linked apps** tab.![Configuring the Google
    Play developer console](img/88590S_09_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Google Play Game Services can be used with almost any platform, even Apple.
    We are using it for Android here, so click on the **Android** button.![Configuring
    the Google Play developer console](img/88590S_09_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All we need to do on this screen is click on the **Package Name** search box
    and click on our **Snake game** option.![Configuring the Google Play developer
    console](img/88590S_09_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save and continue** at the top of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're nearing the end of this phase. Click on **Authorize your app now** and
    review the information.![Configuring the Google Play developer console](img/88590S_09_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on **Continue**.![Configuring the Google Play developer console](img/88590S_09_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a Google Game Services app set up, and linked to our *Snake* game.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the leaderboard in the Google Play developer console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to create our leaderboard in our developer console so that we can
    later interact with it in our Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your developer console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Game Services**, then on **Snake**, and then on **Leaderboards**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on **Add Leaderboard**. This is the **NEW LEADERBOARD** screen:![Implementing
    the leaderboard in the Google Play developer console](img/88590S_09_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This might look like a bit of a marathon ahead, but all we need to do is enter
    a name (`Snake` will do) in the **Name** field, and we are done. It might seem
    strange entering a name for our leaderboard, but this is because it is possible
    to have multiple leaderboards for one game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read through all the options. You will see that they are just right for us and
    no further action is required. Click on **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our leaderboard is now ready to communicate with our *Snake* app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the achievements in the Google Play developer console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will set up in our developer console the achievements that we discussed
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might like to prepare some graphics to represent each of these achievements.
    They need to be 512 x 512 pixels each. Alternatively, you can use an enlarged
    apple bitmap and perhaps a snake body segment for the apples and snake length
    achievements, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your developer console. Click on **Game Services**, then on **Snake**,
    and then on **Achievements**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add Achievement** and you will see the **New Achievement** screen:![Implementing
    the achievements in the Google Play developer console](img/88590S_09_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are implementing the incremental apple achievements, the first thing to
    do is to enter something in the **New Achievement** form. In the **Name** field,
    enter `Apple Muncher 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Description** field, enter `Munch 10 apples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add Icon** button and select your preferred 512 x 512 graphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Incremental achievements** checkbox and enter `5` in the **How
    many steps are needed** field. This is because the first achievement is for eating
    5 apples. This step is shown in the next screenshot:![Implementing the achievements
    in the Google Play developer console](img/88590S_09_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `10` for the number of achievement points in the **Points** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save** and repeat steps 2 to 7 four more times for all the apple
    achievements, varying the **Name**, **Description**, **How many steps are needed?**,
    and **Points** fields as per our plans and tables of values for achievements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can move on to our snake length achievements. Click on **New Achievement**.
    In the **Name** field, enter `Super Snake 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Description** field, enter `Grow your snake to 5 segments`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add Icon** button and browse to your preferred image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, enter `10` for the number of achievement points in the **Points** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save** and repeat steps 9 to 13 four more times for each of the snake
    length achievements, varying the **Name**, **Description**, and **Points** fields
    as per our plans and tables of values for achievements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now set up our achievements, ready to be implemented in code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Snake project ready for implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we will do in this section is prepare our app to communicate with the
    Google Play servers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `AndroidManifest.xml` file, just before the
    closing `</application>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `ids.xml` file in the `values` folder in the Project Explorer. Now
    you need to get your unique code for your game to go to this file. Log in to your
    developer console, click on **Game Services**, and then click on **Snake**. Now
    click on **Achievements**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just below your list of achievements is a small **Get resources** link:![Setting
    up the Snake project ready for implementation](img/88590S_09_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Get resources** link.![Setting up the Snake project ready for
    implementation](img/88590S_09_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the code into the `ids.xml` file. Then click on the **Finished**
    button in the developer console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to get four code files from the Google Play Game Services GitHub
    repository. We will copy and paste the files directly into our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three new empty files in the `java` folder. Right-click on **GameActivity**
    in the project explorer and navigate to **New** | **Java class file**. Name the
    new file `BaseGameActivity`. Repeat this step and name the file `GameHelper`.
    Repeat this once more and name the file `GameHelperUtils`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will get the Java code to copy into the three files we just made. To
    get the code for `BaseGameActivity.java`, visit [https://github.com/playgameservices/android-basic-samples/tree/master/BasicSamples/libraries/BaseGameUtils/src/main/java/com/google/example/games/basegameutils](https://github.com/playgameservices/android-basic-samples/tree/master/BasicSamples/libraries/BaseGameUtils/src/main/java/com/google/example/games/basegameutils),
    where you can see further links to the code for the three files we created in
    step 7:![Setting up the Snake project ready for implementation](img/88590S_09_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **BaseGameActivity.java** as shown in the preceding screenshot. Select
    all of the code and copy and paste it into the identically named file that we
    created in Android Studio. Note that when we created the file, Android Studio
    created some basic template code. We need to delete all of this, except our package
    name at the top. When we paste in the copied code, we need to delete the Google
    package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **GameHelper.java**, as shown in the previous screenshot, and repeat
    step 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **GameHelperUtils.java**, as shown in the preceding screenshot, and
    repeat step 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's one more file to create. Right-click on the **values** folder in the
    project explorer. Navigate to **New** | **File**. Name the file `gamehelper_strings.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the code that we need for this file in the same way as we did for the previous
    three Java files from but from this link: [https://github.com/playgameservices/android-basic-samples/blob/master/BasicSamples/libraries/BaseGameUtils/src/main/res/values/gamehelper_strings.xml](https://github.com/playgameservices/android-basic-samples/blob/master/BasicSamples/libraries/BaseGameUtils/src/main/res/values/gamehelper_strings.xml).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the code in `gamehelper_strings.xml`, which we created in step 12.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now change the `MainActivity` declaration in the `MainActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change it to the following code so that we can now extend the version of Activity
    that handles all the hard work of the Game Services API:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now check out the code in the `GameActivity.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the preceding code to the following code so that we can now extend the
    version of Activity that handles all the hard work of the Game Services API:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that for both Activities, we have an error in the class declaration we
    just typed. If you hover the mouse cursor over the code we typed in the previous
    step, you can see the reason. We need to implement some abstract methods of a
    class we are using. Recall from [Chapter 6](ch06.html "Chapter 6. OOP – Using
    Other People's Hard Work"), OOP – *Using Other People's Hard Work*, that if a
    method in a class is declared abstract, then the class that extends it must implement
    it. That's us! Let's perform an empty implementation for now. Right-click on the
    line of code with the error and navigate to **Generate** | **Implement Methods**.
    Now click on **OK**. Perform this step for the `MainActivity.java` file and the
    `GameActivity.java` file. Our empty methods are now ready for our code. We will
    write the code in the next tutorial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, using the project explorer, find the `build.gradle` file. Be careful;
    there are two files with the same name. The file that we need to find is a couple
    of lines below the `AndroidManifest.xml` file. It is highlighted in the next screenshot.
    Open it by double-clicking on the `build.gradle` file:![Setting up the Snake project
    ready for implementation](img/88590S_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the section of code shown here and add the line that is highlighted. This
    makes all the classes we downloaded in the previous guide available for use in
    our *Snake* game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Okay, I agree that was a fairly tough tutorial, but we are now ready to implement
    our code in three final steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Player sign-in and buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leaderboards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Achievements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then be able to upload our updated app and use our new leaderboards
    and achievements.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the player's sign-in, achievements, and leaderboard buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By the end of this section, players will be able to log in through the game
    to our empty leaderboards and achievements. The guides that follow this section
    will actually make the leaderboards and achievements work.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's enable our Game Services. All of the work we have done so far in
    the developer console needs to be published before we can use it. Log in to your
    developer console. Navigate to **Game Services** | **Snake** | **Ready to publish**
    | **Publish game**. Then you will be shown a **Publish your game** button. Click
    on it. Finally, read the brief disclaimer and click on **Publish now**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to build a UI that has **Sign in**, **Sign out**, **Leaderboards**,
    and **Achievements** buttons. Open the `layout_main.xml` file and edit it on the
    **Text** tab of the editor window by adding the following code. Obviously, there
    is a lot to type. You might like to copy and paste the code from the download
    package at `Chapter9\EnhancedSnakeGame\layout`. Here is the code. Type it in or
    copy and paste it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Explaining the code line by line is beyond the scope of the book, but this is
    not much different from the code we have been autogenerating when using the UI
    designer since [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*. Each block of the code in the last step defines
    a button and its position on the screen. You can switch to the design tab and
    move the buttons around to suit yourself. Note that the reason some of the buttons
    are not visible in the designer is that they are hidden until the player signs
    in. The reason we have done things this way is to make sure we implement the sign
    in button in just the right way. Note the `id` attribute for each of the buttons.
    We will be manipulating them in our Java code next. With some buttons set to `visibility
    = gone`, we see something like this:![Implementing the player's sign-in, achievements,
    and leaderboard buttons](img/88590S_09_40.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With some buttons set to `visibility = visible`, we see something like what
    is shown in the following screenshot:![Implementing the player's sign-in, achievements,
    and leaderboard buttons](img/88590S_09_41.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might be wondering why we are designing a UI when `SnakeAnimView` is what
    the user sees. We could have implemented all our own buttons with bitmaps and
    used their screen coordinates to detect presses, but what we will do now is load
    our UI on top of `SnakeAnimView`, which will greatly simplify things. Switch to
    the **MainActivity** tab in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First of all, we want to implement the `onClickListener` interface to handle
    our button clicks. To achieve this, change the class declaration to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can get Android Studio to quickly implement the required `onClick` method
    by right-clicking on the class declaration, navigating to **Add** | **Implement
    methods**, and then clicking on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Immediately after the previous line of code, we declare our four new buttons.
    Add this code after the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onCreate` method, just after the call to the `setContent` view, we
    use an object of the `LayoutInflater` class to load our UI on top of our `SnakeAnimView`.
    Add the highlighted code after the call to `setContentView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately after the code in the previous step, we can get a reference to
    all our buttons and listen to clicks in the usual way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember that in the previous guide, we overrode two abstract methods that
    we inherited when we extended the `BaseGameActivity` class. Now we will put some
    code into their implementation. The code is very straightforward. We hide the
    sign out button and show the sign in button when the sign-in fails, and we hide
    the sign in button and show all the other three buttons when the sign-in succeeds.
    Here are the two methods in their entirety. Type the highlighted code within the
    methods shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we deal with the `onClick` method and what happens when the player clicks
    on any one of our four buttons. First, we type the code for our switch block.
    We will fill in the `case` statements in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we handle the sign in button. We simply call the `beginUserInitiatedSignIn`
    method. It is implemented for us in the `BaseGameActivity` class. Type this code
    in the `switch` block from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we handle what happens when the player signs out. We just call `signOut`,
    which is implemented for us in the `BaseGameActivity` class. We then hide all
    our buttons and show the sign in button again. Type the following code after the
    code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we handle what happens when the player clicks on the achievements button.
    One line of code gives us all of the achievement functionality. This is what OOP
    is all about—someone else''s hard work doing everything for us. Type this code
    after the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we handle what happens when the player clicks on the **Leaderboards**
    button. Again, one line of code gives us all of the leaderboard''s functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We explained the code as we went, but let''s summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: We designed a simple UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We loaded the UI on top of `SnakeAnimView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We got a reference to our four buttons and listened for clicks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We handled what happens when people click on our buttons, which amounted to
    nothing more than hiding and showing buttons as appropriate, calling methods from
    `BaseGameActivity`, and using the `Intent` class to implement all our leaderboard
    and achievement functionalities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can actually run the *Snake* game and see the leaderboards and achievements
    screens. Of course, at this point, nobody will have any achievements or high scores
    yet. We will fix this now.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the leaderboards in code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once more, we will witness the simplicity of using other people''s well-designed
    code. Admittedly, there was some complexity to arrive at this point, but once
    you have set it all up, then your next game will take a fraction of the time you
    took setting up:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to submit a score to the `leaderboards` at the end of a game. Google
    Play will handle the process to check whether or not it is a high score. Google
    Play will even determine if it is a new high score for the week or month. Open
    the `GameActivity.java` file in the code editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `updateGame` method and add the highlighted code among all the other
    things we do when the game is over (when `dead` equals `true`). We wrap just one
    line of code within a check to ensure that the current player is signed in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! Build the game and play it on a real Android device. You can now
    visit the leaderboards on Google Play and see your high score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That was nice and easy. Here, we can see the login screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the leaderboards in code](img/88590S_09_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then comes the welcome message and our **Achievements** and **Leaderboards**
    buttons as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the leaderboards in code](img/88590S_09_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we can see our new leaderboards with just one player—me.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the leaderboards in code](img/88590S_09_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just in case you're wondering, I can do a lot better than 39.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the achievements in code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This brief tutorial will first set up our game to post incremental updates
    to the progress of the apple achievements and the one-off achievement of the snake
    segment length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GameActivity.java` file, add an `applesMunchedThisTurn` variable just
    after the class declaration, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find the `updateGame` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a line of code to increment `applesMunchedThisTurn` each time an apple
    is eaten by adding the highlighted line of code where it is shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that we place this highlighted line among the code that executes when
    the player dies (the `if(dead)` block). We could do it at the point the player
    eats an apple, but if we send five messages to the Google Play servers every time
    the player eats an apple, we might risk Google considering it as spam. We simply
    increment each achievement by the number of apples that have been eaten, and then
    reset the `applesMunchedThisTurn` variable to zero. We wrap our achievement method
    calls with a check that the player is signed in and that `applesMunchedThisTurn`
    is greater than zero. Now add the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will handle the segment length achievements. In the `updateGame` method,
    in the part of the code that executes when the player eats an apple, just after
    the line of code that increments `snakeLength`, we test for any of the lengths
    that warrant a Super Snake achievement. When the desired length is achieved (5,
    10, 25, 35, or 50 segments), we ask Google Play to award it (if it hasn''t been
    awarded yet). We wrap our achievement method calls with a check that the player
    is signed in and that at least one apple has been eaten. The highlighted code
    is the new code to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! You can now play the game and earn achievements:![Implementing the
    achievements in code](img/88590S_09_48.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, that was nice and easy. You can probably see how simple it would be to
    implement all other achievement ideas that we discussed earlier in the chapter.
    Let's move on and update our game on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the updated Snake game to Google Play
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is nice and easy and is performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to let Google Play know this is a new version. We do this by
    changing the version number. Open the `Build.gradle` file and find these lines
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build your APK in the usual way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to your developer console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Snake Game 1.0**, then on **APK**, and then on **Upload new APK to
    production**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to your newly updated APK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **What's new in this version** field, enter `Added leaderboards and achievements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Publish now to production**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From now onwards, everyone who downloads your game will get the updated version.
    With our first game, complete with sprite sheet animations, leaderboards and achievements,
    it is time to take a break and do a little theory.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be proud of your creations to date, especially if this was your first
    attempt at programming. If some of the concepts, syntax, or projects are still
    not clear, then consider revisiting them after a break.
  prefs: []
  type: TYPE_NORMAL
- en: The one thing we haven't talked about is the even more new skills we need to
    progress further. The reason for this is that it very much depends on your initial
    motivation for reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a programmer's job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to be a Java employee, that is, working full time with a professional
    capacity for a medium or large company, then you will probably need a college
    degree, and this book hopefully has given you a glimpse into the world of programming
    and Java itself. If this describes you, then for further study, you could consider
    a more formal Java book, followed by a pure OOP book about object-oriented analysis
    and design. You could then move on to study design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the best books that fit into these categories are *Head First Object-Oriented
    Analysis and Design: A Brain Friendly Guide to OOA&D, Brett McLaughlin and Gary
    Pollice; Head First Design Patterns*; *Eric Freeman and Elisabeth Robson*, *O''Reilly*;
    and *Design Patterns CD: Elements of Reusable Object-Oriented Software*, *Erich
    Gamma, Richard Helm, Ralph Johnson, and John Vlissides*, *Addison Wesley*. The
    first two are very beginner-friendly. The latter is highly regarded but a much
    more challenging read for a beginner.'
  prefs: []
  type: TYPE_NORMAL
- en: My guess is that most likely, you didn't pick up a beginners' book on games
    and Java because you were headed in that direction, so let's consider our *piece
    de resistance* so far—our Snake game.
  prefs: []
  type: TYPE_NORMAL
- en: Building bigger and better games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you compare our Snake game to a modern, professional title, even a two-dimensional
    game, never mind a modern big-budget First Person Shooter (FPS), then we still
    have a lot of learning to do. Let's consider some inadequacies of our *Snake*
    game compared to a professional game.
  prefs: []
  type: TYPE_NORMAL
- en: Think about our flower and tail animations. They worked because we set up a
    crude timing system within our `controlFPS` method. But what if we had a dozen
    or more game objects that needed to be animated?
  prefs: []
  type: TYPE_NORMAL
- en: Then what if they all had different frame counts and frame rates? We can further
    complicate things if some of the animations need to work on a loop and others
    need to reverse through each frame before restarting.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine a character that has to jump. How do we synchronize whatever frame
    happens to be displayed at the time the player jumps?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, all of these problems and more are solvable with a quick web search
    and some study. The point is that things are starting to get fairly complicated,
    and we have only talked about animation.
  prefs: []
  type: TYPE_NORMAL
- en: What about physics? How will objects in our future games behave when they bounce?
    We were able to cheat with our Squash game because the environment and the objects
    were few and simple. What if the ball was round and there were lots of objects
    of different sizes and shapes, some moving fast and some stationary? How would
    we simulate this physics model?
  prefs: []
  type: TYPE_NORMAL
- en: Again, the answers are all out there but they add complexity. What about other
    environmental factors such as light and shadow? What happens when our screen needs
    to scroll to the left and right? What about up and down?
  prefs: []
  type: TYPE_NORMAL
- en: Now consider all of these problems and imagine implementing a solution in a
    virtual three-dimensional world. Once again, the solutions are out there, but
    it would take a determined beginner many months to implement their own solution
    using the raw mathematics involved in three-dimensional calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, imagine that you want your new three-dimensional, physics-based, superbly
    animated game to be available on Android, Apple, and PC platforms.
  prefs: []
  type: TYPE_NORMAL
- en: If I have discouraged you from seeking some of these solutions but you are fascinated
    to find out the answer, then my advice would be to go and find it out anyway.
    It will definitely be a fascinating journey and make you a better game developer.
    Think twice, however, before implementing any of this stuff for any reason other
    than curiosity, self-improvement, or fun.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is because we are not the first people to have these and
    many other problems—the solutions have already been implemented. And guess what?
    We can use those solutions, often at no cost to ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there is a library called OpenGL that has one purpose—drawing in
    a three-dimensional coordinate system. It has classes and methods for everything
    you will ever need. There is even a version of OpenGL for mobile, called OpenGL
    ES, that you can program in Java. It is true that OpenGL has some complexities
    of its own, but they can be learned in a logical and straightforward manner from
    easy to hard.
  prefs: []
  type: TYPE_NORMAL
- en: If you got this far with this book, take a quick refresher on [Chapter 6](ch06.html
    "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using Other People's
    Hard Work*, and then grab a copy of *OpenGL ES2 for Android*, *K. Brothaler*,
    *Pragmatic Bookshelf*. The book explores the code library and some of the mathematics
    behind it, so it should satisfy both the curious and the purely practical reader.
    Alternatively, you can check out loads of free tutorials at [http://www.learnopengles.com/](http://www.learnopengles.com/).
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to make more games and are not particularly fussed about the
    three-dimensional features, then the next logical step would be a Java-based game
    library. There are many, but one in particular uses pure Java to build games on
    Android, iPhone, PC, and the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, you can build one Java game and it will run on almost any device in
    the world, even a web page. It also has classes that simplify the use of the aforementioned
    OpenGL ES. The library is called LibGDX, and I had loads of fun making a platform
    game following along with *Learning Libgdx Game development* ([https://www.packtpub.com/game-development/learning-libgdx-game-development](https://www.packtpub.com/game-development/learning-libgdx-game-development)).
    LibGDX also solves all our animation, scrolling, and physics conundrums without
    any math, although it doesn't really address three-dimensional features.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that both books have some quite in-depth OOP, but this is not out of reach
    if you understood [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's
    Hard Work"), *OOP – Using Other People's Hard Work*, and are determined.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to go 3D straightaway, then a really fun option is the Unreal Engine.
    Unreal Engine is used in lots of really big-budget games and can involve immense
    complexity in another programming language. However, for a way to make two-dimensional
    and three-dimensional games within a GUI development environment, it is probably
    unbeatable. Unreal Engine 4 uses a system called Blueprint, where you can drag
    and drop elements of flow chart-like elements, instead of coding. It still uses
    all the concepts of OOP as well as loops and branching, but you can do loads without
    a single line of *real* code. Take a look at the Unreal Engine version of Flappy
    Bird created without a single line of code, at [https://play.google.com/store/apps/details?id=com.epicgames.TappyChicken](https://play.google.com/store/apps/details?id=com.epicgames.TappyChicken).
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine can also build games for multiple platforms, but unfortunately,
    there is a small monthly fee, and most restrictively of all, any commercial project
    you make will be subject to an agreement. Here, you pay 30 percent to Epic games,
    but for learning and having fun, it probably can't be beaten.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, take a look at my blog ([www.gamecodeschool.com](http://www.gamecodeschool.com)),
    where I regularly add articles and fun game building guides aimed at beginner
    to intermediate game programmers. My blog discusses lots of different programming
    languages, target platforms, all the tools previously mentioned, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) Try to implement local high scores on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Q2) How many eminent computer scientists have made cameo appearances in the
    code throughout this book?
  prefs: []
  type: TYPE_NORMAL
- en: Q3) As a final challenge, try to beat my high score on the Snake leaderboards.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot. We published our *Snake* game on Google Play.
    Then we added some online leaderboards and achievements. We also updated our publication.
    The process showed how very complicated tasks such as communication over the Internet
    can be made really simple using an API.
  prefs: []
  type: TYPE_NORMAL
- en: While putting the finishing touches to this book, I watched a YouTube video
    of a lecture from John Carmack, a software legend. He was a key engineer in the
    development of the *Doom* game, which was published in June 1995\. I had to laugh,
    as did his audience, when he explained that while in school, he felt he was missing
    out on the technology revolution, and by the time he was old enough to work, it
    would all be over.
  prefs: []
  type: TYPE_NORMAL
- en: It is certainly true that lots of technology revolutions have come and many
    have gone. At least, many of the early adopters' opportunities have faded. John
    Carmack explained that there is always going to be another revolution just around
    the corner.
  prefs: []
  type: TYPE_NORMAL
- en: So you are probably going to develop your skills and watch out for the next
    big thing. Or perhaps, you just want a bit of fun programming anything in any
    language for any platform.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have enjoyed our journey through Android and Java, and that you will
    continue this journey as well. I sincerely wish you well, whichever path you choose
    for your future. Feel free to come and share your experiences and knowledge at
    [www.gamecodeschool.com](http://www.gamecodeschool.com). The perfect sequel to
    this book will be published mid 2015 called *Android Game Programming by Example*.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Self-test Questions and Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we have included some questions you could ask yourself to see whether
    you have understood each chapter. Don't worry! The answers are also included.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What should you do if all this talk of life cycles, classes, and methods
    is a bit confusing?
  prefs: []
  type: TYPE_NORMAL
- en: A) Don't worry about them. Understanding comes a bit at a time, and if they
    are not entirely clear at this stage, it will not hold you back from thoroughly
    learning Java, and all will become clearer as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: Q2) What exactly is a Java class?
  prefs: []
  type: TYPE_NORMAL
- en: A) Classes are a fundamental building block of Java programs. They are like
    containers for our Java code, and we can even use other people's classes to simplify
    the programs we write, even without seeing or understanding the code contained
    within those classes.
  prefs: []
  type: TYPE_NORMAL
- en: Q3) What is the difference between a method and a class?
  prefs: []
  type: TYPE_NORMAL
- en: A) Methods are contained within classes and represent the specific functionality
    of the class, like another container within a container. As an example from a
    game, we might have a `Tank` class with `shoot`, `drive`, and `selfDestruct` methods.
    We can use a class and its methods by making our own class, as we will in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*, or by using the `@import` statement as we did earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Q4) Take a look at the Android developer site and its more technical explanation
    of the lifecycle phases, at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html).
    Can you see the phase and its related method that we haven't discussed? When would
    it be triggered in an app? What is the precise pathway an activity takes from
    creation to destruction?
  prefs: []
  type: TYPE_NORMAL
- en: A) It's the restarting phase. Its corresponding method is `onRestart`. It is
    triggered when an app has been stopped and then restarted. We won't need the `onRestart`
    method in this book, but this exercise hopefully helped clarify the concept of
    life cycles. The precise pathway will vary; we just need to handle the phases
    that are relevant to our game. So far, we have just tinkered with `onCreate`.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What does this code do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: A) Nothing, because it is commented out with //.
  prefs: []
  type: TYPE_NORMAL
- en: Q2) Which of these lines causes an error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: A) The fourth line, `a = a + b`, has no semicolon, so it will cause an error.
    The last line, `c = c + a;`, will also cause an error because you cannot assign
    a string to an `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: Q3) We talked a lot about operators and how different operators can be used
    together to build complicated expressions. Expressions, at a glance, can sometimes
    make code look complicated. However, when looked at closely, they are not as tough
    as they seem. Usually, it is just a case of splitting the expressions into smaller
    pieces to work out what is going on. Here is an expression that is more convoluted
    than anything else you will ever meet in this book. As a challenge, can you work
    out what `x` will be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: A) You can run the `SelfTestC3Q3` project in the `Chapter3` folder of the code
    bundle to check out the answer in the console, but `isTrueOrFalse` evaluates to
    true; here's why.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s break down the nasty line into manageable sections defined by
    the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we were asking the question, "is `x` less than or equal to `y` or
    is `x` exactly equal to `10`?". Clearly, `x` is not equal to or less than `y`
    but `x` is exactly equal to `10`, so our use of the logical OR operator, `||`,
    in the middle causes the entire part of the expression to evaluate to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '&&'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both sides of an `&&` operator must evaluate to `true` for the overall expression
    to be true. So let''s look at the other side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Well, `isTrueOrFalse` is a Boolean. It can only be true or false so this part
    of the expression must be true because we are essentially asking, "is `isTrueOrFalse`
    false or is `isTrueOrFalse` true?". It must be one or the other. So, regardless
    of how we initialized `isTrueOrFalse`, the last part of the expression will be
    true.
  prefs: []
  type: TYPE_NORMAL
- en: So the overall expression evaluates to `true`, and `true` is assigned to `isTrueOrFalse`.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What is wrong with this method?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: A) It returns a value but has a `void` return type.
  prefs: []
  type: TYPE_NORMAL
- en: Q2) What will `x` be equal to at the end of this code snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: A) Okay, this was a slightly tricky question. Regardless of the value of `x`,
    the `do` block always executes at least once. Then `x` is set to `11`, and after
    that, it is incremented to `12`. So when the `while` expression is evaluated,
    it is true and the `do` block executes again. Once more, `x` is set to `11` and
    then incremented to `12`. The program is stuck in a never-ending (infinite) loop.
    This code is most likely a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) Suppose we wanted to have a quiz where the question could be about naming
    the president, the capital city, and so on. How would we do this with multidimensional
    arrays?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) We would just make the inner array hold three strings, perhaps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: Q2) In our persistence example, we saved a continually updating string to a
    file so that it persisted after the app had been shut down and restarted. This
    is like asking the user to click on a **Save** button. Summoning all your knowledge
    of [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, can you think of a way to save the string without saving
    it by the button click but just when the user quits the app?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) Override the `onPause` life cycle method and put the code to save the string
    in there, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: Q3) Other than increasing the difficulty level, how could we make the memory
    game harder?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) We could simply alter the pause in our thread execution to mention a lower
    number, giving the player less thinking time, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: Q4) Using the plain Android UI with the dull grey buttons isn't very exciting.
    Take a look at the UI elements in the visual designer. Can you work out how to
    use an image for our button background?
  prefs: []
  type: TYPE_NORMAL
- en: A) Simply add some `.png` graphics to the `drawable-mdpi` folder and then find
    the background property in the **Properties** window while your button is selected.
    Click to edit the property in the usual way and choose the graphic you added to
    the `drawable-mdpi` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What is encapsulation?
  prefs: []
  type: TYPE_NORMAL
- en: A) Encapsulation is the way we pack our variables, code, and methods in a manner
    that exposes just the parts and functionality we want to the parts of our app
    (or any app that uses our classes) that we want.
  prefs: []
  type: TYPE_NORMAL
- en: Q2) I don't get all this, and actually, I have more questions now than I had
    at the start of the chapter. What should I do?
  prefs: []
  type: TYPE_NORMAL
- en: A) You know enough about OOP to make significant progress with games and any
    other type of Java programming. If you are desperate to know more OOP right now,
    there are plenty of highly rated books that discuss nothing but OOP. However,
    practice and familiarity with the syntax will go a long way to achieving the same
    thing and will probably be more fun. The deciding factor in whether you rush off
    and learn the intricate details of OOP now will really depend on your personal
    goals and what you want to do with your programming skills in the future. Read
    the last few pages of [Chapter 9](ch09.html "Chapter 9. Making Your Game the Next
    Big Thing"), *Making Your Game the Next Big Thing*, for more discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) The speed of the ball is calculated in pixels. Different devices have different
    numbers of pixels. Can you explain how to make the ball speed approximately the
    same on different screen resolutions?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) A simple way to accommodate different screen resolutions would be to devise
    a system that that takes into account the number of pixels the screen has. We
    have already done this for the racket and ball sizes. We could declare a member
    variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then initialize these variables in `onCreate` after we have obtained
    the screen dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can move our ball a bit, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What about a visual improvement for our game screen, perhaps a nice, light
    green grassy background instead of just black?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) You can use most graphics programs such as Gimp or Photoshop to get the
    RGB value of a nice, light green grassy color. Alternatively, you can use an online
    color picker such as [http://www.colorpicker.com/](http://www.colorpicker.com/).
    Then look at this line in our `drawGame` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Q2) How about adding some nice flowers to the background?
  prefs: []
  type: TYPE_NORMAL
- en: A) Here is the way to do this. Create a flower bitmap (or use mine), load it,
    and scale it in the usual way, in the `configureDisplay` method. Decide how many
    flowers to draw. Choose and store locations on the board in the `SnakeView` constructor
    (or write and call a special method, perhaps `plantFlowers`).
  prefs: []
  type: TYPE_NORMAL
- en: Draw them before the snake and the apple in the `drawGame` method. This will
    ensure that they can never hide an apple or a part of the snake. You can see my
    specific implementation in the methods mentioned and a copy of the flower bitmap
    in the `EnhancedSnakeGame` project in the `Chapter8` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Q3) If you're feeling brave, make the flowers sway. Think of sprite sheets.
    The theory is exactly the same as that of the animated snake head. We just need
    a few lines of code to control the frame rate separately from the game frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: A) Take a look at the new code in the `controlFPS` method. We simply set up
    a new counter for flower animations to switch flower frames once every six game
    frames. You can also copy the sprite sheet from the `EnhancedSnakeGame` project
    in the `Chapter8` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Q4) We could set up another counter and use our snake head animation, but it
    wouldn't be that useful because the subtle tongue movements would be barely visible
    due to the smaller size. Nevertheless, we could quite easily swish the tail segment.
  prefs: []
  type: TYPE_NORMAL
- en: A) There is a two-frame tail bitmap in the `EnhancedSnakeGame` project in the
    `Chapter8` folder. As this is also two frames, we could use the same frame timer
    as that used for the flower. Take a look at the implementation in the `EnhancedSnakeGame`
    project in the `Chapter8` folder. The only required changes are in `configureDisplay`
    and `drawGame`.
  prefs: []
  type: TYPE_NORMAL
- en: Q5) Here is a slightly trickier enhancement. You can't help notice that when
    the snake sprites are headed in three out of the four possible directions, they
    don't look right. Can you fix this?
  prefs: []
  type: TYPE_NORMAL
- en: A) We need to rotate them depending upon the way they are heading. Android has
    a `Matrix` class, which allows us to easily rotate Bitmaps, and the `Bitmap` class
    has an overloaded version of the `createBitmap` method that takes a `Matrix` object
    as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can create a matrix for each angle we need to handle, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can rotate a bitmap using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: 'Another problem is that as the snake twists and turns, how do we keep track
    of the individual orientation of each segment? We already have a direction finding
    scheme: 0 is up, 1 is right, and so on. So we can just create another array for
    the orientation of each segment that corresponds to a body segment in the `snakeX`
    and `snakeY` arrays. Then all we need to do is to ensure that the head has the
    correct direction, and update from the back on each frame just as we do for the
    snake''s coordinates. You can see this implemented in the `EnhancedSnakeGame`
    project in the `Chapter8` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: The finished project with a few more enhancements is in the `EnhancedSnakeGame`
    project in the `Chapter8` folder. This is the version we will be using as a starting
    point in the next and final chapter. You can also download the game from Google
    Play at [https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame).
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 8](img/8859OS_Appendix_01.jpg)![Chapter 8](img/8859OS_Appendix_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) Try to implement the local high scores on the device.
  prefs: []
  type: TYPE_NORMAL
- en: A) You already know how to do this. Just go back to [Chapter 5](ch05.html "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials* in case you are unsure. The
    implementation is in the code for this chapter's project as well.
  prefs: []
  type: TYPE_NORMAL
- en: Q2) How many eminent computer scientists have made cameo appearances in the
    code throughout this book?
  prefs: []
  type: TYPE_NORMAL
- en: A) 9
  prefs: []
  type: TYPE_NORMAL
- en: Ada Lovelace
  prefs: []
  type: TYPE_NORMAL
- en: Charles Babbage
  prefs: []
  type: TYPE_NORMAL
- en: Alan Turing
  prefs: []
  type: TYPE_NORMAL
- en: Vinton Cerf
  prefs: []
  type: TYPE_NORMAL
- en: Jeff Minter
  prefs: []
  type: TYPE_NORMAL
- en: Corrine Yu
  prefs: []
  type: TYPE_NORMAL
- en: André LaMothe
  prefs: []
  type: TYPE_NORMAL
- en: Gabe Newell
  prefs: []
  type: TYPE_NORMAL
- en: Sid Meier
  prefs: []
  type: TYPE_NORMAL
- en: Why not search on the Web for some of these names? There are some interesting
    stories about each of them.
  prefs: []
  type: TYPE_NORMAL
