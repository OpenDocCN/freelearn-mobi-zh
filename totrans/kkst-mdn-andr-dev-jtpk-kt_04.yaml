- en: '*Chapter 3*: Displaying Data from REST APIs with Retrofit'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：使用 Retrofit 显示 REST API 的数据'
- en: In this chapter, we'll be taking a break from the Jetpack libraries and focusing
    on adding real data within our Restaurants application by using a very popular
    networking library on Android called **Retrofit**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将暂时放下 Jetpack 库，通过使用 Android 上一个非常流行的网络库 Retrofit，来专注于在我们的餐厅应用程序中添加真实数据。
- en: Retrofit is an HTTP client library that lets you create an HTTP client declaratively
    and abstracts most of the underlying complexity associated with handling network
    requests and responses. This library allows us to connect to a real web API and
    retrieve real data within our app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit 是一个 HTTP 客户端库，允许您声明性地创建 HTTP 客户端，并抽象出处理网络请求和响应的大部分底层复杂性。这个库使我们能够连接到真实的网络
    API，并在我们的应用程序中检索真实数据。
- en: In the *Understanding how apps communicate with remote servers* section, we
    will focus on exploring how mobile applications retrieve and send data to remote
    web APIs. In the *Creating and populating your database with Firebase* section,
    we will create a database for our Restaurants application with the help of Firebase
    and fill it with JSON content.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *理解应用如何与远程服务器通信* 部分，我们将专注于探索移动应用程序如何检索和向远程网络 API 发送数据。在 *使用 Firebase 创建并填充数据库*
    部分，我们将借助 Firebase 为我们的餐厅应用程序创建数据库，并用 JSON 内容填充它。
- en: In the *Exploring Retrofit as an HTTP networking client for Android* section,
    we will learn what Retrofit is, and how it can help us create network requests
    within our Restaurants app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *探索 Retrofit 作为 Android 的 HTTP 网络客户端* 部分，我们将了解 Retrofit 是什么，以及它如何帮助我们创建餐厅应用程序中的网络请求。
- en: Lastly, in the *Improving the way our app handles network requests* section,
    we will tackle some common issues that occur when Android applications create
    async work to retrieve data from web APIs. We will identify those issues and fix
    them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *改进我们应用处理网络请求的方式* 部分，我们将解决 Android 应用在创建异步工作以从网络 API 获取数据时出现的常见问题。我们将识别这些问题并修复它们。
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下主要主题：
- en: Understanding how apps communicate with remote servers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解应用如何与远程服务器通信
- en: Creating and populating your database with Firebase
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Firebase 创建并填充数据库
- en: Exploring Retrofit as an HTTP networking client for Android
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Retrofit 作为 Android 的 HTTP 网络客户端
- en: Improving the way our app handles network requests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进我们应用处理网络请求的方式
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为这一章设定技术要求。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects with Retrofit usually requires just
    your day-to-day tools. However, to follow along smoothly, make sure you have the
    following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Retrofit 构建 Compose 基础的 Android 项目通常只需要您日常使用的工具。然而，为了顺利跟进，请确保您具备以下条件：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that IDE interface and other
    generated code files might differ from the ones used throughout this book.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio 的 Arctic Fox 2020.3.1 版本。您也可以使用更新的 Android Studio 版本，甚至可以尝试 Canary
    版本，但请注意，IDE 界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10 or newer installed in Android Studio.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中安装了 Kotlin 1.6.10 或更高版本。
- en: The Restaurants app code from the previous chapter.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的餐厅应用程序代码。
- en: A Google account to create a Firebase project.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Google 账户来创建 Firebase 项目。
- en: The starting point for this chapter is the Restaurants application that we developed
    in the previous chapter. If you haven't followed the coding steps from the previous
    chapter, access the starting point for this chapter by navigating to the `Chapter_02`
    directory of this book's GitHub repository and importing the Android project entitled
    `chapter_2_restaurants_app`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是我们上一章开发的餐厅应用程序。如果您没有遵循上一章的编码步骤，可以通过导航到本书 GitHub 仓库的 `Chapter_02` 目录并导入名为
    `chapter_2_restaurants_app` 的 Android 项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_03`
    directory:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到 `Chapter_03` 目录：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03)。'
- en: Understanding how apps communicate with remote servers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序如何与远程服务器通信
- en: Modern applications need to show real content that can change over time and
    need to avoid hardcoding data, as we did in the previous chapters. Let's briefly
    cover how they do that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序需要显示可以随时间变化的真实内容，并且需要避免像我们在前几章中那样硬编码数据。让我们简要地了解一下它们是如何做到这一点的。
- en: Most network-connected apps use the HTTP protocol to send or receive data in
    the format of JSON from REST web services through a REST API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络连接的应用程序使用 HTTP 协议通过 REST API 以 JSON 格式发送或接收数据。
- en: 'That''s a lot of words we''ve just thrown at you, so let''s break them down:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚向你抛出了很多词汇，所以让我们来分解它们：
- en: '**Hypertext Transfer Protocol** (**HTTP**) is a protocol for asynchronously
    fetching various resources from web servers. In our case, the resources are the
    data that our application needs to display.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是一种用于从网络服务器异步获取各种资源的协议。在我们的案例中，资源是我们应用程序需要显示的数据。'
- en: '**JavaScript Object Notation** (**JSON**) is the data format of the content
    that''s transferred in HTTP requests. It''s structured, lightweight, and human-readable
    as it consists of key-value pairs that are easy to parse and commonly used as
    a suitable format for data exchange between apps and web servers. In our app,
    we will receive the data from the web server in such JSON format.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**（**JSON**）是 HTTP 请求中传输的内容的数据格式。它是结构化的、轻量级的，并且由于其由易于解析的键值对组成，因此易于阅读，常用于应用程序和服务器之间数据交换的合适格式。在我们的应用程序中，我们将以这种
    JSON 格式从网络服务器接收数据。'
- en: '`GET`, `PUT`, `POST`, `DELETE`, and so on.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`、`PUT`、`POST`、`DELETE` 等等。'
- en: A **REST API** is an **application programming interface** (**API**) that conforms
    to the constraints of the REST architecture and allows you to interact with REST
    web services. The REST API is the contract and the entry point that's used by
    apps to obtain or send data to and from the backend.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST API** 是一个符合 REST 架构约束的 **应用程序编程接口**（**API**），它允许你与 REST 网络服务进行交互。REST
    API 是应用程序用于从后端获取或发送数据的合约和入口点。'
- en: 'Let''s try to visualize the relationship between these entities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试可视化这些实体之间的关系：
- en: '![Figure 3.1 – Overview of HTTP communication between apps and web servers'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 应用程序与网络服务器之间 HTTP 通信概述'
- en: '](img/B17788_03_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B17788_03_01.jpg](img/B17788_03_01.jpg)'
- en: Figure 3.1 – Overview of HTTP communication between apps and web servers
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 应用程序与网络服务器之间 HTTP 通信概述
- en: We want to implement something similar for our Restaurants application. For
    this to work, we will need a REST server. For the sake of simplicity, we will
    use the Firebase Realtime Database and create a database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在我们的餐厅应用程序中实现类似的功能。为了使其工作，我们需要一个 REST 服务器。为了简化，我们将使用 Firebase 实时数据库并创建一个数据库。
- en: Creating and populating your database with Firebase
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Firebase 创建和填充你的数据库
- en: So far, we've only used hardcoded data as the source of content for our Restaurants
    app. Since almost every real application uses dynamic data that comes from a backend
    server through a REST API, it's time to step up our game and create a database
    that simulates such a remote API.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了硬编码的数据作为我们餐厅应用程序内容来源。由于几乎每个真实的应用程序都使用来自后端服务器通过 REST API 的动态数据，是时候提高我们的水平，创建一个模拟这种远程
    API 的数据库了。
- en: We can do this for free with the help of Firebase. Firebase is backed by Google
    and represents a **Backend-as-a-Service** (**BaaS**), which allows us to build
    a database very easily. We will use the Realtime Database service from Firebase
    without using the Firebase Android SDK. Even though such a database is not a proper
    REST web service, we can use its database URL as a REST endpoint and pretend that
    that is our REST interface, therefore simulating a real backend.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Firebase 的帮助下免费完成这项工作。Firebase 由 Google 支持，代表了一种 **后端即服务**（**BaaS**），这使得我们能够非常容易地构建数据库。我们将使用
    Firebase 的实时数据库服务，而无需使用 Firebase Android SDK。尽管这样的数据库不是一个合适的 REST 网络服务，但我们可以使用其数据库
    URL 作为 REST 端点，并假装那是我们的 REST 接口，从而模拟一个真实的后端。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As we mentioned in the *Technical requirements* section, make sure that you
    have an existing Google account or that you create one beforehand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *技术要求* 部分中提到的，请确保你有一个现有的 Google 账户，或者事先创建一个。
- en: 'Let''s start creating a database:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个数据库：
- en: Navigate to the Firebase console and log into your Google account by going to
    [https://console.firebase.google.com/](https://console.firebase.google.com/).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Firebase 控制台，通过访问 [https://console.firebase.google.com/](https://console.firebase.google.com/)
    登录你的 Google 账户。
- en: 'Create a new Firebase project:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Firebase 项目：
- en: '![Figure 3.2 – Creating a new Firebase project'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 创建新的Firebase项目'
- en: '](img/B17788_03_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_02.jpg)'
- en: Figure 3.2 – Creating a new Firebase project
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 创建新的Firebase项目
- en: Input the name of your project (it should be about restaurants!) and press **Continue**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您项目的名称（它应该是关于餐厅的！）然后按**继续**。
- en: Optionally, in the next dialog, you can opt out from Google Analytics since
    we won't be using the Firebase SDK. Press **Continue** again. At this point, the
    project should be created.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在下一个对话框中，您可以取消选择Google Analytics，因为我们不会使用Firebase SDK。再次按**继续**。此时，项目应该已经创建。
- en: 'From the left menu, expand the **Build** tab, search for **Realtime Database**,
    and then select it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中，展开**构建**选项卡，搜索**实时数据库**，然后选择它：
- en: '![Figure 3.3 – Accessing Realtime Database'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 访问实时数据库'
- en: '](img/B17788_03_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_03.jpg)'
- en: Figure 3.3 – Accessing Realtime Database
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 访问实时数据库
- en: On the newly displayed page, create a new database by clicking **Create Database**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新显示的页面上，通过点击**创建数据库**来创建一个新的数据库。
- en: 'In the **Set up database** dialog, select a location for your database and
    then click **Next**:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置数据库**对话框中，选择数据库的位置，然后点击**下一步**：
- en: '![Figure 3.4 – Setting up a Realtime Database'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 设置实时数据库'
- en: '](img/B17788_03_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_04.jpg)'
- en: Figure 3.4 – Setting up a Realtime Database
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 设置实时数据库
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If later on any network calls to your Firebase Database fail for no apparent
    reason, you might find yourself in a Firebase restricted location – as I am writing
    this chapter, because of the current situation caused by the eastern war, all
    internet providers from Romania are restricted and any network calls to Firebase
    Database are failing. If this happens to you, try selecting a different location
    for your Realtime Database instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后来对您的Firebase数据库的任何网络调用因不明原因失败，您可能会发现自己处于Firebase限制位置——正如我撰写这一章节时，由于当前由东战引起的情况，罗马尼亚的所有互联网服务提供商都被限制，对Firebase数据库的任何网络调用都失败了。如果这种情况发生在您身上，请尝试为实时数据库实例选择不同的位置。
- en: In the same dialog, define your security rules by selecting **Start in test
    mode** and then clicking **Enable**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的对话框中，通过选择**以测试模式开始**然后点击**启用**来定义您的安全规则。
- en: '![Figure 3.5 – Setting up the security rules of your database'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 设置数据库的安全规则'
- en: '](img/B17788_03_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_05.jpg)'
- en: Figure 3.5 – Setting up the security rules of your database
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 设置数据库的安全规则
- en: Important Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The default security rules for test mode allow anyone to view or modify the
    content within your database for the next 30 days since creation. After these
    30 days, if you want to keep using the database in test mode, you will need to
    update the security rules by changing the timestamp values for the `".read"` and
    the `".write"` fields with greater timestamp values. To skip this, we will just
    set the `".read"` and the `".write"` fields to `true` in the next steps. However,
    Firebase might still restrict your access if you leave the database open for access
    without any rules indefinitely – that's why I recommend you visit the Firebase
    console and check the security rules for your database often to make sure that
    access was not revoked.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模式的默认安全规则允许任何人在创建后的前30天内查看或修改您数据库中的内容。在这30天后，如果您想继续以测试模式使用数据库，您需要通过更改`".read"`和`".write"`字段的时戳值来更新安全规则，并使用更大的时戳值。为了跳过这一步骤，我们将在下一步中将`".read"`和`".write"`字段设置为`true`。然而，如果您无限期地不设置任何规则而让数据库开放访问，Firebase可能会限制您的访问权限——这就是为什么我建议您经常访问Firebase控制台并检查您数据库的安全规则，以确保访问权限没有被撤销。
- en: 'At this point, you should be redirected to your database''s main page in the
    **Data** tab:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该被重定向到**数据**选项卡中您数据库的主页：
- en: '![Figure 3.6 – Observing the Realtime Database main page'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 观察实时数据库主页'
- en: '](img/B17788_03_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_06.jpg)'
- en: Figure 3.6 – Observing the Realtime Database main page
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 观察实时数据库主页
- en: 'You will now notice your URL for this database: [https://restaurants-db-default-rtdb.firebaseio.com/](https://restaurants-db-default-rtdb.firebaseio.com/).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将注意到此数据库的URL：[https://restaurants-db-default-rtdb.firebaseio.com/](https://restaurants-db-default-rtdb.firebaseio.com/).
- en: Your URL should be similar but may differ, depending on the name you have chosen
    for your database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您的URL应该类似，但可能因您为数据库选择的名称而有所不同。
- en: 'Note that the database seems to be empty; we only have an empty root node being
    called after our database: `restaurants-db-default-rtdb`. It''s time to add data
    to our database.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数据库看起来似乎是空的；我们只有一个名为 `restaurants-db-default-rtdb` 的空根节点。现在是时候向我们的数据库添加数据了。
- en: 'Access the solution code for this chapter by navigating to the `Chapter_03`
    directory of this book''s GitHub repository. Then, select the `restaurants.json`
    file. You can also access it by following this link: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json).'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到本书 GitHub 仓库的 `Chapter_03` 目录来访问本章的解决方案代码。然后，选择 `restaurants.json` 文件。您也可以通过以下链接访问它：[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json)。
- en: From here, download the `restaurants.json` file as we will need it shortly.
    To do that, press on the **Raw** button provided by the Github website and then
    right click the document that has been opened and download the JSON file by selecting
    **Saves As**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，下载 `restaurants.json` 文件，因为我们很快就会需要它。为此，点击 Github 网站提供的 **Raw** 按钮，然后右键点击已打开的文档，通过选择
    **另存为** 下载 JSON 文件。
- en: 'Go back to the Firebase console, press on the three-dots menu to the right
    of the database URL, and select **Import JSON**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Firebase 控制台，点击数据库 URL 右侧的三点菜单，并选择 **导入 JSON**：
- en: '![Figure 3.7 – Importing JSON content into Realtime Database'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 将 JSON 内容导入实时数据库'
- en: '](img/B17788_03_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_07.jpg)'
- en: Figure 3.7 – Importing JSON content into Realtime Database
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 将 JSON 内容导入实时数据库
- en: Make sure that you select the `restaurants.json` file that you've previously
    downloaded from the book's GitHub repository.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您选择之前从书籍的 GitHub 仓库下载的 `restaurants.json` 文件。
- en: 'Wait for the page to refresh and check out the content that is populated in
    the database:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待页面刷新并查看数据库中填充的内容：
- en: '![Figure 3.8 – Observing the content''s structure in our database'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 观察我们数据库中的内容结构'
- en: '](img/B17788_03_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_08.jpg)'
- en: Figure 3.8 – Observing the content's structure in our database
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 观察我们数据库中的内容结构
- en: 'Here, we can see that our database contains a list of `Restaurant` class: an
    ID, title, and description. The restaurants in our database also contain other
    fields that we will not need right now, so let''s ignore them.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的数据库包含一个 `Restaurant` 类的列表：一个 ID、标题和描述。我们数据库中的餐厅还包含我们目前不需要的其他字段，所以让我们忽略它们。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'If you compare the structure of the content in our database with the one from
    the JSON file we''ve uploaded, we can see that it is very similar: we have a `restaurants`
    node that contains an array of objects, each containing consistent key-value pairs.
    The only exception is the presence of the indexes (0, 1, 2, and so on) for each
    restaurant, which were automatically created by Firebase. We should ignore these
    as they won''t affect us.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较我们数据库中的内容结构与已上传的 JSON 文件的结构，我们可以看到它们非常相似：我们有一个包含对象的数组的 `restaurants` 节点，每个对象都包含一致的键值对。唯一的例外是每个餐厅的索引（0、1、2
    等等），这些是由 Firebase 自动创建的。我们应该忽略这些，因为它们不会影响我们。
- en: Now, even though we set the security rules to **Test Mode** previously, let's
    revisit them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管我们之前已经将安全规则设置为**测试模式**，但让我们重新审视它们。
- en: 'Move away from the `".read"` key''s value to `"true"`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `".read"` 键的值从 `"true"` 移开：
- en: '![](img/B17788_03_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_03_09.jpg)'
- en: Figure 3.9 – Updating security rules in Realtime Database
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 更新实时数据库中的安全规则
- en: Press `true` since we are testing and not publishing anything to production.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在进行测试而不是发布任何内容到生产环境，请按 `true`。
- en: Now, we can access the database URL as a simple REST endpoint, simulating a
    real REST server that we can connect to. To experiment, copy the URL of your newly
    created database, append `restaurants.json`, and paste it into your browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将数据库 URL 作为简单的 REST 端点来访问，模拟一个我们可以连接到的真实 REST 服务器。为了实验，复制您新创建的数据库的 URL，追加
    `restaurants.json`，并将其粘贴到浏览器中。
- en: Accessing this URL should return the JSON response of our restaurants, whose
    structure we will cover shortly. Until then, we need to instruct our application
    to create HTTP requests to obtain that data from our newly created database. So,
    let's do that next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 访问此 URL 应该返回我们的餐厅的 JSON 响应，其结构我们将在稍后介绍。在此之前，我们需要指示我们的应用程序创建 HTTP 请求以从我们新创建的数据库中获取该数据。所以，让我们继续吧。
- en: Exploring Retrofit as an HTTP networking client for Android
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Retrofit 作为 Android 的 HTTP 网络客户端
- en: For the application to obtain data from our database, we need to implement an
    HTTP client that will send network requests to the REST API of the database.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让应用程序从我们的数据库获取数据，我们需要实现一个 HTTP 客户端，该客户端将向数据库的 REST API 发送网络请求。
- en: Instead of working with the HTTP library provided by default by Android, we
    will use the **Retrofit** HTTP client library, which lets you create an HTTP client
    that is very easy to work with.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Retrofit** HTTP 客户端库，而不是与 Android 默认提供的 HTTP 库一起工作，它允许你创建一个非常容易与之一起工作的
    HTTP 客户端。
- en: If you plan to develop an HTTP client that interfaces with a REST API, you will
    have to take care of a lot of things – from making connections, retrying failed
    requests, or caching to response parsing and error handling. Retrofit saves you
    development time and potential headaches as it abstracts most of the underlying
    complexity associated with handling network requests and responses.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划开发一个与 REST API 交互的 HTTP 客户端，你将不得不处理很多事情——从建立连接、重试失败的请求或缓存到响应解析和错误处理。Retrofit
    通过抽象处理网络请求和响应的大部分底层复杂性，为你节省了开发时间和潜在的头痛。
- en: 'In this section, we will cover the following topics:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下主题：
- en: Using Retrofit
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Retrofit
- en: Adding Retrofit to the Restaurants application
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Retrofit 添加到 Restaurants 应用程序
- en: Mapping JSON to model classes
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JSON 映射到模型类
- en: Executing GET requests to the Firebase REST API
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行对 Firebase REST API 的 GET 请求
- en: Let's start with some basics about Retrofit!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Retrofit 的基础知识开始吧！
- en: Using Retrofit
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Retrofit
- en: Retrofit makes networking simple in Android apps. It allows us to consume web
    services easily, create network requests, and receive responses while reducing
    the boilerplate code that's usually associated with their implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit 使 Android 应用中的网络变得简单。它允许我们轻松消费网络服务，创建网络请求，并在减少与实现相关的样板代码的同时接收响应。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Retrofit also allows you to easily add custom headers and request types, file
    uploads, mocking responses, and more.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit 还允许你轻松添加自定义头和请求类型、文件上传、模拟响应等。
- en: 'To execute network requests with Retrofit, we need the following three components:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Retrofit 执行网络请求，我们需要以下三个组件：
- en: An interface that defines the HTTP operations that need to be performed. Such
    an interface can specify request types such as `GET`, `PUT`, `POST`, `DELETE`,
    and so on.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义需要执行 HTTP 操作的接口。这样的接口可以指定请求类型，如 `GET`、`PUT`、`POST`、`DELETE` 等。
- en: A `Retrofit.Builder` instance that creates a concrete implementation of the
    interface we defined previously. The Builder API allows us to define networking
    parameters such as the HTTP client type, the URL endpoint for the HTTP operations,
    the converter to deserialize the JSON responses, and so on.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Retrofit.Builder` 实例，它创建了一个我们之前定义的接口的具体实现。Builder API 允许我们定义网络参数，如 HTTP
    客户端类型、HTTP 操作的 URL 端点、反序列化 JSON 响应的转换器等。
- en: Model classes that allow Retrofit to know how to map the deserialized JSON objects
    to regular data classes.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型类允许 Retrofit 知道如何将反序列化的 JSON 对象映射到常规数据类。
- en: Enough with the theory – let's try to implement Retrofit and use the components
    we introduced previously in our Restaurants application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了——让我们尝试在 Restaurants 应用程序中实现 Retrofit 并使用我们之前介绍过的组件。
- en: Adding Retrofit to the Restaurants application
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Retrofit 添加到 Restaurants 应用程序
- en: We want to connect our Restaurants application to the newly created Firebase
    database and send HTTP network requests to it. More specifically, when the Restaurants
    application is launched and the `RestaurantsScreen` composable is composed, we
    want to get the list of restaurants at runtime and not depend on hardcoded content
    within the app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们的 Restaurants 应用程序连接到新创建的 Firebase 数据库，并向其发送 HTTP 网络请求。更具体地说，当 Restaurants
    应用程序启动并且 `RestaurantsScreen` 组合组件被组合时，我们希望在运行时获取餐厅列表，而不是依赖于应用程序内的硬编码内容。
- en: 'Let''s do that with the help of Retrofit:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助 Retrofit 来完成这项工作：
- en: 'Inside the `build.gradle` file in the app module, add the dependency for Retrofit
    inside the `dependencies` block:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序模块的 `build.gradle` 文件中，在 `dependencies` 块内添加 Retrofit 的依赖项：
- en: '[PRE0]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by clicking on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新 `build.gradle` 文件后，请确保将项目与其 Gradle 文件同步。您可以通过点击 **文件** 菜单选项，然后选择 **同步项目与
    Gradle 文件** 来完成此操作。
- en: 'Create an interface that defines the HTTP operations that are executed between
    our app and the database. Do so by clicking on the application package, selecting
    `RestaurantsApiService` as the name and select **Interface** as the type. Inside
    the newly created file, add the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接口，定义我们的应用程序和数据库之间执行的 HTTP 操作。通过点击应用程序包，将名称选为 `RestaurantsApiService`，并选择
    **接口** 作为类型。在新建的文件中，添加以下代码：
- en: '[PRE1]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the code we''ve just added into meaningful actions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们刚刚添加的代码分解成有意义的操作：
- en: Retrofit turns your HTTP API into a simple Java/Kotlin interface, so we've created
    a `RestaurantsApiService` interface that defines the HTTP actions we need.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Retrofit 将您的 HTTP API 转换为简单的 Java/Kotlin 接口，因此我们创建了一个 `RestaurantsApiService`
    接口，该接口定义了我们需要的 HTTP 操作。
- en: We've defined a `getRestaurants` method inside the interface that returns a
    `Call` object with an undefined response type marked by Kotlin's `Any type`. Each
    `Call` from `RestaurantsApiService` can make a synchronous or asynchronous HTTP
    request to the remote web server.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在接口内部定义了一个 `getRestaurants` 方法，该方法返回一个带有 Kotlin 的 `Any` 类型标记的未定义响应类型的 `Call`
    对象。来自 `RestaurantsApiService` 的每个 `Call` 都可以向远程 Web 服务器发出同步或异步 HTTP 请求。
- en: We've annotated the `getRestaurants` method with the `@GET` annotation, thereby
    telling Retrofit that this method should execute a `GET` HTTP action to obtain
    data from our web server. Inside the `@GET` annotation, we passed the endpoint's
    path, which represents the `restaurants` node within our Firebase database. This
    means that when we execute this request, the `restaurants.json` endpoint will
    be appended to the base URL of the HTTP client.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `@GET` 注解注释了 `getRestaurants` 方法，从而告诉 Retrofit 该方法应执行 `GET` HTTP 操作以从我们的
    Web 服务器获取数据。在 `@GET` 注解中，我们传递了端点的路径，它代表我们 Firebase 数据库中的 `restaurants` 节点。这意味着当我们执行此请求时，`restaurants.json`
    端点将被附加到 HTTP 客户端的基 URL。
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We mentioned that we can use our Firebase Realtime Database URL as a REST API.
    To access a specific node, such as the `restaurants` node of our database, we
    also appended the `.json` format to make sure that the Firebase database will
    behave like a REST API and return a JSON response.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到可以使用我们的 Firebase 实时数据库 URL 作为 REST API。为了访问特定的节点，例如我们数据库中的 `restaurants`
    节点，我们还附加了 `.json` 格式，以确保 Firebase 数据库的行为类似于 REST API 并返回 JSON 响应。
- en: Later on, after we instantiate a Retrofit builder, the library will know how
    to turn our `getRestaurants` method into a proper HTTP call.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在我们实例化 Retrofit 构建器之后，库将知道如何将我们的 `getRestaurants` 方法转换为适当的 HTTP 请求。
- en: But before that, you have probably noticed that the `getRestaurants` HTTP request
    from our interface has its response type defined as `Any`. We expect to receive
    the JSON content of our restaurants mapped to data classes that we can use in
    our code. So, let's work on that next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但在之前，你可能已经注意到，我们接口中的 `getRestaurants` HTTP 请求将其响应类型定义为 `Any`。我们期望接收将我们的餐厅 JSON
    内容映射到我们可以用于我们代码的数据类的 JSON 内容。所以，让我们继续这个工作。
- en: Mapping JSON to model classes
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 JSON 映射到模型类
- en: Retrofit lets you automatically serialize request bodies and deserialize response
    bodies. In our case, we're interested in deserializing the response body, from
    JSON into Java/Kotlin objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit 允许您自动序列化请求体和反序列化响应体。在我们的情况下，我们对我们将响应体从 JSON 反序列化为 Java/Kotlin 对象感兴趣。
- en: To deserialize the JSON response, we will instruct Retrofit to use the GSON
    deserialization library, but until then, let's have a look at the JSON response
    that our database returns. Remember that we imported a JSON file called `restaurants.json`
    when we populated the Firebase database.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反序列化 JSON 响应，我们将指示 Retrofit 使用 GSON 反序列化库，但在此之前，让我们看看我们的数据库返回的 JSON 响应。记住，当我们填充
    Firebase 数据库时，我们导入了一个名为 `restaurants.json` 的 JSON 文件。
- en: 'Let''s open that file with any text editor and observe its structure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用任何文本编辑器打开该文件并观察其结构：
- en: '![Figure 3.10 – The JSON structure of the Firebase database''s content'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – Firebase 数据库内容的 JSON 结构'
- en: '](img/B17788_03_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_03_10.jpg)'
- en: Figure 3.10 – The JSON structure of the Firebase database's content
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – Firebase 数据库内容的 JSON 结构
- en: 'We can observe the following elements in the JSON response structure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 JSON 响应结构中观察到以下元素：
- en: It contains an array of JSON objects marked by the `[` and `]` identifiers.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含由 `[` 和 `]` 标识符标记的一系列 JSON 对象。
- en: The contents of the JSON array's element are marked by the `{` and `}` identifiers
    and they enclose the JSON object structure of a restaurant.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 数组元素的 内容 由 `{` 和 `}` 标识符标记，并包含餐厅的 JSON 对象结构。
- en: The restaurant JSON object contains four key-value pairs, separated by the `,`
    separator.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅 JSON 对象包含四个键值对，由 `,` 分隔。
- en: The response from our database will be of type `List<?>` since the response
    holds an array of JSON objects. The main question that remains is, what data type
    should our application expect inside that list?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 来自我们数据库的响应将是 `List<?>` 类型，因为响应包含一个 JSON 对象数组。剩下的问题是我们应用程序应该期望列表中包含什么数据类型？
- en: 'To answer that, we must inspect the structure of the restaurant JSON object
    a bit closer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们必须更仔细地检查餐厅 JSON 对象的结构：
- en: '![](img/B17788_03_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_03_11.jpg)'
- en: Figure 3.11 – The structure of the restaurant JSON object
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 餐厅 JSON 对象的结构
- en: 'Here, we can see that the JSON restaurant has four key-value pairs that refer
    to the `id`, `title`, `description`, and `shutdown` statuses of the corresponding
    restaurant. This structure is similar to our `Restaurant.kt` data class within
    the project:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 JSON 餐厅有四个键值对，分别对应餐厅的 `id`、`title`、`description` 和 `shutdown` 状态。这种结构与项目中的
    `Restaurant.kt` 数据类类似：
- en: '[PRE2]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our `Restaurant` also contains the `id`, `title`, and `description` fields.
    We are not interested in the `shutdown` status for now, so it's tempting to use
    the `Restaurant` class as the model for our response, thus making our `getRestaurants()`
    method in `RestaurantsApiService` return `List<Restaurant>` as the response of
    the request.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Restaurant` 还包含 `id`、`title` 和 `description` 字段。目前我们对 `shutdown` 状态不感兴趣，因此使用
    `Restaurant` 类作为响应的模型很诱人，从而使 `RestaurantsApiService` 中的 `getRestaurants()` 方法返回
    `List<Restaurant>` 作为请求的响应。
- en: 'The issue with this approach is that we need to tell Retrofit to match the
    `r_id` key''s value with our `id` field. The same goes for `r_title`, which should
    be matched with the `title` field and so on. We can approach this in two ways:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们需要告诉 Retrofit 将 `r_id` 键的值与我们的 `id` 字段匹配。同样，`r_title` 应该与 `title`
    字段匹配，依此类推。我们可以用两种方法来处理这个问题：
- en: 'Rename the `Restaurant` data class fields so that they match the response keys:
    `r_id`, `r_title`, and so on. In this case, the deserialization will automatically
    match our fields with the fields from the JSON objects since the JSON keys are
    identical to the fields'' names.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Restaurant` 数据类的字段重命名，以便它们与响应键匹配：`r_id`、`r_title` 等。在这种情况下，反序列化将自动将我们的字段与
    JSON 对象的字段匹配，因为 JSON 键与字段名称相同。
- en: Annotate the `Restaurant` data class fields with special serialization matchers
    that tell Retrofit which keys should be matched with each field. This won't change
    the variable names.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊的序列化匹配器注释 `Restaurant` 数据类的字段，以告诉 Retrofit 哪些键应该与每个字段匹配。这不会改变变量名。
- en: The first approach is bad because our `Restaurant` data class would end up with
    fields that contain underscore naming dictated by the server. It would also not
    comply with Kotlin's CamelCase guideline for defining field variables anymore.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法不好，因为我们的 `Restaurant` 数据类最终会包含由服务器指定的下划线命名的字段。它也不再符合 Kotlin 的 CamelCase
    规范来定义字段变量。
- en: 'Let''s choose the second approach, where we specify the serialization keys
    ourselves. To do that, we will tell Retrofit to deserialize the JSON with the
    GSON deserialization library, which is a powerful framework for converting JSON
    strings into Java/Kotlin objects and vice versa:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择第二种方法，其中我们自行指定序列化键。为此，我们将告诉 Retrofit 使用 GSON 反序列化库来反序列化 JSON，这是一个将 JSON
    字符串转换为 Java/Kotlin 对象以及相反方向的强大框架：
- en: 'First, we need to add the GSON library dependency to mark our fields with custom
    serialization keys. Inside the `build.gradle` file in the app module, add the
    dependency for GSON inside the `dependencies` block:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加 GSON 库依赖项来标记我们的字段，使用自定义序列化键。在 app 模块的 `build.gradle` 文件中，在 `dependencies`
    块内添加 GSON 依赖项：
- en: '[PRE3]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by clicking on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `build.gradle` 文件后，请确保将项目与其 Gradle 文件同步。您可以通过点击 **文件** 菜单选项，然后选择 **与 Gradle
    文件同步项目** 来完成此操作。
- en: 'Inside `Restaurant.kt`, add the `@SerializedName` annotation for each field
    and specify the corresponding serialization keys from the JSON structure:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Restaurant.kt` 中，为每个字段添加 `@SerializedName` 注解，并指定来自 JSON 结构的相应序列化键：
- en: '[PRE4]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By doing so, we''ve made sure that Retrofit will correctly match each of the
    JSON key''s values with our corresponding field inside the `Restaurant` data class
    while also matching the data type:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们确保 Retrofit 将正确地将每个 JSON 键的值与 `Restaurant` 数据类中的相应字段匹配，同时匹配数据类型：
- en: 'The `r_id` key matches the `id` field. The `r_id` key has a whole number as
    its value in the JSON structure, so we stored this key''s value in the `id: Int`
    field.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r_id` 键与 `id` 字段匹配。在 JSON 结构中，`r_id` 键的值是一个整数，所以我们将其值存储在 `id: Int` 字段中。'
- en: 'The `r_title` key matches the `title` field. The `r_title` key has text as
    its value marked with the `"` and `"` identifiers, so we stored this key''s value
    in the `title: String` field.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r_title` 键与 `title` 字段匹配。`r_title` 键的值是带有 `"` 和 `"` 标识符的文本，所以我们将其值存储在 `title:
    String` 字段中。'
- en: 'The `r_description` key matches the `description` field. The `r_description`
    key has text as its value marked with the `"` and `"` identifiers, so we stored
    this key''s value in the `description: String` field.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r_description` 键与 `description` 字段匹配。`r_description` 键的值是带有 `"` 和 `"` 标识符的文本，所以我们将其值存储在
    `description: String` 字段中。'
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For now, we are using the Restaurant data model both as the API response model
    and as the domain model that's used throughout the application. Architecturally,
    this practice is not recommended, and we will cover why this is the case and fix
    it in [*Chapter 8*](B17788_08_ePub.xhtml#_idTextAnchor285), *Getting Started with
    Clean Architecture in Android*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在将 Restaurant 数据模型同时用作 API 响应模型和整个应用程序中使用的域模型。从架构角度来看，这种做法并不推荐，我们将在 [*第
    8 章*](B17788_08_ePub.xhtml#_idTextAnchor285) 中解释为什么这样做不合适，并将在 *Android 清洁架构入门*
    中修复它。
- en: 'Update the `getRestaurants()` method inside `RestaurantsApiService` so that
    it returns a `Call` object from the server with the type parameter that matches
    the response that is expected. In our case, that would be `List<Restaurant>`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `RestaurantsApiService` 中的 `getRestaurants()` 方法，使其从服务器返回一个类型参数与预期响应匹配的 `Call`
    对象。在我们的例子中，这将是一个 `List<Restaurant>`：
- en: '[PRE5]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that, our Retrofit API interface has been defined to receive the content
    of the Restaurants database from our Firebase database. The only step left is
    to configure a Retrofit builder instance and execute the request.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们的 Retrofit API 接口已经定义好了，用于从我们的 Firebase 数据库接收餐厅数据库的内容。剩下的唯一步骤是配置一个 Retrofit
    构建器实例并执行请求。
- en: Executing GET requests to the Firebase REST API
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行对 Firebase REST API 的 GET 请求
- en: 'Let''s configure the last component that''s needed to perform requests with
    Retrofit – the `Retrofit.builder` object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置执行请求所需的最后一个组件——`Retrofit.builder` 对象：
- en: 'First, we need to add the GSON Converter library dependency for Retrofit so
    that Retrofit deserializes the JSON response while following the GSON serialization
    annotations we added previously. Inside the `build.gradle` file in the app module,
    add the dependency for the Retrofit GSON converter inside the `dependencies` block:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为 Retrofit 添加 GSON 转换器库依赖，以便 Retrofit 在反序列化 JSON 响应时遵循我们之前添加的 GSON 序列化注解。在应用模块的
    `build.gradle` 文件中，在 `dependencies` 块内添加 Retrofit GSON 转换器的依赖项：
- en: '[PRE6]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by clicking on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `build.gradle` 文件后，请确保将项目与其 Gradle 文件同步。您可以通过点击 **文件** 菜单选项，然后选择 **与 Gradle
    文件同步项目** 来完成此操作。
- en: 'Inside `RestaurantsViewModel`, add a `restInterface` variable of type `RestaurantsApiService`
    and create an `init` block where we will instantiate the `Retrofit.builder` object:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 中，添加一个类型为 `RestaurantsApiService` 的 `restInterface`
    变量，并创建一个 `init` 块，我们将在这里实例化 `Retrofit.builder` 对象：
- en: '[PRE7]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ve added all the necessary pieces for our networking client. Let''s break
    this code down:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的网络客户端添加了所有必要的组件。让我们分析一下这段代码：
- en: First, we've defined a `restInterface` variable of type `RestaurantsApiService`
    that we will call upon to execute the desired network requests. At this point,
    the `restInterface` variable holds no value.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个类型为 `RestaurantsApiService` 的 `restInterface` 变量，我们将调用它来执行所需的网络请求。在此阶段，`restInterface`
    变量没有任何值。
- en: We've added an `init` block to instantiate the Retrofit builder object. As the
    primary constructor can't contain any code, we are placing the initialization
    code in an initializer block prefixed with the `init` keyword.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个 `init` 块来实例化 Retrofit 构建器对象。由于主构造函数不能包含任何代码，我们将初始化代码放置在一个以 `init` 关键字为前缀的初始化块中。
- en: 'We''ve instantiated a `retrofit: Retrofit` variable with the `Retrofit.Builder`
    accessor and specified the following:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们使用 `Retrofit.Builder` 访问器实例化了一个 `retrofit: Retrofit` 变量，并指定了以下内容：'
- en: A `GsonConverterFactory` to explicitly tell Retrofit that we want the JSON to
    be deserialized with the GSON converter, following the `@Serialized` annotations
    we specified in the `Restaurant` data class.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `GsonConverterFactory`，明确告诉 Retrofit 我们想要使用 GSON 转换器反序列化 JSON，遵循我们在 `Restaurant`
    数据类中指定的 `@Serialized` 注解。
- en: A `baseUrl` for all the requests that are to be executed – in your case, replace
    this URL with the URL of your Firebase database.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `baseUrl` 用于执行所有请求——在你的情况下，将此 URL 替换为你的 Firebase 数据库的 URL。
- en: 'Finally, we called `.create()` on the previously obtained `Retrofit` object
    and passed our interface with the desired requests: `RestaurantsApiService`. Behind
    the scenes, Retrofit creates a concrete implementation of our interface that will
    handle all the networking logic, without us having to worry about it. We store
    this instance from Retrofit inside our `restInterface` variable.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在之前获得的 `Retrofit` 对象上调用了 `.create()`，并传递了我们的接口以及所需的请求：`RestaurantsApiService`。幕后，Retrofit
    创建了我们接口的具体实现，该实现将处理所有网络逻辑，我们无需担心这一点。我们将 Retrofit 中的这个实例存储在 `restInterface` 变量中。
- en: Now, we can execute requests – in our case, the request to get the list of restaurants.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行请求——在我们的案例中，是获取餐厅列表的请求。
- en: 'Inside `RestaurantsViewModel`, add the `getRestaurants` method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 内部，添加 `getRestaurants` 方法：
- en: '[PRE8]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve added all the necessary steps for our networking request to be executed.
    Let''s break this code down:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的网络请求执行添加了所有必要的步骤。让我们分解这段代码：
- en: We've obtained a `Call` object called `Call<List<Restaurant>>` from our Retrofit
    `restInterface` variable by calling the `getRestaurants()` interface method. The
    `Call` object represents the invocation of a Retrofit method that sends network
    requests and receives a response. The type parameter of the `Call` object matches
    the response type; that is, `<List<Restaurant>>`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用 `getRestaurants()` 接口方法从 Retrofit 的 `restInterface` 变量中获取了一个名为 `Call<List<Restaurant>>`
    的 `Call` 对象。`Call` 对象代表了调用 Retrofit 方法发送网络请求并接收响应的调用。`Call` 对象的类型参数与响应类型相匹配；即
    `<List<Restaurant>>`。
- en: On the previously obtained `Call` object, we called `execute()`. The `execute()`
    method is the most simple approach to starting a network request with Retrofit
    as it runs the request synchronously on the main thread (the UI thread) and blocks
    it until the response arrives. No network request should block the UI thread yet,
    though we will fix this soon.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前获得的 `Call` 对象上，我们调用了 `execute()` 方法。`execute()` 方法是使用 Retrofit 开始网络请求的最简单方法，因为它在主线程（UI
    线程）上同步运行请求，并在响应到达之前阻塞它。尽管我们很快会解决这个问题，但任何网络请求都不应该阻塞 UI 线程。
- en: The `execute()` method returns a Retrofit `Response` object that allows us to
    see if the response was successful and obtain the resulting body.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`execute()` 方法返回一个 Retrofit `Response` 对象，它允许我们查看响应是否成功，并获取结果体。'
- en: The `body()` accessor returns a nullable list of type `List<Restaurant>>?`.
    We apply the Kotlin `let` extension function and name the list `restaurants`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`body()` 访问器返回一个可能为空的 `List<Restaurant>>?` 类型的列表。我们应用 Kotlin 的 `let` 扩展函数，并将列表命名为
    `restaurants`。'
- en: We pass the resulting `restaurants` list to our `state` object after restoring
    the selections in case of system-initiated process death, similar to what we did
    for the initial state value.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统启动的进程死亡的情况下，我们在恢复选择后，将生成的 `restaurants` 列表传递给我们的 `state` 对象，这与我们为初始状态值所做的方法类似。
- en: With that, we've instructed our `ViewModel` on how to obtain the list of restaurants
    from the database and to pass this result to our screen's state. One issue that
    we will have to address later is that we are not catching any errors that may
    be thrown by Retrofit if the request fails. Until then, let's focus on updating
    the state with the new result.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们指示我们的 `ViewModel` 如何从数据库中获取餐厅列表，并将此结果传递到屏幕的状态中。我们稍后必须解决的问题之一是我们没有捕获
    Retrofit 如果请求失败可能抛出的任何错误。在此之前，让我们专注于使用新的结果更新状态。
- en: '5. Inside `RestaurantsViewModel`, we need to update the state''s initial value
    so that it contains an empty list. This is because, when the screen is first displayed,
    we no longer have restaurants to render – we will get them later in the network
    request. Update the initial value of the `state` object by removing `dummyList`
    and placing an `emptyList()` instead:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 在`RestaurantsViewModel`内部，我们需要更新状态对象的初始值，使其包含一个空列表。这是因为，当屏幕首次显示时，我们不再有餐厅来渲染
    – 我们将在网络请求中稍后获取它们。通过移除`dummyList`并放置一个`emptyList()`来更新`state`对象的初始值：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the `Restaurant.kt` file, remove the `dummyRestaurants` list since we
    will be obtaining the restaurants at runtime through the previously defined request.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Restaurant.kt`文件中，移除`dummyRestaurants`列表，因为我们将通过之前定义的请求在运行时获取餐厅。
- en: 'We want to trigger the network request to obtain the restaurants from the server.
    Inside `RestaurantsScreen.kt`, update the `RestaurantsScreen` composable function
    so that it calls the `getRestaurants()` method of `viewModel`, which will trigger
    the network request to obtain the restaurants from the server:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望触发网络请求以从服务器获取餐厅。在`RestaurantsScreen.kt`内部，更新`RestaurantsScreen`可组合函数，使其调用`viewModel`的`getRestaurants()`方法，这将触发网络请求以从服务器获取餐厅：
- en: '[PRE10]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By calling `viewModel.getRestaurants()`, we are trying to load the list of restaurants
    when the `RestaurantsScreen` composable is composed for the first time. This practice
    is not recommended and we will see in the following steps why that is and how
    we can fix it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`viewModel.getRestaurants()`，我们试图在`RestaurantsScreen`可组合函数首次组合时加载餐厅列表。这种做法是不推荐的，我们将在以下步骤中看到为什么这是不推荐的，以及如何修复它。
- en: 'Add internet permission inside the `AndroidManifest.xml` file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中添加互联网权限：
- en: '[PRE11]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the application by clicking the **Run** button.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**运行**按钮来运行应用程序。
- en: 'Unfortunately, the application will most likely crash. If we check **Logcat**,
    we will notice an exception stack similar to the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，应用程序很可能会崩溃。如果我们检查**Logcat**，我们会注意到一个类似于以下异常堆栈：
- en: '![](img/B17788_03_12.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_03_12.jpg)'
- en: Figure 3.12 – Crash stack trace for executing a network request on the main
    thread
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 在主线程上执行网络请求的崩溃堆栈跟踪
- en: 'The exception that''s been thrown here is a `NetworkOnMainThreadException`
    and it''s clear what''s wrong with our code: we are executing a network request
    on the Main thread.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里抛出的异常是`NetworkOnMainThreadException`，我们很清楚我们的代码哪里出了问题：我们正在主线程上执行网络请求。
- en: This has happened because with the Android Honeycomb SDK, *executing network
    requests on the Main thread is forbidden* because the UI of the application will
    freeze until the response from the server arrives, making the app unusable in
    that timeframe. In other words, we can't and shouldn't use the `.execute()` method
    of a Retrofit `Call` object because the request will run synchronously on the
    Main thread.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在Android Honeycomb SDK中，*在主线程上执行网络请求是被禁止的*，因为应用程序的UI将冻结，直到服务器响应到达，这使得应用程序在该时间段内无法使用。换句话说，我们不能也不应该使用Retrofit
    `Call`对象的`.execute()`方法，因为请求将在主线程上同步运行。
- en: Instead, we can use an alternative that not only will execute the requests asynchronously
    and on a separate thread, but also allow us to handle any errors that are thrown
    by Retrofit.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用一个替代方案，它不仅将以异步方式在单独的线程上执行请求，而且还允许我们处理Retrofit抛出的任何错误。
- en: 'In the `getRestaurants()` method of `ViewModel`, replace the `.execute()` call
    with `.enqueue()`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModel`的`getRestaurants()`方法中，将`.execute()`调用替换为`.enqueue()`：
- en: '[PRE12]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When adding the missing imports for the `Call`, `Callback` and `Response` classes,
    make sure that you''re adding the Retrofit2 imports that start off like this:
    `import retrofit2.*`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当为`Call`、`Callback`和`Response`类添加缺少的导入时，确保你添加的是以`import retrofit2.*`开头的Retrofit2导入。
- en: 'Getting back to the code that we''ve added, let''s look at it in more detail:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们添加的代码，让我们更详细地看看它：
- en: On the `Call` object that we obtained from our `restInterface.getRestaurants()`
    method, we called the `.enqueue()` function. The `enqueue()` call is a better
    alternative to `.execute()` since it runs the network request asynchronously on
    a separate thread, so it will no longer run on the UI thread and it won't block
    the UI.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们从`restInterface.getRestaurants()`方法获得的`Call`对象上，我们调用了`.enqueue()`函数。`.enqueue()`调用是`.execute()`的一个更好的替代方案，因为它在单独的线程上异步运行网络请求，因此它将不再在UI线程上运行，也不会阻塞UI。
- en: The `.enqueue()` function receives a `Callback` object as an argument that allows
    us to listen for success or failure callbacks. The `Callback` object's type parameter
    defines the expected `Response` object. Since we expect a response of type `<List<Restaurant>>`,
    the returned `Callback` type is defined as `Callback<List<Restaurant>>`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.enqueue()` 函数接收一个 `Callback` 对象作为参数，允许我们监听成功或失败回调。`Callback` 对象的类型参数定义了预期的
    `Response` 对象。由于我们期望响应类型为 `<List<Restaurant>>`，返回的 `Callback` 类型被定义为 `Callback<List<Restaurant>>`。'
- en: 'We''ve implemented the required `object : Callback<List<Restaurant>>` and implemented
    its two callbacks:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们实现了所需的 `object : Callback<List<Restaurant>>` 并实现了其两个回调：'
- en: '`onResponse()`, which is the success callback that''s invoked when the network
    request succeeds. It provides us with the initial `Call` object, but more importantly
    the `Response` object; that is, `Response<List<Restaurant>>`. Inside this callback,
    we get the body from the response and update the value of the `state` variable,
    just like we did with `execute()`.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResponse()`，这是在网络请求成功时被调用的成功回调。它为我们提供了初始的 `Call` 对象，但更重要的是 `Response` 对象；即
    `Response<List<Restaurant>>`。在这个回调内部，我们获取响应体并更新 `state` 变量的值，就像我们使用 `execute()`
    时做的那样。'
- en: '`onFailure()`, which is the failure callback. It''s invoked when a network
    exception occurs while talking to the server or when an unexpected exception occurs
    while creating the request or processing the response. This callback provides
    us with the initial `Call` object and the `Throwable` exception that was intercepted
    and whose stack trace we print.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onFailure()`，这是失败回调。当与服务器通信时发生网络异常，或者在创建请求或处理响应时发生意外异常时，它会被调用。这个回调为我们提供了初始的
    `Call` 对象和被拦截的 `Throwable` 异常，我们打印了其堆栈跟踪。'
- en: Now, you can run the application. It shouldn't crash anymore since calling `enqueue()`
    allowed the request to run on a separate thread so that we could safely wait for
    the response without blocking the UI.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用程序。它不应该再崩溃了，因为调用 `enqueue()` 允许请求在单独的线程上运行，这样我们就可以安全地等待响应而不阻塞 UI。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a good practice, make sure that when you're making requests with Retrofit,
    you always call the `enqueue()` function and not `execute()`. You want your users
    to not experience crashes and to be able to interact with the app while they're
    waiting for the network response.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，确保当你使用 Retrofit 发起请求时，始终调用 `enqueue()` 函数而不是 `execute()` 函数。你希望用户在等待网络响应时不会遇到崩溃，并且能够与应用程序进行交互。
- en: Yet even with this addition, there are still two concerning issues with our
    code. Were you able to notice them? Let's try to identify them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了这个添加，我们的代码中仍然存在两个令人担忧的问题。你是否注意到了？让我们尝试识别它们。
- en: Improving the way our app handles network requests
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进应用程序处理网络请求的方式
- en: 'Our application now successfully obtains data from the server dynamically,
    at runtime. Unfortunately, we have made two major mistakes in our code, and both
    are related to how the app handles the requests. Let''s identify them:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在可以成功地在运行时从服务器动态获取数据。不幸的是，我们在代码中犯了两个主要错误，这两个错误都与应用程序处理请求的方式有关。让我们来识别它们：
- en: First, we are not canceling our network request as a cleanup measure. If our
    UI component that is bound to `RestaurantsViewModel` – in our case, `MainActivity`
    – is destroyed before the response from the server can arrive (for example, if
    the user navigates to another activity), we could potentially create a memory
    leak. This is because our `RestaurantsViewModel` would still be tied to the `Callback<List<Restaurant>>`
    object, which waits for the server's response. Due to this, the garbage collector
    won't free up the memory associated with both of their instances.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们没有取消我们的网络请求作为清理措施。如果我们的 UI 组件（在我们的例子中是 `MainActivity`）在服务器响应到达之前被销毁（例如，如果用户导航到另一个活动），我们可能会创建潜在的内存泄漏。这是因为我们的
    `RestaurantsViewModel` 仍然绑定到 `Callback<List<Restaurant>>` 对象上，该对象等待服务器的响应。由于这个原因，垃圾收集器不会释放与这两个实例相关的内存。
- en: Secondly, we are not triggering the network request from a controlled environment.
    The `viewModel.getRestaurants()` method is called inside the `RestaurantsScreen()`
    composable function without any special considerations. This means that every
    time the UI is recomposed, the composable will ask `ViewModel` to execute network
    requests, resulting in possible multiple and redundant requests.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们没有从受控环境中触发网络请求。`viewModel.getRestaurants()` 方法是在 `RestaurantsScreen()`
    组合函数内部被调用的，没有任何特殊考虑。这意味着每次 UI 重新组合时，组合函数都会要求 `ViewModel` 执行网络请求，从而导致可能的多余和重复请求。
- en: Let's focus on the first issue for now.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先关注第一个问题。
- en: Canceling network requests as a cleanup measure
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将取消网络请求作为清理措施
- en: 'The main problem in our `RestaurantsViewModel` is that we are enqueueing a
    `Call` object and we''re waiting for the response through the `Callback` object,
    but we are never canceling that enqueued `Call`. We should cancel it when the
    host `Activity` or `ViewModel` is cleared to prevent memory leaks. Let''s do that
    here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `RestaurantsViewModel` 中的主要问题是我们在排队一个 `Call` 对象，并通过 `Callback` 对象等待响应，但我们从未取消那个排队的
    `Call`。我们应该在宿主 `Activity` 或 `ViewModel` 被清除时取消它，以防止内存泄漏。让我们在这里做这件事：
- en: 'Inside `RestaurantsViewModel`, define a class variable of type `Call` with
    the `List<Restaurant>>` type parameter. Call this variable `restaurantsCall` as
    we will use it to hold a reference to our enqueued `Call` object:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 中，定义一个类型为 `Call` 且具有 `List<Restaurant>` 类型参数的类变量。将其命名为
    `restaurantsCall`，因为我们将会使用它来保存对排队的 `Call` 对象的引用：
- en: '[PRE13]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've marked `restaurantsCall` as a `lateinit` variable to instantiate it later
    when we perform the network request.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `restaurantsCall` 标记为 `lateinit` 变量，以便在执行网络请求时稍后实例化它。
- en: 'Inside the `getRestaurants()` method of `RestaurantsViewModel`, assign the
    `Call` object that you obtained from the `restInterface.getRestaurants()` method
    call to the `restaurantsCall` member variable and call `enqueue()` on it:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 的 `getRestaurants()` 方法内部，将您从 `restInterface.getRestaurants()`
    方法调用中获得的 `Call` 对象分配给 `restaurantsCall` 成员变量，并对其调用 `enqueue()`：
- en: '[PRE14]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside `RestaurantsViewModel`, override the `onCleared()` method and call the
    `cancel()` method of the `restaurantCall` object:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 中，重写 `onCleared()` 方法并调用 `restaurantCall` 对象的 `cancel()`
    方法：
- en: '[PRE15]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `onCleared()` callback method is provided by the Jetpack `ViewModel` and
    is called just before `ViewModel` is destroyed as a consequence of the attached
    activity/fragment or composable being destroyed or removed from the composition.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCleared()` 回调方法由 Jetpack `ViewModel` 提供，并在 `ViewModel` 由于附加的活动/片段或组合函数被销毁或从组合中移除而销毁之前被调用。'
- en: This callback represents the perfect opportunity for us to cancel any ongoing
    work – or in our case, to cancel the pending `Call` object that's enqueued in
    the `restaurantCall` object. This way, we prevent leaking memory and therefore
    fix the first issue in our code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调为我们提供了一个完美的机会来取消任何正在进行的工作——或者在我们的情况下，取消在 `restaurantCall` 对象中排队的挂起 `Call`
    对象。这样，我们防止了内存泄漏，并因此修复了我们代码中的第一个问题。
- en: Now, it's time to focus on the second issue, where the `RestaurantsScreen()`
    composable calls the `viewModel.getRestaurants()` method without any special considerations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候关注第二个问题，即 `RestaurantsScreen()` 组合函数在没有任何特殊考虑的情况下调用了 `viewModel.getRestaurants()`
    方法。
- en: Triggering network requests from a controlled environment
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从受控环境中触发网络请求
- en: The `viewModel.getRestaurants()` method is called because we want to apply a
    **side effect** in our UI. A side effect is a change that's made to the state
    of the application that usually happens outside the scope of a composable function.
    In our case, the side effect is that we need to start loading the restaurants
    for the first time when the user enters the screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `viewModel.getRestaurants()` 方法是因为我们想在 UI 中应用一个 **副作用**。副作用是对应用程序状态所做的更改，通常发生在组合函数的作用域之外。在我们的情况下，副作用是我们需要在用户进入屏幕时首次开始加载餐厅。
- en: As a rule of thumb, composables should be side-effect free, but in our application,
    we need to know when to trigger the network request, and what better place than
    the moment when our UI is initially composed?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，组合函数应该是无副作用的，但在我们的应用程序中，我们需要知道何时触发网络请求，以及还有什么比我们的 UI 首次组合时更好的时机呢？
- en: The problem with the existing approach of simply calling a method on `ViewModel`
    from the composable layer is that the Compose UI can be recomposed many times
    on the screen. For example, when an animation is rendered, the Compose UI is recomposed
    many times to execute the animation's keyframes. On every recomposition of the
    UI, our composable calls the `getRestaurants()` method on `RestaurantsViewModel`,
    which, in turn, executes network requests to obtain the restaurants from the server,
    which could result in multiple and redundant requests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的简单从组合层调用`ViewModel`方法的方法存在一个问题，那就是Compose UI可以在屏幕上多次重新组合。例如，当渲染动画时，Compose
    UI会多次重新组合以执行动画的关键帧。在每次UI重新组合时，我们的组合都会调用`RestaurantsViewModel`上的`getRestaurants()`方法，这会反过来执行网络请求以从服务器获取餐厅，这可能导致多次和冗余的请求。
- en: 'To prevent this issue from happening, Compose has the right tool for us to
    handle side-effects efficiently: the **Effects** API.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，Compose为我们提供了处理副作用的有效工具：**Effects** API。
- en: An *effect* is a composable function that, instead of emitting UI elements,
    causes side effects that run when a composition process completes. Such composables
    are based on the Kotlin Coroutine API, which allows you to run async work in their
    bodies. However, we will disregard coroutines for now as we will cover them in
    [*Chapter 4*](B17788_04_ePub.xhtml#_idTextAnchor115), *Handling Async Operations
    with Coroutines*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**effect**是一个组合函数，它不是发出UI元素，而是在组合过程完成后执行副作用。这些组合基于Kotlin Coroutine API，允许你在它们的主体中运行异步工作。然而，我们现在将忽略协程，因为我们将在[*第4章*](B17788_04_ePub.xhtml#_idTextAnchor115)中介绍它们，即使用协程处理异步操作。
- en: In Compose, there are many types of effect composables that we can use but we
    will not go too deep into that. In our case, though, a suitable effect could be
    the `LaunchedEffect` composable since it allows us to run a task only once when
    it first enters composition.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Compose中，有许多类型的effect组合函数我们可以使用，但我们将不会深入探讨这一点。然而，在我们的情况下，一个合适的效果可以是`LaunchedEffect`组合函数，因为它允许我们在第一次进入组合时只运行一次任务。
- en: 'The signature of `LaunchedEffect` is simple – it contains a `key1` parameter
    and a `block` parameter where we can execute our code. For now, we should ignore
    the Coroutine terminology and just think of the `block` function parameter as
    a block of code that can be executed asynchronously:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`LaunchedEffect`的签名很简单——它包含一个`key1`参数和一个`block`参数，我们可以在这里执行我们的代码。现在，我们应该忽略协程术语，只需将`block`函数参数视为可以异步执行的代码块：'
- en: '![Figure 3.13 – The signature of the LaunchedEffect composable'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – `LaunchedEffect`组合函数的签名'
- en: '](img/B17788_03_13.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – `LaunchedEffect`组合函数的签名'
- en: Figure 3.13 – The signature of the LaunchedEffect composable
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – `LaunchedEffect`组合函数的签名
- en: When `LaunchedEffect` enters the composition process, it runs the `block` parameter
    function, which is passed as an argument. The execution of the block will be canceled
    if `LaunchedEffect` leaves the composition. If `LaunchedEffect` is recomposed
    with different keys that have been passed to the `key1` parameter, the existing
    execution of the block of code will be canceled and a new iteration of execution
    will be launched.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当`LaunchedEffect`进入组合过程时，它会运行`block`参数函数，该函数作为参数传递。如果`LaunchedEffect`离开组合，则取消执行该块。如果`LaunchedEffect`使用传递给`key1`参数的不同键重新组合，则现有的代码块执行将被取消，并启动新的执行迭代。
- en: 'Now that we know how `LaunchedEffect` works, we can agree that it seems a viable
    solution for our issue, at least for now: we want to make sure that the call to
    `ViewModel` is only executed once on the initial composition, so `LaunchedEffect`
    seems to suffice our needs.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`LaunchedEffect`是如何工作的，我们可以同意它似乎是我们问题的可行解决方案，至少目前是这样：我们想要确保在初始组合中只执行一次对`ViewModel`的调用，所以`LaunchedEffect`似乎能满足我们的需求。
- en: 'Let''s add a `LaunchedEffect` to prevent our UI from asking for restaurants
    from `ViewModel` repeatedly on every recomposition:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`LaunchedEffect`来防止我们的UI在每次重新组合时反复从`ViewModel`请求餐厅：
- en: 'Inside the `RestaurantsScreen` composable, wrap the `viewModel.getRestaurants()`
    call in a `LaunchedEffect` composable:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen`组合函数内部，将`viewModel.getRestaurants()`调用包裹在`LaunchedEffect`组合函数中：
- en: '[PRE16]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To implement the `LaunchedEffect` composable, we did the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`LaunchedEffect`组合函数，我们做了以下操作：
- en: We passed a `String` hardcoded value of `"request_restaurants"` to the `key1`
    parameter. We passed a hardcoded value to the `key1` argument because we want
    the block of code passed inside the `LaunchedEffect` composable to not execute
    on every recomposition. We could have passed any constant to `key1`, yet what's
    important here is that the value shouldn't change over time.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将硬编码的 `"request_restaurants"` 字符串值传递给 `key1` 参数。我们向 `key1` 参数传递硬编码的值，因为我们希望传递给
    `LaunchedEffect` composable 中的代码块在每次重组时都不执行。我们可以向 `key1` 传递任何常量，但这里重要的是这个值不应该随时间改变。
- en: We passed our code that calls the `getRestaurants()` method on our `ViewModel`
    inside the `block` parameter of the effect. Since the `block` parameter is the
    last parameter of the `LaunchedEffect` composable and is a function, we used the
    trailing lambda syntax.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在效果的 `block` 参数中传递了调用 `getRestaurants()` 方法的代码。由于 `block` 参数是 `LaunchedEffect`
    composable 的最后一个参数，并且是一个函数，我们使用了尾随 lambda 语法。
- en: Run the application. Now, the code inside `LaunchedEffect` should only be executed
    once.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。现在，`LaunchedEffect` 内部的代码应该只执行一次。
- en: Yet even with this addition, our code still has an issue. If you try rotating
    the emulator or device you're testing with, you will trigger a configuration change
    and another network will be executed. But we mentioned previously that `LaunchedEffect`
    will only execute the `viewModel.getRestaurants()` call once, so why is this happening?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 即使添加了这一功能，我们的代码仍然存在问题。如果你尝试旋转你正在测试的模拟器或设备，将会触发配置更改，并执行另一个网络请求。但我们之前提到，`LaunchedEffect`
    只会执行一次 `viewModel.getRestaurants()` 调用，那么为什么会出现这种情况呢？
- en: '`LaunchedEffect` works fine – the issue lies in the activity being destroyed
    on configuration change. If the activity is destroyed, the UI will be composed
    again from scratch, and for all it knows, `LaunchedEffect` will run the code inside
    the `block` parameter for the first time.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`LaunchedEffect` 工作正常——问题在于配置更改时活动被销毁。如果活动被销毁，UI 将从头开始重新组合，并且对于它来说，`LaunchedEffect`
    将会第一次运行 `block` 参数中的代码。'
- en: Can you think of a better alternative to get around the issue of the activity
    being destroyed due to configuration changes?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一个更好的替代方案来解决这个问题，即避免由于配置更改而导致活动被销毁吗？
- en: 'An alternative would be to use the `ViewModel` component because it survives
    configuration changes. If we trigger the request only once in `RestaurantsViewModel`,
    we no longer care if a configuration change occurs – the request will not be executed
    again. Follow these steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用 `ViewModel` 组件，因为它会存活于配置更改。如果我们只在 `RestaurantsViewModel` 中触发一次请求，我们就不再关心配置更改是否发生——请求将不会再次执行。按照以下步骤操作：
- en: 'Inside `RestaurantsViewModel`, locate the `init` block and inside it, call
    `getRestaurants()`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 中，找到 `init` 块，并在其中调用 `getRestaurants()`：
- en: '[PRE17]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `init` block is called once when an instance of `ViewModel` is created,
    so placing our network request here is a safer bet than at the UI level in any
    composable. Make sure you've placed the `getRestaurants()` call after the instantiation
    of the `restInterface` variable since the `getRestaurants()` method depends on
    that variable being ready to work.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `ViewModel` 实例时，`init` 块只会被调用一次，因此在这里放置我们的网络请求比在任何 composable 的 UI 层面上更安全。确保你在
    `restInterface` 变量实例化之后放置 `getRestaurants()` 调用，因为 `getRestaurants()` 方法依赖于该变量准备好工作。
- en: 'Still inside `RestaurantsViewModel`, navigate to the `getRestaurants()` method
    and mark it as `private`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `RestaurantsViewModel` 中，导航到 `getRestaurants()` 方法，将其标记为 `private`：
- en: '[PRE18]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We no longer need to expose this method publicly to the UI since it's now only
    called inside `ViewModel`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要将此方法公开暴露给 UI，因为它现在仅在 `ViewModel` 内部调用。
- en: Inside the `RestaurantsScreen` composable, remove the `LaunchedEffect` composable
    function with all the code inside it since we no longer need it.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreen` composable 中，移除包含所有代码的 `LaunchedEffect` composable 函数，因为我们不再需要它。
- en: Run the application. The network request should not be executed again when a
    configuration change is made since the `RestaurantsViewModel` instance is preserved
    and the code inside its `init` block is not executed again.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。在做出配置更改时，网络请求不应该再次执行，因为 `RestaurantsViewModel` 实例被保留，并且其 `init` 块中的代码不会再次执行。
- en: We've taken quite a few steps to make sure that our application handles network
    requests correctly, and this was a great first step toward creating a modern application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经采取了相当多的步骤来确保我们的应用程序正确处理网络请求，这是创建现代应用程序的一个很好的第一步。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how mobile apps communicate with remote web APIs
    using HTTP connections and REST APIs. Then, we created a database for our Restaurants
    application with the help of Firebase and populated it with content.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了移动应用程序如何使用HTTP连接和REST API与远程Web API通信。然后，我们在Firebase的帮助下为我们的Restaurants应用程序创建了一个数据库，并填充了内容。
- en: After that, we explored what Retrofit is and how it abstracts the complexity
    associated with handling network requests and responses within HTTP connections
    between apps and web APIs.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们探讨了Retrofit是什么以及它是如何抽象处理应用程序与Web API之间HTTP连接中的网络请求和响应的复杂性的。
- en: Then, we executed a network request with Retrofit in our Restaurants application
    and learned how the JSON content that is sent by the server can be parsed or deserialized
    by our Retrofit networking client. We also learned how to correctly wait for network
    responses and how to notify the application when responses arrive.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在我们的Restaurants应用程序中使用Retrofit执行了一个网络请求，并学习了服务器发送的JSON内容是如何被我们的Retrofit网络客户端解析或反序列化的。我们还学习了如何正确等待网络响应，以及如何在响应到达时通知应用程序。
- en: Finally, we solved some common issues that occur when our applications communicate
    with web APIs asynchronously to retrieve data, especially in the context of Compose.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解决了当我们的应用程序异步与Web API通信以检索数据时出现的一些常见问题，尤其是在Compose的上下文中。
- en: 'In the next chapter, we''ll explore a very efficient tool in Android for async
    work that comes bundled with Kotlin: coroutines!'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Android中一个用于异步工作的非常高效的工具，这个工具与Kotlin一起提供：协程！
- en: Further reading
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'With the help of custom annotations inside the Retrofit interface, this library
    hides most of the complexity associated with handling network requests. We''ve
    seen that with simple `GET` requests in our `RestaurantsApiService` interface
    when we annotated our request with the `@GET` annotation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在Retrofit接口内部使用自定义注解的帮助下，这个库隐藏了与处理网络请求相关的绝大多数复杂性。我们看到了在我们的`RestaurantsApiService`接口中，当我们使用`@GET`注解注释我们的请求时，简单的`GET`请求：
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Yet apart from plain `GET` operations, such Retrofit interfaces can also handle
    other request types, such as `PUT,` `POST`, and `DELETE`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了普通的`GET`操作之外，这样的Retrofit接口还可以处理其他请求类型，如`PUT`、`POST`和`DELETE`。
- en: 'For example, if you need to define a request that passes some data to the server
    that is likely to be stored, you can use a `POST` request by adding the `@POST`
    annotation to your desired method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您需要定义一个将一些数据传递给服务器的请求，这些数据可能需要存储，您可以通过添加`@POST`注解到您希望的方法来使用`POST`请求：
- en: '[PRE20]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To understand how to use Retrofit for such cases, or more advanced ones, check
    out the official documentation: https://square.github.io/retrofit/.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用Retrofit处理此类情况，或更高级的情况，请查看官方文档：https://square.github.io/retrofit/
