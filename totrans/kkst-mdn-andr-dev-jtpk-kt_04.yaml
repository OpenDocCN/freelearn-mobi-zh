- en: '*Chapter 3*: Displaying Data from REST APIs with Retrofit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be taking a break from the Jetpack libraries and focusing
    on adding real data within our Restaurants application by using a very popular
    networking library on Android called **Retrofit**.
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit is an HTTP client library that lets you create an HTTP client declaratively
    and abstracts most of the underlying complexity associated with handling network
    requests and responses. This library allows us to connect to a real web API and
    retrieve real data within our app.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Understanding how apps communicate with remote servers* section, we
    will focus on exploring how mobile applications retrieve and send data to remote
    web APIs. In the *Creating and populating your database with Firebase* section,
    we will create a database for our Restaurants application with the help of Firebase
    and fill it with JSON content.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Exploring Retrofit as an HTTP networking client for Android* section,
    we will learn what Retrofit is, and how it can help us create network requests
    within our Restaurants app.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the *Improving the way our app handles network requests* section,
    we will tackle some common issues that occur when Android applications create
    async work to retrieve data from web APIs. We will identify those issues and fix
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how apps communicate with remote servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and populating your database with Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Retrofit as an HTTP networking client for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the way our app handles network requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before jumping in, let's set up the technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building Compose-based Android projects with Retrofit usually requires just
    your day-to-day tools. However, to follow along smoothly, make sure you have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that IDE interface and other
    generated code files might differ from the ones used throughout this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin 1.6.10 or newer installed in Android Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Restaurants app code from the previous chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Google account to create a Firebase project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting point for this chapter is the Restaurants application that we developed
    in the previous chapter. If you haven't followed the coding steps from the previous
    chapter, access the starting point for this chapter by navigating to the `Chapter_02`
    directory of this book's GitHub repository and importing the Android project entitled
    `chapter_2_restaurants_app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the solution code for this chapter, navigate to the `Chapter_03`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how apps communicate with remote servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications need to show real content that can change over time and
    need to avoid hardcoding data, as we did in the previous chapters. Let's briefly
    cover how they do that.
  prefs: []
  type: TYPE_NORMAL
- en: Most network-connected apps use the HTTP protocol to send or receive data in
    the format of JSON from REST web services through a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a lot of words we''ve just thrown at you, so let''s break them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypertext Transfer Protocol** (**HTTP**) is a protocol for asynchronously
    fetching various resources from web servers. In our case, the resources are the
    data that our application needs to display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is the data format of the content
    that''s transferred in HTTP requests. It''s structured, lightweight, and human-readable
    as it consists of key-value pairs that are easy to parse and commonly used as
    a suitable format for data exchange between apps and web servers. In our app,
    we will receive the data from the web server in such JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`, `PUT`, `POST`, `DELETE`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **REST API** is an **application programming interface** (**API**) that conforms
    to the constraints of the REST architecture and allows you to interact with REST
    web services. The REST API is the contract and the entry point that's used by
    apps to obtain or send data to and from the backend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to visualize the relationship between these entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Overview of HTTP communication between apps and web servers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Overview of HTTP communication between apps and web servers
  prefs: []
  type: TYPE_NORMAL
- en: We want to implement something similar for our Restaurants application. For
    this to work, we will need a REST server. For the sake of simplicity, we will
    use the Firebase Realtime Database and create a database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and populating your database with Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've only used hardcoded data as the source of content for our Restaurants
    app. Since almost every real application uses dynamic data that comes from a backend
    server through a REST API, it's time to step up our game and create a database
    that simulates such a remote API.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this for free with the help of Firebase. Firebase is backed by Google
    and represents a **Backend-as-a-Service** (**BaaS**), which allows us to build
    a database very easily. We will use the Realtime Database service from Firebase
    without using the Firebase Android SDK. Even though such a database is not a proper
    REST web service, we can use its database URL as a REST endpoint and pretend that
    that is our REST interface, therefore simulating a real backend.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the *Technical requirements* section, make sure that you
    have an existing Google account or that you create one beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating a database:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Firebase console and log into your Google account by going to
    [https://console.firebase.google.com/](https://console.firebase.google.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Firebase project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Creating a new Firebase project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Creating a new Firebase project
  prefs: []
  type: TYPE_NORMAL
- en: Input the name of your project (it should be about restaurants!) and press **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, in the next dialog, you can opt out from Google Analytics since
    we won't be using the Firebase SDK. Press **Continue** again. At this point, the
    project should be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the left menu, expand the **Build** tab, search for **Realtime Database**,
    and then select it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Accessing Realtime Database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Accessing Realtime Database
  prefs: []
  type: TYPE_NORMAL
- en: On the newly displayed page, create a new database by clicking **Create Database**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Set up database** dialog, select a location for your database and
    then click **Next**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Setting up a Realtime Database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Setting up a Realtime Database
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If later on any network calls to your Firebase Database fail for no apparent
    reason, you might find yourself in a Firebase restricted location – as I am writing
    this chapter, because of the current situation caused by the eastern war, all
    internet providers from Romania are restricted and any network calls to Firebase
    Database are failing. If this happens to you, try selecting a different location
    for your Realtime Database instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the same dialog, define your security rules by selecting **Start in test
    mode** and then clicking **Enable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Setting up the security rules of your database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Setting up the security rules of your database
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The default security rules for test mode allow anyone to view or modify the
    content within your database for the next 30 days since creation. After these
    30 days, if you want to keep using the database in test mode, you will need to
    update the security rules by changing the timestamp values for the `".read"` and
    the `".write"` fields with greater timestamp values. To skip this, we will just
    set the `".read"` and the `".write"` fields to `true` in the next steps. However,
    Firebase might still restrict your access if you leave the database open for access
    without any rules indefinitely – that's why I recommend you visit the Firebase
    console and check the security rules for your database often to make sure that
    access was not revoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should be redirected to your database''s main page in the
    **Data** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Observing the Realtime Database main page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Observing the Realtime Database main page
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now notice your URL for this database: [https://restaurants-db-default-rtdb.firebaseio.com/](https://restaurants-db-default-rtdb.firebaseio.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Your URL should be similar but may differ, depending on the name you have chosen
    for your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the database seems to be empty; we only have an empty root node being
    called after our database: `restaurants-db-default-rtdb`. It''s time to add data
    to our database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the solution code for this chapter by navigating to the `Chapter_03`
    directory of this book''s GitHub repository. Then, select the `restaurants.json`
    file. You can also access it by following this link: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, download the `restaurants.json` file as we will need it shortly.
    To do that, press on the **Raw** button provided by the Github website and then
    right click the document that has been opened and download the JSON file by selecting
    **Saves As**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the Firebase console, press on the three-dots menu to the right
    of the database URL, and select **Import JSON**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Importing JSON content into Realtime Database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Importing JSON content into Realtime Database
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you select the `restaurants.json` file that you've previously
    downloaded from the book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for the page to refresh and check out the content that is populated in
    the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Observing the content''s structure in our database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Observing the content's structure in our database
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that our database contains a list of `Restaurant` class: an
    ID, title, and description. The restaurants in our database also contain other
    fields that we will not need right now, so let''s ignore them.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare the structure of the content in our database with the one from
    the JSON file we''ve uploaded, we can see that it is very similar: we have a `restaurants`
    node that contains an array of objects, each containing consistent key-value pairs.
    The only exception is the presence of the indexes (0, 1, 2, and so on) for each
    restaurant, which were automatically created by Firebase. We should ignore these
    as they won''t affect us.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, even though we set the security rules to **Test Mode** previously, let's
    revisit them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move away from the `".read"` key''s value to `"true"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17788_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Updating security rules in Realtime Database
  prefs: []
  type: TYPE_NORMAL
- en: Press `true` since we are testing and not publishing anything to production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can access the database URL as a simple REST endpoint, simulating a
    real REST server that we can connect to. To experiment, copy the URL of your newly
    created database, append `restaurants.json`, and paste it into your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing this URL should return the JSON response of our restaurants, whose
    structure we will cover shortly. Until then, we need to instruct our application
    to create HTTP requests to obtain that data from our newly created database. So,
    let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Retrofit as an HTTP networking client for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the application to obtain data from our database, we need to implement an
    HTTP client that will send network requests to the REST API of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of working with the HTTP library provided by default by Android, we
    will use the **Retrofit** HTTP client library, which lets you create an HTTP client
    that is very easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to develop an HTTP client that interfaces with a REST API, you will
    have to take care of a lot of things – from making connections, retrying failed
    requests, or caching to response parsing and error handling. Retrofit saves you
    development time and potential headaches as it abstracts most of the underlying
    complexity associated with handling network requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Retrofit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Retrofit to the Restaurants application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping JSON to model classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing GET requests to the Firebase REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with some basics about Retrofit!
  prefs: []
  type: TYPE_NORMAL
- en: Using Retrofit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retrofit makes networking simple in Android apps. It allows us to consume web
    services easily, create network requests, and receive responses while reducing
    the boilerplate code that's usually associated with their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit also allows you to easily add custom headers and request types, file
    uploads, mocking responses, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute network requests with Retrofit, we need the following three components:'
  prefs: []
  type: TYPE_NORMAL
- en: An interface that defines the HTTP operations that need to be performed. Such
    an interface can specify request types such as `GET`, `PUT`, `POST`, `DELETE`,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Retrofit.Builder` instance that creates a concrete implementation of the
    interface we defined previously. The Builder API allows us to define networking
    parameters such as the HTTP client type, the URL endpoint for the HTTP operations,
    the converter to deserialize the JSON responses, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model classes that allow Retrofit to know how to map the deserialized JSON objects
    to regular data classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enough with the theory – let's try to implement Retrofit and use the components
    we introduced previously in our Restaurants application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Retrofit to the Restaurants application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to connect our Restaurants application to the newly created Firebase
    database and send HTTP network requests to it. More specifically, when the Restaurants
    application is launched and the `RestaurantsScreen` composable is composed, we
    want to get the list of restaurants at runtime and not depend on hardcoded content
    within the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do that with the help of Retrofit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `build.gradle` file in the app module, add the dependency for Retrofit
    inside the `dependencies` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by clicking on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an interface that defines the HTTP operations that are executed between
    our app and the database. Do so by clicking on the application package, selecting
    `RestaurantsApiService` as the name and select **Interface** as the type. Inside
    the newly created file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break down the code we''ve just added into meaningful actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit turns your HTTP API into a simple Java/Kotlin interface, so we've created
    a `RestaurantsApiService` interface that defines the HTTP actions we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've defined a `getRestaurants` method inside the interface that returns a
    `Call` object with an undefined response type marked by Kotlin's `Any type`. Each
    `Call` from `RestaurantsApiService` can make a synchronous or asynchronous HTTP
    request to the remote web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've annotated the `getRestaurants` method with the `@GET` annotation, thereby
    telling Retrofit that this method should execute a `GET` HTTP action to obtain
    data from our web server. Inside the `@GET` annotation, we passed the endpoint's
    path, which represents the `restaurants` node within our Firebase database. This
    means that when we execute this request, the `restaurants.json` endpoint will
    be appended to the base URL of the HTTP client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that we can use our Firebase Realtime Database URL as a REST API.
    To access a specific node, such as the `restaurants` node of our database, we
    also appended the `.json` format to make sure that the Firebase database will
    behave like a REST API and return a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, after we instantiate a Retrofit builder, the library will know how
    to turn our `getRestaurants` method into a proper HTTP call.
  prefs: []
  type: TYPE_NORMAL
- en: But before that, you have probably noticed that the `getRestaurants` HTTP request
    from our interface has its response type defined as `Any`. We expect to receive
    the JSON content of our restaurants mapped to data classes that we can use in
    our code. So, let's work on that next.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping JSON to model classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retrofit lets you automatically serialize request bodies and deserialize response
    bodies. In our case, we're interested in deserializing the response body, from
    JSON into Java/Kotlin objects.
  prefs: []
  type: TYPE_NORMAL
- en: To deserialize the JSON response, we will instruct Retrofit to use the GSON
    deserialization library, but until then, let's have a look at the JSON response
    that our database returns. Remember that we imported a JSON file called `restaurants.json`
    when we populated the Firebase database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open that file with any text editor and observe its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The JSON structure of the Firebase database''s content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – The JSON structure of the Firebase database's content
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe the following elements in the JSON response structure:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains an array of JSON objects marked by the `[` and `]` identifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the JSON array's element are marked by the `{` and `}` identifiers
    and they enclose the JSON object structure of a restaurant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The restaurant JSON object contains four key-value pairs, separated by the `,`
    separator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response from our database will be of type `List<?>` since the response
    holds an array of JSON objects. The main question that remains is, what data type
    should our application expect inside that list?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer that, we must inspect the structure of the restaurant JSON object
    a bit closer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17788_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The structure of the restaurant JSON object
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that the JSON restaurant has four key-value pairs that refer
    to the `id`, `title`, `description`, and `shutdown` statuses of the corresponding
    restaurant. This structure is similar to our `Restaurant.kt` data class within
    the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our `Restaurant` also contains the `id`, `title`, and `description` fields.
    We are not interested in the `shutdown` status for now, so it's tempting to use
    the `Restaurant` class as the model for our response, thus making our `getRestaurants()`
    method in `RestaurantsApiService` return `List<Restaurant>` as the response of
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue with this approach is that we need to tell Retrofit to match the
    `r_id` key''s value with our `id` field. The same goes for `r_title`, which should
    be matched with the `title` field and so on. We can approach this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the `Restaurant` data class fields so that they match the response keys:
    `r_id`, `r_title`, and so on. In this case, the deserialization will automatically
    match our fields with the fields from the JSON objects since the JSON keys are
    identical to the fields'' names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate the `Restaurant` data class fields with special serialization matchers
    that tell Retrofit which keys should be matched with each field. This won't change
    the variable names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first approach is bad because our `Restaurant` data class would end up with
    fields that contain underscore naming dictated by the server. It would also not
    comply with Kotlin's CamelCase guideline for defining field variables anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s choose the second approach, where we specify the serialization keys
    ourselves. To do that, we will tell Retrofit to deserialize the JSON with the
    GSON deserialization library, which is a powerful framework for converting JSON
    strings into Java/Kotlin objects and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add the GSON library dependency to mark our fields with custom
    serialization keys. Inside the `build.gradle` file in the app module, add the
    dependency for GSON inside the `dependencies` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by clicking on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `Restaurant.kt`, add the `@SerializedName` annotation for each field
    and specify the corresponding serialization keys from the JSON structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By doing so, we''ve made sure that Retrofit will correctly match each of the
    JSON key''s values with our corresponding field inside the `Restaurant` data class
    while also matching the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `r_id` key matches the `id` field. The `r_id` key has a whole number as
    its value in the JSON structure, so we stored this key''s value in the `id: Int`
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `r_title` key matches the `title` field. The `r_title` key has text as
    its value marked with the `"` and `"` identifiers, so we stored this key''s value
    in the `title: String` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `r_description` key matches the `description` field. The `r_description`
    key has text as its value marked with the `"` and `"` identifiers, so we stored
    this key''s value in the `description: String` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For now, we are using the Restaurant data model both as the API response model
    and as the domain model that's used throughout the application. Architecturally,
    this practice is not recommended, and we will cover why this is the case and fix
    it in [*Chapter 8*](B17788_08_ePub.xhtml#_idTextAnchor285), *Getting Started with
    Clean Architecture in Android*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `getRestaurants()` method inside `RestaurantsApiService` so that
    it returns a `Call` object from the server with the type parameter that matches
    the response that is expected. In our case, that would be `List<Restaurant>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, our Retrofit API interface has been defined to receive the content
    of the Restaurants database from our Firebase database. The only step left is
    to configure a Retrofit builder instance and execute the request.
  prefs: []
  type: TYPE_NORMAL
- en: Executing GET requests to the Firebase REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s configure the last component that''s needed to perform requests with
    Retrofit – the `Retrofit.builder` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add the GSON Converter library dependency for Retrofit so
    that Retrofit deserializes the JSON response while following the GSON serialization
    annotations we added previously. Inside the `build.gradle` file in the app module,
    add the dependency for the Retrofit GSON converter inside the `dependencies` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by clicking on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `RestaurantsViewModel`, add a `restInterface` variable of type `RestaurantsApiService`
    and create an `init` block where we will instantiate the `Retrofit.builder` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ve added all the necessary pieces for our networking client. Let''s break
    this code down:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we've defined a `restInterface` variable of type `RestaurantsApiService`
    that we will call upon to execute the desired network requests. At this point,
    the `restInterface` variable holds no value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've added an `init` block to instantiate the Retrofit builder object. As the
    primary constructor can't contain any code, we are placing the initialization
    code in an initializer block prefixed with the `init` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve instantiated a `retrofit: Retrofit` variable with the `Retrofit.Builder`
    accessor and specified the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `GsonConverterFactory` to explicitly tell Retrofit that we want the JSON to
    be deserialized with the GSON converter, following the `@Serialized` annotations
    we specified in the `Restaurant` data class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `baseUrl` for all the requests that are to be executed – in your case, replace
    this URL with the URL of your Firebase database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we called `.create()` on the previously obtained `Retrofit` object
    and passed our interface with the desired requests: `RestaurantsApiService`. Behind
    the scenes, Retrofit creates a concrete implementation of our interface that will
    handle all the networking logic, without us having to worry about it. We store
    this instance from Retrofit inside our `restInterface` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can execute requests – in our case, the request to get the list of restaurants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `RestaurantsViewModel`, add the `getRestaurants` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ve added all the necessary steps for our networking request to be executed.
    Let''s break this code down:'
  prefs: []
  type: TYPE_NORMAL
- en: We've obtained a `Call` object called `Call<List<Restaurant>>` from our Retrofit
    `restInterface` variable by calling the `getRestaurants()` interface method. The
    `Call` object represents the invocation of a Retrofit method that sends network
    requests and receives a response. The type parameter of the `Call` object matches
    the response type; that is, `<List<Restaurant>>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the previously obtained `Call` object, we called `execute()`. The `execute()`
    method is the most simple approach to starting a network request with Retrofit
    as it runs the request synchronously on the main thread (the UI thread) and blocks
    it until the response arrives. No network request should block the UI thread yet,
    though we will fix this soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `execute()` method returns a Retrofit `Response` object that allows us to
    see if the response was successful and obtain the resulting body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `body()` accessor returns a nullable list of type `List<Restaurant>>?`.
    We apply the Kotlin `let` extension function and name the list `restaurants`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass the resulting `restaurants` list to our `state` object after restoring
    the selections in case of system-initiated process death, similar to what we did
    for the initial state value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we've instructed our `ViewModel` on how to obtain the list of restaurants
    from the database and to pass this result to our screen's state. One issue that
    we will have to address later is that we are not catching any errors that may
    be thrown by Retrofit if the request fails. Until then, let's focus on updating
    the state with the new result.
  prefs: []
  type: TYPE_NORMAL
- en: '5. Inside `RestaurantsViewModel`, we need to update the state''s initial value
    so that it contains an empty list. This is because, when the screen is first displayed,
    we no longer have restaurants to render – we will get them later in the network
    request. Update the initial value of the `state` object by removing `dummyList`
    and placing an `emptyList()` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `Restaurant.kt` file, remove the `dummyRestaurants` list since we
    will be obtaining the restaurants at runtime through the previously defined request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to trigger the network request to obtain the restaurants from the server.
    Inside `RestaurantsScreen.kt`, update the `RestaurantsScreen` composable function
    so that it calls the `getRestaurants()` method of `viewModel`, which will trigger
    the network request to obtain the restaurants from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By calling `viewModel.getRestaurants()`, we are trying to load the list of restaurants
    when the `RestaurantsScreen` composable is composed for the first time. This practice
    is not recommended and we will see in the following steps why that is and how
    we can fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add internet permission inside the `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application by clicking the **Run** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unfortunately, the application will most likely crash. If we check **Logcat**,
    we will notice an exception stack similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17788_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Crash stack trace for executing a network request on the main
    thread
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception that''s been thrown here is a `NetworkOnMainThreadException`
    and it''s clear what''s wrong with our code: we are executing a network request
    on the Main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: This has happened because with the Android Honeycomb SDK, *executing network
    requests on the Main thread is forbidden* because the UI of the application will
    freeze until the response from the server arrives, making the app unusable in
    that timeframe. In other words, we can't and shouldn't use the `.execute()` method
    of a Retrofit `Call` object because the request will run synchronously on the
    Main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use an alternative that not only will execute the requests asynchronously
    and on a separate thread, but also allow us to handle any errors that are thrown
    by Retrofit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `getRestaurants()` method of `ViewModel`, replace the `.execute()` call
    with `.enqueue()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When adding the missing imports for the `Call`, `Callback` and `Response` classes,
    make sure that you''re adding the Retrofit2 imports that start off like this:
    `import retrofit2.*`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to the code that we''ve added, let''s look at it in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: On the `Call` object that we obtained from our `restInterface.getRestaurants()`
    method, we called the `.enqueue()` function. The `enqueue()` call is a better
    alternative to `.execute()` since it runs the network request asynchronously on
    a separate thread, so it will no longer run on the UI thread and it won't block
    the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.enqueue()` function receives a `Callback` object as an argument that allows
    us to listen for success or failure callbacks. The `Callback` object's type parameter
    defines the expected `Response` object. Since we expect a response of type `<List<Restaurant>>`,
    the returned `Callback` type is defined as `Callback<List<Restaurant>>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve implemented the required `object : Callback<List<Restaurant>>` and implemented
    its two callbacks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResponse()`, which is the success callback that''s invoked when the network
    request succeeds. It provides us with the initial `Call` object, but more importantly
    the `Response` object; that is, `Response<List<Restaurant>>`. Inside this callback,
    we get the body from the response and update the value of the `state` variable,
    just like we did with `execute()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onFailure()`, which is the failure callback. It''s invoked when a network
    exception occurs while talking to the server or when an unexpected exception occurs
    while creating the request or processing the response. This callback provides
    us with the initial `Call` object and the `Throwable` exception that was intercepted
    and whose stack trace we print.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you can run the application. It shouldn't crash anymore since calling `enqueue()`
    allowed the request to run on a separate thread so that we could safely wait for
    the response without blocking the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a good practice, make sure that when you're making requests with Retrofit,
    you always call the `enqueue()` function and not `execute()`. You want your users
    to not experience crashes and to be able to interact with the app while they're
    waiting for the network response.
  prefs: []
  type: TYPE_NORMAL
- en: Yet even with this addition, there are still two concerning issues with our
    code. Were you able to notice them? Let's try to identify them.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the way our app handles network requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application now successfully obtains data from the server dynamically,
    at runtime. Unfortunately, we have made two major mistakes in our code, and both
    are related to how the app handles the requests. Let''s identify them:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are not canceling our network request as a cleanup measure. If our
    UI component that is bound to `RestaurantsViewModel` – in our case, `MainActivity`
    – is destroyed before the response from the server can arrive (for example, if
    the user navigates to another activity), we could potentially create a memory
    leak. This is because our `RestaurantsViewModel` would still be tied to the `Callback<List<Restaurant>>`
    object, which waits for the server's response. Due to this, the garbage collector
    won't free up the memory associated with both of their instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, we are not triggering the network request from a controlled environment.
    The `viewModel.getRestaurants()` method is called inside the `RestaurantsScreen()`
    composable function without any special considerations. This means that every
    time the UI is recomposed, the composable will ask `ViewModel` to execute network
    requests, resulting in possible multiple and redundant requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's focus on the first issue for now.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling network requests as a cleanup measure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main problem in our `RestaurantsViewModel` is that we are enqueueing a
    `Call` object and we''re waiting for the response through the `Callback` object,
    but we are never canceling that enqueued `Call`. We should cancel it when the
    host `Activity` or `ViewModel` is cleared to prevent memory leaks. Let''s do that
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `RestaurantsViewModel`, define a class variable of type `Call` with
    the `List<Restaurant>>` type parameter. Call this variable `restaurantsCall` as
    we will use it to hold a reference to our enqueued `Call` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've marked `restaurantsCall` as a `lateinit` variable to instantiate it later
    when we perform the network request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `getRestaurants()` method of `RestaurantsViewModel`, assign the
    `Call` object that you obtained from the `restInterface.getRestaurants()` method
    call to the `restaurantsCall` member variable and call `enqueue()` on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `RestaurantsViewModel`, override the `onCleared()` method and call the
    `cancel()` method of the `restaurantCall` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `onCleared()` callback method is provided by the Jetpack `ViewModel` and
    is called just before `ViewModel` is destroyed as a consequence of the attached
    activity/fragment or composable being destroyed or removed from the composition.
  prefs: []
  type: TYPE_NORMAL
- en: This callback represents the perfect opportunity for us to cancel any ongoing
    work – or in our case, to cancel the pending `Call` object that's enqueued in
    the `restaurantCall` object. This way, we prevent leaking memory and therefore
    fix the first issue in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to focus on the second issue, where the `RestaurantsScreen()`
    composable calls the `viewModel.getRestaurants()` method without any special considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering network requests from a controlled environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `viewModel.getRestaurants()` method is called because we want to apply a
    **side effect** in our UI. A side effect is a change that's made to the state
    of the application that usually happens outside the scope of a composable function.
    In our case, the side effect is that we need to start loading the restaurants
    for the first time when the user enters the screen.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, composables should be side-effect free, but in our application,
    we need to know when to trigger the network request, and what better place than
    the moment when our UI is initially composed?
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the existing approach of simply calling a method on `ViewModel`
    from the composable layer is that the Compose UI can be recomposed many times
    on the screen. For example, when an animation is rendered, the Compose UI is recomposed
    many times to execute the animation's keyframes. On every recomposition of the
    UI, our composable calls the `getRestaurants()` method on `RestaurantsViewModel`,
    which, in turn, executes network requests to obtain the restaurants from the server,
    which could result in multiple and redundant requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this issue from happening, Compose has the right tool for us to
    handle side-effects efficiently: the **Effects** API.'
  prefs: []
  type: TYPE_NORMAL
- en: An *effect* is a composable function that, instead of emitting UI elements,
    causes side effects that run when a composition process completes. Such composables
    are based on the Kotlin Coroutine API, which allows you to run async work in their
    bodies. However, we will disregard coroutines for now as we will cover them in
    [*Chapter 4*](B17788_04_ePub.xhtml#_idTextAnchor115), *Handling Async Operations
    with Coroutines*.
  prefs: []
  type: TYPE_NORMAL
- en: In Compose, there are many types of effect composables that we can use but we
    will not go too deep into that. In our case, though, a suitable effect could be
    the `LaunchedEffect` composable since it allows us to run a task only once when
    it first enters composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of `LaunchedEffect` is simple – it contains a `key1` parameter
    and a `block` parameter where we can execute our code. For now, we should ignore
    the Coroutine terminology and just think of the `block` function parameter as
    a block of code that can be executed asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The signature of the LaunchedEffect composable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – The signature of the LaunchedEffect composable
  prefs: []
  type: TYPE_NORMAL
- en: When `LaunchedEffect` enters the composition process, it runs the `block` parameter
    function, which is passed as an argument. The execution of the block will be canceled
    if `LaunchedEffect` leaves the composition. If `LaunchedEffect` is recomposed
    with different keys that have been passed to the `key1` parameter, the existing
    execution of the block of code will be canceled and a new iteration of execution
    will be launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how `LaunchedEffect` works, we can agree that it seems a viable
    solution for our issue, at least for now: we want to make sure that the call to
    `ViewModel` is only executed once on the initial composition, so `LaunchedEffect`
    seems to suffice our needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `LaunchedEffect` to prevent our UI from asking for restaurants
    from `ViewModel` repeatedly on every recomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsScreen` composable, wrap the `viewModel.getRestaurants()`
    call in a `LaunchedEffect` composable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement the `LaunchedEffect` composable, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We passed a `String` hardcoded value of `"request_restaurants"` to the `key1`
    parameter. We passed a hardcoded value to the `key1` argument because we want
    the block of code passed inside the `LaunchedEffect` composable to not execute
    on every recomposition. We could have passed any constant to `key1`, yet what's
    important here is that the value shouldn't change over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We passed our code that calls the `getRestaurants()` method on our `ViewModel`
    inside the `block` parameter of the effect. Since the `block` parameter is the
    last parameter of the `LaunchedEffect` composable and is a function, we used the
    trailing lambda syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the application. Now, the code inside `LaunchedEffect` should only be executed
    once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yet even with this addition, our code still has an issue. If you try rotating
    the emulator or device you're testing with, you will trigger a configuration change
    and another network will be executed. But we mentioned previously that `LaunchedEffect`
    will only execute the `viewModel.getRestaurants()` call once, so why is this happening?
  prefs: []
  type: TYPE_NORMAL
- en: '`LaunchedEffect` works fine – the issue lies in the activity being destroyed
    on configuration change. If the activity is destroyed, the UI will be composed
    again from scratch, and for all it knows, `LaunchedEffect` will run the code inside
    the `block` parameter for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of a better alternative to get around the issue of the activity
    being destroyed due to configuration changes?
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative would be to use the `ViewModel` component because it survives
    configuration changes. If we trigger the request only once in `RestaurantsViewModel`,
    we no longer care if a configuration change occurs – the request will not be executed
    again. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `RestaurantsViewModel`, locate the `init` block and inside it, call
    `getRestaurants()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `init` block is called once when an instance of `ViewModel` is created,
    so placing our network request here is a safer bet than at the UI level in any
    composable. Make sure you've placed the `getRestaurants()` call after the instantiation
    of the `restInterface` variable since the `getRestaurants()` method depends on
    that variable being ready to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still inside `RestaurantsViewModel`, navigate to the `getRestaurants()` method
    and mark it as `private`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We no longer need to expose this method publicly to the UI since it's now only
    called inside `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `RestaurantsScreen` composable, remove the `LaunchedEffect` composable
    function with all the code inside it since we no longer need it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application. The network request should not be executed again when a
    configuration change is made since the `RestaurantsViewModel` instance is preserved
    and the code inside its `init` block is not executed again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've taken quite a few steps to make sure that our application handles network
    requests correctly, and this was a great first step toward creating a modern application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how mobile apps communicate with remote web APIs
    using HTTP connections and REST APIs. Then, we created a database for our Restaurants
    application with the help of Firebase and populated it with content.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we explored what Retrofit is and how it abstracts the complexity
    associated with handling network requests and responses within HTTP connections
    between apps and web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we executed a network request with Retrofit in our Restaurants application
    and learned how the JSON content that is sent by the server can be parsed or deserialized
    by our Retrofit networking client. We also learned how to correctly wait for network
    responses and how to notify the application when responses arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we solved some common issues that occur when our applications communicate
    with web APIs asynchronously to retrieve data, especially in the context of Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll explore a very efficient tool in Android for async
    work that comes bundled with Kotlin: coroutines!'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the help of custom annotations inside the Retrofit interface, this library
    hides most of the complexity associated with handling network requests. We''ve
    seen that with simple `GET` requests in our `RestaurantsApiService` interface
    when we annotated our request with the `@GET` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Yet apart from plain `GET` operations, such Retrofit interfaces can also handle
    other request types, such as `PUT,` `POST`, and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you need to define a request that passes some data to the server
    that is likely to be stored, you can use a `POST` request by adding the `@POST`
    annotation to your desired method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how to use Retrofit for such cases, or more advanced ones, check
    out the official documentation: https://square.github.io/retrofit/.'
  prefs: []
  type: TYPE_NORMAL
