["```swift\nclass Person {    var name: String\n    var age: Int\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    func canVote() -> Bool {\n        return age >= 18\n    }\n}\n```", "```swift\nclass PersonView: UIView {    var nameLabel: UILabel\n    var ageLabel: UILabel\n    var canVoteLabel: UILabel\n    init(frame: CGRect) {\n        super.init(frame: frame)\n        nameLabel = UILabel()\n        ageLabel = UILabel()\n        canVoteLabel = UILabel()\n    }\n    func configure(with person: Person) {\n        nameLabel.text = person.name\n        ageLabel.text = \"\\(person.age)\"\n        canVoteLabel.text = person.canVote() ? \"Can vote\" :\n            \"Can't vote\"\n    }\n}\n```", "```swift\nclass PersonViewController: UIViewController {    var person: Person\n    var personView: PersonView\n    init(person: Person) {\n        self.person = person\n        personView = PersonView()\n        super.init(nibName: nil, bundle: nil)\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        view.addSubview(personView)\n        personView.configure(with: person)\n    }\n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```", "```swift\nimport Foundationimport Combine\nclass StatusViewModel {\n    private let networkService: NetworkService\n    private var cancellables = Set<AnyCancellable>()\n    private let statusDidChange = PassthroughSubject\n        <String, Never>()\n    var status: String = \"Loading...\" {\n        didSet {\n            statusDidChange.send(status)\n        }\n    }\n    init(networkService: NetworkService) {\n        self.networkService = networkService\n    }\n    func fetchStatus() {\n        networkService.fetchStatus()\n            .sink { completion in\n                switch completion {\n                case .failure(let error):\n                    self.status = \"Error: \\\n                        (error.localizedDescription)\"\n                case .finished:\n                    break\n                }\n            } receiveValue: { isReady in\n                self.status = isReady ? \"Ready\" : \"Not ready\"\n            }\n            .store(in: &cancellables)\n    }\n```", "```swift\n    func observeStatusChange(handler: @escaping (String) ->        Void) {\n        statusDidChange\n            .receive(on: RunLoop.main)\n            .sink { status in\n                handler(status)\n            }\n            .store(in: &cancellables)\n    }\n}\n```", "```swift\nimport UIKitclass StatusLabel: UILabel {\n    var viewModel: StatusViewModel? {\n        didSet {\n            viewModel?.observeStatusChange { [weak self]\n                status in\n                self?.text = status\n            }\n            viewModel?.fetchStatus()\n        }\n    }\n}\n```", "```swift\nimport UIKitclass ViewController: UIViewController {\n    let networkService = NetworkService()\n    let statusViewModel = StatusViewModel(networkService:\n        NetworkService())\n    let statusLabel = StatusLabel()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        statusLabel.frame = CGRect(x: 50, y: 50, width:\n            200, height: 50)\n        statusLabel.textAlignment = .center\n        view.addSubview(statusLabel)\n        statusLabel.viewModel = statusViewModel\n    }\n}\n```", "```swift\nimport Foundationimport Combine\nclass MyViewModel {\n    private let navigationSubject = PassthroughSubject\n        <Void, Never>()\n    var navigation: AnyPublisher<Void, Never> {\n        return navigationSubject.eraseToAnyPublisher()\n    }\n    func didTapButton() {\n        navigationSubject.send(())\n    }\n}\n```", "```swift\nimport UIKitimport Combine\nclass MyViewController: UIViewController {\n    var viewModel: MyViewModel!\n    private var cancellables = Set<AnyCancellable>()\n    let button = UIButton()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        viewModel.navigation\n            .sink { [weak self] in\n                self?.navigateToDetails()\n            }\n            .store(in: &cancellables)\n    }\n    private func setupUI() {\n        button.addTarget(self, action: #selector\n            (didTapButton), for: .touchUpInside)\n    }\n    @objc private func didTapButton() {\n        viewModel.didTapButton()\n    }\n    private func navigateToDetails() {\n        let detailsViewController = DetailsViewController()\n        navigationController?.pushViewController\n        (detailsViewController, animated: true)\n    }\n}\n```", "```swift\nimport Foundationimport Combine\nclass MyViewModel {\n    private let didTapButtonSubject = PassthroughSubject\n        <Void, Never>()\n    var didTapButtonPublisher: AnyPublisher<Void, Never> {\n        return didTapButtonSubject.eraseToAnyPublisher()\n    }\n    func didTapButton() {\n        didTapButtonSubject.send(())\n    }\n}\n```", "```swift\nclass MyMainCoordinator: MyCoordinator {    private var cancellables = Set<AnyCancellable>()\n    func start() {\n        let viewModel = MyViewModel()\n        viewModel.didTapButtonPublisher\n            .sink { [weak self] _ in self?.didTapButton()\n            }\n            .store(in: &cancellables)\n        let viewController = MyViewController()\n        viewController.viewModel = viewModel\n        navigationController.pushViewController\n            (viewController, animated: true)\n    }\n    func didTapButton() {\n        let detailsViewController = DetailsViewController()\n        navigationController.pushViewController\n            (detailsViewController, animated: true)\n    }\n}\n```", "```swift\nimport Foundationimport Combine\nclass MyViewModel {\n    let didTapButton = PassthroughSubject<Void, Never>()\n    @Published var labelValue: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    init() {\n        didTapButton\n            .map { \"Ready\" }\n            .assign(to: \\.labelValue, on: self)\n            .store(in: &cancellables)\n    }\n}\n```", "```swift\nimport XCTestimport Combine\n@testable import MyProject\nclass MyViewModelTests: XCTestCase {\n    func testLabelValue() {\n        let viewModel = MyViewModel()\n        let labelValueExpectation = viewModel.$labelValue\n            .dropFirst() // Ignore initial value\n            .sink { labelValue in XCTAssertEqual(labelValue, \"Ready\")\n            }\n        viewModel.didTapButton.send(())\n        labelValueExpectation.cancel()\n    }\n}\n```", "```swift\nclass MyViewController: UIViewController {    private let dataManager: DataManager\n    init(dataManager: DataManager) {\n        self.dataManager = dataManager\n        super.init(nibName: nil, bundle: nil)\n    }\n}\nlet viewController = MyViewController\n    (dataManager: dataManager)\n```", "```swift\n// Define a view controller that depends on a data managerclass MyViewController: UIViewController {\n    var dataManager: DataManager?\n    }\n}\nlet dataManager = ConcreteDataManager()\nlet viewController = MyViewController()\nviewController.dataManager = dataManager\n```", "```swift\n// Define a view controller that depends on a data managerclass MyViewController: UIViewController {\n    func fetchData(dataManager: DataManager) {\n        let data = dataManager.fetchData()\n    }\n}\nlet dataManager = ConcreteDataManager()\nlet viewController = MyViewController()\nviewController.fetchData(dataManager: dataManager)\n```", "```swift\nprotocol DataManager {    func fetchData() -> [String]\n}\nclass ConcreteDataManager: DataManager {\n    func fetchData() -> [String] {\n        return [\"Item 1\", \"Item 2\", \"Item 3\"]\n    }\n}\nclass OtherDataManager: DataManager {\n    func fetchData() -> [String] {\n        return [\"Item A\", \"Item B\", \"Item C\"]\n    }\n}\nclass MyViewController: UIViewController {\n    let dataManager: DataManager\n    init(dataManager: DataManager) {\n        self.dataManager = dataManager\n        super.init(nibName: nil, bundle: nil)\n    }\n}\nlet concreteDataManager = ConcreteDataManager()\nlet viewController1 = MyViewController\n    (dataManager: concreteDataManager)\nlet otherDataManager = OtherDataManager()\nlet viewController2 = MyViewController\n    (dataManager: otherDataManager)\n```", "```swift\nprotocol MyViewDelegate: AnyObject {    func didTapButton()\n}\nclass MyView: UIView {\n    weak var delegate: MyViewDelegate?\n    private let button = UIButton(type: .system)\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        button.addTarget(self, action: #selector\n            (buttonTapped), for: .touchUpInside)\n        addSubview(button)\n    }\n    override func layoutSubviews() {\n        super.layoutSubviews()\n        button.frame = bounds\n    }\n    @objc private func buttonTapped() {\n        delegate?.didTapButton()\n    }\n}\nclass MyViewController: UIViewController, MyViewDelegate {\n    private let myView = MyView()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        myView.delegate = self\n        view.addSubview(myView)\n    }\n    func didTapButton() {\n        print(\"Button tapped!\")\n    }\n}\n```", "```swift\nfinal class MySingleton {    static let shared = MySingleton()\n    private init() {}\n    func doSomething() {\n        print(\"Doing something...\")\n    }\n}\nMySingleton.shared.doSomething()\n```", "```swift\nstatic let shared = Singleton()\n```", "```swift\nclass Service {    static let shared = Service()\n    func doSomething() {}\n}\nclass Client {\n    func useService() {\n        Service.shared.doSomething()\n    }\n}\n```", "```swift\nclass Service {    func doSomething() {}\n}\nclass Client {\n    let service: Service\n    init(service: Service) {\n        self.service = service\n    }\n    func useService() {\n        service.doSomething()\n    }\n}\nlet service = Service()\nlet client = Client(service: service)\n```", "```swift\nprotocol Service {    func doSomething()\n}\nclass ServiceImpl: Service {\n    func doSomething() {}\n}\nlet service = ServiceImpl()\nlet client = Client(service: service)\n```", "```swift\nMySingleton.shared.doSomething()DispatchQueue.global().async {\n    DispatchQueue.main.async {\n        MySingleton.shared.doSomething()\n    }\n}\n```", "```swift\nclass MySingleton {    static private var privateShared: MySingleton?\n    static private let lock = NSLock()\n    private init() {\n        // Perform any necessary setup or initialization\n    }\n    static func threadSafeShared() -> MySingleton {\n        lock.lock()\n        defer {\n            lock.unlock()\n        }\n        if privateShared == nil {\n            privateShared = MySingleton()\n        }\n        return privateShared!\n    }\n    func doSomething() {\n        // Perform some action or logic\n    }\n}\n```", "```swift\nfunc downloadImage(url: URL, completion: @escaping    (UIImage?) -> Void) {\n    let queue = DispatchQueue.global(qos: .background)\n    queue.async {\n        if let data = try? Data(contentsOf: url),\n           let image = UIImage(data: data) {completion(image)\n        } else {\n            completion(nil)\n        }\n    }\n}\n```", "```swift\nclass ImageDownloadOperation: Operation {    let url: URL\n    var result: UIImage?\n    init(url: URL) {\n        self.url = url\n    }\n    override func main() {\n        if let data = try? Data(contentsOf: url),\n           let image = UIImage(data: data) {\n            result = image\n        }\n    }\n}\nlet urls: [URL] = // an array of image URLs\nlet queue = OperationQueue()\nlet downloadOperations = urls.map { url in\n    ImageDownloadOperation(url: url)\n}\nqueue.addOperations(downloadOperations,\n    waitUntilFinished: true)\nlet images = downloadOperations.compactMap { $0.result }\n```", "```swift\nqueue.maxConcurrentOperationCount = 3\n```", "```swift\nlet downloadOp1 = ImageDownloadOperation(url: url1)let downloadOp2 = ImageDownloadOperation(url: url2)\ndownloadOp2.addDependency(downloadOp1)\n```", "```swift\nclass SharedResource {    private var count = 0\n    private let lock = NSLock()\n    func increment() {\n        lock.lock()\n        count += 1\n        lock.unlock()\n    }\n    func getCount() -> Int {\n        lock.lock()\n        let result = count\n        lock.unlock()\n        return result\n    }\n}\n```", "```swift\nfunc loadJSONFile() -> Future<Data, Error> {    return Future { promise in\n        DispatchQueue.global().async {\n            let fileURL = FileManager.default.urls(for:\n                .libraryDirectory, in: .userDomainMask)[0].\n                    appendingPathComponent(\"articles.json\")\n            do {\n                let data = try Data(contentsOf: fileURL)\n                promise(.success(data))\n            } catch {\n                promise(.failure(error))\n            }\n        }\n    }\n}\n```", "```swift\nlet newArticles = loadJSONFile()    .decode(type: [Article].self, decoder: JSONDecoder())\n    .map { articles -> [Article] in\n        let lastUpdate = UserDefaults.standard.object(\n         forKey: \"lastUpdate\") as? Date ?? Date.distantPast\n        return articles.filter { $0.publishedAt > lastUpdate }\n    }\n    .eraseToAnyPublisher()\n```"]