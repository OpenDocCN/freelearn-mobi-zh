- en: Data Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing simple data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and writing a text file to internal storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and writing a text file to external storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including resource files in your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing data in the background using a Loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing external storage with scoped directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since most applications, big or small, require saving data – from default user
    selections to user accounts – Android offers many options. From saving a simple
    value to creating full databases using SQLite, storage options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shared preferences: Simple name/value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Internal storage: Data files in private storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'External storage: Data files in private or public storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLite database: Private data (can be made public through a Content Provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud storage: Private server or service provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are benefits and trade-offs to using internal and external storage. We
    will list some of the differences here to help you decide which option best fits
    your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal storage**:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike external storage, internal storage is always available but generally
    has less free space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are not accessible to the user (unless the device has root access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are automatically deleted when your app is uninstalled (or with the Clear
    Cache/Cleanup File option in the App Manager)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External storage**:'
  prefs: []
  type: TYPE_NORMAL
- en: The device may not have external storage or it may be inaccessible (such as
    when it's connected to a computer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are accessible to the user (and other apps) without requiring root access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are not deleted when your app is uninstalled (unless you use `getExternalFilesDir()`
    to get app-specific public storage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will demonstrate working with shared preferences, internal
    and external storage, and SQLite databases. For cloud storage, take a look at
    the internet recipes in [Chapter 12](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),
    *Telephony, Networks*.
  prefs: []
  type: TYPE_NORMAL
- en: Storing simple data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a common requirement to store simple data, and Android makes it simple
    using the Preferences API. It's not limited to just user preferences either; you
    can store any of the primitive data types using a name/value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll demonstrate saving a name from an `EditText` and displaying it when
    the application starts. The following screenshots shows how the application looks
    the first time with no saved name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ed2bbe2-b637-4865-a352-2db38ed9d601.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an example of how it looks after saving a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/306a0343-f644-4791-b986-16282f6f2ad9.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `Preferences`. Use the default Phone
    & Tablet options and select Empty Activity in the Add an Activity to Mobile dialog.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the existing TextView to display a Welcome back message and create
    a new `EditText` button to save the name. Start by opening `activity_main.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing TextView with the following new views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `ActivityMain.java` and add the following global declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to `onCreate()` to save a reference to `EditText` and
    to load any saved name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `saveName()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator. Since we are demonstrating persisting
    data, it loads the name during `onCreate()`, so save a name and restart the program
    to see it load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To load the name, we first get a reference to `SharedPreference` and call the
    `getString()` method. We pass in the key for our name/value pair (we created a
    constant called `NAME`) and the default value to return if the key is not found.
  prefs: []
  type: TYPE_NORMAL
- en: To save the preference, we first need to get a reference to the Preference Editor.
    We use `putString()` with our `NAME` constant and follow it with `commit().` Without
    `commit()`, the change will not be saved.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our example stores all the preferences in a single file. We can also store preferences
    in different files using `getSharedPreferences()` and passing in the name. One
    example where this option could be useful is you wanted to have separate profiles
    in a multi-user app.
  prefs: []
  type: TYPE_NORMAL
- en: Read and write a text file to internal storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When simple name/value pairs are not sufficient, Android also supports regular
    file operations, including working with text and binary data.
  prefs: []
  type: TYPE_NORMAL
- en: The following recipe demonstrates how to read and write a file to internal or
    private storage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `InternalStorageFile`. Use
    the default Phone & Tablet options and select Empty Activity in the Add an Activity
    to Mobile dialog.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate both reading and writing text, we''ll need a layout with an
    `EditText` and two buttons. Start by opening `main_activity.xml` and follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing `<TextView>` element with the following views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open `ActivityMain.java` and add the following global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `onCreate()` method, after `setContentView ()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `writeFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `readFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the `InputStream` and `FileOutputStream` classes to read and write, respectively.
    Writing to the file is as simple as getting the text from `EditText `and calling
    the `write()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Reading back the contents is a little more involved. We could use the `FileInputStream`
    class for reading, but when working with text, the helper classes make it easier.
    In our example, we open the file with `openFileInput()`, which returns an `InputStream`
    object. We then use `InputStream` to get a `BufferedReader`, which offers the
    `ReadLine()` method. We loop through each line in the file and append it to our
    `StringBuilder`. When we're finished reading the file, we assign the text to `EditText`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example used the private storage to save the file. Here's how you
    can use the cache folder.
  prefs: []
  type: TYPE_NORMAL
- en: Caching files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If all you need is to temporarily store data, you can also use the cache folder.
    The following method returns the cache folder as a `File` object (the next recipe
    demonstrates working with the `File` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The main benefit of the cache folder is that the system can clear the cache
    if running low on storage space. (The user can also clear the cache folder from
    Apps Management in Settings.)
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your app downloads news articles, you could store those in the
    cache. When your app starts, you can display the news already downloaded. These
    are files that are not required to make your app work. If the system is low on
    resources, the cache can be cleared without adversely affecting your app. (Even
    though the system may clear the cache, it's still a good idea for your app to
    remove old files as well.)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipe, *Read and write a text file to external storage*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write a text file to external storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of reading and writing files to external storage is basically the
    same as using internal storage. The difference is in obtaining a reference to
    the storage location. Also, as mentioned in the *Introduction*, external storage
    may not be available, so it's best to check availability before attempting to
    access it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will read and write a text file, as we did in the previous recipe.
    We'll also demonstrate how to check the external storage state before we access
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `ExternalStorageFile`. Use
    the default Phone & Tablet options and select Empty Activity on the Add an Activity
    to Mobile dialog. We will use the same layout as the previous recipe, so you can
    just copy and paste if you typed it in already. Otherwise, use the layout from
    step 1 in the previous recipe, *Read and write a text file to internal storage*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously in the *Getting ready* section, we''ll use the layout
    from the previous recipe. With the layout file done, the first step will be to
    add permission to access the write to external storage. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Android Manifest and add the following permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `ActivityMain.java` and add the following global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `onCreate()` method, after `setContentView()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following two methods to check the storage state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method to verify the app has permission to access the external
    storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `writeFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `readFile()`method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator with external storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading and writing files are basically the same for both internal and external
    storage. The main difference is that we should check for the availability of the
    external storage before attempting to access it, which we do with the `isExternalStorageWritable()`
    and `isExternalStorageReadable()` methods. When checking the storage state, `MEDIA_MOUNTED`
    means we can read and write to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the internal storage example, we request the working path, which we
    do in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The actual reading and writing is done with the same classes, as it is just
    the location that is different.
  prefs: []
  type: TYPE_NORMAL
- en: It is not safe to hard code an external folder path. The path can vary between
    versions of the OS and especially between hardware manufacturers. It is always
    best to call `getExternalStorageDirectory()` as shown.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably noticed the `checkStoragePermission()` function from step 5 wasn't
    mentioned. This is because permissions aren't specific to storage but are required
    for the app to access various device features. Unlike the previous recipe, which
    used local app storage, "external" storage is considered risky for the user. (It
    wouldn't be good if just any app could go through a user's private files.) For
    that reason, the app must make additional effort to check if it has the required
    permission to access storage. If it does not, the user will be prompted. Note
    that this additional dialog is coming from the OS, not the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: When you first run the app, if you are prompted for permission but still get
    an error writing, exit the app and restart. For a more in-depth explanation and
    handling of the new Android permission model, see the *See also...* section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting public folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getExternalStorageDirectory()` method returns the root folder of the external
    storage. If you want to obtain specific public folders, such as the `Music` or
    `Ringtone` folder, use `getExternalStoragePublicDirectory()` and pass in the desired
    folder type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Checking available space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One issue consistent between internal and external storage is limited space.
    If you know how much space you will need ahead of time, you can call the `getFreeSpace()`
    method on the `File` object. (`getTotalSpace()` will return the total space.)
    Here is a simple example, using the call to `getFreeSpace()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many helper methods available through the `File` object, including
    deleting a file. If we wanted to delete the text file we created in the example,
    we could call `delete()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Working with directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it''s called a `File` object, it supports directory commands as well,
    such as making and removing directories. If you want to make or remove a directory,
    build the `File` object, then call the respective methods: `mkdir()` and `delete()`.
    (There''s also a method called `mkdirs()` (plural) that will create parent folders
    as well.)'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the link in the *See also* section for a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing files from being included in galleries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android employs a **media scanner** that automatically includes sound, video,
    and image files in system collections, such as the Image Gallery. To exclude your
    directory, create an empty file called `.nomedia` (note the preceding period)
    in the same directory as the files you wish to exclude.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on the Android 6.0 permission model, see the corresponding
    recipe in [Chapter 15](98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml),* Getting Your
    App Ready for the Play Store*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of methods available in the `File` class, visit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://developer.android.com/reference/java/io/File.html](http://developer.android.com/reference/java/io/File.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Including resource files in your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android provides two options for including files in your project: the `raw`
    folder and the `assets` folder. Which option you use depends on your requirements.
    To start, we''ll give a brief overview of each option to help you decide the best
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raw files**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Included in the resource directory: `/res/raw`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a resource, accessed through the raw identifier: `R.raw.<resource>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A good place for storing media files such as MP3, MP4, and OGG files
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset files**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a file compiled in your APK (does not provide a resource ID)
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Access files using their filenames, generally making them easier to use with
    dynamically created names
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some APIs do not support a Resource Identifier and therefore require including
    as an Asset
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, `raw` files are easier to work with since they are accessed through
    the resource identifier. As we'll demonstrate in this recipe, the main difference
    is how you access the file. In this example, we will load both a `raw` text file
    and an `asset` text file and display the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `ReadingResourceFiles`. Use
    the default Phone & Tablet options and select Empty Activity in the Add an Activity
    to Mobile dialog.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate reading content from both resource locations, we''ll create
    a split layout. We also need to create both resource folders as they are not included
    in the default Android project. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml` and replace the contents with the following layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `raw` resource folder in the `res` folder. It will read as follows:
    `res/raw`. You can easily create it manually or let Android Studio do it for you
    by right-clicking on the `res` folder and selecting New | Android Resource Directory.
    When the Select Resource Directory dialog opens, select raw as the `Resource type`,
    as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5e832b7e-dd40-4271-a0f3-82b56494d0bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a new text file by right-clicking on the `raw` folder and select New
    | File. Name the file `raw_text.txt` and type some text in the file. (This text
    will be displayed when you run the application.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `asset` folder. The `asset` folder is trickier to create manually
    as it needs to be at the correct folder level. Fortunately, Android Studio provides
    a menu option that makes creating it very easy. Go to the File menu (or right-click
    on the app node) and select New | Folder | Assets Folder, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ebd91ff-349c-40e8-8746-fc4cd3d6f047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a text file in the asset folder called `asset_text.txt`. Again, whatever
    text you type here will be shown when you run the app. Here''s how the final result
    should look after both text files are created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b681874c-85c9-47fa-9084-6d53269ee5e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it''s time for the code. Open `MainActivity.java` and add the following
    method to read the text file (which is passed into the method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following code to the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To summarize, the only difference is in how we get a reference to each file.
    This line of code reads the `raw` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And this code reads the `asset` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Both calls return an `InputStream`, which the `getText()` method uses to read
    the file contents. It is worth noting, though, that the call to open the `asset`
    text file requires an additional `try`/`catch`.
  prefs: []
  type: TYPE_NORMAL
- en: As noted in the recipe introduction, resources are indexed so we have compile-time
    verification, which the `asset` folder does not have.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common approach is to include resources in your APK, but download new resources
    as they become available. (See the network communication in [Chapter 13](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),
    *Telephony, Networks, and the Web*.) If new resources aren't available, you can
    always fall back on the resources in your APK.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network communication recipes in [Chapter 13](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),
    *Telephony, Networks, and the Web.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we're going to demonstrate working with an SQLite database.
    If you are already familiar with SQL databases from other platforms, then much
    of what you know will apply. If you are new to SQLite, take a look at the reference
    links in the *See also* section as this recipe assumes a basic understanding of
    database concepts, including schemas, tables, cursors, and raw SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get you up and running with an SQLite database quickly, our example implements
    the basic CRUD operations. Generally, when creating a database in Android, you
    create a class that extends `SQLiteOpenHelper`, which is where your database functionality
    is implemented. Here is a list of the CRUD (create, read, update, and delete)
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create: `insert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read: `query()` and `rawQuery()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update: `update()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delete: `delete()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate a fully working database, we will create a simple `Dictionary`
    database where we'll store words and their definitions. We'll demonstrate the
    CRUD operations by adding new words (with their definitions) and updating existing
    word definitions. We'll show words in a `ListView` using a cursor. Pressing a
    word in the `ListView` will read the definition from the database and display
    it in a Toast message. A long press will delete the word.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `SQLiteDatabase`. Use the
    default Phone & Tablet options and select Empty Activity on the Add an Activity
    to Mobile dialog.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll create the UI, which will consist of two `EditText` fields, a
    button, and a `ListView`. As we add words to the database, they will populate
    the `ListView`. Start by opening `activity_main.xml` and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the default XML with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new Java class to the project named `DictionaryDatabase`. This class
    extends from `SQLiteOpenHelper` and handles all the SQLite functions. Here is
    the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the declaration, add the following constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following constructor, `OnCreate()`, and `onUpgrade()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are responsible for creating, updating, and deleting
    the records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And these methods handle reading the information from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the database, class finished, open `MainActivity.java`. Add the following
    global variables below the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method to save the fields when the button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this method to populate the `ListView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following code to `onCreate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by explaining the `DictionaryDatabase` class as that''s the heart
    of an SQLite database. The first item to note is the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice `DATABASE_VERSION`? Only when you make changes to your database schema
    do you need to increment this value.
  prefs: []
  type: TYPE_NORMAL
- en: Next is `onCreate()`, where the database is actually created. This is only called
    the first time the database is created, not each time the class is created. It's
    also worth noting the `_id` field. Android does not require tables to have a primary
    field, but some classes, such as the `SimpleCursorAdapter`, may require an `_id`.
  prefs: []
  type: TYPE_NORMAL
- en: We're required to implement the `onUpgrade()` callback, but as this is a new
    database, there's nothing to do. This method will only be called when the database
    version is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: The `saveRecord()` method handles calling `addRecord()` or `updateRecord()`,
    as appropriate. Since we are going to modify the database, both methods use `getWritableDatabase()` to
    get an updatable database reference. A writable database requires more resources
    so if you don't need to make changes, get a read-only database instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method to note is `getWordList()`, which returns all the words in
    the database using a cursor object. We use this cursor to populate the `ListView`,
    which brings us to `ActivityMain.java`. The `onCreate()` method does the standard
    initialization we''ve seen before and also creates an instance of the database
    with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `onCreate()` method is also where we set up the events to show the word
    definition (with a Toast) when an item is pressed and to delete the word on a
    long press. Probably the most complicated code is in `updateWordList()`.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't the first time we've used an adapter, but this is the first cursor
    adapter, so we'll explain. We use the `SimpleCursorAdapter` to create a mapping
    between our field in the cursor and the `ListView` item. We use the `layout.simple_list_item_1`
    layout, which only includes a single text field with the ID `android.R.id.text1`.
    In a real application, we'd probably create a custom layout and include the definition
    in the `ListView` item, but we wanted to demonstrate a method to read the definition
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `updateWordList()` in three places: during `onCreate()` to create the
    initial list, then again after we add/update an item, and lastly when deleting
    an item.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this is a fully functioning example of SQLite, it is still just the
    basics. There are many books dedicated to SQLite for Android and they are worth
    checking out.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, when we increment the database version, the `onUpgrade()`
    method will be called. What you do here is dependent on the changes made to the
    database. If you changed an existing table, ideally you'll want to migrate the
    user data to the new format by querying the existing data and inserting it into
    the new format. Keep in mind that there is no guarantee the user will upgrade
    in consecutive order, so they could jump from version 1 to version 4, for example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQLite homepage: [https://www.sqlite.org/](https://www.sqlite.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLite database Android reference: [http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing data in the background using a Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any potentially long-running operations should not be done on the UI thread,
    as this can cause your application to be slow or become unresponsive. The Android
    OS will bring up the **Application Not Responding** (**ANR**) dialog when apps
    become unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: Since querying databases can be time-consuming, Android introduced the Loader
    API in Android 3.0\. A Loader processes the query on a background thread and notifies
    the UI thread when it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two primary benefits to Loaders are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the database is (automatically) handled on a background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query auto-updates (when using a Content Provider data source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate a Loader, we will modify the previous SQLite database example
    to use a `CursorLoader` to populate `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the project from the previous example, *Creating and using an SQLite
    database,* as the base for this recipe. Create a new project in Android Studio
    and call it `Loader`. Use the default Phone & Tablet options and select Empty
    Activity on the Add an Activity to Mobile dialog. Copy the `DictionaryDatabase`
    class and the layout from the previous recipe. Although we will use parts of the
    previous `ActivityMain.java` code, we will start at the beginning in this recipe
    to make it easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the project set up as described in *Getting ready*, we''ll continue by
    creating two new Java classes, and then tie it all together in `ActivityMain.java`.
    Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java class called `DictionaryAdapter` that extends `CursorAdapter`.
    This class replaces the `SimpleCursorAdapater` used in the previous recipe. Here
    is the full code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create another new Java class and call this one `DictionaryLoader`. Although
    this is the class that handles the data loading on the background thread, it''s
    actually very simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `ActivityMain.java`. We need to change the declaration to implement
    the `LoaderManager.LoaderCallbacks<Cursor>` interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the adapter to the global declarations. The complete list is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `onCreate()` to use the new adapter and add a call to update the Loader
    after deleting a record. The final `onCreate()` method should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We no longer have the `updateWordList()` method, so change `saveRecord()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement these three methods for the Loader interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default `CursorAdapter` requires a Content Provider URI. Since we are accessing
    the SQLite database directly (and not through a Content Provider), we don't have
    a URI to pass, so instead, we created a custom adapter by extending the `CursorAdapter`
    class. `DictionaryAdapter` still performs the same functionality as `SimpleCursorAdapter`
    from the previous recipe, namely mapping the data from the cursor to the item
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: The next class we added was `DictionaryLoader`, which handles populating the
    adapter. As you can see, it's actually very simple. All it does is return the
    cursor from `getWordList()`. The key here is that this query is being handled
    in a background thread and will call the `onLoadFinished()` callback (in `MainActivity.java`)
    when it finishes. Fortunately, most of the heavy lifting is handled in the base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This takes us to `ActivityMain.java`, where we implemented the following three
    callbacks from the `LoaderManager.LoaderCallbacks` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreateLoader()`: It''s initially called in `onCreate()` with the `initLoader()`
    call. It''s called again with the `restartLoader()` call after we make changes
    to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoadFinished()`: It''s called when the Loader `loadInBackground()` finishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoaderReset()`: It''s called when the Loader is being recreated (such as
    with the `restart()` method). We set the old cursor to `null` because it will
    be invalidated and we don''t want a reference kept around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous example, we need to manually notify the Loader to
    re-query the database using `restartLoader()`. One of the benefits of using a
    Loader is that it can auto-update, but it requires a Content Provider as the data
    source. A Content Provider supports using an SQLite database as the data source
    and is recommended for a serious application. (See the following Content Provider
    link to get started.)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *AsyncTask* recipe in [Chapter 14](01fd07ae-9274-4fb2-a536-bc3ed6ec088c.xhtml),
    *Location and Using Geofencing*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a Content Provider: [http://developer.android.com/guide/topics/providers/content-provider-creating.html](http://developer.android.com/guide/topics/providers/content-provider-creating.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also worth checking out Paging and LiveData in the Android Jetpack Components: [https://developer.android.com/jetpack/](https://developer.android.com/jetpack/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Loader (and AsyncTask) are both included in the Android SDK. A non-SDK option
    (and highly recommended) is RXJava for Android: [https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid).
    RXJava is gaining popularity on Android and we're seeing more and more support
    for RXJava observables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing external storage with scoped directories in Android N
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With security awareness on the rise, users are becoming more skeptical about
    allowing apps to have unnecessary permissions. Android N introduces a new option
    called Scoped Directory Access, allowing your application to request access to
    only the required permissions, instead of general access to all folders.
  prefs: []
  type: TYPE_NORMAL
- en: If your application requests `READ_EXTERNAL_STORAGE` and/or `WRITE_EXTERNAL_STORAGE`
    permission, but only needs access to a specific directory, you can use Scoped
    Directory access instead. This recipe will demonstrate how to request access to
    a specific directory, the `Music` folder in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it `ScopedDirectoryAccess`.
    In the Target Android Device dialog, be sure to select API 24: Android 7.0 (Nougat)
    or higher for the Phone & Tablet option. Select Empty Activity on the Add an Activity
    to Mobile dialog.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To initiate the user access request, we''ll add a button to the layout. Start
    by opening `activity_main.xml` and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing `TextView` with this button XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open `MainActivity.java` and add the following line of code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the method to handle the button click:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onActivityResult()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You're ready to run the application on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The access request is handled by the OS, not by the app. To request access,
    we need to call `createAccessIntent()`, which we do with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We call the Intent using the `startActivityForResult()` method, which we’ve
    used before. Since we are looking for a result to come back, we need to pass a
    unique identifier to know when the returned result callback is from our request.
    (The `onActivityResult()` callback method can receive callbacks for multiple requests.)
    If the request code matches our request, we then check whether the result code
    equals `Activity.RESULT_OK`, which means the user granted the permission request.
    We pass the result to `takePersistableUriPermission()` so we will not need to
    prompt the user the next time we need to access the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Access to a directory also includes access to all sub-directories.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the best user experience, observe the following best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to persist the URI after the user grants permission to avoid repeatedly
    requesting the same permission (as we do with `takePersistableUriPermission()`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user denies the permission request, don't annoy your users by continuously
    asking
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the following link for more information on the Storage Access Framework: [http://developer.android.com/guide/topics/providers/document-provider.html](http://developer.android.com/guide/topics/providers/document-provider.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
