<html><head></head><body>
		<div><h1 id="_idParaDest-101" class="chapter-number"><a id="_idTextAnchor163" class="calibre6 pcalibre pcalibre1"/>5</h1>
			<h1 id="_idParaDest-102" class="calibre5"><a id="_idTextAnchor164" class="calibre6 pcalibre pcalibre1"/>The Swift Programming Language</h1>
			<p class="calibre3">As we discussed in <a href="B18653_04.xhtml#_idTextAnchor097" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 4</em></a>, understanding data structures is a crucial and complex skill for any developer, regardless of the platform or language they work with. Data structures are the foundation of computer science programming and algorithms, and mastering them is essential for success as a developer. Now that we have a solid understanding of data structures, it’s time to move on to another important aspect of iOS development: Swift.</p>
			<p class="calibre3">Swift is a highly popular topic in iOS interviews, and it’s not only a programming language for iOS developers but also the core foundation of Apple’s new frameworks and technologies.</p>
			<p class="calibre3">Therefore, understanding Swift’s primary features such as structs, property wrappers, generics, and more is vital to succeeding in iOS development and passing an interview. The close relationship between Swift and Apple’s latest technologies makes a deep understanding of the language crucial for any iOS developer.</p>
			<p class="calibre3">In this chapter, we will learn about optionals, access levels, and closures. We will also review computed and lazy properties, extensions, generics, error handling, protocols, and memory management questions.</p>
			<p class="calibre3">To that end, we will cover the following topics:</p>
			<ul class="calibre10">
				<li class="calibre11">How do we master all Swift features?</li>
				<li class="calibre11">Basic Swift features</li>
				<li class="calibre11">Advanced Swift language features</li>
			</ul>
			<p class="calibre3">It’s essential to ensure that we have a good grasp of the primary language features to excel in the iOS interview process. But how can we ensure that we are fully covered in knowledge and understanding? We will see in this chapter.</p>
			<h1 id="_idParaDest-103" class="calibre5"><a id="_idTextAnchor165" class="calibre6 pcalibre pcalibre1"/>How do we master all Swift features?</h1>
			<p class="calibre3">First, reading this<a id="_idIndexMarker260" class="calibre6 pcalibre pcalibre1"/> chapter will get us through most of the important Swift features interviewers ask about in the iOS technical interviews.</p>
			<p class="calibre3">But that’s not enough.<a id="_idTextAnchor166" class="calibre6 pcalibre pcalibre1"/></p>
			<p class="calibre3">To become a true professional, we must start acting like one.</p>
			<p class="calibre3">For example, reading the <em class="italic">official Swift documentation</em> is an excellent start to ensure we are covered with the latest Swift<a id="_idTextAnchor167" class="calibre6 pcalibre pcalibre1"/> enhancements. We will ensure we cover the basics by going over access levels, error handling, and extensions. But don’t think of Swift as just a programming language. Some features were developed with deep thinking and interesting methodology.</p>
			<p class="calibre3">Ideally, we shouldn’t answer Swift interview questions just by memorizing the technical documentation – the interviewer would like to hear our thoughts, best practices, and recommendations.</p>
			<p class="calibre3">Let’s explain that idea with extensions.</p>
			<p class="calibre3">A typical answer to the question “<em class="italic">Can you please tell me about Swift extensions</em>?” would be, “<em class="italic">Swift extensions allow us to add functionality to an existing class </em><em class="italic">or struct</em>.”</p>
			<p class="calibre3">While this answer is not a mistake, it is still very technical. Try to think deeper:</p>
			<ul class="calibre10">
				<li class="calibre11">Why do we need extensions?</li>
				<li class="calibre11">How do extensions help us to write better code?</li>
				<li class="calibre11">What are the use cases that make extensions so powerful?</li>
			</ul>
			<p class="calibre3">A better answer would be as follows:</p>
			<p class="calibre3"><em class="italic">Swift extensions are a powerful tool that allows developers to add new functionality to existing classes, structures, enumerations, and protocols. They enable code organization by grouping related functionality together, making it easier to read and maintain. They also increase the code reusability, readability, </em><em class="italic">and testability.</em></p>
			<p class="calibre3">Of course, we must ensure we fully understand extensions to phrase this type of answer.</p>
			<p class="calibre3">Our next step would be to take what we’ve just learned about extensions and implement it on other topics, such as optionals, protocols, generics, and other Swift features. That’s precisely what we’re going to do in this chapter.</p>
			<p class="calibre3">Do we need to know all Swift features? The answer is yes. Do we need to know all the features exceptionally well? It’s highly recommended, but we can pass some of the interviews without expertise on some of the features.</p>
			<p class="calibre3">That’s why I grouped<a id="_idIndexMarker261" class="calibre6 pcalibre pcalibre1"/> the Swift features into two levels: basic and advanced.</p>
			<p class="calibre3">Let’s start with some basic language features such as optionals, access levels, and closures.</p>
			<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor168" class="calibre6 pcalibre pcalibre1"/>Basic Swift features</h1>
			<p class="calibre3">Having a solid understanding of Swift’s basic concepts is essential, as a lack of knowledge in these areas can cause significant issues for iOS developers, not to mention job interviews.</p>
			<h2 id="_idParaDest-105" class="calibre7"><a id="_idTextAnchor169" class="calibre6 pcalibre pcalibre1"/>Answering optionals questions</h2>
			<p class="calibre3"><code>?</code> after the variable type.</p>
			<p class="calibre3">Here's an example:</p>
			<pre class="source-code">
<a id="_idTextAnchor170" class="pcalibre pcalibre1 calibre17"/>var name: String?</pre>			<p class="calibre3">In the preceding line of code, <code>name</code> can contain a value or nil.</p>
			<p class="calibre3">A simple way to unwrap an optional and extract its value is the <code>if </code><code>let</code> stateme<a id="_idTextAnchor171" class="calibre6 pcalibre pcalibre1"/>nt:</p>
			<pre class="source-code">
<a id="_idTextAnchor172" class="pcalibre pcalibre1 calibre17"/>var name: String? = "Avi"if let unwrappedValue = name {
    print("The unwrapped value is: \(unwrappedValue)")
} else {
    print("The optional was nil")
}
if let</strong> statement safely “extracts” the value from the <code>unwrappedValue</code> variable and provides an <code>else</code> statement in case it is nil.</pre>
			<p class="calibre3">Notice that since Swift 5.7, it is possible to unwrap more elegantly, keeping the optional name as it is:</p>
			<pre class="source-code">
var name: String? = "Avi"if let name {
    print("The unwrapped value is: \(name)")
} else {
    print("The optional was nil")
}</pre>
			<p class="calibre3">The <code>if let</code> shorthand<a id="_idIndexMarker264" class="calibre6 pcalibre pcalibre1"/> makes it simpler to unwrap <a id="_idIndexMarker265" class="calibre6 pcalibre pcalibre1"/>as it doesn’t require us to create another variable/constant with the same name as the optional.</p>
			<p class="calibre3">Now, let’s move to some interview questions.</p>
			<h3 class="calibre9">“Can you give an example of a situation where you would use an optional in your c<a id="_idTextAnchor173" class="calibre6 pcalibre pcalibre1"/>ode?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question impor<a id="_idTextAnchor174" class="calibre6 pcalibre pcalibre1"/>tant?</em></p>
			<p class="calibre3">This question tests<a id="_idIndexMarker266" class="calibre6 pcalibre pcalibre1"/> our practical understanding of Swift optionals. Because optionals are a widespread feature that involves API interface design, functions declarations, and control flows, the interviewer needs to see if we understand correctly how to u<a id="_idTextAnchor175" class="calibre6 pcalibre pcalibre1"/>se it.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">We can use optionals in our code in a few everyday situations. Here are some of them:</p>
			<ul class="calibre10">
				<li class="calibre11">An optional parameter in function declarations:<pre class="source-code">
func checkPerson(name: String, age: Int, address: Address?) -&gt; Bool</pre></li>				<li class="calibre11">Handling situations where a function may return null:<pre class="source-code">
func getParentViewController() -&gt; UIViewController?</pre></li>				<li class="calibre11">Handling missing data in JSON response using optionals in a struct:<pre class="source-code">
struct Person {    var name: String    var age: Int    var address: String?}</pre></li>			</ul>
			<p class="calibre3">We should use optionals in every place where we understand that we <em class="italic">may not receive a value</em> and<a id="_idIndexMarker267" class="calibre6 pcalibre pcalibre1"/> receive nil instead.</p>
			<h3 class="calibre9">“List all the options you know to unwrap an op<a id="_idTextAnchor176" class="calibre6 pcalibre pcalibre1"/>tional”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">There are several ways to unwrap an optional. It doesn’t mean that all of them are alternatives to each<a id="_idIndexMarker268" class="calibre6 pcalibre pcalibre1"/> other – each method solves a <a id="_idIndexMarker269" class="calibre6 pcalibre pcalibre1"/>different use case. Knowing most of the ways and their use cases shows our ability to unwrap optionals in our code elegantly and eff<a id="_idTextAnchor177" class="calibre6 pcalibre pcalibre1"/>ectively.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Let’s go over some of the ways to unwrap an optional:</p>
			<ul class="calibre10">
				<li class="calibre11">Use <strong class="source-inline1">if let</strong> syntax to perform a code block with an unwrapped value:<pre class="source-code">
if let value = optionalValue {    // Do something with the unwrapped value}</pre></li>				<li class="calibre11">Use Optional Chaining to avoid multiple <strong class="source-inline1">if </strong><strong class="source-inline1">let</strong> statements:<pre class="source-code">
if let country = person.address?.country {    print("The person lives in \(country).")} else {    print("The person's address is unknown.")}</pre></li>				<li class="calibre11">Use <strong class="source-inline1">guard let</strong> to have a stop condition and exit the scope if the value is nil:<pre class="source-code">
guard let value = optionalValue else {    return}// Do something with the unwrapped value</pre></li>				<li class="calibre11">Use the <strong class="source-inline1">!</strong> operator. Force unwrap if we are certain the optional contains<a id="_idTextAnchor178" class="calibre6 pcalibre pcalibre1"/> a value:<pre class="source-code">
let value = optionalValue!// Do something with the unwrapped value</pre></li>				<li class="calibre11">Use nil coalescing (<strong class="source-inline1">??</strong>) to provide a default value:<pre class="source-code">
let value = optionalValue ?? defaultValue</pre></li>			</ul>
			<p class="calibre3">There is no preferred <a id="_idIndexMarker270" class="calibre6 pcalibre pcalibre1"/>way to unwrap a <a id="_idIndexMarker271" class="calibre6 pcalibre pcalibre1"/>value. It all depends on the control flow and the situation.</p>
			<h3 class="calibre9">“Using force unwrapping will crash our app in case of nil. So why would we use it?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">That’s a tricky <a id="_idIndexMarker272" class="calibre6 pcalibre pcalibre1"/>question often asked in interviews. Take the following line of code:</p>
			<pre class="source-code">
let value = optionalValue!</pre>			<p class="calibre3">If <code>optionalValue</code> is nil, we’ll get an exception. So, why are we using that method?</p>
			<p class="calibre3">This interview question is not really about optionals – it’s about our ability to <em class="italic">manage exceptions</em> in our code and crash the app wh<a id="_idTextAnchor179" class="calibre6 pcalibre pcalibre1"/>en needed.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The most straightforward answer would be, “When we are certain the value is not nil.” Here is an example:</p>
			<pre class="source-code">
var maybeString: String?maybeString = "Hello"
if let unwrappedString = maybeString {
    // If the optional has a value, print it
    print(unwrappedString) // Output: Hello
    print(maybeString!) // force unwrapping
}</pre>
			<p class="calibre3">But that answer is not a complete one. Why would we even approach the <code>maybeString</code> variable, even if we just unwrapped it?</p>
			<p class="calibre3">As mentioned earlier, this question tests our ability to manage exceptions using optionals. There are cases where an optional must contain a value. Otherwise, the program cannot continue.</p>
			<p class="calibre3">One<a id="_idIndexMarker273" class="calibre6 pcalibre pcalibre1"/> popular<a id="_idIndexMarker274" class="calibre6 pcalibre pcalibre1"/> example would be declaring an <code>IBOutlet</code> as forced unwrap:</p>
			<pre class="source-code">
class ViewController: UIViewController {    // Declare an IBOutlet
    @IBOutlet var label: UILabel!
    override func viewDidLoad() {
        super.viewDidLoad()
        // Force unwrap the label outlet
        label.text = "Hello World!"
    }
}</pre>
			<p class="calibre3">We’ll get an exception if the <code>label</code> is nil. In general, we don’t want our app to crash, but in this case, a crash indicates that <em class="italic">our program setup is broken</em> – we either disconnected that outlet or even removed it from the storyboard.</p>
			<p class="calibre3">Another good example is force-cast <code>UITableViewCell</code> in a <code>cellForRow</code> method. Even though it’s a casting operation, it is related to optionals because the result of casting is an optional value, and we force it to succeed.</p>
			<p class="calibre3">Our program is not relevant if this casting fails, therefore we will use force-cast for that:</p>
			<pre class="source-code">
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {    let cell = tableView.dequeueReusableCell
        (withIdentifier: "customCell", for: indexPath) as!
            CustomTableViewCell
    // configure the cell using the properties and methods
       of the custom class
    return cell
}</pre>
			<p class="calibre3">In summary, force<a id="_idIndexMarker275" class="calibre6 pcalibre pcalibre1"/> unwrapping is not a common<a id="_idIndexMarker276" class="calibre6 pcalibre pcalibre1"/> technique, but it can be helpful in certain situations where normal unwrapping is not applicable.</p>
			<h2 id="_idParaDest-106" class="calibre7"><a id="_idTextAnchor180" class="calibre6 pcalibre pcalibre1"/>Solving access-level questions</h2>
			<p class="calibre3">At first, access-level<a id="_idIndexMarker277" class="calibre6 pcalibre pcalibre1"/> questions seem like a small<a id="_idIndexMarker278" class="calibre6 pcalibre pcalibre1"/> topic. Technically speaking, it is a small topic. Learning and remembering the different access levels is pretty straightforward.</p>
			<p class="calibre3">The question is always, do we use access levels properly?</p>
			<p class="calibre3">While a single keyword represents access levels, they influence code encapsulation, visibility, project and organization, and readability.</p>
			<p class="calibre3">Access levels also influence how our interfaces between the simple app components look.</p>
			<p class="calibre3">We should come to our interview knowing what the different levels represent and what they mean to our project structure.</p>
			<h3 class="calibre9">“What are the different access levels in Swift, and what are<a id="_idTextAnchor181" class="calibre6 pcalibre pcalibre1"/> their use cases?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This question is considered a screening question, and its goal is to ensure we understand the basic access levels in Swift before we move on to more advanced questions on this topic.</p>
			<p class="callout-heading">A screening question</p>
			<p class="callout">A screening question is a question that the interviewer asks to make sure we pass the minimum qualifications for the position and that we have the basic knowledge for the role. Experienced developers may find these questions weird – but we should remember that the interviewer doesn’t have a previous acquaintance with us. We should be careful with these questions and ensure they won’t be a trap in our interview. A screening question is also called a “fundamental” or “core” question.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There are five different access levels:</p>
			<ol class="calibre15">
				<li class="calibre11"><em class="italic">open</em> – Entities marked as open can be accessed and subclassed by any other module, including other frameworks. This level is used when we want to allow our<a id="_idIndexMarker279" class="calibre6 pcalibre pcalibre1"/> class or<a id="_idIndexMarker280" class="calibre6 pcalibre pcalibre1"/> method to be subclassed or overridden.</li>
				<li class="calibre11"><em class="italic">public</em> – With public, we allow the entity to be accessible from any other module or framework <em class="italic">without subclassing</em> it. Sometimes, because of backward compatibility or security, we don’t want other users to subclass our class, and using public is a great way to ensure that.</li>
				<li class="calibre11"><em class="italic">internal</em> – We should use the internal access level when we want our entity to be accessible <em class="italic">within the same module</em> but not from the outside. Marking an entity as internal is not mandatory – that’s the default access level in case we didn’t define it explicitly. But in libraries, it is a best practice to mark classes explicitly as internal.</li>
				<li class="calibre11"><em class="italic">fileprivate</em> – Entities marked as fileprivate are accessible <em class="italic">within the same file</em>. This is used when we have a class named A, and we want to add another class relevant only to class A. The <strong class="source-inline1">fileprivate</strong> entity will ensure that constraint if we write both classes in the same file.</li>
				<li class="calibre11"><em class="italic">private</em> – private methods and variables are accessible only for the <em class="italic">same class or struct</em> (enclosing declaration). With private, we can hide code implementation outside the entity.</li>
			</ol>
			<h3 class="calibre9">“How do access levels affect code organization and readability?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Just like the previous question, as iOS developers, we shouldn’t look at access levels as technical features. Access levels tremendously influence how our code is organized and viewed. As a matter of fact, in some way, access levels have a part in our code documentation, as it describes what methods are part of the interface and what methods are part of the implementation.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Access level affects <a id="_idIndexMarker281" class="calibre6 pcalibre pcalibre1"/>code <a id="_idIndexMarker282" class="calibre6 pcalibre pcalibre1"/>organization by separating it to interface and implementation. For example, let’s take the following <code>Game</code> class:</p>
			<pre class="source-code">
class Game {    private var gameOver: Bool = false
    public func restart() {
        gameOver = false
        // Other restart logic here
    }
}</pre>
			<p class="calibre3">We can see that <code>Game</code> has a <code>gameOver</code> property which is declared <code>private</code>, and a <code>restart()</code> method, which is <code>public</code>. We understand that <code>gameOver</code> is hidden and cannot be modified directly from outside the class. The only way to change it is by using the <code>restart()</code> method, and that leads us to my main point ‒ readability.</p>
			<p class="calibre3">By looking at the <code>Game</code> class, we can immediately see that there’s only one way to stop the game: by calling <code>restart()</code>. They can safely ignore any other private methods or variables as it is used only for implementation. If <code>gameOver</code> was not private, it was possible to modify it from the outside without calling the necessary steps that are being done in the <code>restart()</code> method.</p>
			<p class="calibre3">In short – the access level explains how to use the class or struct and separate them nicely to<a id="_idIndexMarker283" class="calibre6 pcalibre pcalibre1"/> interface <a id="_idIndexMarker284" class="calibre6 pcalibre pcalibre1"/>and implementation.</p>
			<h2 id="_idParaDest-107" class="calibre7"><a id="_idTextAnchor182" class="calibre6 pcalibre pcalibre1"/>Handling questions about Closures</h2>
			<p class="calibre3">Closures replaced what<a id="_idIndexMarker285" class="calibre6 pcalibre pcalibre1"/> used to be Blocks in<a id="_idIndexMarker286" class="calibre6 pcalibre pcalibre1"/> Objective-C and are widely used in Swift development. But the reason I put it under <em class="italic">basic Swift features</em> is because closures became a fundamental part of many advanced Swift features. It is used as completion handles, advanced collection type functions, SwiftUI, and Combine. Not knowing closures well can affect our ability as iOS developers to move fast and implement advanced features.</p>
			<h3 class="calibre9">“How do you use closures to handle callbacks in iOS?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">I chose to start with this question because callbacks and asynchronous operations are typical examples of how to use closures in many Swift applications. Unlike delegates, closures can make asynchronous tasks look simple and always in context.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Closures are passed to a function as a parameter and can be executed later. Suppose the asynchronous operation is based on a delegate or any other mechanism where the response is out of the function scope. In that case, we can handle that dependency by saving the closure to an instance variable and calling the closure whenever we finish the task.</p>
			<p class="calibre3">Here’s a code example to explain that:</p>
			<pre class="source-code">
class SomeClass: SomeDelegate {    var completion: ((Bool) -&gt; Void)?
    Func startAsyncOperation(completion: @escaping ((Bool) -&gt; Void)) {
        self.completion = completion
        // Start async operation
        NetworkManager.shared.performAsyncOperation (delegate: self)
    }
    func operationDidFinish(success: Bool) {
        self.completion?(success)
    }
}
protocol SomeDelegate: AnyObject {
    func operationDidFinish(success: Bool)
}</pre>
			<p class="calibre3">And now, let’s <a id="_idIndexMarker287" class="calibre6 pcalibre pcalibre1"/>see <a id="_idIndexMarker288" class="calibre6 pcalibre pcalibre1"/>how to use the closure without using any delegate:</p>
			<pre class="source-code">
let someObject = SomeClass()someObject.startAsyncOperation { success in
    if success {
        print("Async operation succeeded")
    } else {
        print("Async operation failed")
    }
}</pre>
			<p class="calibre3">In the preceding code blocks, I demonstrated how to encapsulate the delegate inside <code>SomeClass</code>, and expose only a closure to be run when the async operation ends. This pattern provides a clearer interface to the developer when calling <code>startAsyncOperation</code>.</p>
			<h3 class="calibre9">“Can you explain how closure capture semantics in Swift can lead to retain cycles and how to avoid them?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This classic interview question is a common pitfall junior developers fall into when working with closures.</p>
			<p class="calibre3">In iOS development, topics are related to each other, even though we deal with closures and not memory management.</p>
			<p class="calibre3">Closures are powerful, but when we don’t use them correctly, they can produce memory leaks and affect our app performance.</p>
			<p class="calibre3">This question<a id="_idIndexMarker289" class="calibre6 pcalibre pcalibre1"/> tests<a id="_idIndexMarker290" class="calibre6 pcalibre pcalibre1"/> our understanding of how closures work. It checks our knowledge of what happens in our app memory when we create and call closure and how scopes are handled.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Closures capture variables and constants from the surrounding scopes with a <strong class="bold">strong reference</strong>. One of these constants might be the objects that hold the closure itself, which can <a id="_idIndexMarker291" class="calibre6 pcalibre pcalibre1"/>cause a <strong class="bold">retain cycle</strong>.</p>
			<p class="calibre3">Look at the following code:</p>
			<pre class="source-code">
class SomeClass {    let someProperty = "property value"
    var closure: (() -&gt; Void)?
    func setupClosure() {
        closure = {
            print(self.someProperty)
        }
    }
}
let someObject = SomeClass()
someObject.setupClosure()</pre>
			<p class="calibre3">We can see that <code>SomeClass</code> has a strong reference to <code>closure</code>, and <code>closure</code> prints <code>someProperty</code>, which requires <code>closure</code> to have a strong reference to <code>SomeClass</code> (aka <code>self</code>).</p>
			<p class="calibre3">The simplest way to <a id="_idIndexMarker292" class="calibre6 pcalibre pcalibre1"/>avoid a retain cycle is to declare <code>self</code> as a <code>weak</code> reference and, by that, untie the retain cycle:</p>
			<pre class="source-code">
class SomeClass {    let someProperty = "property value"
    var closure: (() -&gt; Void)?
    func setupClosure() {
        closure = { [weak self] in
            guard let self else { return }
            print(self.someProperty)
        }
    }
}</pre>
			<p class="calibre3">We can also<a id="_idIndexMarker293" class="calibre6 pcalibre pcalibre1"/> use <code>unowned</code> instead of <code>weak</code>, but this is a dangerous approach – the closure may still be alive while <code>self</code> gets deallocated, and that may lead to an exception. However, there are cases where using <code>unowned</code> instead of <code>weak</code> is safe, and that can be derived from the relationship between our classes. A good example would be the <code>Country</code> class and the <code>CapitalCity</code> class. A country has a reference to its capital city, and the capital city can have an <code>unowned</code> reference to its country. We understand that the lifetime of a capital city is aligned with its country’s lifetime, and therefore, it cannot exist without its country. Therefore, using an <code>unowned</code> reference in this scenario would be more practical, and if an exception occurs, it indicates an error in the code implementation.</p>
			<p class="calibre3">Here’s a code <a id="_idIndexMarker294" class="calibre6 pcalibre pcalibre1"/>example that <a id="_idIndexMarker295" class="calibre6 pcalibre pcalibre1"/>demonstrates using <code>unowned</code> between a <code>Country</code> class and a <code>CapitalCity</code> class:</p>
			<pre class="source-code">
class Country {    let name: String
    var capital: CapitalCity?
    init(name: String) {
        self.name = name
    }
    deinit {
        print("\(name) is no longer a country.")
    }
}
class CapitalCity {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
    deinit {
        print("\(name) is no longer a capital city.")
    }
}</pre>
			<p class="calibre3">Having an <code>unowned</code> reference between <code>CapitalCity</code> and <code>Country</code> ensures that we avoid the retain cycle while still maintaining references between our classes.</p>
			<p class="calibre3">Now that we <a id="_idIndexMarker296" class="calibre6 pcalibre pcalibre1"/>have<a id="_idIndexMarker297" class="calibre6 pcalibre pcalibre1"/> been through the basic Swift features, we are moving to more advanced Swift features to ensure we are covered over there.</p>
			<h1 id="_idParaDest-108" class="calibre5"><a id="_idTextAnchor183" class="calibre6 pcalibre pcalibre1"/>Advanced Swift language features</h1>
			<p class="calibre3">Generally, interviewers<a id="_idIndexMarker298" class="calibre6 pcalibre pcalibre1"/> like to start up softly with Swift features, checking different language aspects and trying to locate any red flags we might have about Swift.</p>
			<p class="calibre3">In this section, we will go through more advanced features of Swift, beginning with computed and lazy variables.</p>
			<h2 id="_idParaDest-109" class="calibre7"><a id="_idTextAnchor184" class="calibre6 pcalibre pcalibre1"/>Solving computed and lazy variables questions</h2>
			<p class="calibre3">Computed and lazy <a id="_idIndexMarker299" class="calibre6 pcalibre pcalibre1"/>variables<a id="_idIndexMarker300" class="calibre6 pcalibre pcalibre1"/> are both advanced features of Swift variables, providing efficient ways to improve performance and code readability.</p>
			<p class="calibre3">First, let’s be aligned about what computed and lazy variables are:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Computed variable</strong> – a variable that calculates its value <em class="italic">based on other properties</em>, doesn’t store its value in memory, and calculates it every time it’s accessed</li>
			</ul>
			<p class="calibre3">In the following <code>Rectangle</code> class, <code>area</code> is a computed variable that is based on <code>width</code> and <code>height</code> values:</p>
			<pre class="source-code">
class Rectangle {    var width: Double
    var height: Double
    var area: Double {
        return width * height
    }
}</pre>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Lazy variable</strong> – a <a id="_idIndexMarker301" class="calibre6 pcalibre pcalibre1"/>variable <a id="_idIndexMarker302" class="calibre6 pcalibre pcalibre1"/>whose initial value is <em class="italic">calculated once</em> when it’s first accessed</li>
			</ul>
			<p class="calibre3">The following code example explains what a lazy variable is:</p>
			<pre class="source-code">
class ExpensiveObject {    // Some expensive initialization
}
class MyClass {
    lazy var expensiveObject = ExpensiveObject()
}</pre>
			<p class="calibre3">The <code>expensiveObject</code> variable is only initialized when we first access it. We can see the <code>lazy</code> keyword prefixed the variable declaration, making it lazy.</p>
			<p class="calibre3">Many iOS developers make little use of computed and lazy variables, and most of the time, the reasons are a lack of understanding and premature optimization.</p>
			<p class="calibre3">Now, let’s dive into our first question.</p>
			<h3 class="calibre9">“When would you use a computed property instead of a stored property, and vice versa?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">That’s a thoughtful question, and it helps to test our understanding of how to apply the theory in practice. Both computed and stored properties have their advantages and disadvantages in terms of performance and accuracy, so the question goes beyond just technical considerations.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Computed properties are used when the value needs to be calculated every time the property is being accessed. A computed property usually uses other properties to calculate its value. Some examples are date formatted, the area of a rectangle, or a full name value that is based on other properties such as first and last name.</p>
			<p class="calibre3">Stored properties, on the other hand, are stored and changed from the outside of the class based on user input or other events — for example, username, configuration value, and more.</p>
			<p class="calibre3">Computed <a id="_idIndexMarker303" class="calibre6 pcalibre pcalibre1"/>properties <a id="_idIndexMarker304" class="calibre6 pcalibre pcalibre1"/>have a more dynamic nature. They are being calculated constantly and are, therefore, more accurate. The downside is that they are less efficient in many cases, especially when the value tends to change.</p>
			<p class="calibre3">There is a tension between computed and stored properties. Stored properties are excellent for performance, but we need to maintain their data accuracy. Computed properties are the opposite – they are always accurate but are calculated all the time.</p>
			<h3 class="calibre9">“How can you use lazy variables to improve the performance of an app that loads large amounts of data?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Lazy variables are significant for performance and memory consumption. This question tests our ability to optimize our app and UI loading using lazy variables.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Lazy variables can improve our app’s performance by delaying the data’s initialization until it is needed. Loading an object is always considered a heavy task, as the runtime environment needs to initialize the object and its properties. So, variables that need to initialize and load a large amount of data can affect the loading time (and the memory consumption) of the object being loaded. If there’s a possibility to postpone the data loading for later, it can improve the object loading time.</p>
			<p class="calibre3">Here’s an example<a id="_idIndexMarker305" class="calibre6 pcalibre pcalibre1"/> of a lazy <a id="_idIndexMarker306" class="calibre6 pcalibre pcalibre1"/>loading code:</p>
			<pre class="source-code">
class MyData {    lazy var largeData: [String] = {
        // load large data from a file or remote API
        return loadLargeData()
    }()
    private func loadLargeData() -&gt; [String] {
        // perform the expensive operation to load the
           large data
        // here we just return an array of string but it
           could be some large data
        return ["large","data","loaded"]
    }
}
let data = MyData()
// the largeData is not loaded until this point
print(data.largeData)</pre>
			<p class="calibre3">We can see from the preceding code that the <code>largeData</code> variable can take time to be initialized, so we declared it as <code>lazy</code>. When we allocate <code>data</code>, <code>largeData</code> is still not allocated, not <a id="_idIndexMarker307" class="calibre6 pcalibre pcalibre1"/>until we<a id="_idIndexMarker308" class="calibre6 pcalibre pcalibre1"/> call it using the <code>print</code> command.</p>
			<h2 id="_idParaDest-110" class="calibre7"><a id="_idTextAnchor185" class="calibre6 pcalibre pcalibre1"/>Solving extensions questions</h2>
			<p class="calibre3">Some of the <a id="_idIndexMarker309" class="calibre6 pcalibre pcalibre1"/>features we <a id="_idIndexMarker310" class="calibre6 pcalibre pcalibre1"/>discussed are related to code organization. For example, access levels are not just for technical restrictions; they are also part of organizing our code and declaring what’s part of the interface and what’s encapsulated.</p>
			<p class="calibre3">Another important feature in that area is <strong class="bold">extensions</strong>.</p>
			<p class="calibre3">Extensions in Swift have several important roles:</p>
			<ul class="calibre10">
				<li class="calibre11">Extensions allow us to <em class="italic">add new functionality to existing classes</em>, structs, and enums without modifying their source code</li>
				<li class="calibre11">Extensions can help us to <em class="italic">group related functionality</em> and improve our code readability and organization</li>
				<li class="calibre11">Extensions are used to <em class="italic">add protocol conformance</em> to types, aligning their interface with other types conforming to the same protocol</li>
			</ul>
			<p class="calibre3">We can see how many extensions are essential to Swift language, as they are widely used in our daily iOS development.</p>
			<p class="calibre3">Even though extensions are powerful, they are effortless to use and understand. That’s why we must be highly prepared for this topic, as any mistake can raise a red flag for our interviewer.</p>
			<p class="calibre3">Now let’s move to our first question.</p>
			<h3 class="calibre9">“Can you add new properties to a struct or class using an extension?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This question seems like a simple yes/no question, but the reality is that it hides two more layers of understanding the interviewer wishes to hear.</p>
			<p class="calibre3">First, they want to hear the practical layer – what is and is not <em class="italic">possible</em> in extensions (aka the full answer).</p>
			<p class="calibre3">But second, and this is a bonus, they want to hear <em class="italic">why extensions work the way they work</em>. That will show how deeply we understand Swift memory usage.</p>
			<p class="calibre3">Don’t worry, we’ll cover both layers in our answer.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The short answer is “no,” we cannot add stored properties in extensions. But it is worth mentioning that it is possible to add computed properties. The reason is that we can add new functionality to a type but not its memory layout, which can imply to us what can/can’t be added to a type using extensions.</p>
			<p class="calibre3">There are several workarounds for that – wrapping the original type or using a global variable to store the property value, but the idea stays the same.</p>
			<p class="calibre3">Now for the “bonus” part of the answer: a type’s memory layout is <em class="italic">determined in compile-time</em> and embedded in the binary. This means that we cannot add new stored properties on the fly using extensions, as they will make changes to the memory layout set<a id="_idIndexMarker311" class="calibre6 pcalibre pcalibre1"/> earlier. Adding<a id="_idIndexMarker312" class="calibre6 pcalibre pcalibre1"/> that fact to the answer would give us additional points in the interview!</p>
			<h3 class="calibre9">“Can you use an e<a id="_idTextAnchor186" class="calibre6 pcalibre pcalibre1"/>xtension to add a method to a protocol? If so, how?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This is a tricky question. Protocols are not types. Extending the protocol is like adding new functionality to the conforming types. Confused? That’s why this question <a id="_idTextAnchor187" class="calibre6 pcalibre pcalibre1"/>is tricky…  Let’s see the answer to clear things up.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Yes, it is possible to extend a protocol. Extending a protocol adds new functionality to all types that conform to that protocol, allowing us to add a default implementation to protocol methods.</p>
			<p class="calibre3">Let’s see a code example of extending a protocol:</p>
			<pre class="source-code">
protocol MyProtocol {    // existing protocol requirements
}
extension MyProtocol {
    func newMethod() {
        // implementation
    }
}</pre>
			<p class="calibre3">We can see that the <code>MyProtocol</code> extension adds a new method: <code>newMethod()</code>. The new method<a id="_idIndexMarker313" class="calibre6 pcalibre pcalibre1"/> can be used in all types that conform to <code>MyProtocol</code>. Let’s continue the code example to explain that:</p>
			<pre class="source-code">
struct MyStruct: MyProtocol {    // existing struct properties and methods
}
let myStruct = MyStruct()
myStruct.newMethod()</pre>
			<p class="calibre3">I hope it’s clearer <a id="_idIndexMarker314" class="calibre6 pcalibre pcalibre1"/>now, as <code>myStruct</code> can call <code>newMethod()</code> even though it wasn’t defined in the original protocol declaration.</p>
			<h2 id="_idParaDest-111" class="calibre7"><a id="_idTextAnchor188" class="calibre6 pcalibre pcalibre1"/>Solving generics questions</h2>
			<p class="calibre3"><strong class="bold">Generics</strong> are Swift features<a id="_idIndexMarker315" class="calibre6 pcalibre pcalibre1"/> that allow <a id="_idIndexMarker316" class="calibre6 pcalibre pcalibre1"/>iOS developers to write reusable code that can work with any type of data.</p>
			<p class="calibre3">For iOS developers, generics are particularly important because they can be used to write reusable and type-safe code. This means developers can write code used in multiple places within an app without worrying about typecasting or other type-related issues. Additionally, generics can help to prevent runtime errors and improve performance by allowing the compiler to optimize the code at compile time. Overall, generics are powerful tools that can help iOS developers write more robust and efficient code.</p>
			<p class="calibre3">Now, let’s see an example of a reverse method for an array that can work with any type:</p>
			<pre class="source-code">
func reverseArray&lt;T&gt;(arr: [T]) -&gt; [T] {    var reversedArr: [T] = []
    for i in stride(from: arr.count - 1, through: 0, by: -1) {
        reversedArr.append(arr[i])
    }
    return reversedArr
}
let numbers = [1, 2, 3, 4, 5]
let reversedNumbers = reverseArray(arr: numbers)
// reversedNumbers is [5, 4, 3, 2, 1]
let words = ["apple", "banana", "cherry"]
let reversedWords = reverseArray(arr: words)
// reversedWords is ["cherry", "banana", "apple"]</pre>
			<p class="calibre3">The most important thing to understand about that code snippet is this line:</p>
			<pre class="source-code">
func reverseArray&lt;T&gt;(arr: [T]) -&gt; [T]</pre>			<p class="calibre3">The <code>reverseArray()</code> method receives an array from a specific type and returns an array at the same <a id="_idIndexMarker317" class="calibre6 pcalibre pcalibre1"/>time. Perhaps that’s the core concept of generics – not just creating reusable code but also m<a id="_idTextAnchor189" class="calibre6 pcalibre pcalibre1"/>aintaining type safety and avoiding type-casting issues.</p>
			<h3 class="calibre9">“Can you give an<a id="_idTextAnchor190" class="calibre6 pcalibre pcalibre1"/> example of a problem that can be solved using generics?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Like previous questions, this question challenges us by taking a theoretical topic and asking for a real-life example of how to use it.</p>
			<p class="calibre3">Compared to other Swift features, it is harder to understand generics’ benefi<a id="_idTextAnchor191" class="calibre6 pcalibre pcalibre1"/>ts without going over real-world problems and solutions.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">A caching class is an excellent example of a problem that can be solved using generics. If we want to cache data, we need to create a separate class for each type we want to cache or create a different <a id="_idIndexMarker318" class="calibre6 pcalibre pcalibre1"/>method in some abstract class.</p>
			<p class="calibre3">In this case, generics let us reuse the same code for different types:</p>
			<pre class="source-code">
class Cache&lt;T&gt; {    private var cache = [String: T]()
    func set(value: T, for key: String) {
        cache[key] = value
    }
    func get(for key: String) -&gt; T? {
        return cache[key]
    }
}</pre>
			<p class="calibre3">This is how we<a id="_idIndexMarker319" class="calibre6 pcalibre pcalibre1"/> use the <code>Cache</code> class with <code>Int</code>:</p>
			<pre class="source-code">
let cache = Cache&lt;[Int]&gt;()cache.set(value: [1, 2, 3, 4, 5], for: "numbers")
let cachedNumbers = cache.get(for: "numbers")
// cachedNumbers is [1, 2, 3, 4, 5]</pre>
			<p class="calibre3">A cache is a good <a id="_idIndexMarker320" class="calibre6 pcalibre pcalibre1"/>example because it doesn’t require us to cast the returned type. We can initialize a new cache instance that works with a different kind of data each time.</p>
			<h3 class="calibre9">“How do you use associated types in a generic protocol?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3"><strong class="bold">Associated types</strong> are features<a id="_idIndexMarker321" class="calibre6 pcalibre pcalibre1"/> that iOS developers rarely use, but I still want to dedicate one question to them. The reason is that it can give you a better picture of generics’ usage and examples in Swift. It is difficult for many iOS developers to find practical use cases for generics, so providing an example from a different perspective may help your interview readiness.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Associated types are actually <em class="italic">generics for protocols</em>. They work the same way as classes and structs work with generics.</p>
			<p class="calibre3">To use the associated type, we need to define it in a protocol using the keyword <code>associatedtype</code>:</p>
			<pre class="source-code">
protocol DataSource {    associatedtype Data
    func fetchData() -&gt; Data
}</pre>
			<p class="calibre3">The <code>DataSource</code> protocol contains a <code>Data</code> <code>associatedtype</code>, but it is not specified what kind of type it will be used. We do that in the protocol implementation.</p>
			<p class="calibre3">For example, this is an implementation of <code>DataSource</code> with <code>Int</code> as <code>Data</code>:</p>
			<pre class="source-code">
struct LocalDataSource: DataSource {    typealias Data = [Int]
    func fetchData() -&gt; [Int] {
    }
}</pre>
			<p class="calibre3">Of course, other<a id="_idIndexMarker322" class="calibre6 pcalibre pcalibre1"/> structs or classes<a id="_idIndexMarker323" class="calibre6 pcalibre pcalibre1"/> can implement the protocol using a different type by defining it in the <code>Data</code> type alias, which makes this protocol flexible and reusable.</p>
			<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor192" class="calibre6 pcalibre pcalibre1"/>Solving error-handling questions</h2>
			<p class="calibre3">Error handling is<a id="_idIndexMarker324" class="calibre6 pcalibre pcalibre1"/> an essential<a id="_idIndexMarker325" class="calibre6 pcalibre pcalibre1"/> topic in every language and platform. It lets us respond to unexpected events or conditions (which makes them “expected” when we think of it).</p>
			<p class="calibre3">Error handling and Swift are interesting when we discuss job interviews – first, this area <em class="italic">improved tremendously</em> when we moved from Objective-C to Swift. Still, it also improved dramatically between the different Swift versions. Consider that by the time you read this book, probably more changes will have been made in error handling, so it is worth having a look.</p>
			<p class="calibre3">Moreover, the <em class="italic">increasing popularity of Combine and SwiftUI</em> made error handling even more popular. We can confidently say that error handling is a fundamental part of Combine data streams, and if that’s an area we feel insecure about, now is the time to catch up!</p>
			<h3 class="calibre9">“How do you use the try? and try! operators for error handling in Swift?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3"><code>try?</code> and <code>try!</code> are operators that handle errors more concisely.</p>
			<p class="calibre3">It is important to explain the difference between the two operators and implement them in our code flow.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Instead of using <a id="_idIndexMarker326" class="calibre6 pcalibre pcalibre1"/>the <code>do-catch</code> flow, we can use the <code>try?</code> operator to bypass it, similar to how we unwrap an optional:</p>
			<pre class="source-code">
let result = try? someThrowingFunction()if result != nil {
    // Use the result
} else {
    // Handle the error
}</pre>
			<p class="calibre3">In this code example, we wrap the call for <code>someThrowingFunction()</code> with the <code>try?</code> operator. The result is an optional value – if the function throws an exception, the returned value will be nil.</p>
			<p class="calibre3">However, <code>try!</code> is exactly like force unwrapping. If the function throws an exception, our program will be terminated:</p>
			<pre class="source-code">
let result = try! someThrowingFunction()</pre>			<p class="calibre3">Notice that we <a id="_idIndexMarker327" class="calibre6 pcalibre pcalibre1"/>should use <code>try!</code> with caution and in cases where there’s no point in continuing our program if the function throws an exception.</p>
			<h3 class="calibre9">“Can you explain and give an example of how you would write a function in Swift that throws an error?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Many developers know how to perform a basic <code>do-catch</code> block, mainly because it is required in many cases.</p>
			<p class="calibre3">The natural step forward is to perform the throwing action ourselves. Knowing how to write a function that throws an exception shows a good understanding of Swift’s error-handling mechanism.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There are three things we need to do to have a throwing function:</p>
			<ul class="calibre10">
				<li class="calibre11">The first thing is to <em class="italic">add the </em><strong class="source-inline1">throws</strong><em class="italic"> keyword</em> to its declaration:<pre class="source-code">
func readFile(at path: String) throws -&gt; String { … }</pre></li>				<li class="calibre11">The second <a id="_idIndexMarker328" class="calibre6 pcalibre pcalibre1"/>thing is having some kind of an <em class="italic">error to throw back</em> in case of a problem:<pre class="source-code">
enum FileError: Error {    case fileNotFound}</pre></li>				<li class="calibre11">The third will be the implementation and <em class="italic">throwing the error in case of an exception</em> (complete code ahead):<pre class="source-code">
enum FileError: Error {    case fileNotFound}func readFile(at path: String) throws -&gt; String {    guard let data = FileManager.default.contents        (atPath: path) else {        throw FileError.fileNotFound    }    return String(data: data, encoding: .utf8) ?? ""}</pre></li>			</ul>
			<p class="calibre3">Remembering these three fundamental components of throwing functions will help us nail this function efficiently.</p>
			<p class="calibre3">If you still feel insecure about error handling, try to return to one of your projects and add error<a id="_idIndexMarker329" class="calibre6 pcalibre pcalibre1"/> handling in places where you think it’s relevant. There’s nothing like practical experience to deal<a id="_idIndexMarker330" class="calibre6 pcalibre pcalibre1"/> with topics with which you don’t feel strongly about.</p>
			<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor193" class="calibre6 pcalibre pcalibre1"/>Solving protocol questions</h2>
			<p class="calibre3">One of the most <a id="_idIndexMarker331" class="calibre6 pcalibre pcalibre1"/>important principles <a id="_idIndexMarker332" class="calibre6 pcalibre pcalibre1"/>in computer science is the <strong class="bold">Separation of Concerns</strong>. To achieve that, one <a id="_idIndexMarker333" class="calibre6 pcalibre pcalibre1"/>of the things we want to do is reduce coupling between different parts of our code – decoupling objects and classes.</p>
			<p class="calibre3">Protocols play a significant part in this task, making our code more flexible and reusable. In modern iOS development, protocols are a fundamental part of the development, and we can find them heavily used in almost every API and SDK.</p>
			<h3 class="calibre9">“Can you explain the use of protocol-oriented programming in iOS development?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Even though that’s an open-ended question, it is common in interviews. Maybe because it is an open question, interviewers like to ask it so they can understand how candidates think.</p>
			<p class="calibre3">Protocols are like spices in cooking – technically, they are easy to use. The problem starts with how much and when.</p>
			<p class="calibre3">We should be ready for this question, and it is also a chance to spread our methodologic point of view of protocol’s role in our code writing.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The first thing to <a id="_idIndexMarker334" class="calibre6 pcalibre pcalibre1"/>understand about <strong class="bold">Protocol-Oriented Programming</strong> (<strong class="bold">POP</strong>) is that it’s a programming paradigm. This means that POP is a set of guidelines and rules for organizing and structuring our code.</p>
			<p class="calibre3">The main idea of POP is that objects communicate with each other using protocols. This makes our code much more flexible and reusable, as different types can implement different behaviors and still work with other objects by conforming to the same interface.</p>
			<p class="calibre3">POP works<a id="_idIndexMarker335" class="calibre6 pcalibre pcalibre1"/> with <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) and doesn’t replace it.</p>
			<h3 class="calibre9">“How do you decide when to use a protocol in your iOS app?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This question<a id="_idIndexMarker336" class="calibre6 pcalibre pcalibre1"/> takes a theory topic (protocol) and moves it to the practical world of considerations and tradeoffs. The interviewer doesn’t want to hear a dichotomous answer but rather a more profound solution involving our point of view on Swift’s development.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">I’ll start with the bottom line: we shouldn’t always use protocols. We should use them only when it is effective and they don’t make our project more cumbersome than it is already. We should do that with caution and according to the following factors:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Interface reusability</em> – if we want to reuse a specific interface between different types.</li>
				<li class="calibre11"><em class="italic">Abstraction</em> – A protocol provides another level of abstraction to our code by defining a set of methods and properties used by different objects.</li>
				<li class="calibre11"><em class="italic">Dependency injection</em> – We can use protocols to inject dependencies into a class and, by that, make it more flexible and testable.</li>
			</ul>
			<p class="calibre3">To summarize, protocols are a great solution whenever we need more flexibility and decreased coupling in our code.</p>
			<p class="calibre3">On the other hand, protocols can add a layer of complexity to our code, adding a virtual layer between <a id="_idIndexMarker337" class="calibre6 pcalibre pcalibre1"/>classes. And<a id="_idIndexMarker338" class="calibre6 pcalibre pcalibre1"/> that’s an expected trade-off in programming – <em class="italic">complexity </em><em class="italic">versus coupling</em>.</p>
			<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor194" class="calibre6 pcalibre pcalibre1"/>Solving memory management questions</h2>
			<p class="calibre3">Memory<a id="_idIndexMarker339" class="calibre6 pcalibre pcalibre1"/> management <a id="_idIndexMarker340" class="calibre6 pcalibre pcalibre1"/>for iOS developers has been a critical issue from the beginning days of iOS development.</p>
			<p class="calibre3">I must say that things have become better over the years – Apple added <strong class="bold">Automatic Reference Counting</strong> (<strong class="bold">ARC</strong>), debug <a id="_idIndexMarker341" class="calibre6 pcalibre pcalibre1"/>tools became better, and the hardware has evolved dramatically.</p>
			<p class="calibre3">Having said that, efficiency is still essential when discussing resource management.</p>
			<p class="calibre3">Be prepared for some questions on that topic in your next iOS technical interview.</p>
			<h3 class="calibre9">“What is the difference between a strong and a weak reference in iOS?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3"><strong class="bold">Strong</strong> and <strong class="bold">weak</strong> references are the core components of the memory ownership concept we have in Swift.</p>
			<p class="calibre3">Ownership is the key to ARC, which is the basis of the memory management mechanism in iOS, and if we don’t <a id="_idIndexMarker342" class="calibre6 pcalibre pcalibre1"/>understand<a id="_idIndexMarker343" class="calibre6 pcalibre pcalibre1"/> how that mechanism works, we are on the path of creating <strong class="bold">memory leaks</strong> and <strong class="bold">retaining cycles</strong>.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The answer is fairly simple: a strong reference (which is the default reference unless defined otherwise) is a way to indicate an object is being held in memory by one or more elements. In contrast, a weak reference allows the object to be deallocated when it is no longer needed.</p>
			<p class="calibre3">A strong<a id="_idIndexMarker344" class="calibre6 pcalibre pcalibre1"/> reference <em class="italic">increases</em> the reference counting by one, while a weak reference <em class="italic">doesn’t change</em> the reference counting at all.</p>
			<p class="calibre3">A good example of weak<a id="_idIndexMarker345" class="calibre6 pcalibre pcalibre1"/> reference usage is <strong class="bold">a </strong><strong class="bold">delegate pattern</strong>.</p>
			<p class="calibre3">Let’s see an example:</p>
			<pre class="source-code">
class ViewController: UIViewController {    var delegate: ViewControllerDelegate?
}
protocol ViewControllerDelegate: class {
    func didTapButton()
}
class AnotherViewController: UIViewController,
    ViewControllerDelegate {
    weak var viewController: ViewController?
    override func viewDidLoad() {
        super.viewDidLoad()
        viewController = ViewController()
        viewController!.delegate = self
    }
    func didTapButton() {
        // Perform some action
    }
}</pre>
			<p class="calibre3">In this code <a id="_idIndexMarker346" class="calibre6 pcalibre pcalibre1"/>example, we <a id="_idIndexMarker347" class="calibre6 pcalibre pcalibre1"/>can see that the <code>ViewController</code> has a strong reference to its <code>delegate</code> object, while the <code>delegate</code> object has a weak reference to its <code>ViewController</code>. The reason for this arrangement is to avoid a retain cycle and, as a result, increase our app memory usage.</p>
			<h3 class="calibre9">“How do you handle low memory warnings in iOS?”</h3>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This question is designed to assess our understanding of managing resources. There are situations where it is acceptable to receive low memory warnings, but the question is how we should handle it when it occurs. Having control over the resources in our app allows us to manage and respond to these situations appropriately.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">One thing we need to do when we get a low memory warning is to release any unnecessary resources and reduce the app’s memory footprint.</p>
			<p class="calibre3">Here are some examples of how to reduce our app’s memory footprint:</p>
			<ul class="calibre10">
				<li class="calibre11">Release cache data</li>
				<li class="calibre11">Use autorelease pools</li>
				<li class="calibre11">Use weak references</li>
				<li class="calibre11">Release unused resources such as off-screen views</li>
				<li class="calibre11">Use NSCache</li>
			</ul>
			<p class="calibre3">That’s the time <a id="_idIndexMarker348" class="calibre6 pcalibre pcalibre1"/>to dig in<a id="_idIndexMarker349" class="calibre6 pcalibre pcalibre1"/> our memory from past projects and try to remember resources we could have released when we get low memory warnings.</p>
			<h1 id="_idParaDest-115" class="calibre5"><a id="_idTextAnchor195" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we discussed the many topics in Swift development, both basic and advanced. We covered optionals, access levels, closures, computed and lazy variables, extensions, generics, error handling, protocols, and memory management.</p>
			<p class="calibre3">These are a lot of topics! But on the other hand, we are experienced Swift developers, and these all need to be familiar.</p>
			<p class="calibre3">As I said earlier, we are good iOS developers and know the job well. We just need to organize our knowledge to be prepared for our interview.</p>
			<p class="calibre3">Our next chapter deals with something different than just Swift – we will talk about code management.</p>
		</div>
	</body></html>