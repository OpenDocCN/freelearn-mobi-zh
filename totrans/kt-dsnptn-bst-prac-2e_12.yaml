- en: '*Chapter 9*: Idioms and Anti-Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed the different aspects of the Kotlin programming
    language, the benefits of functional programming, and concurrent design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses the best and worst practices in Kotlin. You'll learn
    what idiomatic Kotlin code should look like and which patterns to avoid. This
    chapter contains a collection of best practices spanning those different topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the scope functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type checks and casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative to the try-with-resources statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing algebraic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reified generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constants efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor overload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with nulls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making asynchronicity explicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferring sealed classes over enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you should be able to write more readable and
    maintainable Kotlin code, as well as avoid some common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the requirements from the previous chapters, you will also need
    a **Gradle**-enabled **Kotlin** project to be able to add the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the scope functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has the concept of **scoping functions**, which are available on any
    object and can replace the need to write repetitive code. Among other benefits,
    these scoping functions help us simplify single-expression functions. They are
    considered higher-order functions since each scoping function receives a lambda
    expression as an argument. In this section, we'll discuss all the necessary functions
    and execute their code blocks using objects as their *scope*. In this section,
    we'll use the terms *scope* and *context object* interchangeably to describe the
    objects that those functions operate on.
  prefs: []
  type: TYPE_NORMAL
- en: Let function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `let()` function to invoke a function on a nullable object, but
    only if the object is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, as an example, the following map of quotes (we discussed this
    in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Kotlin*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s fetch a quote from a movie that may not exist in the collection
    and print it, but only if it''s not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code can we rewritten using the `let` scoping function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'One common mistake is forgetting to use the safe navigation operator before
    `let`, because `let()` by itself also works on nulls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code will print `null` to the console. Make sure that you don't forget
    the question mark (`?`) when you use `let()` for null checks.
  prefs: []
  type: TYPE_NORMAL
- en: Apply function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have discussed `apply()` in previous chapters. It returns the same object
    it operates on and sets the context to `this`. You can use `apply()` if you need
    to initialize a mutable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of how many times you had to create a class that has an empty constructor,
    and then call a lot of setters, one after another. Let''s look at the following
    class as an example. This may be a class that comes from a library, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we need to create a new instance of such a class, we could do so in a
    procedural manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can only set `name` and `movie`, and leave `alsoStarring`
    blank, using the `apply()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the context of the block is set to `this`, we can simplify the preceding
    code even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using the `apply()` function is especially good when you're working with Java
    classes that usually have a lot of setters and a default empty constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Also function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in the introduction to this section, single-expression functions
    are very nice and concise. Let''s look at the following simple function, which
    multiplies two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But often, you have a single-statement function that also needs to, for example,
    write to a log or have another side effect. To achieve this, we could rewrite
    our function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to make our function much more verbose here and introduce another variable.
    Let''s see how we can use the `also()` function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will assign the results of the expression to `it` and return
    the result of the expression. The `also()` function is also useful when you want
    to have a side effect on a chain of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we can continue our chain of calls with a `map()` function,
    even though we used the `also()` function to print each element of a list.
  prefs: []
  type: TYPE_NORMAL
- en: Run function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `run()` function is very similar to the `let()` function, but it sets the
    context of the block to `this` instead of using `it`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `this` is set to reference the `justAString` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, `this` could be omitted, so the code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run()` function is mostly useful when you plan to initialize an object,
    much like the `apply()` function we discussed earlier. However, instead of returning
    the object itself, like `apply()` does, you usually like to return the result
    of some computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, the object was initialized with `"ROGER MOORE"`. Note that here, we operated
    on the `JamesBond` object, but our return value was a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: With function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike the other four scoping functions, `with()` is not an extension function.
    This means you cannot do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, `with()` receives the object you want to scope as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And as usual, we can omit `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Just like `run()` and `let()`, you can return any result from `with()`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how the various scope functions can help reduce
    the amount of boilerplate code by defining a code block to be executed on the
    object. In the next section, we'll see how Kotlin also allows us to write fewer
    instance checks than other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Type checks and casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing your code, you may often be inclined to check what type your
    object is using, `is`, and cast it using `as`. As an example, let''s imagine we''re
    building a system for superheroes. Each superhero has their own set of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also a function where a superhero tries to invoke their superpower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'But as you may know, Kotlin has smart casts, so implicit casting, in this case,
    is not needed. Let''s rewrite this function using smart casts and see how they
    improve our code. All we need to do is remove the explicit casts from our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, in most cases, using `when()` while smart casting produces cleaner
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'As a rule of thumb, you should avoid using casts and rely on smart casts most
    of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you absolutely must, there''s also a safe cast operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The **safe cast operator** will return null if the object cannot be cast, instead
    of throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the try-with-resources statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AutoCloseable` and the try-with-resources statement.'
  prefs: []
  type: TYPE_NORMAL
- en: This statement allows us to provide a set of resources that will be automatically
    closed once the code is done with them. So, there will be no more risk (or at
    least less risk) of forgetting to close a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Java 7, this was a total mess, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'After **Java 7** was released, the preceding code could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin doesn''t support this syntax. Instead, the try-with-resource statement
    is replaced with the `use()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: An object must implement the `Closeable` interface for the `use()` function
    to be available. The `Closeable` object will be closed as soon as we exit the
    `use{}` block.
  prefs: []
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of `inline` functions as instructions for the compiler to copy
    and paste your code. Each time the compiler sees a call to a function marked with
    the `inline` keyword, it will replace the call with the concrete function body.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to use the `inline` function if it's a higher-order function
    that receives a lambda as one of its arguments. This is the most common use case
    where you would like to use `inline`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at such a higher-order function and see what pseudocode the compiler
    will output.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here is the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we pass a lambda, or a `block`, to our function. This `block` simply
    returns the word `"Inlining"` as a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to view the Java equivalent of the decompiled bytecode, you''d
    see that there''s no call to our `makesSense` function at all. Instead, you''d
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Since the `inline` function is a copy/paste of your code, you shouldn't use
    it if you have more than a few lines of code. It would be more efficient to have
    it as a regular function. But if you have single-expression functions that receive
    a lambda, it makes sense to mark them with the `inline` keyword to optimize performance.
    In the end, it's a trade-off between the size of your application and its performance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Algebraic Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Algebraic Data Types**, or **ATDs** for short, is a concept from functional
    programming and is very similar to the **Composite design pattern** we discussed
    in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080), *Understanding Structural
    Patterns*.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how ADTs work and what their benefits are, let's discuss how we
    can implement a simple binary tree in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s declare an interface for our tree. Since a tree data structure
    can contain any type of data, we can parameterize it with a type (`T`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The type is marked with an `out` keyword, which means that this type is *covariant*.
    If you aren't familiar with this term, we'll cover it later, while implementing
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of a covariant is a *contravariant*. Contravariant types should
    be marked using the `in` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: We can also mark this interface with a `sealed` keyword. We saw this keyword
    applied to regular classes in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, while discussing the `sealed` interfaces
    are a relatively new feature and were introduced in **Kotlin 1.5**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The meaning is the same, though: only the owner of the interface can implement
    it. This means that all the implementations of the interface are known at compile
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s declare what an empty tree looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Since all empty trees are the same, we declare it as an object. This is another
    use of the `Nothing` as the type of an empty tree. This is a special class in
    Kotlin's object hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: There is some confusion between `Any`, which represents any class and is similar
    to `Object` in Java, and `Nothing`, which represents no class. We'll see why `Any`
    wouldn't work in this case later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define a non-empty node of a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '`Node` also implements the `Tree` interface, but it is a data class and not
    an object since every node is different. The type of the value of a `Node` is
    `T`, which means it can contain any type of value, but all the nodes in the same
    tree will contain the same type of value. This is the real power of generics.'
  prefs: []
  type: TYPE_NORMAL
- en: A node also has two children, left and right, since it's a binary tree. By default,
    both of them are empty.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify the default values for the children of a node thanks to the fact
    that the type is covariant and `Empty` is of the `Nothing` type. `Nothing` is
    at the bottom of the class hierarchy, while `Any` is at the very top.
  prefs: []
  type: TYPE_NORMAL
- en: When we declared the type of our `Tree` as `out T`, we meant that our `Tree`
    could contain values of type `T` or anything that inherits from that type.
  prefs: []
  type: TYPE_NORMAL
- en: Since `Nothing` is at the bottom of a class hierarchy, it *inherits* from all
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that everything has been set, let''s learn how to create a new instance
    of the tree we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a tree with **1** as the value of the root node and a right
    node with a value of **2**. The right node has a left child with a value of **3**.
    This is what our tree looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Tree diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17816_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Tree diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'However, printing the tree in such a form is not very interesting. So, let''s
    implement a function that will summarize all the nodes of a tree if it''s numeric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: This is also called an **operation** on an ADT. This is an extension function
    that is declared only on trees that contain integers.
  prefs: []
  type: TYPE_NORMAL
- en: For each node, we check whether it's `Empty` or `Node`. That's the beauty of
    `sealed` classes and interfaces. Since the compiler knows that the `Tree` interface
    has exactly two implementations, we don't need an `else` block in our `when` expression.
  prefs: []
  type: TYPE_NORMAL
- en: If it's an `Empty` node, we use `0` as a neutral value. If it's not empty, then
    we sum its values with the left and right children.
  prefs: []
  type: TYPE_NORMAL
- en: This function is also another example of a recursive algorithm, which we discussed
    in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional
    Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss another topic related to generics in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Reified generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we mentioned `inline` functions. Since `inline`
    functions are copied, we can get rid of one of the major JVM limitations: **type
    erasure**. After all, inside the function, we know exactly what type we''re getting.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the following example. We would like to create a generic function
    that will receive a `Number` (`Number` can either be `Int` or `Long`), but will
    only print it if it's of the same type as the function type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a naïve implementation, simply trying the instance check
    on the type directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this code won''t compile and we''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'What we usually do in Java, in this case, is pass the class as an argument.
    We can try a similar approach in Kotlin. If you''ve worked with Android before,
    you''ll recognize this pattern immediately, since it''s used a lot in the standard
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that the code works correctly by running the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works but has a few downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use the `is` operator and must use the `isInstance()` function instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must pass the correct class; that is, `clazz: KClass<T>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This code could be improved by using a `reified` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: This function works the same as the previous one but doesn't need a class as
    input to work. A function that uses a `reified` type must be declared as `inline`.
    This is due to type erasure on the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test that our code still works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that now, we specify the type that the function operates on, such as
    `Int` or `Long`, between *angular brackets*, instead of passing a class to it
    as an argument. We get the following benefits from using the `reified` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A clear method signature, without the need to pass a class as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to use the `is` construct inside the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's type-inference friendly, which means that if the *type* parameter can be
    inferred by the compiler, it can be completely omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the same rules for the regular `inline` functions apply here. This
    code would be replicated, so it shouldn't be too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider another case for `reified` types – **function overloading**.
    We''ll try to define two functions with the same name that differ only in terms
    of the types they operate on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'This won''t compile because there''s a platform declaration clash. Both have
    the same signature in terms of JVM: `printList(list: List)`. This is because types
    are erased during compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But with `reified`, we can achieve this easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Since the entire function is *inlined*, we can check the actual type of the
    list and output the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: Using constants efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since everything in Java is an object (unless it's a primitive type), we're
    used to putting all the constants inside our objects as static members.
  prefs: []
  type: TYPE_NORMAL
- en: 'And since Kotlin has `companion` objects, we usually try putting them there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: This will work, but you should remember that `companion object` is an object,
    after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this will be translated into the following code, more or less:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the Kotlin compiler generates a getter for our constant, which
    adds another level of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the code using the constant, we''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: We can invoke a method to get the constant value, which is not very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s mark this value as constant and see how the code produced by the
    compiler changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the bytecode changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there's no reference for our `Spock` class in the code anymore.
    The compiler has already *inlined* its value for us. After all, it's constant,
    so it will never change and can be safely *inlined*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all you need is a constant, you can also set it up outside of any class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you need namespacing, you can wrap it in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've learned how to use constants more efficiently, let's learn how
    to work with constructors in an idiomatic manner.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor overload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, we''re used to having overloaded constructors. For example, let''s
    look at the following Java class, which requires the `a` parameter and defaults
    the value of `b` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simulate the same behavior in Kotlin by defining multiple constructors
    using the `constructor` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: The secondary constructor, as defined in the class body, will invoke the primary
    constructor, providing `1` as the default value for the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s usually better to have default parameter values and named arguments
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all the secondary constructors must delegate to the primary constructor
    using the `this` keyword. The only exception is when you have a default primary
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's discuss how to efficiently handle nulls in Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with nulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`null` in Kotlin; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'We could rewrite this code using the `Elvis` operator (`?:`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: If the length is not `null`, this operator will return its value. Otherwise,
    it will return the default value we supplied, which is `0` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a nested object, you can chain those checks. For example, let''s
    have a `Response` object that contains a `Profile`, which, in turn, contains the
    first name and last name fields, which can be nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'This chaining will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: If any of the fields in the chain are null, our code won't crash. Instead, it
    will print `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can use the `let()` block for null checks, as we briefly mentioned
    in the *Using the scope functions* section. The same code, but using the `let()`
    function instead, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to get rid of `it` everywhere, you can use another scoping function,
    `run()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to avoid using the unsafe `!!` null operator in production code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: This will result in `KotlinNullPointerException`. However, during tests, the
    `!!` operator may prove useful, as it will help you spot null-safety issues faster.
  prefs: []
  type: TYPE_NORMAL
- en: Making asynchronicity explicit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you saw in the previous chapter, it is very easy to create an asynchronous
    function in Kotlin. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: However, this asynchronicity may be an unexpected behavior for the user of the
    function, as they may expect a simple value.
  prefs: []
  type: TYPE_NORMAL
- en: '*What do you think the following code prints?*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'For the user, the preceding code somewhat unexpectedly prints the following
    instead of `"OK"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you have read [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164),
    *Threads and Coroutines*, you will know that what''s missing here is the `await()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'But it would have been a lot more obvious if we''d named our function accordingly,
    by adding an `async` suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin's convention is to distinguish asynchronous functions from regular ones
    by adding `Async` to the end of the function's name. If you're working with **IntelliJ
    IDEA**, it will even suggest you that rename it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about some built-in functions for validating the user's input.
  prefs: []
  type: TYPE_NORMAL
- en: Validating input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input validation is a necessary but very tedious task. *How many times did you
    have to write code like the following?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you can check arguments with the `require()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the code a lot more fluent. You can use `require()` to check for
    nulls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'But there''s also `requireNotNull()` for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `check()` to validate the state of your object. This is useful when you
    are providing an object that the user may not have set up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, there''s a shortcut for this as well: `checkNotNull()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the `require()` and `check()` functions is that `require()`
    throws `IllegalArgumentException`, implying that the input that was provided to
    the function was incorrect. On the other hand, `check()` throws `IllegalStateException`,
    which means that the state of the object is corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Consider using functions such as `require()` and `check()` to improve the readability
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's discuss how to efficiently represent different states in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring sealed classes over enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming from Java, you may be tempted to overload your `enum` with functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say you build an application that allows users to order
    a pizza and track its status. We can use the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `sealed` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a separate class for each object state, extending the `PizzaOrderStatus`
    sealed class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of this approach is that we can now store the state, along with
    its `status`, more easily. In our example, we can store the ID of the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: In general, `sealed` classes are good if you want to have data associated with
    a state, and you should prefer them over enums.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the best practices in Kotlin, as well as some of
    the caveats of the language. Now, you should be able to write more idiomatic code
    that is also performant and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: You should make use of the scoping functions where necessary, but make sure
    not to overuse them as they may make the code confusing, especially for those
    newer to the language.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to handle nulls and type casts correctly, with `let()`, the `Elvis`
    operator, and the smart casts that the language provides. Finally, generics and
    `sealed` classes and interfaces are powerful tools that help describe complex
    relationships and behaviors between different classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll put those skills to use by writing a real-life microservice
    Reactive design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the alternative to Java's try-with-resources in Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different options for handling nulls in Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which problem can be solved by reified generics?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
