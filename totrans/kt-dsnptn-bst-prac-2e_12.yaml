- en: '*Chapter 9*: Idioms and Anti-Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：惯用和反模式'
- en: In the previous chapters, we discussed the different aspects of the Kotlin programming
    language, the benefits of functional programming, and concurrent design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了Kotlin编程语言的不同方面、函数式编程的好处以及并发设计模式。
- en: This chapter discusses the best and worst practices in Kotlin. You'll learn
    what idiomatic Kotlin code should look like and which patterns to avoid. This
    chapter contains a collection of best practices spanning those different topics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Kotlin的最佳和最差实践。你将了解惯用的Kotlin代码应该是什么样子，以及哪些模式应该避免。本章包含了一个涵盖这些不同主题的最佳实践集合。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using the scope functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用作用域函数
- en: Type checks and casts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查和转换
- en: An alternative to the try-with-resources statement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: try-with-resources语句的替代方案
- en: Inline functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数
- en: Implementing algebraic data types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现代数数据类型
- en: Reified generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新泛型
- en: Using constants efficiently
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用常量
- en: Constructor overload
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数重载
- en: Dealing with nulls
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理null值
- en: Making asynchronicity explicit
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确异步性
- en: Validating input
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入
- en: Preferring sealed classes over enums
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用密封类而不是枚举
- en: After completing this chapter, you should be able to write more readable and
    maintainable Kotlin code, as well as avoid some common pitfalls.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该能够编写更易于阅读和维护的Kotlin代码，以及避免一些常见的陷阱。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In addition to the requirements from the previous chapters, you will also need
    a **Gradle**-enabled **Kotlin** project to be able to add the required dependencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几章的要求之外，你还需要一个**Gradle**启用的**Kotlin**项目，以便能够添加所需的依赖项。
- en: 'You can find the source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的源代码：[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09)。
- en: Using the scope functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用作用域函数
- en: Kotlin has the concept of **scoping functions**, which are available on any
    object and can replace the need to write repetitive code. Among other benefits,
    these scoping functions help us simplify single-expression functions. They are
    considered higher-order functions since each scoping function receives a lambda
    expression as an argument. In this section, we'll discuss all the necessary functions
    and execute their code blocks using objects as their *scope*. In this section,
    we'll use the terms *scope* and *context object* interchangeably to describe the
    objects that those functions operate on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有**作用域函数**的概念，这些函数在任何对象上都是可用的，可以替代编写重复代码的需要。除了其他好处之外，这些作用域函数帮助我们简化单表达式函数。它们被认为是高阶函数，因为每个作用域函数都接收一个lambda表达式作为参数。在本节中，我们将讨论所有必要的函数，并使用对象作为它们的*作用域*来执行它们的代码块。在本节中，我们将交替使用*作用域*和*上下文对象*来描述这些函数操作的对象。
- en: Let function
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令函数
- en: We can use the `let()` function to invoke a function on a nullable object, but
    only if the object is not null.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`let()`函数在可空对象上调用一个函数，但前提是这个对象不是null。
- en: 'Let''s take, as an example, the following map of quotes (we discussed this
    in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Kotlin*):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下引言地图（我们在[*第1章*](B17816_01_ePub.xhtml#_idTextAnchor015)，*Kotlin入门*）为例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s fetch a quote from a movie that may not exist in the collection
    and print it, but only if it''s not null:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从一个可能不在集合中的电影中获取一个引言并打印它，但前提是它不是null：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same code can we rewritten using the `let` scoping function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的代码可以使用`let`作用域函数重写：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One common mistake is forgetting to use the safe navigation operator before
    `let`, because `let()` by itself also works on nulls:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是忘记在`let`之前使用安全导航操作符，因为`let()`本身也可以在null上工作：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code will print `null` to the console. Make sure that you don't forget
    the question mark (`?`) when you use `let()` for null checks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在控制台打印`null`。确保在使用`let()`进行null检查时不要忘记问号（`?`）。
- en: Apply function
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apply函数
- en: We have discussed `apply()` in previous chapters. It returns the same object
    it operates on and sets the context to `this`. You can use `apply()` if you need
    to initialize a mutable object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中讨论了`apply()`。它返回它操作的对象，并将上下文设置为`this`。如果你需要初始化一个可变对象，可以使用`apply()`。
- en: 'Think of how many times you had to create a class that has an empty constructor,
    and then call a lot of setters, one after another. Let''s look at the following
    class as an example. This may be a class that comes from a library, for example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你有多少次不得不创建一个具有空构造函数的类，然后依次调用很多设置器。以下是一个例子，这可能是一个来自库的类。例如：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we need to create a new instance of such a class, we could do so in a
    procedural manner:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要创建此类的新实例时，我们可以以过程式的方式这样做：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, we can only set `name` and `movie`, and leave `alsoStarring`
    blank, using the `apply()` function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以只设置 `name` 和 `movie`，并使用 `apply()` 函数将 `alsoStarring` 留空：
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since the context of the block is set to `this`, we can simplify the preceding
    code even further:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码块的范围被设置为 `this`，我们可以进一步简化前面的代码：
- en: '[PRE27]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the `apply()` function is especially good when you're working with Java
    classes that usually have a lot of setters and a default empty constructor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `apply()` 函数在处理通常有很多设置器和默认空构造函数的 Java 类时特别有用。
- en: Also function
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`also` 函数'
- en: 'As we mentioned in the introduction to this section, single-expression functions
    are very nice and concise. Let''s look at the following simple function, which
    multiplies two numbers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节介绍的引言中提到的，单表达式函数非常简洁。让我们看看以下简单的函数，它乘以两个数字：
- en: '[PRE31]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But often, you have a single-statement function that also needs to, for example,
    write to a log or have another side effect. To achieve this, we could rewrite
    our function in the following way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常，你有一个单语句函数，还需要执行其他操作，例如写入日志或产生其他副作用。为了实现这一点，我们可以将我们的函数重写如下：
- en: '[PRE32]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We had to make our function much more verbose here and introduce another variable.
    Let''s see how we can use the `also()` function instead:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不在这里使我们的函数更加冗长，并引入另一个变量。让我们看看我们如何使用 `also()` 函数来替代：
- en: '[PRE37]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This function will assign the results of the expression to `it` and return
    the result of the expression. The `also()` function is also useful when you want
    to have a side effect on a chain of calls:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将表达式的结果分配给 `it` 并返回表达式的结果。`also()` 函数在你想在一系列调用中产生副作用时也非常有用：
- en: '[PRE39]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, you can see that we can continue our chain of calls with a `map()` function,
    even though we used the `also()` function to print each element of a list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们可以继续使用 `map()` 函数来继续我们的调用链，即使我们使用了 `also()` 函数来打印列表中的每个元素。
- en: Run function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行函数
- en: The `run()` function is very similar to the `let()` function, but it sets the
    context of the block to `this` instead of using `it`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 函数与 `let()` 函数非常相似，但它将代码块的范围设置为 `this` 而不是使用 `it`。'
- en: 'Let''s look at an example to understand this better:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解这一点：
- en: '[PRE44]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, `this` is set to reference the `justAString` variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`this` 被设置为引用 `justAString` 变量。
- en: 'Usually, `this` could be omitted, so the code will look as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`this` 可以省略，所以代码将如下所示：
- en: '[PRE48]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `run()` function is mostly useful when you plan to initialize an object,
    much like the `apply()` function we discussed earlier. However, instead of returning
    the object itself, like `apply()` does, you usually like to return the result
    of some computation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 函数主要用于初始化对象，就像我们之前讨论的 `apply()` 函数一样。然而，与 `apply()` 不同，它返回对象本身，而不是返回某些计算的结果：'
- en: '[PRE51]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code prints the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印以下输出：
- en: '[PRE57]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, the object was initialized with `"ROGER MOORE"`. Note that here, we operated
    on the `JamesBond` object, but our return value was a `String`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对象使用 `"ROGER MOORE"` 初始化。注意，在这里，我们对 `JamesBond` 对象进行了操作，但我们的返回值是一个 `String`。
- en: With function
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数
- en: 'Unlike the other four scoping functions, `with()` is not an extension function.
    This means you cannot do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他四个作用域函数不同，`with()` 不是一个扩展函数。这意味着你不能这样做：
- en: '[PRE58]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Instead, `with()` receives the object you want to scope as an argument:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`with()` 接收你想要作用域的对象作为参数：
- en: '[PRE59]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And as usual, we can omit `this`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，像往常一样，我们可以省略 `this`：
- en: '[PRE62]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Just like `run()` and `let()`, you can return any result from `with()`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `run()` 和 `let()` 一样，你可以从 `with()` 中返回任何结果。
- en: In this section, we learned how the various scope functions can help reduce
    the amount of boilerplate code by defining a code block to be executed on the
    object. In the next section, we'll see how Kotlin also allows us to write fewer
    instance checks than other languages.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了各种作用域函数如何通过定义要在对象上执行的代码块来帮助减少样板代码的数量。在下一节中，我们将看到 Kotlin 还允许我们比其他语言编写更少的实例检查。
- en: Type checks and casts
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查和转换
- en: 'While writing your code, you may often be inclined to check what type your
    object is using, `is`, and cast it using `as`. As an example, let''s imagine we''re
    building a system for superheroes. Each superhero has their own set of methods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，你可能会倾向于检查你的对象类型，使用`is`，然后使用`as`进行转换。作为一个例子，让我们想象我们正在构建一个超级英雄系统。每个超级英雄都有自己的方法集：
- en: '[PRE65]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'There''s also a function where a superhero tries to invoke their superpower:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个函数，超级英雄试图施展他们的超能力：
- en: '[PRE76]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'But as you may know, Kotlin has smart casts, so implicit casting, in this case,
    is not needed. Let''s rewrite this function using smart casts and see how they
    improve our code. All we need to do is remove the explicit casts from our code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你所知，Kotlin有智能转换，所以在这种情况下，隐式转换不是必需的。让我们使用智能转换重写这个函数，看看它们如何改进我们的代码。我们只需要从我们的代码中移除显式转换：
- en: '[PRE84]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Moreover, in most cases, using `when()` while smart casting produces cleaner
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在大多数情况下，使用`when()`进行智能转换会产生更干净的代码：
- en: '[PRE92]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As a rule of thumb, you should avoid using casts and rely on smart casts most
    of the time:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，你应该避免使用转换，并尽可能多地依赖智能转换：
- en: '[PRE99]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'But if you absolutely must, there''s also a safe cast operator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你绝对必须，还有一个安全转换运算符：
- en: '[PRE101]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The **safe cast operator** will return null if the object cannot be cast, instead
    of throwing an exception.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全转换运算符**如果对象无法转换，将返回null，而不是抛出异常。'
- en: An alternative to the try-with-resources statement
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try-with-resources语句的替代方案
- en: '`AutoCloseable` and the try-with-resources statement.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoCloseable`和try-with-resources语句。'
- en: This statement allows us to provide a set of resources that will be automatically
    closed once the code is done with them. So, there will be no more risk (or at
    least less risk) of forgetting to close a file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明使我们能够提供一组资源，一旦代码使用完毕，这些资源将被自动关闭。因此，将不再有忘记关闭文件的风险（或者至少风险更小）。
- en: 'Before Java 7, this was a total mess, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7之前，这完全是混乱的，如下面的代码所示：
- en: '[PRE102]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'After **Java 7** was released, the preceding code could be written as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7发布后，前面的代码可以写成以下形式：
- en: '[PRE113]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Kotlin doesn''t support this syntax. Instead, the try-with-resource statement
    is replaced with the `use()` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin不支持这种语法。相反，try-with-resource语句被`use()`函数所取代：
- en: '[PRE116]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: An object must implement the `Closeable` interface for the `use()` function
    to be available. The `Closeable` object will be closed as soon as we exit the
    `use{}` block.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对象必须实现`Closeable`接口，`use()`函数才可用。`Closeable`对象将在我们退出`use{}`块时关闭。
- en: Inline functions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联函数
- en: You can think of `inline` functions as instructions for the compiler to copy
    and paste your code. Each time the compiler sees a call to a function marked with
    the `inline` keyword, it will replace the call with the concrete function body.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`inline`函数视为编译器复制和粘贴你的代码的指令。每次编译器看到标记为`inline`关键字的函数调用时，它都会将调用替换为具体的函数体。
- en: It makes sense to use the `inline` function if it's a higher-order function
    that receives a lambda as one of its arguments. This is the most common use case
    where you would like to use `inline`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个接受lambda作为其参数之一的高阶函数，那么使用`inline`函数是有意义的。这是你想要使用`inline`的最常见用例。
- en: Let's look at such a higher-order function and see what pseudocode the compiler
    will output.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这样的高阶函数，看看编译器将输出什么伪代码。
- en: 'First, here is the function definition:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是函数定义：
- en: '[PRE120]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here, we pass a lambda, or a `block`, to our function. This `block` simply
    returns the word `"Inlining"` as a `String`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向函数传递一个lambda，或一个`block`。这个`block`简单地返回单词`"Inlining"`作为一个`String`：
- en: '[PRE125]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'If you were to view the Java equivalent of the decompiled bytecode, you''d
    see that there''s no call to our `makesSense` function at all. Instead, you''d
    see the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看反编译的字节码的Java等效版本，你会看到根本就没有调用我们的`makesSense`函数。相反，你会看到以下内容：
- en: '[PRE128]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Since the `inline` function is a copy/paste of your code, you shouldn't use
    it if you have more than a few lines of code. It would be more efficient to have
    it as a regular function. But if you have single-expression functions that receive
    a lambda, it makes sense to mark them with the `inline` keyword to optimize performance.
    In the end, it's a trade-off between the size of your application and its performance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`inline`函数是代码的复制/粘贴，如果你有超过几行代码，就不应该使用它。将其作为常规函数会更有效率。但如果你有接受lambda作为参数的单表达式函数，使用`inline`关键字来优化性能是有意义的。最终，这是应用程序大小和性能之间的权衡。
- en: Implementing Algebraic Data Types
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现代数数据类型
- en: '**Algebraic Data Types**, or **ATDs** for short, is a concept from functional
    programming and is very similar to the **Composite design pattern** we discussed
    in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080), *Understanding Structural
    Patterns*.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**代数数据类型**，或简称 **ADTs**，是函数式编程中的一个概念，它与我们在 [*第3章*](B17816_03_ePub.xhtml#_idTextAnchor080)
    *理解结构模式* 中讨论的 **组合设计模式** 非常相似。'
- en: To understand how ADTs work and what their benefits are, let's discuss how we
    can implement a simple binary tree in Kotlin.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 ADTs 的工作原理以及它们的优点，让我们讨论如何在 Kotlin 中实现一个简单的二叉树。
- en: 'First, let''s declare an interface for our tree. Since a tree data structure
    can contain any type of data, we can parameterize it with a type (`T`):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的树声明一个接口。由于树数据结构可以包含任何类型的数据，我们可以用类型（`T`）来参数化它：
- en: '[PRE134]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The type is marked with an `out` keyword, which means that this type is *covariant*.
    If you aren't familiar with this term, we'll cover it later, while implementing
    the interface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 类型用 `out` 关键字标记，这意味着这个类型是 *协变的*。如果你不熟悉这个术语，我们将在实现接口时再讨论它。
- en: The opposite of a covariant is a *contravariant*. Contravariant types should
    be marked using the `in` keyword.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 协变的对立面是 *逆变的*。逆变类型应该使用 `in` 关键字标记。
- en: We can also mark this interface with a `sealed` keyword. We saw this keyword
    applied to regular classes in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, while discussing the `sealed` interfaces
    are a relatively new feature and were introduced in **Kotlin 1.5**.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用 `sealed` 关键字标记这个接口。我们在 [*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)
    *熟悉行为模式* 中讨论了将此关键字应用于常规类，而 `sealed` 接口是一个相对较新的特性，它是在 **Kotlin 1.5** 中引入的。
- en: 'The meaning is the same, though: only the owner of the interface can implement
    it. This means that all the implementations of the interface are known at compile
    time.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 意义是相同的：只有接口的所有者才能实现它。这意味着在编译时就可以知道接口的所有实现。
- en: 'Next, let''s declare what an empty tree looks like:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们声明一个空树看起来像什么：
- en: '[PRE135]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Since all empty trees are the same, we declare it as an object. This is another
    use of the `Nothing` as the type of an empty tree. This is a special class in
    Kotlin's object hierarchy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有空树都是相同的，我们将其声明为一个对象。这是 `Nothing` 作为空树类型的另一个用途。这是 Kotlin 对象层次结构中的一个特殊类。
- en: 'Important Note:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: There is some confusion between `Any`, which represents any class and is similar
    to `Object` in Java, and `Nothing`, which represents no class. We'll see why `Any`
    wouldn't work in this case later in this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Any` 和 `Nothing` 之间存在一些混淆，`Any` 代表任何类，类似于 Java 中的 `Object`，而 `Nothing` 代表没有类。我们将在本章后面看到为什么
    `Any` 在这个情况下不起作用。
- en: 'Next, let''s define a non-empty node of a tree:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个非空树节点：
- en: '[PRE138]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '`Node` also implements the `Tree` interface, but it is a data class and not
    an object since every node is different. The type of the value of a `Node` is
    `T`, which means it can contain any type of value, but all the nodes in the same
    tree will contain the same type of value. This is the real power of generics.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node` 也实现了 `Tree` 接口，但它是一个数据类，而不是一个对象，因为每个节点都是不同的。`Node` 的值类型是 `T`，这意味着它可以包含任何类型的值，但同一树中的所有节点都将包含相同类型的值。这是泛型真正的力量。'
- en: A node also has two children, left and right, since it's a binary tree. By default,
    both of them are empty.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 节点也有两个子节点，左和右，因为它是一个二叉树。默认情况下，它们都是空的。
- en: We can specify the default values for the children of a node thanks to the fact
    that the type is covariant and `Empty` is of the `Nothing` type. `Nothing` is
    at the bottom of the class hierarchy, while `Any` is at the very top.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型是协变的，并且 `Empty` 是 `Nothing` 类型，我们可以指定节点子节点的默认值。`Nothing` 在类层次结构的底部，而 `Any`
    在顶部。
- en: When we declared the type of our `Tree` as `out T`, we meant that our `Tree`
    could contain values of type `T` or anything that inherits from that type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明 `Tree` 的类型为 `out T` 时，我们的意思是 `Tree` 可以包含类型 `T` 的值或继承自该类型的任何值。
- en: Since `Nothing` is at the bottom of a class hierarchy, it *inherits* from all
    types.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Nothing` 在类层次结构的底部，它 *继承* 自所有类型。
- en: 'Now that everything has been set, let''s learn how to create a new instance
    of the tree we just defined:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，让我们学习如何创建我们刚刚定义的树的实例：
- en: '[PRE143]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Here, we created a tree with **1** as the value of the root node and a right
    node with a value of **2**. The right node has a left child with a value of **3**.
    This is what our tree looks like:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个以 **1** 为根节点值和具有 **2** 值的右节点的树。右节点有一个值为 **3** 的左子节点。这就是我们的树看起来像什么：
- en: '![Figure 9.1 – Tree diagram'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 树形图'
- en: '](img/B17816_09_01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17816_09_01.jpg)'
- en: Figure 9.1 – Tree diagram
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 树形图
- en: 'The preceding code outputs the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出以下内容：
- en: '[PRE152]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'However, printing the tree in such a form is not very interesting. So, let''s
    implement a function that will summarize all the nodes of a tree if it''s numeric:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以这种形式打印树并不很有趣。所以，让我们实现一个函数，如果树是数值型的，它会总结树的所有节点：
- en: '[PRE153]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This is also called an **operation** on an ADT. This is an extension function
    that is declared only on trees that contain integers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这也称为ADT上的**操作**。这是一个仅在包含整数的树上声明的扩展函数。
- en: For each node, we check whether it's `Empty` or `Node`. That's the beauty of
    `sealed` classes and interfaces. Since the compiler knows that the `Tree` interface
    has exactly two implementations, we don't need an `else` block in our `when` expression.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点，我们检查它是否是`Empty`或`Node`。这就是`sealed`类和接口的美丽之处。由于编译器知道`Tree`接口恰好有两个实现，因此我们不需要在`when`表达式中使用`else`块。
- en: If it's an `Empty` node, we use `0` as a neutral value. If it's not empty, then
    we sum its values with the left and right children.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个`Empty`节点，我们使用`0`作为中性值。如果它不为空，那么我们将它的值与其左右子节点的值相加。
- en: This function is also another example of a recursive algorithm, which we discussed
    in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional
    Programming*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数也是递归算法的另一个例子，我们在[*第5章*](B17816_05_ePub.xhtml#_idTextAnchor144)，“介绍函数式编程”中讨论过。
- en: Now, let's discuss another topic related to generics in Kotlin.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论与Kotlin中的泛型相关的话题。
- en: Reified generics
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实化泛型
- en: 'Previously in this chapter, we mentioned `inline` functions. Since `inline`
    functions are copied, we can get rid of one of the major JVM limitations: **type
    erasure**. After all, inside the function, we know exactly what type we''re getting.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们提到了`inline`函数。由于`inline`函数被复制，我们可以消除JVM的一个主要限制：**类型擦除**。毕竟，在函数内部，我们知道我们得到的确切类型。
- en: Let's look at the following example. We would like to create a generic function
    that will receive a `Number` (`Number` can either be `Int` or `Long`), but will
    only print it if it's of the same type as the function type.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。我们希望创建一个泛型函数，该函数将接收一个`Number`（`Number`可以是`Int`或`Long`），但只有当它的类型与函数类型相同时才会打印它。
- en: 'We''ll start with a naïve implementation, simply trying the instance check
    on the type directly:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一种简单的实现开始，直接尝试在类型上执行实例检查：
- en: '[PRE157]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'However, this code won''t compile and we''ll get the following error:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码无法编译，我们会得到以下错误：
- en: '[PRE162]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'What we usually do in Java, in this case, is pass the class as an argument.
    We can try a similar approach in Kotlin. If you''ve worked with Android before,
    you''ll recognize this pattern immediately, since it''s used a lot in the standard
    library:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通常在Java中传递类作为参数。我们可以在Kotlin中尝试类似的方法。如果你之前使用过Android，你会立即认出这个模式，因为它在标准库中用得很多：
- en: '[PRE163]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'We can check that the code works correctly by running the following lines:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下行来检查代码是否正确工作：
- en: '[PRE171]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'This code works but has a few downsides:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作，但有一些缺点：
- en: We cannot use the `is` operator and must use the `isInstance()` function instead.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能使用`is`运算符，而必须使用`isInstance()`函数。
- en: 'We must pass the correct class; that is, `clazz: KClass<T>`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们必须传递正确的类；即`clazz: KClass<T>`。'
- en: 'This code could be improved by using a `reified` type:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以通过使用`reified`类型来改进：
- en: '[PRE174]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: This function works the same as the previous one but doesn't need a class as
    input to work. A function that uses a `reified` type must be declared as `inline`.
    This is due to type erasure on the JVM.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与上一个函数的工作方式相同，但不需要输入一个类即可工作。使用`reified`类型的函数必须声明为`inline`。这是由于JVM上的类型擦除。
- en: 'We can test that our code still works as expected:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式测试我们的代码是否仍然按预期工作：
- en: '[PRE181]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Notice that now, we specify the type that the function operates on, such as
    `Int` or `Long`, between *angular brackets*, instead of passing a class to it
    as an argument. We get the following benefits from using the `reified` functions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在，我们在*尖括号*中指定函数操作的类型，例如`Int`或`Long`，而不是将其作为参数传递给函数。使用`reified`函数我们可以获得以下好处：
- en: A clear method signature, without the need to pass a class as an argument.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的方法签名，无需传递一个类作为参数。
- en: The ability to use the `is` construct inside the function.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部使用`is`构造的能力。
- en: It's type-inference friendly, which means that if the *type* parameter can be
    inferred by the compiler, it can be completely omitted.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对类型推断友好，这意味着如果类型参数可以被编译器推断出来，它就可以完全省略。
- en: Of course, the same rules for the regular `inline` functions apply here. This
    code would be replicated, so it shouldn't be too large.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，常规 `inline` 函数的相同规则也适用于这里。这段代码将被复制，所以它不应该太大。
- en: 'Now, let''s consider another case for `reified` types – **function overloading**.
    We''ll try to define two functions with the same name that differ only in terms
    of the types they operate on:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑 `reified` 类型的另一个用例——**函数重载**。我们将尝试定义两个具有相同名称但操作类型不同的函数：
- en: '[PRE184]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'This won''t compile because there''s a platform declaration clash. Both have
    the same signature in terms of JVM: `printList(list: List)`. This is because types
    are erased during compilation.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '这将无法编译，因为存在平台声明冲突。它们在 JVM 方面具有相同的签名：`printList(list: List)`。这是因为类型在编译过程中被擦除。'
- en: 'But with `reified`, we can achieve this easily:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用 `reified`，我们可以轻松实现这一点：
- en: '[PRE192]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Since the entire function is *inlined*, we can check the actual type of the
    list and output the correct result.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个函数是**内联**的，我们可以检查列表的实际类型并输出正确的结果。
- en: Using constants efficiently
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用常量
- en: Since everything in Java is an object (unless it's a primitive type), we're
    used to putting all the constants inside our objects as static members.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 中的所有内容都是对象（除非是原始类型），我们习惯于将所有常量作为静态成员放入我们的对象中。
- en: 'And since Kotlin has `companion` objects, we usually try putting them there:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kotlin 有 `companion` 对象，我们通常尝试将它们放在那里：
- en: '[PRE200]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: This will work, but you should remember that `companion object` is an object,
    after all.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，但你应该记住，`companion object` 仍然是一个对象。
- en: 'So, this will be translated into the following code, more or less:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这将大致转换为以下代码：
- en: '[PRE205]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: In this example, the Kotlin compiler generates a getter for our constant, which
    adds another level of indirection.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Kotlin 编译器为我们的常量生成一个 getter，这增加了另一个间接层。
- en: 'If we look at the code using the constant, we''ll see the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看使用常量的代码，我们会看到以下内容：
- en: '[PRE212]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: We can invoke a method to get the constant value, which is not very efficient.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用一个方法来获取常量值，这并不高效。
- en: 'Now, let''s mark this value as constant and see how the code produced by the
    compiler changes:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此值标记为常量，看看编译器生成的代码如何变化：
- en: '[PRE214]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Here are the bytecode changes:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是字节码的变化：
- en: '[PRE219]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'And here is the call:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个调用的示例：
- en: '[PRE223]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Notice that there's no reference for our `Spock` class in the code anymore.
    The compiler has already *inlined* its value for us. After all, it's constant,
    so it will never change and can be safely *inlined*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码中已经没有 `Spock` 类的引用了。编译器已经为我们**内联**了它的值。毕竟，它是常量，所以它永远不会改变，可以安全地**内联**。
- en: 'If all you need is a constant, you can also set it up outside of any class:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个常量，你也可以在类外部设置它：
- en: '[PRE225]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'And if you need namespacing, you can wrap it in an object:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要命名空间，你可以将其包裹在一个对象中：
- en: '[PRE226]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Now that we've learned how to use constants more efficiently, let's learn how
    to work with constructors in an idiomatic manner.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何更有效地使用常量，让我们学习如何以惯用的方式处理构造函数。
- en: Constructor overload
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数重载
- en: 'In Java, we''re used to having overloaded constructors. For example, let''s
    look at the following Java class, which requires the `a` parameter and defaults
    the value of `b` to `1`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，我们习惯于使用重载构造函数。例如，让我们看看以下需要 `a` 参数并将 `b` 的值默认设置为 `1` 的 Java 类：
- en: '[PRE229]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'We can simulate the same behavior in Kotlin by defining multiple constructors
    using the `constructor` keyword:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `constructor` 关键字定义多个构造函数来在 Kotlin 中模拟相同的行为：
- en: '[PRE240]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The secondary constructor, as defined in the class body, will invoke the primary
    constructor, providing `1` as the default value for the second argument.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 次构造函数，如类体中定义的，将调用主构造函数，为第二个参数提供默认值 `1`。
- en: 'However, it''s usually better to have default parameter values and named arguments
    instead:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常最好有默认参数值和命名参数：
- en: '[PRE243]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Note that all the secondary constructors must delegate to the primary constructor
    using the `this` keyword. The only exception is when you have a default primary
    constructor:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有次构造函数都必须使用 `this` 关键字委托给主构造函数。唯一的例外是当你有一个默认的主构造函数：
- en: '[PRE244]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Next, let's discuss how to efficiently handle nulls in Kotlin code.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何在 Kotlin 代码中高效地处理空值。
- en: Dealing with nulls
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理空值
- en: '`null` in Kotlin; for example:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的 `null`；例如：
- en: '[PRE253]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'We could rewrite this code using the `Elvis` operator (`?:`):'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Elvis` 操作符（`?:`）重写此代码：
- en: '[PRE261]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: If the length is not `null`, this operator will return its value. Otherwise,
    it will return the default value we supplied, which is `0` in this case.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果长度不是 `null`，这个操作符将返回其值。否则，它将返回我们提供的默认值，在这种情况下是 `0`。
- en: 'If you have a nested object, you can chain those checks. For example, let''s
    have a `Response` object that contains a `Profile`, which, in turn, contains the
    first name and last name fields, which can be nullable:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个嵌套对象，你可以链式调用这些检查。例如，让我们有一个包含 `Profile` 的 `Response` 对象，而 `Profile` 又包含名字和姓氏字段，这些字段可能是可空的：
- en: '[PRE262]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'This chaining will look like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这种链式调用将看起来像这样：
- en: '[PRE269]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: If any of the fields in the chain are null, our code won't crash. Instead, it
    will print `null`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链中的任何字段为空，我们的代码不会崩溃。相反，它会打印 `null`。
- en: 'Finally, you can use the `let()` block for null checks, as we briefly mentioned
    in the *Using the scope functions* section. The same code, but using the `let()`
    function instead, will look like this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 `let()` 块来进行空检查，正如我们在 *使用作用域函数* 部分简要提到的。使用 `let()` 函数的相同代码将看起来像这样：
- en: '[PRE271]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'If you want to get rid of `it` everywhere, you can use another scoping function,
    `run()`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在所有地方去掉 `it`，你可以使用另一个作用域函数，`run()`：
- en: '[PRE276]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Try to avoid using the unsafe `!!` null operator in production code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免在生产代码中使用不安全的 `!!` 空操作符：
- en: '[PRE281]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: This will result in `KotlinNullPointerException`. However, during tests, the
    `!!` operator may prove useful, as it will help you spot null-safety issues faster.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 `KotlinNullPointerException`。然而，在测试期间，`!!` 操作符可能很有用，因为它可以帮助你更快地发现空安全的问题。
- en: Making asynchronicity explicit
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确异步性
- en: 'As you saw in the previous chapter, it is very easy to create an asynchronous
    function in Kotlin. Here is an example:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，在 Kotlin 中创建异步函数非常简单。以下是一个示例：
- en: '[PRE282]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: However, this asynchronicity may be an unexpected behavior for the user of the
    function, as they may expect a simple value.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种异步性可能对函数的用户来说是一个意外的行为，因为他们可能期望一个简单的值。
- en: '*What do you think the following code prints?*'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '*你认为以下代码会打印什么？*'
- en: '[PRE286]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'For the user, the preceding code somewhat unexpectedly prints the following
    instead of `"OK"`:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，前面的代码有些意外地打印了以下内容而不是 `"OK"`：
- en: '[PRE287]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Of course, if you have read [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164),
    *Threads and Coroutines*, you will know that what''s missing here is the `await()`
    function:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你已经阅读了 [*第6章*](B17816_06_ePub.xhtml#_idTextAnchor164)，*线程和协程*，你就会知道这里缺少的是
    `await()` 函数：
- en: '[PRE288]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'But it would have been a lot more obvious if we''d named our function accordingly,
    by adding an `async` suffix:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们给我们的函数添加一个 `async` 后缀，那么它就会更加明显：
- en: '[PRE289]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Kotlin's convention is to distinguish asynchronous functions from regular ones
    by adding `Async` to the end of the function's name. If you're working with **IntelliJ
    IDEA**, it will even suggest you that rename it.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的约定是在函数名末尾添加 `Async` 来区分异步函数和常规函数。如果你在使用 **IntelliJ IDEA**，它甚至会建议你重命名它。
- en: Now, let's talk about some built-in functions for validating the user's input.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈一些用于验证用户输入的内置函数。
- en: Validating input
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证输入
- en: Input validation is a necessary but very tedious task. *How many times did you
    have to write code like the following?*
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证是一项必要但非常繁琐的任务。*你有多少次不得不编写如下代码？*
- en: '[PRE293]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Instead, you can check arguments with the `require()` function:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用 `require()` 函数来检查参数：
- en: '[PRE299]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'This makes the code a lot more fluent. You can use `require()` to check for
    nulls:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更加流畅。你可以使用 `require()` 来检查空值：
- en: '[PRE302]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'But there''s also `requireNotNull()` for that:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有 `requireNotNull()` 可以做到这一点：
- en: '[PRE305]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'Use `check()` to validate the state of your object. This is useful when you
    are providing an object that the user may not have set up correctly:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `check()` 来验证你对象的状态。这在提供用户可能没有正确设置的对象时非常有用：
- en: '[PRE308]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'And again, there''s a shortcut for this as well: `checkNotNull()`.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这里也有一个快捷方式：`checkNotNull()`。
- en: The difference between the `require()` and `check()` functions is that `require()`
    throws `IllegalArgumentException`, implying that the input that was provided to
    the function was incorrect. On the other hand, `check()` throws `IllegalStateException`,
    which means that the state of the object is corrupted.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`require()` 和 `check()` 函数之间的区别在于 `require()` 会抛出 `IllegalArgumentException`，这意味着提供给函数的输入是错误的。另一方面，`check()`
    会抛出 `IllegalStateException`，这意味着对象的状态已被破坏。'
- en: Consider using functions such as `require()` and `check()` to improve the readability
    of your code.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用 `require()` 和 `check()` 函数来提高你代码的可读性。
- en: Finally, let's discuss how to efficiently represent different states in Kotlin.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论如何在 Kotlin 中有效地表示不同的状态。
- en: Preferring sealed classes over enums
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先考虑 `sealed` 类而不是枚举
- en: Coming from Java, you may be tempted to overload your `enum` with functionality.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Java 的你可能会倾向于在 `enum` 上添加功能。
- en: 'For example, let''s say you build an application that allows users to order
    a pizza and track its status. We can use the following code for this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你开发了一个允许用户订购披萨并跟踪其状态的程序。我们可以使用以下代码来完成这个任务：
- en: '[PRE317]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Alternatively, you can use the `sealed` class:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `sealed` 类：
- en: '[PRE329]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: Here, we created a separate class for each object state, extending the `PizzaOrderStatus`
    sealed class.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个对象状态创建了一个单独的类，这些类扩展了 `PizzaOrderStatus` `sealed` 类。
- en: 'The benefit of this approach is that we can now store the state, along with
    its `status`, more easily. In our example, we can store the ID of the order:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，我们现在可以更容易地存储状态及其 `status`。在我们的例子中，我们可以存储订单的 ID：
- en: '[PRE347]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: In general, `sealed` classes are good if you want to have data associated with
    a state, and you should prefer them over enums.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果你想要与状态关联数据，`sealed` 类是好的选择，你应该优先考虑它们而不是枚举。
- en: Summary
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the best practices in Kotlin, as well as some of
    the caveats of the language. Now, you should be able to write more idiomatic code
    that is also performant and maintainable.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 Kotlin 的最佳实践以及语言的一些注意事项。现在，你应该能够编写更符合语言习惯、性能良好且易于维护的代码。
- en: You should make use of the scoping functions where necessary, but make sure
    not to overuse them as they may make the code confusing, especially for those
    newer to the language.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在必要时，你应该使用作用域函数，但确保不要过度使用它们，因为它们可能会使代码变得混乱，尤其是对于那些刚开始使用该语言的人来说。
- en: Be sure to handle nulls and type casts correctly, with `let()`, the `Elvis`
    operator, and the smart casts that the language provides. Finally, generics and
    `sealed` classes and interfaces are powerful tools that help describe complex
    relationships and behaviors between different classes.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要正确处理空值和类型转换，使用 `let()`、`Elvis` 操作符以及语言提供的智能转换功能。最后，泛型和 `sealed` 类和接口是描述不同类之间复杂关系和行为的有力工具。
- en: In the next chapter, we'll put those skills to use by writing a real-life microservice
    Reactive design pattern.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过编写实际的微服务响应式设计模式来应用这些技能。
- en: Questions
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the alternative to Java's try-with-resources in Kotlin?
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 中 Java 的 try-with-resources 的替代方案是什么？
- en: What are the different options for handling nulls in Kotlin?
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 中处理空值的不同选项有哪些？
- en: Which problem can be solved by reified generics?
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新实例化的泛型可以解决哪些问题？
