<html><head></head><body>
		<div><h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><em class="italic">Chapter 1</em>: Getting Started with Clean Architecture</h1>
			<p>In this chapter, we'll take you back and show you how a feature would have been implemented in the past while analyzing the potential issues and problems with that approach. Then, we'll look at some key design principles for software development and apply those principles to our legacy examples. After that, we'll cover the evolution of the Android platform and the various libraries and frameworks that have emerged. We'll also see how they can be integrated while adhering to various software design principles. </p>
			<p>After that, we'll introduce clean architecture so that we know what our system needs to be improved and what questions we must ask, as developers, so that we can create a robust, scalable, maintainable, and testable application.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>The architecture of a legacy app</li>
				<li>Software design principles</li>
				<li>Exploring the evolution of Android </li>
				<li>Enter clean architecture</li>
			</ul>
			<p>By the end of this chapter, you will know about the evolution of Android development, its architecture, and its design concepts, as well as the concept of clean architecture and how it can be used to build flexible, maintainable, and testable applications. </p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements </h1>
			<p>For this chapter, you will need Android Studio Arctic Fox 2020.3.1 Patch 3.</p>
			<p>The following are the hardware requirements for this chapter:</p>
			<ul>
				<li>Windows:<ul><li>64-bit Microsoft® Windows® 8/10</li><li>x86_64 CPU architecture; 2nd generation Intel Core or newer, or an AMD CPU with support for a Windows Hypervisor</li><li>8 GB of RAM or more</li><li>8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)</li><li>1,280 x 800 minimum screen resolution</li></ul></li>
				<li>Mac:<ul><li>macOS® 10.14 (Mojave) or higher</li><li>ARM-based chips, or 2nd generation Intel Core or newer with support for Hypervisor.Framework</li><li>8 GB of RAM or more</li><li>8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)</li><li>1,280 x 800 minimum screen resolution</li></ul></li>
				<li>Linux:<ul><li>Any 64-bit Linux distribution that supports Gnome, KDE, or Unity DE; GNU C Library (glibc) 2.31 or later</li><li>x86_64 CPU architecture; 2nd generation Intel Core or newer, or AMD processor with support for AMD Virtualization (AMD-V) and SSSE3</li><li>8 GB of RAM or more</li><li>8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)</li><li>1,280 x 800 minimum screen resolution</li></ul></li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>The architecture of a legacy app</h1>
			<p>In this section, we will look at how Android applications<a id="_idIndexMarker000"/> used to be built in the past and what difficulties developers had with the approach taken.</p>
			<p>Before we start analyzing an older application, we must distinguish the architecture and design of an application. To borrow from the construction industry, we can define architecture as a plan for the structure of a building; a design would be a plan to create each part of the building. Translating this into the world of software engineering, we can say that the architecture of an application or a system would be defining a plan that would incorporate the business and technical requirements, while software design deals with integrating all the components, modules, and frameworks into this plan. In an ideal world, you would want to recognize the architecture of an application in the same way you would recognize the architecture of your house. </p>
			<p>Now, let's look at the four main components of an Android application:</p>
			<ul>
				<li><strong class="bold">Activities</strong>: These represent the entry<a id="_idIndexMarker001"/> points for interacting with the user.</li>
				<li><strong class="bold">Services</strong>: These represent the entry points<a id="_idIndexMarker002"/> for having an app run in the background for all kinds of reasons, such as large downloads or audio playback.</li>
				<li><strong class="bold">Broadcast Receivers</strong>: These allow the system<a id="_idIndexMarker003"/> to interact with an application for a variety of reasons.</li>
				<li><strong class="bold">Content Providers</strong>: These represent a way<a id="_idIndexMarker004"/> for an application to manage application data.</li>
			</ul>
			<p>Using and relying on these components created a challenge for developers because an app's architecture became dependent on the Android framework, mainly when it came to implementing unit tests. To understand why this is a problem, let's look at an example of what some older application code would look like. Let's suppose you have been asked to fetch some data from a backend service. The data would be served in the form of JSON through an HTTP connection. </p>
			<p>It wasn't uncommon to see a class such as <code>BaseRequest.java</code>, which would execute the request and depend on abstraction in the form of <code>JsonMapper.java</code>, to convert the data from a <code>String</code> into a <strong class="bold">Plain Old Java Object</strong> (<strong class="bold">POJO</strong>). The following code represents<a id="_idIndexMarker005"/> an example of how fetching the data might be impleme<a id="_idTextAnchor018"/>nted:</p>
			<pre>public class BaseRequest&lt;O&gt; {
    private final JsonMapper&lt;O&gt; mapper;
    protected BaseRequest(JsonMapper&lt;O&gt; mapper) {
        this.mapper = mapper;
    }
    public O execute() {
        try {
            URL url = new URL("schema://host.com/path");
            HttpURLConnection urlConnection = 
                (HttpURLConnection) url.openConnection();
            int code = urlConnection.getResponseCode();
            StringBuilder sb = new StringBuilder();
            BufferedReader rd = new BufferedReader(new 
            InputStreamReader(urlConnection.
                getInputStream()));
            String line;
            while ((line = rd.readLine()) != null) {
               sb.append(line);
            }
            return mapper.convert(new JSONObject
                (sb.toString()));
        } catch (Exception e) {
            …
        } finally {
            if (urlConnection != null) {
                urlConnection.disconnect();
            }
        }
        return null;
    }
}</pre>
			<p>In the <code>execute</code> method, we would use <code>HttpURLConnection</code> to connect to the backend service<a id="_idIndexMarker006"/> and retrieve the data. Then, we would read it into a <code>String</code>, which would then be converted into a <code>JSONObject</code> and then passed to <code>JsonMapper</code> to be converted into a POJO.</p>
			<p>The <code>JsonMapper.java</code> interface would look something like this:</p>
			<pre>interface JsonMapper&lt;T&gt; {
    T convert(JSONObject jsonObject) throws JSONException;
}</pre>
			<p>This interface represents the abstraction of converting a <code>JSONObject</code> into any POJO. </p>
			<p>The use of generics allows us to apply this logic to any POJO. In our case, the POJO should look something like <code>ConcreteData.java</code>:</p>
			<pre>public class ConcreteData {
    private final String field1;
    private final String field2;
    public ConcreteData(String field1, String field2) {
        this.field1 = field1;
        this.field2 = field2;
    }
    public String getField1() {
        return field1;
    }
    public String getField2() {
        return field2;
    }
}</pre>
			<p>The <code>ConcreteData</code> class will be responsible<a id="_idIndexMarker007"/> for holding the data we will receive from the backend service. In this case, we just have two <code>String</code> instance variables. </p>
			<p>Now, we need to create a concrete <code>JsonMapper.java</code> that will be responsible for converting a <code>JSONObject</code> into <code>ConcreteData</code>:</p>
			<pre>public class ConcreteMapper implements JsonMapper&lt;ConcreteData&gt; {
    @Override
    public ConcreteData convert(JSONObject jsonObject) {
        return new ConcreteData(jsonObject.optString
            ("field1"), jsonObject.optString("field2"));
    }
} </pre>
			<p>The <code>convert</code> method creates a new <code>ConcreteData</code> object, extracts the data from the <code>JSONObject</code> object, and populates<a id="_idIndexMarker008"/> the <code>field1</code> and <code>field2</code> values.</p>
			<p>Next, we must create a <code>ConcreteRequest.java</code> that will extend <code>BaseRequest</code> and use <code>ConcreteMapper</code>:</p>
			<pre>public class ConcreteRequest extends BaseRequest&lt;ConcreteData&gt; {
    public ConcreteRequest() {
        super(new ConcreteMapper());
    }
}</pre>
			<p>This class will inherit the <code>execute</code> method from <code>BaseRequest</code> and supply a new <code>ConcreteMapper</code> object so that we can convert the backend data into <code>ConcreteData</code>.</p>
			<p>Finally, we can use this in our <code>Activity</code> to execute<a id="_idIndexMarker009"/> the request and update our <code>AsyncTask</code> class, which offers a set of methods for doing work on a separate thread and then processing the results on the main thread. However, we risk creating a context leak (if, for any reason, the <code>Activity</code> object is destroyed, then the garbage collector will not be able to collect the <code>Activity</code> object while <code>AsyncTask</code> is running since <code>Activity</code> has a dependency on <code>AsyncTask</code>) by using an inner <code>AsyncTask</code> class. To circumvent this, the recommended approach is to create a <code>WeakReference</code> for our <code>Activity</code>. This way, if the <code>Activity</code> object is destroyed either by the user or the system, its reference can be collected by the garbage collector. </p>
			<p>Now, let's look at the code for our <code>MainActivity</code>:</p>
			<pre>public class MainActivity extends Activity {
    private TextView textView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.textView = findViewById(R.id.text_view);
        new LoadConcreteDataTask(this).execute();
    }
    private void update(ConcreteData concreteData) {
        textView.setText(concreteData.getField1());
    }    
}</pre>
			<p>This class is responsible for loading<a id="_idIndexMarker010"/> the UI and starting <code>LoadConcreteDataTask</code>. The <code>update</code> method will then be called by <code>LoadConcreteDataTask</code> to show the data in the user interface.</p>
			<p><code>LoadConcreteDataTask</code> must be an inner class of <code>MainActivity</code>:</p>
			<pre>public class MainActivity extends Activity {
    …
    private static class LoadConcreteDataTask extends 
        AsyncTask&lt;Void, Void, ConcreteData&gt; {
        private final WeakReference&lt;MainActivity&gt; 
            mainActivityWeakReference;
        private LoadConcreteDataTask(MainActivity 
           mainActivity) {
            this.mainActivityWeakReference = new 
                WeakReference&lt;&gt;(mainActivity);
        }
        @Override
        protected ConcreteData doInBackground(Void... 
            voids) {
            return new ConcreteRequest().execute();
        }
        @Override
        protected void onPostExecute(ConcreteData 
            concreteData) {
            super.onPostExecute(concreteData);
            MainActivity mainActivity = 
                mainActivityWeakReference.get();
            if (mainActivity != null) {
                mainActivity.update(concreteData);
            }
        }
    }
}</pre>
			<p>In <code>LoadConcreteDataTask</code>, we take advantage of the <code>doInBackground</code> method, which is executed on a separate<a id="_idIndexMarker011"/> thread to load our data and then update our UI in the <code>onPostExecute</code> method. We also hold a <code>WeakReference</code> to <code>MainActivity</code> so that it can be safely garbage collected when destroyed. This also means that we will need to check if the reference still exists before updating the user interface.</p>
			<p>The class diagram for the preceding code looks as follows:</p>
			<div><div><img src="img/Figure_1.01_B18320.jpg" alt="Figure 1.1 – A class diagram for an older Android app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – A class diagram for an older Android app</p>
			<p>Here, we can see how the dependencies move from <code>MainActivity</code> toward the <code>ConcreteRequest</code> class, with one exception between <code>MainActivity</code> and <code>LoadConcreteDataTask</code>, where both classes depend on each other. This is a problem because the classes are then coupled together and making a change to one implies making a change to the other. Later in this chapter, we will look at some principles that can help us avoid such dependencies.</p>
			<p>Now that we have an idea of what a legacy application looks like, let's see what issues we may encounter if we follow t<a id="_idTextAnchor019"/>his path. </p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>Legacy analysis</h2>
			<p>In this section, we will analyze some of the problems<a id="_idIndexMarker012"/> that legacy applications have.</p>
			<p>Let's ask ourselves the following questions:</p>
			<ol>
				<li>What can we unit test?</li>
				<li>What happens if, instead of showing the value of <code>field1</code> from <code>ConcreteData</code>, we need to show <code>field1+field2</code>?</li>
				<li>What happens when the requirements<a id="_idIndexMarker013"/> for this particular screen change and data needs to be retrieved from another endpoint on top of this one?</li>
				<li>What happens if we need to introduce caching or SQLite persistence?</li>
				<li>What happens if another activity needs this particular use case?</li>
			</ol>
			<p>Let's answer these questions:</p>
			<ul>
				<li><code>androidTest</code> and <code>test</code> directories. Theoretically, we can write our unit tests so that they can run on the emulator, but that takes more time and instability. We can now execute these types of tests in the cloud using technologies such as Firebase Test Lab, but that would inevitably cost us money and it's in our interest to avoid taking in such costs. Realistically, we are left with one option and that is to test as much as possible using local unit tests instead of instrumented ones. To solve this, we will need to separate the Android components we use from the Java components. </li>
				<li><code>MainActivity</code> or add a method into the <code>ConcreteData</code> class that will return the concatenated result. But either of these will come with downsides. If we move the concatenation into <code>MainActivity</code>, we will put logic that can be unit tested into a class that is very hard and shouldn't be unit tested. If we create a method to concatenate in <code>ConcreteData</code>, we risk giving responsibility to this class that it shouldn't have since it's related more to the UI than the actual representation of the JSON itself. What if, in the future, the networking aspect is developed by another team? You would need to rely on that particular team to create this update. </li>
				<li><code>AsyncTask</code> or execute both requests in the same <code>LoadConcreteData</code> class and then update the UI. If we create a separate <code>AsyncTask</code>, then we will need to make the activity responsible for managing the results and balance the two <code>AsyncTasks</code>, which again creates a problem concerning testing. If we execute the requests in the same <code>AsyncTask</code>, then the responsibility of <code>AsyncTask</code> increases, which we may want to avoid.</li>
				<li><code>LoadConcreteDataTask</code>. Here, we run into the same issues that we did in the previous questions. If we used the request classes, we would end up being more responsible for dealing with HTTP connections than handling calls to the database. If we use <code>LoadConcreteDataTask</code>, we make the answer to the fifth question even harder.</li>
				<li><code>LoadConcreteDataTask</code> class. Now, let's imagine that another activity with a completely different UI and a different interpretation of that data will rely on the same use case. One solution is to duplicate <code>LoadConcreteDataTask</code> into the new activity. This is not a great idea because a change in the requirements will make the developers change all the tasks. A better approach would be to create a new abstraction that will remove the dependency between <code>LoadConcreteDataTask</code> and <code>Activity</code>. This would allow us to reuse the same class for both activities. Let's say that the activities would need different types of data for each interpretation. Here, we could follow the <code>JsonMapper</code> example and create an interface that would convert <code>ConcreteData</code> into a generic type, provide two implementations for each activity, and create the necessary POJOs to convert into. </li>
			</ul>
			<p>Another question that can be asked here is, "What amount of work would be necessary to export the business logic into another project?" This is an important question because it highlights how we should structure our code so that it can be reused by others without making it a pain for them to integrate. If we were to answer this, we must first ask, "Where's the business logic?" The answer would probably be <code>LoadConcreteDataTask</code>. Can we export that and publish it somewhere where other developers can get it? </p>
			<p>The answer is no, because of its dependency on <code>MainActivity</code>. This question highlights an important aspect<a id="_idIndexMarker016"/> of defining an architecture, namely drawing the boundaries around your components. A component can be defined as the smallest piece of deliverable code. In our case, it would be the equivalent of a module. Now, let's say we were in a place where we could ship out our <code>LoadConcreteDataTask</code>. A follow-up question would be, "Would the data be hosted on the same service?" followed by, "Is it in the same JSON format?" Here, we would need to draw a boundary between <code>LoadConcreteDataTask</code> and <code>BaseRequest</code> and remove such dependencies on how the data is retrieved.</p>
			<p>The reason these questions were raised and answered is that all those scenarios have happened in the past and they will all likely happen in the life cycle of an application. We, as developers, tend to answer those questions in our code differently based either on time constraints, the rigor imposed on the team we work in, our ambition to deliver something fast by constantly challenging ourselves, and our experience or the team's experience. The fact that we had the option to make a less desirable solution or to be stuck in a situation where we had to pick between the frying pan or the fire represents a problem. Sometimes, it is good to take a step back from our daily routine, ask ourselves some of these questions, do mind experiments to see how our code may end up in those scenarios, and assess what would happen if that would happen now or 1 or 2 years from now. </p>
			<p>A common scenario a lot of Android developers found themselves in was having a lack of businesses investing in testing because it would take too much time and there was a need to go to market. In many of these cases, the apps became harder to maintain over time, so more developers needed to be hired to keep the same productivity as a team compared to when they had fewer developers. When code is written with the notion that it needs to be unit tested, then the way we write that code becomes more rigorous and more maintainable. We start keeping track of how we create instances and separate the things we can test from the things we can't, we apply creational design patterns, and we also shorten the sizes of the methods in our classes, among other things.</p>
			<p>We now have an idea of how applications<a id="_idIndexMarker017"/> used to be written in the past and the problems that were caused by the approaches that were taken, such as issues with the testability and maintainability of an application due to dependencies on the Android framework. Next, we will look at some design principles that will prove useful in how we write an application.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor021"/>Software design principles</h1>
			<p>In this section, we will analyze a set of design principles that are adopted by developers worldwide to improve their systems and can also be applied to Android development. We will mainly focus on the principles defined by <em class="italic">Robert C Martin</em> (also known as Uncle Bob) for classes and components because they are well suited to Android development.</p>
			<p>Based on the examples in the previous section, we understand that our code bases should be maintainable, understandable, and flexible. There is a set of software design principles<a id="_idIndexMarker018"/> that we can turn to for help when we develop classes or components. Think of a component as the minimum amount of code that can be released as part of a system. In Android, you can view them as individual modules. They don't necessarily need to be modules, but they can be organized as if they are.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>SOLID principles</h2>
			<p>These are some<a id="_idIndexMarker019"/> of the most known design principles. The name is an acronym<a id="_idIndexMarker020"/> for a set of design principles that were collected by <em class="italic">Robert C Martin</em>. These principles are as follows:</p>
			<ul>
				<li>Single responsibility principle</li>
				<li>Open-closed principle</li>
				<li>Liskov substitution principle</li>
				<li>Interface segregation principle</li>
				<li>Dependency inversion principle</li>
			</ul>
			<p>Let's look at these<a id="_idIndexMarker021"/> principles in detail:</p>
			<ul>
				<li><code>BaseRequest</code> class to change how the HTTP request is executed. Let's assume that we now have two different AsyncTasks that will load the data. Both of these will be impacted by the change in the <code>BaseRequest</code> class. A solution would be to delegate the execution of the request to different classes for each particular use case. This would also allow developers to work on different features related to backend communication without changing the same source file.</li>
				<li><strong class="bold">Open-Closed Principle</strong>: This states that a class should be open for extension and closed<a id="_idIndexMarker024"/> for modification. Thinking back<a id="_idIndexMarker025"/> to our example, this principle would answer the question, "What would happen if an activity requires this particular use case?" The abstractions we discussed in how to answer that question would serve as a good example of implementing this principle.</li>
				<li><code>Bird</code> and a sub-class called <code>Duck</code>. If you are using references of <code>Bird</code> in your code and substitute those usages with <code>Duck</code>, then your code should remain unchanged. A famous example of a violation of this principle is having a <code>Rectangle</code> class with two members named <code>width</code> and <code>height</code> and a sub-class named <code>Square</code>. In reality, a square is a rectangle, but our modeling of a square wouldn't be a rectangle because the rules in <code>Square</code> would mean that the width and height will always have to be the same. If you were to swap these two dependencies, then your code would break.</li>
				<li><code>OnClickListener</code>, <code>OnLongClickListener</code>, and <code>OnTouchListener</code>.</li>
				<li><strong class="bold">Dependency Inversion Principle</strong>: This states that we should depend on abstractions<a id="_idIndexMarker030"/> rather than concretions. The idea here is to depend <a id="_idIndexMarker031"/>as much as possible on abstract classes and interfaces. This can be very difficult to achieve considering that we rely on concretions a lot of the time. Here, we should identify parts of the code that are constantly developed and subject to change and introduce layers of abstractions between our code and these classes. A good way to protect against this is through dependency injection frameworks such as Dagger and Hilt, which generate factories to create volatile components. </li>
			</ul>
			<p>SOLID principles<a id="_idIndexMarker032"/> are used across the <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) field to create applications <a id="_idIndexMarker033"/>that are flexible and able to incorporate new features and requirements. The principles that follow represent an expansion of SOLID. </p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Component cohesion principles</h2>
			<p>We can define cohesion<a id="_idIndexMarker034"/> by how well the classes in a component<a id="_idIndexMarker035"/> belong together or what classes belong in a certain component. In the past, components were assembled based on the context without any particular guiding principle. This would cause issues such as a change in the dependencies of a component triggering a change in the dependants of this component, without this having any relevance to the dependants. </p>
			<p>The three principles are as follows:</p>
			<ul>
				<li><strong class="bold">Reuse/Release Equivalence Principle</strong> (<strong class="bold">REP</strong>): This states that we group classes in a component<a id="_idIndexMarker036"/> that can be released together. In Android<a id="_idIndexMarker037"/> development, this would translate to making sure that every module you create should be able to be published and used by other developers. </li>
				<li><strong class="bold">Common Closure Principle</strong> (<strong class="bold">CCP</strong>): This states that components<a id="_idIndexMarker038"/> should have<a id="_idIndexMarker039"/> one reason to change. This principle is an application of the single responsibility principle for components.</li>
				<li><strong class="bold">Common Reuse Principle</strong> (<strong class="bold">CRP</strong>): This states that a component should only have classes<a id="_idIndexMarker040"/> that should be used together. This represents<a id="_idIndexMarker041"/> the interface segregation principle for your component. In Android, this would mean that you should make sure that the users of your Android modules depend on all your classes in the module, not just some.</li>
			</ul>
			<p>When these principles<a id="_idIndexMarker042"/> are incorporated, they end up conflicting with each other. REP and CCP tend to make components bigger, while CRP tends to make them smaller. The idea is to always match the current requirements of the application and find the middle ground between these principles. After that, you should constantly monitor how new requirements would affect this middle ground.</p>
			<p>Now that we've seen how SOLID can be applied to building a particular component through the component cohesion principles, let's learn how to manage a set of components.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>Component coupling principles</h2>
			<p>These principles<a id="_idIndexMarker043"/> deal with how to manage the relationships<a id="_idIndexMarker044"/> between our components in an Android application. In Android, this would be represented by how to manage the Gradle dependencies between different modules. The principles are as follows:</p>
			<ul>
				<li><strong class="bold">Acyclic Dependencies Principle</strong>: This states that we should avoid cyclic dependencies<a id="_idIndexMarker045"/> between components. Applying this to Android<a id="_idIndexMarker046"/> would mean that the dependencies that our modules have most not be cyclical (for example, module A depends on module B, which depends on module A). Fortunately, this rule is currently enforced by the build system, which doesn't allow cyclical dependencies. A solution to this would be to create a new module in which we apply the dependency inversion principle and make one of the modules depend on the abstraction and create the implementation in the second module. If this is not possible, we can create a new module that can depend on both existing modules. An example of this can be seen in the following diagram:</li>
			</ul>
			<div><div><img src="img/Figure_1.02_B18320.jpg" alt="Figure 1.2 – Cyclic module dependency&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Cyclic module dependency</p>
			<ul>
				<li><strong class="bold">Stable Dependencies Principle</strong>: This states that less stable<a id="_idIndexMarker047"/> modules should depend on more stable modules. A component's stability<a id="_idIndexMarker048"/> is defined as the ratio between outgoing<a id="_idIndexMarker049"/> dependencies (dependency on other components) and the total number of dependencies. The closer the number is to 0, the more stable a component becomes. This means that stable components should avoid having changes made because this will cause potential issues for the components that depend on the stable ones. One solution to avoid the dependencies between stable components and volatile components would be using abstract components. These are components that will contain nothing but abstractions.</li>
				<li><strong class="bold">Stable Abstractions Principle</strong>: This states that components that are likely to change should be more concrete<a id="_idIndexMarker050"/> and that stable components should be more abstract. This principle represents<a id="_idIndexMarker051"/> an application of the open-closed principle. We would want our high-level architecture decisions to be flexible enough to be changed without having to modify existing source code. We can achieve this using abstract classes. The abstractness of a component is defined as the ratio between the number of abstract classes and interfaces inside a component and the total number of classes in the component. The closer to 1 the value gets, the more abstract the component becomes. A component with 0 stability<a id="_idIndexMarker052"/> and 0 abstractness represents a <strong class="bold">zone of pain</strong> because it is very hard to change. A component with 1 stability and 1 abstractness is called a <strong class="bold">zone of uselessness</strong> because we have an independent<a id="_idIndexMarker053"/> component with no implementations. The aim is to get as many components as possible in either the 0 stability and 1 abstractness or 1 stability and 0 abstractness range.</li>
			</ul>
			<p>With that, we have looked at some of the key design principles that should help us tackle problems that we face while developing an application. The SOLID principles show us how we should structure our code into classes, while the component cohesion principles and component coupling principles show us how we should structure our classes into separate<a id="_idIndexMarker054"/> modules, as well as how we should establish the relationships between those modules. In the next section, we will see how these principles lead to the evolution of the Android platform and what an application may look like now.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor025"/>Exploring the evolution of Android</h1>
			<p>In this section, we will look at key releases and changes that have been made to the Android framework and supporting<a id="_idIndexMarker055"/> libraries that have shaped the development of applications and how applications have evolved because of these changes. </p>
			<p>We started by looking at an example of what the code in an older Android application looked like before looking at the design principles we should incorporate into our work. Now, let's see how the Android framework evolved and how some of our questions from the beginning have been answered. We will analyze some of the newer libraries, frameworks, and technologies that we can incorporate into an Android application.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>Fragments</h2>
			<p>The introduction of fragments<a id="_idIndexMarker056"/> was meant to solve important issues developers<a id="_idIndexMarker057"/> were facing – that is, the activity code would become too big and hard to manage. They were released on Android Honeycomb, which was an Android release that only targeted tablets. The introduction of fragments was also meant to solve the issue of having different displays for activities in landscape versus activities in portrait. Fragments are meant to control portions of an activity's user interface. </p>
			<p>Another improvement fragments brought was the ability to change and replace fragments at runtime. There was even a separate back stack for Fragments that the activity would be responsible for. This comes at a couple of costs: the life cycle of the fragment was even more complex than the life cycle of the activity, where you would have fragments that had their views destroyed but the fragments themselves weren't. Another cost was the communication between two fragments. If you needed to update the user interface being handled by Fragment1 because of a change in Fragment2, you would need to communicate through the activity. This meant that every time a Fragment needed to be reused<a id="_idIndexMarker058"/> by a different activity, then the activity would be forced<a id="_idIndexMarker059"/> to adapt to this:</p>
			<div><div><img src="img/Figure_1.03_B18320.jpg" alt="Figure 1.3 – Activity and fragment life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Activity and fragment life cycle</p>
			<p>In the preceding figure, we can see the difference between the lifecycle of activities and the lifecycle of fragments. We can observe how fragments have their own internal lifecycle for managing the views that they display between the <code>onCreateView</code> method and <code>onDestroyView</code> methods. This is often the reason why in many applications, you will see these methods used to load data and on the opposite site unsubscribing<a id="_idIndexMarker060"/> from any operations that might trigger<a id="_idIndexMarker061"/> a change in the user interface.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>The Gradle build system</h2>
			<p>Initially, Android development<a id="_idIndexMarker062"/> used the Eclipse IDE and Ant as its build system. This came with certain limitations for applications. Things such as flavors were not available at the time. The release of Android Studio, along with the Gradle build system, provided new opportunities and features. This allows us to write extra scripts and easily integrate plugins and tools, such as performance monitoring of an application, Google Play services, Firebase Crashlytics, and more. This is often done through <code>".gradle"</code> files. These files are written in a language called Groovy. Another improvement that<a id="_idIndexMarker063"/> was added was the usage of the <code>".gradle.kts"</code> extensions, where we can provide the same configurations using the Kotlin language. The following code shows what the <code>build.gradle</code> file for a module looks like:</p>
			<pre>plugins {
    id 'com.android.application'
}
android {
    compileSdk 31
    defaultConfig {
        minSdk 21
        targetSdk 31
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
        }
    }
    compileOptions {
    }
}
dependencies {
    implementation ""
}</pre>
			<p>In the <code>plugins</code> section, we can define<a id="_idIndexMarker064"/> external plugins that will provide certain methods and scripts that our project can use. Examples include annotation processing plugins, the <code>Parcelize</code> plugin, and Room plugins. In this case, the <code>com.android.application</code> plugin offers us the <code>android</code> configuration, which we can then use to specify the app version, what Android versions we want the app to be accessible from, various compilation options, and configurations for how the app should be built for the end user. In the <code>dependencies</code> section, we specify which external libraries we want to add to the project.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>Networking</h2>
			<p>Quite a few popular networking libraries<a id="_idIndexMarker065"/> have emerged, mainly in the open sourcing<a id="_idIndexMarker066"/> community. A large proportion of the applications in Google Play rely on HTTP communication and a large proportion of them use JSON data. With the addition of networking libraries, JSON serialization/deserialization to POJOs also became adopted. What this means for developers is that the communication with the backend is simplified – we no longer need to concern ourselves with how the actual communication is done; we only point to where we want the data from and provide the models that are required for this communication. The libraries will take care of the rest. Some of the most popular libraries include Volley and Retrofit. In terms of object serialization, we have libraries such as Moshi and GSON.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>Humble objects</h2>
			<p>Because activities and fragments<a id="_idIndexMarker067"/> are difficult to unit test, the code inside<a id="_idIndexMarker068"/> them needed to be split into testable sections and untestable sections. Because of this necessity, two patterns emerged: <strong class="bold">Model View Presenter</strong> (<strong class="bold">MVP</strong>) and <strong class="bold">Model View ViewModel</strong> (<strong class="bold">MVVM</strong>). Sometimes, these patterns<a id="_idIndexMarker069"/> are referred to as architecture patterns. This shouldn't be confused<a id="_idIndexMarker070"/> with the entire architecture<a id="_idIndexMarker071"/> of the app. The idea is to turn activities and fragments into humble objects with no logic, keep the references to the user interface objects, and shift the logic into the presenter and ViewModel, which we can write unit tests for. We will focus more on the particularities of each in <a href="B18320_08_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 8</em></a><em class="italic">,</em><em class="italic"> Implementing an MVVM Architecture</em>.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor030"/>Functional paradigms</h2>
			<p>Just like objected-oriented languages have adopted paradigms from functional programming, so has the Android development<a id="_idIndexMarker072"/> world in the form of RxJava. Functional programming<a id="_idIndexMarker073"/> works on the premise that programs are built from composing functions rather than imperative statements such as the ones in Java. RxJava is a library that allows developers to implement event-driven applications. It offers observables (for emitting data) and subscribers (for subscribing to that data). What made this library appealing to developers was how it deals with threading. Let's assume you wanted an operation to be executed on a separate thread, and then you wanted to transform your data – all you need to do here is invoke the data you want, apply mapping functions, and then subscribe to get the final result. The added benefit is that you can chain different operations, have them processed, and get the result with all of the operations. All of this removes the need for creating and managing different AsyncTasks or threads. </p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Kotlin adoption</h2>
			<p>RxJava introduced some<a id="_idIndexMarker074"/> aspects of functional programming. Its adoption<a id="_idIndexMarker075"/> and transition into Kotlin programming has added others. One of the most important is the concept of mutability. In Java, all variables are mutable unless they're declared otherwise through the <code>final</code> keyword. In Kotlin, all the variables must have their mutability declared. Why is this important? Because of multi-threading. If you had an application where multiple threads were executed at the same time and they all interacted with the same object, you would end up in a situation where you would either modify the same value at the same time or create deadlocks in which a thread would wait for another thread to release a resource, but the second thread would need access to a resource that the first thread is currently holding. This introduction helps developers aim for a greater degree of immutability, which would increase thread safety because immutable variables are thread-safe. Lambdas represent another great feature of Kotlin that allows boilerplate code to be reduced when you're dealing with callbacks. Other benefits of the adoption of Kotlin<a id="_idIndexMarker076"/> include that you can remove boilerplate code by introducing<a id="_idIndexMarker077"/> data classes, which represent POJOs, and introducing sealed classes, which allow developers to define enum-like structures that can carry data.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>Dependency injection</h2>
			<p>Dependency injection represents the decoupling<a id="_idIndexMarker078"/> of object invocation and object creation. Why is this important? Mainly<a id="_idIndexMarker079"/> because of testing. It's easier to write unit tests for classes that have their dependencies injected rather than adding extra responsibilities, such as creating new instances for all of the dependencies in that class. Another benefit is in situations where we depend on abstractions. If we have a dependency on an abstraction, we can easily switch between different implementations, depending on different circumstances. Several libraries have emerged to tackle this issue: Dagger, Koin, and Hilt. Dagger is more of a general library that is not only Android applicable, but also applicable for other Java-based platforms. It aims to manage our dependencies using components and modules. Components are responsible for how the dependencies are managed, while modules are responsible for providing the appropriate dependencies. It relies on annotation processors, which generate the necessary code that will be responsible for managing our dependencies. Koin is what's referred to as a service locator library. It keeps a collection<a id="_idIndexMarker080"/> of all the dependencies and when a particular dependency is required, it will look it up and provide it. Koin is an Android-specific library, and it provides support for injecting specific Android dependencies. Hilt is the newest of these libraries and it is built on top of Dagger. It removes the boilerplate code that was required for Dagger and provides support for Android dependencies as well.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor033"/>Android architecture components</h2>
			<p>This is represented<a id="_idIndexMarker081"/> by a set of libraries that help developers make their apps scalable, testable, and maintainable. These libraries affect components that deal with activity and fragment life cycles, persisting data, background work, and UIs. Here, we have seen the introduction of concepts such as life cycle owners (such as activities and fragments), the Android ViewModel, and LiveData. These are meant to solve problems developers had with managing the state of a life cycle owner when it's destroyed and recreated by the system. It puts the logic that, in the past, was handled by the life cycle owners and delegated to the Android ViewModel. The combination of the Android ViewModel and LiveData has helped developers implement the MVVM pattern, which is also life cycle aware. This means that developers no longer have to concern themselves with stopping a background task when the life cycle owner is destroyed. </p>
			<p>The introduction of Room<a id="_idIndexMarker082"/> means that developers no longer have to deal with interacting with the SQLite framework, which caused a lot of boilerplate code to be written to define tables and various queries. Developers no longer need to deal with the SQLite interaction and the many dependencies that come with it; instead, they can focus on creating their own models and providing the abstractions for what needs to be queried, deleted, updated, and deleted; Room will take care of the actual implementations. DataStore does for SharedPreferences what Room does for SQLite. This is for when we want to store data in key-value pairs instead of using an entire table. DataStore provides two options for storing data: safely typed data and no type safety data.</p>
			<p>With the addition of these new persistence libraries, the Repository pattern was adopted. The idea behind this pattern is to create a class that will interact with all the data sources we have in our application. As an example, let's imagine we have some data we will need to fetch from our backend that will then need to be stored locally in case we want the user to view it offline. Our repository would be responsible for fetching the data from the network class and then storing it using the persistence class. The repository would sit in between the local and remote classes and the classes that would want access to that data.</p>
			<p>Regarding the UI, we now have access to view binding and data binding. Both of these deal with how activities and fragments deal with the views that are declared in our XML layout files. View binding generates references for each view we defined in our XML. This solves an issue that developers would have in the past where a view would be deleted from your XML file, but your application would still run because of another view with the same name in another file. This would cause crashes in the past because the <code>findViewById</code> function would return <code>null</code>. With view binding, we know at compile time what views we have in our hierarchy and what views we don't. Data binding allows us to bind our views to data sources. For example, we can bind a <code>TextView</code> in our XML file directly to a field<a id="_idIndexMarker083"/> in our source code. This approach tends to work well with the MVVM pattern, in which the ViewModel updates certain fields that are bound by views in our XML. This would update what the view would display without it interacting with the activity. </p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor034"/>Coroutines and flows</h2>
			<p>Coroutines<a id="_idIndexMarker084"/> came as a feature of the Kotlin language. The idea behind coroutines<a id="_idIndexMarker085"/> is to execute data asynchronously<a id="_idIndexMarker086"/> in a very simplified manner. We no longer have to create threads or AsyncTasks (which have been deprecated) and manage concurrency because it's managed under the hood. Other features include that it's not bound to a particular thread, and it can be suspended and resumed. Flows<a id="_idIndexMarker087"/> represent an extension of coroutines where we can have multiple emissions of data, such as RxJava, providing similar benefits.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Jetpack Compose</h2>
			<p>This allows developers<a id="_idIndexMarker088"/> to build UIs directly in Kotlin without the use of XML files<a id="_idIndexMarker089"/> through composable functions. This removes the amount of code that needs to be written for building your UI. Compatibility with the other Android architecture component libraries is provided, allowing for easier integration into your application. The following is an example of what Compose looks like:</p>
			<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ExampleTheme {
                Surface {
                    ExampleScreen()
                }
            }
        }
    }
}
@Composable
fun ExampleScreen() {
    Column(modifier = Modifier.padding(16.dp)) {
        TextField(
            value = "",
            onValueChange = {
                // Handle text change
            },
            label = { Text("Input") }
        )
        Text(text = "Example text")
        Button(onClick = {
            // Handle button click
        }) {
            Text(text = "Button")
        }
    }
}</pre>
			<p>In this example, we can see a screen<a id="_idIndexMarker090"/> that contains an input field, some text that displays <code>Example Text</code>, and a button<a id="_idIndexMarker091"/> with the text <code>Button</code>. The layout of the screen is defined as a function annotated with the <code>@Compose</code> annotation. This content is then set in an activity through the <code>setContent</code> method, where a theme is provided. We will expand on how Jetpack Compose works later in this book.</p>
			<p>Now, let's look at what our example code from the <em class="italic">The architecture of a legacy app</em> section will look like after we transition it through some of the aforementioned Android frameworks and updates. All our code<a id="_idIndexMarker092"/> will now be migrated to Kotlin. We will be using libraries<a id="_idIndexMarker093"/> such as Retrofit and Moshi for networking and JSON serialization and Hilt for dependency injection, as well as ViewModel, LiveData, and Compose for the UI layer. We will discuss how these libraries work in the following chapters.</p>
			<p>The <code>ConcreteData</code> class will look this:</p>
			<pre>@JsonClass(generateAdapter = true)
data class ConcreteData(
    @Json(name = "field1") val field1: String,
    @Json(name = "field1") val field2: String
)</pre>
			<p>The <code>ConcreteData</code> class is now a Kotlin data class and will use the Moshi library for JSON conversion. Next, let's see what our HTTP request will look like when we use something such as Retrofit to handle our HTTP communication:</p>
			<pre>interface ConcreteDataService {
 
    @GET("/path")
    suspend fun getConcreteData(): ConcreteData
}</pre>
			<p>Because we use Retrofit and OkHttp, we only need to define the template for the endpoint we want to connect to and the data we want; the libraries will handle the rest. The <code>suspend</code> keyword will come in handy for Kotlin flows. </p>
			<p>Now, let's define a repository class that will be responsible for invoking this HTTP call on a separate thread:</p>
			<pre>class ConcreteDataRepository @Inject constructor(private val concreteDataService: ConcreteDataService) {
 
    fun getConcreteData(): Flow&lt;ConcreteData&gt; {
        return flow {
            val fooList = concreteDataService.
                getConcreteData()
            emit(fooList)
        }.flowOn(Dispatchers.IO)
    }
}</pre>
			<p><code>ConcreteDataRepository</code> will have a dependency on <code>ConcreteDataService</code>, which it will call<a id="_idIndexMarker094"/> to fetch the data. It will be responsible for retrieving<a id="_idIndexMarker095"/> the data on a separate thread by using Kotlin flows. The constructor will be annotated with the <code>@Inject</code> annotation because we are using Hilt, which will inject <code>ConcreteDataService</code> into <code>ConcreteDataRepository</code>.</p>
			<p>Now, let's create a <code>ViewModel</code> that will depend on the repository to load the appropriate data:</p>
			<pre>@HiltViewModel
class MainViewModel @Inject constructor(private val concreteDataRepository: ConcreteDataRepository) :
    ViewModel() {
 
    private val _concreteData = MutableLiveData
        &lt;ConcreteData&gt;()
    val concreteData: LiveData&lt;ConcreteData&gt; get() = 
        _concreteData
 
    fun loadConcreteData() {
        viewModelScope.launch {
            concreteDataRepository.getConcreteData()
                .collect { data -&gt;
                    _concreteData.postValue(data)
                }
        }
    }
}</pre>
			<p><code>MainViewModel</code> will then use <code>ConcreteDataRepository</code> to retrieve<a id="_idIndexMarker096"/> the data, subscribe to the result, and post<a id="_idIndexMarker097"/> the result in <code>LiveData</code>, which <code>MainActivity</code> will subscribe to.</p>
			<p>Now, let's create <code>MainActivity</code>:</p>
			<pre>@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Screen()
        }
    }
}
 
@Composable
fun Screen(mainViewModel: MainViewModel = viewModel()){
    mainViewModel.loadConcreteData()
    UpdateText()
}
 
@Composable
fun UpdateText(mainViewModel: MainViewModel = viewModel()) {
    val concreteData by mainViewModel.concreteData.
        observeAsState(ConcreteData("test", "test"))
    MessageView(text = concreteData.field1)
 
}
 
@Composable
fun MessageView(text: String) {
    Text(text = text)
}</pre>
			<p><code>MainActivity</code> is now written<a id="_idIndexMarker098"/> using Jetpack Compose. It will trigger the data load when the screen is created<a id="_idIndexMarker099"/> and then subscribe to <code>LiveData</code> from <code>ViewModel</code>, which will update the text on the screen when the data is loaded.</p>
			<p>Since we are using Hilt for dependency injection, we will need to define our external dependencies in a module, as follows:</p>
			<pre>@Module
@InstallIn(SingletonComponent::class)
class ApplicationModule {
 
    @Singleton
    @Provides
    fun provideHttpClient(): OkHttpClient {
        return OkHttpClient
            .Builder()
            .readTimeout(15, TimeUnit.SECONDS)
            .connectTimeout(15, TimeUnit.SECONDS)
            .build()
    }
}</pre>
			<p>First, we must provide the <code>OkHttp</code> client, which<a id="_idIndexMarker100"/> is used to make the HTTP requests.</p>
			<p>Next, we will need to provide<a id="_idIndexMarker101"/> the JSON serialization:</p>
			<pre>@Module
@InstallIn(SingletonComponent::class)
class ApplicationModule {
    … 
    @Singleton
    @Provides
    fun provideConverterFactory(): MoshiConverterFactory = MoshiConverterFactory.create()
}</pre>
			<p>We are using the Moshi library for JSON serialization, so we will have to provide a Factory that will be used by Retrofit for JSON conversion.</p>
			<p>Next, we need to provide a Retrofit object:</p>
			<pre>@Module
@InstallIn(SingletonComponent::class)
class ApplicationModule {
    …
    @Singleton
    @Provides
    fun provideRetrofit(
        okHttpClient: OkHttpClient,
        gsonConverterFactory: MoshiConverterFactory
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("schema://host.com")
            .client(okHttpClient)
            .addConverterFactory(gsonConverterFactory)
            .build()
    }
}</pre>
			<p>The Retrofit object will need <a id="_idIndexMarker102"/>a base URL that will act as the host for our backend<a id="_idIndexMarker103"/> service, <code>OkHttpClient</code>, and the JSON converter factory, which were provided earlier.</p>
			<p>Finally, we will need to provide the template we defined previously:</p>
			<pre>@Module
@InstallIn(SingletonComponent::class)
class ApplicationModule {
 
    @Singleton
    @Provides
    fun provideConcreteDataService(retrofit: Retrofit): 
        ConcreteDataService =
           retrofit.create(ConcreteDataService::class.java)
}</pre>
			<p>Here, we will use Retrofit<a id="_idIndexMarker104"/> to create an instance of <code>ConcreteDataService</code> that will be injected<a id="_idIndexMarker105"/> into <code>ConcreteDataRepository</code> by Hilt.</p>
			<p>Finally, we need to initialize Hilt in the <code>Application</code> class:</p>
			<pre>@HiltAndroidApp
class MyApplication : Application()</pre>
			<p>This code represents a 10-year jump in time when it comes to Android development. Going back to the questions we asked for the initial example in the Legacy analysis section, we can see that we answered quite a few. If we want to introduce persistence into the application, we now have a repository that can manage that for us. We also have a lot of classes that can be individually unit tested because of the introduction of Hilt and because we have delimited separated from the Android framework dependencies. We have also introduced flows, which allow us to manipulate and handle the data in case we need to connect to multiple sources and handle multi-threading more easily. The introduction of Kotlin and Retrofit also allowed us to reduce the amount of code. If we were to make a diagram of this, it would look as follows:</p>
			<div><div><img src="img/Figure_1.04_B18320.jpg" alt="Figure 1.4 – A class diagram for a newer Android application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – A class diagram for a newer Android application</p>
			<p>Here, we can see that the dependencies between the classes go from one direction to the other, which is another positive. The introduction of Retrofit saved us a lot of hassle when dealing with HTTP requests. But an issue remains with regards to how <code>ConcreteData</code> is handled. We can see that it travels from <code>ConcreteDataService</code> into <code>MainActivity</code>. Imagine if we wanted to provide the data from a different URL with a different POJO representation. This means that all of the classes will have to be changed to accommodate for this. This violates the single responsibility principle because the <code>ConcreteData</code> class is used to serve multiple actors in our application. In the next section, we will try to seek a solution to this problem and address ways to properly structure our classes and components.</p>
			<p>With that, we have explored the evolution<a id="_idIndexMarker106"/> of the Android platform and tools, what an application<a id="_idIndexMarker107"/> may look like using the latest tools and libraries, and how this evolution solved many problems developers had in the past. However, we still haven't solved all of them. In the next section, we will talk about the concept of clean architecture and how we can use it to make our application flexible and more adaptable to changes.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor036"/>Enter clean architecture</h1>
			<p>In this section, we will discuss the concept<a id="_idIndexMarker108"/> of clean architecture, the problems it solves, and how it can be applied to an Android application.</p>
			<p>Architecture can be viewed as the high-level solution that's required to build a system that can solve business and technical requirements. The goal should be to keep as many options on the table for as long as we can. From an Android development perspective, we've seen the platform grow a lot, and to balance the new changes that have been added to the platform with the addition of new features for our application and its maintenance, we will need to give our application a very good foundation so that it will adapt to changes. A common approach to architecture in Android development was the layered architecture, where apps would be split into three layers – the user interface, domain, and data layers. The problem here was that the domain layer depended on the data layer, so when the data layer changed, the domain layer needed to change too. </p>
			<p>Clean architecture represents an integration of multiple types of architecture that provide independence from frameworks, user interfaces, and databases, as well as being testable. The shape resembles that of an onion, where dependencies go toward the inner layers. These layers are as follows:</p>
			<ul>
				<li><strong class="bold">Entity Layer</strong>: This layer is the innermost layer<a id="_idIndexMarker109"/> and is represented by objects that hold data or business-critical functions.</li>
				<li><strong class="bold">Use Case Layer</strong>: This layer implements<a id="_idIndexMarker110"/> the business logic of the system.</li>
				<li><strong class="bold">Interface Adapter Layer</strong>: This layer is responsible<a id="_idIndexMarker111"/> for converting the data between the frameworks and drivers and the use case. This will hold components such as ViewModels and presenters, as well as various converters that are responsible for converting network and persistence-related data into entities.</li>
				<li><strong class="bold">Frameworks and Drivers Layer</strong>: This layer is the outermost layer and is comprised of components<a id="_idIndexMarker112"/> such as activities, fragments, networking components, and persistence components.</li>
			</ul>
			<p>Let's consider a scenario: you've recently been hired by a start-up company as their first Android engineer. You have been given<a id="_idIndexMarker113"/> a basic idea of what the app that you've been asked to develop should do, but there isn't anything too concrete; the user interface has not been finalized, the teams working on the backend are new themselves, and there isn't anything too concrete on their side either. What you do know is a set of use cases that specify what the app does: log into a system, load a list of tasks and add new tasks, delete tasks, and edit existing tasks. The product owner tells you that you should work on something while using mock data so that they can get a feel of the product and consult with the user interface and user experience teams to discuss improvements and modifications.</p>
			<p>You are faced with a choice here: you can build the product that's been requested by the product owner as fast as possible and then constantly refactor your code for each new integration and the change in requirements, or you can take a little bit more time and factor in the future changes that will come into your approach. If you were to take the first approach, then you would find yourself in a situation where many developers found themselves, which is to go back and change things properly. Let's assume you chose the second approach. What would you need to do then? You can start decoupling your code into separate layers. You know that the UI will change, so you will need to keep it isolated so that when it is changed, the change will only be isolated to that particular section. Often, the UI<a id="_idIndexMarker114"/> is referred to as the presentation layer. </p>
			<p>Next, you want to decouple the business logic. This is something specific to processing the data that your app will use. This is often done in the domain layer. Finally, you want to decouple how the data<a id="_idIndexMarker115"/> is loaded and stored. This will be the part where you deal with integrating libraries such as Room and Retrofit and it's often called the data layer. Because the requirements<a id="_idIndexMarker116"/> aren't definitive yet, you also want to decouple how you want to handle use cases so that if a use case changes, you can protect the others from that change. If you were to rotate the class diagram from <em class="italic">Figure 1.4</em>, you would see a layered approach to this example.</p>
			<p>As we've mentioned previously, the fact that <code>ConcreteData</code> shows up in all the classes in our example is not a good idea. This is because, at the end of the day, the fact that we chose Retrofit and Moshi shouldn't impact the rest of the application. This is similar if it was the opposite way around and the activity or <code>ViewModel</code> would've done the same. At the end of the day, the way we choose to implement our UI or what networking library we should use represent details. Our domain layer shouldn't be impacted by any of these choices. </p>
			<p>What we are doing here is establishing boundaries between the components in our system so that a change in a component doesn't impact a change in another component. In Android, even if we use the latest libraries and frameworks, we should still make sure that our domain is still protected by changes in those frameworks. Going back to the start-up example, and assuming you've chosen to decouple your components and pick the appropriate boundaries, after many demos and iterations, your company decides to hire additional developers to work on new, separate features. If those developers follow the guidelines you've set up, they can work with a minimal level of overlap. </p>
			<p>The recommendation from Android development documentation is to take advantage of modules. One of the arguments is that it improves build speed because when you work on a certain module, it won't rebuild the others when you build the application – it caches them instead. Splitting your application into multiple modules serves another purpose.</p>
			<p>Let's go back to the start-up. Things are going great and people love your product, so your company decides to open your APIs for other businesses to integrate into their systems. Your company also wants to provide an Android library so that it's easier for businesses to access your APIs. You already have this logic integrated into your application; you just need to export it. What features do you want to export? All? None? Do they want to persist data locally? Do they want some of the UI or not? If your modules were split with proper boundaries, then you would be able to accommodate all of those features. What we want<a id="_idIndexMarker117"/> to do is have a system where we can easily plug things in and easily plug them out.</p>
			<p>Transitioning our previous example to this approach, we would have something like this. The <code>ConcreteData</code> class and <code>ConcreteDataService</code> would remain the same:</p>
			<pre>@JsonClass(generateAdapter = true)
data class ConcreteData(
    @Json(name = "field1") val field1: String,
    @Json(name = "field1") val field2: String
)
interface ConcreteDataService {
 
    @GET("/path")
    suspend fun getConcreteData(): ConcreteData
}</pre>
			<p>Now, we will need to isolate the Retrofit library and create the interface adapter for it. But to do that, we will need to define our entity: </p>
			<pre>data class ConcreteEntity(
    val field1: String,
    val field2: String
)</pre>
			<p>It looks like it's a duplicate of <code>ConcreteData</code>, but this is a case of fake duplication. In reality, as things evolve, the two classes may contain different data, so they will need to be separated.</p>
			<p>To isolate the Retrofit call, we need to invert the dependency of our repository. So, let's create a new interface that will return <code>ConcreteEntity</code>:</p>
			<pre>interface ConcreteDataSource {
 
    suspend fun getConcreteEntity(): ConcreteEntity
}</pre>
			<p>In our implementation, we will invoke<a id="_idIndexMarker118"/> the Retrofit service interface:</p>
			<pre>class ConcreteDataSourceImpl(private val concreteDataService: ConcreteDataService) :
    ConcreteDataSource {
 
    override suspend fun getConcreteEntity(): 
        ConcreteEntity {
        val concreteData = concreteDataService.
            getConcreteData()
        return ConcreteEntity(concreteData.field1, 
            concreteData.field2)
    }
}</pre>
			<p>Here, we have invoked <code>ConcreteDataService</code> and then converted the network model into an entity.</p>
			<p>Now, our repository will change into the following:</p>
			<pre>class ConcreteDataRepository @Inject constructor(private val concreteDataSource: ConcreteDataSource) {
 
    suspend fun getConcreteEntity(): ConcreteEntity {
        return concreteDataSource.getConcreteEntity()
    }</pre>
			<p><code>ConcreteDataRepository</code> will depend on <code>ConcreteDataSource</code> to avoid the dependencies<a id="_idIndexMarker119"/> on the networking layer.</p>
			<p>Now, we need to build the use case to retrieve <code>ConcreteEntity</code>:</p>
			<pre>class ConcreteDataUseCase @Inject constructor(private val concreteDataRepository: ConcreteDataRepository) {
 
    fun getConcreteEntity(): Flow&lt;ConcreteEntity&gt; {
        return flow {
            val fooList = concreteDataRepository.
                getConcreteEntity()
            emit(fooList)
        }.flowOn(Dispatchers.IO)
    }
}</pre>
			<p><code>ConcreteDataUseCase</code> will depend on <code>ConcreteDataRepository</code> to retrieve the data and emit it using Kotlin flows.</p>
			<p>Now, <code>MainViewModel</code> will need to be changed to invoke the use case. To do so, it will use the <code>field1</code> object from <code>ConcreteEntity</code>:</p>
			<pre>@HiltViewModel
class MainViewModel @Inject constructor(private val concreteDataUseCase: ConcreteDataUseCase) :
    ViewModel() {
 
    private val _textData = MutableLiveData&lt;String&gt;()
    val textData: LiveData&lt;String&gt; get() = _textData
 
    fun loadConcreteData() {
        viewModelScope.launch {
            concreteDataUseCase.getConcreteEntity()
                .collect { data -&gt;
                    _textData.postValue(data.field1)
                }
        }
    }
}</pre>
			<p><code>MainViewModel</code> will now depend on <code>ConcreteDataUseCase</code> and retrieve <code>ConcreteEntity</code>, where it will extract <code>field1</code>. This will then be set in <code>LiveData</code>.</p>
			<p><code>MainActivity</code> will be updated to use the <code>textData</code> object from <code>MainViewModel</code>:</p>
			<pre>@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Screen()
        }
    }
}
 
@Composable
fun Screen(mainViewModel: MainViewModel = viewModel()){
    mainViewModel.loadConcreteData()
    UpdateText()
}
 
@Composable
fun UpdateText(mainViewModel: MainViewModel = viewModel()) {
    val text by mainViewModel.textData.
        observeAsState("test")
    MessageView(text = text)
 
}
 
@Composable
fun MessageView(text: String) {
    Text(text = text)
}</pre>
			<p>With that, <code>MainActivity</code> has been<a id="_idIndexMarker120"/> updated to use <code>LiveData</code>, which emits a <code>String</code> instead of a <code>ConcreteData</code> object.</p>
			<p>Finally, the Hilt module<a id="_idIndexMarker121"/> will be updated as follows:</p>
			<pre>@Module
@InstallIn(SingletonComponent::class)
class ApplicationModule {
    … 
    @Singleton
    @Provides
    fun provideHttpClient(): OkHttpClient {
        return OkHttpClient
            .Builder()
            .readTimeout(15, TimeUnit.SECONDS)
            .connectTimeout(15, TimeUnit.SECONDS)
            .build()
    }
 
    @Singleton
    @Provides
    fun provideConverterFactory(): MoshiConverterFactory = 
        MoshiConverterFactory.create()
 
    @Singleton
    @Provides
    fun provideRetrofit(
        okHttpClient: OkHttpClient,
        gsonConverterFactory: MoshiConverterFactory
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("schema://host.com")
            .client(okHttpClient)
            .addConverterFactory(gsonConverterFactory)
            .build()
    }
 
    @Singleton
    @Provides
    fun provideCurrencyService(retrofit: Retrofit): 
        ConcreteDataService =
        retrofit.create(ConcreteDataService::class.java)
    @Singleton
    @Provides
    fun provideConcreteDataSource(concreteDataService: 
        ConcreteDataService): ConcreteDataSource =
        ConcreteDataSourceImpl(concreteDataService)
}</pre>
			<p>Here, we can see that <code>ConcreteDataUseCase</code> just invokes <code>ConcreteDataRepository</code>, which just invokes <code>ConcreteDataSource</code>. You may be wondering<a id="_idIndexMarker122"/> why this boilerplate is necessary. In this case, we have a bit of fake duplication. As the code grows, <code>ConcreteDataRepository</code> may connect to other data sources, and <code>ConcreteDataUseCase</code> may need to connect to multiple repositories to combine the data. The same can be said about <code>ConcreteData</code> and <code>ConcreteEntity</code>. Another benefit of this approach is the imposition of more rigor when it comes to development, and it creates consistency. </p>
			<p>Let's look at the following diagram and see how it compares to <em class="italic">Figure 1.4</em>:</p>
			<div><div><img src="img/Figure_1.05_B18320.jpg" alt="Figure 1.5 – Clean architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Clean architecture</p>
			<p>If we look at the top row, we will see the use case and the entity. We can also see that the dependencies go<a id="_idIndexMarker123"/> from the classes at the bottom toward the classes at the top, similar to how the dependencies go from the outer layers toward the inner layers here. A difference you may have noticed is that our example doesn't mention the usage of modules. Later in this book, we will explore how to apply clean architecture to multiple modules and how to manage them.</p>
			<p>We are now back in the start-up, and you started working on the application, where you have defined a few entities and use cases and have put a simple UI in place. The product owner has asked you to deliver a demo with some mock data for tomorrow. What can you do? You can create a new implementation of your data source and plug in some mock objects that you can use to satisfy the conditions for the demo. You show the demo of the application and you receive some feedback about your UI. This means you can change your activities and fragments to render the data appropriately, and this won't impact any of the other components. What would happen if the use case were to change? In that situation, this would propagate into the rest of the other layers. This depends on the change, though, but this scenario<a id="_idIndexMarker124"/> is to be expected in this situation. </p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor037"/>Summary</h1>
			<p>In this chapter, we explored what an Android app used to look like and all the problems developers would face at the time. We've looked at some of the most important software design principles, such as SOLID, to get a better understanding of how to improve our code and how these principles helped the Android platform evolve. We also looked at the adoption of a new programming language that came with the introduction of new software paradigms, the addition of event-based libraries and frameworks, the introduction of architecture components to help developers write more testable applications, and a new way to build user interfaces. Finally, we introduced clean architecture, which helps us build maintainable, testable, and more independent applications. We looked at all of these changes through a small example, where we saw them transition from what they may have looked like in 2010 to what they may look like now. </p>
			<p>In the next chapter, we will deep dive into the libraries that are required for loading, storing, and managing data on Android. We will combine them to build an app using clean architecture.</p>
		</div>
	</body></html>