["```java\nJobScheduler js = (JobScheduler)\n     getSystemService(Context.JOB_SCHEDULER_SERVICE);\n```", "```java\nint schedule(JobInfo job);\n```", "```java\nBuilder(int jobId, ComponentName jobService)\n```", "```java\nComponentName jobSrvc= new ComponentName(ctx, MyJobService.class);\nJobInfo.Builder jobIBuilder = new JobInfo.Builder(MY_JOB_ID,\n                                                  jobSrvc);\n```", "```java\njobIBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);\n```", "```java\njobIBuilder.setRequiresCharging(true);\n```", "```java\njobIBuilder.setRequiresDeviceIdle(true);\n```", "```java\njobIBuilder.setPersisted(true);\n```", "```java\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\n```", "```java\nlong interval = TimeUnit.HOURS.toMillis(5L);\njobIBuilder.setPeriodic(interval);\n```", "```java\nlong maxExecutionTime = TimeUnit.MINUTES.toMillis(5L);\njobIBuilder.setOverrideDeadline(maxExecutionTime);\n```", "```java\njobIBuilder.setOverrideDeadline(TimeUnit.HOURS.toMillis(1L));\n```", "```java\njobIBuilder.setMinimumLatency(TimeUnit.SECONDS.toMillis(120));\n```", "```java\n// Initial Backoff of 10 minutes that grows linearly\njobIBuilder.setBackoffCriteria(TimeUnit.MINUTES.toMillis(10L),\nJobInfo.BACKOFF_POLICY_LINEAR);\n\n// Initial Backoff of 3 minutes that grows exponentially\njobIBuilder.setBackoffCriteria(TimeUnit.MINUTES.toMillis(3),\nJobInfo.BACKOFF_POLICY_EXPONENTIAL);\n```", "```java\nPersistableBundle bundle = new PersistableBundle();\nbundle.putInt(MY_JOB_ARG1,2);\njobIBuilder.setExtras(bundle);\n```", "```java\nJobInfo.Builder jobIBuilder = ...\n// Set Criterias\nJobInfo jobInfo = jobIBuilder.setRequiresCharging(true)\n\nsetRequiresDeviceIdle(true).\n                                             ...\n                                             build();\n```", "```java\n  static final int ACC_BACKUP_JOB_ID =\"AccountBackJobService\"\n  hashCode();\n```", "```java\nprivate static final String SYNC_FILE = \"account.json\";\nprivate static final String SYNC_PATH = \"account_sync\";\nprivate static final String SYNC_PATH_KEY = \"path\";\n...\nPersistableBundle bundle = new PersistableBundle();\n// Forward filename where the account information is stored\nbundle.putString(SyncTask.SYNC_FILE_KEY,SYNC_FILE);\n// Forward the HTTP Path used to upload the account information\nbundle.putString(SyncTask.SYNC_PATH_KEY,SYNC_PATH);\n```", "```java\nComponentName serviceName = new ComponentName(this,\n  AccountBackupJobService.class);\n\n// Setup the Job Information and criterias over a builder\nJobInfo jobInfo = new JobInfo.\n   Builder(ACC_BACKUP_JOB_ID, serviceName)\n    .setRequiresCharging(true)\n    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)\n    .setRequiresDeviceIdle(true)\n    .setPersisted(true)\n    .setOverrideDeadline(TimeUnit.HOURS.toMillis(8L))\n    .setExtras(bundle)\n    .build();\n```", "```java\n// Get a Reference to the Service\nJobScheduler jobScheduler = (JobScheduler) \n   getSystemService(JOB_SCHEDULER_SERVICE);\n\nint result = jobScheduler.schedule(jobInfo);\n\nif ( result == JobScheduler.RESULT_FAILURE ) {\n  // Failed to setup the job \n  Toast.makeText(AccountInfoActivity.this, \n                 \"Failed to setup a sharedpref backup job\", \n                 Toast.LENGTH_SHORT).show();\n} else {\n  // Schedule Success \n  Toast.makeText(SharedPrefActivity.this,\n                 \"SharedPrefBack job successfully scheduled\",\n                 Toast.LENGTH_SHORT).show();\n}\n```", "```java\npublic class AccountBackupJobService extends JobService {\n    @Override\n    public boolean onStartJob(JobParameters params) {\n      // Start your job here\n        return false;\n    } \n    @Override\n    public boolean onStopJob(JobParameters params) {\n        // Stop your job here\n        return false;\n    }\n}\n```", "```java\n<service \n   android:name=\".chapter7.AccountBackupJobService\"\n   android:exported=\"true\"\n   android:permission=\"android.permission.BIND_JOB_SERVICE\" />\n```", "```java\npublic class Result<T> {\n    public T result;\n    public Exception exc;\n}\n\npublic class SyncTask extends \n  AsyncTask<JobParameters, Void, Result<JobParameters>> {\n\n  // Parameter Keys for parameter arguments\n  public static final String SYNC_FILE_KEY = \"file\";\n  public static final String SYNC_ENDPOINT_KEY = \"http_endpoint\";\n\n   // Variable used to store a reference to the service\n  private final JobService jobService;\n\n  // Constructor\n  public SyncTask(JobService jobService) {\n        this.jobService = jobService;\n  } \n  ...\n}\n```", "```java\n@Override\nprotected Result<JobParameters> doInBackground(\n  JobParameters... params) {\n\n  Result<JobParameters> result = new Result<JobParameters>();\n  HttpURLConnection urlConn = null;\n  try {\n    URL url;\n    ...\n         // Retrieve the file to upload from the parameters\n         // passed in \n    String file = params[0].getExtras().\n                                  getString(SYNC_FILE_KEY);\n         // Remote WebService Path\n    String endpoint = params[0].getExtras().\n                             getString(SYNC_ENDPOINT_KEY);\n    url = new URL (\"http://<webs_host>:<webs_port>/\" \n                        + endpoint);\n    ...\n    // Load the account information stored internally\n    String body = Util.loadJSONFromFile(jobService, file);\n    // Write the information to the remote service\n            uploadJsonToServer(urlConn, body);\n    // Process Server Response\n         ...\n  } catch (Exception e) {\n    result.exc = e;\n  } finally {\n     if ( urlConn != null) {\n      urlConn.disconnect();\n     }\n  }\n  return result;\n}\n```", "```java\ntry {\n  ...\n  int resultCode = urlConn.getResponseCode();\n  if ( resultCode != HttpURLConnection.HTTP_OK ) {\n    throw new Exception(\"Failed to sync with server :\" + \n        resultCode);\n  }\n  result.result = params[0];\n...\n```", "```java\n@Override\nprotected void onPostExecute(Result<JobParameters> result) {\n\n  NotificationCompat.Builder builder =\n    new NotificationCompat.Builder(jobService);\n  ...\n  if ( result.exc != null ) {\n    // Error handling \n    jobService.jobFinished(result.result, true);\n    builder.setContentTitle(\"Failed to sync account\")\n    .setContentText(\"Failed to sync account \" + result.exc);\n  } else {\n    // Success handling\n    builder.setContentTitle(\"Account Updated\")\n      .setContentText(\"Updated Account Sucessfully at \" + \n             new Date().toString());\n    jobService.jobFinished(result.result, false);\n  }\n  nm.notify(NOTIFICACTION_ID, builder.build());\n}\n```", "```java\npublic class SyncJobService extends JobService {\n\n    private static final String TAG = \"SyncJobService\";\n    SyncTask mJob = null;\n    @Override\n    public boolean onStartJob(JobParameters params) {\n        Log.i(TAG, \"on start job: \" + params.getJobId());\n        if ( mJob != null ){\n            mJob = new SyncTask(this);\n            mJob.execute(params);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onStopJob(JobParameters params) {\n        Log.i(TAG, \"on stop job: \" + params.getJobId());\n        if ( mJob != null ){\n            mJob.cancel(true);\n            mJob = null;\n        }\n        return true;\n    }    \n}\n```", "```java\npublic List<JobInfo> getAllPendingJobs();\n```", "```java\npublic class JobListActivity extends Activity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n   ...\nJobScheduler jobScheduler = (JobScheduler)\n       getSystemService(JOB_SCHEDULER_SERVICE);\n\n    // Get the list of scheduled jobs\n    List<JobInfo> jobList = jobScheduler.getAllPendingJobs();\n    // Initialize the adapter job list\n    JobListRecyclerAdapter adapter = \n      new JobListRecyclerAdapter(this, jobList);\n\n    rv.setAdapter(adapter);\n    // Set the Job Counter\n    TextView jobCountTv = (TextView)findViewById(R.id.jobCount);\n    jobCountTv.setText(Integer.toString(jobList.size()));\n  }\n}\n```", "```java\npublic class JobListRecyclerAdapter extends\n  RecyclerView.Adapter<JobListRecyclerAdapter.JobViewHolder> {\n       â€¦\n  public static class JobViewHolder extends\n    RecyclerView.ViewHolder {\n    // References to the Views\n    CardView cv;\n    TextView jobId;\n    TextView serviceName;\n\n    JobViewHolder(View itemView) {\n      super(itemView);\n      cv = (CardView)itemView.findViewById(R.id.cv);\n      jobId = (TextView)itemView.findViewById(R.id.jobIdTv);\n      serviceName = (TextView) \n        itemView.findViewById(R.id.className);\n   }\n }\n}\n```", "```java\n@Override\npublic void onBindViewHolder(\n  JobListRecyclerAdapter.JobViewHolder holder, int position) {\n  // Retrieve the job for the current list row\n  final JobInfo ji = mJobList.get(position);\n  // Update the UI Views with the Job Info\n  holder.jobId.setText(Integer.toString(ji.getId()));\n  holder.serviceName.setText(ji.getService().getClassName());\n}\n```", "```java\nvoid cancel(int jobId);\n\nvoid cancelAll();\n```", "```java\n  final JobInfo ji = ...;\n  JobScheduler jobScheduler = (JobScheduler)\n        mContext.getSystemService(mContext.JOB_SCHEDULER_SERVICE);\n  // Cancel a Specific Job based on the JobInfo->jobId\n  jobScheduler.cancel(ji.getId());\n```", "```java\nstatic final int SYNC_PER_JOB_ID = \"SyncJobPerService\".hashCode();\n```", "```java\nJobInfo.Builder builder = new JobInfo.Builder(SYNC_PER_JOB_ID,\n   serviceName);\nbuilder.setRequiresDeviceIdle(true)  \n  // Persist the schedule across the device reboots\n .setPersisted(true)\n .setPeriodic(TimeUnit.HOURS.toMillis(12L))\n  .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)\n  .setRequiresDeviceIdle(true)\n  .setExtras(bundle);\n\n// Schedule the repeating job\nJobScheduler jobScheduler = (JobScheduler) getSystemService(JOB_SCHEDULER_SERVICE);\njobScheduler.schedule(builder.build());\n```"]