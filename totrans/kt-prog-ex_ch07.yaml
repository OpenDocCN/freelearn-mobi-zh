- en: Storing Information in a Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数据库中存储信息
- en: 'In the last chapter,  we touched on important topics, such as the use of third
    party libraries, Android application testing, and how to run background tasks
    on the Android platform. In this chapter, we will focus on the storage of data.
    Over the course of this book, we have stored persistent application data at different
    instances when necessary. So far, we have made use of `SharedPreferences` to cater
    to all our data storage needs. This is by no means the only option for data storage
    the Android application framework provides. In this chapter, we will take an in-depth
    look at the means of data storage available to us on Android. In the process of
    doing this, we will learn about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了重要的话题，例如使用第三方库、Android应用程序测试以及如何在Android平台上运行后台任务。在本章中，我们将专注于数据的存储。在本书的整个过程中，我们在必要时在不同实例中存储了持久应用程序数据。到目前为止，我们已经使用了`SharedPreferences`来满足所有我们的数据存储需求。这绝不是Android应用程序框架提供的唯一数据存储选项。在本章中，我们将深入探讨我们在Android上可用的数据存储方式。在这个过程中，我们将了解以下内容：
- en: Internal storage
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部存储
- en: External storage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部存储
- en: Network storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络存储
- en: SQLite databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite数据库
- en: Content providers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容提供者
- en: In addition, we will identify which storage method is best for various use cases.
    Let's start the chapter off by learning about internal storage.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将确定哪种存储方法最适合各种用例。让我们从学习内部存储开始本章。
- en: Ellipses between code signifies more code that will be present in the code files.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 代码之间的省略号表示代码文件中将包含更多代码。
- en: Working with internal storage
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与内部存储一起工作
- en: This is an available storage medium on the Android application framework that
    empowers developers to store private data on a device's memory. As the word *private*
    implies, other applications cannot access the data stored by an app via internal
    storage. In addition, these files will be removed from storage when that app is
    uninstalled.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Android应用程序框架中可用的一种存储介质，它使开发者能够在设备的内存中存储私有数据。正如“私有”一词所暗示的，其他应用程序无法通过内部存储访问应用程序存储的数据。此外，当应用程序被卸载时，这些文件将从存储中删除。
- en: Writing files to internal storage
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件写入内部存储
- en: In order to create a private file on internal storage, it is necessary to call
    `openFileOutput()`. The `openFileOutput()` function takes two arguments. The first
    is the name (in form of a `String`) of the file to open and the second is the
    operating mode. Note that `openFileOutput()` must be called within an instance
    of `Context`, such as an `Activity`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在内部存储上创建一个私有文件，必须调用`openFileOutput()`。`openFileOutput()`函数接受两个参数。第一个是要打开的文件（以`String`形式）的名称，第二个是操作模式。请注意，`openFileOutput()`必须在`Context`实例中调用，例如`Activity`。
- en: 'The `openFileOutput()` method returns a `FileOutputStream`. This can then be
    used to tell the file it is done with the `write()` method. Once writing is done,
    the `FileOutputStream` should be closed by calling its `close()` method. The following
    code snippet demonstrates this process:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`openFileOutput()`方法返回一个`FileOutputStream`。然后可以使用`write()`方法来告诉文件已完成写入。一旦写入完成，应该通过调用其`close()`方法来关闭`FileOutputStream`。以下代码片段演示了此过程：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`MODE_PRIVATE` is an operating mode that creates a file with a given name (or
    replaces a file with a corresponding name) and makes it private to your application.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODE_PRIVATE`是一种操作模式，它创建一个具有给定名称（或替换具有相应名称的文件）的文件，并将其设置为对您的应用程序私有。'
- en: Reading files from internal storage
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从内部存储读取文件
- en: In order to read a private file, get a `FileInputStream` by calling `openFileInput()`.
    This method takes a single argument—the name of the file to be read. `openFileInput()`
    must be called within an instance of `Context`. After retrieving a `FileInputStream`,
    you read bytes from the file by calling its `read()` function. Once you are done
    reading from the file, close it by invoking `close()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取一个私有文件，通过调用`openFileInput()`获取一个`FileInputStream`。此方法接受单个参数——要读取的文件的名称。`openFileInput()`必须在`Context`实例中调用。在获取`FileInputStream`之后，通过调用其`read()`函数从文件中读取字节。一旦完成从文件中读取，通过调用`close()`关闭它。
- en: 'Check out the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A sample application using internal storage
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内部存储的示例应用
- en: As a suitable example generally helps the understanding of a concept, let's
    create a quick bare bones *file-updater* application that utilizes internal storage.
    The operation of the file updater is simple. It collects text data from the user
    via an input field and updates a file stored in internal storage. A user can then
    check the text existing in that file from a view within the application. Simple,
    right? It's supposed to be! Create a new Android project and name it whatever
    you want. Just ensure that whatever name you give it reflects the purpose of the
    application. Once the project is created, create two new packages named `base` and
    `main`, within the `src` project package.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个合适的例子通常有助于理解一个概念，让我们创建一个快速简单的*文件更新器*应用程序，该程序利用内部存储。文件更新器的操作很简单。它通过输入字段从用户那里收集文本数据，并更新存储在内部存储中的文件。然后，用户可以从应用程序中的视图检查该文件中存在的文本。简单，对吧？它应该是这样的！创建一个新的Android项目，并给它起任何您想要的名字。只需确保您给出的名字反映了应用程序的目的。一旦项目创建完成，在`src`项目包中创建两个新的包，分别命名为`base`和`main`。
- en: 'Add a `BaseView` interface to the `base` package, containing the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`base`包中添加一个`BaseView`接口，包含以下代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will already be familiar with view interface definitions if you read the
    previous chapter. If you haven''t, this would be a good time to do so. In the
    `main` package, create a `MainView` extending the `BaseView` as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读了上一章，您将已经熟悉视图接口定义。如果您还没有，现在是做这件事的好时机。在`main`包中，创建一个扩展`BaseView`的`MainView`，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The file-updater application is going to have two distinct views in the form
    of fragments that can be shown to a user. The first view is the home view from
    which a user can update the content of the file, and the second a content view
    from which the user can read the content of the updated file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件更新应用程序将以两种不同的视图形式存在，以供用户显示。第一个视图是主页视图，用户可以从该视图更新文件的内容，第二个视图是内容视图，用户可以从该视图读取更新文件的文本内容。
- en: 'Now, create a new empty activity within `main`. Name this activity `MainActivity`.
    Ensure that you make `MainActivity` the launcher activity. Once `MainActivity`
    is created, ensure that it extends the `MainView` before proceeding. Open `activity_main.xml`
    and edit it to contain the following content:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main`中创建一个新的空活动。将此活动命名为`MainActivity`。确保您将`MainActivity`设置为启动活动。一旦创建了`MainActivity`，在继续之前，确保它扩展了`MainView`。打开`activity_main.xml`并编辑它以包含以下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We added a `LinearLayout` view group to the root view of the layout file. This
    layout is going to serve as the container for the home and content fragment of
    the application. We now need layouts for the home and content fragments. The following
    is the home fragment layout (`fragment_home.xml`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在布局文件的根视图中添加了一个`LinearLayout`视图组。这个布局将作为应用程序主页和内容片段的容器。我们现在需要为主页和内容片段创建布局。以下是为主页片段创建的布局（`fragment_home.xml`）：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before you open the design window to view how the layout translates we need
    to add some value resources. Your project''s `strings.xml` file should look similar
    to the following (with the exception of the `app_name` string resource):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在您打开设计窗口查看布局如何转换之前，我们需要添加一些值资源。您的项目的`strings.xml`文件应类似于以下内容（除了`app_name`字符串资源）：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition, your project should have a `dimens.xml` file containing the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您的项目应该有一个包含以下代码的`dimens.xml`文件：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you are done adding the preceding resources, you can view the layout design
    window of `fragment_home.xml`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加了上述资源，您就可以查看`fragment_home.xml`的布局设计窗口：
- en: '![](img/4d2dc4f3-2dcf-4ca9-b5f0-11a0ae9d4047.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d2dc4f3-2dcf-4ca9-b5f0-11a0ae9d4047.jpg)'
- en: 'Now for the content fragment layout. Add a `fragment_content.xml` layout file
    to the layout resource directory containing the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是内容片段布局。将一个名为`fragment_content.xml`的布局文件添加到布局资源目录中，包含以下代码：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The layout contains a single `TextView` that will render the text existing in
    the internal storage file to the user of the application. You can check the layout
    design window if you want, but there will not be much to see.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 布局包含一个单独的`TextView`，它将渲染存储在内部存储文件中的文本给应用程序的用户。如果您想检查布局设计窗口，可以这样做，但您不会看到太多内容。
- en: 'We have reached the point where we need to create appropriate fragment classes
    to render the fragment layouts we just created. Add the `HomeFragment` class to
    `MainActivity`, which is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了需要创建适当的片段类以渲染我们刚刚创建的片段布局的阶段。将`HomeFragment`类添加到`MainActivity`中，如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following method is for the instantiation of instance properties:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法用于实例化实例属性：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s open a new `FileOutputStream` to a file named `content_file`. This file
    is a private file stored in internal storage and as such is only accessible by
    your application:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个名为`content_file`的新`FileOutputStream`。此文件是存储在内部存储中的私有文件，因此只能由您的应用程序访问：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following function is called to display an error to the user if an invalid
    input is given:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数在给出无效输入时向用户显示错误：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's write a string content with the use of file via a `FileOutputStream`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用文件通过`FileOutputStream`写入字符串内容
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the function below is called to clear the input in the input field:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数被调用以清除输入字段中的输入：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code snippet shows a success message to the user when invoked:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，以下代码片段向用户显示成功消息：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It will display an error message if the user submits an empty value as file
    content input:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提交空值作为文件内容输入，它将显示错误消息：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s write content to the file, clear the input `EditText` and show a file
    update success message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将内容写入文件，清除输入的`EditText`并显示文件更新成功消息：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s navigate user to the content fragment and display home button on action
    bar to enable a user go back to the previous fragment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引导用户到内容片段，并在工具栏上显示主页按钮，以便用户能够返回到上一个片段：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Read through the comments of `HomeFragment` to ensure you understand what’s
    going on. Now that we have added `HomeFragment` to `MainActivity`, we must also
    add a fragment to render the `fragment_content.xml` layout to a user. The following
    is the necessary `ContentFragment` class. Add this class to `MainActivity`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`HomeFragment`的注释以确保您理解正在发生的事情。现在，我们已经将`HomeFragment`添加到`MainActivity`中，我们还必须添加一个片段来渲染`fragment_content.xml`布局给用户。以下是需要添加到`MainActivity`的`ContentFragment`类：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s update content rendered in `TextView` upon resumption of fragment:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当片段恢复时，让我们更新`TextView`中渲染的内容：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code reads the content of file in internal storage and returns
    content as a string:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码读取内部存储中文件的内容，并将内容作为字符串返回：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `tvContent` instance (the `TextView` displaying the file content to the
    user) is updated upon resumption of the `ContentFragment` activity. The content
    of the `TextView` is updated by setting the text of the `TextView` to the content
    read from the file with `readFile()`. The last thing that is necessary is the
    completion of `MainActivity`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ContentFragment`活动恢复时，`tvContent`实例（向用户显示文件内容的`TextView`）将被更新。`TextView`的内容通过将`TextView`的文本设置为从文件中读取的内容（使用`readFile()`）来更新。最后一件必要的事情是完成`MainActivity`。
- en: 'Your fully completed `MainActivity` class should look similar to the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您完全完成的`MainActivity`类应类似于以下内容：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s set up fragment instances:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置片段实例：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s create the `fragment_home.xml` layout:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`fragment_home.xml`布局：
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s open a new `FileOutputStream` to a file named `content_file`. This file
    is a private file stored in internal storage and as such is only accessible by
    your application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个名为`content_file`的新`FileOutputStream`。此文件是存储在内部存储中的私有文件，因此只能由您的应用程序访问：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following code snippet displays an error message if the user submits an
    empty value as file content input:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段会在用户提交空值作为文件内容输入时显示错误消息：
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will navigate user to the content fragment and display home button on action
    bar to enable a user go back to the previous fragment:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引导用户到内容片段，并在工具栏上显示主页按钮，以便用户能够返回到上一个片段：
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s update content rendered in `TextView` upon resumption of fragment:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在片段恢复时更新`TextView`中渲染的内容：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will read the content of file in internal storage and return content
    as a string:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将读取内部存储中文件的 内容，并将内容作为字符串返回：
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have completed `MainActivity`, the application is ready to be run.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`MainActivity`，应用程序准备运行。
- en: 'Build and run the project on a device of your choice. Upon launch of the application,
    the home fragment of `MainActivity` will be presented on the device''s display.
    Type in any content of your choice within the `EditText` input:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择的设备上构建并运行项目。当应用程序启动时，`MainActivity`的主片段将在设备上显示。在`EditText`输入中输入您选择的内容：
- en: '![](img/eab3fed7-7d1e-46ad-99f4-6fc3eba4f395.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eab3fed7-7d1e-46ad-99f4-6fc3eba4f395.jpg)'
- en: 'After adding content to the `EditText`, click the UPDATE FILE button. The internal
    storage file will be updated with the content provided, and you will be notified
    upon completion of this update with a toast message. Having updated the file,
    click the VIEW FILE button:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在向 `EditText` 添加内容后，点击 UPDATE FILE 按钮。内部存储文件将更新为提供的内容，更新完成后会通过 toast 消息通知您。更新文件后，点击
    VIEW FILE 按钮：
- en: '![](img/f24940a3-9fdf-4e4b-a9cb-23fd51e3750f.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f24940a3-9fdf-4e4b-a9cb-23fd51e3750f.jpg)'
- en: The content fragment will be displayed with its `TextView` containing the updated
    file content. Though simple, the file-updater application we just created is a
    good example showing how Android applications work with internal storage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 内容片段将通过包含更新后文件内容的 `TextView` 显示。虽然简单，但我们刚刚创建的文件更新应用程序是一个很好的例子，展示了 Android 应用程序如何与内部存储一起工作。
- en: Saving cached files
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存缓存文件
- en: In the event that you would rather not store data permanently, but instead cache
    data within storage, make use of `cacheDir` to open a file that represents a directory
    (within internal storage) where your application should save temporary cache files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想永久存储数据，而是将数据缓存到存储中，请使用 `cacheDir` 打开一个表示目录（在内部存储中）的文件，您的应用程序应在此目录中保存临时缓存文件。
- en: '`cacheDir` returns a `File`. As such, you may make use of all methods put at
    your disposal by the `File` class, such as the `outputStream()`, which returns
    a `FileOutputStream`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheDir` 返回一个 `File` 对象。因此，您可以利用 `File` 类提供的所有方法，例如 `outputStream()`，它返回一个
    `FileOutputStream`。'
- en: Working with external storage
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部存储一起工作
- en: External storage is used to create and access non-private, shared, world-readable
    files. Shared external storage is supported by all Android devices. The first
    thing you need to start using external storage is its permission.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 外部存储用于创建和访问非私有、共享、世界可读的文件。所有 Android 设备都支持共享外部存储。开始使用外部存储的第一件事是获取其权限。
- en: Getting external storage permission
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取外部存储权限
- en: The `READ_EXTERNAL_STORAGE` and `WRITE_EXTERNAL_STORAGE` permissions must be
    acquired by your application before it can make use of external storage APIs.
    `READ_EXTERNAL_STORAGE` is necessary when you only need to read from external
    storage. The `WRITE_EXTERNAL_STORAGE` permission is necessary when your application
    requires the ability to write directly to external storage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序可以使用外部存储 API 之前，必须获取 `READ_EXTERNAL_STORAGE` 和 `WRITE_EXTERNAL_STORAGE`
    权限。当您只需要从外部存储读取时，`READ_EXTERNAL_STORAGE` 是必要的。当您的应用程序需要直接写入外部存储的能力时，`WRITE_EXTERNAL_STORAGE`
    权限是必要的。
- en: 'These two permissions can be added with ease to the manifest file, as we have
    seen in previous chapters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所见，这两个权限可以轻松添加到清单文件中：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It should be noted that `WRITE_EXTERNAL_STORAGE` implicitly includes `READ_EXTERNAL_STORAGE`.
    As such, if both permissions are required, it is only necessary to request the
    `WRITE_EXTERNAL_STORAGE` permission:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，`WRITE_EXTERNAL_STORAGE` 隐含包含了 `READ_EXTERNAL_STORAGE`。因此，如果需要这两个权限，只需请求
    `WRITE_EXTERNAL_STORAGE` 权限即可：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Asserting media availability
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言媒体可用性
- en: Sometimes—for one reason or another, such as the storage device being missing—an
    external storage medium may not be available for access. As a consequence, it
    is important to check the availability of external storage media before attempting
    to make use of them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时——由于各种原因，例如存储设备丢失——外部存储介质可能无法访问。因此，在尝试使用它们之前，检查外部存储介质的可用性非常重要。
- en: 'The `getExternalStorageState()` method should be called in order to check whether
    media are available. You can use the following code snippet to check whether external
    storage is available to be written to in your application:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查媒体是否可用，应该调用 `getExternalStorageState()` 方法。您可以使用以下代码片段来检查应用程序是否可以写入外部存储：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Firstly, we retrieve the current state of external storage and then we check
    whether it is in the `MEDIA_MOUNTED` state. If it is in this state, your application
    can write to it. Hence, true is returned by `isExternalStorageWritable()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索外部存储的当前状态，然后检查它是否处于 `MEDIA_MOUNTED` 状态。如果处于此状态，您的应用程序可以写入它。因此，`isExternalStorageWritable()`
    方法返回 true。
- en: 'Checking whether external storage is readable is similarly easy:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查外部存储是否可读同样简单：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Your application can read data from external storage if it is in either the
    `MEDIA_MOUNTED` or the `MEDIA_MOUNTED_READ_ONLY` state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部存储处于 `MEDIA_MOUNTED` 或 `MEDIA_MOUNTED_READ_ONLY` 状态，您的应用程序可以从中读取数据。
- en: Storing sharable files
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储可共享文件
- en: Files that a user or other applications may need to access later on should be
    stored in a shared public directory. Examples of such directories are the `Pictures/`
    and `Music/` directories.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 用户或其他应用程序可能需要稍后访问的文件应存储在共享公共目录中。此类目录的示例包括 `Pictures/` 和 `Music/` 目录。
- en: The `getExternalStoragePulicDirectory()` method should be called by your application
    in order to retrieve a `File` representing a required public directory. The type
    of directory to be retrieved should be passed as the sole argument to the function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应调用 `getExternalStoragePulicDirectory()` 方法以检索表示所需公共目录的 `File` 对象。要检索的目录类型应作为函数的唯一参数传递。
- en: 'The following is a function that creates a directory for music to be stored:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个创建用于存储音乐的目录的函数：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the case where an error occurs when creating the public directory, an appropriate
    message is logged to the console.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建公共目录时发生错误的情况下，适当的消息会被记录到控制台。
- en: Caching files with external storage
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部存储缓存文件
- en: Scenarios may arise in which you need to cache files with external storage.
    You can open a file representing the external storage directory in which your
    application should save cached files with `externalCacheDir`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现需要使用外部存储缓存文件的场景。您可以使用 `externalCacheDir` 打开表示外部存储目录的文件，以便在您的应用程序中保存缓存文件。
- en: Network storage
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络存储
- en: This is the storage of data on a remote server. Unlike other means of storage
    we have talked about, this kind of storage utilizes a network connection to store
    and retrieve data that exists on a remote server. You utilized this storage medium
    when you created the messenger Android application in the previous chapter. The
    messenger application relied heavily on a remote server for the storage and retrieval
    of information. The client-server architecture is primarily in play when a remote
    server acts as a data source for a client application. The client sends a request
    for the data required (typically a GET request) to the server via HTTP, and the
    server responds by sending the required data as a response, thus completing the
    HTTP transaction cycle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是远程服务器上的数据存储。与其他我们讨论过的存储方式不同，这种存储方式利用网络连接来存储和检索存在于远程服务器上的数据。在上一章创建 Android
    消息应用时，您使用了这种存储介质。消息应用严重依赖于远程服务器进行信息的存储和检索。当远程服务器作为客户端应用程序的数据源时，客户端-服务器架构主要发挥作用。客户端通过
    HTTP 向服务器发送所需数据（通常是 GET 请求）的请求，服务器通过发送所需数据作为响应来响应，从而完成 HTTP 事务周期。
- en: Working with a SQLite database
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 SQLite 数据库一起工作
- en: SQLite is a popular **relational database management system** (**RDBMS**) that,
    unlike many RDBMS systems, is not a client-server database engine. Instead, a
    SQLite database is embedded directly into an application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是一个流行的 **关系数据库管理系统**（**RDBMS**），与许多 RDBMS 系统不同，它不是一个客户端-服务器数据库引擎。相反，SQLite
    数据库直接嵌入到应用程序中。
- en: Android provides full support for SQLite. SQLite databases are accessible throughout
    an Android project by classes. Note that in Android, a database is only accessible
    to the application that created it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Android 完全支持 SQLite。SQLite 数据库可以通过类在 Android 项目中访问。请注意，在 Android 中，数据库仅对创建它的应用程序可访问。
- en: 'The use of the Room persistence library is the recommended method of working
    with SQLite in Android. The first step to work with `room` in Android  is the
    inclusion of its necessary dependencies in a project''s `build.gradle` script:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中使用 Room 持久化库是推荐的工作方式。在 Android 中使用 `room` 的第一步是在项目的 `build.gradle`
    脚本中包含其必要的依赖项：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Entities can easily be created with the help of `Room`. All entities must be
    annotated with `@Entity`. The following is a simple `User` entity:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可以借助 `Room` 轻松创建实体。所有实体都必须使用 `@Entity` 注解。以下是一个简单的 `User` 实体：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Room` will create the necessary SQLite table for the `User` entity defined.
    The table will have a name, `user`, and will have four attributes: `id`, `first_name`,
    `surname`, and `phone_number`. The `id` attribute is the primary of the user table
    created. We specified that this should be the case by using the `@PrimaryKey`
    annotation. We specified that the primary keys of each record in the user table
    should be generated by `Room`, by setting `autoGenerate = true` in the `@PrimaryKey`
    annotation. `@ColumnInfo` is an annotation used to specify additional information
    pertaining to a column in a table. Take the following code snippet, for example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Room` 将为定义的 `User` 实体创建必要的 SQLite 表。该表将有一个名为 `user` 的名称，并将有四个属性：`id`、`first_name`、`surname`
    和 `phone_number`。`id` 属性是创建的用户表的主键。我们通过使用 `@PrimaryKey` 注解指定了这一点。我们通过在 `@PrimaryKey`
    注解中将 `autoGenerate` 设置为 `true` 来指定用户表中每条记录的主键应由 `Room` 生成。`@ColumnInfo` 是一个用于指定与表中列相关的额外信息的注解。以下是一个示例代码片段：'
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code specifies that there is a `firstName` attribute possessed
    by a `User`. `@ColumnInfo(name ="first_name")` sets the name of the column in
    the user table for the `firstName` attribute to `first_name`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码指定了 `User` 拥有一个 `firstName` 属性。`@ColumnInfo(name="first_name")` 将 `firstName`
    属性在用户表中的列名设置为 `first_name`。
- en: 'In order to read and write records to and from a database, you need a **Data
    Access Object** (**DAO**). A DAO allows the performance of database operations
    with the use of annotated methods. The following is a DAO for the `User` entity:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在数据库中读取和写入记录，你需要一个**数据访问对象**（**DAO**）。DAO 允许通过注解方法执行数据库操作。以下是一个针对 `User` 实体的
    DAO 示例：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `@Query` annotation marks a method in a DAO class as a query method. The
    query that will be run when the method is invoked is passed as a value to the
    annotation. Naturally, the queries passed to `@Query` are SQL queries. The writing
    of SQL queries is far too vast a topic to cover here, but it is a good idea to
    take some time to understand how to write them properly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Query` 注解将 DAO 类中的方法标记为查询方法。当方法被调用时，将运行的查询作为值传递给注解。自然地，传递给 `@Query` 的查询是
    SQL 查询。编写 SQL 查询是一个过于庞大的主题，在这里无法涵盖，但花些时间了解如何正确编写它们是个好主意。'
- en: The `@Insert` annotation is used to insert data into a table. Other important
    annotations that exist are `@Update` and `@Delete`. They are used to update and
    delete data within a database table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Insert` 注解用于向表中插入数据。其他重要的注解包括 `@Update` 和 `@Delete`。它们用于在数据库表中更新和删除数据。'
- en: 'Lastly, after creating the necessary entities and DAOs, you must define your
    application''s database. In order to do this, you must create a subclass of `RoomDatabase`
    and annotate it with `@Database`. At the minimum, the annotation should include
    a collection of entity class references and a database version number. The following
    is a sample `AppDatabase` abstract class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在创建必要的实体和 DAO 之后，你必须定义你的应用程序数据库。为此，你必须创建 `RoomDatabase` 的一个子类，并用 `@Database`
    注解它。至少，该注解应包括实体类引用的集合和数据库版本号。以下是一个示例 `AppDatabase` 抽象类：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once your app database class is created, you can get an instance of the database
    by calling `databaseBuilder()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了你的应用数据库类，你可以通过调用 `databaseBuilder()` 来获取数据库的一个实例：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once you have an instance of your `RoomDatabase`, you can use it to retrieve
    data access objects that in turn can be used to read, write, update, query, and
    delete data from a database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 `RoomDatabase` 的实例，你可以使用它来检索数据访问对象，进而可以使用这些对象从数据库中读取、写入、更新、查询和删除数据。
- en: Keeping with the practice we have adopted so far, let's create a simple application
    that shows how to utilize SQLite with the help of `Room` in Android. The application
    we are about to build will let an app user manually input information pertaining
    to people (users), and view all user information input at a later time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们迄今为止采用的实践，让我们创建一个简单的应用程序，展示如何在 Android 中使用 `Room` 利用 SQLite。我们将要构建的应用程序将允许应用程序用户手动输入有关人员（用户）的信息，并在稍后查看所有用户输入的信息。
- en: 'Create a new Android project with an empty `MainActivity` set as its launcher
    activity. Add the following dependencies to your application''s `build.gradle`
    script:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Android 项目，并将一个空的 `MainActivity` 设置为启动活动。将以下依赖项添加到你的应用的 `build.gradle`
    脚本中：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In addition, apply the `kotlin-kapt` standalone plugin to your `build.gradle`
    script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将 `kotlin-kapt` 独立插件应用到你的 `build.gradle` 脚本中：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Having added the preceding project dependencies, create a `data` and a `ui`
    package within the project source package. In the `ui` package, add the `MainView`,
    which is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了前面的项目依赖项后，在项目源包内创建一个`data`和一个`ui`包。在`ui`包中，添加`MainView`，如下所示：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After adding `MainView` to the `ui` package, relocate `MainActivity` to the
    `ui` package as well. Now let''s work on the database of our application. As the
    application is going to be storing user information, we need to create a `User`
    entity. Add the following `User` entity to the `data` package:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MainView`添加到`ui`包后，将`MainActivity`也移至`ui`包。现在让我们来处理我们应用程序的数据库。由于应用程序将要存储用户信息，我们需要创建一个`User`实体。将以下`User`实体添加到`data`包中：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now create a `UserDao` within the `data` package:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`data`包中创建一个`UserDao`：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `UserDao` interface has three methods: `all()`, `findById()`, and `Insert()`.
    The `all()` method returns a `Flowable` containing a list of all users. The `findById()`
    method finds a `User` who has an id matching that which is passed to the method,
    if any, and returns the `User` in a `Flowable`. The `insert()` method is used
    to insert a user as a record into the `user` table.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDao`接口有三个方法：`all()`、`findById()`和`Insert()`。`all()`方法返回一个包含所有用户的`Flowable`列表。`findById()`方法查找一个`User`，其id与传递给方法的方法匹配，如果有的话，并在`Flowable`中返回该`User`。`insert()`方法用于将用户作为记录插入到`user`表中。'
- en: 'Now that we have our DAO and entity created, we must create an `AppDatabase`
    class. Add the following to the `data` package:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了DAO和实体，我们必须创建一个`AppDatabase`类。将以下内容添加到`data`包中：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We created a `Factory` companion object possessing a single `create()` function
    that has the sole job of creating an `AppDatabase` instance—if not previously
    created—and returning that instance for use.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个拥有单个`create()`函数的`Factory`伴随对象，该函数的唯一任务是创建一个`AppDatabase`实例（如果尚未创建）并返回该实例以供使用。
- en: 'Creating an `AppDatabase` is the last thing we need to do pertaining to data.
    Now we must create suitable layouts for our application views. We will make use
    of two fragments in our `MainActivity`. The first will be used to collect input
    for a new user to be created and the second will display the information of all
    created users in a `RecyclerView`. Firstly, modify the `activity_main.xml` layout
    to contain the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`AppDatabase`是我们需要做的关于数据的最后一件事。现在我们必须为我们的应用程序视图创建合适的布局。在我们的`MainActivity`中，我们将使用两个片段。第一个将用于收集创建新用户所需的输入，第二个将显示所有已创建用户的信息，在一个`RecyclerView`中。首先，修改`activity_main.xml`布局以包含以下内容：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `LinearLayout` in `activity_main.xml` will contain the fragments of `MainActivity`.
    Add a `fragment_create_user.xml` file to the `resource` layout directory with
    the following content:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`activity_main.xml`中的`LinearLayout`将包含`MainActivity`的片段。将一个`fragment_create_user.xml`文件添加到`resource`布局目录中，并包含以下内容：'
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now add a `fragment_list_users.xml` layout resource with the following content:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加一个包含以下内容的`fragment_list_users.xml`布局资源：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `fragment_list_users.xml` file has a `RecyclerView` that will display the
    information of each user saved to the database. We must create a view holder layout
    resource item for this `RecyclerView`. We''ll call this layout file `vh_user.xml`.
    Create a new `vh_user.xml` resource file and add the following content to it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`fragment_list_users.xml`文件包含一个`RecyclerView`，它将显示保存到数据库中的每个用户的信息。我们必须为这个`RecyclerView`创建一个视图持有者布局资源项。我们将把这个布局文件命名为`vh_user.xml`。创建一个新的`vh_user.xml`资源文件，并添加以下内容：'
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you might have expected, we must add some string and dimension resources
    to our project. Open your application''s `strings.xml` layout file and add the
    following string resources to it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，我们必须向我们的项目中添加一些字符串和维度资源。打开你的应用程序的`strings.xml`布局文件，并添加以下字符串资源：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now create the following dimension resources in your project:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的项目中创建以下维度资源：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It is now time to work on `MainActivity`. As we previously established, we will
    be using two distinct fragments in our `MainActivity` class. The first fragment
    enables a person to save the data of an individual to a SQL database, and the
    next will allow a user to view the information of people that has been saved in
    the database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始工作于`MainActivity`了。正如我们之前所确定的，我们将在`MainActivity`类中使用两个不同的片段。第一个片段允许一个人将个人的数据保存到SQL数据库中，下一个将允许用户查看数据库中已保存的人的信息。
- en: We will create a `CreateUserFragment` first. Add the following fragment class
    to `MainActivity` (located in the `MainActivity.kt`) .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`CreateUserFragment`。将以下片段类添加到`MainActivity`（位于`MainActivity.kt`）中。
- en: '[PRE53]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following method validates the inputs submitted in the create a user form:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法验证在创建用户表单中提交的输入：
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following function shows toast message indicating the user successfully
    created:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数显示提示消息，表明用户已成功创建：
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We have worked with fragments numerous times already. As such, our focus of
    explanation will be on the parts of this fragment that work with the `AppDatabase`.
    In `setupInstances()`, we set up references to the `AppDatabase` and `UserDao`.
    We retrieved an instance of the `AppDatabase` by invoking the `create()` function
    of the `Factory` companion object of the `AppDatabase`. An instance of `UserDao`
    was easily retrieved by calling the `appDatabase.userDao()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用过片段。因此，我们的解释重点将放在与 `AppDatabase` 一起工作的这个片段的部分。在 `setupInstances()` 中，我们设置了
    `AppDatabase` 和 `UserDao` 的引用。通过调用 `AppDatabase` 的 `Factory` 伴生对象的 `create()`
    函数获取 `AppDatabase` 的一个实例。通过调用 `appDatabase.userDao()` 轻松获取 `UserDao` 的一个实例。
- en: 'Let''s move on to the `onClick()` method of the fragment class. When the submit
    button is clicked, the submitted user information will be checked for validity.
    An appropriate error message is shown if any of the input is invalid. Once it
    is asserted that all input are valid, a new `User` object containing the submitted
    user information is created and saved to the database. This is done in the following
    lines:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到片段类的 `onClick()` 方法。当点击提交按钮时，将检查提交的用户信息的有效性。如果任何输入无效，将显示适当的错误消息。一旦断定所有输入都有效，将创建一个新的包含提交用户信息的
    `User` 对象并将其保存到数据库中。这是在以下几行中完成的：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Creating the `ListUsersFragment` is similarly easy to achieve.  Add the following
    `ListUsersFragment` to `MainActivity`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `ListUsersFragment` 同样容易实现。将以下 `ListUsersFragment` 添加到 `MainActivity`：
- en: '[PRE57]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Bind the user recycler view instance to its layout element:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户回收视图实例绑定到其布局元素：
- en: '[PRE58]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s get all users in the user table of the database. And upon successful
    retrieval of the list, add all user objects in the list to users `ArrayList`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取数据库中用户表的所有用户。在成功检索到列表后，将列表中的所有用户对象添加到用户 `ArrayList` 中：
- en: '[PRE59]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`UsersAdapter` in the `ListUsersFragment` uses an instance of `UserDao` to
    populate its user list. This population is done within `populateUsers()`. When
    `populateUsers()` is invoked, a list of all users that have been saved by the
    application is retrieved by invoking `userDao.all()`. Upon successful retrieval
    of all users, all `User` objects are added to the users `ArrayList` of `UserAdapter`.
    The adapter is then notified of the change in data in its dataset by the call
    to `notifyDataSetChanged()`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListUsersFragment` 中的 `UsersAdapter` 使用 `UserDao` 的一个实例来填充其用户列表。这个填充操作是在 `populateUsers()`
    方法中完成的。当调用 `populateUsers()` 方法时，通过调用 `userDao.all()` 获取应用程序已保存的所有用户列表。在成功检索到所有用户后，所有
    `User` 对象都被添加到 `UserAdapter` 的用户 `ArrayList` 中。然后通过调用 `notifyDataSetChanged()`
    通知适配器其数据集中的数据已更改。'
- en: '`MainActivity` itself requires some minor additions. Your completed `MainActivity`
    should look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity` 本身需要一些小的添加。你的完成后的 `MainActivity` 应该看起来像这样：'
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following function is called when the user click the back button, if the
    fragments back stack has one or more fragments, the fragments manager pops the
    fragment and displays it to the user:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击后退按钮时，以下函数被调用，如果片段的后退栈中有一个或多个片段，片段管理器将弹出片段并显示给用户：
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We must now run the application to see if it works as we would like. Build
    and run the project on a device of your choice. Once the project launches, you
    will come face to face with the user creation form. Go ahead and input some user
    information in the form:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须运行应用程序以查看它是否按我们的预期工作。在您选择的设备上构建并运行项目。一旦项目启动，您将面对用户创建表单。请继续在表单中输入一些用户信息：
- en: '![](img/80429a28-c8b2-46b5-8299-978decc32b91.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80429a28-c8b2-46b5-8299-978decc32b91.jpg)'
- en: 'Once you have input valid information into the create user form, click the
    Submit button to save the user to the application''s SQLite database. You will
    be notified once the user has been saved successfully. Having been notified, click
    VIEW USERS to see the information of the user you just saved:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在创建用户表单中输入了有效的信息，点击提交按钮将用户保存到应用程序的 SQLite 数据库中。用户保存成功后，你会收到通知。通知后，点击“查看用户”以查看你刚刚保存的用户信息：
- en: '![](img/c81ed510-be58-4646-b291-b153235ddf8f.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c81ed510-be58-4646-b291-b153235ddf8f.jpg)'
- en: You can create and view information for as many users as you like. There's no
    upper limit to the amount of information the database can contain!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建和查看任意数量的用户信息。数据库可以包含的信息量没有上限！
- en: Working with content providers
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与内容提供者一起工作
- en: We spoke briefly about content providers as Android components in [Chapter 2](kt-prog-ex_ch02.html),
    *Building an Android Application - Tetris*. While doing so, we established the
    fact that content providers help an application control access to data resources
    stored either within the application or within another app. In addition, we established
    that a content provider facilitates the sharing of data with another application
    via an exposed application programming interface.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](kt-prog-ex_ch02.html)中简要介绍了内容提供者作为Android组件，*构建Android应用程序 - 橡皮泥*。在这样做的时候，我们确立了这样一个事实：内容提供者帮助应用程序控制对存储在应用程序内部或另一个应用程序中的数据资源的访问。此外，我们还确立了内容提供者通过公开的应用程序编程接口促进数据与其他应用程序的共享。
- en: A content provider behaves in a way that is similar to the behavior of a database.
    A content provider permits the insertion, deletion, editing, updating, and querying
    of content. These abilities are permitted by the use of methods such as `insert()`,
    `update()`, `delete()`, and `query()`. In many cases, data controlled by a content
    provider exists in a SQLite database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供者的行为类似于数据库的行为。内容提供者允许插入、删除、编辑、更新和查询内容。这些能力通过使用`insert()`、`update()`、`delete()`和`query()`等方法来实现。在许多情况下，由内容提供者控制的数据存在于SQLite数据库中。
- en: 'A content provider for your application can be created in five easy steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内容提供者的应用程序可以按以下五个简单步骤进行：
- en: Create a content provider class that extends `ContentProvider`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`ContentProvider`的内容提供者类。
- en: Define a content URI address.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义内容URI地址。
- en: Create a datasource that the content provider will interact with.  This datasource
    is usually in the form of a SQLite database. In cases where SQLite is the datasource,
    you will need to create a `SQLiteOpenHelper` and override its `onCreate()` in
    order to create the database that will be controlled by the content provider.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建内容提供者将与之交互的数据源。此数据源通常是SQLite数据库的形式。在SQLite是数据源的情况下，您需要创建一个`SQLiteOpenHelper`并覆盖其`onCreate()`方法，以便创建内容提供者将控制的数据库。
- en: Implement the required content provider methods.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现所需的内容提供者方法。
- en: Register the content provider in your project's manifest file.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的清单文件中注册内容提供者。
- en: 'In all, there are six  methods that must be implemented by a content provider.
    These are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，内容提供者必须实现六个方法。这些是：
- en: '`onCreate()`: This method is called to initialize the database'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`: 此方法被调用以初始化数据库'
- en: '`query()`:This method returns data to the caller via a `Cursor`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query()`: 此方法通过`Cursor`将数据返回给调用者'
- en: '`insert()`: This method is called to insert new data into the content provider'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert()`: 此方法被调用以将新数据插入内容提供者'
- en: '`delete()`: This method is called to delete data from the content provider'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`: 此方法被调用以从内容提供者中删除数据'
- en: '`update()`:This method is called to update data in the content provider'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`: 此方法被调用以更新内容提供者中的数据'
- en: '`getType()`: This method returns the MIME type of data in the content provider
    when called'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getType()`: 当调用此方法时，它返回内容提供者中数据的MIME类型'
- en: In order to ensure you fully understand the workings of a content provider,
    let's create a quick example project that utilizes a content provider and a SQLite
    database. Create a new Android studio project named `ContentProvider` and add
    an empty `MainActivity` to it upon creation. Similar to all other applications
    created in this chapter, this example is simple in nature. The application allows
    a user to enter the details of a product (a product name and its manufacturer)
    in text fields and save them to a SQLite database. The user can then view the information
    of products that they previously saved with the click of a button.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您完全理解内容提供者的工作原理，让我们创建一个快速示例项目，该项目利用内容提供者和SQLite数据库。创建一个新的名为`ContentProvider`的Android
    Studio项目，并在创建时向其中添加一个空的`MainActivity`。与本章中创建的所有其他应用程序类似，此示例在本质上很简单。该应用程序允许用户在文本字段中输入产品的详细信息（产品名称及其制造商），并将它们保存到SQLite数据库中。然后，用户可以通过点击按钮查看他们之前保存的产品信息。
- en: 'Modify `activity_main.xml` to contain the following XML:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`activity_main.xml`以包含以下XML：
- en: '[PRE62]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After making the preceding modifications, add the following string resource
    to your project''s `strings.xml` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行上述修改后，将以下字符串资源添加到项目的`strings.xml`文件中：
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now create a `ProductProvider.kt` file in the `com.example.contentproviderexample`
    package and add the following content:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`com.example.contentproviderexample`包中创建一个名为`ProductProvider.kt`的文件，并添加以下内容：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`SQLiteOpenHelper` class that creates the content provider''s database:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内容提供者数据库的 `SQLiteOpenHelper` 类：
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s use the `SQLiteOpenHelper` to get a writable database; a new database
    is created if one does not already exist:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `SQLiteOpenHelper` 来获取一个可写数据库；如果尚不存在，则会创建一个新的数据库：
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Having added a suitable `ProductProvider` to provide content pertaining to
    saved products, we must register the new component in the `AndroidManifest` file.
    We have added the provider to the manifest file in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了一个合适的 `ProductProvider` 来提供与已保存产品相关的内容后，我们必须在 `AndroidManifest` 文件中注册新组件。我们已在以下代码片段中将提供者添加到清单文件中：
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s modify `MainActivity` to exploit this newly registered provider.
    Modify `MainActivity.kt` to contain the following content:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改 `MainActivity` 以利用这个新注册的提供者。将 `MainActivity.kt` 修改为包含以下内容：
- en: '[PRE68]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following function is called to show products that exist in the database:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数被调用以显示数据库中存在的产品：
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The two methods you should focus your attention on in the preceding code block
    are `addProduct()` and `showProducts()`. `addProduct()` stores the product data
    in a `contentValues` instance and then inserts this data into the SQLite database
    with the help of the `ProductProvider` by invoking `contentResolver.insert(ProductProvider.CONTENT_URI,
    contentValues)`. `showProducts()` uses a `Cursor` to display the product information
    stored in the database in toast messages.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，你应该关注的方法是 `addProduct()` 和 `showProducts()`。`addProduct()` 将产品数据存储在
    `contentValues` 实例中，然后通过调用 `contentResolver.insert(ProductProvider.CONTENT_URI,
    contentValues)` 并借助 `ProductProvider` 将这些数据插入 SQLite 数据库。`showProducts()` 使用 `Cursor`
    在 toast 消息中显示存储在数据库中的产品信息。
- en: 'Now that we understand what''s going on, let''s run the application. Build
    and run the application as you have done thus far and wait until the application
    installs and starts. You will be taken straight to `MainActivity` and presented
    with a form to input the name and manufacturer of a product:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了情况，让我们运行应用程序。像以前一样构建并运行应用程序，等待应用程序安装并启动。你将被直接带到 `MainActivity`，并呈现一个表单来输入产品的名称和制造商：
- en: '![](img/385353fc-a1c3-49e3-943c-5fc3f1197780.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/385353fc-a1c3-49e3-943c-5fc3f1197780.jpg)'
- en: 'Upon inputting valid product information, click ADD PRODUCT. The product will
    be inserted as a new record in the products table of the application''s SQLite
    database. Add a few more products with the form and click SHOW PRODUCTS:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输入有效的产品信息后，点击“添加产品”。产品将被作为新记录插入到应用程序的 SQLite 数据库中的产品表中。使用表单添加更多产品并点击“显示产品”：
- en: '![](img/55aa67c9-45b5-4e78-99c6-7457679229c5.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55aa67c9-45b5-4e78-99c6-7457679229c5.jpg)'
- en: Doing this will lead to the invocation of `showProducts()` in `MainActivity`.
    All product records will be fetched and displayed in toast messages one after
    the other.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作将导致在 `MainActivity` 中调用 `showProducts()`。所有产品记录将依次从数据库中检索并显示在 toast 消息中。
- en: That is as much as we need to implement in a sample application to demonstrate
    how content providers work. Try to make the application even more awesome by implementing
    functionality for updating and deleting product records. Doing so will be good
    practice!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在一个示例应用程序中需要实现的内容，以演示内容提供者的工作原理。尝试通过实现更新和删除产品记录的功能来使应用程序更加出色。这样做将是一个良好的实践！
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we dived headfirst into the various mediums of data storage
    that the Android application framework puts at our disposal. We took a look at
    how we can use internal storage and external storage to store data in private
    and public files. In addition, we learned how to work with cache files with the
    help of both internal and external storage.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Android 应用程序框架为我们提供的各种数据存储介质。我们查看了一下如何使用内部存储和外部存储来存储私有和公共文件中的数据。此外，我们还学习了如何在内部和外部存储的帮助下与缓存文件一起工作。
- en: Further into the chapter, we learned about the SQLite RDBMS and explored how
    we can make use of it in our Android applications. We learned how to utilize `Room`
    to retrieve and store data in a SQLite database and then went a step further by
    exploring how to use content providers to control access to data with a SQLite
    database as an underlying datastore.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进一步内容中，我们学习了 SQLite RDBMS 并探讨了如何在我们的 Android 应用程序中利用它。我们学习了如何使用 `Room` 从
    SQLite 数据库中检索和存储数据，然后进一步探讨了如何使用内容提供者来控制以 SQLite 数据库作为底层数据存储的数据访问。
- en: In the next chapter, we will conclude our Android application framework exploration
    by learning how to secure and deploy an Android application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习如何确保和部署一个Android应用程序来总结我们对Android应用框架的探索。
