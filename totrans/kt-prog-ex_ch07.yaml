- en: Storing Information in a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter,  we touched on important topics, such as the use of third
    party libraries, Android application testing, and how to run background tasks
    on the Android platform. In this chapter, we will focus on the storage of data.
    Over the course of this book, we have stored persistent application data at different
    instances when necessary. So far, we have made use of `SharedPreferences` to cater
    to all our data storage needs. This is by no means the only option for data storage
    the Android application framework provides. In this chapter, we will take an in-depth
    look at the means of data storage available to us on Android. In the process of
    doing this, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Internal storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we will identify which storage method is best for various use cases.
    Let's start the chapter off by learning about internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipses between code signifies more code that will be present in the code files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with internal storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an available storage medium on the Android application framework that
    empowers developers to store private data on a device's memory. As the word *private*
    implies, other applications cannot access the data stored by an app via internal
    storage. In addition, these files will be removed from storage when that app is
    uninstalled.
  prefs: []
  type: TYPE_NORMAL
- en: Writing files to internal storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create a private file on internal storage, it is necessary to call
    `openFileOutput()`. The `openFileOutput()` function takes two arguments. The first
    is the name (in form of a `String`) of the file to open and the second is the
    operating mode. Note that `openFileOutput()` must be called within an instance
    of `Context`, such as an `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `openFileOutput()` method returns a `FileOutputStream`. This can then be
    used to tell the file it is done with the `write()` method. Once writing is done,
    the `FileOutputStream` should be closed by calling its `close()` method. The following
    code snippet demonstrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`MODE_PRIVATE` is an operating mode that creates a file with a given name (or
    replaces a file with a corresponding name) and makes it private to your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading files from internal storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to read a private file, get a `FileInputStream` by calling `openFileInput()`.
    This method takes a single argument—the name of the file to be read. `openFileInput()`
    must be called within an instance of `Context`. After retrieving a `FileInputStream`,
    you read bytes from the file by calling its `read()` function. Once you are done
    reading from the file, close it by invoking `close()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A sample application using internal storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a suitable example generally helps the understanding of a concept, let's
    create a quick bare bones *file-updater* application that utilizes internal storage.
    The operation of the file updater is simple. It collects text data from the user
    via an input field and updates a file stored in internal storage. A user can then
    check the text existing in that file from a view within the application. Simple,
    right? It's supposed to be! Create a new Android project and name it whatever
    you want. Just ensure that whatever name you give it reflects the purpose of the
    application. Once the project is created, create two new packages named `base` and
    `main`, within the `src` project package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `BaseView` interface to the `base` package, containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will already be familiar with view interface definitions if you read the
    previous chapter. If you haven''t, this would be a good time to do so. In the
    `main` package, create a `MainView` extending the `BaseView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The file-updater application is going to have two distinct views in the form
    of fragments that can be shown to a user. The first view is the home view from
    which a user can update the content of the file, and the second a content view
    from which the user can read the content of the updated file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new empty activity within `main`. Name this activity `MainActivity`.
    Ensure that you make `MainActivity` the launcher activity. Once `MainActivity`
    is created, ensure that it extends the `MainView` before proceeding. Open `activity_main.xml`
    and edit it to contain the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a `LinearLayout` view group to the root view of the layout file. This
    layout is going to serve as the container for the home and content fragment of
    the application. We now need layouts for the home and content fragments. The following
    is the home fragment layout (`fragment_home.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you open the design window to view how the layout translates we need
    to add some value resources. Your project''s `strings.xml` file should look similar
    to the following (with the exception of the `app_name` string resource):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, your project should have a `dimens.xml` file containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done adding the preceding resources, you can view the layout design
    window of `fragment_home.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d2dc4f3-2dcf-4ca9-b5f0-11a0ae9d4047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now for the content fragment layout. Add a `fragment_content.xml` layout file
    to the layout resource directory containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The layout contains a single `TextView` that will render the text existing in
    the internal storage file to the user of the application. You can check the layout
    design window if you want, but there will not be much to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have reached the point where we need to create appropriate fragment classes
    to render the fragment layouts we just created. Add the `HomeFragment` class to
    `MainActivity`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method is for the instantiation of instance properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open a new `FileOutputStream` to a file named `content_file`. This file
    is a private file stored in internal storage and as such is only accessible by
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is called to display an error to the user if an invalid
    input is given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's write a string content with the use of file via a `FileOutputStream`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And the function below is called to clear the input in the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows a success message to the user when invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It will display an error message if the user submits an empty value as file
    content input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write content to the file, clear the input `EditText` and show a file
    update success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s navigate user to the content fragment and display home button on action
    bar to enable a user go back to the previous fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Read through the comments of `HomeFragment` to ensure you understand what’s
    going on. Now that we have added `HomeFragment` to `MainActivity`, we must also
    add a fragment to render the `fragment_content.xml` layout to a user. The following
    is the necessary `ContentFragment` class. Add this class to `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update content rendered in `TextView` upon resumption of fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code reads the content of file in internal storage and returns
    content as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `tvContent` instance (the `TextView` displaying the file content to the
    user) is updated upon resumption of the `ContentFragment` activity. The content
    of the `TextView` is updated by setting the text of the `TextView` to the content
    read from the file with `readFile()`. The last thing that is necessary is the
    completion of `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your fully completed `MainActivity` class should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set up fragment instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `fragment_home.xml` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open a new `FileOutputStream` to a file named `content_file`. This file
    is a private file stored in internal storage and as such is only accessible by
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet displays an error message if the user submits an
    empty value as file content input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will navigate user to the content fragment and display home button on action
    bar to enable a user go back to the previous fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update content rendered in `TextView` upon resumption of fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will read the content of file in internal storage and return content
    as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have completed `MainActivity`, the application is ready to be run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the project on a device of your choice. Upon launch of the application,
    the home fragment of `MainActivity` will be presented on the device''s display.
    Type in any content of your choice within the `EditText` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eab3fed7-7d1e-46ad-99f4-6fc3eba4f395.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding content to the `EditText`, click the UPDATE FILE button. The internal
    storage file will be updated with the content provided, and you will be notified
    upon completion of this update with a toast message. Having updated the file,
    click the VIEW FILE button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f24940a3-9fdf-4e4b-a9cb-23fd51e3750f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content fragment will be displayed with its `TextView` containing the updated
    file content. Though simple, the file-updater application we just created is a
    good example showing how Android applications work with internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: Saving cached files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the event that you would rather not store data permanently, but instead cache
    data within storage, make use of `cacheDir` to open a file that represents a directory
    (within internal storage) where your application should save temporary cache files.
  prefs: []
  type: TYPE_NORMAL
- en: '`cacheDir` returns a `File`. As such, you may make use of all methods put at
    your disposal by the `File` class, such as the `outputStream()`, which returns
    a `FileOutputStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with external storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External storage is used to create and access non-private, shared, world-readable
    files. Shared external storage is supported by all Android devices. The first
    thing you need to start using external storage is its permission.
  prefs: []
  type: TYPE_NORMAL
- en: Getting external storage permission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `READ_EXTERNAL_STORAGE` and `WRITE_EXTERNAL_STORAGE` permissions must be
    acquired by your application before it can make use of external storage APIs.
    `READ_EXTERNAL_STORAGE` is necessary when you only need to read from external
    storage. The `WRITE_EXTERNAL_STORAGE` permission is necessary when your application
    requires the ability to write directly to external storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two permissions can be added with ease to the manifest file, as we have
    seen in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that `WRITE_EXTERNAL_STORAGE` implicitly includes `READ_EXTERNAL_STORAGE`.
    As such, if both permissions are required, it is only necessary to request the
    `WRITE_EXTERNAL_STORAGE` permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Asserting media availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes—for one reason or another, such as the storage device being missing—an
    external storage medium may not be available for access. As a consequence, it
    is important to check the availability of external storage media before attempting
    to make use of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getExternalStorageState()` method should be called in order to check whether
    media are available. You can use the following code snippet to check whether external
    storage is available to be written to in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we retrieve the current state of external storage and then we check
    whether it is in the `MEDIA_MOUNTED` state. If it is in this state, your application
    can write to it. Hence, true is returned by `isExternalStorageWritable()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking whether external storage is readable is similarly easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Your application can read data from external storage if it is in either the
    `MEDIA_MOUNTED` or the `MEDIA_MOUNTED_READ_ONLY` state.
  prefs: []
  type: TYPE_NORMAL
- en: Storing sharable files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files that a user or other applications may need to access later on should be
    stored in a shared public directory. Examples of such directories are the `Pictures/`
    and `Music/` directories.
  prefs: []
  type: TYPE_NORMAL
- en: The `getExternalStoragePulicDirectory()` method should be called by your application
    in order to retrieve a `File` representing a required public directory. The type
    of directory to be retrieved should be passed as the sole argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a function that creates a directory for music to be stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the case where an error occurs when creating the public directory, an appropriate
    message is logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Caching files with external storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scenarios may arise in which you need to cache files with external storage.
    You can open a file representing the external storage directory in which your
    application should save cached files with `externalCacheDir`.
  prefs: []
  type: TYPE_NORMAL
- en: Network storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the storage of data on a remote server. Unlike other means of storage
    we have talked about, this kind of storage utilizes a network connection to store
    and retrieve data that exists on a remote server. You utilized this storage medium
    when you created the messenger Android application in the previous chapter. The
    messenger application relied heavily on a remote server for the storage and retrieval
    of information. The client-server architecture is primarily in play when a remote
    server acts as a data source for a client application. The client sends a request
    for the data required (typically a GET request) to the server via HTTP, and the
    server responds by sending the required data as a response, thus completing the
    HTTP transaction cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a popular **relational database management system** (**RDBMS**) that,
    unlike many RDBMS systems, is not a client-server database engine. Instead, a
    SQLite database is embedded directly into an application.
  prefs: []
  type: TYPE_NORMAL
- en: Android provides full support for SQLite. SQLite databases are accessible throughout
    an Android project by classes. Note that in Android, a database is only accessible
    to the application that created it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the Room persistence library is the recommended method of working
    with SQLite in Android. The first step to work with `room` in Android  is the
    inclusion of its necessary dependencies in a project''s `build.gradle` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Entities can easily be created with the help of `Room`. All entities must be
    annotated with `@Entity`. The following is a simple `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`Room` will create the necessary SQLite table for the `User` entity defined.
    The table will have a name, `user`, and will have four attributes: `id`, `first_name`,
    `surname`, and `phone_number`. The `id` attribute is the primary of the user table
    created. We specified that this should be the case by using the `@PrimaryKey`
    annotation. We specified that the primary keys of each record in the user table
    should be generated by `Room`, by setting `autoGenerate = true` in the `@PrimaryKey`
    annotation. `@ColumnInfo` is an annotation used to specify additional information
    pertaining to a column in a table. Take the following code snippet, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code specifies that there is a `firstName` attribute possessed
    by a `User`. `@ColumnInfo(name ="first_name")` sets the name of the column in
    the user table for the `firstName` attribute to `first_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read and write records to and from a database, you need a **Data
    Access Object** (**DAO**). A DAO allows the performance of database operations
    with the use of annotated methods. The following is a DAO for the `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `@Query` annotation marks a method in a DAO class as a query method. The
    query that will be run when the method is invoked is passed as a value to the
    annotation. Naturally, the queries passed to `@Query` are SQL queries. The writing
    of SQL queries is far too vast a topic to cover here, but it is a good idea to
    take some time to understand how to write them properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Insert` annotation is used to insert data into a table. Other important
    annotations that exist are `@Update` and `@Delete`. They are used to update and
    delete data within a database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, after creating the necessary entities and DAOs, you must define your
    application''s database. In order to do this, you must create a subclass of `RoomDatabase`
    and annotate it with `@Database`. At the minimum, the annotation should include
    a collection of entity class references and a database version number. The following
    is a sample `AppDatabase` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your app database class is created, you can get an instance of the database
    by calling `databaseBuilder()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once you have an instance of your `RoomDatabase`, you can use it to retrieve
    data access objects that in turn can be used to read, write, update, query, and
    delete data from a database.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping with the practice we have adopted so far, let's create a simple application
    that shows how to utilize SQLite with the help of `Room` in Android. The application
    we are about to build will let an app user manually input information pertaining
    to people (users), and view all user information input at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Android project with an empty `MainActivity` set as its launcher
    activity. Add the following dependencies to your application''s `build.gradle`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, apply the `kotlin-kapt` standalone plugin to your `build.gradle`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added the preceding project dependencies, create a `data` and a `ui`
    package within the project source package. In the `ui` package, add the `MainView`,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding `MainView` to the `ui` package, relocate `MainActivity` to the
    `ui` package as well. Now let''s work on the database of our application. As the
    application is going to be storing user information, we need to create a `User`
    entity. Add the following `User` entity to the `data` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a `UserDao` within the `data` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserDao` interface has three methods: `all()`, `findById()`, and `Insert()`.
    The `all()` method returns a `Flowable` containing a list of all users. The `findById()`
    method finds a `User` who has an id matching that which is passed to the method,
    if any, and returns the `User` in a `Flowable`. The `insert()` method is used
    to insert a user as a record into the `user` table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our DAO and entity created, we must create an `AppDatabase`
    class. Add the following to the `data` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We created a `Factory` companion object possessing a single `create()` function
    that has the sole job of creating an `AppDatabase` instance—if not previously
    created—and returning that instance for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an `AppDatabase` is the last thing we need to do pertaining to data.
    Now we must create suitable layouts for our application views. We will make use
    of two fragments in our `MainActivity`. The first will be used to collect input
    for a new user to be created and the second will display the information of all
    created users in a `RecyclerView`. Firstly, modify the `activity_main.xml` layout
    to contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LinearLayout` in `activity_main.xml` will contain the fragments of `MainActivity`.
    Add a `fragment_create_user.xml` file to the `resource` layout directory with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a `fragment_list_users.xml` layout resource with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fragment_list_users.xml` file has a `RecyclerView` that will display the
    information of each user saved to the database. We must create a view holder layout
    resource item for this `RecyclerView`. We''ll call this layout file `vh_user.xml`.
    Create a new `vh_user.xml` resource file and add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have expected, we must add some string and dimension resources
    to our project. Open your application''s `strings.xml` layout file and add the
    following string resources to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the following dimension resources in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It is now time to work on `MainActivity`. As we previously established, we will
    be using two distinct fragments in our `MainActivity` class. The first fragment
    enables a person to save the data of an individual to a SQL database, and the
    next will allow a user to view the information of people that has been saved in
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a `CreateUserFragment` first. Add the following fragment class
    to `MainActivity` (located in the `MainActivity.kt`) .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method validates the inputs submitted in the create a user form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function shows toast message indicating the user successfully
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We have worked with fragments numerous times already. As such, our focus of
    explanation will be on the parts of this fragment that work with the `AppDatabase`.
    In `setupInstances()`, we set up references to the `AppDatabase` and `UserDao`.
    We retrieved an instance of the `AppDatabase` by invoking the `create()` function
    of the `Factory` companion object of the `AppDatabase`. An instance of `UserDao`
    was easily retrieved by calling the `appDatabase.userDao()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the `onClick()` method of the fragment class. When the submit
    button is clicked, the submitted user information will be checked for validity.
    An appropriate error message is shown if any of the input is invalid. Once it
    is asserted that all input are valid, a new `User` object containing the submitted
    user information is created and saved to the database. This is done in the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the `ListUsersFragment` is similarly easy to achieve.  Add the following
    `ListUsersFragment` to `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind the user recycler view instance to its layout element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get all users in the user table of the database. And upon successful
    retrieval of the list, add all user objects in the list to users `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`UsersAdapter` in the `ListUsersFragment` uses an instance of `UserDao` to
    populate its user list. This population is done within `populateUsers()`. When
    `populateUsers()` is invoked, a list of all users that have been saved by the
    application is retrieved by invoking `userDao.all()`. Upon successful retrieval
    of all users, all `User` objects are added to the users `ArrayList` of `UserAdapter`.
    The adapter is then notified of the change in data in its dataset by the call
    to `notifyDataSetChanged()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainActivity` itself requires some minor additions. Your completed `MainActivity`
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is called when the user click the back button, if the
    fragments back stack has one or more fragments, the fragments manager pops the
    fragment and displays it to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We must now run the application to see if it works as we would like. Build
    and run the project on a device of your choice. Once the project launches, you
    will come face to face with the user creation form. Go ahead and input some user
    information in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80429a28-c8b2-46b5-8299-978decc32b91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have input valid information into the create user form, click the
    Submit button to save the user to the application''s SQLite database. You will
    be notified once the user has been saved successfully. Having been notified, click
    VIEW USERS to see the information of the user you just saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c81ed510-be58-4646-b291-b153235ddf8f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can create and view information for as many users as you like. There's no
    upper limit to the amount of information the database can contain!
  prefs: []
  type: TYPE_NORMAL
- en: Working with content providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spoke briefly about content providers as Android components in [Chapter 2](kt-prog-ex_ch02.html),
    *Building an Android Application - Tetris*. While doing so, we established the
    fact that content providers help an application control access to data resources
    stored either within the application or within another app. In addition, we established
    that a content provider facilitates the sharing of data with another application
    via an exposed application programming interface.
  prefs: []
  type: TYPE_NORMAL
- en: A content provider behaves in a way that is similar to the behavior of a database.
    A content provider permits the insertion, deletion, editing, updating, and querying
    of content. These abilities are permitted by the use of methods such as `insert()`,
    `update()`, `delete()`, and `query()`. In many cases, data controlled by a content
    provider exists in a SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A content provider for your application can be created in five easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a content provider class that extends `ContentProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a content URI address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a datasource that the content provider will interact with.  This datasource
    is usually in the form of a SQLite database. In cases where SQLite is the datasource,
    you will need to create a `SQLiteOpenHelper` and override its `onCreate()` in
    order to create the database that will be controlled by the content provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the required content provider methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the content provider in your project's manifest file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In all, there are six  methods that must be implemented by a content provider.
    These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreate()`: This method is called to initialize the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query()`:This method returns data to the caller via a `Cursor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert()`: This method is called to insert new data into the content provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete()`: This method is called to delete data from the content provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`:This method is called to update data in the content provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getType()`: This method returns the MIME type of data in the content provider
    when called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to ensure you fully understand the workings of a content provider,
    let's create a quick example project that utilizes a content provider and a SQLite
    database. Create a new Android studio project named `ContentProvider` and add
    an empty `MainActivity` to it upon creation. Similar to all other applications
    created in this chapter, this example is simple in nature. The application allows
    a user to enter the details of a product (a product name and its manufacturer)
    in text fields and save them to a SQLite database. The user can then view the information
    of products that they previously saved with the click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `activity_main.xml` to contain the following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the preceding modifications, add the following string resource
    to your project''s `strings.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a `ProductProvider.kt` file in the `com.example.contentproviderexample`
    package and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`SQLiteOpenHelper` class that creates the content provider''s database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `SQLiteOpenHelper` to get a writable database; a new database
    is created if one does not already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added a suitable `ProductProvider` to provide content pertaining to
    saved products, we must register the new component in the `AndroidManifest` file.
    We have added the provider to the manifest file in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s modify `MainActivity` to exploit this newly registered provider.
    Modify `MainActivity.kt` to contain the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is called to show products that exist in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The two methods you should focus your attention on in the preceding code block
    are `addProduct()` and `showProducts()`. `addProduct()` stores the product data
    in a `contentValues` instance and then inserts this data into the SQLite database
    with the help of the `ProductProvider` by invoking `contentResolver.insert(ProductProvider.CONTENT_URI,
    contentValues)`. `showProducts()` uses a `Cursor` to display the product information
    stored in the database in toast messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand what''s going on, let''s run the application. Build
    and run the application as you have done thus far and wait until the application
    installs and starts. You will be taken straight to `MainActivity` and presented
    with a form to input the name and manufacturer of a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/385353fc-a1c3-49e3-943c-5fc3f1197780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon inputting valid product information, click ADD PRODUCT. The product will
    be inserted as a new record in the products table of the application''s SQLite
    database. Add a few more products with the form and click SHOW PRODUCTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55aa67c9-45b5-4e78-99c6-7457679229c5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Doing this will lead to the invocation of `showProducts()` in `MainActivity`.
    All product records will be fetched and displayed in toast messages one after
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: That is as much as we need to implement in a sample application to demonstrate
    how content providers work. Try to make the application even more awesome by implementing
    functionality for updating and deleting product records. Doing so will be good
    practice!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived headfirst into the various mediums of data storage
    that the Android application framework puts at our disposal. We took a look at
    how we can use internal storage and external storage to store data in private
    and public files. In addition, we learned how to work with cache files with the
    help of both internal and external storage.
  prefs: []
  type: TYPE_NORMAL
- en: Further into the chapter, we learned about the SQLite RDBMS and explored how
    we can make use of it in our Android applications. We learned how to utilize `Room`
    to retrieve and store data in a SQLite database and then went a step further by
    exploring how to use content providers to control access to data with a SQLite
    database as an underlying datastore.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will conclude our Android application framework exploration
    by learning how to secure and deploy an Android application.
  prefs: []
  type: TYPE_NORMAL
