<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Building a Repository Browser" id="1FLS41-d7e55eb5242648e89c396442afe4f84b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Building a Repository Browser</h1></div></div></div><p class="calibre8">Having covered how to integrate the components necessary to build an application, this chapter will create a repository browser that allows user repositories to be displayed using the GitHub API.</p><p class="calibre8">This chapter will present the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An overview of the GitHub API</li><li class="listitem">Talking to the GitHub API with Swift</li><li class="listitem">Creating a repository browser</li><li class="listitem">Maintaining selection between view controllers</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Building a Repository Browser" id="1FLS41-d7e55eb5242648e89c396442afe4f84b">
<div class="book" title="An overview of the GitHub API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec43" class="calibre1"/>An overview of the GitHub API</h1></div></div></div><p class="calibre8">The GitHub API<a id="id343" class="calibre1"/> provides<a id="id344" class="calibre1"/> a REST-based interface using JSON to return information about users and repositories. Version 3 of the API is documented at <a class="calibre1" href="https://developer.github.com/v3/">https://developer.github.com/v3/</a> and is the version used in this book.</p><div class="note" title="Note"><h3 class="title2"><a id="tip67" class="calibre1"/>Tip</h3><p class="calibre8">The API is rate limited; at the time of writing, anonymous requests can be made up to sixty times per hour, while logged in users have a higher limit. The code repository for this book has sample responses that can be used for testing and development purposes.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Building a Repository Browser" id="1FLS41-d7e55eb5242648e89c396442afe4f84b">
<div class="book" title="An overview of the GitHub API">
<div class="book" title="Root endpoint"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec90" class="calibre1"/>Root endpoint</h2></div></div></div><p class="calibre8">The main<a id="id345" class="calibre1"/> entry point to GitHub is the <span class="strong"><em class="calibre11">root endpoint</em></span>. For the main GitHub site, this is <a class="calibre1" href="https://api.github.com">https://api.github.com</a>, and for GitHub Enterprise installations, it will be of the form <code class="literal">https://hostname.example.org/api/v3/</code> along with user credentials. The endpoint provides a collection of URLs that can be used to find specific resources:</p><div class="note"><pre class="programlisting">{
 ...
  "issue_search_url": "https://api.github.com/search/issues?q={query}{&amp;page,per_page,sort,order}",
  "issues_url": "https://api.github.com/issues",
  "repository_url": "https://api.github.com/repos/{owner}/{repo}","user_url": "https://api.github.com/users/{user}"  "user_repositories_url": "https://api.github.com/users/{user}/repos{?type,page,per_page,sort}", }</pre></div><p class="calibre8">The<a id="id346" class="calibre1"/> services are <span class="strong"><em class="calibre11">URI templates</em></span>. Text in braces <code class="literal">{}</code> is replaced on demand with the values of parameters; text that starts with <code class="literal">{?a,b,c}</code> is expanded to form <code class="literal">?a=&amp;b=&amp;c=</code> if present, and is missing otherwise. For example, with a <code class="literal">user</code> of <code class="literal">alblue</code>, the <code class="literal">user_url</code> of the user resource at <code class="literal">https://api.github.com/users/{user}</code> becomes <code class="literal">https://api.github.com/users/alblue</code>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Building a Repository Browser" id="1FLS41-d7e55eb5242648e89c396442afe4f84b">
<div class="book" title="An overview of the GitHub API">
<div class="book" title="User resource"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec91" class="calibre1"/>User resource</h2></div></div></div><p class="calibre8">The <a id="id347" class="calibre1"/>user resource for a specific user contains information about their repositories (<code class="literal">repos_url</code>), name, and other information, such as a location and blog (if provided). In addition, the <code class="literal">avatar_url</code> provides a URL to an image that can be used to display the user's avatar. For example, <code class="literal">https://api.github.com/users/alblue</code> contains:</p><div class="note"><pre class="programlisting">{
  ...
  "login": "alblue",
  "avatar_url": "https://avatars.githubusercontent.com/u/76791?v=2",
  "repos_url": "https://api.github.com/users/alblue/repos",
  "name": "Alex Blewitt",
  "blog": "http://alblue.bandlem.com",
  "location": "Milton Keynes, UK",
  ...
}</pre></div><p class="calibre8">The <code class="literal">repos_url</code> link can be used to find the user's repositories. This is what is reported at the root endpoint as the <code class="literal">user_repositories_url</code> with the <code class="literal">{user}</code> already replaced with the username.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Building a Repository Browser" id="1FLS41-d7e55eb5242648e89c396442afe4f84b">
<div class="book" title="An overview of the GitHub API">
<div class="book" title="Repositories resource"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec92" class="calibre1"/>Repositories resource</h2></div></div></div><p class="calibre8">Repositories for<a id="id348" class="calibre1"/> a user can be accessed via the <code class="literal">repos_url</code> or <code class="literal">user_repositories_url</code> references. This returns an array of JSON objects containing information, such as:</p><div class="note"><pre class="programlisting">[{ 
  "name": "com.packtpub.e4.swift.essentials",
  "html_url":
    "https://github.com/alblue/com.packtpub.swift.essentials",
  "clone_url":
    "https://github.com/alblue/com.packtpub.swift.essentials.git",
  "description": "Swift Essentials",
},{
  "name": "com.packtpub.e4",
  "html_url":
    "https://github.com/alblue/com.packtpub.e4",
  "clone_url":
    "https://github.com/alblue/com.packtpub.e4.git",
  "description":
    "Eclipse Plugin Development by Example: Beginners Guide",
},{
  "name": "com.packtpub.e4.advanced",
  "html_url":
    "https://github.com/alblue/com.packtpub.e4.advanced",
  "clone_url":
    "https://github.com/alblue/com.packtpub.e4.advanced.git",
  "description":
    "Advanced Eclipse plug-in development",
}...]</pre></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Repository browser project"><div class="book" id="1GKCM2-d7e55eb5242648e89c396442afe4f84b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec44" class="calibre1"/>Repository browser project</h1></div></div></div><p class="calibre8">The <code class="literal">RepositoryBrowser</code> client <a id="id349" class="calibre1"/>will be created from the <span class="strong"><strong class="calibre2">Master Detail</strong></span> template. This sets up an empty application that can be used on a large device with a split view controller or a navigator view controller on a small device. In addition to this, actions to add entries are also created.</p><p class="calibre8">To create a project with tests, ensure that the <span class="strong"><strong class="calibre2">Include Unit Tests</strong></span> option is selected when creating the project:</p><div class="mediaobject"><img src="../images/00090.jpeg" alt="Repository browser project" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">To build the APIs necessary to display content, several utility classes are needed:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="literal">URITemplate</code> class <a id="id350" class="calibre1"/>processes URI templates with a set of key/value pairs</li><li class="listitem">The <code class="literal">Threads</code> class <a id="id351" class="calibre1"/>allows functions to be run in the background or in the main thread</li><li class="listitem">The <code class="literal">NSURLExtensions</code> class <a id="id352" class="calibre1"/>provides easy parsing of JSON objects from a URL</li><li class="listitem">The <code class="literal">DictionaryExtensions</code> class <a id="id353" class="calibre1"/>provides a means of creating a Swift dictionary from a JSON object</li><li class="listitem">The <code class="literal">GitHubAPI</code> class <a id="id354" class="calibre1"/>provides access to the GitHub remote API</li></ul></div></div>

<div class="book" title="Repository browser project">
<div class="book" title="URI templates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec93" class="calibre1"/>URI templates</h2></div></div></div><p class="calibre8">URI templates <a id="id355" class="calibre1"/>are defined in RFC 6570 at <a class="calibre1" href="https://tools.ietf.org/html/rfc6570">https://tools.ietf.org/html/rfc6570</a>. They can be used to replace sequences of text surrounded by <code class="literal">{}</code> in a URI. Although GitHub's API uses optional values <code class="literal">{?...}</code>, the example client presented in this chapter will not need to use these, and so, they can be ignored in this implementation.</p><p class="calibre8">The<a id="id356" class="calibre1"/> template class replaces the parameters with values from a dictionary. To create the API, it is useful to write a test case first, following test driven development. A test case class can be created by navigating to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">New</strong></span> | <span class="strong"><strong class="calibre2">File…</strong></span> | <span class="strong"><strong class="calibre2">iOS</strong></span> | <span class="strong"><strong class="calibre2">Source</strong></span> | <span class="strong"><strong class="calibre2">Unit Test Case Class</strong></span> and creating a subclass of <code class="literal">XCTestCase</code> in Swift. The test code will look like:</p><div class="note"><pre class="programlisting">import XCTest
class URITemplateTests: XCTestCase {
  func testURITemplate() {
    let template = "http://example.com/{blah}/blah/{?blah}"
    let replacement = URITemplate.replace(
     template,values: ["blah":"foo"])
    XCTAssertEqual("http://example.com/foo/blah/",
     replacement,"Template replacement")
  }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip68" class="calibre1"/>Tip</h3><p class="calibre8">Don't forget to ensure that the <code class="literal">URITemplateTests.swift</code> file is added to the necessary test targets.</p></div><p class="calibre8">The <code class="literal">replace</code> function requires string processing. Although the function can be a class function or an extension on <code class="literal">String</code>, having it as a separate class makes testing easier. The function signature looks like:</p><div class="note"><pre class="programlisting">import Foundation
class URITemplate {
  class func replace(template:String, values:[String:String])
   -&gt; String {
    var replacement = template
    while true {
      // replace until no more {…} are present
    }
    return replacement
  }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip69" class="calibre1"/>Tip</h3><p class="calibre8">Make sure that the <code class="literal">URITemplate</code> class is added to the test target as well; otherwise, the test script will not compile.</p></div><p class="calibre8">The parameters are matched using a regular expression, such as <code class="literal">{[^}]}</code>. To search or access this from a string involves a <code class="literal">Range</code> of <code class="literal">String.Index</code> values. These are like integer indexes into the string, but instead of referring to a character by its byte offset, the index is an abstract representation (some character encodings, such as UTF8, use multiple bytes to represent a single character).</p><p class="calibre8">The <code class="literal">rangeOfString</code> method<a id="id357" class="calibre1"/> takes a string or regular expression and returns a range if there is a match present (or <code class="literal">nil</code> if there isn't). This can be used to detect whether a pattern is present or to break out of the <code class="literal">while</code> loop:</p><div class="note"><pre class="programlisting">// replace until no more {…} are present
if let parameterRange = replacement.rangeOfString(
  "\\{[^}]*\\}",
  options: NSStringCompareOptions.RegularExpressionSearch) {
  // perform a replacement of parameterRange
} else {
  break
}</pre></div><p class="calibre8">The <code class="literal">parameterRange</code> contains a <code class="literal">start</code> and <code class="literal">end</code> index that represent the locations of the <code class="literal">{</code> and <code class="literal">}</code> characters. The value of the parameter can be extracted with <code class="literal">replacement.substringWithRange(parameterRange)</code>. If it starts with <code class="literal">{?</code> it is replaced with an empty string:</p><div class="note"><pre class="programlisting">// perform a replacement of parameterRange
var value:String
let parameter = replacement.substringWithRange(parameterRange)
if parameter.hasPrefix("{?") {
  value = ""
} else {
  // substitute with real replacement
}
replacement.replaceRange(parameterRange, with: value)</pre></div><p class="calibre8">Finally, if the replacement is of the form <code class="literal">{user}</code>, then the value of <code class="literal">user</code> is acquired from the dictionary and used as the replacement value. To get the name of the parameter, <code class="literal">startIndex</code> has to be advanced to the <code class="literal">successor</code>, and <code class="literal">endIndex</code> has to be reversed to the <code class="literal">predecessor</code> to account for the <code class="literal">{</code> and <code class="literal">}</code> characters:</p><div class="note"><pre class="programlisting">// substitute with real replacement
let start = parameterRange.startIndex.successor()
let end = parameterRange.endIndex.predecessor()
let name = replacement.substringWithRange(
 Range&lt;String.Index&gt;(start:start,end:end))
value = values[name] ?? ""</pre></div><p class="calibre8">Now when the test is run by navigating to <span class="strong"><strong class="calibre2">Product</strong></span> | <span class="strong"><strong class="calibre2">Test</strong></span> or by pressing <span class="strong"><em class="calibre11">Command + U</em></span>, the string replacement will pass.</p><div class="note" title="Note"><h3 class="title2"><a id="note55" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">??</code> is an optional test that is used to return the first argument if it is present, and the second argument if it is <code class="literal">nil</code>.</p></div></div></div>

<div class="book" title="Repository browser project">
<div class="book" title="Background threading"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec94" class="calibre1"/>Background threading</h2></div></div></div><p class="calibre8">Background threading<a id="id358" class="calibre1"/> allows functions to be trivially launched on the UI thread or on a background thread as appropriate. This was explained in <a class="calibre1" title="Chapter 6. Parsing Networked Data" href="part0045_split_000.html#1AT9A2-d7e55eb5242648e89c396442afe4f84b">Chapter 6</a>, <span class="strong"><em class="calibre11">Parsing Networked Data</em></span>, in the <span class="strong"><em class="calibre11">Networking and user interface</em></span> section. Add the following as <code class="literal">Threads.swift</code>:</p><div class="note"><pre class="programlisting">import Foundation
class Threads {
  class func runOnBackgroundThread(fn:()-&gt;()) {
    dispatch_async(dispatch_get_global_queue(
     DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),fn)
  }
  class func runOnUIThread(fn:()-&gt;()) {
    if NSMainThread.isMainThread() {
      fn()
    } else {
      dispatch_async(dispatch_get_main_queue(), fn)
    }
  }
}</pre></div><p class="calibre8">The <code class="literal">Threads</code> class can be tested with the following test case:</p><div class="note"><pre class="programlisting">import XCTest
class ThreadsTest: XCTestCase {
  func testThreads() {
    Threads.runOnBackgroundThread {
      XCTAssertFalse(NSThread.isMainThread(), 
       "Running on background thread")
      Threads.runOnUIThread {
        XCTAssertTrue(NSThread.isMainThread(),
         "Running on UI thread")
      }
    }
  }
}</pre></div><p class="calibre8">When the tests are run with <span class="strong"><em class="calibre11">Command</em></span> + <span class="strong"><em class="calibre11">U</em></span>, the tests should pass.</p></div></div>

<div class="book" title="Repository browser project">
<div class="book" title="Parsing JSON dictionaries"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec95" class="calibre1"/>Parsing JSON dictionaries</h2></div></div></div><p class="calibre8">As <a id="id359" class="calibre1"/>many network responses are returned in JSON format and to make JSON parsing easier, extensions can be added to the <code class="literal">NSURL</code> class to facilitate the acquiring and parsing of content that is loaded from network locations. Instead of designing a synchronous extension that blocks until data is available, using a callback function is best practice. Create a file <code class="literal">NSURLExtensions.swift</code> with the following content:</p><div class="note"><pre class="programlisting">import Foundation
extension NSURL {
  func withJSONDictionary(fn:[String:String] -&gt; ()) {
    let session = NSURLSession.sharedSession()
    session.dataTaskWithURL(self) {
      data,response,error -&gt; () in
      if let json = try? NSJSONSerialization.JSONObjectWithData(
        data!, options: .AllowFragments) as? [String:AnyObject] {
        fn(json!) // will give a compile time error
      } else {
        fn([String:String]())
      }
    }.resume()
  }
}</pre></div><p class="calibre8">This provides an extension for an <code class="literal">NSURL</code> to provide a JSON dictionary. However, the data type returned from the <code class="literal">JSONObjectWithData</code> method is <code class="literal">[String:AnyObject]</code>, not <code class="literal">[String:String]</code>. Although it may be expected that it could just be cast to the right type, the <code class="literal">as</code> will perform a test, and if there are mixed values (such as a number or a <code class="literal">nil</code>), then the entire object will be considered invalid. Instead, the JSON data structure must be converted to a <code class="literal">[String:String]</code> type. Add the following as a standalone function to <code class="literal">NSURLExtensions.swift</code>:</p><div class="note"><pre class="programlisting">func toStringString(dict:[String:AnyObject]) -&gt; [String:String] {
  var result:[String:String] = [:]
  for (key,value) in dict {
    if let valueString = value as? String {
      result[key] = valueString
    } else {
      result[key] = "\(value)"
    }
  }
  return result
}</pre></div><p class="calibre8">This can be used to convert the <code class="literal">[String:AnyObject]</code> in the JSON function:</p><div class="note"><pre class="programlisting">fn(toStringString(json!)) // fixes compile time error</pre></div><p class="calibre8">The function can be tested with a test class using the <code class="literal">data:</code> protocol by passing in a <span class="strong"><em class="calibre11">base64</em></span> encoded <a id="id360" class="calibre1"/>string representing the JSON data. To create a <code class="literal">base64</code> representation, create a string, convert it to a UTF8 data object and then convert it back to a string representation with a <code class="literal">data:</code> prefix:</p><div class="note"><pre class="programlisting">import XCTest
class NSURLExtensionsTest: XCTestCase {
  func testNSURLJSON() {
    let json = "{\"test\":\"value\"}".
     dataUsingEncoding(NSUTF8StringEncoding)!
    let base64 = json.base64EncodedDataWithOptions(     .EncodingEndLineWithLineFeed)
    let data = String(data: base64, 
     encoding: NSUTF8StringEncoding)!
    let dataURL = NSURL(string:"data:text/plain;base64,\(data)")!
    dataURL.withJSONDictionary {
      dict in
      XCTAssertEqual(dict["test"] ?? "", "value",
       "Value is as expected")
    }
    sleep(1)
  }
}</pre></div><p class="calibre8">Please note that the <code class="literal">sleep(1)</code> is required as parsing the response has to happen in the background thread and, therefore, may not be immediately available. By adding a delay to the function it gives a chance for the assertion to be executed.</p></div></div>

<div class="book" title="Repository browser project">
<div class="book" title="Parsing JSON arrays of dictionaries"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec96" class="calibre1"/>Parsing JSON arrays of dictionaries</h2></div></div></div><p class="calibre8">A similar <a id="id361" class="calibre1"/>approach can be used to parse arrays of dictionaries (such as those that are returned by the list repositories resource). The differences here are the type signatures (which have an extra <code class="literal">[]</code> to represent the array), and the fact that a <code class="literal">map</code> is being used to process the elements in the list:</p><div class="note"><pre class="programlisting">func withJSONArrayOfDictionary(fn:[[String:String]] -&gt; ()) {
  … 
  if let json = try? NSJSONSerialization.JSONObjectWithData(
   data, options: .AllowFragments) as? <span class="strong"><strong class="calibre2">[[String:AnyObject]]</strong></span> {
    <span class="strong"><strong class="calibre2">fn(json!.map(toStringString))</strong></span>
  } else {
    <span class="strong"><strong class="calibre2">fn([[String:String]]())</strong></span>
  }</pre></div><p class="calibre8">The test can be extended as well:</p><div class="note"><pre class="programlisting">let json = <span class="strong"><strong class="calibre2">"[{\"test\":\"value\"}]"</strong></span>.
 dataUsingEncoding(NSUTF8StringEncoding)!
…
dataURL.withJSONArrayOfDictionary {
  dict in XCTAssertEqual(<span class="strong"><strong class="calibre2">dict[0]["test"]</strong></span> ?? "", "value",
 "Value is as expected")
}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating the client" id="1HIT81-d7e55eb5242648e89c396442afe4f84b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec45" class="calibre1"/>Creating the client</h1></div></div></div><p class="calibre8">Now that <a id="id362" class="calibre1"/>the utilities are complete, the GitHub client API can be created. Once that is complete, it can be integrated with the user interface.</p></div>

<div class="book" title="Creating the client" id="1HIT81-d7e55eb5242648e89c396442afe4f84b">
<div class="book" title="Talking to the GitHub API"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec97" class="calibre1"/>Talking to the GitHub API</h2></div></div></div><p class="calibre8">A Swift class <a id="id363" class="calibre1"/>will be created to talk to the GitHub API. This will connect to the root endpoint host and download the JSON for the service URLs so that subsequent network connections can be made.</p><p class="calibre8">To ensure that network requests are not repeated, an <code class="literal">NSCache</code> will be used to save the responses. This will automatically be emptied when the application is under memory pressure:</p><div class="note"><pre class="programlisting">import Foundation
class GitHubAPI {
  let base:NSURL
  let services:[String:String]
  let cache = NSCache()
  class func connect() -&gt; GitHubAPI? {
    return connect("https://api.github.com")
  }
  class func connect(url:String) -&gt; GitHubAPI? {
    if let nsurl = NSURL(string:url) {
      return connect(nsurl)
    } else {
      return nil
    }
  }
  class func connect(url:NSURL) -&gt; GitHubAPI? {
    if let data = NSData(contentsOfURL:url) {
      if let json = try? NSJSONSerialization.JSONObjectWithData(
       data,options:.AllowFragments) as? [String:String] {
        return GitHubAPI(url,json!)
      } else {
       return nil
      }
    } else {
      return nil
    }
  }
  init(_ base:NSURL, _ services:[String:String]) {
    self.base = base
    self.services = services
  }
}</pre></div><p class="calibre8">This can be<a id="id364" class="calibre1"/> tested by saving the response from the main GitHub API site at <a class="calibre1" href="https://api.github.com">https://api.github.com</a> into an <code class="literal">api/index.json</code> file by creating an <code class="literal">api</code> directory in the root level of the project and running <code class="literal">curl https://api.github.com &gt; api/index.json</code> from a Terminal prompt. Inside Xcode, add the <code class="literal">api</code> directory to the project by navigating to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">Add Files to Project…</strong></span> or by pressing <span class="strong"><em class="calibre11">Command</em></span> + <span class="strong"><em class="calibre11">Option</em></span> + <span class="strong"><em class="calibre11">A</em></span>, and ensure it is associated with the test target.</p><p class="calibre8">It can then be accessed with an <code class="literal">NSBundle</code>:</p><div class="note"><pre class="programlisting">import XCTest
class GitHubAPITests: XCTestCase{
  func testApi() {
    <span class="strong"><strong class="calibre2">let bundle = NSBundle(forClass:GitHubAPITests.self)</strong></span>
<span class="strong"><strong class="calibre2">    if let url = bundle.URLForResource("api/index",</strong></span>
<span class="strong"><strong class="calibre2">     withExtension:"json") {</strong></span>
      if let api = GitHubAPI.connect(url) {
        XCTAssertTrue(true,"Created API \(api)")
      } else {
        XCTAssertFalse(true,"Failed to parse \(url)")
      }
    } else {
      XCTAssertFalse(true,"Failed to find sample API")
    }
  }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip70" class="calibre1"/>Tip</h3><p class="calibre8">The dummy API should not be part of the main application's target, but rather of the test target. As a result, instead of using <code class="literal">NSBundle.mainBundle</code> to acquire the application's bundle, <code class="literal">NSBundle(forClass)</code> is used.</p></div></div></div>

<div class="book" title="Creating the client" id="1HIT81-d7e55eb5242648e89c396442afe4f84b">
<div class="book" title="Returning repositories for a user"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec98" class="calibre1"/>Returning repositories for a user</h2></div></div></div><p class="calibre8">The APIs returned<a id="id365" class="calibre1"/> from the services lookup include <code class="literal">user_repositories_url</code>, which is a template that can be instantiated with a specific user. It is possible to add a method <code class="literal">getURLForUserRepos</code> to the <code class="literal">GitHubAPI</code> class that will return the URL of the user's repositories. As it will be called frequently, the results should be cached using an <code class="literal">NSCache</code>:</p><div class="note"><pre class="programlisting">func getURLForUserRepos(user:String) -&gt; NSURL {
  let key = "r:\(user)"
  if let url = cache.objectForKey(key) as? NSURL {
    return url
  } else {
    let userRepositoriesURL = services["user_repositories_url"]!
    let userRepositoryURL = URITemplate.replace(
     userRepositoriesURL, values:["user":user])
    let url = NSURL(string:userRepositoryURL, relativeToURL:base)!
    cache.setObject(url, forKey:key)
    return url
  }
}</pre></div><p class="calibre8">Once the URL is known, data can be parsed as an array of JSON objects using an asynchronous callback function to notify when the data is ready:</p><div class="note"><pre class="programlisting">func withUserRepos(user:String, fn:([[String:String]]) -&gt; ()) {
  let key = "repos:\(user)"
  if let repos = cache.objectForKey(key) as? [[String:String]] {
    fn(repos)
  } else {
    let url = getURLForUserRepos(user)
    url.withJSONArrayOfDictionary {
      repos in
      self.cache.setObject(repos,forKey:key)
      fn(repos)
    }
  }
}</pre></div><p class="calibre8">This can be tested using a simple addition to the <code class="literal">GitHubAPITests</code> class:</p><div class="note"><pre class="programlisting">api.withUserRepos("alblue") {
  array in
  XCTAssertEqual(24,array.count,"Number of repos")
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note56" class="calibre1"/>Note</h3><p class="calibre8">The sample data contains 24 repositories in the following file, but the GitHub API may contain a different value for this user in the future:</p><p class="calibre8">
<a class="calibre1" href="https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/RepositoryBrowser/api/users/alblue/repos.json">https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/RepositoryBrowser/api/users/alblue/repos.json</a>
</p></div></div></div>

<div class="book" title="Creating the client" id="1HIT81-d7e55eb5242648e89c396442afe4f84b">
<div class="book" title="Accessing data through the AppDelegate"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec99" class="calibre1"/>Accessing data through the AppDelegate</h2></div></div></div><p class="calibre8">When <a id="id366" class="calibre1"/>building an iOS application that manages data, deciding where to declare the variable is the first decision that has to be made. When implementing a view controller, it is common for view-specific data to be associated with that class; but if the data needs to be used across multiple view controllers, there is more choice.</p><p class="calibre8">A common approach is to wrap everything into a <span class="strong"><em class="calibre11">singleton</em></span>, which is an object that is instantiated once. This is typically achieved with a <code class="literal">private var</code> in the implementation class, with a <code class="literal">class func</code> that returns (or instantiates on demand) the singleton.</p><div class="note" title="Note"><h3 class="title2"><a id="tip71" class="calibre1"/>Tip</h3><p class="calibre8">The Swift <code class="literal">private</code> keyword ensures that the variable is only visible in the current source file. The default visibility is <code class="literal">internal</code>, which means that code is only visible in the current module; the <code class="literal">public</code> keyword means that it is visible outside of the module as well.</p></div><p class="calibre8">Another approach is to use the <code class="literal">AppDelegate</code> itself. This is in effect already a singleton that can be accessed with <code class="literal">UIApplication.sharedApplication().delegate</code>, and is set up prior to any other object accessing it.</p><div class="note" title="Note"><h3 class="title2"><a id="tip72" class="calibre1"/>Tip</h3><p class="calibre8">The AppDelegate should not be overused to store data. Instead of adding too many properties, consider creating a separate class or struct to hold the values.</p></div><p class="calibre8">The <code class="literal">AppDelegate</code> will be used to store the reference to the <code class="literal">GitHubAPI</code>, which could use a preference store or other external means to define what instance to connect to, along with the list of users and a cache of repositories:</p><div class="note"><pre class="programlisting">class AppDelegate {
  var api:GitHubAPI!
  var users:[String] = []
  var repos:[String:[[String:String]]] = [:]
  func application(application: UIApplication,
   didFinishLaunchingWithOptions: [NSObject: AnyObject]?)
   -&gt; Bool {
    api = GitHubAPI.connect()
    users = ["alblue"]
    return true
  }
}</pre></div><p class="calibre8">To facilitate loading<a id="id367" class="calibre1"/> repositories from view controllers, a function can be added to <code class="literal">AppDelegate</code> to provide a list of repositories for a given user:</p><div class="note"><pre class="programlisting">func loadRepoNamesFor(user:String, fn:([[String:String]])-&gt;()) {
  repos[user] = []
  api.withUserRepos(user) {
    results in
    self.repos[user] = results
    fn(results)
  }
}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Accessing repositories from view controllers"><div class="book" id="1IHDQ2-d7e55eb5242648e89c396442afe4f84b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec46" class="calibre1"/>Accessing repositories from view controllers</h1></div></div></div><p class="calibre8">In <a id="id368" class="calibre1"/>the <code class="literal">MasterViewController</code> (created from the <span class="strong"><strong class="calibre2">Master Detail</strong></span> template or a new subclass of a <code class="literal">UITableViewController</code>), define an instance variable, <code class="literal">AppDelegate</code>, which is assigned in the <code class="literal">viewDidLoad</code> method:</p><div class="note"><pre class="programlisting">class MasterViewController:UITableViewController {
  var app:AppDelegate!
  override func viewDidLoad() {
    app = UIApplication.sharedApplication().delegate
     as? AppDelegate
    …
  }
}</pre></div><p class="calibre8">The table view controller provides data in a number of sections and rows. The <code class="literal">numberOfSections</code> method will return the number of users with the section title being the username (indexed by the users list):</p><div class="note"><pre class="programlisting">override func numberOfSectionsInTableView(tableView: UITableView)
 -&gt; Int {
  return app.users.count
}
override func tableView(tableView: UITableView,
 titleForHeaderInSection section: Int) -&gt; String? {
  return app.users[section]
}</pre></div><p class="calibre8">The <code class="literal">numberOfRowsInSection</code> function is called to determine how many rows are present in each section. If the<a id="id369" class="calibre1"/> number is not known, <code class="literal">0</code> can be returned while running a background query to find the right answer:</p><div class="note"><pre class="programlisting">override func tableView(tableView: UITableView,
 numberOfRowsInSection section: Int) -&gt; Int {
  let user = app.users[section]
  if let repos = app.repos[user] {
    return repos.count
  } else {
    app.loadRepoNamesFor(user) { _ in
      Threads.runOnUIThread {
        tableView.reloadSections(
         NSIndexSet(index: section),
         withRowAnimation: .Automatic)
      }
    }
    return 0
  }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip73" class="calibre1"/>Tip</h3><p class="calibre8">Remember to reload the section on the UI thread; otherwise, the updates won't display correctly.</p></div><p class="calibre8">Finally, the repository name needs to be shown in the value of the cell. If a default <code class="literal">UITableViewCell</code> is used, then the value can be set on the <code class="literal">textLabel</code>; if it is loaded from a storyboard prototype cell, then the content can be accessed appropriately using tags:</p><div class="note"><pre class="programlisting">override func tableView(tableView: UITableView,
 cellForRowAtIndexPath indexPath: NSIndexPath)
 -&gt; UITableViewCell {
  let cell = tableView.dequeueReusableCellWithIdentifier(
   "Cell", forIndexPath: indexPath)
  let user = app.users[indexPath.section]
  let repo = app.repos[user]![indexPath.row]
  cell.textLabel!.text = repo["name"] ?? ""
  return cell
}</pre></div><p class="calibre8">When the application is run, the list of repositories will be displayed, grouped by the user:</p><div class="mediaobject"><img src="../images/00091.jpeg" alt="Accessing repositories from view controllers" class="calibre9"/></div><p class="calibre10"> </p></div>

<div class="book" title="Accessing repositories from view controllers">
<div class="book" title="Adding users"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec100" class="calibre1"/>Adding users</h2></div></div></div><p class="calibre8">At this moment, the list of <a id="id370" class="calibre1"/>users is hardcoded into the application. It would be preferable to remove this hardcoded list and allow users to be added on demand. Create an <code class="literal">addUser</code> function in the <code class="literal">AppDelegate</code> class:</p><div class="note"><pre class="programlisting">func addUser(user:String) {
  users += [user]
  users.sortInPlace({ $0 &lt; $1 })
}</pre></div><p class="calibre8">This allows the detail controller to call the <code class="literal">addUser</code> function and ensure that the list of users is ordered alphabetically.</p><div class="note" title="Note"><h3 class="title2"><a id="note57" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">$0</code> and <code class="literal">$1</code> are anonymous parameters expected by the <code class="literal">sort</code> function. This is a shorthand form of <code class="literal">users.sort({ user1, user2 in user1 &lt; user2})</code>. It is also possible to sort the array using the <code class="literal">&lt;</code> function on the array itself using <code class="literal">users.sortInPlace(&lt;)</code>.</p></div><p class="calibre8">The add button can be created in the <code class="literal">MasterViewController</code> in the <code class="literal">viewDidLoad</code> method such that the <code class="literal">insertNewObject</code> method is called when tapped:</p><div class="note"><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()
  let addButton = UIBarButtonItem(barButtonSystemItem: .Add,
   target: self, action: "insertNewObject:")
  self.navigationItem.rightBarButtonItem = addButton
  …
}</pre></div><p class="calibre8">When the add button is selected, a <code class="literal">UIAlertController</code> dialog can be shown with a number of actions with handlers that will be called to add the user.</p><p class="calibre8">Add (or replace) the <code class="literal">insertNewObject</code> in the <code class="literal">MasterViewController</code>, as follows:</p><div class="note"><pre class="programlisting">func insertNewObject(sender: AnyObject) {
  let alert = UIAlertController(
   title: "Add user",
   message: "Please select a user to add",
   preferredStyle: .Alert)
  alert.addAction(UIAlertAction(
   title: "Cancel", style: .Cancel, handler: nil))
  alert.addAction(UIAlertAction(
   title: "Add", style: .Default) {
    alertAction in
    let username = alert.textFields![0].text
    self.app.addUser(username!)
    Threads.runOnUIThread {
      self.tableView.reloadData()
    }
  })
  alert.addTextFieldWithConfigurationHandler {
    textField -&gt; Void in
    textField.placeholder = "Username";
  }
  presentViewController(alert, animated: true, completion: nil)
}</pre></div><p class="calibre8">Now, the users <a id="id371" class="calibre1"/>can be added in the UI by clicking the <span class="strong"><strong class="calibre2">Add</strong></span> (<span class="strong"><strong class="calibre2">+</strong></span>) button at the top right of the application. Each time the application is launched, the users array will be empty, and users can be re-added.</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00092.jpeg" alt="Adding users" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">
</p><div class="note" title="Note"><h3 class="title2"><a id="tip74" class="calibre1"/>Tip</h3><p class="calibre8">Users could persist between launches using <code class="literal">NSUserDefaults.standardUserDefaults</code> and the <code class="literal">setObject:forKey</code> and <code class="literal">stringArrayForKey</code> methods. The implementation of this is left to the reader.</p></div></div></div>

<div class="book" title="Accessing repositories from view controllers">
<div class="book" title="Implementing the detail view"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec101" class="calibre1"/>Implementing the detail view</h2></div></div></div><p class="calibre8">The<a id="id372" class="calibre1"/> final step is to implement the detail view so that when a repository is selected, per-repository information is shown. At the time the repository is selected from the master screen, the username, and repository name are known. These can be used to pull more information from the repository and add the items into the detail view.</p><p class="calibre8">Update the view in the storyboard to add four labels and four label titles for username, repository name, number of watchers, and number of open issues. Wire these into outlets into the <code class="literal">DetailViewController</code>:</p><div class="note"><pre class="programlisting">@IBOutlet weak var userLabel: UILabel?
@IBOutlet weak var repoLabel: UILabel?
@IBOutlet weak var issuesLabel: UILabel?
@IBOutlet weak var watchersLabel: UILabel?</pre></div><p class="calibre8">To set content on the details view, the <code class="literal">user</code> and <code class="literal">repo</code> will be stored as (optional) strings, and the additional <code class="literal">data</code> will be stored in string key/value pairs. When they are changed, the <code class="literal">configureView</code> method should be called to redisplay content:</p><div class="note"><pre class="programlisting">var user: String? { didSet { configureView() } }
var repo: String? { didSet { configureView() } }
var data:[String:String]? { didSet { configureView() } }</pre></div><p class="calibre8">The <code class="literal">configureView</code> call will also need to be called after the <code class="literal">viewDidLoad</code> method is called to ensure that the UI is set up as expected:</p><div class="note"><pre class="programlisting">override func viewDidLoad() { configureView() }</pre></div><p class="calibre8">In the <code class="literal">configureView</code> method, the labels may not have been set, so they need to be tested with an <code class="literal">if let</code> statement before the content is set:</p><div class="note"><pre class="programlisting">func configureView() {
  if let label = userLabel { label.text = user }
  if let label = repoLabel { label.text = repo }
  if let label = issuesLabel {
    label.text = self.data?["open_issues_count"]
  }
  if let label = watchersLabel {
    label.text = self.data?["watchers_count"]
  }
}</pre></div><p class="calibre8">If using the standard template, the <code class="literal">splitViewController</code> of the <code class="literal">AppDelegate</code> needs to be changed to return <code class="literal">true</code> after the detail view is amended:</p><div class="note"><pre class="programlisting">func splitViewController(
 splitViewController: UISplitViewController,
 collapseSecondaryViewController 
  secondaryViewController:UIViewController!,
 ontoPrimaryViewController
  primaryViewController:UIViewController!) -&gt; Bool {
  return true
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note58" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">splitViewController:collapseSecondaryViewController</code> method determines whether or not the first page that is displayed is the master (<code class="literal">true</code>) or detail (<code class="literal">false</code>) page.</p></div></div></div>

<div class="book" title="Accessing repositories from view controllers">
<div class="book" title="Transitioning between the master and detail views"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec102" class="calibre1"/>Transitioning between the master and detail views</h2></div></div></div><p class="calibre8">The<a id="id373" class="calibre1"/> connection between the master and detail view is triggered with the <code class="literal">showDetail</code> segue in <code class="literal">MasterViewController</code>. This can be used to extract the selected row from the table, which can then be used to extract the selected row and section:</p><div class="note"><pre class="programlisting">override func prepareForSegue(segue: UIStoryboardSegue,
 sender: AnyObject?) {
  if segue.identifier == "showDetail" {
    if let indexPath = self.tableView.indexPathForSelectedRow {
      // get the details controller
      // set the details
    }
  }
}</pre></div><p class="calibre8">The details controller can be accessed from the segue's destination controller—except that the destination is the navigation controller, so it needs to be unpacked one step further:</p><div class="note"><pre class="programlisting">// get the details controller
let controller = (segue.destinationViewController as!
 UINavigationController).topViewController
 as! DetailViewController
// set the details</pre></div><p class="calibre8">Next, the details need to be passed in, which can be extracted from <code class="literal">indexPath</code>, as in the prior parts of the application:</p><div class="note"><pre class="programlisting">let user = app.users[indexPath.section]
let repo = app.repos[user]![indexPath.row]
controller.repo = repo["name"] ?? ""
controller.user = user
controller.data = repo</pre></div><p class="calibre8">Finally, to ensure that the application works in split mode with <code class="literal">SplitViewController</code>, the back <a id="id374" class="calibre1"/>button needs to be displayed if in split mode:</p><div class="note"><pre class="programlisting">controller.navigationItem.leftBarButtonItem =
 self.splitViewController?.displayModeButtonItem()
controller.navigationItem.leftItemsSupplementBackButton = true</pre></div><p class="calibre8">Running the application now will show a set of repositories, and when one is selected, the details will be displayed:</p><div class="mediaobject"><img src="../images/00093.jpeg" alt="Transitioning between the master and detail views" class="calibre9"/></div><p class="calibre10"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip75" class="calibre1"/>Tip</h3><p class="calibre8">If a crash is seen when displaying the detail view, check in the <code class="literal">Main.storyboard</code> that the connector for a nonexistent field is not defined. Otherwise an error similar to <span class="strong"><strong class="calibre2">This class is not key value coding-compliant for the key detailDescriptionLabel</strong></span> might be seen, which is caused by the Storyboard runtime attempting to assign a missing outlet in the code. Open the <code class="literal">Main.storyboard</code>, go to the connections inspector, and remove the connection to the missing outlet.</p></div><div class="mediaobject"><img src="../images/00094.jpeg" alt="Transitioning between the master and detail views" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div class="book" title="Accessing repositories from view controllers">
<div class="book" title="Loading the user's avatar"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec103" class="calibre1"/>Loading the user's avatar</h2></div></div></div><p class="calibre8">The user may <a id="id375" class="calibre1"/>have an avatar or icon that they have uploaded to GitHub. This information is stored in the user information, which is accessible from a separate lookup in the GitHub API. Each user's avatar will be stored as a reference with <code class="literal">avatar_url</code> in the user information document, such as <a class="calibre1" href="https://api.github.com/users/alblue">https://api.github.com/users/alblue</a>, which will return something like this:</p><div class="note"><pre class="programlisting">{
  … 
  "avatar_url": "https://avatars.githubusercontent.com/u/76791?v=2",
  … 
}</pre></div><p class="calibre8">This URL represents an image that can be used in the header for the user's repository.</p><p class="calibre8">To add support for this, the user info needs to be added to the <code class="literal">GitHubAPI</code> class:</p><div class="note"><pre class="programlisting">func getURLForUserInfo(user:String) -&gt; NSURL {
  let key = "ui:\(user)"
  if let url = cache.objectForKey(key) as? NSURL {
    return url
  } else {
    let userURL = services["user_url"]!
    let userSpecificURL = URITemplate.replace(userURL,
     values:["user":user])
    let url = NSURL(string:userSpecificURL, relativeToURL:base)!
    cache.setObject(url,forKey:key)
    return url
  }
}</pre></div><p class="calibre8">This looks up the <code class="literal">user_url</code> service from the GitHub API, which returns the following URI template:</p><div class="note"><pre class="programlisting">  "user_url": "https://api.github.com/users/{user}",</pre></div><p class="calibre8">This can be instantiated with the user and then the image can be loaded asynchronously:</p><div class="note"><pre class="programlisting">import UIKit
...
func withUserImage(user:String, fn:(UIImage -&gt; ())) {
  let key = "image:\(user)"
  if let image = cache.objectForKey(key) as? UIImage {
    fn(image)
  } else {
    let url = getURLForUserInfo(user)
    url.withJSONDictionary {
      userInfo in
      if let avatar_url = userInfo["avatar_url"] {
        if let avatarURL = NSURL(string:avatar_url,
         relativeToURL:url) {
          if let data = NSData(contentsOfURL:avatarURL) {
            if let image = UIImage(data: data) {
              self.cache.setObject(image,forKey:key)
              fn(image)
} } } } } } }</pre></div><p class="calibre8">Once the support to<a id="id376" class="calibre1"/> load the user's avatar has been implemented, it can be added to the view's header to display it in the user interface.</p><div class="note" title="Note"><h3 class="title2"><a id="tip76" class="calibre1"/>Tip</h3><p class="calibre8">The set of nested <code class="literal">if</code> statements here suggests that it may be better to refactor to Swift's <code class="literal">guard</code> statement instead. This would ensure that the indentation does not increase on each condition. The refactoring is left as an exercise for the reader.</p></div></div></div>

<div class="book" title="Accessing repositories from view controllers">
<div class="book" title="Displaying the user's avatar"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec104" class="calibre1"/>Displaying the user's avatar</h2></div></div></div><p class="calibre8">The table view<a id="id377" class="calibre1"/> that presents the repository information by user can be amended so that along with the user's name, it also displays their avatar at the same time. Currently, this is done in the <code class="literal">tableView:</code><span class="strong"><strong class="calibre2">title</strong></span><code class="literal">ForHeaderInSection</code> method, but an equivalent <code class="literal">tableView:</code><span class="strong"><strong class="calibre2">view</strong></span><code class="literal">ForHeaderInSection</code> method is available that provides more customization options.</p><p class="calibre8">Although the method signature indicates that the return type is <code class="literal">UIView</code>, in fact, it must be a subtype of <code class="literal">UITableViewHeaderFooterView</code>. Unfortunately, there is no support to edit or customize these in Storyboard, so they must be implemented programmatically.</p><p class="calibre8">To implement the <code class="literal">viewForHeaderInSection</code> method, obtain the username as before, and set it to the <code class="literal">textLabel</code> of a newly created <code class="literal">UITableViewHeaderFooterView</code>. Then, in the asynchronous image loader, create a frame that has the same origin but a square size for the image, and then create and add the image as a subview of the header view. The method will look like this:</p><div class="note"><pre class="programlisting">override func tableView(tableView: UITableView,
 viewForHeaderInSection section: Int) -&gt; UIView? {
  let cell = UITableViewHeaderFooterView()
  let user = app.users[section]
  cell.textLabel!.text = user
  app.api.withUserImage(user) {
    image in
    let minSize = min(cell.frame.height, cell.frame.width)
    let squareSize = CGSize(width:minSize, height:minSize)
    let imageFrame = CGRect(origin:cell.frame.origin,
     size:squareSize)
    Threads.runOnUIThread {
      let imageView = UIImageView(image:image)
      imageView.frame = imageFrame
      cell.addSubview(imageView)
      cell.setNeedsLayout()
      cell.setNeedsDisplay()
    }
  }
  return cell
}</pre></div><p class="calibre8">Now when the <a id="id378" class="calibre1"/>application is run, the avatar will be displayed overlaying the user's repositories:</p><div class="mediaobject"><img src="../images/00095.jpeg" alt="Displaying the user's avatar" class="calibre9"/></div><p class="calibre10"> </p></div></div>
<div class="book" title="Summary" id="1JFUC1-d7e55eb5242648e89c396442afe4f84b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec47" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter has shown how to integrate the subjects that were created in this book to integrate them into a functional application to interact with a remote network service, such as GitHub, and be able to present this information in a tabular way.</p><p class="calibre8">By ensuring that all network requests are implemented on background threads, and that returned data is updated on the UI thread, the application will remain responsive to the user's input. Graphics and custom views can be created to provide headings, or the Storyboard could be modified to include more graphics for each repository.</p></div></body></html>