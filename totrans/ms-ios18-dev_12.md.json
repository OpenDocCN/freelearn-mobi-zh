["```swift\n import NaturalLanguage\n```", "```swift\n \"Running is fun! I love to run.\"\n```", "```swift\n \"run fun love run\".\n```", "```swift\n {\n  \"run\": 2,\n  \"fun\": 1,\n  \"love\": 1\n}\n```", "```swift\n The latest update made everything so much better. Great job!\n```", "```swift\n let sentimentAnalyzer = <st c=\"12135\">NLTagger</st>(tagSchemes:\n  [<st c=\"12158\">.sentimentScore</st>])\n        sentimentAnalyzer.string = userInput\n        let (sentiment, _) = <st c=\"12235\">sentimentAnalyzer.tag</st>(at:\n          userInput.startIndex, unit: .paragraph, scheme:\n          .sentimentScore)\n        if let sentiment = sentiment, let score =\n          Double(sentiment.rawValue) {\n          // here we can use the analyzed score\n        } else {\n            print(\"Unable to analyze sentiment\")\n        }\n```", "```swift\n She enjoys reading books in the library\n```", "```swift\n let inputText = \"She enjoys reading books in the library\"\nlet tagger = NLTagger(tagSchemes: [.lexicalClass])\ntagger.string = inputText\nlet options: NLTagger.Options =  [.omitPunctuation,\n  .omitWhitespace]\ntagger.enumerateTags(in:\n  inputText.startIndex..<inputText.endIndex, unit: .word,\n  scheme: .lexicalClass, options: options) { tag,\n  tokenRange in\n    if tag == .verb {\n       verb = String(inputText[tokenRange])\n       return false\n   }\n   return true\n}\n```", "```swift\n let tagger = NLTagger(tagSchemes: [<st c=\"15650\">.language</st>])\ntagger.string = inputText\nif let language = tagger.dominantLanguage {\n     identifiedLanguage =\n       Locale.current.localizedString(forLanguageCode:\n       language.rawValue) ?? \"Unknown\"\n        } else {\n            identifiedLanguage = \"Unknown\"\n        }\n```", "```swift\n guard let embedding = <st c=\"16557\">NLEmbedding.</st>wordEmbedding(for:\n  .english) else {\n            neighborsText = \"Failed to load word\n              embedding.\" return\n        } <st c=\"16664\">let neighbors = embedding.neighbors(for:</st>\n <st c=\"16704\">embedding.vector(for: inputWord) ??</st> <st c=\"16741\">[], maximumCount: 5)</st> if neighbors.isEmpty {\n       neighborsText = \"No neighbors found for\n         '\\(inputWord)'.\" } else {\n            neighborsText = neighbors.map { \"\\($0.0)\n              (\\($0.1))\" }.joined(separator: \", \")\n        }\n```", "```swift\n func analyze(url: URL) async {\n    let request = <st c=\"19632\">DetectBarcodesRequest()</st> do {\n       let barcodeObservations = <st c=\"19687\">try await</st>\n <st c=\"19696\">request.perform(on: url)</st> barcodeIdentifier = <st c=\"19742\">barcodeObservations.first?.payloadString ??</st> \"\"\n    } catch let error {\n       print(\"error analyzing image â€“\n         \\(error.localizedDescription)\")\n        }\n    }\n```", "```swift\n func analyze(url: URL) async {\n        let request = <st c=\"20652\">DetectFaceRectanglesRequest()</st> do {\n            let observations = try await\n              request<st c=\"20723\">.perform</st>(on: url)\n            if let <st c=\"20749\">observation</st> = observations.first {\n                rect = observation.boundingBox.cgRect\n            }\n        } catch let error {\n            print(error.localizedDescription)\n        }\n    }\n```", "```swift\n func analyze(at url: URL) {\n        do {\n            let audioFileAnalyzer = try <st c=\"24082\">SNAudioFileAnalyzer</st>(url: url)\n            let request = try <st c=\"24131\">SNClassifySoundRequest</st>(classifierIdentifier:\n              .version1)\n            let resultsObserver = <st c=\"24210\">ClassificationResultsObserver</st>()\n            try audioFileAnalyzer.add(request,\n              withObserver: resultsObserver)\n            audioFileAnalyzer.analyze()\n        } catch {\n            print(\"Error: \\(error.localizedDescription)\")\n        }\n    }\n```", "```swift\n class ClassificationResultsObserver: NSObject,\n  SNResultsObserving {\n    func request(_ request: SNRequest, didProduce result:\n      SNResult) {\n        guard let result = result as? SNClassificationResult else { return }\n        if let classification =\n          result.classifications.first {\n <st c=\"25389\">let result = classification.identifier</st> }\n    }\n    func request(_ request: SNRequest, didFailWithError\n      error: Error) { }\n    func requestDidComplete(_ request: SNRequest) {}\n}\n```", "```swift\n let searchableItems: [<st c=\"29812\">CSSearchableItem</st>] = books.map { book\n  in\n            let attributeSet =\n              CSSearchableItemAttributeSet(contentType:\n              .text)\n            attributeSet.title = book.title\n            attributeSet.contentDescription = book.author <st c=\"30000\">let item = CSSearchableItem(uniqueIdentifier:</st>\n <st c=\"30045\">book.id, domainIdentifier: \"books\",</st>\n <st c=\"30081\">attributeSet: attributeSet)</st> return item\n        }\n```", "```swift\n let index = <st c=\"30704\">CSSearchableIndex</st>(name: \"SpotlightSearchIndex\")\n        index.<st c=\"30759\">indexSearchableItems</st>(searchableItems) { error\n          in\n            if let error = error {\n                print(\"Indexing error:\n                  \\(error.localizedDescription)\")\n            } else {\n                print(\"Books successfully indexed!\")\n            }\n        }\n```", "```swift\n let searchContext = CSUserQueryContext()\n        searchContext.fetchAttributes = [\"title\"]\n        searchContext.enableRankedResults = true\n        var items: [CSSearchableItem] = []\n        let query = CSUserQuery(userQueryString: query,\n          userQueryContext: searchContext)\n        do {\n            for try await element in query.responses {\n                switch(element) {\n                case .item(let item):\n                    items.append(item.item)\n                    break\n                case .suggestion(let suggestion):\n                    // handle suggestions. break\n                @unknown default:\n                    break\n                }\n            }\n            self.searchResults = items\n        } catch let error {\n            print(error.localizedDescription)\n        }\n```", "```swift\n CSUserQuery.prepare()\n```", "```swift\n CSUserQuery.prepareProtectionClasses([.completeUnlessOpen])\n```", "```swift\n class MessageClassifier {\n    let model: MLModel\n    init(configuration: MLModelConfiguration =\n      MLModelConfiguration()) throws { <st c=\"48937\">model = try SpamClassifier(configuration:</st>\n <st c=\"48978\">configuration).model</st> }\n}\n```", "```swift\n func prediction(text: String) throws -> Bool {\n        let input = SpamClassifierInput(text: text)\n        if let result =  try? model.prediction(from: input)\n        { <st c=\"49915\">let value = result.featureValue(for:</st>\n <st c=\"49951\">\"label\")!.stringValue</st> return value == \"true\"\n        }\n        return false\n    }\n```"]