<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Manipulating Text with TextKit"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Manipulating Text with TextKit</h1></div></div></div><p>We will start this chapter with an overview of the new UIKit hierarchy. From there, we will dive directly into the dynamic text type to support OS-wide font and size settings. Next, we will cover some of the new features, such as exclusion paths to wrap texts around shapes and adding a letterpress effect with a few lines of code. Last, we will discuss how to apply standard formatting to your text, such as underlined text. Let's get started!</p><div class="section" title="What is TextKit?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec56"/>What is TextKit?</h1></div></div></div><p>Prior to iOS 6, providing mixed<a id="id196" class="indexterm"/> styles for your text was available using <span class="strong"><strong>UIWebView</strong></span> and HTML markup or using the lower level framework <span class="strong"><strong>Core Text</strong></span>. With the launch of iOS 6, Apple introduced attributed strings, allowing developers to adjust color and font attributes on defined subsections of any string. The first 10 characters could be set to a color of yellow and the remaining characters a bold font.</p><p>In iOS 6, text-based UIKit controls were based on both Core Graphics and WebKit. Here is a diagram to illustrate the hierarchy:</p><div class="mediaobject"><img src="graphics/0319OT_07_01.jpg" alt="What is TextKit?"/></div><p>You will notice that <span class="strong"><strong>UITextView</strong></span> actually uses <span class="strong"><strong>WebKit</strong></span> itself for the sake of drawing attributed text using HTML. Although attributed strings provided many solutions for working with text, they were limited in flexibility for advanced layouts. This multi-line rendered text required the use of <span class="strong"><strong>Core Text</strong></span>. This framework is very difficult to work with and understand.</p><p>With iOS 7, Apple has introduced <span class="strong"><strong>TextKit</strong></span> to streamline working with text. Apple now inherits <span class="strong"><strong>UITextView</strong></span> from <span class="strong"><strong>TextKit</strong></span> rather than <span class="strong"><strong>WebKit</strong></span> as illustrated in the following figure:</p><div class="mediaobject"><img src="graphics/0319OT_07_02.jpg" alt="What is TextKit?"/></div><p>
<span class="strong"><strong>TextKit</strong></span> inherits all of the <a id="id197" class="indexterm"/>power found in <span class="strong"><strong>Core Text</strong></span> (it is built on top of <span class="strong"><strong>Core Text</strong></span>) and provides it in an easy-to-use and much improved API. All text-based UIKit controls (with the exception of <span class="strong"><strong>UIWebView</strong></span> for obvious reasons) are now using <span class="strong"><strong>TextKit</strong></span>. You can see how the core structure is now much more refined with better flow.</p><p>TextKit can be divided into <a id="id198" class="indexterm"/>three primary classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSTextStorage</code>: This class is used to store all text attribute information. Think of it as an internal<a id="id199" class="indexterm"/> blueprint for all text effects. It is important to note that <code class="literal">NSTextStorage</code> is a subclass of the <code class="literal">NSMutableAttributedString</code> class, which is why it is responsible for all text attributes. In addition to storing text attributes, <code class="literal">NSTextStorage</code> will also make sure everything stays consistent during all editing operations.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSLayoutManager</code>: This <a id="id200" class="indexterm"/>class will manage the way the data found in <code class="literal">NSTextStorage</code> is laid out in the view (as the name implies). <code class="literal">NSTextStorage</code> will notify this class if any changes or modifications have been made to the stored text attributes. It will then update the views<a id="id201" class="indexterm"/> accordingly. As a result, changes are reflected almost instantaneously.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSTextContainer</code>: This class is responsible for specifying the view that the text will be displayed<a id="id202" class="indexterm"/> in. <code class="literal">NSTextContainer</code> also keeps track of the information related to the view, such as size/frame or shape. Most notably, <code class="literal">NSTextContainer</code> is capable of storing an array of bezier paths, which we will use later when creating exclusion paths. This is what allows TextKit to flow text around images and other objects.</li></ul></div><p>TextKit can be used for multiple<a id="id203" class="indexterm"/> text-based effects. This includes responding to user-selected text sizes with dynamic type, wrapping text around an image with exclusion paths, and text formatting similar to a rich text editor.</p><p>In this chapter, we will cover all of these features in detail and then apply some of them to our application text. To start, let's look at dynamic type.</p></div></div>
<div class="section" title="Dynamic type"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Dynamic type</h1></div></div></div><p>One of the biggest new features of iOS 7 from a user experience standpoint is the ability to adjust OS-wide text formatting. This includes increasing the font weight (bold) and text size. These settings can<a id="id204" class="indexterm"/> be set in the device's settings application. Although it is not a requirement to support dynamic type, it is recommended to do so! Here is an example of these settings:</p><div class="mediaobject"><img src="graphics/0319OT_07_03.jpg" alt="Dynamic type"/></div><p>When typically dealing with fonts, we specify the font family name and the size we want to set, as follows:</p><div class="informalexample"><pre class="programlisting">[UIFont fontWithName:@"HelveticaNeue" size:19.0f]</pre></div><p>When working with dynamic type, <a id="id205" class="indexterm"/>we will use fonts with styles instead of using the literal name of any font unlike the preceding code. <code class="literal">UIFont</code> has been equipped with a new method called <code class="literal">preferredFontForTextStyle</code>. This loads the selected font preferences from the user's device and sets the text to the given style. Here is an example of the multiple font styles:</p><div class="mediaobject"><img src="graphics/0319OT_07_04.jpg" alt="Dynamic type"/></div><p>The text on the left-hand side is the smallest size able to be rendered, the middle text is the largest size possible, while the right-hand side text is each an option in bold format. Let's take a look at an example of using TextKit for dynamic type. Here is a code example:</p><div class="informalexample"><pre class="programlisting">self.foodDateLabel.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];</pre></div><p>As mentioned in the preceding code,<a id="id206" class="indexterm"/> we are not using an explicit font name, but instead are using one of the six included styles. By doing this, we avoid using hard-coded font names for our application. As a result, our application will respond very well to user-defined font selections.</p><div class="section" title="Handling updates"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec30"/>Handling updates</h2></div></div></div><p>The preceding code will automatically render based on the user settings. A problem occurs when you switch to settings<a id="id207" class="indexterm"/> and adjust the text size. If you switch back to the application without closing it first, the text updates will not be reflected. This is<a id="id208" class="indexterm"/> because in order to respond to actual changes, your controller must respond to changes made using <code class="literal">NSNotificatonCenter</code>.</p><p>By adding the following code to the end of any <code class="literal">viewDidLoad</code> method, you can have your controller respond to text updates:</p><div class="informalexample"><pre class="programlisting">[[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(preferredContentSizeChanged:)
                                                 name:UIContentSizeCategoryDidChangeNotification
                                               object:nil];</pre></div><p>The defined selector will look something like this:</p><div class="informalexample"><pre class="programlisting">- (void)preferredContentSizeChanged:(NSNotification *)notification {
    self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];
}</pre></div><p>First we register our class to receive notification updates based on the preferred content size changing. So, if a user switches to the settings application and changes the text size, our app will intercept this and call the defined method <code class="literal">preferredContentSizeChanged</code>. Earlier, this method simply set the font; however, now it will be pulling in the new user-defined text size.</p><p>Changing the text size can<a id="id209" class="indexterm"/> also affect your view layouts. Because of this, you<a id="id210" class="indexterm"/> want to have your views to be responsive based on the text. Most of this can be done using Auto Layout. While Auto Layout may work well in most cases, one area where it does not work well is determining row height.</p></div></div>
<div class="section" title="Exclusion paths"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Exclusion paths</h1></div></div></div><p>Exclusion paths allow you to wrap text around a particular view. Most text editors provide support for this feature, and with TextKit, you can now do it in your applications. With TextKit, you can wrap your text around both complex and simple paths. For instance, you may want to wrap <a id="id211" class="indexterm"/>your text around a simple circle or around a more complex shape such as a butterfly image. You may want to use this feature when displaying text with images, or even views that provide relevant details related to the text.</p><p>Let's assume you have a circular UIView that contains data related to a piece of text. We want to center the circular UIImageView and wrap the text around it on all sides. To test this, let's add a text view to our storyboard and wrap some filler text around our food image. Switch to <span class="strong"><strong>Main.Storyboard</strong></span> and select the <code class="literal">FoodDetailViewController</code> class. Drag over a text view and resize it to be bigger than the food image. Additionally, make sure that the text view is beneath the image view. Here is what your storyboard should look like:</p><div class="mediaobject"><img src="graphics/0319OT_07_05.jpg" alt="Exclusion paths"/></div><p>Make sure to create an outlet to <code class="literal">FoodDetailViewController</code> for our new text view. Give it the name <code class="literal">textview</code>.</p><p>Switch to <code class="literal">FoodDetailViewController.m</code> and scroll to <code class="literal">viewDidLoad</code>. Add this line of code at the very bottom:</p><div class="informalexample"><pre class="programlisting">UIBezierPath *circleExclusion = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(60, 40, 210, 210)];
    self.textView.textContainer.exclusionPaths = @[circleExclusion];</pre></div><p>Here, we create a new bezier path and give it coordinates of a rectangle  that are equal to those of our image view rectangle. <a id="id212" class="indexterm"/>Now that we have defined the shape for exclusion, it is time to tell the text view to pay attention to this exclusion path. TextKit has included an additional property to the text container of all text-based views called <code class="literal">exclusionPaths</code>. This parameter accepts an array, which means that multiple exclusions<a id="id213" class="indexterm"/> can be handled at once. Here is the result:</p><div class="mediaobject"><img src="graphics/0319OT_07_06.jpg" alt="Exclusion paths"/></div></div>
<div class="section" title="Adding letterpress"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Adding letterpress</h1></div></div></div><p>Any text can appear to be letter pressed<a id="id214" class="indexterm"/> with the right amount of shadow and highlight. TextKit provides an easy and<a id="id215" class="indexterm"/> effective way to accomplish this with a new attribute parameter called <code class="literal">NSTextEffectLetterpressStyle</code>.</p><p>Here is an example with code:</p><div class="informalexample"><pre class="programlisting">NSDictionary *attributes = @{ NSForegroundColorAttributeName : [UIColor blueColor],
NSTextEffectAttributeName : NSTextEffectLetterpressStyle};
NSAttributedString* attrString = [[NSAttributedString alloc]
                                      initWithString:someString
                                      attributes:attributes];</pre></div><p>Using attributed strings, we can apply this specific text effect in addition to other attributes. That's all it takes to apply this subtle effect! Take a look at our app as an example:</p><div class="mediaobject"><img src="graphics/0319OT_07_07.jpg" alt="Adding letterpress"/></div></div>
<div class="section" title="Text formatting"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Text formatting</h1></div></div></div><p>With TextKit, we can apply some fairly simple text editing properties to our text. These include bold, italics, and underlined text.<a id="id216" class="indexterm"/> In order to do this, we are going to use a brand new class available in iOS 7, <code class="literal">UIFontDescriptor</code>. This class is used to describe a font and all of its attributes. Also, more importantly, you are able to directly modify attributes and create a new font. All font attributes are represented by either a dictionary or a key string constant.</p><div class="section" title="Making text bold and italicizing"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec31"/>Making text bold and italicizing</h2></div></div></div><p>Let's take a look at a piece of code<a id="id217" class="indexterm"/> to see how we can make bold text using <code class="literal">UIFontDescriptor</code>:</p><div class="informalexample"><pre class="programlisting">NSDictionary *currentAttributesDict = [self.textView.textStorage attributesAtIndex:0

effectiveRange:nil];

UIFont *currentFont = [currentAttributesDict objectForKey:NSFontAttributeName];

UIFontDescriptor *fontDescriptor = [currentFont fontDescriptor];
UIFontDescriptor *changedFontDescriptor = [fontDescriptor fontDescriptorWithSymbolicTraits:UIFontDescriptorTraitBold];

UIFont *updatedFont = [UIFont fontWithDescriptor:changedFontDescriptor size:0.0];

NSDictionary *dict = @{NSFontAttributeName: updatedFont};

    [self.textView.textStorage setAttributes:dict range:NSMakeRange(0, self.textView.text.length)];</pre></div><p>First we are grabbing the current attributes from a text view's text storage object. Next we are creating a reference to the original font used for this piece of text. We want to do this just in case we need that information (this is mostly dependent on why the application is using <code class="literal">UIFontDescriptor</code>). We also create a reference to the current font descriptor as well. Once we have all of this information, we create a new font descriptor and set its symbolic trait to be bold. Lastly, we create an instance of our new font that used our new font descriptor and assign it to our text view. To change<a id="id218" class="indexterm"/> the text to italics, simply pass the proper symbolic trait.</p><p>A symbolic trait is actually just a property of a font that describes its style. It is an unsigned 32-bit integer. Here is the list of all traits that has been provided by Apple:</p><div class="informalexample"><pre class="programlisting">typedef enum : uint32_t {
  /* Typeface info (lower 16 bits of UIFontDescriptorSymbolicTraits) */
  UIFontDescriptorTraitItalic = 1u &lt;&lt; 0,
  UIFontDescriptorTraitBold = 1u &lt;&lt; 1,
  UIFontDescriptorTraitExpanded = 1u &lt;&lt; 5,
  UIFontDescriptorTraitCondensed = 1u &lt;&lt; 6,
  UIFontDescriptorTraitMonoSpace = 1u &lt;&lt; 10,
  UIFontDescriptorTraitVertical = 1u &lt;&lt; 11,
  UIFontDescriptorTraitUIOptimized = 1u &lt;&lt; 12,
  UIFontDescriptorTraitTightLeading = 1u &lt;&lt; 15,
  UIFontDescriptorTraitLooseLeading = 1u &lt;&lt; 16,

/* Font appearance info (upper 16 bits of UIFontDescriptorSymbolicTraits */
  UIFontDescriptorClassMask = 0xF0000000,

  UIFontDescriptorClassUnknown = 0u &lt;&lt; 28,
  UIFontDescriptorClassOldStyleSerifs = 1u &lt;&lt; 28,
  UIFontDescriptorClassTransitionalSerifs = 2u &lt;&lt; 28,
  UIFontDescriptorClassModernSerifs = 3u &lt;&lt; 28,
  UIFontDescriptorClassClarendonSerifs = 4u &lt;&lt; 28,
  UIFontDescriptorClassSlabSerifs = 5u &lt;&lt; 28,
  UIFontDescriptorClassFreeformSerifs = 7u &lt;&lt; 28,
  UIFontDescriptorClassSansSerif = 8u &lt;&lt; 28,
  UIFontDescriptorClassOrnamentals = 9u &lt;&lt; 28,
  UIFontDescriptorClassScripts = 10u &lt;&lt; 28,
  UIFontDescriptorClassSymbolic = 12u &lt;&lt; 28
} UIFontDescriptorSymbolicTraits;</pre></div></div></div>
<div class="section" title="Underlining text"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Underlining text</h1></div></div></div><p>Using <a id="id219" class="indexterm"/>TextKit to underline text is accomplished using a method<a id="id220" class="indexterm"/> similar to any one of the methods shown in the preceding code, with some modifications. <a id="id221" class="indexterm"/>Here is a code sample:</p><div class="informalexample"><pre class="programlisting">NSDictionary *currentAttributesDict = [self.textView.textStorage attributesAtIndex:0

effectiveRange:nil];
NSDictionary *dict;

if ([currentAttributesDict objectForKey:NSUnderlineStyleAttributeName] == nil || [[currentAttributesDict objectForKey:NSUnderlineStyleAttributeName] intValue] == 0) {

  dict = @{NSUnderlineStyleAttributeName: [NSNumber numberWithInt:1]};

}
else{
  dict = @{NSUnderlineStyleAttributeName: [NSNumber numberWithInt:0]};
}

[_textView.textStorage setAttributes:dict range:NSMakeRange(0, self.textView.text.length)];</pre></div><p>Here we must check if the <code class="literal">NSUnderlineStyleAttributeName</code> attribute already exists in our current text attributes.<a id="id222" class="indexterm"/> From here, we simply turn the underline<a id="id223" class="indexterm"/> attribute <span class="strong"><strong>On</strong></span> or <span class="strong"><strong>Off</strong></span> and apply it to our text.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Summary</h1></div></div></div><p>TextKit offers many great ways to manipulate text in iOS. Supporting these features is key to providing a better experience for users. I recommend that you take the time to navigate through Apple's documentation. We have covered many of the standard uses in this chapter. TextKit is a very powerful new API that will continue to provide innovative ways to be used.</p><p>In the final chapter, we are going to cover UIKit Dynamics. We will learn how adding physics to our UI elements can create an exciting experience!</p></div></body></html>