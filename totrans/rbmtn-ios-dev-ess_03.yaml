- en: Chapter 3. Evolution – From Objective-C to RubyMotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Actually, I''m trying to make Ruby natural, not simple."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*— Matz*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will have a detailed discussion on how Ruby is implemented
    in RubyMotion. We will also understand how we can use the various Objective-C
    objects in our Ruby code. As we know, the iOS SDK is written in Objective-C, which
    is a simple extension of the C language. Since this is a book on learning RubyMotion,
    we will not focus too much on this. However, we will make sure you have enough
    knowledge on Objective-C to program in RubyMotion. In this chapter, we will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Ruby and Objective-C work together in RubyMotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In what ways are RubyMotion objects inherited from Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing with C and Objective-C – learning about data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management with RubyMotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby and Objective-C – a partnership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must be wondering how Objective-C and Ruby can work together, as Objective-C
    is a compiled language and Ruby is an interpreted language. Then how come they
    work together in RubyMotion?
  prefs: []
  type: TYPE_NORMAL
- en: In reality, Objective-C in the iOS SDK not only has a compiler, but also has
    a runtime system to execute the compiled code. This runtime system acts as an
    interface for the Objective-C language; this is what makes the language work.
    RubyMotion takes advantage of the Objective-C runtime and our Ruby code interacts
    through this runtime system in just the same way as an Objective-C code does.
    That means Ruby and Objective-C are effectively working on top of the Objective-C
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby and Objective-C – a partnership](img/5220OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram represents the way RubyMotion and Objective-C work together
    in an iOS SDK ecosystem. In simple terms, this means we can access all iOS SDK
    classes with RubyMotion through the Objective-C runtime. The **Foundation Framework**
    is an Objective-C framework, but the great news is that RubyMotion is, in fact,
    based on Objective-C runtime; therefore, the classes that are defined can naturally
    be re-used in RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The runtime library is written mainly in the C language and is open source.
    This is available at [http://opensource.apple.com](http://opensource.apple.com).
  prefs: []
  type: TYPE_NORMAL
- en: Ruby and Objective-C share the same ancestor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the built-in classes of RubyMotion are based on the Foundation Framework.
    To better understand this, let''s fire up REPL in our console for our existing
    RubyMotion application from the previous chapter. As you may remember, in that
    chapter we had learned how to use REPL. Run the `rake` command to start REPL and
    then run the following commands in REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have found the root for the Ruby `integer` and
    `string` classes. Firstly, we declared a variable and assigned an integer value
    to it. When we trace its class, we see a familiar name, `Fixnum`, which is a Ruby
    data type. But when we trace back to the super class for `Fixnum`, we see that
    it's an Objective-C Integer type. This shows that the RubyMotion `Fixnum` data
    type is inherited from `NSNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when we declare a string variable name and then trace its class,
    we see a recognizable Ruby class, `String`. Moreover, this string class is inherited
    from `NSMutableString`. This means the `String` Ruby class is a subclass of the
    Objective-C `String` class in RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby and Objective-C share the same ancestor](img/5220OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A direct consequence of hosting the Ruby built-in classes over Foundation is
    that their instances respond to more messages. For example, the `NSString` class
    defines the uppercase `String` method. Since the `String` class is a subclass
    of `NSString`, strings created in Ruby also respond to that method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This gives us immense flexibility to not only use Ruby methods, but also access
    thousands of classes and methods from the Foundation Framework, making it possible
    to create any app one can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other data types are also inherited in the same fashion. Just have a look at
    the following table (source – [http://www.rubymotion.com/developer-center/guides/runtime](http://www.rubymotion.com/developer-center/guides/runtime)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Ruby class | Ancestors |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `foo` | `NSObject` → `Kernel` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `NSMutableString` → `NSString` → `Comparable` → `NSObject` → `Kernel`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Array` | `NSMutableArray` → `NSArray` → `Enumerable` → `NSObject` → `Kernel`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Hash` | `NSMutableDictionary` → `NSDictionary` → `Enumerable` → `NSObject`
    → `Kernel` |'
  prefs: []
  type: TYPE_TB
- en: '| `Numeric` | `Comparable` → `NSNumber` → `NSValue` → `NSObject` → `Kernel`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Time` | `Comparable` → `NSDate` → `NSObject` → `Kernel` |'
  prefs: []
  type: TYPE_TB
- en: 'You must have noticed that strings created in RubyMotion inherit from `NSMutableString`
    instead of `NSMutable`. Isn''t that strange? It will be good to know the difference
    between these two. `NSMutableString` objects provide us with methods to change
    the underlying array of characters that they represent, while `NSString` objects
    do not. For example, `NSMutableString` provides us methods such as `appendString`,
    `deleteCharactersInRange`, `insertString`, and `replaceOccurencesWithString`.
    All these methods operate directly on the `NSMutableString` object in memory,
    which means we can modify the original value. On the other hand, `NSString` is
    a create-once-then-read-only string. We have many manipulation methods (`substring`,
    `uppercaseString`, and so on) for `NSString` objects. However, they return a new
    `NSString` object and never actually modify the existing string in memory, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As there is no read-only string in Ruby and we need to update the string too,
    we are using `NSMutableString` by default. The same goes for arrays and hashes
    that are inherited from `NSMutableArray` and `NSMutableDictionary` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Foundation comes with the `NSObject` root object class, as well as a set of
    other primitive object classes. In RubyMotion, `Object` is an alias of `NSObject`,
    making `NSObject` the root class of all Ruby classes.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with C and Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although working with RubyMotion does not require one to learn Objective-C,
    or even C for that matter, sometimes when you want to use the iOS API, knowledge
    of its Ruby equivalent is beneficial. Objective-C is a superset of the C language.
    Objective-C methods can therefore accept and return C-language types.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C language—and indirectly Objective-C—has a set of basic data types that are
    used in the iOS SDK APIs. In order to accept or return these data types, we need
    some equivalent data types for Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a function named `foo` that accepts a C integer
    type as a parameter and returns the `some_number` integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, if we want to call the preceding function from Ruby, we will require some
    equivalent Ruby type. Basic C types cannot be created from Ruby directly, but
    are automatically converted from and to equivalent Ruby types. You don't have
    to worry, RubyMotion will take care of this for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss all of the basic C types and discuss how they are converted
    from C data types to Ruby data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From Ruby to C – `nil` is similar to `void`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From C to Ruby – `void` is similar to `nil`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`, `short`, `int`, `long`, and `long_long`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From Ruby to C – If the object is `Fixnum` or `Bignum`, the value is returned.
    If the object is `true` or `false`, `1` or `0` are returned respectively. The
    `char` data type is mapped with `string` and the value returned is the same.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From C to Ruby – Either a `Fixnum` or `Bignum` object is returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bool`/`BOOL`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From Ruby to C – If the value of an object is `false` or `nil`, `false` will
    be returned, else `true` will be returned. Whereas, for `0`, `Fixnum true` will
    be returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From C to Ruby – `true` or `false` will be returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` and `double`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From Ruby to C:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For a `float` object, a value is returned.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `true` or `false`, `1.0` or `0.0` are returned respectively.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object responds to the `to_f` message, the message is sent and the result
    is returned.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From C to Ruby – it is the `float` object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations and constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, C code uses enumerations and constants extensively, but we don't
    have these in Ruby. So they are mapped to constants of the `Object` class. Both
    enumerations and constants defined by the Foundation can be directly accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `NSNotFound` is an enumeration and we can directly access it as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Also, a constant such as `AVMediaTypeAudio` can be directly accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many enumerations or constants defined in the iOS SDK that start with
    a lowercase letter, such as `kCLLocationAccuracyNearestTenMeters`, which starts
    with `k`. But since Ruby constants always begin with a capital letter, their names
    must be changed by making the lowercase of the first letter uppercase. Therefore,
    the constant from the preceding example becomes `KCLLocationAccuracyNearestTenMeters;`
    (starting with a capital `K`) in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C functions are available as methods to be used in Ruby code in RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `CGPointMake` function can be used in Ruby to create a rectangular
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Many functions in the iOS SDK start with a capital letter. And there is also
    a possibility that a few of them accept no arguments; in such cases, it can create
    confusion and the compiler may treat such expressions as constants. So it is very
    important to use parentheses explicitly when calling such functions, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inline functions, which are implemented in the framework's header, are also
    supported by RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A structure is a collection of one or more variables, possibly of different
    data types, grouped together under a single name for convenient handling. To map
    C structures with Ruby, RubyMotion uses classes, which means structures can be
    created in Ruby and then passed to APIs that expect C structures. Similarly, APIs
    returning C structures will return an instance of the appropriate structure class.
  prefs: []
  type: TYPE_NORMAL
- en: A structure class has an `accessor` method for each field of the corresponding
    C structure it wraps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following piece of code creates a `CGPoint` structure, sets
    its `x` and `y` fields, and then passes it to the `drawAtPoint:withFont:` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass this value directly to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'RubyMotion will also accept arrays for our convenience. They must contain the
    same number and type of objects expected in the structure. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C and Objective-C both commonly make use of pointers and therefore it is extensively
    used in the iOS SDK too. In the iOS SDK, pointers are usually used as arguments
    to return objects by reference. For example, the `NSData` method expects an error
    pointer that will be set to an `NSError` object in case of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there is no pointer concept in Ruby, RubyMotion uses the `Pointer` class
    in order to create and manipulate pointers. To create a new pointer, use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we have passed `char` in a `new` initializer, which will create
    a string pointer. Similarly, to create a different type of pointer, we can pass
    the following parameters in the `Pointer` class (source – [http://www.rubymotion.com/developer-center/guides/runtime/#_pointers](http://www.rubymotion.com/developer-center/guides/runtime/#_pointers)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| C type pointer | Runtime type string | Shortcut symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `id*` | `""@""` | `:object` |'
  prefs: []
  type: TYPE_TB
- en: '| `Char` | `""c""` | `:char` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned char*` | `""C""` | `:uchar` |'
  prefs: []
  type: TYPE_TB
- en: '| `short*` | `""s""` | `:short` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned short*` | `""S""` | `:ushort` |'
  prefs: []
  type: TYPE_TB
- en: '| `int*` | `""i""` | `:int` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned int*` | `""I""` | `:uint` |'
  prefs: []
  type: TYPE_TB
- en: '| `long*` | `""l""` | `:long` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned long*` | `""L""` | `:ulong` |'
  prefs: []
  type: TYPE_TB
- en: '| `long long*` | `""q""` | `:long_long` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned long long*` | `""Q""` | `:ulong_long` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `""f""` | `:float` |'
  prefs: []
  type: TYPE_TB
- en: '| `double*` | `""d""` | `:double` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pointers to C characters, which are also called **C strings**, are automatically
    converted from and to `String` objects by RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a class in Ruby is simple, but since the iOS SDK is written in Objective-C,
    it is necessary to understand Objective-C interfaces and learn how to use them
    with Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: An Objective-C interface always starts with a minus or a plus sign, which is
    used to declare an instance or class method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following interface declares the `foo` instance method on
    the `Foo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The methods that instances of a class can use are called **instance methods**
    and are marked with a minus sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following declares the `foo` class method on the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The names of the methods that can be used by class objects are preceded by a
    plus sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the previous section, arguments in Objective-C methods can be named
    with a keyword. The following interface declares the `sharedInstanceWithObject:andObject:`
    class method on the `Test` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding Ruby method for the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It will call the `sharedInstanceWithObject` method of the `Test` class, where
    `obj1` and `obj2` are variables of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can send and define Objective-C messages using RubyMotion. As Objective-C
    uses named arguments, which is unlike Ruby methods, it looks different from a
    typical Ruby method if it contains more than one argument.
  prefs: []
  type: TYPE_NORMAL
- en: Each argument in Objective-C has a keyword associated with it and the final
    Objective-C message is the combination of all these keywords.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Objective-C messages can be sent from RubyMotion using a similar syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The message keywords are `colorWithRed:`, `green:`, `blue:`, and `alpha:`. The
    complete message is the combination of these keywords. If you are a Ruby developer,
    you will probably find it strange to see the colon in the Ruby code. The reason
    is that this is called a **named parameter** and it is very common in RubyMotion
    applications. As we interact a lot with Objective-C methods and these receive
    named parameters, we have to pass them in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntax used to define Objective-C selectors was added to RubyMotion and
    is not part of the Ruby standard.
  prefs: []
  type: TYPE_NORMAL
- en: RubyMotion selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RubyMotion runtime provides convenient shortcuts for certain Objective-C
    selectors (source – [http://www.rubymotion.com](http://www.rubymotion.com)).
  prefs: []
  type: TYPE_NORMAL
- en: '| Selector | Shortcut |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setFoo:` | `foo=` |'
  prefs: []
  type: TYPE_TB
- en: '| `isFoo` | `foo?` |'
  prefs: []
  type: TYPE_TB
- en: '| `objectForKey:` | `[]` |'
  prefs: []
  type: TYPE_TB
- en: '| `setObject:forKey:` | `[]=` |'
  prefs: []
  type: TYPE_TB
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management is an important programming principle of handling the life
    cycles of objects and releasing them when they are no longer needed in your application.
    Management of object memory is necessary to have good performance; if an application
    doesn't free unneeded objects, its memory footprint grows and performance suffers.
  prefs: []
  type: TYPE_NORMAL
- en: RubyMotion provides automatic memory management; you do not need to reclaim
    unused objects. Also, as memory in any iOS device is limited, the bad acting application
    would just be killed at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management in a Cocoa application that doesn't use garbage collection
    is based on a reference-counting method. RubyMotion also uses reference-counting
    ways to reclaim memory. When you create or copy an object, its retain count is
    `1`. Thereafter, other objects may express an ownership interest in your object,
    which increments its retain count. The owners of an object may also surrender
    their possession interest in it, which reduces the retain count. When the retain
    count becomes zero, the object is deallocated (destroyed).
  prefs: []
  type: TYPE_NORMAL
- en: Objects created by Objective-C or the Core-Foundation-style APIs are automatically
    managed by RubyMotion. There is no need to send the retain, release, or auto-release
    messages to them, or to use the `CFRetain` or `CFRelease` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recap what we have just learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How Objective-C and Ruby work together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How RubyMotion objects are inherited from Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How RubyMotion interfaces with C and Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management offered with RubyMotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how we can use the **Model-View-Controller**
    (**MVC**) design principle in our RubyMotion application. We will discuss in detail
    about the MVC architecture. Later in the chapter, we will have some hands-on examples
    to learn how to integrate our mobile application with an external API.
  prefs: []
  type: TYPE_NORMAL
