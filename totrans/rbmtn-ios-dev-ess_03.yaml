- en: Chapter 3. Evolution – From Objective-C to RubyMotion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 进化 – 从Objective-C到RubyMotion
- en: '*"Actually, I''m trying to make Ruby natural, not simple."*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"实际上，我正在尝试让Ruby变得自然，而不是简单。"*'
- en: '*— Matz*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*— 松本行弘*'
- en: 'In this chapter, we will have a detailed discussion on how Ruby is implemented
    in RubyMotion. We will also understand how we can use the various Objective-C
    objects in our Ruby code. As we know, the iOS SDK is written in Objective-C, which
    is a simple extension of the C language. Since this is a book on learning RubyMotion,
    we will not focus too much on this. However, we will make sure you have enough
    knowledge on Objective-C to program in RubyMotion. In this chapter, we will cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细讨论Ruby在RubyMotion中的实现方式。我们还将了解如何在我们的Ruby代码中使用各种Objective-C对象。正如我们所知，iOS
    SDK是用Objective-C编写的，它是C语言的一个简单扩展。由于这是一本关于学习RubyMotion的书，我们不会过多关注这一点。然而，我们将确保你拥有足够的Objective-C知识来在RubyMotion中编程。在本章中，我们将涵盖以下主题：
- en: How Ruby and Objective-C work together in RubyMotion
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby和Objective-C在RubyMotion中的协作方式
- en: In what ways are RubyMotion objects inherited from Objective-C
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RubyMotion对象是如何从Objective-C继承的
- en: Interfacing with C and Objective-C – learning about data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与C和Objective-C接口 – 了解数据类型
- en: Memory management with RubyMotion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RubyMotion的内存管理
- en: Ruby and Objective-C – a partnership
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby和Objective-C – 一种伙伴关系
- en: You must be wondering how Objective-C and Ruby can work together, as Objective-C
    is a compiled language and Ruby is an interpreted language. Then how come they
    work together in RubyMotion?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道Objective-C和Ruby是如何协作的，因为Objective-C是一种编译型语言，而Ruby是一种解释型语言。那么，它们在RubyMotion中是如何协作的呢？
- en: In reality, Objective-C in the iOS SDK not only has a compiler, but also has
    a runtime system to execute the compiled code. This runtime system acts as an
    interface for the Objective-C language; this is what makes the language work.
    RubyMotion takes advantage of the Objective-C runtime and our Ruby code interacts
    through this runtime system in just the same way as an Objective-C code does.
    That means Ruby and Objective-C are effectively working on top of the Objective-C
    runtime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，iOS SDK中的Objective-C不仅有一个编译器，还有一个运行时系统来执行编译后的代码。这个运行时系统充当Objective-C语言的接口；这就是使语言工作的原因。RubyMotion利用Objective-C运行时，我们的Ruby代码通过这个运行时系统与Objective-C代码以相同的方式交互。这意味着Ruby和Objective-C实际上是在Objective-C运行时之上工作的。
- en: '![Ruby and Objective-C – a partnership](img/5220OT_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby和Objective-C – 一种伙伴关系](img/5220OT_03_01.jpg)'
- en: The preceding diagram represents the way RubyMotion and Objective-C work together
    in an iOS SDK ecosystem. In simple terms, this means we can access all iOS SDK
    classes with RubyMotion through the Objective-C runtime. The **Foundation Framework**
    is an Objective-C framework, but the great news is that RubyMotion is, in fact,
    based on Objective-C runtime; therefore, the classes that are defined can naturally
    be re-used in RubyMotion.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了RubyMotion和Objective-C在iOS SDK生态系统中的协作方式。简单来说，这意味着我们可以通过Objective-C运行时使用RubyMotion访问所有iOS
    SDK类。**Foundation框架**是一个Objective-C框架，但好消息是RubyMotion实际上是基于Objective-C运行时的；因此，定义的类可以自然地在RubyMotion中重用。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The runtime library is written mainly in the C language and is open source.
    This is available at [http://opensource.apple.com](http://opensource.apple.com).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库主要用C语言编写，并且是开源的。可以在[http://opensource.apple.com](http://opensource.apple.com)找到。
- en: Ruby and Objective-C share the same ancestor
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby和Objective-C有共同的祖先
- en: 'Some of the built-in classes of RubyMotion are based on the Foundation Framework.
    To better understand this, let''s fire up REPL in our console for our existing
    RubyMotion application from the previous chapter. As you may remember, in that
    chapter we had learned how to use REPL. Run the `rake` command to start REPL and
    then run the following commands in REPL:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion的一些内置类基于Foundation框架。为了更好地理解这一点，让我们在我们的控制台中启动之前章节中的现有RubyMotion应用程序的REPL。如您所记，在那个章节中我们学习了如何使用REPL。运行`rake`命令以启动REPL，然后在REPL中运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we have found the root for the Ruby `integer` and
    `string` classes. Firstly, we declared a variable and assigned an integer value
    to it. When we trace its class, we see a familiar name, `Fixnum`, which is a Ruby
    data type. But when we trace back to the super class for `Fixnum`, we see that
    it's an Objective-C Integer type. This shows that the RubyMotion `Fixnum` data
    type is inherited from `NSNumber`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们找到了 Ruby `integer` 和 `string` 类的根。首先，我们声明了一个变量并将其赋值为一个整数。当我们跟踪其类时，我们看到一个熟悉的名字，`Fixnum`，这是一个
    Ruby 数据类型。但是当我们跟踪 `Fixnum` 的超类时，我们看到它是一个 Objective-C 的 Integer 类型。这表明 RubyMotion
    的 `Fixnum` 数据类型是从 `NSNumber` 继承而来的。
- en: Similarly, when we declare a string variable name and then trace its class,
    we see a recognizable Ruby class, `String`. Moreover, this string class is inherited
    from `NSMutableString`. This means the `String` Ruby class is a subclass of the
    Objective-C `String` class in RubyMotion.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们声明一个字符串变量名并跟踪其类时，我们会看到一个可识别的 Ruby 类，`String`。此外，这个字符串类是从 `NSMutableString`
    继承而来的。这意味着 RubyMotion 的 `String` 类是 RubyMotion 中 Objective-C 的 `String` 类的子类。
- en: '![Ruby and Objective-C share the same ancestor](img/5220OT_03_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 和 Objective-C 共享相同的祖先](img/5220OT_03_02.jpg)'
- en: 'A direct consequence of hosting the Ruby built-in classes over Foundation is
    that their instances respond to more messages. For example, the `NSString` class
    defines the uppercase `String` method. Since the `String` class is a subclass
    of `NSString`, strings created in Ruby also respond to that method, as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Ruby 内置类覆盖 Foundation 的情况下，其实例可以响应更多的消息。例如，`NSString` 类定义了 `uppercase` 字符串方法。由于
    `String` 类是 `NSString` 的子类，因此 Ruby 中创建的字符串也可以响应该方法，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This gives us immense flexibility to not only use Ruby methods, but also access
    thousands of classes and methods from the Foundation Framework, making it possible
    to create any app one can imagine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够不仅使用 Ruby 方法，还可以访问来自 Foundation 框架的数千个类和方法，从而能够创建任何可以想象的应用程序。
- en: 'Other data types are also inherited in the same fashion. Just have a look at
    the following table (source – [http://www.rubymotion.com/developer-center/guides/runtime](http://www.rubymotion.com/developer-center/guides/runtime)):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数据类型也是以相同的方式继承的。只需看一下以下表格（来源 – [http://www.rubymotion.com/developer-center/guides/runtime](http://www.rubymotion.com/developer-center/guides/runtime))：
- en: '| Ruby class | Ancestors |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Ruby 类 | 祖先 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `foo` | `NSObject` → `Kernel` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `foo` | `NSObject` → `Kernel` |'
- en: '| `String` | `NSMutableString` → `NSString` → `Comparable` → `NSObject` → `Kernel`
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `NSMutableString` → `NSString` → `Comparable` → `NSObject` → `Kernel`
    |'
- en: '| `Array` | `NSMutableArray` → `NSArray` → `Enumerable` → `NSObject` → `Kernel`
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `Array` | `NSMutableArray` → `NSArray` → `Enumerable` → `NSObject` → `Kernel`
    |'
- en: '| `Hash` | `NSMutableDictionary` → `NSDictionary` → `Enumerable` → `NSObject`
    → `Kernel` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Hash` | `NSMutableDictionary` → `NSDictionary` → `Enumerable` → `NSObject`
    → `Kernel` |'
- en: '| `Numeric` | `Comparable` → `NSNumber` → `NSValue` → `NSObject` → `Kernel`
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Numeric` | `Comparable` → `NSNumber` → `NSValue` → `NSObject` → `Kernel`
    |'
- en: '| `Time` | `Comparable` → `NSDate` → `NSObject` → `Kernel` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Time` | `Comparable` → `NSDate` → `NSObject` → `Kernel` |'
- en: 'You must have noticed that strings created in RubyMotion inherit from `NSMutableString`
    instead of `NSMutable`. Isn''t that strange? It will be good to know the difference
    between these two. `NSMutableString` objects provide us with methods to change
    the underlying array of characters that they represent, while `NSString` objects
    do not. For example, `NSMutableString` provides us methods such as `appendString`,
    `deleteCharactersInRange`, `insertString`, and `replaceOccurencesWithString`.
    All these methods operate directly on the `NSMutableString` object in memory,
    which means we can modify the original value. On the other hand, `NSString` is
    a create-once-then-read-only string. We have many manipulation methods (`substring`,
    `uppercaseString`, and so on) for `NSString` objects. However, they return a new
    `NSString` object and never actually modify the existing string in memory, as
    shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了，在 RubyMotion 中创建的字符串是从 `NSMutableString` 继承的，而不是从 `NSMutable`。这难道不奇怪吗？了解这两者之间的区别将是有益的。`NSMutableString`
    对象为我们提供了更改它们所表示的字符数组的方法，而 `NSString` 对象则没有。例如，`NSMutableString` 提供了 `appendString`、`deleteCharactersInRange`、`insertString`
    和 `replaceOccurrencesWithString` 等方法。所有这些方法都直接在内存中的 `NSMutableString` 对象上操作，这意味着我们可以修改原始值。另一方面，`NSString`
    是一个一次性创建然后只读的字符串。我们有许多用于 `NSString` 对象的操纵方法（如 `substring`、`uppercaseString` 等）。然而，它们返回一个新的
    `NSString` 对象，并且永远不会实际修改内存中的现有字符串，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As there is no read-only string in Ruby and we need to update the string too,
    we are using `NSMutableString` by default. The same goes for arrays and hashes
    that are inherited from `NSMutableArray` and `NSMutableDictionary` respectively.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ruby 中没有只读字符串，并且我们需要更新字符串，所以我们默认使用 `NSMutableString`。对于从 `NSMutableArray`
    和 `NSMutableDictionary` 继承的数组和哈希表也是同样的情况。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Foundation comes with the `NSObject` root object class, as well as a set of
    other primitive object classes. In RubyMotion, `Object` is an alias of `NSObject`,
    making `NSObject` the root class of all Ruby classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基础类库包含 `NSObject` 根对象类，以及一系列其他原始对象类。在 RubyMotion 中，`Object` 是 `NSObject` 的别名，使得
    `NSObject` 成为所有 Ruby 类的根类。
- en: Interfacing with C and Objective-C
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 C 和 Objective-C 的接口
- en: Although working with RubyMotion does not require one to learn Objective-C,
    or even C for that matter, sometimes when you want to use the iOS API, knowledge
    of its Ruby equivalent is beneficial. Objective-C is a superset of the C language.
    Objective-C methods can therefore accept and return C-language types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 RubyMotion 不需要学习 Objective-C，甚至 C 语言，但有时当你想使用 iOS API 时，了解其 Ruby 等效类型是有益的。Objective-C
    是 C 语言的超集。因此，Objective-C 方法可以接受和返回 C 语言类型。
- en: Types
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: C language—and indirectly Objective-C—has a set of basic data types that are
    used in the iOS SDK APIs. In order to accept or return these data types, we need
    some equivalent data types for Ruby.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言——以及间接的 Objective-C——有一组基本数据类型，这些类型在 iOS SDK API 中被使用。为了接受或返回这些数据类型，我们需要一些等效的
    Ruby 数据类型。
- en: 'For example, let''s create a function named `foo` that accepts a C integer
    type as a parameter and returns the `some_number` integer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个名为 `foo` 的函数，它接受一个 C 整数类型作为参数，并返回 `some_number` 整数：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, if we want to call the preceding function from Ruby, we will require some
    equivalent Ruby type. Basic C types cannot be created from Ruby directly, but
    are automatically converted from and to equivalent Ruby types. You don't have
    to worry, RubyMotion will take care of this for you.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想从 Ruby 调用前面的函数，我们需要一些等效的 Ruby 类型。基本 C 类型不能直接从 Ruby 创建，但会自动转换为和转换为等效的
    Ruby 类型。你不必担心，RubyMotion 会为你处理这些。
- en: 'Let''s discuss all of the basic C types and discuss how they are converted
    from C data types to Ruby data types:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论所有基本 C 类型，并讨论它们如何从 C 数据类型转换为 Ruby 数据类型：
- en: '`void`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`：'
- en: From Ruby to C – `nil` is similar to `void`.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Ruby 到 C – `nil` 与 `void` 类似。
- en: From C to Ruby – `void` is similar to `nil`.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C 到 Ruby – `void` 与 `nil` 类似。
- en: '`char`, `short`, `int`, `long`, and `long_long`:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`、`short`、`int`、`long` 和 `long_long`：'
- en: From Ruby to C – If the object is `Fixnum` or `Bignum`, the value is returned.
    If the object is `true` or `false`, `1` or `0` are returned respectively. The
    `char` data type is mapped with `string` and the value returned is the same.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Ruby 到 C – 如果对象是 `Fixnum` 或 `Bignum`，则返回其值。如果对象是 `true` 或 `false`，则分别返回 `1`
    或 `0`。`char` 数据类型映射为 `string`，返回的值相同。
- en: From C to Ruby – Either a `Fixnum` or `Bignum` object is returned.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C 到 Ruby – 返回的是一个 `Fixnum` 或 `Bignum` 对象。
- en: '`Bool`/`BOOL`:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bool`/`BOOL`：'
- en: From Ruby to C – If the value of an object is `false` or `nil`, `false` will
    be returned, else `true` will be returned. Whereas, for `0`, `Fixnum true` will
    be returned.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Ruby 到 C – 如果对象的值为 `false` 或 `nil`，则返回 `false`，否则返回 `true`。而对于 `0`，则返回 `Fixnum
    true`。
- en: From C to Ruby – `true` or `false` will be returned.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C 到 Ruby – 返回 `true` 或 `false`。
- en: '`float` and `double`:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 和 `double`：'
- en: 'From Ruby to C:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Ruby 到 C：
- en: For a `float` object, a value is returned.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `float` 对象，返回一个值。
- en: For `true` or `false`, `1.0` or `0.0` are returned respectively.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `true` 或 `false`，分别返回 `1.0` 或 `0.0`。
- en: If the object responds to the `to_f` message, the message is sent and the result
    is returned.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象响应 `to_f` 消息，则发送该消息并返回结果。
- en: From C to Ruby – it is the `float` object.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C 到 Ruby – 返回的是 `float` 对象。
- en: Enumerations and constants
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举和常量
- en: Generally, C code uses enumerations and constants extensively, but we don't
    have these in Ruby. So they are mapped to constants of the `Object` class. Both
    enumerations and constants defined by the Foundation can be directly accessed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C 代码会广泛使用枚举和常量，但在 Ruby 中我们没有这些。因此，它们被映射到 `Object` 类的常量。Foundation 定义的枚举和常量都可以直接访问。
- en: 'For example, `NSNotFound` is an enumeration and we can directly access it as
    shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`NSNotFound` 是一个枚举，我们可以直接像下面这样访问它：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Also, a constant such as `AVMediaTypeAudio` can be directly accessed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像 `AVMediaTypeAudio` 这样的常量也可以直接访问。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many enumerations or constants defined in the iOS SDK that start with
    a lowercase letter, such as `kCLLocationAccuracyNearestTenMeters`, which starts
    with `k`. But since Ruby constants always begin with a capital letter, their names
    must be changed by making the lowercase of the first letter uppercase. Therefore,
    the constant from the preceding example becomes `KCLLocationAccuracyNearestTenMeters;`
    (starting with a capital `K`) in Ruby.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: iOS SDK中定义了许多以小写字母开头的枚举或常量，例如`kCLLocationAccuracyNearestTenMeters`，它以`k`开头。但由于Ruby常量总是以大写字母开头，因此它们的名称必须通过将第一个字母的小写形式转换为大写形式来更改。因此，前面示例中的常量在Ruby中变为`KCLLocationAccuracyNearestTenMeters;`（以大写`K`开头）。
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Functions
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: C functions are available as methods to be used in Ruby code in RubyMotion.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C函数可以作为RubyMotion中Ruby代码中的方法使用。
- en: For example, the `CGPointMake` function can be used in Ruby to create a rectangular
    structure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用`CGPointMake`函数在Ruby中创建一个矩形结构体。
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Many functions in the iOS SDK start with a capital letter. And there is also
    a possibility that a few of them accept no arguments; in such cases, it can create
    confusion and the compiler may treat such expressions as constants. So it is very
    important to use parentheses explicitly when calling such functions, as shown
    in the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: iOS SDK中的许多函数以大写字母开头。还有一些函数可能不接受任何参数；在这种情况下，可能会造成混淆，编译器可能会将这些表达式视为常量。因此，在调用此类函数时，显式使用括号非常重要，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Inline functions, which are implemented in the framework's header, are also
    supported by RubyMotion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion也支持在框架头文件中实现的内联函数。
- en: Structures
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: A structure is a collection of one or more variables, possibly of different
    data types, grouped together under a single name for convenient handling. To map
    C structures with Ruby, RubyMotion uses classes, which means structures can be
    created in Ruby and then passed to APIs that expect C structures. Similarly, APIs
    returning C structures will return an instance of the appropriate structure class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是一组一个或多个变量，可能具有不同的数据类型，它们在单个名称下分组，以便于处理。为了将C结构体映射到Ruby，RubyMotion使用类，这意味着可以在Ruby中创建结构体，然后将其传递给期望C结构体的API。同样，返回C结构体的API将返回适当的结构体类的实例。
- en: A structure class has an `accessor` method for each field of the corresponding
    C structure it wraps.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类为其包装的相应C结构体中的每个字段都有一个`accessor`方法。
- en: 'For example, the following piece of code creates a `CGPoint` structure, sets
    its `x` and `y` fields, and then passes it to the `drawAtPoint:withFont:` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码段创建了一个`CGPoint`结构体，设置了其`x`和`y`字段，然后将其传递给`drawAtPoint:withFont:`方法：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also pass this value directly to the constructor:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接将此值传递给构造函数：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'RubyMotion will also accept arrays for our convenience. They must contain the
    same number and type of objects expected in the structure. Here is an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion还将接受数组以方便我们使用。它们必须包含与结构体中期望的数量和类型的对象相同。以下是一个示例：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Pointers
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针
- en: C and Objective-C both commonly make use of pointers and therefore it is extensively
    used in the iOS SDK too. In the iOS SDK, pointers are usually used as arguments
    to return objects by reference. For example, the `NSData` method expects an error
    pointer that will be set to an `NSError` object in case of a failure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: C和Objective-C都普遍使用指针，因此在iOS SDK中也广泛使用。在iOS SDK中，指针通常用作返回对象的引用的参数。例如，`NSData`方法期望一个错误指针，在失败的情况下将设置为`NSError`对象。
- en: 'As there is no pointer concept in Ruby, RubyMotion uses the `Pointer` class
    in order to create and manipulate pointers. To create a new pointer, use the following
    syntax:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ruby中没有指针概念，RubyMotion使用`Pointer`类来创建和操作指针。要创建一个新的指针，请使用以下语法：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see that we have passed `char` in a `new` initializer, which will create
    a string pointer. Similarly, to create a different type of pointer, we can pass
    the following parameters in the `Pointer` class (source – [http://www.rubymotion.com/developer-center/guides/runtime/#_pointers](http://www.rubymotion.com/developer-center/guides/runtime/#_pointers)):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们在`new`初始化器中传递了`char`，这将创建一个字符串指针。同样，要创建不同类型的指针，我们可以在`Pointer`类中传递以下参数（来源
    – [http://www.rubymotion.com/developer-center/guides/runtime/#_pointers](http://www.rubymotion.com/developer-center/guides/runtime/#_pointers)）：
- en: '| C type pointer | Runtime type string | Shortcut symbol |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| C类型指针 | 运行时类型字符串 | 快捷符号 |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `id*` | `""@""` | `:object` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `id*` | `""@""` | `:object` |'
- en: '| `Char` | `""c""` | `:char` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Char` | `""c""` | `:char` |'
- en: '| `unsigned char*` | `""C""` | `:uchar` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned char*` | `""C""` | `:uchar` |'
- en: '| `short*` | `""s""` | `:short` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `short*` | `""s""` | `:short` |'
- en: '| `unsigned short*` | `""S""` | `:ushort` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short*` | `""S""` | `:ushort` |'
- en: '| `int*` | `""i""` | `:int` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `int*` | `""i""` | `:int` |'
- en: '| `unsigned int*` | `""I""` | `:uint` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int*` | `""I""` | `:uint` |'
- en: '| `long*` | `""l""` | `:long` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `long*` | `""l""` | `:long` |'
- en: '| `unsigned long*` | `""L""` | `:ulong` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long*` | `""L""` | `:ulong` |'
- en: '| `long long*` | `""q""` | `:long_long` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `long long*` | `""q""` | `:long_long` |'
- en: '| `unsigned long long*` | `""Q""` | `:ulong_long` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long*` | `""Q""` | `:ulong_long` |'
- en: '| `float` | `""f""` | `:float` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `""f""` | `:float` |'
- en: '| `double*` | `""d""` | `:double` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `double*` | `""d""` | `:double` |'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pointers to C characters, which are also called **C strings**, are automatically
    converted from and to `String` objects by RubyMotion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 指向C字符的指针，也称为**C字符串**，由RubyMotion自动从和到`String`对象转换。
- en: Classes
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: Creating a class in Ruby is simple, but since the iOS SDK is written in Objective-C,
    it is necessary to understand Objective-C interfaces and learn how to use them
    with Ruby.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中创建类很简单，但由于iOS SDK是用Objective-C编写的，因此有必要了解Objective-C接口并学习如何使用Ruby来使用它们。
- en: An Objective-C interface always starts with a minus or a plus sign, which is
    used to declare an instance or class method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C接口始终以减号或加号开头，用于声明实例或类方法。
- en: 'For example, the following interface declares the `foo` instance method on
    the `Foo` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下接口声明了`Foo`类上的`foo`实例方法：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The methods that instances of a class can use are called **instance methods**
    and are marked with a minus sign.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类实例可以使用的方法称为**实例方法**，并用减号标记。
- en: 'The following declares the `foo` class method on the same class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明了同一类上的 `foo` 类方法：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The names of the methods that can be used by class objects are preceded by a
    plus sign.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以由类对象使用的方法名称前有一个加号。
- en: 'As seen in the previous section, arguments in Objective-C methods can be named
    with a keyword. The following interface declares the `sharedInstanceWithObject:andObject:`
    class method on the `Test` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，Objective-C方法中的参数可以用关键字命名。以下接口声明了`Test`类上的`sharedInstanceWithObject:andObject:`类方法：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The corresponding Ruby method for the preceding code will be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对应的Ruby方法如下：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It will call the `sharedInstanceWithObject` method of the `Test` class, where
    `obj1` and `obj2` are variables of the arguments.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它将调用`Test`类的`sharedInstanceWithObject`方法，其中`obj1`和`obj2`是参数的变量。
- en: Objective-C messages
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C消息
- en: We can send and define Objective-C messages using RubyMotion. As Objective-C
    uses named arguments, which is unlike Ruby methods, it looks different from a
    typical Ruby method if it contains more than one argument.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用RubyMotion发送和定义Objective-C消息。由于Objective-C使用命名参数，这与Ruby方法不同，如果它包含多个参数，它看起来与典型的Ruby方法不同。
- en: Each argument in Objective-C has a keyword associated with it and the final
    Objective-C message is the combination of all these keywords.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的每个参数都与一个关键字相关联，最终的Objective-C消息是所有这些关键字的组合。
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Objective-C messages can be sent from RubyMotion using a similar syntax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似语法，RubyMotion可以从Ruby发送Objective-C消息。
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The message keywords are `colorWithRed:`, `green:`, `blue:`, and `alpha:`. The
    complete message is the combination of these keywords. If you are a Ruby developer,
    you will probably find it strange to see the colon in the Ruby code. The reason
    is that this is called a **named parameter** and it is very common in RubyMotion
    applications. As we interact a lot with Objective-C methods and these receive
    named parameters, we have to pass them in this way.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 消息关键字是`colorWithRed:`, `green:`, `blue:`, 和 `alpha:`。完整的消息是这些关键字的组合。如果你是Ruby开发者，你可能会觉得在Ruby代码中看到冒号很奇怪。原因是这被称为**命名参数**，在RubyMotion应用程序中非常常见。由于我们与Objective-C方法和这些接收命名参数互动很多，我们必须以这种方式传递它们。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The syntax used to define Objective-C selectors was added to RubyMotion and
    is not part of the Ruby standard.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义Objective-C选择器的语法是添加到RubyMotion中的，不是Ruby标准的一部分。
- en: RubyMotion selectors
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RubyMotion选择器
- en: The RubyMotion runtime provides convenient shortcuts for certain Objective-C
    selectors (source – [http://www.rubymotion.com](http://www.rubymotion.com)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion运行时为某些Objective-C选择器提供了方便的快捷方式（来源 – [http://www.rubymotion.com](http://www.rubymotion.com))。
- en: '| Selector | Shortcut |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 选择器 | 快捷方式 |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `setFoo:` | `foo=` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `setFoo:` | `foo=` |'
- en: '| `isFoo` | `foo?` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `isFoo` | `foo?` |'
- en: '| `objectForKey:` | `[]` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `objectForKey:` | `[]` |'
- en: '| `setObject:forKey:` | `[]=` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `setObject:forKey:` | `[]=` |'
- en: Memory management
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: Memory management is an important programming principle of handling the life
    cycles of objects and releasing them when they are no longer needed in your application.
    Management of object memory is necessary to have good performance; if an application
    doesn't free unneeded objects, its memory footprint grows and performance suffers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理是处理对象生命周期并在它们在应用程序中不再需要时释放它们的重要编程原则。管理对象内存对于获得良好的性能是必要的；如果一个应用程序不释放不再需要的对象，它的内存占用会增长，性能会受到影响。
- en: RubyMotion provides automatic memory management; you do not need to reclaim
    unused objects. Also, as memory in any iOS device is limited, the bad acting application
    would just be killed at some point.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion提供自动内存管理；你不需要回收未使用的对象。此外，由于任何iOS设备的内存都是有限的，表现不佳的应用程序最终会被杀死。
- en: Memory management in a Cocoa application that doesn't use garbage collection
    is based on a reference-counting method. RubyMotion also uses reference-counting
    ways to reclaim memory. When you create or copy an object, its retain count is
    `1`. Thereafter, other objects may express an ownership interest in your object,
    which increments its retain count. The owners of an object may also surrender
    their possession interest in it, which reduces the retain count. When the retain
    count becomes zero, the object is deallocated (destroyed).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用垃圾回收机制的情况下，Cocoa应用程序的内存管理基于引用计数方法。RubyMotion也使用引用计数方式来回收内存。当你创建或复制一个对象时，它的保留计数是`1`。此后，其他对象可能表达对你的对象的所有权兴趣，这会增加其保留计数。对象的所有者也可能放弃他们对它的所有权兴趣，这会减少保留计数。当保留计数变为零时，对象将被释放（销毁）。
- en: Objects created by Objective-C or the Core-Foundation-style APIs are automatically
    managed by RubyMotion. There is no need to send the retain, release, or auto-release
    messages to them, or to use the `CFRetain` or `CFRelease` functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由Objective-C或Core-Foundation风格的API创建的对象将由RubyMotion自动管理。无需向它们发送保留、释放或自动释放消息，或使用`CFRetain`或`CFRelease`函数。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let''s recap what we have just learned in this chapter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章我们所学到的内容：
- en: How Objective-C and Ruby work together
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C和Ruby如何协同工作
- en: How RubyMotion objects are inherited from Objective-C
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RubyMotion对象如何从Objective-C继承
- en: How RubyMotion interfaces with C and Objective-C
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RubyMotion如何与C和Objective-C接口
- en: Memory management offered with RubyMotion
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RubyMotion提供的内存管理
- en: In the next chapter, we will learn how we can use the **Model-View-Controller**
    (**MVC**) design principle in our RubyMotion application. We will discuss in detail
    about the MVC architecture. Later in the chapter, we will have some hands-on examples
    to learn how to integrate our mobile application with an external API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在RubyMotion应用程序中使用**模型-视图-控制器**（**MVC**）设计原则。我们将详细讨论MVC架构。在章节的后面部分，我们将有一些实际示例来学习如何将我们的移动应用程序与外部API集成。
