["```kt\n@interface PurchaseViewController : UIViewController <SKProductsRequestDelegate, SKPaymentTransactionObserver> \n... \n#import \"PurchaseViewController.h\" \n#import <StoreKit/StoreKit.h> \n... \n\n/* \n 4 In-App Purchases \n*/ \n#define kProductTipGenerous @\"EMP_TIP_JAR_GENEROUS\" \n#define kProductTipMassive @\"EMP_TIP_JAR_MASSIVE\" \n#define kProductTipAmazing @\"EMP_TIP_JAR_AMAZING\" \n@implementation PurchaseViewController \n... \n```", "```kt\n@synthesize scene; \n\n- (void)viewDidLoad { \n    [super viewDidLoad]; \n\n    [Flurry logEvent:analyticsPurchaseViewShown];  \n... \n    [self loadProductsFromStore]; \n} \n\n-(void)loadProductsFromStore{  \n    if([SKPaymentQueue canMakePayments]){ \n        NSLog(@\"User can make payments\");  \nSKProductsRequest *productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:[NSSet setWithObjects: \nkProductColorfulWorld,      \n      kProductTipGenerous,  \n      kProductTipMassive,  \n      ProductTipAmazing, nil]]; \n\n        productsRequest.delegate = self; \n        [productsRequest start]; \n    } \n    else {  \n        NSLog( @\"User cannot make payments,  \n                 perhaps due to parental controls\"); \n    } \n} \n```", "```kt\n- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response{     \n    if (self.view == nil){ \n        return; \n    } \n\n    SKProduct *validProduct = nil; \n    int count = (int)[response.products count];  \n    products = response.products;  \n    if(count > 0){  \n        validProduct = [response.products objectAtIndex:0]; \n        NSLog(@\"Products Available!\"); \n        ...  \n        for (SKProduct* product in products){ \n            [self enableProductPurchaseOption:product]; \n        } \n    } \n    else if(!validProduct){ \n        NSLog(@\"No products available\"); \n    } \n} \n\n-(void)enableProductPurchaseOption:(SKProduct*)product{ \n\n if ([product.productIdentifier    \n       isEqualToString:kProductTipGenerous]){ \n        [nameGenerous setEnabled:YES]; \n        [priceGenerous setEnabled:YES]; \n       [nameGenerous setTitle: @\"Generous donation\"  \n      forState:UIControlStateNormal]; \n      [priceGenerous setTitle: product.price.stringValue                            forState:(UIControlStateNormal)]; \n      } \n ...     \nif ([product.productIdentifier isEqualToString:kProductTipAmazing]){ \n        [nameAmazing setEnabled:YES]; \n        [priceAmazing setEnabled:YES]; \n        [nameAmazing setTitle: @\"Amazing donation\"  \n          forState:UIControlStateNormal]; \n        [priceAmazing setTitle: product.price.stringValue      \n          forState:(UIControlStateNormal)]; \n      } \n    }  \n```", "```kt\n-(void)purchase:(SKProduct *)product{ \n\n    if (products==nil || products.count==0){ \n        return; \n    } \n    SKPayment *payment = [SKPayment paymentWithProduct:product]; \n    [[SKPaymentQueue defaultQueue] addTransactionObserver:self]; \n    [[SKPaymentQueue defaultQueue] addPayment:payment]; \n} \n\n- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions{ \n\n    for(SKPaymentTransaction *transaction in transactions){ \n\n        switch(transaction.transactionState){ \n            case SKPaymentTransactionStatePurchasing: \n                NSLog(@\"Transaction state -> Purchasing\"); \n                //called when the user is in the process of  \n          purchasing. \n                break; \n\n            case SKPaymentTransactionStatePurchased: \n                //this is called when the user has successfully  \n          purchased the package  \n                [self enablePurchaseProduct:  \n         transaction.payment.productIdentifier]; \n\n                [[SKPaymentQueue defaultQueue]  \n         finishTransaction:transaction]; \n                NSLog(@\"Transaction state -> Purchased\");  \n                break; \n\n            case SKPaymentTransactionStateRestored:  \n                NSLog(@\"Transaction state -> Restored\"); \n                [self enablePurchaseProduct:  \n         transaction.payment.productIdentifier]; \n                [[SKPaymentQueue defaultQueue]  \n         finishTransaction:transaction];  \n                break; \n\n            case SKPaymentTransactionStateFailed:  \n                if(transaction.error.code ==  \n           SKErrorPaymentCancelled){ \n                    NSLog(@\"Transaction state -> Cancelled\");  \n                } \n                [[SKPaymentQueue defaultQueue]  \n          finishTransaction:transaction];  \n                break; \n            default: \n                break; \n        } \n    } \n} \n```", "```kt\n- (void)restore{ \n    [[SKPaymentQueue defaultQueue] restoreCompletedTransactions]; \n} \n```", "```kt\n- (void) paymentQueueRestoreCompletedTransactionsFinished: (SKPaymentQueue *)queue \n{ \n    NSLog(@\"received restored transactions: %lu\", (unsigned  \n     long)queue.transactions.count); \n\n    for(SKPaymentTransaction *transaction in queue.transactions){ \n        if(transaction.transactionState ==  \n         SKPaymentTransactionStateRestored){  \n            //called when the user successfully restores a purchase \n            NSLog(@\"Transaction state -> Restored\"); \n            [self enablePurchaseProduct:  \n             transaction.payment.productIdentifier]; \n            [[SKPaymentQueue defaultQueue]   \n             finishTransaction:transaction]; \n            break; \n        } \n... \n    }    \n} \n```"]