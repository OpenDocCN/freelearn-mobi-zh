- en: Menus and Action Mode
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单和动作模式
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an options menu
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建选项菜单
- en: Modifying menus and menu items during runtime
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时修改菜单和菜单项
- en: Enabling Contextual Action Mode for a view
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为视图启用上下文动作模式
- en: Using Contextual Batch Mode with `RecyclerView`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `RecyclerView` 的上下文批量模式
- en: Creating a pop-up menu
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建弹出式菜单
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'The Android OS is an ever-changing environment. The earliest Android devices
    (prior to Android 3.0), were required to have a hardware menu button. Though a
    hardware button is no longer required, menus are no less important. In fact, the
    Menu API has expanded to now support three different types of menus:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Android 操作系统是一个不断变化的环境。最早的 Android 设备（在 Android 3.0 之前），需要有一个硬件菜单按钮。尽管硬件按钮不再需要，但菜单同样重要。事实上，菜单
    API 已经扩展到现在支持三种不同类型的菜单：
- en: '**Options menu and action bar**: This is the standard menu, which is used for
    global options of your application. Use this for additional features such as search,
    settings, and so on.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项菜单和操作栏**：这是标准菜单，用于应用程序的全局选项。用于搜索、设置等附加功能。'
- en: '**Contextual****Mode** (**Contextual Action Mode**): This is generally activated
    by a long press. (Think of this as similar to a right-click on the desktop.) This
    is used to take an action on the pressed item, such as replying to an email or
    deleting a file.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文模式**（**上下文动作模式**）：这通常通过长按激活。（想想这就像桌面上的右键点击。）这用于对按下的项执行操作，例如回复电子邮件或删除文件。'
- en: '**Pop-up m****enu**: This provides a pop-up selection (like a spinner) for
    an additional action. The menu options are not meant to affect the item pressed;
    instead, use Contextual Mode as described previously. An example would be hitting
    the share button and getting an additional list of share options.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹出式菜单**：这为附加操作提供了一个弹出式选择（类似于旋转框）。菜单选项不旨在影响按下的项；相反，使用前面描述的上下文模式。一个例子是点击分享按钮并获取额外的分享选项列表。'
- en: Menu resources are similar to other Android UI components; they are generally
    created in XML, but can be created in code as well. Our first recipe, as shown
    in the following section, will show the XML menu format and how to inflate it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单资源与其他 Android UI 组件类似；它们通常在 XML 中创建，但也可以在代码中创建。我们将在下一节中展示的第一个菜谱将展示 XML 菜单格式以及如何展开它。
- en: Creating an options menu
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建选项菜单
- en: 'Before we actually create and display a menu, let''s look at a menu to see
    the end result. The following is a screenshot showing the menu section of the
    Chrome app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际创建和显示菜单之前，让我们看看一个菜单以查看最终结果。以下是一个显示 Chrome 应用程序菜单部分的屏幕截图：
- en: '![](img/04c89fb1-5c84-4baa-80dd-6559f969fbe7.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04c89fb1-5c84-4baa-80dd-6559f969fbe7.png)'
- en: The most obvious feature to note is that the menu will look different based
    on the screen size. By default, menu items will be added to the overflow menu—that's
    the menu you see when you press the three dots at the far right edge.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的特点是菜单将根据屏幕大小而有所不同。默认情况下，菜单项将被添加到溢出菜单中——这就是你按下最右边边缘的三个点时看到的菜单。
- en: 'Menus are typically created in resource files using XML (like many other Android
    resources) stored in the `res/menu` directory, though they can also be created
    in code. To create a menu resource, use the `<menu>` element as shown:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单通常使用 XML（像许多其他 Android 资源）在 `res/menu` 目录中创建，尽管它们也可以在代码中创建。要创建菜单资源，请使用如下所示的
    `<menu>` 元素：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `<item>` element defines each individual menu item and is enclosed in the
    `<menu>` element. A basic menu item looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`<item>` 元素定义了每个单独的菜单项，并包含在 `<menu>` 元素中。一个基本的菜单项看起来如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The most common `<item>` attributes are the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 `<item>` 属性如下：
- en: '`id`: This is the standard resource identifier'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是标准资源标识符'
- en: '`title`: This indicates the text to display'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这表示要显示的文本'
- en: '`icon`: This is a drawable resource'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icon`：这是一个可绘制资源'
- en: '`showAsAction`: This is explained in the following paragraph'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showAsAction`：这将在以下段落中解释'
- en: '`enabled`: This is enabled by default'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`：默认情况下是启用的'
- en: Let's look at `showAsAction` in more detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `showAsAction`。
- en: The `showAsAction` attribute controls how the menu item is shown. The options
    include
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`showAsAction` 属性控制菜单项的显示方式。选项包括'
- en: 'the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容：
- en: '`ifRoom`: This menu item should be included in the action bar if there''s enough
    space'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifRoom`：如果空间足够，此菜单项应包含在操作栏中'
- en: '`withText`: This indicates that both the title and the icon should be shown'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withText`：这表示标题和图标都应该显示'
- en: '`never`: This indicates that the menu item should never be included in the
    action bar; it is always shown in the overflow menu'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never`：这表示菜单项永远不会包含在操作栏中；它始终显示在溢出菜单中'
- en: '`always`: This indicates that the menu item should be always included in the
    action bar (use sparingly as space is limited)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`：这表示菜单项应始终包含在操作栏中（请谨慎使用，因为空间有限）'
- en: Multiple options can be combined using the pipe (`|`) separator, such as `showAsAction="ifRoom|withText"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用管道（`|`）分隔符组合多个选项，例如`showAsAction="ifRoom|withText"`。
- en: With the fundamentals of the menu resource covered, we are now ready to create
    a standard options menu and inflate it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了菜单资源的基础知识后，我们现在可以创建一个标准选项菜单并填充它。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use Android Studio to create a new project called `OptionsMenu`. Use the default
    Phone & Tablet option and select the Empty Activity option when prompted for the
    Activity Type. The Android Studio wizard does not create the `res/menu` folder
    by default. You can create it manually using File | New | Directory, or create
    it using the Android Resource Directory wizard.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android Studio创建一个名为`OptionsMenu`的新项目。使用默认的“手机和平板”选项，并在提示活动类型时选择“空活动”选项。Android
    Studio向导默认不会创建`res/menu`文件夹。您可以通过使用文件 | 新建 | 目录手动创建它，或者使用Android资源目录向导创建它。
- en: 'Here are the steps to use the wizard:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用向导的步骤：
- en: 'First, right-click on the `res` folder and select New | Android Resource Directory
    as shown here:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`res`文件夹上右键单击，并选择如这里所示的“新建 | Android资源目录”：
- en: '![](img/2222d1e5-7528-4228-9a49-dfd8f015422d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2222d1e5-7528-4228-9a49-dfd8f015422d.png)'
- en: 'On the New Resource Directory dialog, select the Resource type drop-down menu
    and choose the menu option:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“新建资源目录”对话框中，选择资源类型下拉菜单并选择菜单选项：
- en: '![](img/ce9f1789-d9d2-43d9-a5a4-7f951d391464.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce9f1789-d9d2-43d9-a5a4-7f951d391464.png)'
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the new project created as described in the preceding section, you are
    ready to create a menu. First, we will add a string resource to `strings.xml`.
    We will use the new string for the menu title when we create the XML for the menu.
    Here are the steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述创建的新项目，您现在可以创建一个菜单。首先，我们将向`strings.xml`添加一个字符串资源。当创建菜单的XML时，我们将使用这个新字符串作为菜单标题。以下是步骤：
- en: 'Start by opening the `strings.xml` file and adding the following `<string>`
    element to the `<resources>` element:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`strings.xml`文件，并在`<resources>`元素中添加以下`<string>`元素：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a new file in the `res/menu` directory and call it `menu_main.xml`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/menu`目录下创建一个新文件，并将其命名为`menu_main.xml`。
- en: 'Open the `menu_main.xml` file and add the following XML to define the menu:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`menu_main.xml`文件，并添加以下XML以定义菜单：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the menu now defined in the XML, we just have to override the `onCreateOptionsMenu()`
    method in `ActivityMain.java` to inflate the menu:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在菜单已在XML中定义，我们只需在`ActivityMain.java`中重写`onCreateOptionsMenu()`方法来填充菜单：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the program on a device or emulator to see the menu in the action bar.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序，以查看操作栏中的菜单。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are two basic steps here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个基本步骤：
- en: Define the menu in XML
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XML中定义菜单
- en: Inflate the menu when the activity is created
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动创建时填充菜单
- en: As a good programming habit, we define the string in the `strings.xml` file
    rather than hard coding it in the XML. We then use the standard Android string
    identifier to set the title for the menu in step 3\. Since this is a Settings
    menu item, we used the `showAsAction="never"` option so it wouldn't be shown as
    an individual menu option in the action bar.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的编程习惯，我们应在`strings.xml`文件中定义字符串，而不是在XML中硬编码它。然后，我们在第3步使用标准的Android字符串标识符来设置菜单的标题。由于这是一个设置菜单项，我们使用了`showAsAction="never"`选项，这样它就不会在操作栏中作为一个单独的菜单选项显示。
- en: With the menu defined, we will use the menu inflater in step 4 to load the menu
    during the activity creation. Notice the `R.menu.menu_main` menu resource syntax?
    This is why we create the XML in the `res/menu` directory—so the system will know
    this is a menu resource.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单定义后，我们将在第4步使用菜单填充器在活动创建时加载菜单。注意`R.menu.menu_main`菜单资源语法？这就是为什么我们在`res/menu`目录中创建XML的原因——这样系统就会知道这是一个菜单资源。
- en: 'In step 4, we used `app:showAsAction` rather than Android: `android:showAsAction`.
    This is because we are using the `AppCompat` library (also referred to as the
    Android Support Library). By default, the Android Studio new project wizard includes
    the support library in the project.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步，我们使用了`app:showAsAction`而不是Android的`android:showAsAction`。这是因为我们正在使用`AppCompat`库（也称为Android支持库）。默认情况下，Android
    Studio的新项目向导会将支持库包含在项目中。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you ran the program in step 5, then you must have seen the Settings menu
    item when you pressed the menu overflow button. But that was it. Nothing else
    happened. Obviously, menu items aren't very useful if the application doesn't
    respond to them. Responding to the Options menu is done through the `onOptionsItemSelected()`
    callback.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在第 5 步中运行了程序，那么当你按下菜单溢出按钮时，你必须已经看到了设置菜单项。但仅此而已。没有其他发生。显然，如果应用程序没有对这些菜单项做出响应，菜单项就没什么用了。通过
    `onOptionsItemSelected()` 回调来响应选项菜单。
- en: 'Add the following method to the application to see a Toast when the Settings
    menu is selected:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到应用程序中，当选择设置菜单时显示 Toast：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it. You now have a working menu!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你现在有一个可以工作的菜单了！
- en: As shown in the preceding example, return `true` when you've handled the callback;
    otherwise, call the super class as shown in the `else` statement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，当处理回调时返回 `true`；否则，如 `else` 语句所示，调用超类。
- en: Using a menu item to launch an activity
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用菜单项启动活动
- en: In the above example, we show a Toast in response to the menu click; however,
    we could just as easily launch a new activity if needed. To start an activity, create
    an Intent and call it with `startActivity()` as shown in the *Starting a new activity
    with an Intent object* recipe in [Chapter 1](ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml), *Activities.*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们展示了在菜单点击时显示的 Toast；然而，如果需要，我们也可以轻松地启动一个新的活动。要启动一个活动，创建一个 Intent 并使用
    `startActivity()` 调用它，如[第 1 章](ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml)中“使用
    Intent 对象启动新活动”菜谱所示，*活动*。
- en: Creating submenus
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子菜单
- en: '**Submenus** are created and accessed in almost exactly the same manner as
    other menu elements. They can be placed in any of the provided menus but not within
    other submenus. To define a submenu, include a `<menu>` element within an `<item>`
    element. Here is the XML for this recipe with two submenu items added:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**子菜单**的创建和访问几乎与其他菜单元素完全相同。它们可以放置在任何提供的菜单中，但不能放置在其他子菜单中。要定义子菜单，请在 `<item>`
    元素内包含一个 `<menu>` 元素。以下是此菜谱的 XML，其中添加了两个子菜单项：'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Grouping menu items
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对菜单项进行分组
- en: 'Another menu feature that Android supports is grouping menu items. Android
    provides several methods for groups, including the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持的另一个菜单功能是对菜单项进行分组。Android 为分组提供了几个方法，包括以下内容：
- en: '`setGroupVisible()`: Show or hide all items'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGroupVisible()`: 显示或隐藏所有项'
- en: '`setGroupEnabled()`: Enable or disable all items'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGroupEnabled()`: 启用或禁用所有项'
- en: '`setGroupCheckable()`: Set the checkable behavior'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGroupCheckable()`: 设置可勾选行为'
- en: Android will keep all grouped items with `showAsAction="ifRoom"` together. This
    means all items in the group with `showAsAction="ifRoom"` will be in the action
    bar or all items will be in the overflow.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Android 会将所有带有 `showAsAction="ifRoom"` 的分组项一起保留。这意味着组中所有带有 `showAsAction="ifRoom"`
    的项都将位于操作栏中，或者所有项都将位于溢出菜单中。
- en: 'To create a group, add the `<item>` menu elements to a `<group>` element. Here
    is an example using the menu XML from this recipe with two additional items in
    a group:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个分组，将 `<item>` 菜单元素添加到 `<group>` 元素中。以下是一个示例，使用此菜谱中的菜单 XML，并在一个分组中添加了两个额外的项：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: For complete details on the menu, visit the Android Developer Menu Resources
    site at [http://developer.android.com/guide/topics/resources/menu-resource.html](http://developer.android.com/guide/topics/resources/menu-resource.html)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关菜单的完整详细信息，请访问 Android 开发者菜单资源网站 [http://developer.android.com/guide/topics/resources/menu-resource.html](http://developer.android.com/guide/topics/resources/menu-resource.html)
- en: Modifying menus and menu items during runtime
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时修改菜单和菜单项
- en: Though it's been stated many times it's considered the *best* programming practice
    to create UIs in XML rather than in Java, there are still times when using code
    is the better option. This is especially true if you wanted a menu item to be
    visible (or enabled) based on some external criteria. Menus can also be included
    in resource folders, but there are times when you need code to perform the logic
    of which resource to use. One example might be if you wanted to offer an upload
    menu item only if the user is logged in to your app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经多次声明，但创建 UI 的最佳编程实践是在 XML 中而不是在 Java 中进行，但仍然有使用代码是更好的选择的时候。这尤其适用于你希望菜单项根据某些外部标准可见（或启用）的情况。菜单也可以包含在资源文件夹中，但有时你需要代码来执行选择哪个资源的逻辑。一个例子可能是，如果你只想在用户登录你的应用程序时提供上传菜单项。
- en: In this recipe, we will create and modify the menu only through code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将仅通过代码创建和修改菜单。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `RuntimeMenu` using the default
    Phone & Tablet option. Select the Empty Activity option when prompted to add an
    activity. Since we will create and modify the menu completely in code, we will
    not need to create a
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `RuntimeMenu`，使用默认的“电话和平板电脑”选项。当被提示添加活动时，选择“空活动”选项。由于我们将在代码中完全创建和修改菜单，因此我们不需要创建
- en: '`res/menu` directory.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`res/menu` 目录。'
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start, we will add string resources for our menu items and a button to toggle
    the menu visibility. Open the `res/strings.xml` file and follow these steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的菜单项和切换菜单可见性的按钮添加字符串资源。打开 `res/strings.xml` 文件并按照以下步骤操作：
- en: 'Add the following two strings to the existing `<resources>` element:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下两个字符串添加到现有的 `<resources>` 元素中：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Delete the existing `TextView` and add a button to `activity_main.xml` with
    `onClick()` set to `toggleMenu` as shown here:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除现有的 `TextView` 并在 `activity_main.xml` 中添加一个按钮，将其 `onClick()` 设置为 `toggleMenu`，如下所示：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open `ActivityMain.java` and add the following three lines of code just below
    the class declaration:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ActivityMain.java` 并在类声明下方添加以下三行代码：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following method for the button click callback:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮点击回调添加以下方法：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the activity is first created, Android calls `onCreateOptionsMenu()` to
    create the menu. Here is the code to dynamically build the menu:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当活动首次创建时，Android 会调用 `onCreateOptionsMenu()` 来创建菜单。以下是动态构建菜单的代码：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For best programming practice, don''t use `onCreateOptionsMenu()` to update
    or change your menu; instead, use `onPrepareOptionsMenu()`. Here is the code to
    change the visibility of the Download menu item based on our flag:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最佳编程实践，不要使用 `onCreateOptionsMenu()` 来更新或更改您的菜单；相反，使用 `onPrepareOptionsMenu()`。以下是根据我们的标志更改下载菜单项可见性的代码：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Though not technically required for this recipe, this `onOptionsItemSelected()`
    code shows how to respond to each menu item:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然此配方中技术上不需要此 `onOptionsItemSelected()` 代码，但它显示了如何响应每个菜单项：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program on a device or emulator to see the menu changes.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序以查看菜单更改。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created an override for `onCreateOptionsMenu()`, just like we did in the
    previous recipe, *Creating an options menu*. But instead of inflating an existing
    menu resource, we created the menu using the `Menu.add()` method. Since we want
    to modify the menu items later as well as respond to the menu item events, we
    defined our own menu IDs and passed them to the `add()` method. The `onOptionsItemSelected()` object
    is called for all the menu items, so we get the menu ID and use a `switch` statement
    based on the ID. We return `true` if we are handling the menu event, otherwise
    we pass the event to the super class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `onCreateOptionsMenu()` 方法创建了一个覆盖，就像我们在之前的配方中做的那样，*创建一个选项菜单*。但是，我们不是展开现有的菜单资源，而是使用
    `Menu.add()` 方法创建菜单。由于我们希望在以后也修改菜单项以及响应菜单项事件，我们定义了自己的菜单 ID 并将它们传递给 `add()` 方法。`onOptionsItemSelected()`
    对象会为所有菜单项调用，因此我们获取菜单 ID 并根据 ID 使用 `switch` 语句。如果我们正在处理菜单事件，则返回 `true`，否则将事件传递给父类。
- en: Changing the menu occurs in the `onPrepareOptionsMenu()` method. To simulate
    an external event, we created a button to toggle a Boolean flag. The visibility
    of the Download menu is determined by the flag. This is where you would want to
    create your custom code based on whatever criteria you set. Your flag could be
    set using the current player level or maybe when a new level is ready for release,
    you send a push message to enable the menu item.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单更改发生在 `onPrepareOptionsMenu()` 方法中。为了模拟外部事件，我们创建了一个按钮来切换布尔标志。下载菜单的可见性由该标志确定。这就是您根据您设置的任何标准创建自定义代码的地方。您可以使用当前玩家级别设置标志，或者当新级别准备发布时，您发送推送消息以启用菜单项。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'What if we wanted the Download option to stand out when it''s available? We
    could tell Android we want the menu in the action bar by adding the following
    code to `onPrepareOptionsMenu()` (before the return statement):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望当下载选项可用时使其突出显示，我们可以通过在 `onPrepareOptionsMenu()` 方法（在返回语句之前）添加以下代码来告诉 Android
    我们希望在操作栏中显示菜单：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now if you run the code, you will see the Download menu item in the action bar,
    but the behavior isn't correct.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您运行代码，您将在操作栏中看到下载菜单项，但行为并不正确。
- en: 'Earlier, when we didn''t have a menu item in the action bar, Android called
    `onPrepareOptionsMenu()` each time we opened the overflow menu so the visibility
    was always updated. To correct this behavior, add the following line of code to
    the `toggleMenu()` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 早期，当我们动作栏中没有菜单项时，每次打开溢出菜单，Android都会调用`onPrepareOptionsMenu()`来确保可见性总是更新。为了纠正这种行为，请将以下代码行添加到`toggleMenu()`方法中：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `invalidateOptionsMenu()` call tells Android that our option menu is no
    longer valid, which then forces a call to `onPrepareOptionsMenu()`, giving us
    the behavior we expect.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`invalidateOptionsMenu()`调用告诉Android我们的选项菜单不再有效，这会强制调用`onPrepareOptionsMenu()`，从而得到我们期望的行为。'
- en: Android considers the menu as always open if a menu item is displayed in the
    action bar.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动作栏中显示菜单项，Android认为菜单始终是打开的。
- en: Enabling Contextual Action Mode for a view
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为视图启用上下文操作模式
- en: 'A context menu provides additional options related to a specific view—the same
    concept as a right-click on the desktop. Android currently supports two different
    approaches: the floating context menu and Contextual Mode. Contextual Action Mode
    was introduced in Android 3.0\. The older floating context menu could lead to
    confusion since there was no indication of the currently selected item and it
    didn''t support actions on multiple items—such as selecting multiple emails to
    delete in one action.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文菜单提供与特定视图相关的附加选项——这与桌面上的右键单击相同的概念。Android目前支持两种不同的方法：浮动上下文菜单和上下文模式。上下文操作模式在Android
    3.0中引入。较旧的浮动上下文菜单可能导致混淆，因为没有指示当前选中的项，并且它不支持对多个项的操作——例如，在一次操作中删除多个电子邮件。
- en: Creating a floating context menu
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建浮动上下文菜单
- en: If you need to use the old-style context menu, for example to support pre-Android
    3.0 devices, it's very similar to the Option Menu API, you just different method
    names. To create the menu, use `onCreateContextMenu()` instead of `onCreateOptionsMenu()`.
    To handle the menu item selection, use `onContextItemSelected()` instead of `onOptionsItemSelected()`.
    Finally, call `registerForContextMenu()` to let the system know you want context
    menu events for the view.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要使用旧式上下文菜单，例如为了支持Android 3.0之前的设备，它与选项菜单API非常相似，只是方法名不同。要创建菜单，请使用`onCreateContextMenu()`而不是`onCreateOptionsMenu()`。要处理菜单项选择，请使用`onContextItemSelected()`而不是`onOptionsItemSelected()`。最后，调用`registerForContextMenu()`以让系统知道您想要上下文菜单事件。
- en: Since Contextual Mode is considered the preferred way to display context options,
    this recipe will focus on the newer API. Contextual Mode offers the same features
    as the floating context menu, but also adds additional functionality by allowing
    multiple item selection when using batch mode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上下文模式被认为是显示上下文选项的首选方式，本食谱将重点关注较新的API。上下文模式提供了与浮动上下文菜单相同的特性，但通过允许在批量模式下进行多项选择，还增加了额外的功能。
- en: This recipe will demonstrate the setup of Contextual Mode for a single view.
    Once activated, with a long press in our example, a **contextual action bar**
    (**CAB**) will replace the action bar until Contextual Mode is finished.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将演示为单个视图设置上下文模式。一旦激活，在我们的示例中，通过长按，一个**上下文操作栏**（**CAB**）将替换动作栏，直到上下文模式完成。
- en: The CAB is not the same as the action bar and your activity does not need to
    include an action bar.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CAB与动作栏不同，您的活动不需要包含动作栏。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use Android Studio to create a new project and call it `ContextualMode`. Use
    the default Phone & Tablet option and select Empty Activity when prompted to add
    an activity. Create a menu directory (`res/menu`) as we did in the first recipe,
    *Creating an options menu*, to store the XML for the contextual menu.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android Studio创建一个新项目，并将其命名为`ContextualMode`。使用默认的“手机和平板电脑”选项，并在提示添加活动时选择“空活动”。创建一个菜单目录（`res/menu`），就像我们在第一个食谱“创建选项菜单”中所做的那样，以存储上下文菜单的XML。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create `ImageView` to serve as the host view to initialize Contextual
    Mode. Since Contextual Mode is usually triggered with a long press, we will set
    up a long click listener in `onCreate()` for `ImageView`. When called, we will
    start Contextual Mode and pass an `ActionMode` callback to handle the Contextual
    Mode events. Here are the steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`ImageView`作为上下文模式的宿主视图以初始化上下文模式。由于上下文模式通常通过长按触发，我们将在`onCreate()`中为`ImageView`设置一个长按监听器。当被调用时，我们将启动上下文模式，并传递一个`ActionMode`回调来处理上下文模式事件。以下是步骤：
- en: 'We will start by adding two new string resources. Open the `strings.xml` file
    and add the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先添加两个新的字符串资源。打开`strings.xml`文件并添加以下内容：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the strings created, we can now create the menu by creating a new file
    in `res/menu` called `context_menu.xml` using the following XML:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了字符串后，我们现在可以通过在 `res/menu` 中创建一个名为 `context_menu.xml` 的新文件来创建菜单，如下所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now add `ImageView` to `activity_main.xml` to serve as the source for initiating
    Contextual Mode. Here is the XML for `ImageView`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将 `ImageView` 添加到 `activity_main.xml` 中，作为启动上下文模式的来源。以下是 `ImageView` 的 XML：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the UI now set up, we can add the code for Contextual Mode. First, we
    need a global variable to store the `ActionMode` instance returned when we call
    `startActionMode()`. Add the following line of code to `MainActivity.java` below
    the class constructor:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在UI已经设置好了，我们可以添加上下文模式的代码。首先，我们需要一个全局变量来存储在调用 `startActionMode()` 时返回的 `ActionMode`
    实例。将以下行代码添加到 `MainActivity.java` 中的类构造函数下方：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, create an `ActionMode` callback to pass to `startActionMode().` Add the
    following code to the `MainActivity` class below the code in the previous step:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `ActionMode` 回调并将其传递给 `startActionMode()`。在以下 `MainActivity` 类的上一行代码下方添加以下代码：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the `ActionMode` callback created, we just need to call `startActionMode()`
    to begin Contextual Mode. Add the following code to the `onCreate()` method to
    set up the long click listener:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了 `ActionMode` 回调后，我们只需调用 `startActionMode()` 以开始上下文模式。将以下代码添加到 `onCreate()`
    方法中以设置长按监听器：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program on a device or emulator to see the CAB in action.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序，以查看 CAB 的实际效果。
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you saw in step 2, we used the same menu XML to define the contextual menu
    as the other menus.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第 2 步中看到的，我们使用了相同的菜单 XML 来定义上下文菜单和其他菜单。
- en: 'The main piece of code to understand is the `ActionMode` callback. This is
    where we handle the Contextual Mode events: initializing the menu, handling menu
    item selections, and cleaning up. We start Contextual Mode in the long press event
    with a call to `startActionMode()` by passing in the `ActionMode` callback created
    in step 5.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的主要代码片段是 `ActionMode` 回调。这是我们处理上下文模式事件的地方：初始化菜单、处理菜单项选择和清理。我们在长按事件中使用 `startActionMode()`
    调用并传入第 5 步中创建的 `ActionMode` 回调来启动上下文模式。
- en: When action mode is triggered, the system calls the `onCreateActionMode()` callback,
    which inflates the menu and displays it in the CAB. The user can dismiss the CAB
    by pressing the back arrow or the back key. The CAB is also dismissed when the
    user makes a menu selection. We show a Toast to give a visual feedback for this
    recipe but this is where you would implement your functionality.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发操作模式时，系统调用 `onCreateActionMode()` 回调，该回调填充菜单并在 CAB 中显示它。用户可以通过按返回箭头或返回键来取消
    CAB。当用户进行菜单选择时，CAB 也会被取消。我们在这里显示一个 Toast 以提供视觉反馈，但这是你实现功能的地方。
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this example, we store `ActionMode` returned from the `startActionMode()`
    call. We use it to prevent a new instance from being created when the Action Mode
    is already active. We could also use this instance to make changes to the CAB
    itself, such as changing the title with the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们存储了从 `startActionMode()` 调用返回的 `ActionMode`。我们使用它来防止在 Action Mode 已经激活时创建新的实例。我们也可以使用这个实例来对
    CAB 本身进行更改，例如使用以下方式更改标题：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is particularly useful when working with multiple item selections as we'll
    see in the next recipe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这在处理多个项目选择时特别有用，正如我们在下一道菜谱中将要看到的。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the next recipe, *Using Contextual Batch Mode with RecyclerView*, to work
    with multiple item selection
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看下一道菜谱，*使用 RecyclerView 的上下文批量模式*，以处理多个项目选择
- en: Using Contextual Batch Mode with RecyclerView
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RecyclerView 的上下文批量模式
- en: 'As discussed in the previous recipe, Contextual Mode supports two forms of
    use: single View mode (as demonstrated) and multiple selection (or batch) mode.
    Batch mode is where Contextual Mode outperforms the old-style context menu as
    multiple selections were not supported.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一道菜谱中讨论的，上下文模式支持两种使用形式：单视图模式（如演示所示）和多个选择（或批量）模式。批量模式是上下文模式优于旧式上下文菜单的地方，因为旧式上下文菜单不支持多个选择。
- en: 'If you''ve ever used an email app such as Gmail or a file browser, you''ve
    probably seen Contextual Mode when selecting multiple items. Here is a screenshot
    from Solid Explorer, which shows an excellent implementation of Material Theme
    and Contextual Mode:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过像 Gmail 或文件浏览器这样的电子邮件应用，你可能在选择多个项目时见过上下文模式。以下是从 Solid Explorer 中的截图，展示了
    Material 主题和上下文模式的优秀实现：
- en: '![](img/85d5a22f-ca2c-4c51-903a-3257d12c4c78.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85d5a22f-ca2c-4c51-903a-3257d12c4c78.png)'
- en: When we introduced `RecyclerView` in [Chapter 2](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml),
    *Layouts*, we discussed how many features from the old `ListView` were not already
    included in the new `RecyclerView`. Multiple item selection is one of the most
    missed features. In this recipe, we will demonstrate multiple item selection with
    the `RecyclerView` using Action Mode.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第2章](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml)*布局*中介绍`RecyclerView`时，我们讨论了旧`ListView`中的许多功能并未包含在新`RecyclerView`中。多项选择是最受欢迎的功能之一。在本菜谱中，我们将使用`RecyclerView`和Action
    Mode演示多项选择。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the `RecyclerView` example created in [Chapter 2](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml)*,
    Layouts* as the base for this recipe. If you have not already done so, go back
    to the *RecyclerView replaces ListView *recipe in that chapter*,* then add the
    menu directory (`res/menu`) for the contextual menu as demonstrated previously.
    From this point, you can perform the following steps to add multiple item selection
    to `RecyclerView`. The project will be called `RecyclerViewActionMode`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[第2章](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml)*布局*中创建的`RecyclerView`示例作为本菜谱的基础。如果您还没有这样做，请回到该章节中的*RecyclerView替换ListView*菜谱，然后添加之前演示的上下文菜单目录（`res/menu`）。从这一点开始，您可以执行以下步骤以将多项选择添加到`RecyclerView`。项目将被称为`RecyclerViewActionMode`。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll be combining several concepts already learned in previous recipes to
    enable multiple item selection with `RecyclerView`. We''ll start by adding the
    menu and related code, then modify the `RecyclerView` item to show the state selection.
    Finally, we''ll modify the `RecyclerView` adapter to support click notification,
    which will start Action Mode. Here are the steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结合之前菜谱中已经学到的几个概念，以使用`RecyclerView`实现多项选择。我们将首先添加菜单和相关代码，然后修改`RecyclerView`项以显示状态选择。最后，我们将修改`RecyclerView`适配器以支持点击通知，这将启动Action
    Mode。以下是步骤：
- en: 'Open the `strings.xml` file and add two new string resources for the menu items
    as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`strings.xml`文件，并添加两个新的字符串资源用于菜单项，如下所示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new file called `contextual_menu.xml` in the `res/menu` folder with
    the following XML:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/menu`文件夹中创建一个名为`contextual_menu.xml`的新文件，内容如下所示：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, add a new file to the `res/drawable` folder called `item_selector.xml`
    with the following XML:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`res/drawable`文件夹中添加一个名为`item_selector.xml`的新文件，内容如下所示：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open the `item.xml` file in `res/layout` and add the following line to the
    `LinearLayout`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout`中的`item.xml`文件，并在`LinearLayout`中添加以下行：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, create a new Java file called `SelectMode` to server as the click event
    interface. The code is as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`SelectMode`的新Java文件，作为点击事件接口。代码如下：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now open the `MyAdapter` file and add `implements SelectMode` to the class.
    The final result will be as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`MyAdapter`文件，并将`implements SelectMode`添加到类中。最终结果如下：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the `onSelect` method to the class using the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码向类中添加`onSelect`方法：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following declaration to the class to hold the list of selected items:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下声明以保存所选项目的列表：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll add another method to the adapter to handle the actual `delete` method
    called from the Action Mode:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在适配器中添加另一个方法来处理从Action Mode调用的实际`delete`方法：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The final change to make to the `MyAdapter` class is to replace the existing
    `onClick()` . The final code will be as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`MyAdapter`类的最后修改是替换现有的`onClick()`。最终代码如下：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we have the menu created and the adapter updated, we need to hook
    it all up in the `MainActivity` class. To start, modify the `MainActivity` declaration
    to implement the `SelectMode` interface. The final code will be as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了菜单并更新了适配器，我们需要在`MainActivity`类中将它们全部连接起来。首先，修改`MainActivity`声明以实现`SelectMode`接口。最终代码如下：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Below the class declaration, add the following two variable declarations:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明下方，添加以下两个变量声明：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then add the `ActionMode` callback declaration:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`ActionMode`回调声明：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We need to store the `MyAdapter` reference so it can be called from `ActionMode`.
    To do this, modify the `myAdapter` instantiation call in the `onCreate()` method
    as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要存储`MyAdapter`引用，以便可以从`ActionMode`中调用它。为此，修改`onCreate()`方法中`myAdapter`实例化调用如下：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The final code is to implement the `onSelect` method to connect the adapter
    callback to the Action Mode. Add the following method to the `MainActivity` class:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终代码是实现`onSelect`方法以将适配器回调连接到Action Mode。向`MainActivity`类中添加以下方法：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run the program on a device or emulator to see the CAB in action.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序以查看CAB的实际效果。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As mentioned in the *Introduction* to this recipe, multiple item selection is
    one of the most missed features of `RecyclerView` and the one that receives the
    most questions. As you can see from this example, even a basic implementation
    requires many steps but the end result can be the exact implementation required
    for your task. You won't be limited to an existing feature set since you'll be
    creating it yourself.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如本菜谱的*简介*中提到的，多项目选择是`RecyclerView`最常被遗漏的功能，也是收到最多问题的一个。正如这个例子所示，即使是基本实现也需要许多步骤，但最终结果可以是满足你任务所需的精确实现。由于你将自行创建它，所以你不会局限于现有的功能集。
- en: 'This recipe combines several concepts learned from previous recipes, including
    the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱结合了从先前菜谱中学到的几个概念，包括以下内容：
- en: '`RecyclerView`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView`'
- en: The `RecyclerView` adapter
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView` 适配器'
- en: The contextual menu
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文菜单
- en: The action mode callback
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作模式回调
- en: To tie everything together, we created a custom interface so the adapter could
    notify when an item was selected. `MainActivity` receives the `onSelect()` event
    to trigger `ActionMode`. The `ActionMode` menu item calls the adapter when the
    user clicks the Delete All menu item and then closes the CAB.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有内容结合起来，我们创建了一个自定义接口，以便适配器能够在项目被选中时通知。`MainActivity`接收`onSelect()`事件来触发`ActionMode`。当用户点击删除所有菜单项并关闭CAB时，`ActionMode`菜单项会调用适配器。
- en: This is just one-way `ActionMode` could be implemented. We could start `ActionMode`
    with a long press, a checkbox on the item, or maybe a menu item. The choice is
    yours.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是`ActionMode`可能实现的一种方式。我们可以通过长按、项目上的复选框或可能是一个菜单项来启动`ActionMode`。选择权在你。
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you ran the application using the code shown previously, everything works
    as you''d expect. But there''s a problem. Our example only has a few items in
    the list—probably not enough to even allow scrolling. The point of `RecyclerView`
    though is to efficiently handle many items when scrolling. If you add many more
    items to the list, enough to allow scrolling a screen or two, you''ll see the
    problem. `RecyclerView` does exactly what it says: it recycles the views. If you
    select the first item, then scroll down, you''ll see the problem - items you didn''t
    select are selected.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用前面显示的代码运行了应用程序，一切都会如你所预期的那样工作。但是有一个问题。我们的例子中列表只有几个项目——可能甚至不足以允许滚动。然而，`RecyclerView`的目的在于在滚动时高效地处理许多项目。如果你向列表中添加更多的项目，足够多以至于可以滚动一两个屏幕，你就会看到问题。`RecyclerView`确实做了它所说的：回收视图。如果你选中了第一个项目，然后向下滚动，你会看到问题——未选中的项目被选中了。
- en: 'What''s happening is a common issue and confuses many developers new to `RecyclerView`.
    Because the view is being reused, it''s showing the state from the previous item.
    The solution is simple: just set the state appropriately when binding a new item.
    We can fix the preceding problem just by setting the initial state in the `onBindViewHolder()`
    call. Add the following line of code to the `onBindViewHolder()` method in the
    `MyAdapter` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是一个常见问题，并让许多新接触`RecyclerView`的开发者感到困惑。因为视图正在被重用，所以它显示了上一个项目的状态。解决方案很简单：只需在绑定新项目时适当地设置状态。我们只需在`MyAdapter`类的`onBindViewHolder()`调用中设置初始状态即可修复前面的问题。向`MyAdapter`类的`onBindViewHolder()`方法中添加以下代码行：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we set the initial state by checking our list to see if the
    item was selected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们通过检查列表中是否选中了项目来设置初始状态。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on `RecyclerView`, refer to [Chapter 2](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml)*,
    Layouts*
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于`RecyclerView`的信息，请参阅[第2章](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml)*，布局*
- en: For more information on the SparseArray, refer to [https://developer.android.com/reference/android/util/SparseArray](https://developer.android.com/reference/android/util/SparseArray)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于`SparseArray`的信息，请参阅[https://developer.android.com/reference/android/util/SparseArray](https://developer.android.com/reference/android/util/SparseArray)
- en: Creating a pop-up menu
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建弹出菜单
- en: 'A pop-up menu is attached to a view similar to the drop-down menu on a spinner.
    The idea of a pop-up menu is to provide additional options to complete an action.
    A common example might be a Reply button in an email app. When pressed, several
    reply options are shown, such as: Reply, Reply All, and Forward.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个弹出菜单附着在一个类似于选择器下拉菜单的视图中。弹出菜单的目的是提供额外的选项来完成一个动作。一个常见的例子可能是在电子邮件应用中的回复按钮。当按下时，会显示几个回复选项，例如：回复、回复所有人、和转发。
- en: 'Here is an example of the pop-up menu from the following recipe:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是以下菜谱中弹出菜单的示例：
- en: '![](img/08cb6ea0-0eb1-44d4-bbeb-0beab4c9681a.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08cb6ea0-0eb1-44d4-bbeb-0beab4c9681a.png)'
- en: Android will show the menu options below the anchor view if there is room; otherwise,
    the menu will be shown above the view.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有空间，Android将在锚视图下方显示菜单选项；否则，菜单将显示在视图上方。
- en: A pop-up menu is *not* meant to affect the view itself. That is the purpose
    of a Context Menu. Instead refer to the Floating Menu/Context Mode described in
    the *Enabling Contextual Action Mode for a view* recipe.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单**不是**用来影响视图本身的。这是上下文菜单的目的。相反，请参考*启用视图的上下文操作模式*食谱中描述的浮动菜单/上下文模式。
- en: In this recipe, we will create the pop-up menu shown previously, using `ImageButton`
    as the anchor view.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建之前显示的弹出菜单，使用`ImageButton`作为锚视图。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `PopupMenu`. Use the default
    Phone & Tablet option and select Empty Activity on the Add an Activity to Mobile
    dialog. As detailed in the first exercise of this chapter, create a menu directory
    (`res/menu`) to store the menu XML.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`PopupMenu`。使用默认的Phone & Tablet选项，并在添加活动到移动对话框中选择Empty
    Activity。如本章第一项练习中详细说明的，创建一个菜单目录（`res/menu`）来存储菜单XML。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We start by creating the XML menu to inflate on the button press. After inflating
    the pop-up menu, we call `setOnMenuItemClickListener()` by passing in the callback
    to handle the menu item selection. Start by opening the `strings.xml` file located
    in the `res/values` folder, then follow these steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个XML菜单，在按钮按下时展开。展开弹出菜单后，我们通过传递回调来调用`setOnMenuItemClickListener()`处理菜单项选择。首先打开位于`res/values`文件夹中的`strings.xml`文件，然后按照以下步骤操作：
- en: 'Add the following strings:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下字符串：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a new file in the `res/menu` directory called `menu_popup.xml` using
    the following XML:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/menu`目录下创建一个名为`menu_popup.xml`的新文件，使用以下XML：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create `ImageButton` in `activity_main.xml` to provide the anchor view for
    the pop-up menu. Create it as shown in the following XML code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`中创建`ImageButton`以提供弹出菜单的锚视图。按照以下XML代码创建它：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open `MainActivity.java` and add the following `OnMenuItemClickListener` below
    the class constructor:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并在类构造函数下方添加以下`OnMenuItemClickListener`：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The final code is to handle the button `onClick()` event, as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的代码是处理按钮`onClick()`事件，如下所示：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run the program on a device or emulator to see the pop-up menu.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序以查看弹出菜单。
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you read the previous menu recipes, this will probably look very familiar.
    Basically, we just inflate a pop-up menu when `ImageButton` is pressed. We set
    up a menu item listener to respond to the menu selection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了前面的菜单食谱，这可能会看起来非常熟悉。基本上，我们只是在按下`ImageButton`时弹出一个菜单。我们设置了一个菜单项监听器来响应用户的菜单选择。
- en: The key is to understand each of the menu options available in Android so you
    can use the correct menu type for a given scenario. This will help your application
    by providing a consistent user experience and reducing the learning curve for
    the user as they will already be familiar with the *standard* way of doing things.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要理解Android中可用的每个菜单选项，以便你可以为特定场景选择正确的菜单类型。这将通过提供一致的用户体验并减少用户的学习曲线来帮助你的应用程序，因为用户已经熟悉了*标准*的操作方式。
