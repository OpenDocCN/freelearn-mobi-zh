- en: Asynchronous Programming with Coroutines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程进行异步编程
- en: Today's software development landscape makes asynchronous processing one of
    the most important topics. The ever-increasing number of processors and cores
    and the massive consumption of external services (which has grown in recent years
    with the adoption of microservices architectures) are some of the factors that
    we should keep an eye on and strive to use a good asynchronous approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的软件开发格局使得异步处理成为最重要的主题之一。处理器和核心数量的不断增长以及对外部服务的巨大消耗（近年来随着微服务架构的采用而增长）是我们应该关注并努力采用良好异步方法的因素之一。
- en: Kotlin's implementation of coroutines is an excellent tool to build asynchronous
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 对协程的实现是构建异步应用程序的优秀工具。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Coroutines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: Alternative approaches
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代方法
- en: Asynchronous processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理
- en: Channels and actors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道和演员
- en: Introduction to coroutines
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程简介
- en: 'Let''s start with a simple example without coroutines:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从没有协程的简单例子开始：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `thread` function executes a block of code in a different thread. Inside
    the block, we are simulating an expensive I/O computation (such as accessing data
    from a microservice over HTTP) with `Thread.sleep`. `Thread.sleep` will block
    the current thread for the number of milliseconds passed as a parameter. In this
    example, we don't wait until the computation finishes to keep working on other
    things; we print another message, `"Hello"`, while the other computation is being
    executed. At the end, we wait for two seconds until the computation is finished.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread` 函数在不同的线程中执行一段代码。在代码块内部，我们使用 `Thread.sleep` 模拟一个昂贵的 I/O 计算（例如通过 HTTP
    从微服务访问数据）。`Thread.sleep` 将阻塞当前线程，直到传递的参数指定的毫秒数。在这个例子中，我们不等待计算完成，而是继续做其他事情；当其他计算正在执行时，我们打印另一条消息，“Hello”。最后，我们等待两秒钟，直到计算完成。'
- en: 'That''s not a pretty code, and we can do better:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不美观，我们可以做得更好：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this version, we have a reference to our thread called, `computation`; at
    the end, we wait for the `join()` method to finish. This is smarter than just
    waiting for a fixed amount of time, as real-life computations could have different
    execution times.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们有一个名为 `computation` 的线程引用；在最后，我们等待 `join()` 方法完成。这比仅仅等待固定的时间更聪明，因为现实生活中的计算可能具有不同的执行时间。
- en: Understanding JVM threads
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 JVM 线程
- en: Threads are the building blocks of asynchronous concurrent applications on JVM
    (and other platforms, too). A JVM thread is, most of the time, backed by a hardware
    thread (such as a core inside a processor). A hardware thread can support several
    software threads (a JVM thread is a kind of software thread), but only one software
    thread is executed at any given time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是 JVM（以及其他平台）上异步并发应用程序的构建块。大多数情况下，JVM 线程由硬件线程（如处理器内部的内核）支持。硬件线程可以支持多个软件线程（JVM
    线程是一种软件线程），但在任何给定时间只能执行一个软件线程。
- en: The OS (or the JVM) decides which software thread is executed on each hardware
    thread and switches quickly among the live threads, thereby, giving the appearance
    that there are several software threads executing at the same time, when in reality
    there are as many active software threads being executed as there are hardware
    threads. But, in most circumstances, it is useful to think that all software threads
    are being performed at the same time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（或 JVM）决定在每个硬件线程上执行哪个软件线程，并在活动线程之间快速切换，从而给人一种似乎有多个软件线程同时执行的感觉，但实际上活跃的软件线程数量与硬件线程数量相同。但是，在大多数情况下，认为所有软件线程都在同时执行是有用的。
- en: Threads in JVM are very fast and responsive, but they come at a cost. Each `Thread`
    has a cost in CPU time and memory on creation, disposal (when garbage is collected),
    and context switch (the process to store and recover a thread's state when it
    becomes the executing thread or stops being it). Because this cost is relatively
    high, a JVM application can't have a significant number of threads.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 中的线程非常快且响应迅速，但它们也有代价。每个 `Thread` 在创建、销毁（当垃圾回收时）和上下文切换（当线程成为执行线程或停止执行时存储和恢复线程状态的过程）时都会消耗
    CPU 时间和内存。由于这种成本相对较高，JVM 应用程序不能有大量的线程。
- en: 'A JVM application on a typical development machine can easily handle 100 threads:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的开发机器上，一个 JVM 应用程序可以轻松地处理 100 个线程：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you use any external application to monitor the JVM application, such as
    VisualVM or JConsole (among others), you''ll see a graphic like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用任何外部应用程序来监控JVM应用程序，例如VisualVM或JConsole（以及其他），您将看到如下图形：
- en: '![](img/8001e2a4-f132-429f-b70e-395a0d19f861.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8001e2a4-f132-429f-b70e-395a0d19f861.png)'
- en: 'We can increase our threads to 1,000 as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将线程数增加到1,000，如下面的截图所示：
- en: '![](img/57378487-0433-49f3-9d6b-a949b372100f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57378487-0433-49f3-9d6b-a949b372100f.png)'
- en: The amount of memory is growing at a fast rate, reaching more than 1.5 GB.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 内存容量正在以较快的速度增长，达到1.5 GB以上。
- en: 'Can we increase our threads to 10,000? Take a look at the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将线程数增加到10,000？请看以下截图：
- en: '![](img/7ecf2a92-c546-463f-877c-77b1df3b49f4.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ecf2a92-c546-463f-877c-77b1df3b49f4.png)'
- en: The answer is a blunt no; around 2,020 threads were created when the application
    died with `OutOfMemoryError` (this application was running with default settings;
    those settings can be changed at startup time).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是明确的否定；当应用程序因`OutOfMemoryError`而死亡时，创建了大约2,020个线程（此应用程序使用默认设置运行；这些设置可以在启动时更改）。
- en: 'Let''s try with 1,900, a fair estimate of what we can execute safely:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试1,900，这是一个安全的执行量的合理估计：
- en: '![](img/9bb2bf52-dc3a-483d-8164-cae5b7ea75b2.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bb2bf52-dc3a-483d-8164-cae5b7ea75b2.png)'
- en: Yes, we can run 1,900 concurrent threads.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以运行1,900个并发线程。
- en: 'In modern JVM applications, creating and destroying threads is considered a
    bad practice; instead, we use `Executor`, an abstraction that lets us manage and
    reuse threads, reducing the cost of creation and disposal:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JVM应用程序中，创建和销毁线程被视为一种不良做法；相反，我们使用`Executor`，这是一个抽象，允许我们管理和重用线程，从而降低创建和销毁的成本：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We created an `executor` value that, internally, has a thread pool of up to
    1,024 threads. Then, we submit 10,000 tasks; at the end, we shut down `Executor`.
    When we shut down `Executor`, it can''t accept new tasks and executes all pending
    ones as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`executor`值，其内部有一个最多1,024个线程的线程池。然后，我们提交10,000个任务；最后，我们关闭`Executor`。当我们关闭`Executor`时，它不能接受新的任务并执行所有挂起的任务，如下所示：
- en: '![](img/5908d8bf-a749-4bd4-b949-5f61661ef9e1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5908d8bf-a749-4bd4-b949-5f61661ef9e1.png)'
- en: There are many options to fine-tune and play with, `Executor`, such as the number
    of threads and the type of pool or its actual implementation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可以微调和玩耍，例如`Executor`的线程数和池的类型或其实际实现。
- en: There is a lot more theory on JVM threads than is possible to cover in this
    book. If you want to read and learn more about threads and concurrency, we recommend
    the classic book, *Java Concurrency in Practice (2006)* by Dough Lea, David Holmes,
    Joseph Bower, Joshua Block, Tim Peierls, and Brian Goetz, from Addison-Wesley
    Professional. We also recommend *Programming Concurrency on the JVM (2011)* by
    Venkat Subramanian from Pragmatic Bookshelf, and the *Java Concurrency LiveLessons
    (2015)* video by Douglas Schmidt from Addison-Wesley Professional. Last but not
    least,  we suggest the series of books and videos, *Java Concurrency* by Javier
    Fernández Gonzáles, published by Packt.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JVM线程的理论远比本书所能涵盖的多。如果您想阅读和学习更多关于线程和并发的知识，我们推荐经典书籍《Java并发实践（2006）》由Dough Lea、David
    Holmes、Joseph Bower、Joshua Block、Tim Peierls和Brian Goetz所著，由Addison-Wesley Professional出版。我们还推荐Venkat
    Subramanian所著的《Programming Concurrency on the JVM（2011）》由Pragmatic Bookshelf出版，以及Douglas
    Schmidt所著的《Java Concurrency LiveLessons（2015）》视频，由Addison-Wesley Professional提供。最后但同样重要的是，我们建议Javier
    Fernández Gonzáles所著的《Java Concurrency》系列书籍和视频，由Packt出版。
- en: Hello, coroutine world!
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗨，协程世界！
- en: Now, let's rewrite our `Hello World` application with coroutines.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用协程重写我们的`Hello World`应用程序。
- en: 'But, hey! What is a coroutine? Basically, a coroutine is a very light thread
    that runs a block of code and has a similar life cycle, but can complete with
    a return value or an exception. Technically, a coroutine is an instance of a suspendable
    computation, a computation that may suspend. Coroutines aren''t bound to a particular
    thread and can suspend in one `Thread` and resume execution in a different one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，嘿！什么是协程？基本上，协程是一个非常轻量级的线程，它运行一段代码，具有类似的生命周期，但可以带有返回值或异常完成。技术上讲，协程是可挂起计算的一个实例，这种计算可能会挂起。协程不绑定到特定的线程，可以在一个`Thread`中挂起并在另一个中恢复执行：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are a few things to cover here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要讨论的内容：
- en: '`runBlocking`: This function creates a coroutine and blocks the current `Thread`
    until the coroutine finishes, returning its result value (`Unit` in this case).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runBlocking`：此函数创建一个协程并阻塞当前`Thread`，直到协程完成，返回其结果值（在这种情况下为`Unit`）。'
- en: '`launch`: This function creates a new coroutine without blocking the current
    `Thread` and returns `Job` (ignored here).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch`: 这个函数创建一个新的协程而不阻塞当前 `Thread`，并返回 `Job`（在此处忽略）。'
- en: '`delay`: This function is a suspending (more on this later) function that delays
    the current coroutine without blocking the current thread.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`: 这个函数是一个挂起函数（稍后会有更多介绍），它延迟当前协程的执行而不阻塞当前线程。'
- en: '`suspend`: A suspending function is a function that may suspend the execution
    of a coroutine, without blocking the current `Thread`; therefore a suspending
    function must be called inside a coroutine—it can''t be invoked from normal code.
    The function must be marked with the `suspend` modifier. So, `delay` can be invoked
    inside `runBlocking` and `launch`, both functions (among others) take a suspending
    lambda as the last parameter—a suspending lambda is a lambda marked with the `suspend`
    modifier.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend`: 一个挂起函数是一个可能挂起协程执行而不阻塞当前 `Thread` 的函数；因此，挂起函数必须在协程内部调用——它不能从普通代码中调用。该函数必须带有
    `suspend` 修饰符。因此，`delay` 可以在 `runBlocking` 和 `launch` 中调用，这两个函数（以及其他函数）将挂起 lambda
    作为最后一个参数——挂起 lambda 是一个带有 `suspend` 修饰符的 lambda。'
- en: 'Let''s summarize what we know now, and a few other concepts before going further:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在继续之前总结一下我们现在所知道的内容，以及一些其他概念：
- en: '| **Concept** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **描述** |'
- en: '| **Coroutine** | A very light thread that can return a value and can suspend
    and resume. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **协程** | 一个非常轻的线程，可以返回一个值，并且可以挂起和恢复。|'
- en: '| **Suspending function** | A function marked with a `suspend` modifier. It
    can suspend a coroutine without blocking the thread. Suspending functions must
    be invoked inside a coroutine, for example `delay`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **挂起函数** | 一个带有 `suspend` 修饰符的函数。它可以挂起协程而不阻塞线程。挂起函数必须在协程内部调用，例如 `delay`。|'
- en: '| **Suspending lambda** | A lambda function marked with a `suspend` modifier.
    It can suspend a coroutine without blocking the thread. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **挂起 lambda** | 一个带有 `suspend` 修饰符的 lambda 函数。它可以挂起协程而不阻塞线程。|'
- en: '| **Coroutine builder** | A function that takes a suspending lambda, creates
    a coroutine and may return a result, for example `runBlocking`. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **协程构建器** | 一个接受一个挂起 lambda 的函数，创建一个协程，可能返回一个结果，例如 `runBlocking`。|'
- en: '| **Suspension point** | A point where a suspending function is invoked. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **挂起点** | 调用挂起函数的点。|'
- en: '| **Continuation** | The state of a suspended coroutine at a suspension point,
    it represents the rest of its execution after suspension point. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **延续** | 在挂起点处挂起的协程的状态，它代表了挂起点之后其执行剩余部分的状态。|'
- en: Let's get back to business.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到正事上来。
- en: 'As we discussed previously, computations can have different execution times.
    So, `delay` isn''t ideal in our `Hello World` example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，计算可能具有不同的执行时间。因此，`delay` 在我们的 `Hello World` 示例中并不理想：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As with our example with threads, we take the reference to the job created by
    `launch`, and we suspend it at the end with the suspending function `join`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的线程示例一样，我们获取由 `launch` 创建的作业的引用，并使用挂起函数 `join` 在最后挂起它。
- en: So far, so good. But are coroutines so very light? Can we have 10,000 coroutines?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但协程真的这么轻吗？我们能拥有 10,000 个协程吗？
- en: 'Let''s try it by executing the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下代码片段来试一试：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Oh, indeed! It works:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，确实如此！它工作了：
- en: '![](img/b4ef915b-0b6c-4500-ae98-3abd33dc1c36.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4ef915b-0b6c-4500-ae98-3abd33dc1c36.png)'
- en: They are orders of magnitude faster than the `Executor` solution, a lot less
    memory, fewer threads (barely seven threads) and, on top of that, are very easy
    to read.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它们比 `Executor` 解决方案快得多，内存少得多，线程少得多（仅有大约七个线程），而且最重要的是，它们非常容易阅读。
- en: 'Let''s go with 1 million coroutines:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一百万个协程来试试：
- en: '![](img/976557d1-0cf2-4969-9415-6f931b29b2aa.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/976557d1-0cf2-4969-9415-6f931b29b2aa.png)'
- en: Less than 2,000 threads need more than 1.5 GB of memory. 1 million coroutines
    need less than 700 MB of memory—I rest my case. The verdict is that the coroutines
    are very, very light.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不到 2,000 个线程需要超过 1.5 GB 的内存。一百万个协程需要不到 700 MB 的内存——我的论点就此结束。结论是协程非常非常轻。
- en: Using coroutines in real life
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现实生活中使用协程
- en: Microbenchmarks are very funny and they give us an idea of the power of Kotlin
    coroutines, but they don't represent a real-case scenario.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试非常有趣，它们让我们了解了 Kotlin 协程的强大之处，但它们并不代表真实场景。
- en: 'Let''s introduce our real-case scenario:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍我们的真实场景：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `UserService` interface has just one method—`getFact` will return a Chuck
    Norris-style fact about our user, identified by the user ID.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `UserService` 接口只有一个方法——`getFact` 将返回有关我们用户的 Chuck Norris 风格的事实，该用户由用户 ID
    标识。
- en: The implementation should check first on a local database for a user; if the
    user doesn't exist in the database, it should get it from the **RandomUser API**
    service, ([https://randomuser.me/documentation](https://randomuser.me/documentation)),
    and then store for future use. Once the service has a user, it should check again
    in the database for a fact related to that user; if the fact doesn't exist in
    the database, it should get it from The **Internet Chuck Norris Database API**
    service, ([http://www.icndb.com/api/](http://www.icndb.com/api/)), and store it
    in the database. Once the service has a fact, it could be returned. The service
    must try to reduce the number of external calls (database, API services) without
    using a cache.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实现应该首先在本地数据库中检查用户；如果用户不在数据库中，它应该从**RandomUser API**服务（[https://randomuser.me/documentation](https://randomuser.me/documentation)）获取它，然后存储以供将来使用。一旦服务有了用户，它应该再次在数据库中检查与该用户相关的信息；如果信息不在数据库中，它应该从**Internet
    Chuck Norris Database API**服务（[http://www.icndb.com/api/](http://www.icndb.com/api/)）获取，并将其存储在数据库中。一旦服务有了信息，就可以返回。服务必须尝试减少外部调用（数据库、API服务）的数量，而不使用缓存。
- en: 'Now, let''s introduce other interfaces, HTTP clients—`UserClient` and `FactClient`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍其他接口，HTTP客户端——`UserClient`和`FactClient`：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our clients will be implemented using `http4k` ([https://www.http4k.org/](https://www.http4k.org/))
    for HTTP communication, and Kotson ([https://github.com/SalomonBrys/Kotson](https://github.com/SalomonBrys/Kotson))
    for JSON processing. Both libraries are being designed for Kotlin, but any other
    library should work fine:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`http4k`（[https://www.http4k.org/](https://www.http4k.org/)）实现客户端的HTTP通信，并使用Kotson（[https://github.com/SalomonBrys/Kotson](https://github.com/SalomonBrys/Kotson)）进行JSON处理。这两个库都是为Kotlin设计的，但任何其他库都应该工作得很好：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Both clients will extend a common parent class that contains `http4k ApacheClient`
    and a `Gson` value configured with Kotson DSL:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两个客户端都将扩展一个包含`http4k ApacheClient`和用Kotson DSL配置的`Gson`值的公共父类：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Http4KUserClient` is very simple, both libraries are easy to use, and we move
    a lot of code to the parent class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Http4KUserClient`非常简单，这两个库都很容易使用，我们将大量代码移动到父类：'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Http4KFactClient` sets the user value inside the `Fact` instance, using the
    `copy` method.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Http4KFactClient`使用`copy`方法在`Fact`实例中设置用户值。'
- en: 'These classes are very nicely implemented, but to test the actual performance
    of our algorithm, we will mock these interfaces:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类实现得非常好，但为了测试我们算法的实际性能，我们将模拟这些接口：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Take a look at the following database repositories, `UserRepository` and `FactRepository`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下数据库存储库，`UserRepository`和`FactRepository`：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For our repositories, we''ll use `JdbcTemplate` of Spring 5\. Spring 5 comes
    with support for Kotlin, including extension functions for easy and idiomatic
    Kotlin use (you can use `JdbcTemplate` in any application, it doesn''t need to
    be a Spring one):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的存储库，我们将使用Spring 5的`JdbcTemplate`。Spring 5提供了对Kotlin的支持，包括用于简化Kotlin使用的扩展函数（你可以在任何应用程序中使用`JdbcTemplate`，它不需要是Spring应用程序）：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with the clients, both repositories will have a parent class—in this case,
    with a function to transform, `EmptyResultDataAccessException`; (spring's way
    to indicate a non-existing record) into a nullable—idiomatic Kotlin.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端一样，两个存储库也将有一个父类——在这种情况下，有一个将`EmptyResultDataAccessException`（Spring表示不存在的记录的方式）转换为可空——符合Kotlin语法的函数；
- en: 'Both implementations are straightforward, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 两个实现都很直接，如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For our database, we are using the H2 in-memory database, but any database
    will work (you can make this application work with some different persistence
    mechanisms, such as NoSQL database or any cache):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据库，我们使用的是H2内存数据库，但任何数据库都可以工作（你可以使这个应用程序与一些不同的持久化机制一起工作，例如NoSQL数据库或任何缓存）：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The function `initJdbcTemplate` creates `JdbcTemplate` with an H2 `DataSource`,
    and, once it is ready, it creates the tables inside the `apply` extension function.
    The `apply` extension function is useful to configure properties and call initialization
    code, returning the same value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`initJdbcTemplate`使用H2 `DataSource`创建`JdbcTemplate`，一旦准备就绪，它就在`apply`扩展函数内部创建表。`apply`扩展函数用于配置属性和调用初始化代码，并返回相同的值：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As with the clients, for testing, we will use mocks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端一样，为了测试，我们将使用模拟：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With these mocks, our worst case scenario is around 1,600 milliseconds:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模拟，我们的最坏情况场景大约是1,600毫秒：
- en: '`UserRepository.getUserById = 200ms ~`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserRepository.getUserById = 200ms ~`'
- en: '`UserClient.getUser = 500ms ~`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserClient.getUser = 500ms ~`'
- en: '`UserRepository = 200ms ~`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserRepository = 200ms ~`'
- en: '`FactClient.getFact = 500ms ~`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FactClient.getFact = 500ms ~`'
- en: '`FactRepository.insertRepository = 200ms ~`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FactRepository.insertRepository = 200ms ~`'
- en: Now, we'll implement `UserService` with different styles of asynchronicity,
    including a synchronous implementation, our baseline.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用不同的异步风格实现`UserService`，包括一个同步实现，这是我们的基础。
- en: Synchronous implementation
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步实现
- en: 'Synchronous code is easy to write, predictable, and easy to test, but in some
    cases, it doesn''t use system resources in an optimal manner:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同步代码易于编写，可预测，且易于测试，但在某些情况下，它并没有以最佳方式使用系统资源：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There''s nothing fancy here, just your normal, old boring code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么花哨的，只是你正常的、老套的代码：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We execute the `UserService.getFact` method 10 times to warm up the JVM (JVM
    optimizations make the application run faster after a while). Needless to say,
    execution time is 1,600 milliseconds, no surprises here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行`UserService.getFact`方法10次以预热 JVM（JVM 优化使得应用程序在一段时间后运行得更快）。不用说，执行时间是1,600毫秒，这里没有惊喜。
- en: Callbacks
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: A popular style of asynchronous code is to execute the code in a separate thread
    and invoke a `callback` function when the aforementioned thread finishes its execution.
    One downside of the callback style is that our asynchronous functions now need
    an extra parameter. Callback style is easy to write in Kotlin with its support
    for lambdas.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码的一种流行风格是在单独的线程中执行代码，当上述线程完成其执行时调用`callback`函数。回调风格的一个缺点是我们的异步函数现在需要一个额外的参数。在
    Kotlin 的 lambda 支持下，回调风格在 Kotlin 中很容易编写。
- en: 'For our callback implementation, we''ll need adapters for our clients and repositories:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的回调实现，我们需要为我们的客户端和仓库提供适配器：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These adapters execute our code in a separate thread and invoke the callback,
    lambda, once it is completed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适配器在单独的线程中执行我们的代码，并在完成后调用回调，lambda：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Callback style tends to be very obscure and hard to read; when several callbacks
    are nested, it is even worse (affectionately known in the community as callback
    hell). The `while` block at the end with `Thread.sleep` looks very hacky. It is
    also very fast with an execution time of 1,200 milliseconds but with many threads
    created and memory consumption to match it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回调风格往往非常晦涩难懂；当多个回调嵌套时，情况更糟（在社区中亲切地称为回调地狱）。结尾的`while`循环中使用`Thread.sleep`看起来非常笨拙。它的执行速度也非常快，耗时1,200毫秒，但创建了大量的线程，内存消耗与之相匹配。
- en: A callback implementation that creates a thread per function call will quickly
    consume all the application's resources in a production scenario; therefore, it
    should be based on some `Executor` implementation or similar.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数调用创建一个线程的回调实现将很快在生产场景中消耗掉应用程序的所有资源；因此，它应该基于某种`Executor`实现或类似的东西。
- en: Java Futures
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 未来
- en: 'As callback style tends to be hard to maintain, other styles have emerged in
    recent years. One of these styles is futures. A **future** is a computation that
    may complete in the future. When we invoke the `Future.get` method, it will obtain
    its result, but we also block the thread:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回调风格难以维护，近年来出现了其他风格。其中一种风格是未来。**未来**是指可能在将来完成的计算。当我们调用`Future.get`方法时，它将获取其结果，但我们也会阻塞线程：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The implementation with futures is very similar to our synchronous implementation,
    but with those weird `submit` and `get` functions all over the place. We also
    have `Executor` that we need to take care of. Total time is around 1,200 milliseconds,
    with many threads created, more than in the callback example. One possible option
    is to have `Executor` per instance or globally, but in that case, we also need
    to have some way to manage its life cycle.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未来的实现与我们的同步实现非常相似，但到处都是那些奇怪的`submit`和`get`函数。我们还有一个需要关注的`Executor`。总时间大约是1,200毫秒，创建了大量的线程，比回调示例中的更多。一个可能的选项是每个实例或全局地有一个`Executor`，但在这种情况下，我们还需要有某种方式来管理其生命周期。
- en: Promises with Kovenant
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kovenant 中的承诺
- en: Another option to write asynchronous code is to use promises. A **promise**
    is similar to a future (in many frameworks, futures and promises are synonymous),
    as it represents a computation that may complete in the future. We have a blocking
    method to obtain its result, but we can also react to its result, callback style.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写异步代码的另一种选择是使用承诺。**承诺**与未来类似（在许多框架中，未来和承诺是同义的），因为它代表了一个可能在将来完成的计算。我们有一个阻塞方法来获取其结果，但我们也可以以回调风格对其结果做出反应。
- en: '**Kovenant** ([http://kovenant.komponents.nl/](http://kovenant.komponents.nl/))
    is an implementation of promises for Kotlin:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kovenant** ([http://kovenant.komponents.nl/](http://kovenant.komponents.nl/))
    是 Kotlin 中对承诺的实现：'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The function `task` creates `Promise<T, Exception>` (something that we didn''t
    cover previously in our other implementations). We can interact with `Promise<T,
    Exception>` in several ways:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `task` 创建 `Promise<T, Exception>`（在我们之前的其他实现中未涉及）。我们可以以几种方式与 `Promise<T,
    Exception>` 交互：
- en: '`get(): T`: This blocks the current thread and returns the promise''s result.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(): T`：这会阻塞当前线程并返回 promise 的结果。'
- en: '`then(bind: (T) -> R): Promise<R, Exception>`: This is similar to `map` on
    functional collections; it returns a new `Promise` value with a new type.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then(bind: (T) -> R): Promise<R, Exception>`：这与函数式集合上的 `map` 类似；它返回一个具有新类型的新
    `Promise` 值。'
- en: '`success(callback: (T) -> Unit): Promise<T, Exception>`: This is callback on
    successful `Promise` execution. It''s useful for side effects'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`success(callback: (T) -> Unit): Promise<T, Exception>`：这是在 `Promise` 执行成功时的回调。它对于副作用很有用。'
- en: '`fail(callback: (Exception) -> Unit): Promise<T, Exception>`: This is callback
    on fail, like a `catch` block.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail(callback: (Exception) -> Unit): Promise<T, Exception>`：这是在失败时的回调，类似于
    `catch` 块。'
- en: '`always(callback: () -> Unit): Promise<T, Exception>`: This always executes,
    like a `finally` block.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always(callback: () -> Unit): Promise<T, Exception>`：这总是执行，就像 `finally` 块一样。'
- en: The codes feel difficult to grasp at first sight, but, once you get used to
    the promise idioms, it is easy to read. Also, notice that a promise is a future,
    so you can write something similar to our future's example but without messing
    around with `Executors`. Java 8 includes a new type of future named `CompletableFuture<T>`
    which can be considered a promise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码一开始看起来很难理解，但一旦习惯了 promise 习惯用法，阅读起来就很容易。此外，请注意，promise 是一个未来，因此你可以编写类似于我们未来示例的代码，但不需要与
    `Executors` 打扰。Java 8 包含一种名为 `CompletableFuture<T>` 的新类型未来，它可以被视为一个 promise。
- en: Execution time is around 1,350 milliseconds for the first execution (Kovenant
    initialization phase), and then it stabilizes around 1,200 milliseconds. On its
    default configuration, Kovenant uses as many threads as possible, resulting in
    a high use of memory, but Kovenant can be fine-tuned to use fewer threads.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首次执行（Kovenant 初始化阶段）的执行时间约为 1,350 毫秒，然后稳定在 1,200 毫秒左右。在默认配置下，Kovenant 尽可能使用尽可能多的线程，导致内存使用量很高，但
    Kovenant 可以微调以使用更少的线程。
- en: Coroutines
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: 'Now, let''s rework our example with coroutines:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用协程重新整理我们的示例：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our code is more straightforward than our `Future` example, getting very close
    to our synchronous code. We covered `runBlocking` and `launch` in the previous
    section, but a new coroutine builder is introduced here, `async`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的简洁性比我们的 `Future` 示例更接近，几乎接近我们的同步代码。我们在上一节中介绍了 `runBlocking` 和 `launch`，但在这里引入了一个新的协程构建器，`async`。
- en: The `async` coroutine builder takes a block of code and executes it asynchronously,
    returning `Deferred<T>`. A `Deferred` is a `Future` with an `await` method that
    blocks the coroutine until completion but not the thread; `Deferred` also extends
    from `Job` so inherits all its methods, such as `join`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 协程构建器接收一段代码块并异步执行它，返回 `Deferred<T>`。`Deferred` 是一个带有 `await` 方法的 `Future`，它会在协程完成前阻塞协程但不会阻塞线程；`Deferred`
    还从 `Job` 继承，因此继承了所有它的方法，例如 `join`。'
- en: Coroutine code feels natural yet it is explicit when we are using asynchronous
    code, but due to the low cost on resources, we can use as many coroutines as we
    want in our code; for example, `CoroutineUserService` uses less than half of threads
    and memory than any other implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 协程代码感觉自然，当我们使用异步代码时又很明确，但由于资源消耗低，我们可以在代码中使用尽可能多的协程；例如，`CoroutineUserService`
    比其他任何实现使用的线程和内存都少一半。
- en: 'Now that we have all implementations, we can compare code complexity and resource
    consumption:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有实现，我们可以比较代码复杂度和资源消耗：
- en: '|  | **Code complexity** | **Resource consumption** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  | **代码复杂度** | **资源消耗** |'
- en: '| **Synchronous** | There is very low code complexity. | The resource consumption
    is very low with slow performance. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **同步** | 代码复杂度非常低。 | 资源消耗非常低，但性能较慢。 |'
- en: '| **Callbacks** | Very high adapters are needed; duplication is expected; nested
    callbacks are hard to read; and there are various hacks. | The resource consumption
    is high. It could improve using a shared `Executor`, but it will add more code
    complexity. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **回调** | 需要非常高的适配器；预期会有重复；嵌套回调难以阅读；并且有各种技巧。 | 资源消耗很高。使用共享 `Executor` 可以提高效率，但会增加代码复杂度。
    |'
- en: '| **Futures** | Code complexity is medium. `Executors` and `get()` are noisy
    but it is still readable. | Resource consumption is high, but it can be fine-tuned
    using different `Executor` implementations and sharing executors but this adds
    code complexity. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **Futures** | 代码复杂度中等。`Executors` 和 `get()` 很吵，但仍然可读。 | 资源消耗高，但可以通过不同的 `Executor`
    实现和共享执行器进行微调，但这会增加代码复杂度。 |'
- en: '| **Promises** | Code complexity is medium using promise style (`then`, `success`).
    Using a futures style (`get`), it can be as slick as coroutines without affecting
    performance. | Resource consumption is very high, with top performance, but it
    can be fine-tuned without altering the code. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **承诺** | 使用承诺风格（`then`、`success`）时，代码复杂度中等。使用 futures 风格（`get`），它可以像协程一样流畅，而不会影响性能。
    | 资源消耗非常高，具有顶级性能，但可以通过不更改代码的方式进行微调。 |'
- en: '| **Coroutines** | Code complexity is low; it''s the same size as synchronous
    style with explicit blocks for asynchronous operations. | Resource consumption
    is low, with top performance out of the box. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **协程** | 代码复杂度低；与同步风格相同的大小，具有显式的异步操作块。 | 资源消耗低，具有出色的性能。 |'
- en: Overall, coroutines are a clear winner, with Kovenant promises coming in a close
    second.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，协程是明显的赢家，Kovenant 的承诺紧随其后。
- en: Coroutine context
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程上下文
- en: 'Coroutines always run in a context. All coroutine builders have context specified
    by default, and that context is available through the value `coroutineContext`,
    inside the coroutine body:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 协程总是在上下文中运行。所有协程构建器默认指定上下文，并且该上下文可以通过协程体内的 `coroutineContext` 值访问：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each coroutine context also includes `CoroutineDispatcher` that decides which
    thread the coroutine runs. Coroutines builders, such as `async` and `launch`,
    use the `DefaultDispatcher` dispatcher as default (in the current coroutines version,
    0.2.1, `DefaultDispatcher` is equal to `CommonPool`; however, this behavior can
    change in the future).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协程上下文还包括 `CoroutineDispatcher`，它决定了协程在哪个线程上运行。例如，`async` 和 `launch` 这样的协程构建器默认使用
    `DefaultDispatcher` 分派器（在当前协程版本 0.2.1 中，`DefaultDispatcher` 等于 `CommonPool`；然而，这种行为在未来可能会改变）。
- en: The coroutine context can also hold values; for example, you can recover the
    coroutine's job by using `coroutineContext[Job]`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 协程上下文还可以持有值；例如，你可以通过使用 `coroutineContext[Job]` 来恢复协程的工作。
- en: 'Coroutine contexts can be used to control its children. Our 1 million coroutines
    example can be reworked to join all its children:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 协程上下文可以用来控制其子协程。我们的 100 万个协程示例可以被重新设计，以便将所有子协程连接起来：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Instead of each one of the million coroutines having its own context, we can
    set a shared coroutine context that actually comes from the external `launch`
    coroutine context. When we join the outer `launch` job, it joins all its coroutine
    children, too.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每个百万个协程都有自己的上下文，我们可以设置一个共享的协程上下文，它实际上来自外部的 `launch` 协程上下文。当我们连接外部的 `launch`
    作业时，它也会连接所有其协程子作业。
- en: Channels
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: 'One way for two coroutines to communicate (or for a coroutine to the external
    world as with `async`) is through `Deferred<T>`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 两个协程之间通信（或者协程与外部世界通信，如 `async`）的一种方式是通过 `Deferred<T>`：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Deferreds are fine for single values, but sometimes we want to send a sequence
    or a stream. In that case, we can use `Channel`. `Channel` which is similar to `BlockingQueue`,
    but with suspending operations instead of blocking ones, also `Channel` can be
    `close`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个值，延迟调用（Deferreds）是可行的，但有时我们希望发送一个序列或流。在这种情况下，我们可以使用 `Channel`。`Channel`
    类似于 `BlockingQueue`，但使用的是挂起操作而不是阻塞操作，而且 `Channel` 可以被 `close`：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s write our 1 million coroutines example with channels as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用通道的方式编写我们的 100 万个协程示例，如下所示：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, this isn''t the intended use case for channels. Usually, a single
    coroutine (or many) sends messages to the channel:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是通道的预期用途。通常，单个协程（或多个）向通道发送消息：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A channel is itself an Iterator, so it can be used on the `for` blocks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通道本身就是一个迭代器，因此它可以在 `for` 循环中使用。
- en: 'A simpler way to write this code is by using the `produce` builder as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编写此代码的一个更简单的方法是使用 `produce` 构建器，如下所示：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `produce` builder returns `ReceiveChannel<T>`, a channel type just for receiving.
    A `Channel<T>` extends both types, `SendChannel<T>` and `ReceiveChannel<T>`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`produce` 构建器返回 `ReceiveChannel<T>`，这是一种仅用于接收的通道类型。`Channel<T>` 同时扩展了 `SendChannel<T>`
    和 `ReceiveChannel<T>` 这两种类型。'
- en: Channel pipelines
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道管道
- en: When we have channels, we can have related patterns, such as pipelines. A **pipeline**
    is a series of channels connecting consumers and producers, similar to Unix pipes
    or **Enterprise Integration Patterns** (**EIP**).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有通道时，我们可以有相关的模式，例如管道。一个 **pipeline** 是一系列连接消费者和生产者的通道，类似于 Unix 管道或 **企业集成模式**（**EIP**）。
- en: 'Let''s write our own sales system using EIPs. Let''s first take a look at the
    models:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 EIPs 编写自己的销售系统。首先，让我们看看模型：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s take a look at the patterns:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看模式：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `calculatePriceTransformer` function receives quotes from a channel and
    transforms it into `Pair<Bill, PickingOrder>`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculatePriceTransformer` 函数从通道接收报价并将其转换为 `Pair<Bill, PickingOrder>`：'
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `cheapBillFilter` function well filters the `bill` value below `100`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`cheapBillFilter` 函数很好地过滤了低于 `100` 的 `bill` 值：'
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`splitter` splits `Pair<Bill, PickingOrder>` into their own channels:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`splitter` 将 `Pair<Bill, PickingOrder>` 分割成各自的通道：'
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Both `accountingEndpoint` and `warehouseEndpoint` process their respective
    messages by printing, but, in a real-life scenario, we could be storing these
    messages into our database, sending emails or sending messages to other systems
    using **JMS**, **AMQP**, or **Kafka**:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`accountingEndpoint` 和 `warehouseEndpoint` 都通过打印处理它们各自的消息，但在实际场景中，我们可以将这些消息存储到数据库中，发送电子邮件或使用
    **JMS**、**AMQP** 或 **Kafka** 向其他系统发送消息：'
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `main` method assembles our sales system and tests it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法组装我们的销售系统并对其进行测试。'
- en: Many other channel messages patterns can be implemented with coroutine channels,
    such as fan-in, fan-out, and `actors`. We'll cover `actors` in our next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用协程通道实现许多其他通道消息模式，例如扇入、扇出和 `actors`。我们将在下一节中介绍 `actors`。
- en: Managing mutable state
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理可变状态
- en: The main concern (and nightmare fuel) when we deal with asynchronous code is
    how to handle mutable state. We covered how to reduce mutable state with a functional
    style in [Chapter 3](3d8794f8-c237-4d9e-992e-c54a1392a89c.xhtml), *Immutability
    - It's Important*. But sometimes it is impossible to use a functional immutable
    style. Coroutines offer some alternatives to this problem.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理异步代码时，主要关注点（以及噩梦的来源）是如何处理可变状态。我们在第 3 章[不可变性 - 它很重要](3d8794f8-c237-4d9e-992e-c54a1392a89c.xhtml)中介绍了如何使用函数式风格减少可变状态。但有时使用函数式不可变风格是不可能的。协程为此问题提供了一些替代方案。
- en: 'In the following example, we''ll use several coroutines to update a counter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用几个协程来更新一个计数器：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: On smaller numbers, `counter` is right, but once we start increasing the size,
    we'll see wacky numbers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的数字，`counter` 是正确的，但一旦我们开始增加大小，我们就会看到奇怪的数字。
- en: Now we can have a look at the alternatives that coroutines provide us.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看协程为我们提供的替代方案。
- en: Switching contexts
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换上下文
- en: 'Our first option is to use a different context for our update operation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种选择是使用不同的上下文来更新操作：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `withContext` function executes a block in a specific coroutine context—in
    this case, a single-threaded one. Switching context is a powerful technique that
    lets us manipulate, in a fine-grained way, how our code runs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`withContext` 函数在特定的协程上下文中执行一个块——在这种情况下，是单线程的。切换上下文是一种强大的技术，它让我们能够以细粒度的方式操纵代码的运行方式。'
- en: Thread safe structures
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全结构
- en: 'From Java 5 and onwards, we have access to some atomic thread safe structures,
    that are still useful with coroutines:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 5 开始，我们可以访问一些原子线程安全的结构，这些结构在协程中仍然很有用：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`AtomicInteger` gives us many atomic operations that are thread safe. There
    are more thread safe structures such as other atomic primitives and concurrent
    collections.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`AtomicInteger` 给我们许多线程安全的原子操作。还有更多线程安全的结构，如其他原子原语和并发集合。'
- en: Mutexes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: 'A `Mutex` (mutual exclusion) object allows access to multiple coroutines to
    share the same resource but not simultaneously:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Mutex`（互斥锁）对象允许多个协程访问相同的资源，但不能同时访问：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A `Mutex` object works similarly to a synchronized control structure, but, instead
    of blocking the thread, it just blocks the coroutine.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex` 对象的工作方式与同步控制结构类似，但它不是阻塞线程，而是阻塞协程。'
- en: Actors
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actors
- en: 'An `actor` is kind of object that interacts with other actors and with the
    external world through messages. An `actor` object can have a private internal
    mutable state that can be modified and accessed externally through messages, but
    not directly. Actors are growing in popularity in recent years due to their consistent
    programming model, and have been tested successfully in multi-million user applications,
    such as **WhatsApp** that is built with **Erlang**, the language that brings actors
    into the limelight:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`actor` 是一种与其它 `actor` 和外部世界通过消息交互的对象。一个 `actor` 对象可以有一个私有的内部可变状态，该状态可以通过消息修改和访问，但不能直接访问。由于它们一致的编程模型，演员在近年来越来越受欢迎，并在多百万用户的应用程序中成功进行了测试，例如用
    **Erlang** 编写的 **WhatsApp**，这种语言使演员成为焦点：'
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To write an `actor`, first, we need to define which messages we want to send.
    Here, we are creating two messages, `IncCounter` and `GetCounter`. `GetCounter`
    has a `CompletableDeferred<Int>` value that will let us know the counter value
    outside the `actor`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个 `actor`，首先，我们需要定义我们想要发送哪些消息。在这里，我们创建了两个消息，`IncCounter` 和 `GetCounter`。`GetCounter`
    有一个 `CompletableDeferred<Int>` 值，这将让我们知道 `actor` 外部的计数器值。
- en: 'We can use the `actor<CounterMsg>` builder to create `actor`. Inside our `actor`
    coroutine, we have access to the `channel` property, `ReceiveChannel<CounterMsg>`,
    to receive the messages and react to them. The `counterActor(Int)` function will
    return `SendChannel<CounterMsg>`; therefore, the only functions that we can call
    are `send(CounterMsg)` and `close()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `actor<CounterMsg>` 构建器来创建 `actor`。在我们的 `actor` 协程内部，我们可以访问 `channel`
    属性，即 `ReceiveChannel<CounterMsg>`，以接收消息并对它们做出反应。`counterActor(Int)` 函数将返回 `SendChannel<CounterMsg>`；因此，我们只能调用
    `send(CounterMsg)` 和 `close()` 这两个函数：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Actors can be hard to grasp at the beginning but once, you understand, the `actor`
    model is straightforward for creating complex and powerful systems.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，演员（Actors）可能难以理解，但一旦你理解了，`actor` 模型对于创建复杂和强大的系统来说非常直接。
- en: In the example code for this book, you can find an implementation of our `UserService`
    example using `actors`. You can watch it online at [https://github.com/MarioAriasC/FunctionalKotlin/blob/master/Chapter07/src/main/kotlin/com/packtpub/functionalkotlin/chapter07/facts.kt#L377](https://github.com/MarioAriasC/FunctionalKotlin/blob/master/Chapter07/src/main/kotlin/com/packtpub/functionalkotlin/chapter07/facts.kt#L377).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例代码中，你可以找到一个使用 `actors` 实现的 `UserService` 示例。你可以在网上观看它：[https://github.com/MarioAriasC/FunctionalKotlin/blob/master/Chapter07/src/main/kotlin/com/packtpub/functionalkotlin/chapter07/facts.kt#L377](https://github.com/MarioAriasC/FunctionalKotlin/blob/master/Chapter07/src/main/kotlin/com/packtpub/functionalkotlin/chapter07/facts.kt#L377)。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Coroutines show a high potential to transform the way we think about asynchronous
    code and execution. In this chapter, we covered how to write coroutines and how
    to use coroutine contexts and channels. We also took a comprehensive look at how
    to deal with asynchronous shared mutable state.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 协程显示出改变我们思考异步代码和执行方式的高潜力。在本章中，我们介绍了如何编写协程以及如何使用协程上下文和通道。我们还全面探讨了如何处理异步共享可变状态。
- en: In our next chapter, we'll learn about functional collections and their operations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一章中，我们将学习函数式集合及其操作。
