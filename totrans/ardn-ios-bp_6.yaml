- en: Chapter 6. Automatic Garage Door Opener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project is about an emerging technology called **iBeacon** that is based
    on the Bluetooth BLE communication protocol. Basically, an iBeacon is a small
    device that continuously transmits a unique coded signal. An iOS device can detect
    iBeacon to determine whether it is more or less near an iBeacon and trigger actions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**iBeacon is an Apple technology**'
  prefs: []
  type: TYPE_NORMAL
- en: iBeacon is a technology that was invented by Apple, and the protocol has not
    been disclosed (if you can find any information on the Internet, Google is your
    friend). So, to work with iBeacon devices, you need an iOS device and the API
    provided by Apple.
  prefs: []
  type: TYPE_NORMAL
- en: There is another standard that is emerging and which can also work with Android
    devices—AltBeacon (for more information, visit [http://bit.ly/1KsXD17](http://bit.ly/1KsXD17)).
    The AltBeacon site has a lot of useful information for iOS too.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use these technologies to open our garage door as soon as we
    get close enough to it. You may wonder what the difference is between this and
    a traditional garage remote control or the numerous remote control apps that are
    available for iOS devices. The main difference is that everything happens automatically
    (automagically?); you don't even need to touch your phone. Believe it or not,
    you don't even need the controller app running.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t have a garage?**'
  prefs: []
  type: TYPE_NORMAL
- en: This project can be used to open any kind of door, but you may need to adapt
    or change your lock to something that can be controlled by an electric signal.
    Alternatively, you can use this project to control internal/external lights. There's
    no chance of getting bored!
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by having a closer look at iBeacon.
  prefs: []
  type: TYPE_NORMAL
- en: iBeacon – a technical overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iBeacon is a small device that, leveraging the Bluetooth BLE, establishes
    a region around itself. Any iOS device that supports Bluetooth BLE can determine
    whether it has entered or exited the region and roughly estimate the distance
    from the iBeacon.
  prefs: []
  type: TYPE_NORMAL
- en: We can put an iBeacon close to each museum artwork and write an iOS application
    that shows artwork information as soon as a visitor gets close to it. This is
    a typical example of how iBeacon is used.
  prefs: []
  type: TYPE_NORMAL
- en: iBeacon is univocally identified by three values—a UUID (a 16 bytes universal
    identifier), major (2 bytes), and minor (2 bytes), which are constantly transmitted
    over the Bluetooth signal.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**All that you need to know** **about iBeacon**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find all that you need to know at [https://developer.apple.com/ibeacon/](https://developer.apple.com/ibeacon/)
    and [https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf](https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Referring to the next diagram, you can see that there is a region around the
    iBeacon (the iBeacon region). The iOS application that registers to this region
    (with the UUID, major, and minor of the iBeacon) receives an "entering" notification
    when the iOS device crosses this region's border and enters it, and an "exiting"
    notification when the iOS device crosses the region's border and exits it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the details of this in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iBeacon – a technical overview](img/image00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In open air, the iBeacon region is about 30 meters wide, but this size widely
    depends on the hardware design, configuration, obstacles, and the way of installation.
  prefs: []
  type: TYPE_NORMAL
- en: When inside the region, an iOS device can continuously monitor the distance
    from the iBeacon device. This distance is returned as Far, Near, or Immediate.
    Apple doesn't declare the actual size of these distances, most likely because
    they are really influenced by the iBeacon's transmitting power, obstacles between
    the iBeacon and the iOS device, the iOS device orientation, and other factors.
    Anyway, this information can be used to change the application's behavior with
    the distance from iBeacon.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**iBeacon distance calculation**'
  prefs: []
  type: TYPE_NORMAL
- en: An iOS device can find out the signal strength of the iBeacon. It can calculate
    the distance from the iBeacon by using a formula that describes the signal attenuation
    with distance. Unfortunately, since an iBeacon signal has a lot of fluctuations
    and its propagation is influenced by a lot of factors, the formula gives a very
    poor estimation of the distance. Probabilistic techniques have to be used to get
    the estimation of the distance to use this value for practical applications. We
    cannot cover these techniques in this book.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting feature of how the iBeacon notifications are handled by the iOS
    is that even if the application is not running, the entering and exiting notifications
    are received and they start the application. To save the iOS device power, the
    application is started just for a few seconds (for about 3 seconds) and then paused.
    Then, the application has to complete every operation in this short interval.
  prefs: []
  type: TYPE_NORMAL
- en: I have to point out that usually, an iOS app receives an entering notification
    almost as soon as it crosses the iBeacon region. Conversely, the exiting notification
    may be received even a few minutes after the region border is crossed.
  prefs: []
  type: TYPE_NORMAL
- en: The garage door opener requirements and design constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing the capabilities of the iBeacon, it's not hard to imagine how a garage
    door opener may work. The iBeacon is installed just behind the garage door. An
    Arduino with the BLE board listens for commands from the iOS device and controls
    the garage door opener. An iOS app sends an "Open" command when entering into
    the iBeacon region and a "Close" command when exiting the iBeacon region. Very
    simple, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we have to face the potentially long delay when receiving an
    exiting notification. When driving a car, you can cover a great distance traveling
    away from your garage in a few minutes; an iOS device cannot connect to the Arduino
    in such a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, after taking a look at the next picture, you may realize that the
    iBeacon region may also cover only a part of the house. We obviously don't want
    that walking around the house with the iOS device in our pockets, the garage door
    would open and close randomly.
  prefs: []
  type: TYPE_NORMAL
- en: '![The garage door opener requirements and design constraints](img/image00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A simple solution could be adding as many iBeacons as needed across the house,
    all with the same UUID, major, and minor, in order to extend the iBeacon region.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this solution will be too expensive. We are going to use another power
    feature of the iOS to overcome these two issues—geofencing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The garage door opener requirements and design constraints](img/image00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can register a geofencing region (using the latitude and longitude of the
    center and the radius) that covers our entire house. On crossing the geofencing
    region's border, we get a notification (or even better, two notifications—one
    when entering the region and the other when exiting).
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we don't simply use only a geofencing region to open the
    garage door. The reason behind not doing this is that the geofencing notifications
    are not very precise. They may have a very long delay and may not work in all
    areas. By combining the two technologies, we get exactly what we want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'We eventually overcame all the design challenges that involve tracking the
    entering of the device in the iBeacon region and its exiting from the geofencing
    region. This is how the automatic garage door opener works:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we are outside both the regions. When we cross the geofencing
    region, nothing happens, because the app recognizes only the exiting notification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as we cross the iBeacon region a few meters away from the garage, the
    iOS device gets a notification, and it sends an opening command to the Arduino
    board, which controls the door, thereby opening the door.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The door is automatically closed after a short time. This allows us to park
    the car inside the garage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From now on, the action of crossing the iBeacon region is ignored. Then, in
    case we cross the iBeacon region while moving around the house, the garage will
    not be opened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we leave, we eventually cross the geofencing region. This event again enables
    the receiving of the iBeacon entering notification. We are in the same state that
    was described in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can describe the behavior of the app by using the following state diagram
    (strictly speaking, it''s a Mealy State Machine; for more information, visit [http://bit.ly/1hmZs3V](http://bit.ly/1hmZs3V)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The garage door opener requirements and design constraints](img/image00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We obviously don't want anyone else to open our garage. So, each authorized
    user must identify themselves by using a PIN (personal identification number).
    Assigning a new PIN, you allow others to get access to your garage. You can revoke
    access just by removing the PIN from the authorization list.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the app has to manage the PINs, and we need a master PIN, which is wired
    into the Arduino code. Only the person who knows the master PIN is authorized
    to manage PINs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A security warning!**'
  prefs: []
  type: TYPE_NORMAL
- en: Even if the iOS app requires a PIN in order to open the garage door, the app
    is not completely secure since it doesn't provide any encryption mechanism. Anyone
    can access the PIN by using a Bluetooth protocol sniffer. It's not so easy, but
    it's possible. You have been warned! Making the communication secure could be
    a good chance to learn more about encryption and how to implement encryption using
    the little memory and little processing power available on Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main hardware component that we need is the iBeacon. We have used the one
    that is shown at [http://redbear.net](http://redbear.net). Many products are available
    on the market at almost any price. When choosing an iBeacon, make sure that it
    is compatible with the iBeacon Apple protocol, since there are products that are
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**An iOS device as an iBeacon**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have two iOS devices, you can use one of them to act as an iBeacon that
    running via one of the apps that are available on the iTunes store. I have published
    my own app for this purpose, which can be found at [http://apple.co/1hmZt80](http://apple.co/1hmZt80).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the iBeacon enclosure, it can be mounted inside or outside the
    garage. It is better if it is placed at a higher position. Usually, the battery
    that powers the iBeacon should last for at least one year. Consider battery replacement
    anyway while positioning it.
  prefs: []
  type: TYPE_NORMAL
- en: Additional electronic components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we will need the following additional components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A BJT transistor: P2N2222 (see the details in the text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An NMOSFET transistor BS170 (see the details in the text)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 10K resistor (see the details in the text)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 1.5K resistor (see the details in the text)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A diode 1N4001 (see the details in the text)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A relay: coil voltage 5 and contact current max 1A (see the details in the
    text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electronic circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following picture shows the electric diagram of the electronic circuit
    that we need for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Usually, the relay current is about 40 mA, which exceeds the maximum amount
    of current that Arduino can provide. There are relays that draw less current,
    but to avoid burning the Arduino, we can use a transistor to power the relay.
    When the relay is turned off, the energy stored in the coil is discharged against
    the transistor as reverse current, and this can damage the transistor. The diode
    (a flyback diode) shorts this current, protecting the transistor from damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to mount the circuit on a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A relay is an electromechanical device that drains current, and it is subject
    to faults. So, you can use a more reliable circuit by using N-MOSFET. This alternative
    circuit is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows how to mount the circuit on a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The R1 resistor pulls down the gate of the MOSFET. So, it turns off when the
    driving pin (7) is LOW and the pin is floating like that during the powering on
    phase of Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may need to adjust the value of R1 in the range of 1K to 1M in order to
    ensure that the MOSFET doesn't turn on when not expected to.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RFduino instead of Arduino**'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we can use RFduino instead of Arduino (for more information,
    visit [http://www.rfduino.com](http://www.rfduino.com)). It is compatible with
    Arduino, and also includes the Bluetooth device and the related software stack.
    Moreover, it can act as an iBeacon at the same time. One device could cover all
    the hardware requirements for the project. It doesn't have the EEPROM that we
    are going to use to store PINs, but we can store them in flash. The original version
    of this project was on RFduino and was a commercial product. For this book, I
    chose to work with Arduino to avoid buying another piece of hardware and because
    RFduino requires a more complex code to use Bluetooth for receiving commands and
    acting as an iBeacon at the same time. You can try to build the project on RFduino
    yourself. This could be a good opportunity to learn more. Check out RFduino. It's
    an amazing product!
  prefs: []
  type: TYPE_NORMAL
- en: Arduino code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding of the explanations in the next paragraphs, open
    the downloaded code while reading them.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we are going to use EEPROM to store PINS. In fact, this memory
    doesn't lose its content when it's not powered.
  prefs: []
  type: TYPE_NORMAL
- en: To store a PIN, we use the first character to indicate whether it is used or
    not and the last five characters to store the actual PIN (which is exactly five
    characters long). PINs are stored sequentially in EEPROM, starting from address
    0.
  prefs: []
  type: TYPE_NORMAL
- en: Setup code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the downloaded code. Since the setup code is quite simple, it
    doesn't require a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup code is not much different from the setup code of other projects.
    Let''s take a look at the EEPROM initialization instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop initializes the EEPROM locations that are used to initialize
    PINs to 0\. This loop has to be executed only the first time the code is executed,
    otherwise, it clears the stored PINS. In the *Testing and tuning* section, we
    will provide more details on this.
  prefs: []
  type: TYPE_NORMAL
- en: The last few lines write the master PIN from location 1 (the master PIN is 12345
    in the example). The location 0 is set to 1 to indicate that the next five locations
    are used to store a PIN.
  prefs: []
  type: TYPE_NORMAL
- en: Main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The loop function is very easy. It only checks whether the door has been opened,
    and after this, `CLOSING_DOOR_INTERVAL` closes it by calling the `pulseOutput`
    function that pulses the relay for 300 ms.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the Arduino code is used to react to the messages that are received
    in the `rxCallback` function.
  prefs: []
  type: TYPE_NORMAL
- en: Each message is made up of a PIN (five characters) followed by a few other characters.
    The PIN is checked, and if it's not recognized, the message is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main message is used to open the garage door: <PIN>O=1, where <PIN> is
    the 5 characters long PIN assigned to the user who is opening the door. When it''s
    received, it pulses the relay and opens the door.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the other messages, which are as follows, are related to PIN management:'
  prefs: []
  type: TYPE_NORMAL
- en: '`P`, when the iOS device requests the list of the current PINs stored in the
    Arduino EEPROM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A`, when the iOS device needs to add a new PIN. The next 5 bytes after the
    command are the actual PIN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E`, when the iOS device needs to update an existing PIN. The first byte after
    the command is the index of the PIN that needs to be edited, which is followed
    by 5 bytes of the new PIN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`, when the iOS device needs to delete an existing PIN. The first byte after
    the command is the index of the PIN that needs to be deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions, which implement each command, don't require much explanation.
    Note that the master PIN (PIN at the location 0 in EEPROM) is never transferred
    to the iOS application. To change the master PIN, it has to be changed directly
    in the code. The `printPins` function that dumps all the stored PINs can help
    you understand how the functions work. Comment out the calls that are already
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: iOS code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at the iOS application that monitors the
    iBeacon region and the geofencing region and sends a command to open the door.
    The same application manages the PINs that can be assigned to relatives, guests,
    and friends in order to open your garage.
  prefs: []
  type: TYPE_NORMAL
- en: The application can also be used to open the garage door manually like a traditional
    remote control.
  prefs: []
  type: TYPE_NORMAL
- en: The full code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: To understand better the explanations in the next paragraphs, open the downloaded
    code while reading.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Xcode project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a new project as we have done in the previous chapters. The
    following are the steps that you need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the parameters for the new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Type**: Tabbed application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product Name**: GarageiBeacon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: Objective-C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: Universal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to set a capability for this project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the project in the left pane of Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Capabilities** in the right pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the **Background Modes** option and select **Location updates** (see
    the following screenshot):![Creating the Xcode project](img/image00221.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once more, since the structure of this project is very close to the Pet Door
    Locker, we can reuse a part of the user interface and code by following these
    steps (for more details, go back to the iOS guided rover project in [Chapter 4](part0033.xhtml#aid-VF2I1
    "Chapter 4. iOS Guided Rover"), *iOS Guided Rover*, where we did almost the same
    thing as this):'
  prefs: []
  type: TYPE_NORMAL
- en: Select **FirstViewController.h** and **FirstViewController.m**, right-click
    on them, click on **Delete**, and select **Move to Trash**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the same procedure, delete **SecondViewController** and **Main.storyboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **PetDoorLocker** project in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the following files and drag and drop them to this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.h**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.m**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main.storyboard**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that **Copy items if needed** is selected and then click on **Finish**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the icon that was used for the BLEConnectionViewController view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new View Controller class called `GarageViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Main.storyboard** and locate the main View Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all the graphical components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Identity Inspector** and change the **Class** to **GarageViewController**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to make location properly ask for authorization, we need to add a new
    file. Do this by navigating to **File** | **New** | **File…** and then select
    **iOS - Resource** and **Strings File**. Click on **Next** and enter the name
    of the file, `InfoPlist`. Finally, click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the newly created file and enter the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we are ready to create the new application!
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface for BLEConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to add many components to this view controller to add our personal PIN
    and information related to the geofencing region.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should be a master in adding UIKit components and the related Layout
    Constraints. So, we won''t spend much time on this subject. Your final result
    should look similar to the one in the following picture. Anyway, you can always
    refer to the downloaded code, in case you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface for BLEConnectionViewController](img/image00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We also need to set the delegate outlet of the **PIN** text field to the BLEConnectionViewController
    in order to know when it changes. You can do this by using the Connection Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the PIN text field, we need to mask the values that will be entered. To
    do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Attributes Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Secure Text Entry** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Linking the new components to the code, you should end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **Set House Position** button will be used to set the center of the geofencing
    region around the house, and the **House Region Size** segment will be used to
    set the radius of the geofencing region itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The button is connected to the method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The segment is connected to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Designing the user interface for GarageViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This view controller is the main view controller of the application, and it
    should contain the button to manually open/close the garage door, just in case!
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a learning project, we added some components to give the user
    a lot more information about their position with respect to the iBeacon and geofencing
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface for GarageViewController](img/image00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, the two buttons have a background (you can copy it from the downloaded
    code; it is named `buttonBackground.png`). To add it, select the button, open
    the **Attribute Inspector**, and select **buttonBackground.png** for the **Background**
    (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface for GarageViewController](img/image00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Don't forget to change the **Text Color** to white.
  prefs: []
  type: TYPE_NORMAL
- en: You can also copy the images for the three LEDs (`blueLED.png` and `grayLED.png`)
    from the downloaded project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have linked the GUI components to the code, you should end up with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the two buttons are linked to the two methods respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Designing the user interface for PinsViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need another view controller to manage the PINs. Create and link it to the
    main view controller like we did in the previous projects and embed it into a
    Navigation Controller. To do this, select the new view controller and navigate
    to **Editor** | **Embed In Navigation Controller**. This creates a Navigation
    Bar, where we can drop a button for adding the PINs (see the circled area in the
    following screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI components are shown in the following screenshot. Basically, they are
    a Table View to show the enabled PINs and a field where one can enter the Master
    PIN. Only the person who knows the Master PIN can manage the other pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface for PinsViewController](img/image00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before moving on to the next section, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named PinsViewController that is inherited from UIViewController.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the PinsViewController in the storyboard, open the Identity Inspector,
    and select PinsViewController for **Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Connections Inspector (browse **View** | **Utilities** | **Show Connections
    Inspector**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Table View, drag the dataSource, and delegate outlets to the PinsViewController
    class (see the following screenshot). This tells the Table View to ask for items
    to show and inform about the events in the PinsViewController:![Designing the
    user interface for PinsViewController](img/image00226.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the delegate outlet of the master PIN field to the view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Secure Text Entry** checkbox for the master PIN.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Linking the GUI components with the code, you should end up with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'and with the method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Writing code for BLEConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we copied this View Controller from the Pet Door Locker project, we need
    to make only a few changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to open the **BLEConnectionViewController.h** file and add the
    following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make a change to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding lines to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the `BLEConnectionViewController.m` to make the rest of the changes.
    Let''s add a new property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The location manager allows us to get the geographical coordinates (through
    the GPS receiver of our iOS device) of our house. This will be used to create
    the geofencing region.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the location manager, we have to change the `viewDidAppear` method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The location manager has to be authorized by the user to work. For this reason,
    we need to issue the following method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this method, the iOS starts an authorization request to the user that
    contains the message we added to the InfoPlist file we created in the previous
    section. The code that is needed to start receiving the position of your own house
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code doesn't require any explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the GPS receiver has located the position, the following method is called,
    and we can store the longitude and latitude of the house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note that once the coordinates are available, we stop the location manager
    to update them (`[manager stopUpdatingLocation]`). We do this to save batteries
    and because we do not check the coordinates anymore to know whether we are inside
    or outside the region around the house. See the following sections to understand
    how we get this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we change the size of the geofencing region, the following method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is where we store the size of the region itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method that we need to write is used to store the personal PIN once
    it is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the values of the text fields when the view controller is started,
    change the `viewDidLoad` method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the view controller is not shown on the screen, we can free both the location
    manager and the central manager, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to work on the GarageViewController, which is much more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for GarageViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we use both the location manager and the central manager, we need to
    update **GarageViewController.h** with the required includes and protocols ending
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then, we open the **GarageViewController.m** to add the code to manage the notifications
    from the geofencing regions and the iBeacon region, and to send an opening message
    to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add the code used to manage the Bluetooth communication with Arduino.
    This code is almost the same as what we used in the previous chapters. So, we
    don''t have to spend much time on it. We just point out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don't receive any data from Arduino via Bluetooth, the `didUpdateValueForCharacteristic`
    function can be removed, and we don't need to look for the characteristic that
    was used to receive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the application gets connected to Arduino, it immediately sends the opening
    command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `didDiscoverCharacteristicsForService` method is slightly different from
    what we used in the other projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the view controller is started, we have to initialize the location manager
    and create the geofencing region and iBeacon region, if they are not yet created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the location manager is initialized and authorized by the user, the following
    method is called and the iBeacon region is created (we will discuss the actual
    iBeacon region creation later in this section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we call a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This method activates a key-value observer in user defaults, where information
    about the geofencing region is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Key-value observing**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about key-value observing, take a look at the Apple documentation
    at [http://apple.co/1PZ6aJm](http://apple.co/1PZ6aJm).
  prefs: []
  type: TYPE_NORMAL
- en: Now, every time the `HouseLongitude` changes, the `observeValueForKeyPath` method
    is called, and this allows us to create or update the geofencing region. Note
    that `HouseLongitude` changes in the BLEConnectionViewController when the user
    locates the house. The KVO technique allows you to automatically keep the geofencing
    region updated. The KVO is also set for the `HouseSize` user default property
    so that the region gets updated when the user changes the size of the region itself.
  prefs: []
  type: TYPE_NORMAL
- en: We can also set the KVO for the `insideHouse` property. We will talk about this
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `observeValueForKeyPath` method where the geofencing
    region is actually created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the geofencing region, we need to define its center, which is the
    location of the house, and a radius that is manually chosen. Then, call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The iOS knows that we need to receive a notification as soon as we enter or
    exit the geofencing region. Therefore, we call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We request the iOS to establish whether we are inside or outside the geofencing
    region and call the `locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state
    forRegion:(CLRegion *)region` method to inform us about the same (we'll talk about
    this method later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how iBeacon is created instead. Remember that when the location
    manager is authorized and the central manager, which manages the Bluetooth connections
    and communication, is turned on, the following method is called in order to create
    the iBeacon region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The creation of the region is quite similar to that of the geofencing region.
    This time, the region has an UUID, a major, and a minor instead of a center and
    a radius.
  prefs: []
  type: TYPE_NORMAL
- en: Once the iBeacon region is created, we ask the iOS to start monitoring it (`[_locationManager
    startMonitoringForRegion:beaconRegion]`) and immediately tell us whether we are
    inside or outside the region itself (`[_locationManager requestStateForRegion:beaconRegion]`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the most important part of the code—the code that
    actually manages the regions' boundary crossing and sends the command of opening
    the garage door.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we enter a region, the `didEnterRegion` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines send a local notification to the user to inform them that
    the region border has been crossed going into it.
  prefs: []
  type: TYPE_NORMAL
- en: If you are entering the iBeacon region and you are inside the house (`_insideHouse
    = YES`), nothing happens. This means that if the iBeacon region cannot cover the
    entire house and if you exit the iBeacon region by moving inside your house, you
    don't open the garage door unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not in the house, the app gets connected to Arduino (via Bluetooth)
    and the garage door opens. Don't forget that the actual opening command is sent
    into the `didDiscoverCharacteristicsForService` method.
  prefs: []
  type: TYPE_NORMAL
- en: Forget `[_locationManager startRangingBeaconsInRegion:(CLBeaconRegion *)region]`
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Enabling local notifications**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to send local notifications, they have to be authorized by the user.
    To do this, we need to call the `[application registerUserNotificationSettings:[UIUserNotificationSettings
    settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound
    categories:nil]]` method as soon as the application starts. The `didFinishLaunchingWithOptions`
    method is the place where we call it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we get into a region, the `didExitRegion` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After sending a local notification, if we are exiting the geofencing region,
    we can set the `insideHouse` property to `NO` so that when we enter the iBeacon
    region again, the opening command is sent. Forget `[_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion
    *)region]` for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why don''t we use the traditional code (`_insideHouse = YES`) to set the property?
    In the `viewDidLoad` method, we set an observer for the property so that every
    time it changes, the `observeValueForKeyPath` is called. The traditional code
    doesn''t start the `observeValueForKeyPath` method, and we need to use `[self
    setInsideHouse:NO]` instead. When the `observeValueForKeyPath` is called because
    `insideHouse` changes, we update the image of the `readyToOpen`, keeping the user
    informed about whether the app will send the opening command on entering the iBeacon
    region or not. To do this, we need these few lines of code into the `observeValueForKeyPath`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Working in the background**'
  prefs: []
  type: TYPE_NORMAL
- en: What makes the iBeacon technology along with geofencing particularly interesting
    is that `didEnterRegion` and `didExitRegion` are also called when the application
    is either running in the background, or not even running. Unfortunately, when
    the application is not running, the iOS starts it and keeps it running for some
    period of time (for about 3s) to save the batteries. So, any kind of action that
    is required to respond to the event has to be very quick. In the code, we just
    connect to the Arduino and send a few bytes to it, and this takes up much less
    time than 3s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last relevant method that we need to write is `didDetermineState`, which
    is called to find out where the device is with respect to a region (calling `[_locationManager
    startMonitoringForRegion:beaconRegion]` or `[_locationManager startMonitoringForRegion:houseRegion]`)
    or when the iOS recognizes that something has changed. In this function, we update
    the indicators that visually inform the user that they are in one of the monitored
    regions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that the visual information (inside the iBeacon and geofencing region,
    ready to open the garage door) is not strictly needed. We put that in the app
    to make you experiment with iBeacon and geofencing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`manualOperation`: This manually opens the garage door by sending the opening
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simulateHomeRegionExit`: This simulates the exit from the geofencing region
    by manually setting the `insideHouse` property to `NO`. This can be useful in
    the debugging phase or if you wish to learn how the application works without
    having to actually drive away from your house (which we did too many times!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is very simple and doesn''t require much explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The very last two methods (we promise!) that you need to look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`didRangeBeacons`: This method is not used in this project, but we have shown
    it because it may be very useful in another iBeacon project, as it gives an estimation
    of the distance between an iOS device and each iBeacon in range. Ranging iBeacons
    can be started and stopped by using `[_locationManager startRangingBeaconsInRegion:(CLBeaconRegion
    *)region]` and `[_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion *)region]`
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monitoringDidFailForRegion`: This method tells us whether something is wrong
    in the monitoring of any region. Never forget to implement it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Writing code for PinsViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This view controller manages the PINs that are required to authorize your relatives
    and friends so that they can access your garage. It works almost in the same way
    as the ActivationsTableViewController in the Power Plug project. So, we won't
    spend much time on it.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference here is that we have to enter just a PIN, and it doesn't
    make sense to create a screen for that. We take advantage of a feature of UIAlertView.
    By setting its style to `UIAlertViewStylePlainTextInput`, it presents a text field
    in which we can enter the PIN. This is very easy and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to write this view controller yourself and compare your results
    with the downloaded code. Let's give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to test this project and impress our neighbors. First, you
    have to set the iBeacon parameters. If you are using RedLab iBeacon, you can set
    it by using the iOS app that is available from the iTunes Store for free ([https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&mt=8](https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&mt=8)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to enter the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UUID**: 00000000-0000-0000-0000-0000000000FF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Major**: 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advertising Interval**: 250 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TX Power**: 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Double-check the UUID. It's a long string, and any error prevents the iBeacon
    from being recognized by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tuning the iBeacon parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: Once everything works as expected, you can try reducing the TX power and/or
    Advertising Interval. The lower they are, the more battery you save, and the longer
    the iBeacon works without you having to replace the batteries. Moreover, reducing
    the TX power allows you to send the opening command when you are closer to your
    garage. Let's make some tests to detect the best values for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a different iBeacon, ask the manufacturer how to set the parameters
    so they are exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should place the iBeacon near your garage door at a high position and
    leave it turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Wire the relay contacts or the MOSFET pins to your garage door opener (please
    refer to the electric diagrams provided at the beginning of this chapter). There
    are a lot of different models out there, so you need to do this yourself. The
    general advice is that you have to put the relay exit (or the exit connected to
    the MOSFET) in parallel to the push button that you use to manually open and close
    the garage door. Take a look at your garage door opener instruction manual for
    more information and directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting the test phase, we need to set up the Arduino code to properly
    clean up the EEPROM and store the master PIN. To do this, perform the following
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `setup` function, comment out the following lines, which clean up the
    EEPROM and store the master PIN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can change the master PIN (12345) to your preferred code here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Upload the code to Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment the previous code again and upload it to Arduino. Now, the EEPROM is
    cleared and the master PIN is stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when you open the app, you will see a message. You have to respond to
    this message by selecting **Allow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and tuning](img/image00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the app, open the Configuration tab, scan for the RF8001, choose your personal
    PIN, enter it in the PIN field, and then tap on Set House Position. A few seconds
    later, you should see the longitude and latitude of your house, as acquired by
    the GPS.
  prefs: []
  type: TYPE_NORMAL
- en: Set the **House Region Size** to 100 meters. Change it to a higher value only
    if your garage door opens unexpectedly when you are inside your house or if you
    have a very large house (lucky you!).
  prefs: []
  type: TYPE_NORMAL
- en: Tap the **PINS** tab, enter the master PIN (`12345`, if you have not changed
    it in the Arduino code), and tap *Enter*. You should see an empty list. Tap on
    the add button (**+**) and enter your personal PIN that you chose before.
  prefs: []
  type: TYPE_NORMAL
- en: Tap on the Main tab and then tap on the **Open** button. Now, your garage should
    open and then close about 30 seconds later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To change the closing delay time, you have to change the value of CLOSING_DOOR_INTERVAL
    in the Arduino code. Moreover, to operate the garage door opener, Arduino shorts
    the control line for about 300 ms. If this is not enough for your device, you
    can change the delay in the `pulseOutput` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to test the most exciting feature—opening the garage automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Main tab again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the **In House Region** indicator turned on, the **In Garage
    Region** turned off, and the **Ready To Open** turned on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the **Ready To Open** indicator is off, tap on **Simulate Exit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close your app, sending it to the background or closing it from the task list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the iBeacon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see a notification on the screen and hear a short sound, and your
    garage should start opening.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you move around and inside your house, your garage shouldn't open anymore
    (the **Ready To Open** indicator should remain off).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drive away from your house until you hear a sound notification from your iOS
    device. Please drive safely. You don't need to look at your iOS device while driving.
    The sound notification alerts you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a stop and check the application. Now, the **Ready To Open** indicator
    should be on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drive back to your house. As soon as you are close enough to the iBeacon, you
    should hear a notification, and the garage door should start opening.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you are ready to impress your neighbors!
  prefs: []
  type: TYPE_NORMAL
- en: How to go further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some improvements that could be done to this project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the automatic door closing interval directly from the app instead of
    changing the Arduino code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning the garage lights on and off on entering and exiting the garage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening the garage door from the inside by using the noise generated by the
    car engine instead of manually. This requires listening to the motor noise from
    the iOS device and comparing it with a pre-recorded noise of the motor. This is
    done to avoid a situation where a noise inside or outside the garage unexpectedly
    opens the door. For signal comparison, you can use an operation called the correlation
    of two signals (take a look at the Accelerate framework that is available in iOS),
    but you have to pay attention to the fact that the acquired signal and the pre-recorded
    signal may have different lengths and/or may be time shifted. Okay, this is a
    big challenge, but this is the last chapter of the book, and you should be a master
    of Arduino and iOS programming by now. Digital signal processing is an art that
    you may be interested in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the garage door is effectively closed by using a reed switch,
    a hall effect sensor, or an ultrasonic distance sensor, and having a notification
    sent to your phone. You may need the WiFi Shield to take advantage of one of the
    available IoT services to send the notification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building this project, you learned a lot, especially with regards to iOS.
    You learned how to create and manage the geofencing and iBeacon regions. This
    opens the door to many different projects on iOS with or without the Arduino integration.
    Moreover, you learned how to monitor changes in properties (KVO), which is a technique
    that lies at the base of good programming together with the help of Model-View-Controller
    model. This can be applied many times. On Arduino, you learned how to use EEPROM
    to store information that needs to be permanently stored on the board to control
    the behavior of your programs.
  prefs: []
  type: TYPE_NORMAL
- en: This project ends this long journey of Arduino and iOS programming and the two
    platforms' integration.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you had fun reading the book, coding, and building at least some
    of the proposed projects (or maybe all!). Mostly, I hope that you learned more
    about Arduino, iOS, and their integration so that from now on, you can design
    and build your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Have a great time making some revolutionary and game-changing projects!
  prefs: []
  type: TYPE_NORMAL
