- en: Chapter 6. Adding Game Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about animating our objects on the screen
    using tweens; we also learned about sprite sheets, generated our very own sprite
    sheet with texture information, and animated it.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at what kind of topics we will tackle in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Shooting cannonballs, which is pretty much a core mechanic of our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a cannonball is displayed on the battlefield, it should be able to collide
    with the enemy ship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying the enemy ship, if enough cannonballs hit the ship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the asset manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we loaded our very first texture atlas and displayed
    each subtexture as frames in a movie clip. We did not use our asset manager for
    this as we hadn't implemented this functionality yet.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's go ahead and allow our asset manager to deal with texture atlases.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding texture atlases to the asset manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can extend our asset manager with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our game's project file, if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the `TextureManager.h` file and declare the method `registerTextureAtlas`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to the `TextureManager.m` file and implement the `registerTextureAtlas`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Head over to the `Assets.h` file and add the static method `textureAtlas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Assets.m` file, implement the following method by referring to its
    `TextureManager` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the battlefield scene (`Battlefield.m`), navigate to where we are loading
    the texture atlas and getting the textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the preceding code with the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example. We will see the following constellation of ships on the screen:![Time
    for action – adding texture atlases to the asset manager](img/1509OS_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we opened our Xcode template from where we left off in the previous
    chapter. In order to load texture atlases, we needed to switch to the texture
    manager, which we designated to load everything that is remotely connected to
    textures. In step 2, we declared the method we used in order to use texture atlases
    through the asset management system. To keep the method names consistent, we will
    name this method `registerTextureAtlas` to make it similar to `registerTexture`.
    The signature resembles that of `registerTexture`, but it returns an instance
    of `SPTextureAtlas` instead of `SPTexture`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we implemented the `registerTextureAtlas` method that loads
    the texture through the `filename` parameter, and we used the `SPTextureAtlas`
    factory method just like we did when we learned about texture atlases.
  prefs: []
  type: TYPE_NORMAL
- en: Once we finished extending the texture manager part, we needed to extend the
    `Assets` class, which we did in step 4 by adding the function head which we implemented
    in step 5\. To keep the naming scheme consistent, we named this method `textureAtlas`.
    In this method, we just called the `registerTextureAtlas` method of our texture
    manager and returned the result.
  prefs: []
  type: TYPE_NORMAL
- en: We updated the lines in the battlefield to load the texture atlas for the movie
    clip through the asset management system. Instead of two lines—one for setting
    up the texture atlas instance and another for getting the needed textures out
    of the atlas—we now have only a single line that gets our texture atlas with the
    `textureAtlas` method from the last two steps and then gets the necessary textures
    for the movie clip.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example in the last step, we had the exact result as we did
    at the end of the previous chapter, which is a good sign and an indication that
    the changes work as they should.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our ships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our ships are just instances of `SPImage` with tweens attached to them
    right inside our battlefield scene. In order to keep code duplication to a minimum,
    let's refactor the ship logic into its own class.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a ship class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To structure the code of our ship, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new group called `Entities`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this group, add a new Objective-C class called `Ship`, which is derived
    from `SPSprite`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Ship.h` file. Add one instance variable for the ship image and another
    for the movie clip of the ship shooting cannonballs, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an alternative initializer called `initWithContentsOfFile`, which takes
    an `NSString` as its parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a method called `shoot`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare another method called `moveTo` that takes the `x` value as its first
    parameter and the `y` value as its second parameter, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a method called `stop`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the default initializer for the `Ship` class with the following lines
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the alternate initializer that takes `filename` as its parameter,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `shoot` method with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The content of the `moveTo` method should look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `stop` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to the `Battlefield.h` file and update the class so that the instance
    variable `_pirateShip` is from the type `Ship`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, switch to the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `onBackgroundTouch` method in the scene, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the `onShipStop` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the remaining references from `SPImage` to the `Ship` class and remove
    all occurrences of the cannon ship, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example. We now see the pirate and enemy ships on the screen:![Time
    for action – creating a ship class](img/1509OS_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In game development, the term entity usually refers to an object on the screen
    which interacts with other objects. Let''s take a 2D action side-scroller as an
    example: the enemy ships as well as the ship controlled by the player were entities.
    The bullets were entities too. A bullet, for example, interacted with the player
    ship as it spawned from it. The enemy ships interacted with the bullets; if a
    bullet hit an enemy ship, it needed to react by losing hit points or by being
    destroyed. The same applied to the player ship.'
  prefs: []
  type: TYPE_NORMAL
- en: Entities also feature in more advanced game development techniques such as the
    entity-component pattern, where the interaction is described as components. These
    components are then attached to entities.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to take away from our game is a clear separation between the different
    elements of the game. In step 1, we added a new group called `Entities`. In the
    next step, we defined our very first entity called `Ship`, which is a subclass
    of `SPSprite`. It was also possible to add a prefix before the class name, just
    like all Sparrow classes have the prefix `SP`. For our game, the prefix `PG` would
    make sense as it stands for PirateGame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ship had two instance variables, which we declared in step 3: one was the
    cannonball-shooting animation we previously saw in the battlefield scene and the
    second was the image of the ship itself.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the default initializer, we declared a second initializer in
    step 4\. This method takes `filename` as a parameter. We didn't want to create
    a separate class for the pirate ship. We can use the same class for both types.
    We just needed a different `filename` parameter for either the enemy or the pirate
    ship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our ship class needed to have the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: Shooting (step 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the ship to a certain position (step 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping the movement (step 7)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `Ship.h` file now looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all methods and instance variables for the `Ship` class were declared,
    we went on to implement the methods. Before we did that, we defined the initializer
    in step 8: we initialized the movie clip—with the texture atlas from the shooting
    pirate ship—and the ship image itself. The only difference to what we know so
    far is that we are initializing the image if it hasn''t been initialized yet.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second initializer that we implemented in step 9, we initialized the
    image with the filename we passed in and we called the default initializer. So,
    if the alternate initializer was called, we didn't overwrite the `_idleImage`
    instance variable with a fresh instance of `SPImage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full piece of code of `Ship.m` up to this point is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next steps, we implemented methods for the ship''s actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shooting**: Plays the `_shooting` movie clip (step 10).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moving**: This is the moving logic of the ship we previously had in the `backgroundTouch`
    method in the battlefield scene. Instead of removing all tweens from the ship
    instance, we called the `stop` method from the `ship` instance (step 11).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopping**: Removes all tweens from the current instance (step 12).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In its completeness, these methods look like the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the last steps, we updated the battlefield scene. First, we updated the header
    file. We needed to import the `Ship.h` file, and instead of being a pointer to
    `SPImage`, the `_pirateShip` instance variable was a pointer to the `Ship` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this step, our `Battlefield.h` file had the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We updated the touch interactions in the battlefield scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onBackgroundTouch`: Since we moved the movement logic to the `Ship` class,
    we just needed to call the correct method, which was `moveTo`, and pass in the
    *x* and *y* coordinate of `touch` (step 15)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onShipStop`: Similar to the `moveTo` method, we just needed to call the `stop`
    method of the ship itself (step 16)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The touch events inside the `Battlefield.m` file should resemble the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the next step, we updated the initializer for the ships. We didn't need the
    `cannonShip` movie clip anymore as this was an instance variable inside the `Ship`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the initializer in the following code that binds these
    touch selectors and sets up the ship itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we ran the example, we saw two ships on the screen; if we tapped anywhere,
    our pirate ship moved to that point, just like we expected it to. If we touched
    the ship during movement, it stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the ship class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the base of our ship class is done, let''s think of what we need for
    the ship class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hit points**: If a ship is hit, the hit points should reflect this state.
    The ship will start out with a given number of hit points, say 20 for example,
    and it will lose some each time it is hit. When it finally reaches zero hit points,
    it will be completely destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direction**: This is the direction the ship is facing. Depending on the direction,
    the cannonballs will be fired from each side of the ship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should abstain from using filenames where we don't necessarily need to, for
    example now, when initializing our ship instances.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go ahead and get to the coding part of things, let's download the
    latest images from [https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip).
    These images include updated sprite sheets for both the pirate ship and a cannonball
    that we will use later.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `ship_small_cannon` files and copy the newer files to the project.
    This can be done easily, but Xcode doesn't always like replacing existing files.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding more functionality to the ship class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s extend the ship class using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `enum` for the eight directions of the ship, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another `enum` for the type of the ship, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `_shootingClip` instance variable to be a pointer to the `NSArray`
    class and remove the `_idleImage` instance variable, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a property for the ship''s `hitpoints`, as shown in the following line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another property for `type`, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third property is the direction of the ship:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because we will need to write custom getters and setters for this property
    as well, we will need an instance variable of the same name, prefixed with an
    underscore:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `initWithContentsOfFile` method declaration with `initWithType`.
    This method takes `ShipType` as its parameter, as shown in the following line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Ship.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s implement the `initWithType` method with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the `initWithContentsOfFile` method and update the default initializer
    to use the `initWithType` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the custom getter for the `direction` property by simply returning
    the `_direction` instance variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The setter for the `direction` property needs to have the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the content of the `shoot` method with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `moveTo` method, after the creation of the `tweenX` and `tweenY`
    objects, declare and define two variables that should detect which direction the
    ship will be rotated to, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Only update the values if a certain threshold has been broken, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `direction` to `DirectionEast` if `signX` has the value `1` and `signY`
    still has the value `0`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat this for all the remaining directions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the initializers to the pirate and enemy ships. Only the pirate ship
    needs to have the `PirateShip` value from the `ShipType` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `onShipStop` method, add the functionality to shoot when the pirate
    ship is tapped twice and stop if the ship is tapped once, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename `onShipStop` and all its references to `onShipTap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now see that the ship is moving in the direction where we touched the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – adding more functionality to the ship class](img/1509OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we opened the ship header file, and then we defined an `enum` for all
    the direction states. Objective-C provides a handy `NS_ENUM` macro which lets
    us do exactly that. As the first parameter, we need the type the `enum` will be
    represented as. The second parameter is the name of the `enum` type. This `enum`
    type has eight states: north, south, west, east, and a combination of these.'
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we defined a second `enum` for the type of ship. It can either be
    a pirate ship or a normal enemy ship without black flags.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we redefined the type of the `_shootingClip` instance. The reasoning
    behind this change is that we hold all movie clips in an array and can access
    a specific movie clip through the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few steps, we added a few properties to the class, as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hitpoints`: This indicates how many hit points the ship currently has (step
    5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This indicates the type of the ship (step 6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direction`: This indicates the direction the ship is facing (step 7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it would have been fine to just add the filename to each initializer call
    when we created an instance of the ship class, it would get messy once we either
    changed all of these filenames or if we had more than just a few ships on the
    screen. This is why we replaced the `initWithContentsOfFile` method with the `initWithType`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implemented all of the methods we just declared. We started with the
    one we declared last. As this was our go-to initializer, we got through what was
    happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the `hitpoints` property to `100`. While `100` is more or less a random
    number, it is a good starting point to balance from as it's very easy to calculate
    with. For example, let's say we require four hits to destroy any ships; the damage
    potential of a cannonball is 25.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the `type` property to the value of the `type` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We set the texture atlas to either the pirate ship atlas or the other option,
    depending on the type. A ternary operation was just a fancy way of writing an
    `if` statement, as shown in the following line of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The advantage of the ternary operation was that we could assign its result directly
    to a variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We got the textures for each direction. Within the texture atlas, every direction
    of the shooting animation was prefixed with the abbreviation of the direction:
    `n` for north, `nw` for northwest, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then defined the speed for the animations. We set it to 12 frames per second
    as we didn't want the animation to be slower than usual. After all, operating
    the cannons is tough.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like we made an instance of `NSArray` for every direction, we needed to
    do the same for all the movie clips. We could also write this line as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added all movie clips to the `_shootingClip` instance variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the movie clips were added to the display tree by iterating over the `_shootingClip`
    instance variable. We also wanted the movie clips to play only once, which is
    why we set the `loop` property to `NO`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default direction of a ship was south-west.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In step 11, we significantly simplified the default initializer by just calling
    the `initWithType` initializer with the `ShipNormal` type.
  prefs: []
  type: TYPE_NORMAL
- en: We started with creating the custom getters and setters for the `direction`
    property. We added the `nonatomic` keyword to the property definition. This was
    a performance optimization method to make the generated accessor faster, but non-thread
    safe. Since Sparrow should only be used single-threaded, it was safe to use `nonatomic`
    in our game. Internally, Objective-C had already defined the getters and setters
    as `propertyName` and `setPropertyName`, or in our case, `direction` and `setDirection`.
  prefs: []
  type: TYPE_NORMAL
- en: To use our own code, we just needed to overwrite these methods. The getter for
    the `direction` property was pretty simple as it just needed to return the `_direction`
    instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: In our custom setter for the `direction` property, we needed to set the instance
    variable `_direction` to the value of the parameter first. Then, we iterated through
    all the movie clips and set its `visible` property to `NO`. We then showed the
    movie clip of the current direction. This was very similar to how we show scenes
    through the scene director.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 14, we updated the `shoot` method using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We removed all animatable objects from the juggler which originate from any
    of the movie clips.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We played the movie clip from the current direction and added it to the juggler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added an event listener to the movie clip that fired when the movie clip
    animation was complete. Instead of a selector, we used a block. A block (also
    called a closure in non-Objective-C environments) is a function which has access
    to non-local variables. So, while we could define variables inside the block,
    we accessed the variables as if we were declaring a statement inside the `shoot`
    method. A block had a certain appeal to it as we didn't need to define a separate
    selector for just a few lines of code. There were few things we needed to be careful
    about when using blocks, but Xcode usually warned us about potential side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside our block, we stopped the movie clip as it didn't reset itself. It was
    like rewinding a VHS tape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this time, we updated the ship''s direction when it moved. To achieve this,
    we defined two variables inside the `moveTo` method: `signX` and `signY`. Their
    default values were `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind that was to map the direction from the values we got in our
    `moveTo` method to a value from the `ShipDirection` values. If `signY` was `1`,
    it would map to `DirectionNorth`; if `signX` was `-1`, it would map to `DirectionWest`;
    and if both had the values at the same time, they would map to `DirectionNorthWest`.
  prefs: []
  type: TYPE_NORMAL
- en: We had set the `signX` variables to the *x* coordinate of the object minus the
    target *x* coordinate and dividing that by `distanceX`. So, our values for `signX`
    were either `1` or `-1`. The same happened for the `signY` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we moved the ship, we only got directions such as `DirectionNorthWest`,
    `DirectionNorthEast`, `DirectionSouthEast`, and `DirectionSouthWest`. It is pretty
    much impossible to tap the same pixel on a line twice. This was why we needed
    a threshold. We only set `signX` and `signY` to `1` or `-1`, respectively, if
    distance was more than 40 points. In this case, 40 was not a random number; a
    rectangle with 40 x 40 points is the average size of a tap, according to Apple.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 17 and 18, we mapped the `signX` and `signY` variables to the `ShipDirection`
    values, and we set the `direction` property accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Within the battlefield scene, we needed to create our ship instances. For the
    enemy ship, we used the default initializer.
  prefs: []
  type: TYPE_NORMAL
- en: In step 21, we updated the `onShipStop` method. We utilized the `tapCount` property
    of the `touch` object to see how many times the object had been tapped. If the
    ship had been tapped once, it would stop its movement, and if it had been tapped
    twice, it would shoot.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `onShipStop` method did not only stop the ship but also shot if tapped
    twice, it was a good call to rename this method to `onShipTap`.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, the ship changed its direction depending on where we
    tapped on the screen, and when we double-tapped the ship, we saw the cannon animation.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting cannonballs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we double-tap our ship, the animation plays. However, there is one obvious
    thing missing, the cannonballs! Let's go ahead and add some cannonballs.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – allowing the ship to shoot cannonballs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s allow the pirate ship to shoot cannonballs by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a read-only property called `isShooting`, which has an instance variable
    counterpart called `_isShooting`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a cannonball for the left-hand side and the right-hand side of the ship.
    Both of them are pointers to `SPImage`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Ship.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `initWithType` method, set the `_isShooting` instance variable to
    `NO` at the top of the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `initWithType` method, create both cannonballs with the `cannonball.png`
    image, set their `visible` property to `NO`, and add them to the display tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `shoot` method, abort if `_isShooting` is set to `YES`, else set
    `_isShooting` to `YES`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set some default values for the animation speed and target position, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a reference to the movie clip with the current direction, as shown in the
    following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a tween object for each cannonball and their respective *x* and *y*
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the cannonballs and their tween properties for a direction pair, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up the cannonballs for the `DirectionEast/DirectionWest` pair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set both cannonballs to be visible on the screen and add all cannonball-related
    tweens to the main juggler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all tweens that originate from the cannonballs just after the line where
    we removed all tweens originating from the movie clips.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the movie clip is finished, set the `_isShooting` instance variable to
    `NO` and hide both cannonballs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example. Our pirate ship can now shoot cannonballs, as shown in the
    following screenshot:![Time for action – allowing the ship to shoot cannonballs](img/1509OS_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started this example in the header file of the `Ship` class, where we added
    a few new properties, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isShooting`: This indicates if the ship is currently shooting (step 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cannonBallLeft`: This indicates the cannonball shooting from the left-hand
    side of the ship (step 3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cannonBallRight`: This indicates the cannonball shooting from the right-hand
    side of the ship (step 3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next steps, we modified the `initWithType` method using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We set `_isShooting` to a default value, which is `NO` (step 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the cannonball objects (step 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We hid both cannonballs (step 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the cannonballs to the display tree (step 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s head into the `shoot` method and see what changed here:'
  prefs: []
  type: TYPE_NORMAL
- en: We only executed the method if the ship was not shooting to minimize potential
    side effects and prevent someone from tapping on the ship all the time (step 7).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined the variable `shootingTime` at the time the shooting took place.
    It is set to 1.2 seconds because this is the approximate length of the movie clip
    animation (step 8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable `innerBox` was the distance from the edge of the ship image to
    the actual image itself (step 8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable `targetPos` stored how far the cannonballs would fly (step 8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For convenience, we defined the `currentClip` variable, so we didn't have to
    type `_shootingClip[self.direction]` each time we wanted to access the movie clip
    of the current direction (step 9).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined a tween for each coordinate and cannonball, so in total, we had four
    tweens at this point (step 10).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In steps 11 and 12, we set up the positions and the tweens for the cannonballs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We needed to see the cannonballs on the screen, which is why we set them to
    be visible. To see the corresponding animation, we needed to add the tweens to
    the juggler (step 13).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also removed all tweens originating from the cannonballs before we actually
    played the animation (step 14).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last thing we needed to update in the `shoot` method was setting the `_isShooting`
    instance variable to `NO` once the animation was complete, and we hid both cannonballs
    in the same block (step 15).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we ran the example and double-tapped our pirate ship, the movie clip played
    and two huge cannonballs emerged from both sides of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the ship cannot shoot diagonally. Go ahead and implement this functionality
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we implement collision detection, let''s take a look at different types
    of collision detections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounding box collision**: We check the bounds of the entities (which is a
    rectangle). If these rectangles intersect, we have a collision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounding sphere collision**: We calculate the distance between two entities.
    If the distance is smaller than the radius of both entities combined, these entities
    are colliding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel collision**: We check if all the pixels of one entity intersect with
    the pixels of another entity. While this is definitely the most detailed and comprehensive
    collision check, it is also the most CPU-intensive one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that our pirate ship is actually shooting cannonballs, let's implement the
    functionality that can hit and sink the enemy ship. We use the bounding box collision
    because this is one of the easiest collision detection types to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – letting cannonballs collide with ships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To check if cannonballs collide against the enemy ship, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add custom getters and setters to the `hitpoints` property, so let's
    make this property `nonatomic` and add an instance variable called `_hitpoints`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the methods `abortShooting` and `hit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the `Ship.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The custom `hitpoints` getter just returns the instance variable `_hitpoints`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The custom setter for `hitpoints` contains the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `abortShooting` method consists of the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `hit` method has the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the battlefield header file, we need to add an instance variable called `_enemyShip`,
    which is a pointer to the class `Ship`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the references from `ship` to `_enemyShip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an event listener to the `SP_EVENT_TYPE_ENTER_FRAME` event, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `onEnterFrame` method with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example. When the enemy ship is hit, it flashes red for a moment, as
    shown in the following screenshot:![Time for action – letting cannonballs collide
    with ships](img/1509OS_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 2, we updated our `hitpoints` property so that we can add custom getters
    and setters. In the next step, we declared the methods `abortShooting` and `hit`.
    We needed the first method to cancel the current shooting animations and the second
    method to do something when a ship has been hit.
  prefs: []
  type: TYPE_NORMAL
- en: We defined the custom getter and setter in steps 5 and 6, respectively. For
    the getter, we just returned the instance variable `_hitpoints` that we declared
    in step 2\. For the setter, we set this instance variable; but when `_hitpoints`
    equals or was below zero, we hid the ship.
  prefs: []
  type: TYPE_NORMAL
- en: The `abortShooting` method in step 7 set the `_isShooting` instance variable,
    removed all tweens from the cannonballs, and hid the cannonballs as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `hit` method subtracted 25 points from `hitpoints` and added an animation
    that let the ship flash red for a very short amount of time to get some visual
    feedback if a ship had been hit.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two steps, we refactored the enemy ship instance to be an instance
    variable, instead of being a local variable inside the initializer. We also updated
    all references to the enemy ship.
  prefs: []
  type: TYPE_NORMAL
- en: In step 11, we added an event listener. This event listener was called on each
    frame. In the next step, we implemented the collision between the enemy ship and
    the cannonballs from the pirate ship.
  prefs: []
  type: TYPE_NORMAL
- en: First, we needed to get the bounds from each of these objects relative to the
    current scene. We needed to see if any of the cannonballs intersected with the
    enemy ship. In order to make sure that the cannons were actually firing, we checked
    for the visibility of the cannonballs, and then we called the `hit` method from
    the enemy ship and the `abortShooting` method from the pirate ship. The latter
    was necessary, otherwise the check would happen again with a positive result,
    so much so that the enemy ship would be destroyed instantly and we wouldn't even
    get to see the red flashing ship.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, we needed to hit the enemy ship exactly four times
    for it to disappear. Each time the enemy ship was hit, it flashed red for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Loading gameplay-relevant data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s reflect on what kind of gameplay-relevant data we have at this moment.
    They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit points for each ship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The damage a cannonball inflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positions for each ship in the battlefield
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should put this data in a file and load it in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – avoiding hardcoded values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To separate and load our gameplay-relevant data, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file called `gameplay.json` in the `Resources` folder with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a property called `maxHitpoints`, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Ship` initializer, replace the piece of code where we set `hitpoints`
    with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `hit` method, replace the hardcoded damage value to load from the
    `gameplay.json` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Battlefield.m` file, replace the hardcoded ship positions with
    those from the `gameplay.json` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instead of having hardcoded values in our code, we are now loading the values
    from a file. As a result, the ships are at different starting positions, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – avoiding hardcoded values](img/1509OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we created the JSON file with values that we will load later on.
    The values we have so far are the hit points, damage, and of course, positions
    of the ships.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Ship.h` file, we added a new property called `maxHitpoints`, which
    indicates the maximum health of any ship.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we first set the `maxHitpoints` property with the `hitpoints` property
    from the `gameplay.json` file. Since a property is loaded from the `gameplay.json`
    file and it is from the type `id`, we need to cast it into a more familiar data
    type. We casted it into a pointer to `NSNumber` and then used its integer value
    through the `intValue` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we did the same for the `damage` property.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we switched to the battlefield scene and updated the positions for
    the ships to reflect the same from the `gameplay.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, our ships were at the position we defined in the `gameplay.json`
    file. Shooting and destroying an enemy worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. How can event listeners be described?
  prefs: []
  type: TYPE_NORMAL
- en: Using blocks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using selectors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using selectors or blocks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. When is an event registered to `SP_TYPE_EVENT_ENTER_FRAME` called?
  prefs: []
  type: TYPE_NORMAL
- en: Once in the first frame after it's added to the display tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once every frame
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Never
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. Detecting double taps is not possible with Sparrow.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about adding the basic game logic elements to our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered how to structure our code. We got a deeper knowledge
    of touches, event listeners, and collision detections.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our pirate ship can actually shoot and hit things, let's add user-interface
    elements—which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
