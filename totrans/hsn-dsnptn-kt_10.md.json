["```kt\nval sometimesNull = if (Random().nextBoolean()) \"not null\" else null\n\nsometimesNull?.let {\n    println(\"It was $it this time\")\n}\n```", "```kt\nval alwaysNull = null\n\nalwaysNull.let { // No null pointer there\n    println(\"It was $it this time\") // Always prints null\n}\n```", "```kt\nval numberReturned = justAString.let {\n    println(it)\n    it.length\n}\n```", "```kt\nclass JamesBond {\n    lateinit var name: String\n    lateinit var movie: String\n    lateinit var alsoStarring: String\n}\n\nval agentJavaWay = JamesBond()\nagentJavaWay.name = \"Sean Connery\"\nagentJavaWay.movie = \"Dr. No\"\n```", "```kt\nval `007` = JamesBond().apply {\n    this.name = \"Sean Connery\"\n    this.movie = \"Dr. No\"\n}\n\nprintln(`007`.name)\n```", "```kt\nval `007` = JamesBond().apply {\n    name = \"Sean Connery\"\n    movie = \"Dr. No\"\n}\n```", "```kt\nfun multiply(a: Int, b: Int): Int = a * b\n```", "```kt\nfun multiply(a: Int, b: Int): Int {\n    val c = a * b\n    println(c)\n    return c\n}\n```", "```kt\nfun multiply(a: Int, b: Int): Int = (a * b).also { println(it) }\n```", "```kt\nval l = (1..100).toList()\n\nl.filter{ it % 2 == 0 }\n    .also { println(it) } // Prints, but doesn't change anything\n    .map { it * it }\n\n```", "```kt\nval justAString = \"string\"\n\nval n = justAString.run { \n    this.length\n}\n```", "```kt\nval n = justAString.run { \n    length\n}\n```", "```kt\nval year = JamesBond().run {\n    name = \"ROGER MOORE\"\n    movie = \"THE MAN WITH THE GOLDEN GUN\"\n    1974 // <= Not JamesBond type\n}\n```", "```kt\n\"scope\".with { ... }\n```", "```kt\nwith(\"scope\") {\n    println(this.length) // \"this\" set to the argument of with()\n}\n```", "```kt\nwith(\"scope\") {\n    length\n}\n```", "```kt\ninterface Superhero\nclass Batman : Superhero {\n    fun callRobin() {\n        println(\"To the Bat-pole, Robin!\")\n    }\n}\n\nclass Superman : Superhero {\n    fun fly() {\n        println(\"Up, up and away!\")\n    }\n}\n\nfun doCoolStuff(s : Superhero) {\n    if (s is Superman) {\n        (s as Superman).fly()\n    }\n    else if (s is Batman) {\n        (a as Batman).callRobin()\n    }\n}\n```", "```kt\nfun doCoolStuff(s : Superhero) {\n    if (s is Superman) {\n        s.fly()\n    }\n    else if (s is Batman) {\n        s.callRobin()\n    }\n}\n```", "```kt\nfun doCoolStuff(s : Superhero) {\n    when(s) {\n        is Superman -> s.fly()\n        is Batman -> s.callRobin()\n        else -> println(\"Unknown superhero\")\n    }\n}\n```", "```kt\n// Superhero is clearly not a string\nval superheroAsString = (s as String)\n```", "```kt\nval superheroAsString = (s as? String)\n```", "```kt\nBufferedReader br = null; // Nulls are bad, we know that\ntry {\n    br = new BufferedReader(new FileReader(\"/some/peth\"));\n    System.out.println(br.readLine());\n}\nfinally {\n    if (br != null) { // Explicit check\n        br.close(); // Boilerplate\n    }\n}\n```", "```kt\ntry (BufferedReader br = new BufferedReader(new FileReader(\"/some/peth\"))) {\n    System.out.println(br.readLine());\n}\n```", "```kt\nval br = BufferedReader(FileReader(\"\"))\n\nbr.use {\n    println(it.readLine())\n}\n```", "```kt\ninline fun doesntMakeSense(something: String) {\n    println(something)\n}\n```", "```kt\ninline fun makesSense(block: () -> String) {\n    println(\"Before\")\n    println(block())\n    println(\"After\")\n}\n```", "```kt\nmakesSense {\n    \"Inlining\"\n}\n```", "```kt\nprintln(\"Before\")\nprintln(\"Inlining\")\nprintln(\"After\")\n```", "```kt\nString var1 = \"Before\"; <- Inline function call\nSystem.out.println(var1);\nvar1 = \"Inlining\";\nSystem.out.println(var1);\nvar1 = \"After\";\nSystem.out.println(var1);\n\nvar1 = \"Before\"; // <- Usual code\nSystem.out.println(var1);\nvar1 = \"Inlining\";\nSystem.out.println(var1);\nvar1 = \"After\";\nSystem.out.println(var1);\n```", "```kt\nfun <T> printIfSameType(a: Number) {\n    if (a is T) { // <== Error\n        println(a)   \n    }\n}\n```", "```kt\nCannot check for instance of erased type: T\n```", "```kt\nfun <T: Number> printIfSameType(clazz: KClass<T>, a: Number) {\n    if (clazz.isInstance(a) ) {\n        println(a)\n    }\n}\n```", "```kt\nprintIfSameType(Int::class, 1) // Print 1, as 1 is Int\nprintIfSameType(Int::class, 2L) // Prints nothing, as 2 is Long\n```", "```kt\ncompile group: 'org.jetbrains.kotlin', name: 'kotlin-reflect', version: '1.2.31'\n```", "```kt\nclazz: KClass<T>\n```", "```kt\nreified T> printIfSameTypeReified(a: Number) {\n    if (a is T) {\n        println(a)\n    }\n}\n```", "```kt\nprintIfSameTypeReified<Int>(3) // Prints 3, as 3 is Int\nprintIfSameTypeReified<Int>(4L) // Prints nothing, as 4 is Long\nprintIfSameTypeReified<Long>(5) // Prints nothing, as 5 is Int\nprintIfSameTypeReified<Long>(6L) // Prints 6, as 6 is Long\n```", "```kt\nfun printList(list: List<Int>) {\n    println(\"This is a lit of Ints\")\n    println(list)\n}\n\nfun printList(list: List<Long>) {\n    println(\"This is a lit of Longs\")\n    println(list)\n}\n```", "```kt\nconst val int = 1\nconst val long = 1L\ninline fun <reified T : Any> printList(list: List<T>) {\n    when {\n        int is T -> println(\"This is a list of Ints\")\n        long is T -> println(\"This is a list of Longs\")\n        else -> println(\"This is a list of something else\")\n    }\n\n    println(list)\n}\n```", "```kt\nclass MyClass {\n    companion object {\n        val MY_CONST = \"My Const\"\n    }\n}\n```", "```kt\npublic final class Spock {\n   @NotNull\n   private static final String MY_CONST = \"My Const\";\n   public static final Spock.Companion Companion = new Spock.Companion(...);\n\n   public static final class Companion {\n      @NotNull\n      public final String getMY_CONST() {\n         return MyClass.MY_CONST;\n      }\n\n      private Companion() {\n      }\n   }\n}\n```", "```kt\nString var1 = Spock.Companion.getSENSE_OF_HUMOR();\nSystem.out.println(var1);\n```", "```kt\nclass Spock {\n    companion object {\n        const val SENSE_OF_HUMOR = \"None\"\n    }\n}\n```", "```kt\npublic final class Spock {\n   @NotNull\n   public static final String SENSE_OF_HUMOR = \"NONE\";\n   public static final Spock.Companion Companion = new Spock.Companion(...);\n   )\n   public static final class Companion {\n      private Companion() {\n      }\n        ...\n   }\n}\n```", "```kt\nString var1 = \"NONE\";\nSystem.out.println(var1);\n```", "```kt\nconst val SPOCK_SENSE_OF_HUMOR = \"NONE\"\n```", "```kt\nobject SensesOfHumor {\n    const val SPOCK = \"NONE\"\n}\n```", "```kt\nclass MyClass {\n    private final String a;\n    private final Integer b;\n    public MyClass(String a) {\n        this(a, 1);\n    }\n\n    public MyClass(String a, Integer b) {\n        this.a = a;\n        this.b = b;\n    }\n}\n```", "```kt\nclass MyClass(val a: String, val b: Int, val c: Long) {\n\n    constructor(a: String, b: Int) : this(a, b, 0) \n\n    constructor(a: String) : this(a, 1)\n\n    constructor() : this(\"Default\")\n}\n```", "```kt\n\nclass BetterClass(val a: String = \"Default\",\n                  val b: Int = 1,\n                  val c: Long = 0)\n```", "```kt\n// Will return \"String\" half of the time, and null the other half\nval stringOrNull: String? = if (Random().nextBoolean()) \"String\" else null \n\n// Java-way check\nif (stringOrNull != null) {\n    println(stringOrNull.length)\n}\n```", "```kt\nval alwaysLength = stringOrNull?.length ?: 0\n\nprintln(alwaysLength) // Will print 6 or 0, but never null\n```", "```kt\ndata class Json(\n        val User: Profile?\n)\n\ndata class Profile(val firstName: String?,\n                   val lastName: String?)\n\nval json: Json? = Json(Profile(null, null))\n\nprintln(json?.User?.firstName?.length)\n```", "```kt\nprintln(json?.let {\n    it.User?.let {\n        it.firstName?.length\n    }\n})\n```", "```kt\nprintln(json?.run {\n    User?.run {\n        firstName?.length\n    }\n})\n```", "```kt\nprintln(json!!.User!!.firstName!!.length)\n```", "```kt\nfun getName() = async {\n   delay(100)\n   \"Ruslan\"\n}\n```", "```kt\nprintln(\"Name: ${getName()}\")\n```", "```kt\nName: DeferredCoroutine{Active}@...\n```", "```kt\nprintln(\"Name: ${getName().await()}\")\n```", "```kt\nfun getNameAsync() = async {\n   delay(100)\n   \"Ruslan\"\n}\n```", "```kt\nfun setCapacity(cap: Int) {\n    if (cap < 0) {\n        throw IllegalArgumentException()\n    }\n    ...\n}\n```", "```kt\nfun setCapacity(cap: Int) {\n    require(cap > 0)\n}\n```", "```kt\nfun printNameLength(p: Profile) {\n    require(p.firstName != null)\n}\n```", "```kt\nfun printNameLength(p: Profile) {\n    requireNotNull(p.firstName)\n}\n```", "```kt\nprivate class HttpClient {\n    var body: String? = null\n    var url: String = \"\"\n\n    fun postRequest() {\n        check(body != null) {\n            \"Body must be set in POST requests\"\n        }\n    }\n\n    fun getRequest() {\n        // This one is fine without body\n    }\n}\n```", "```kt\n// Java code\nenum PizzaOrderStatus {\n    ORDER_RECEIVED, \n    PIZZA_BEING_MADE, \n    OUT_FOR_DELIVERY, \n    COMPLETED;\n\n    public PizzaOrderStatus nextStatus() {\n        switch (this) {\n            case ORDER_RECEIVED: return PIZZA_BEING_MADE;\n            case PIZZA_BEING_MADE: return OUT_FOR_DELIVERY;\n            case OUT_FOR_DELIVERY: return COMPLETED;\n            case COMPLETED:return COMPLETED;\n        }\n    }\n}\n```", "```kt\nsealed class PizzaOrderStatus(protected val orderId: Int) {\n    abstract fun nextStatus() : PizzaOrderStatus\n    class OrderReceived(orderId: Int) : PizzaOrderStatus(orderId) {\n        override fun nextStatus(): PizzaOrderStatus {\n            return PizzaBeingMade(orderId)\n        }\n    }\n\n    class PizzaBeingMade(orderId: Int) : PizzaOrderStatus(orderId) {\n        override fun nextStatus(): PizzaOrderStatus {\n            return OutForDelivery(orderId)\n        }\n    }\n\n    class OutForDelivery(orderId: Int) : PizzaOrderStatus(orderId) {\n        override fun nextStatus(): PizzaOrderStatus {\n            return Completed(orderId)\n        }\n    }\n\n    class Completed(orderId: Int) : PizzaOrderStatus(orderId) {\n        override fun nextStatus(): PizzaOrderStatus {\n            return this\n        }\n    }\n}\n```", "```kt\nvar status: PizzaOrderStatus = OrderReceived(123)\n\nwhile (status !is Completed) {\n    status = when (status) {\n        is OrderReceived -> status.nextStatus()\n        is PizzaBeingMade -> status.nextStatus()\n        is OutForDelivery -> status.nextStatus()\n        is Completed -> status\n    }\n}\n```", "```kt\nclass A {\n   companion {\n   }\n   companion {\n   }\n}\n```", "```kt\nclass A {\n   object B {\n   }\n   object C {\n   }\n}\n```", "```kt\nfun hello() = {\n    \"hello\"\n}\n```", "```kt\nprintln(\"Say ${hello()}\")\n```", "```kt\n Say () -> kotlin.String\n```", "```kt\nprintln(\"Say ${hello()()}\")\n```", "```kt\nSay hello\n```", "```kt\nfun hello(): () -> String {\n    return {\n        \"hello\"\n    }\n}\n```", "```kt\nfun helloExpandedMore(): () -> String {\n    return fun():String {\n        return \"hello\"\n    }\n}\n```"]