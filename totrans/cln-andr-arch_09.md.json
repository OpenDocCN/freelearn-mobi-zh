["```kt\ndata class User(\n    val id: String,\n    val firstName: String,\n    val lastName: String,\n    val email: String\n) {\n    fun getFullName() = \"$firstName $lastName\"\n}\n```", "```kt\ndata class UserApiModel(\n    @Json(name = \"id\") val id: String,\n    @Json(name = \"first_name\") val firstName: String,\n    @Json(name = \"last_name\") val lastName: String,\n    @Json(name = \"email\") val email: String\n)\n```", "```kt\ninterface UserRemoteDataSource {\n    fun getUser(id: String): Flow<User>\n}\n```", "```kt\ninterface UserService {\n    @GET(\"/users/{userId}\")\n    suspend fun getUser(@Path(\"userId\") userId: String): \n        UserApiModel\n}\n```", "```kt\ndata class UserRemoteDataSourceImpl(private val userService: UserService) : UserRemoteDataSource {\n    override fun getUser(id: String): Flow<User> {\n        return flow {\n            emit(userService.getUser(id))\n        }.map {\n            User(it.id, it.firstName, it.lastName,\n                it.email)\n        }\n    }\n}\n```", "```kt\n{\n    \"id\": 1,\n    \"name\": \"Leanne Graham\",\n    \"username\": \"Bret\",\n    \"email\": \"Sincere@april.biz\"\n}\n```", "```kt\n{\n    \"userId\": 1,\n    \"id\": 1,\n    \"title\": \"sunt aut facere repellat provident \n        occaecati excepturi optio reprehenderit\",\n    \"body\": \"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\"\n}\n```", "```kt\n    buildscript {\n         …\n        dependencies {\n            classpath gradlePlugins.android\n            classpath gradlePlugins.kotlin\n            classpath gradlePlugins.hilt\n        }\n    }\n    ```", "```kt\n        ext {\n            …\n            versions = [\n                    …\n                    okHttp             : \"4.9.0\",\n                    retrofit           : \"2.9.0\",\n                    moshi              : \"1.13.0\",\n                    …\n            ]\n            …\n            network = [\n                    okHttp       : \"com.squareup.okhttp3:\n                        okhttp:${versions.okHttp}\",\n                    retrofit     : \"com.squareup.retrofit2\n                        :retrofit:${versions.retrofit}\",\n                    retrofitMoshi: \"com.squareup.retrofit2\n                        :converter-moshi:$\n                            {versions.retrofit}\",\n                    moshi        : \"com.squareup.moshi:\n                        moshi:${versions.moshi}\",\n                    moshiKotlin  : \"com.squareup.moshi:\n                        moshi-kotlin:${versions.moshi}\"\n            ]\n            …\n        }\n    ```", "```kt\n    plugins {\n        id 'com.android.library'\n        id 'kotlin-android'\n        id 'kotlin-kapt'\n        id 'dagger.hilt.android.plugin'\n    }\n    ```", "```kt\n    android {\n        compileSdk defaultCompileSdkVersion\n        defaultConfig {\n            minSdk defaultMinSdkVersion\n            targetSdk defaultTargetSdkVersion\n            …\n        }\n        compileOptions {\n            sourceCompatibility javaCompileVersion\n            targetCompatibility javaCompileVersion\n        }\n        kotlinOptions {\n            jvmTarget = jvmTarget\n        }\n    }\n    ```", "```kt\n    dependencies {\n        implementation(project(path: \":domain\"))\n        implementation(project(path: \":data-repository\"))\n        implementation coroutines.coroutinesAndroid\n        implementation network.okHttp\n        implementation network.retrofit\n        implementation network.retrofitMoshi\n        implementation network.moshi\n        implementation network.moshiKotlin\n        implementation di.hiltAndroid\n        kapt di.hiltCompiler\n        testImplementation test.junit\n        testImplementation test.coroutines\n        testImplementation test.mockito\n    }\n    ```", "```kt\n    android.jetifier.ignorelist=moshi-1.13.0\n    ```", "```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        package=\"com.clean.data_remote\">\n        <uses-permission android:name=\"android.permission.INTERNET\" />\n    </manifest>\n    ```", "```kt\n    data class UserApiModel(\n        @Json(name = \"id\") val id: Long,\n        @Json(name = \"name\") val name: String,\n        @Json(name = \"username\") val username: String,\n        @Json(name = \"email\") val email: String\n    )\n    ```", "```kt\n    interface UserService {\n        @GET(\"/users\")\n        suspend fun getUsers(): List<UserApiModel>\n        @GET(\"/users/{userId}\")\n        suspend fun getUser(@Path(\"userId\") userId: Long): \n            UserApiModel\n    }\n    ```", "```kt\n    data class PostApiModel(\n        @Json(name = \"id\") val id: Long,\n        @Json(name = \"userId\") val userId: Long,\n        @Json(name = \"title\") val title: String,\n        @Json(name = \"body\") val body: String\n    )\n    ```", "```kt\n    interface PostService {\n        @GET(\"/posts\")\n        suspend fun getPosts(): List<PostApiModel>\n        @GET(\"/posts/{postId}\")\n        suspend fun getPost(@Path(\"postId\") id: Long): \n            PostApiModel\n    }\n    ```", "```kt\n    class RemoteUserDataSourceImpl @Inject constructor(private val userService: UserService) :\n        RemoteUserDataSource {\n        override fun getUsers(): Flow<List<User>> = flow {\n            emit(userService.getUsers())\n        }.map { users ->\n            users.map { userApiModel ->\n                convert(userApiModel)\n            }\n        }.catch {\n            throw UseCaseException.UserException(it)\n        }\n        override fun getUser(id: Long): Flow<User> = flow {\n            emit(userService.getUser(id))\n        }.map {\n            convert(it)\n        }.catch {\n            throw UseCaseException.UserException(it)\n        }\n\n        private fun convert(userApiModel: UserApiModel) =\n            User(userApiModel.id, userApiModel.name, \n                userApiModel.username, userApiModel.email)\n    }\n    ```", "```kt\n    class RemotePostDataSourceImpl @Inject constructor(private val postService: PostService) :\n        RemotePostDataSource {\n\n        override fun getPosts(): Flow<List<Post>> = flow {\n            emit(postService.getPosts())\n        }.map { posts ->\n            posts.map { postApiModel ->\n                convert(postApiModel)\n            }\n        }.catch {\n            throw UseCaseException.PostException(it)\n        }\n        override fun getPost(id: Long): Flow<Post> = flow {\n            emit(postService.getPost(id))\n        }.map {\n            convert(it)\n        }.catch {\n            throw UseCaseException.PostException(it)\n        }\n        private fun convert(postApiModel: PostApiModel) =\n            Post(postApiModel.id, postApiModel.userId, \n                postApiModel.title, postApiModel.body)\n    }\n    ```", "```kt\n    @Module\n    @InstallIn(SingletonComponent::class)\n    class NetworkModule {\n        @Provides\n        fun provideOkHttpClient(): OkHttpClient = \n            OkHttpClient\n            .Builder()\n            .readTimeout(15, TimeUnit.SECONDS)\n            .connectTimeout(15, TimeUnit.SECONDS)\n            .build()\n        @Provides\n        fun provideMoshi(): Moshi = Moshi.Builder().add\n            (KotlinJsonAdapterFactory()).build()\n        @Provides\n        fun provideRetrofit(okHttpClient: OkHttpClient, \n            moshi: Moshi): Retrofit = Retrofit.Builder()\n            .baseUrl\n                 (\"https://jsonplaceholder.typicode.com/\")\n            .client(okHttpClient)\n            .addConverterFactory\n                (MoshiConverterFactory.create(moshi))\n            .build()\n        @Provides\n        fun provideUserService(retrofit: Retrofit): \n            UserService =\n            retrofit.create(UserService::class.java)\n        @Provides\n        fun providePostService(retrofit: Retrofit): \n            PostService =\n            retrofit.create(PostService::class.java)\n    }\n    ```", "```kt\n    @Module\n    @InstallIn(SingletonComponent::class)\n    abstract class RemoteDataSourceModule {\n        @Binds\n        abstract fun bindPostDataSource(postDataSourceImpl: RemotePostDataSourceImpl): RemotePostDataSource\n        @Binds\n        abstract fun bindUserDataSource\n            (userDataSourceImpl: \n                RemoteUserDataSourceImpl):\n     RemoteUserDataSource\n    }\n    ```", "```kt\n    class RemoteUserDataSourceImplTest {\n        private val userService = mock<UserService>()\n        private val userDataSource = \n            RemoteUserDataSourceImpl(userService)\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetUsers() = runBlockingTest {\n            val remoteUsers = listOf(UserApiModel(1, \n                \"name\", \"username\", \"email\"))\n            val expectedUsers = listOf(User(1, \"name\", \n                \"username\", \"email\"))\n            whenever(userService.getUsers()).\n                thenReturn(remoteUsers)\n            val result = userDataSource.getUsers().first()\n            Assert.assertEquals(expectedUsers, result)\n        }\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetUser() = runBlockingTest {\n            val id = 1L\n            val remoteUser = UserApiModel(id, \"name\", \n                \"username\", \"email\")\n            val user = User(id, \"name\", \"username\", \n                \"email\")\n            whenever(userService.getUser(id))\n                .thenReturn(remoteUser)\n            val result = userDataSource.getUser(id).\n                first()\n            Assert.assertEquals(user, result)\n        }\n    }\n    ```", "```kt\n    class RemoteUserDataSourceImplTest {\n        …\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetUsersThrowsError() = runBlockingTest {\n            whenever(userService.getUsers()).thenThrow\n                (RuntimeException())\n            userDataSource.getUsers().catch {\n                Assert.assertTrue(it is UseCaseException.\n                    UserException)\n            }.collect()\n        }\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetUserThrowsError() = runBlockingTest {\n            val id = 1L\n            whenever(userService.getUser(id)).thenThrow\n                (RuntimeException())\n            userDataSource.getUser(id).catch {\n                Assert.assertTrue(it is UseCaseException.\n                    UserException)\n            }.collect()\n        }\n    }\n    ```", "```kt\n    class RemotePostDataSourceImplTest {\n        private val postService = mock<PostService>()\n        private val postDataSource = \n            RemotePostDataSourceImpl(postService)\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetPosts() = runBlockingTest {\n            val remotePosts = listOf(PostApiModel(1, 1, \n                \"title\", \"body\"))\n            val expectedPosts = listOf(Post(1, 1, \"title\", \n                \"body\"))\n            whenever(postService.getPosts()).thenReturn\n                (remotePosts)\n            val result = postDataSource.getPosts().first()\n            Assert.assertEquals(expectedPosts, result)\n        }\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetPost() = runBlockingTest {\n            val id = 1L\n            val remotePost = PostApiModel(id, 1, \"title\", \n                \"body\")\n            val expectedPost = Post(id, 1, \"title\", \n                \"body\")\n            whenever(postService.getPost(id)).thenReturn\n                (remotePost)\n            val result = postDataSource.getPost(id).\n                first()\n            Assert.assertEquals(expectedPost, result)\n        }\n    }\n    ```", "```kt\n    class RemotePostDataSourceImplTest {\n        …\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetPostsThrowsError() = runBlockingTest {\n            whenever(postService.getPosts()).thenThrow\n                (RuntimeException())\n            postDataSource.getPosts().catch {\n                Assert.assertTrue(it is UseCaseException.\n                    PostException)\n            }.collect()\n        }\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetPostThrowsError() = runBlockingTest {\n            val id = 1L\n            whenever(postService.getPost(id)).thenThrow\n                (RuntimeException())\n            postDataSource.getPost(id).catch {\n                Assert.assertTrue(it is UseCaseException.\n                    PostException)\n            }.collect()\n        }\n    }\n    ```", "```kt\ndata class User(\n    val id: String,\n    val firstName: String,\n    val lastName: String,\n    val email: String\n) {\n    fun getFullName() = \"$firstName $lastName\"\n}\n```", "```kt\ninterface UserLocalDataSource {\n    suspend fun insertUser(user: User)\n    fun getUser(id: String): Flow<User>\n}\n```", "```kt\n@Entity(tableName = \"user\")\ndata class UserEntity(\n    @PrimaryKey @ColumnInfo(name = \"id\") val id: String,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String,\n    @ColumnInfo(name = \"email\") val email: String\n)\n```", "```kt\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user where id = :id\")\n    fun getUser(id: String): Flow<UserEntity>\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    fun insertUser(users: UserEntity)\n}\n```", "```kt\nclass UserLocalDataSourceImpl(private val userDao: UserDao) : UserLocalDataSource {\n    override suspend fun insertUser(user: User) {\n        userDao.insertUser(UserEntity(user.id, \n            user.firstName, user.lastName, user.email))\n    }\n    override fun getUser(id: String): Flow<User> {\n        return userDao.getUser(id).map {\n            User(it.id, it.firstName, it.lastName, \n                it.email)\n        }\n    }\n}\n```", "```kt\nprivate val KEY_ID = stringPreferencesKey(\"key_id\")\nprivate val KEY_FIRST_NAME = \n    stringPreferencesKey(\"key_first_name\")\nprivate val KEY_LAST_NAME = \n    stringPreferencesKey(\"key_last_name\")\nprivate val KEY_EMAIL = stringPreferencesKey(\"key_email\")\nclass UserLocalDataSourceImpl(private val dataStore: \n    DataStore<Preferences>) : UserLocalDataSource {\n    override suspend fun insertUser(user: User) {\n        dataStore.edit {\n            it[KEY_ID] = user.id\n            it[KEY_FIRST_NAME] = user.firstName\n            it[KEY_LAST_NAME] = user.lastName\n            it[KEY_EMAIL] = user.email\n        }\n    }\n    override fun getUser(id: String): Flow<User> {\n        return dataStore.data.map {\n            User(\n                it[KEY_ID].orEmpty(),\n                it[KEY_FIRST_NAME].orEmpty(),\n                it[KEY_LAST_NAME].orEmpty(),\n                it[KEY_EMAIL].orEmpty()\n            )\n        }\n    }\n}\n```", "```kt\n    buildscript {\n         …\n        dependencies {\n            classpath gradlePlugins.android\n            classpath gradlePlugins.kotlin\n            classpath gradlePlugins.hilt\n        }\n    }\n    ```", "```kt\n        ext {\n            …\n            versions = [\n                    …\n                    room               : \"2.4.0\",\n                    datastore          : \"1.0.0\",\n                    …\n            ]\n            …\n            persistence = [\n                    roomRuntime : \"androidx.room:room-\n                        runtime:${versions.room}\",\n                    roomKtx     : \"androidx.room:room-\n                         ktx:${versions.room}\",\n                    roomCompiler: \"androidx.room:room-\n                        compiler:${versions.room}\",\n                    datastore   : \"androidx.datastore:\n                        datastore-preferences:$\n                           {versions.datastore}\"\n            ]\n            …\n        }\n    ```", "```kt\n    plugins {\n        id 'com.android.library'\n        id 'kotlin-android'\n        id 'kotlin-kapt'\n        id 'dagger.hilt.android.plugin'\n    }\n    ```", "```kt\n    android {\n        compileSdk defaultCompileSdkVersion\n        defaultConfig {\n            minSdk defaultMinSdkVersion\n            targetSdk defaultTargetSdkVersion\n            …\n        }\n        compileOptions {\n            sourceCompatibility javaCompileVersion\n            targetCompatibility javaCompileVersion\n        }\n        kotlinOptions {\n            jvmTarget = jvmTarget\n        }\n    }\n    ```", "```kt\n    dependencies {\n        implementation(project(path: \":domain\"))\n        implementation(project(path: \":data-repository\"))\n        implementation coroutines.coroutinesAndroid\n        implementation persistence.roomRuntime\n        implementation persistence.roomKtx\n        kapt persistence.roomCompiler\n        implementation persistence.datastore\n        implementation di.hiltAndroid\n        kapt di.hiltCompiler\n        testImplementation test.junit\n        testImplementation test.coroutines\n        testImplementation test.mockito\n    }\n    ```", "```kt\n    @Entity(tableName = \"user\")\n    data class UserEntity(\n        @PrimaryKey @ColumnInfo(name = \"id\") val id: Long,\n        @ColumnInfo(name = \"name\") val name: String,\n        @ColumnInfo(name = \"username\") val username: \n            String,\n        @ColumnInfo(name = \"email\") val email: String\n    )\n    ```", "```kt\n    @Dao\n    interface UserDao {\n        @Query(\"SELECT * FROM user\")\n        fun getUsers(): Flow<List<UserEntity>>\n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        fun insertUsers(users: List<UserEntity>)\n    }\n    ```", "```kt\n    @Entity(tableName = \"post\")\n    data class PostEntity(\n        @PrimaryKey @ColumnInfo(name = \"id\") val id: Long,\n        @ColumnInfo(name = \"userId\") val userId: Long,\n        @ColumnInfo(name = \"title\") val title: String,\n        @ColumnInfo(name = \"body\") val body: String\n    )\n    ```", "```kt\n    @Dao\n    interface PostDao {\n        @Query(\"SELECT * FROM post\")\n        fun getPosts(): Flow<List<PostEntity>>\n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        fun insertPosts(users: List<PostEntity>)\n    }\n    ```", "```kt\n    @Database(entities = [UserEntity::class, PostEntity::class], version = 1)\n    abstract class AppDatabase : RoomDatabase() {\n        abstract fun userDao(): UserDao\n        abstract fun postDao(): PostDao\n    }\n    ```", "```kt\n    class LocalUserDataSourceImpl @Inject constructor(private val userDao: UserDao) :\n        LocalUserDataSource {\n        override fun getUsers(): Flow<List<User>> = \n            userDao.getUsers().map { users ->\n            users.map {\n                User(it.id, it.name, it.username, \n                    it.email)\n            }\n        }\n        override suspend fun addUsers(users: List<User>) = \n            userDao.insertUsers(users.map {\n            UserEntity(it.id, it.name, it.username, \n                it.email)\n        })\n    }\n    ```", "```kt\n    class LocalPostDataSourceImpl @Inject constructor(private val postDao: PostDao) :\n        LocalPostDataSource {\n        override fun getPosts(): Flow<List<Post>> = \n           postDao.getPosts().map { posts ->\n            posts.map {\n                Post(it.id, it.userId, it.title, it.body)\n            }\n        }\n        override suspend fun addPosts(posts: List<Post>) = \n            postDao.insertPosts(posts.map {\n            PostEntity(it.id, it.userId, it.title, \n                it.body)\n        })\n    }\n    ```", "```kt\n    internal val KEY_TOTAL_TAPS = intPreferencesKey(\"key_total_taps\")\n    class LocalInteractionDataSourceImpl @Inject constructor(private val dataStore: DataStore<Preferences>) :\n        LocalInteractionDataSource {\n        override fun getInteraction(): Flow<Interaction> {\n            return dataStore.data.map {\n                Interaction(it[KEY_TOTAL_TAPS] ?: 0)\n            }\n        }\n        override suspend fun saveInteraction(interaction: \n            Interaction) {\n            dataStore.edit {\n                it[KEY_TOTAL_TAPS] = \n                    interaction.totalClicks\n            }\n        }\n    }\n    ```", "```kt\n    val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = \"my_preferences\")\n    @Module\n    @InstallIn(SingletonComponent::class)\n    class PersistenceModule {\n        @Provides\n        fun provideAppDatabase(@ApplicationContext \n            context: Context): AppDatabase =\n            Room.databaseBuilder(\n                context,\n                AppDatabase::class.java, \"my-database\"\n            ).build()\n        @Provides\n        fun provideUserDao(appDatabase: AppDatabase): \n            UserDao = appDatabase.userDao()\n        @Provides\n        fun providePostDao(appDatabase: AppDatabase): \n            PostDao = appDatabase.postDao()\n        @Provides\n        fun provideLocalInteractionDataSourceImpl\n            (@ApplicationContext context: Context) =\n            LocalInteractionDataSourceImpl(context.dataStore)\n    } \n    ```", "```kt\n    @Module\n    @InstallIn(SingletonComponent::class)\n    abstract class LocalDataSourceModule {\n        @Binds\n        abstract fun bindPostDataSource\n           (lostDataSourceImpl: LocalPostDataSourceImpl): \n               LocalPostDataSource\n        @Binds\n        abstract fun bindUserDataSource\n            (userDataSourceImpl: LocalUserDataSourceImpl): \n                LocalUserDataSource\n        @Binds\n        abstract fun bindInteractionDataStore\n            (interactionDataStore:LocalInteractionData\n                SourceImpl): LocalInteractionDataSource\n    }\n    ```", "```kt\n    class LocalUserDataSourceImplTest {\n        private val userDao = mock<UserDao>()\n        private val userDataSource = \n            LocalUserDataSourceImpl(userDao)\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetUsers() = runBlockingTest {\n            val localUsers = listOf(UserEntity(1, \"name\", \n                \"username\", \"email\"))\n            val expectedUsers = listOf(User(1, \"name\", \n                \"username\", \"email\"))\n            whenever(userDao.getUsers()).thenReturn\n                (flowOf(localUsers))\n            val result = userDataSource.getUsers().first()\n            Assert.assertEquals(expectedUsers, result)\n        }\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testAddUsers() = runBlockingTest {\n            val localUsers = listOf(UserEntity(1, \"name\", \n                \"username\", \"email\"))\n            val users = listOf(User(1, \"name\", \"username\", \n                \"email\"))\n            userDataSource.addUsers(users)\n            verify(userDao).insertUsers(localUsers)\n        }\n    }\n    ```", "```kt\n    class LocalPostDataSourceImplTest {\n        private val postDao = mock<PostDao>()\n        private val postDataSource = \n            LocalPostDataSourceImpl(postDao)\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetPosts() = runBlockingTest {\n            val localPosts = listOf(PostEntity(1, 1, \n                \"title\", \"body\"))\n            val expectedPosts = listOf(Post(1, 1, \"title\", \n                \"body\"))\n            whenever(postDao.getPosts()).thenReturn\n                (flowOf(localPosts))\n            val result = postDataSource.getPosts().first()\n            Assert.assertEquals(expectedPosts, result)\n        }\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testAddUsers() = runBlockingTest {\n            val localPosts = listOf(PostEntity(1, 1, \n                \"title\", \"body\"))\n            val posts = listOf(Post(1, 1, \"title\", \n                \"body\"))\n            postDataSource.addPosts(posts)\n            verify(postDao).insertPosts(localPosts)\n        }\n    }\n    ```", "```kt\n    class LocalInteractionDataSourceImplTest {\n        private val dataStore = mock<DataStore\n            <Preferences>>()\n        private val interactionDataSource = \n            LocalInteractionDataSourceImpl(dataStore)\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testGetInteraction() = runBlockingTest {\n            val clicks = 10\n            val interaction = Interaction(clicks)\n            val preferences = mock<Preferences>()\n            whenever(preferences[KEY_TOTAL_TAPS]).\n                thenReturn(clicks)\n            whenever(dataStore.data).thenReturn\n                (flowOf(preferences))\n            val result = interactionDataSource.\n                getInteraction().first()\n            assertEquals(interaction, result)\n        }\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testSaveInteraction() = runBlockingTest {\n            val clicks = 10\n            val interaction = Interaction(clicks)\n            val preferences = mock<MutablePreferences>()\n            whenever(preferences.toMutablePreferences())\n                .thenReturn(preferences)\n            whenever(dataStore.updateData(any())).\n                thenAnswer {\n                runBlocking {\n                    it.getArgument<suspend (Preferences) -\n                     > Preferences>(0).invoke(preferences)\n                }\n                preferences\n            }\n            interactionDataSource.saveInteraction(interaction)\n            verify(preferences)[KEY_TOTAL_TAPS] = clicks\n        }\n    }\n    ```"]