<html><head></head><body>
        

            
                <h1 class="header-title">Enabling VirtualBox-Specific Hardware Interfaces</h1>
            

            
                
<p>In the last chapter, we did a deep analysis of Android Gralloc HAL modules. We analyzed the default Gralloc module and the hardware GPU emulation Gralloc HAL for the Android emulator. We don't have time to walk through the boot up process related to the graphics system yet. In this chapter, we will walk through the boot up process of the graphics system and explore the VirtualBox-specific hardware drivers. At the end of this chapter, we will have a relatively complete system on VirtualBox. We will cover the following topics in this chapter:</p>
<ul>
<li>OpenGL ES and graphics hardware initialization</li>
<li>Integration of VirtualBox Guest Additions</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">OpenGL ES and graphics hardware initialization</h1>
            

            
                
<p>In Android systems, the initialization of the graphics system is done by SurfaceFlinger. Besides the Gralloc HAL that we discussed in <a href="900f7c1a-7db8-4172-899a-8e9a167372ce.xhtml">Chapter 10</a>, <em>Enabling Graphics</em>, another important part of graphics system initialization is the loading of OpenGL ES libraries. In our VirtualBox implementation, we use most of the HAL modules from Android-x86. The graphics system support includes the following components:</p>
<ul>
<li>Gralloc HAL</li>
<li>Mesa lib for OpenGL ES</li>
<li>uvesafb framebuffer driver or VirtualBox video driver</li>
</ul>
<p>We have discussed Gralloc HAL in the last chapter. We will explore the loading of the OpenGL ES library and uvesafb framebuffer driver in this chapter. We will use the default uvesafb framebuffer driver in the introduction of graphics system initialization. We will also introduce how to use the native graphic driver from VirtualBox when we talk about the integration of VirtualBox Guest Additions later in this chapter.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Loading OpenGL ES libraries</h1>
            

            
                
<p><strong>OpenGL ES</strong> stands for <strong>Open GL Embedded System</strong>, which is a subset of OpenGL from Khronos. EGL is an interface between OpenGL ES and the underlying native platform. The API of EGL is supposed to be platform-agnostic, but the implementation of the EGL API is not.</p>
<p>The implementation of OpenGL ES in Android includes the Java API and native implementation. These two parts can be found at:</p>
<ul>
<li>Java API: <kbd>$AOSP/frameworks/base/opengl</kbd></li>
<li>OpenGL ES native: <kbd>$AOSP/frameworks/native/opengl</kbd></li>
</ul>
<p>These two parts of the OpenGL implementation depend on a vendor implementation to provide the full function of the OpenGL ES API. During the system start-up, the system will search for paths <kbd>/system/lib/egl</kbd> or <kbd>/vendor/lib/egl</kbd> to find the vendor OpenGL libraries.</p>
<p>The OpenGL ES vendor libraries should follow the following naming conventions. If the vendor library is a single library, it should use the name as <kbd>libGLES_*.so</kbd>. In our case, the OpenGL ES library for VirtualBox is <kbd>libGLES_mesa.so</kbd>, which is provided as a single library.</p>
<p>If the vendor libraries are provided as separate libraries, they must be something like the following:</p>
<ul>
<li><kbd>/system/lib/egl/libEGL_*.so</kbd></li>
<li><kbd>/system/lib/egl/libGLESv1_CM_*.so</kbd></li>
<li><kbd>/system/lib/egl/libGLESv2_*.so</kbd></li>
</ul>
<p>This is the case for the Android emulator hardware emulation libraries. We can find the following ones for the Android emulator:</p>
<ul>
<li><kbd>/system/lib/egl/libEGL_emulation.so</kbd></li>
<li><kbd>/system/lib/egl/libGLESv1_CM_emulation.so</kbd></li>
<li><kbd>/system/lib/egl/libGLESv2_emulation.so</kbd></li>
</ul>
<p>The vendor libraries are loaded during the <kbd>SurfaceFlinger</kbd> initialization. Before we go to the details about the start up process, let's have a look at the message from the debug log first.</p>
<p>I removed the timestamp from the following log so that we can have a better format:</p>
<pre>
I SurfaceFlinger: SurfaceFlinger is starting <br/>I SurfaceFlinger: SurfaceFlinger's main thread ready to run. Initializing graphics H/W... <br/>D libEGL  : loaded /system/lib/egl/libGLES_mesa.so <br/>W linker  : /system/lib/libglapi.so has text relocations. This is wasting memory and prevents security hardening. Please fix. <br/>I HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0x5 handle=0xb7145664 <br/>I EGL-DRI2: found extension DRI_Core version 1 <br/>I EGL-DRI2: found extension DRI_SWRast version 5 <br/>I EGL-DRI2: found extension DRI_TexBuffer version 2 <br/>I EGL-DRI2: found extension DRI_IMAGE version 11 <br/>I HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0x0 handle=0xb7145664 <br/>I powerbtn: open event0(Power Button) ok fd=4 <br/>W gralloc : page flipping not supported (yres_virtual=768, requested=1536) <br/>I gralloc : using (fd=12) <br/>I gralloc : id           = VESA VGA <br/>I gralloc : xres         = 1024 px <br/>I gralloc : yres         = 768 px <br/>I gralloc : xres_virtual = 1024 px <br/>I gralloc : yres_virtual = 768 px <br/>I gralloc : bpp          = 32 <br/>I gralloc : r            = 16:8 <br/>I gralloc : g            =  8:8 <br/>I gralloc : b            =  0:8 <br/>I gralloc : a            = 24:8 <br/>I gralloc : stride       = 4096 <br/>I gralloc : fbSize       = 12582912 <br/>I gralloc : width        = 163 mm (159.568100 dpi) <br/>I gralloc : height       = 122 mm (159.895081 dpi) <br/>I gralloc : refresh rate = 65.46 Hz <br/>E SurfaceFlinger: hwcomposer module not found 
</pre>
<p>As we can see, when the main thread of <kbd>SurfaceFlinger</kbd> is ready to run, it loads the <kbd>/system/lib/egl/libGLES_mesa.so</kbd> library during the x86vbox device boot up. After that, it loads and initializes the <kbd>gralloc.default.so</kbd> Gralloc module:</p>
<pre>
I SurfaceFlinger: EGL information: <br/>I SurfaceFlinger: vendor    : Android <br/>I SurfaceFlinger: version   : 1.4 Android META-EGL <br/>I SurfaceFlinger: extensions: EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffers_with_damage EGL_KHR_image_base EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_3D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_reusable_sync EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_surfaceless_context EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable  <br/>I SurfaceFlinger: Client API: OpenGL_ES <br/>I SurfaceFlinger: EGLSurface: 8-8-8-8, config=0xb46a3800 
</pre>
<p>Next, <kbd>SurfaceFlinger</kbd> initializes the EGL library as the preceding log message. The EGL version in our environment is 1.4:</p>
<pre>
I SurfaceFlinger: OpenGL ES informations: <br/>I SurfaceFlinger: vendor    : VMware, Inc. <br/>I SurfaceFlinger: renderer  : Gallium 0.4 on llvmpipe (LLVM 3.7, 256 bits) <br/>I SurfaceFlinger: version   : OpenGL ES 3.0 Mesa 12.0.1 (git-c3bb2e3) <br/>I SurfaceFlinger: extensions: GL_EXT_blend_minmax GL_EXT_multi_draw_arrays GL_EXT_texture_compression_dxt1 GL_EXT_texture_format_BGRA8888 GL_OES_compressed_ETC1_RGB8_texture GL_OES_depth24 GL_OES_element_index_uint GL_OES_fbo_render_mipmap GL_OES_mapbuffer GL_OES_rgb8_rgba8 GL_OES_standard_derivatives GL_OES_stencil8 GL_OES_texture_3D GL_OES_texture_float GL_OES_texture_float_linear GL_OES_texture_half_float GL_OES_texture_half_float_linear GL_OES_texture_npot GL_EXT_texture_sRGB_decode GL_OES_EGL_image GL_OES_depth_texture GL_OES_packed_depth_stencil GL_EXT_texture_type_2_10_10_10_REV GL_OES_get_program_binary GL_APPLE_texture_max_level GL_EXT_discard_framebuffer GL_EXT_read_format_bgra GL_NV_fbo_color_attachments GL_OES_EGL_image_external GL_OES_EGL_sync GL_OES_vertex_array_object GL_ANGLE_texture_compression_dxt3 GL_ANGLE_texture_compression_dxt5 GL_EXT_texture_rg GL_EXT_unpack_subimage GL_NV_draw_buffers GL_NV_read_buffer GL_NV_read_depth GL_NV_read_depth_stencil GL_NV_read_stencil GL_EXT_draw_buffers GL_EXT_map_buffer_ra <br/>I SurfaceFlinger: GL_MAX_TEXTURE_SIZE = 8192 <br/>I SurfaceFlinger: GL_MAX_VIEWPORT_DIMS = 8192 <br/>D SurfaceFlinger: Open /dev/tty0 OK <br/>I HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0xb769a108 handle=0xb7145664 <br/>I HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0xb769a108 handle=0xb7145664 <br/>D SurfaceFlinger: Set power mode=2, type=0 flinger=0xb70e2000 <br/>D SurfaceFlinger: shader cache generated - 24 shaders in 25.081509 ms 
</pre>
<p>After EGL initialization, the OpenGL ES library is initialized, as we can see from the preceding log message. We can see that OpenGL ES 3.0 is supported by the Mesa library. The rendering engine is a software implementation using Gallium with <kbd>llvmpipe</kbd>.</p>
<p>Each graphics hardware vendor usually has their own implementation of OpenGL. Mesa is an open source implementation of OpenGL. Mesa has multiple backends for OpenGL support. It can support both hardware and software implementation according to the hardware GPU. If you don't have a hardware GPU, Mesa has three CPU-based implementations: swrast, softpipe, and llvmpipe. The one that we used in x86vbox is llvmpipe. There are two architectures for Mesa driver implementation. Gallium is the new architecture for the Mesa driver implementation.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Analyzing the loading process</h1>
            

            
                
<p>After we have a general introduction about OpenGL ES implementation in x86vbox (reuse from Android-x86), we will analyze the source code to have another level of understanding. Since the detail implementation of graphics systems and OpenGL ES is huge, we won't be able to cover them in a chapter. We will focus on the loading process of graphics systems and the OpenGL ES library in our analysis.</p>
<p>Again, you may feel frustrated while we walk through the source code. The best way to help with this is to open your source code editor while you read this chapter. If you don't have AOSP source code at hand, you can always refer to the following website:<br/>
<a href="http://xref.opersys.com/">http://xref.opersys.com/</a><br/>
You can just search for the function name that we discuss in this chapter to locate the source code.</p>
<p>From the preceding debug log, we will start from the point where we see the first debug message related to the graphics system and <kbd>SurfaceFlinger</kbd>, as follows:</p>
<pre>
I SurfaceFlinger: SurfaceFlinger is starting <br/>I SurfaceFlinger: SurfaceFlinger's main thread ready to run. Initializing graphics H/W... 
</pre>
<p>The first message is printed by the constructor of <kbd>SurfaceFlinger</kbd> and the second message is printed out from the <kbd>init</kbd> method of <kbd>SurfaceFlinger</kbd>.</p>
<p>The source code of <kbd>SurfaceFlinger</kbd> can be found at: <kbd>$AOSP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</kbd>.</p>
<p>We will start our analysis from <strong>SurfaceFlinger:init</strong>, according to the flow shown in the following diagram:</p>
<div><img height="250" width="342" class=" image-border" src="img/image_11_001.png"/></div>
<p>Loading of OpenGL ES libraries</p>
<p>In <kbd>SurfaceFlinger:init</kbd>, as shown in the following code snippet, it calls the EGL function <kbd>eglGetDisplay</kbd> first. After that, it tries to create a hardware composer instance. With the instances of display <kbd>mEGLDisplay</kbd> and hardware composer <kbd>mHwc</kbd>, it creates a rendering engine using the underlying OpenGL ES implementation:</p>
<pre>
void SurfaceFlinger::init() { <br/>    ALOGI(  "SurfaceFlinger's main thread ready to run. " <br/>            "Initializing graphics H/W..."); <br/><br/>    Mutex::Autolock _l(mStateLock); <br/><br/>    // initialize EGL for the default display <br/>    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); <br/>    eglInitialize(mEGLDisplay, NULL, NULL); <br/><br/>    ... <br/><br/>    // Initialize the H/W composer object.  There may or may not  <br/>    // be an actual hardware composer underneath. <br/>    mHwc = new HWComposer(this, <br/>            *static_cast&lt;HWComposer::EventHandler *&gt;(this)); <br/><br/>    // get a RenderEngine for the given display / config <br/>    mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc-<br/>    &gt;getVisualID()); <br/><br/>    // retrieve the EGL context that was selected/created <br/>    mEGLContext = mRenderEngine-&gt;getEGLContext(); 
</pre>
<p>Let's analyze the EGL function <kbd>eglGetDisplay</kbd> first. The <kbd>eglGetDisplay</kbd> function is implemented in the <kbd>frameworks/native/opengl/libs/EGL/eglApi.cpp</kbd> file, as shown in the following code snippet:</p>
<pre>
EGLDisplay eglGetDisplay(EGLNativeDisplayType display) <br/>{ <br/>    clearError(); <br/><br/>    uintptr_t index = reinterpret_cast&lt;uintptr_t&gt;(display); <br/>    if (index &gt;= NUM_DISPLAYS) { <br/>        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY); <br/>    } <br/><br/>    if (egl_init_drivers() == EGL_FALSE) { <br/>        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY); <br/>    } <br/><br/>    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display); <br/>    return dpy; <br/>} 
</pre>
<p>In <kbd>eglGetDisplay</kbd>, it checks the index of display to be initialized first. In the current Android code, the <kbd>EGL_DEFAULT_DISPLAY</kbd> parameter is zero and the definition of <kbd>NUM_DISPLAYS</kbd> is 1. This means it can only support one display in the current Android implementation. What does this mean here? For example, if you have a laptop, you can connect it to a projector. In this case, you can have two displays at the same time. Some new computers can even connect to three displays at the same time nowadays. After checking the number of displays, it calls the <kbd>egl_init_drivers</kbd> function to load the OpenGL ES libraries:</p>
<pre>
static EGLBoolean egl_init_drivers_locked() { <br/>    if (sEarlyInitState) { <br/>        // initialized by static ctor. should be set here. <br/>        return EGL_FALSE; <br/>    } <br/><br/>    // get our driver loader <br/>    Loader&amp; loader(Loader::getInstance()); <br/><br/>    // dynamically load our EGL implementation <br/>    egl_connection_t* cnx = &amp;gEGLImpl; <br/>    if (cnx-&gt;dso == 0) { <br/>        cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX] = <br/>                &amp;gHooks[egl_connection_t::GLESv1_INDEX]; <br/>        cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX] = <br/>                &amp;gHooks[egl_connection_t::GLESv2_INDEX]; <br/>        cnx-&gt;dso = loader.open(cnx); <br/>    } <br/><br/>    return cnx-&gt;dso ? EGL_TRUE : EGL_FALSE; <br/>} <br/><br/>static pthread_mutex_t sInitDriverMutex = PTHREAD_MUTEX_INITIALIZER; <br/><br/>EGLBoolean egl_init_drivers() { <br/>    EGLBoolean res; <br/>    pthread_mutex_lock(&amp;sInitDriverMutex); <br/>    res = egl_init_drivers_locked(); <br/>    pthread_mutex_unlock(&amp;sInitDriverMutex); <br/>    return res; <br/>} 
</pre>
<p>The <kbd>egl_init_drivers</kbd> function acquires a mutex and calls to another function, <kbd>egl_init_drivers_locked</kbd>, to load the OpenGL ES libraries. In the <kbd>egl_init_drivers_locked</kbd> function, it gets an instance of a <kbd>Loader</kbd> class, which is defined using the <strong>singleton pattern</strong>. After that, it initializes the global variable <kbd>gEGLImpl</kbd>, which is defined as the data structure <kbd>egl_connection_t</kbd>:</p>
<pre>
struct egl_connection_t { <br/>    enum { <br/>        GLESv1_INDEX = 0, <br/>        GLESv2_INDEX = 1 <br/>    }; <br/><br/>    inline egl_connection_t() : dso(0) { } <br/>    void *              dso; <br/>    gl_hooks_t *        hooks[2]; <br/>    EGLint              major; <br/>    EGLint              minor; <br/>    egl_t               egl; <br/><br/>    void*               libEgl; <br/>    void*               libGles1; <br/>    void*               libGles2; <br/>}; 
</pre>
<p>In the <kbd>egl_connection_t</kbd> data structure, it defines the following fields:</p>
<ul>
<li><kbd>dso</kbd>: This is a pointer that points to a <kbd>driver_t</kbd> data structure defined inside the <kbd>Loader</kbd> class. This <kbd>driver_t</kbd> data structure stores the handle of OpenGL ES libraries after they are loaded by the <kbd>Loader</kbd> class.</li>
<li><kbd>hooks</kbd>: This is an array of the pointers of the <kbd>gl_hooks_t</kbd> data structure. The <kbd>gl_hooks_t</kbd> data structure is used to define all the function pointers of the OpenGL ES API. After the OpenGL ES libraries are loaded, the OpenGL ES functions inside the libraries will be initialized and assigned to the <kbd>hooks</kbd> field. There are two OpenGL ES versions that are defined in <kbd>enum { GLESv1_INDEX , GLESv2_INDEX }</kbd>. The <kbd>hooks[GLESv1_INDEX]</kbd> is used to store OpenGL ES version 1 APIs and it points to the <kbd>gHooks[GLESv1_INDEX]</kbd> global variable. The same is for <kbd>GLESv2_INDEX</kbd>. The list of OpenGL ES APIs can be found in the following file: <kbd>$AOSP/frameworks/native/opengl/libs/entries.in</kbd></li>
<li><kbd>major</kbd> and <kbd>minor</kbd>: These two are used to store the EGL version.</li>
<li><kbd>egl</kbd>: This is defined as <kbd>egl_t</kbd>, which is used to store the EGL APIs. The list of EGL APIs can be found in the following file: <kbd>$AOSP/frameworks/native/opengl/libs/EGL/egl_entries.in</kbd></li>
<li><kbd>libEgl</kbd>, <kbd>libGles1</kbd>, and <kbd>libGles2</kbd>: These are the handles of OpenGL ES wrapper libraries. We will see the initialization of these libraries in a moment.</li>
</ul>
<p>After the <kbd>cnx</kbd> data structure is initialized, it calls the <kbd>loader.open</kbd> function to load the libraries. Let's look at the <kbd>loader.open</kbd> function:</p>
<pre>
void* Loader::open(egl_connection_t* cnx) <br/>{ <br/>    void* dso; <br/>    driver_t* hnd = 0; <br/><br/>    dso = load_driver("GLES", cnx, EGL | GLESv1_CM | GLESv2); <br/>    if (dso) { <br/>        hnd = new driver_t(dso); <br/>    } else { <br/>        // Always load EGL first <br/>        dso = load_driver("EGL", cnx, EGL); <br/>        if (dso) { <br/>            hnd = new driver_t(dso); <br/>            hnd-&gt;set( load_driver("GLESv1_CM", cnx, GLESv1_CM), <br/>            GLESv1_CM ); <br/>            hnd-&gt;set( load_driver("GLESv2",    cnx, GLESv2),    GLESv2 ); <br/>        } <br/>    } <br/><br/>    LOG_ALWAYS_FATAL_IF(!hnd, "couldn't find an OpenGL ES <br/>    implementation"); <br/><br/>#if defined(__LP64__) <br/>    cnx-&gt;libEgl   = load_wrapper("/system/lib64/libEGL.so"); <br/>    cnx-&gt;libGles2 = load_wrapper("/system/lib64/libGLESv2.so"); <br/>    cnx-&gt;libGles1 = load_wrapper("/system/lib64/libGLESv1_CM.so"); <br/>#else <br/>    cnx-&gt;libEgl   = load_wrapper("/system/lib/libEGL.so"); <br/>    cnx-&gt;libGles2 = load_wrapper("/system/lib/libGLESv2.so"); <br/>    cnx-&gt;libGles1 = load_wrapper("/system/lib/libGLESv1_CM.so"); <br/>#endif <br/>    LOG_ALWAYS_FATAL_IF(!cnx-&gt;libEgl, <br/>            "couldn't load system EGL wrapper libraries"); <br/><br/>    LOG_ALWAYS_FATAL_IF(!cnx-&gt;libGles2 || !cnx-&gt;libGles1, <br/>            "couldn't load system OpenGL ES wrapper libraries"); <br/><br/>    return (void*)hnd; <br/>} 
</pre>
<p>In <kbd>Loader::open</kbd>, it tries to load a single OpenGL ES library first. If it fails, it tries to load the separated libraries one by one. If the libraries are loaded successfully, it stores the handles to the <kbd>driver_t</kbd> data structure. We explained about <kbd>driver_t</kbd> previously when we talked about the <kbd>dso</kbd> field in the <kbd>egl_connection_t</kbd> data structure. The actual loading process is done in the <kbd>load_driver</kbd> function and we will look at it soon. After the OpenGL ES libraries are loaded, it also tries to load the wrapper libraries using the <kbd>load_wrapper</kbd> function. The <kbd>load_wrapper</kbd> function just calls the <kbd>dlopen</kbd> system call and returns the handle so we don't need to investigate it.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Loading the driver</h1>
            

            
                
<p>Let's analyze the <kbd>load_driver</kbd> function, which is the one that finds and loads the OpenGL ES user space driver:</p>
<pre>
void *Loader::load_driver(const char* kind, <br/>        egl_connection_t* cnx, uint32_t mask) <br/>{ <br/>    class MatchFile { <br/>    public: <br/>        static String8 find(const char* kind) { <br/>    ... <br/>    }; <br/><br/><br/>    String8 absolutePath = MatchFile::find(kind); <br/>    if (absolutePath.isEmpty()) { <br/>        // this happens often, we don't want to log an error <br/>        return 0; <br/>    } <br/>    const char* const driver_absolute_path = absolutePath.string(); <br/><br/>    void* dso = dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL); <br/>    if (dso == 0) { <br/>        const char* err = dlerror(); <br/>        ALOGE("load_driver(%s): %s", driver_absolute_path, err?<br/>        err:"unknown"); <br/>        return 0; <br/>    } <br/><br/>    ALOGD("loaded %s", driver_absolute_path); <br/><br/>    if (mask &amp; EGL) { <br/>        getProcAddress = (getProcAddressType)dlsym(dso, <br/>        "eglGetProcAddress"); <br/><br/>        ALOGE_IF(!getProcAddress, <br/>                "can't find eglGetProcAddress() in %s", <br/>                driver_absolute_path); <br/><br/>        egl_t* egl = &amp;cnx-&gt;egl; <br/>        __eglMustCastToProperFunctionPointerType* curr = <br/>            (__eglMustCastToProperFunctionPointerType*)egl; <br/>        char const * const * api = egl_names; <br/>        while (*api) { <br/>            char const * name = *api; <br/>            __eglMustCastToProperFunctionPointerType f = <br/>                (__eglMustCastToProperFunctionPointerType)dlsym(dso, <br/>                name); <br/>            if (f == NULL) { <br/>                // couldn't find the entry-point, use <br/>                // eglGetProcAddress() <br/><br/>                f = getProcAddress(name); <br/>                if (f == NULL) { <br/>                    f = (__eglMustCastToProperFunctionPointerType)0; <br/>                } <br/>            } <br/>            *curr++ = f; <br/>            api++; <br/>        } <br/>    } <br/><br/>    if (mask &amp; GLESv1_CM) { <br/>        init_api(dso, gl_names, <br/>            (__eglMustCastToProperFunctionPointerType*) <br/>                &amp;cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl, <br/>               getProcAddress); <br/>    } <br/><br/>    if (mask &amp; GLESv2) { <br/>      init_api(dso, gl_names, <br/>            (__eglMustCastToProperFunctionPointerType*) <br/>                &amp;cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl, <br/>            getProcAddress); <br/>    } <br/><br/>    return dso; <br/>} 
</pre>
<p>In the <kbd>load_driver</kbd> function, it defines a <kbd>MatchFile</kbd> inner class. It uses the <kbd>MatchFile::find</kbd> method to find the path of the libraries. The <kbd>load_driver</kbd> function has three parameters: <kbd>kind</kbd>, <kbd>cnx</kbd>, and <kbd>mask</kbd>. According to the kind of libraries, the parameter kind could be <kbd>GLES</kbd>, <kbd>EGL</kbd>, <kbd>GLESv1_CM</kbd>, or <kbd>GLESv2</kbd>. Once it gets the absolute path of a library, it calls the <kbd>dlopen</kbd> system function to open the shared library. The <kbd>mask</kbd> parameter is a bit map of the <kbd>kind</kbd> parameter. Using the <kbd>mask</kbd> parameter, it can initialize the <kbd>cnx</kbd> parameter according to the kind of library. As we mentioned before, the <kbd>cnx</kbd> parameter, which is an instance of <kbd>egl_connection_t</kbd>, has an <kbd>egl</kbd> field to store all the EGL function pointers. It has another field, <kbd>hooks[GLESv1_INDEX]/ hooks[GLESv2_INDEX]</kbd>, to store all OpenGL ES functions.</p>
<p>If the library type is EGL, it gets the address of the <kbd>eglGetProcAddress</kbd> function by first calling the <kbd>dlsym</kbd> system function. After that, it will loop through all the function names defined in the <kbd>egl_names</kbd> global variable to find out the addresses and store them in <kbd>cnx-&gt;egl</kbd>. During the process, it tries to get the address using the <kbd>dlsym</kbd> system function first. If the call to <kbd>dlsym</kbd> fails, it will try it again using the <kbd>eglGetProcAddress</kbd> function.</p>
<p>If the library type is either <kbd>GLESv1_CM</kbd> or <kbd>GLESv2</kbd>, it calls another function, <kbd>init_api</kbd>, to initialize all OpenGL ES function pointers. In the <kbd>init_api</kbd> function, it will loop through all the function names defined in the <kbd>gl_names</kbd> global variable to find out the addresses and store them in <kbd>cnx-&gt;hooks[egl_connection_t::GLESv?_INDEX]-&gt;gl</kbd>.</p>
<p>Now we have done all the initialization of the OpenGL ES user space drivers and we can use the <kbd>egl_connection_t</kbd> data structure to access all OpenGL ES vendor APIs.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating the rendering engine</h1>
            

            
                
<p>After the OpenGL ES vendor libraries are loaded, <kbd>SurfaceFlinger:init</kbd> will create the rendering engine:</p>
<pre>
mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID()); 
</pre>
<p>Inside <kbd>RenderEngine::create</kbd>, it will call <kbd>RenderEngine::chooseEglConfig</kbd>, which will print out the debug message for EGL:</p>
<pre>
EGLConfig RenderEngine::chooseEglConfig(EGLDisplay display, int format) { <br/>    status_t err; <br/>    EGLConfig config; <br/><br/>    // First try to get an ES2 config <br/>    err = selectEGLConfig(display, format, EGL_OPENGL_ES2_BIT, <br/>    &amp;config); <br/>    ... <br/>    eglGetConfigAttrib(display, config, EGL_ALPHA_SIZE, &amp;a); <br/>    ALOGI("EGL information:"); <br/>    ALOGI("vendor    : %s", eglQueryString(display, EGL_VENDOR)); <br/>    ALOGI("version   : %s", eglQueryString(display, EGL_VERSION)); <br/>    ALOGI("extensions: %s", eglQueryString(display, EGL_EXTENSIONS)); <br/>    ALOGI("Client API: %s", eglQueryString(display, <br/>    EGL_CLIENT_APIS)?:"Not <br/>    Supported"); <br/>    ALOGI("EGLSurface: %d-%d-%d-%d, config=%p", r, g, b, a, config); <br/><br/>    return config; <br/>} 
</pre>
<p>At the end of <kbd>RenderEngine::create</kbd>, it will print out the OpenGL ES initialization information as follows:</p>
<pre>
RenderEngine* RenderEngine::create(EGLDisplay display, int hwcFormat) { <br/>    EGLConfig config = EGL_NO_CONFIG; <br/>    if (!findExtension( <br/>            eglQueryStringImplementationANDROID(display,  <br/>            EGL_EXTENSIONS), <br/>            "EGL_ANDROIDX_no_config_context")) { <br/>        config = chooseEglConfig(display, hwcFormat); <br/>    } <br/><br/>    ... <br/><br/>    engine-&gt;setEGLHandles(config, ctxt); <br/><br/>    ALOGI("OpenGL ES informations:"); <br/>    ALOGI("vendor    : %s", extensions.getVendor()); <br/>    ALOGI("renderer  : %s", extensions.getRenderer()); <br/>    ALOGI("version   : %s", extensions.getVersion()); <br/>    ALOGI("extensions: %s", extensions.getExtension()); <br/>    ALOGI("GL_MAX_TEXTURE_SIZE = %zu", engine-&gt;getMaxTextureSize()); <br/>    ALOGI("GL_MAX_VIEWPORT_DIMS = %zu", engine-&gt;getMaxViewportDims()); <br/><br/>    eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, <br/>    EGL_NO_CONTEXT); <br/>    eglDestroySurface(display, dummy); <br/><br/>    return engine; <br/>} 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">The uvesafb framebuffer driver</h1>
            

            
                
<p>Th framebuffer driver is the third component that we need to support the graphics system for x86vbox. Since you may run VirtualBox on different Intel devices, they may use different graphics hardware, such as Nvidia, AMD, or Intel. To get the best performance in a virtualization environment, you may want to explore various GPU virtualization technologies, such as GPU passthrough, GPU sharing, GPU software emulation, and so on. To have a simple solution, we use the default solution from Android-x86, which is the uvesafb framebuffer driver.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">What is uvesafb?</h1>
            

            
                
<p>The uvesafb is a user space VESA framebuffer driver that works with VESA 2.0-compliant graphic cards. VESA BIOS extensions provide the primary functionality of VESA standard through the BIOS interface. On Linux, uvesafb needs a user space daemon called <kbd>v86d</kbd> as a backend for kernel drivers that need to execute x86 BIOS code. Since BIOS code can only be executed in a controlled environment, the code executed by <kbd>v86d</kbd> can be run either in a fully software-emulated environment or a virtualized environment supported by the CPU. The <kbd>v86d</kbd> has been ported to Android by the Android-x86 project. It can be found at <kbd>$AOSP/external/v86d</kbd>. Since the <kbd>v86d</kbd> project needs additional system calls such as <kbd>ioperm</kbd> and <kbd>iopl</kbd>, the Android-x86 project changed the bionic library to support these system calls.</p>
<p>You can refer to the following kernel document to find out more about uvesafb:</p>
<p><a href="https://www.kernel.org/doc/Documentation/fb/uvesafb.txt">https://www.kernel.org/doc/Documentation/fb/uvesafb.txt</a></p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Testing the uvesafb framebuffer driver</h1>
            

            
                
<p>Before we try to understand how uvesafb is loaded in our environment, we can test it using two framebuffer testing tools, <kbd>fbset</kbd> and <kbd>fbtest</kbd>.</p>
<p>As we know, we can boot to a debug console using two stages boot of Android-x86 from <a href="c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml">Chapter 9</a>, <em>Booting Up x86vbox Using PXE/NFS</em>. We can test uvesafb in the debug console with <kbd>fbset</kbd> and <kbd>fbtest</kbd>.</p>
<p><kbd>fbset</kbd> is a system tool to show or change the settings of the framebuffer device. You can refer to the help page of Linux commands to find out how to use <kbd>fbset</kbd>. In our environment, we use <kbd>busybox</kbd> in the first stage boot and we use <kbd>toybox</kbd> or <kbd>toolbox</kbd> in the Android environment. <kbd>fbset</kbd> is supported by <kbd>busybox</kbd>, so we can use it in the first stage or the second stage boot through <kbd>busybox</kbd>.</p>
<p><kbd>fbtest</kbd> is a framebuffer test program that can be found at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git">https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git</a>.</p>
<p>I cloned it from the kernel Git repository and ported it to the Android environment. The source code for Android can be found at GitHub via the following link:</p>
<p><a href="https://github.com/shugaoye/fbtest">https://github.com/shugaoye/fbtest</a></p>
<p>To build <kbd>fbtest</kbd>, we can get it from GitHub and build it in the AOSP build environment:</p>
<pre>
<strong>$ cd {your AOSP root folder}</strong><br/><strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86vbox-eng</strong>  
</pre>
<p>After we set up the AOSP build environment, we can check out and build the <kbd>fbtest</kbd> source code using the following commands:</p>
<pre>
<strong>$ cd $HOME</strong><br/><strong>$ git clone https://github.com/shugaoye/fbtest</strong><br/><strong>$ cd fbtest</strong><br/><strong>$ git checkout -b android-x86 remotes/origin/android-x86</strong><br/><strong>$ make</strong>  
</pre>
<p>Be aware that I changed the Makefile and that it depends on the AOSP environment variable <kbd>$OUT</kbd>, as follows:</p>
<pre>
# Paths and settings <br/>TARGET_PRODUCT = x86vbox <br/>ANDROID_ROOT   = $(OUT)/../../../.. <br/>BIONIC_LIBC    = $(ANDROID_ROOT)/bionic/libc <br/>PRODUCT_OUT    = $(ANDROID_ROOT)/out/target/product/$(TARGET_PRODUCT) <br/>CROSS_COMPILE  = \ <br/>    $(ANDROID_ROOT)/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-  <br/>    4.9/bin/x86_64-linux-android- <br/><br/>ARCH_NAME = x86 <br/><br/># Tool names <br/>AS            = $(CROSS_COMPILE)as <br/>AR            = $(CROSS_COMPILE)ar <br/>... 
</pre>
<p>If we look at the preceding <kbd>fbtest/Rules.make</kbd> Makefile, we use the <kbd>$OUT</kbd> environment variable to find the right AOSP build environment. After that, we can use prebuilt toolchains and the <kbd>bionic</kbd> library to build <kbd>fbtest</kbd>.</p>
<p>After we build <kbd>fbtest</kbd>, we can copy it to the <kbd>$OUT/system/bin</kbd> folder so that we can use it in the test environment later. As we remember from <a href="c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml">Chapter 9</a>, <em>Booting Up x86vbox Using PXE/NFS</em>, we can boot to a debug console in the first stage boot using PXE/NFS. In this case, we can change and test <kbd>fbtest</kbd> without rebooting the x86vbox, since we can access the build result through NFS from x86vbox.</p>
<p>Let's boot x86vbox to the debug console in the first stage boot and perform the tests. As we recall, we have a minimal embedded Linux environment in the debug console of the first stage boot. We have a built-in <kbd>busybox</kbd> available in this environment. Before we test the framebuffer device, we must load the <kbd>uvesafb</kbd> module manually, as shown in the following screenshot:</p>
<div><img height="320" width="500" class=" image-border" src="img/image_11_002.png"/></div>
<p>We use the following command to load the <kbd>uvesafb</kbd> module:</p>
<pre>
<strong>(debug-late)@android: /android # system/xbin/modprobe uvesafb</strong>  
</pre>
<p>From the debug output, we can see that the underlying graphic hardware is <kbd>Oracle VM VirtualBox VBE Adapter</kbd>.</p>
<p>After the <kbd>uvesafb</kbd> module is loaded, we can find the <kbd>/dev/fb0</kbd> device. We can use <kbd>fbset</kbd> to change the settings of the framebuffer device. For example, we can switch to different supported resolutions as we want. Let's just run the <kbd>fbset</kbd> command and see what happens. If we run <kbd>fbset</kbd> without any parameters, we can see the following output:</p>
<pre>
<strong>(debug-late)@android:/android # fbset </strong><br/><br/><strong>mode "640x480-60" </strong><br/><strong>        # D: 23.845 MHz, H: 29.844 kHz, V: 60.048 Hz </strong><br/><strong>        geometry 640 480 640 9830 16 </strong><br/><strong>        timings 41937 80 16 13 1 63 3 </strong><br/><strong>        accel false </strong><br/><strong>        rgba 5/11,6/5,5/0,0/0 </strong><br/><strong>endmode</strong>  
</pre>
<p>If <kbd>fbset</kbd> is run without any parameters, it just prints out the current settings of the framebuffer device. As we can see from the output, if we load <kbd>uvesafb</kbd> without any parameters, the default resolution is 640 x 480 in 16-bit colors.</p>
<p>We can try to change the resolution with the name of the resolution as follows:</p>
<pre>
<strong>(debug-late)@android:/android # fbset vga                                       </strong><br/><strong>fbset: /etc/fb.modes: No such file or directory                                 </strong><br/><strong>fbset: unknown video mode 'vga' </strong>  
</pre>
<p>We got an error message that tells us that the resolution is not defined in the <kbd>/etc/fb.modes</kbd> file. We need to create this file to change resolutions. We can add the following resolutions in <kbd>/etc/fb.modes</kbd> as follows:</p>
<pre>
mode "640x480-60" <br/>        # D: 23.845 MHz, H: 29.844 kHz, V: 60.048 Hz  <br/>        geometry 640 480 640 9830 16  <br/>        timings 41937 80 16 13 1 63 3  <br/>        accel false  <br/>        rgba 5/11,6/5,5/0,0/0  <br/>endmode <br/><br/>mode "1024x768-60"  <br/>        # D: 64.033 MHz, H: 47.714 kHz, V: 60.018 Hz  <br/>        geometry 1024 768 1024 768 32  <br/>        timings 15617 159 52 23 1 107 3  <br/>        accel false  <br/>        rgba 8/16,8/8,8/0,8/24  <br/>endmode  
</pre>
<p>Now we can test the resolution change. If we run the following command, we can change to a higher resolution with true color:</p>
<pre>
<strong>(debug-late)@android:/android # fbset 1024x768-60</strong>  
</pre>
<p>After we load the framebuffer driver and test the configuration changes, we can test the framebuffer by drawing something on the screen. Using the <kbd>fbtest</kbd> command that we built in this section, we can run a set of framebuffer test cases. First, let's find out how many test cases <kbd>fbtest</kbd> can run:</p>
<pre>
<strong>(debug-late)@android:/android # fbtest -f /dev/fb0 -l</strong><br/><strong>Listing all tests </strong><br/><strong>test001: Draw a 16x12 checkerboard pattern </strong><br/><strong>test002: Draw a grid and some circles </strong><br/><strong>test003: Draw the 16 Linux console colors </strong><br/><strong>test004: Show the penguins </strong><br/><strong>test005: Draw the default color palette </strong><br/><strong>test006: Draw grayscale bands </strong><br/><strong>test007: DirectColor test </strong><br/><strong>test008: Draw the UV color space </strong><br/><strong>test009: Show the penguins using copy_rect </strong><br/><strong>test010: Hello world </strong><br/><strong>test011: Panning test </strong><br/><strong>test012: Filling squares </strong>  
</pre>
<p>If we run <kbd>fbtest</kbd> with the <kbd>-l</kbd> option, it prints out the list of test cases available. We can see that we have 12 test cases:</p>
<pre>
<strong>(debug-late)@android:/android # fbtest -f /dev/fb0 test002</strong>  
</pre>
<p>As an example, we can run test case 002 and we will see the following screen. Feel free to test any of the preceding test cases yourself.</p>
<div><img height="384" width="464" class=" image-border" src="img/image_11_003.png"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Initializing uvesafb in x86vbox</h1>
            

            
                
<p>The initialization of <kbd>uvesafb</kbd> in x86vbox is done in the start up script <kbd>init.sh</kbd>. If we recall the discussion on HAL initialization in <a href="acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml">Chapter 8</a>, <em>Creating Your Own Device on VirtualBox</em>, we can see the following code in <kbd>init.sh</kbd>. We discussed the initialization of graphics HAL in <a href="acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml">Chapter 8</a>, <em>Creating Your Own Device on VirtualBox</em> briefly, and we can look into the details now:</p>
<pre>
function init_uvesafb() <br/>{ <br/>    case "$PRODUCT" in <br/>        ET2002*) <br/>            UVESA_MODE=${UVESA_MODE:-1600x900} <br/>            ;; <br/>        *) <br/>            ;; <br/>    esac <br/><br/>    [ "$HWACCEL" = "0" ] &amp;&amp; bpp=16 || bpp=32 <br/>    modprobe uvesafb mode_option=${UVESA_MODE:-1024x768}-$bpp ${UVESA_OPTION:-    <br/>    mtrr=3 scroll=redraw} <br/>} <br/><br/>function init_hal_gralloc() <br/>{ <br/>    case "$(cat /proc/fb | head -1)" in <br/>        *virtiodrmfb) <br/>#            set_property ro.hardware.hwcomposer drm <br/>            ;&amp; <br/>        0*inteldrmfb|0*radeondrmfb|0*nouveaufb|0*svgadrmfb) <br/>            set_property ro.hardware.gralloc drm <br/>            set_drm_mode <br/>            ;; <br/>        "") <br/>            init_uvesafb <br/>            ;&amp; <br/>        0*) <br/>            ;; <br/>    esac <br/><br/>    [ -n "$DEBUG" ] &amp;&amp; set_property debug.egl.trace error <br/>} 
</pre>
<p>In our current setup, let's see what the content of <kbd>/proc/fb</kbd> is. We can check this from either the debug console or the adb console. Before a framebuffer device is initialized, the content of <kbd>/proc/fb</kbd> is empty. In our case, it is empty, since there is no framebuffer device available until the <kbd>init.sh</kbd> script is executed. If the output is empty, the <kbd>init.sh</kbd> script will call the <kbd>init_uvesafb</kbd> function to initialize <kbd>uvesafb</kbd>. After the framebuffer device is initialized, we can see the content of <kbd>/proc/fb</kbd> as follows:</p>
<pre>
<strong>root@x86vbox:/ # cat /proc/fb </strong><br/><strong>0 VESA VGA</strong>  
</pre>
<p>If there is a framebuffer device available before <kbd>init.sh</kbd> is called, <kbd>init_hal_gralloc</kbd> will set the <kbd>ro.hardware.gralloc</kbd> system property for DRM drivers. For the devices that <kbd>init_hal_gralloc</kbd> cannot handle, it will do nothing.</p>
<p>In <kbd>init_uvesafb</kbd>, the actual command to load <kbd>uvesafb</kbd> can be extended to the following one:</p>
<pre>
<strong># modprobe uvesafb mode_option=1024x768-32 mtrr=3 scroll=redraw</strong>  
</pre>
<p>The options of <kbd>uvesafb</kbd> are:</p>
<ul>
<li><kbd>mtrr:n</kbd>: Set up memory type range registers for the framebuffer, where <kbd>n</kbd> can be:
<ul>
<li><kbd>0</kbd>: Disabled (equivalent to the <kbd>nomtrr</kbd> option)</li>
<li><kbd>3</kbd>: Write-combining (default)</li>
</ul>
</li>
</ul>
<p style="padding-left: 90px">The memory type range registers are a set of processor supplementary capabilities control registers in Intel processors. Write-combining allows bus write transfers to be combined into a larger transfer before bursting them over the bus. This can help to improve the graphics performance.</p>
<ul>
<li><kbd>redraw</kbd>: Scroll by redrawing the affected part of the screen.</li>
<li><kbd>mode_option</kbd>: Set the resolution to a supported one.</li>
</ul>
<p>After <kbd>uvesafb</kbd> is loaded, we can find all the supported resolutions using the following command:</p>
<pre>
<strong># cat /sys/bus/platform/drivers/uvesafb/uvesafb.0/vbe_modes</strong><br/><strong>640x400-8, 0x0100 </strong><br/><strong>640x480-8, 0x0101 </strong><br/><strong>800x600-8, 0x0103 </strong><br/><strong>1024x768-8, 0x0105 </strong><br/><strong>1280x1024-8, 0x0107 </strong><br/><strong>320x200-15, 0x010d </strong><br/><strong>320x200-16, 0x010e </strong><br/><strong>320x200-24, 0x010f </strong><br/><strong>640x480-15, 0x0110 </strong><br/><strong>640x480-16, 0x0111 </strong><br/><strong>640x480-24, 0x0112 </strong><br/><strong>800x600-15, 0x0113 </strong><br/><strong>800x600-16, 0x0114 </strong><br/><strong>800x600-24, 0x0115 </strong><br/><strong>1024x768-15, 0x0116 </strong><br/><strong>1024x768-16, 0x0117 </strong><br/><strong>1024x768-24, 0x0118 </strong><br/><strong>1280x1024-15, 0x0119 </strong><br/><strong>1280x1024-16, 0x011a </strong><br/><strong>1280x1024-24, 0x011b </strong><br/><strong>320x200-32, 0x0140 </strong><br/><strong>640x400-32, 0x0141 </strong><br/><strong>640x480-32, 0x0142 </strong><br/><strong>800x600-32, 0x0143 </strong><br/><strong>1024x768-32, 0x0144 </strong><br/><strong>1280x1024-32, 0x0145 </strong><br/><strong>320x200-8, 0x0146 </strong><br/><strong>1600x1200-32, 0x0147 </strong><br/><strong>1152x864-8, 0x0148 </strong><br/><strong>1152x864-15, 0x0149 </strong><br/><strong>1152x864-16, 0x014a </strong><br/><strong>1152x864-24, 0x014b </strong><br/><strong>1152x864-32, 0x014c</strong>  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Integrating VirtualBox Guest Additions</h1>
            

            
                
<p>Up to now, we can boot x86vbox to Android. What we can do further is integrate VirtualBox Guest Additions to x86vbox.</p>
<p>VirtualBox is a virtualization environment. We can install a guest operating system as it is in VirtualBox. However, there are some limitations to working in this way. To run a guest operating system in a host environment, you may expect more things than just hardware virtualization. For example, you may find the mouse cursor to behave badly when you move between the host and guest system. You may want to share data between the hosts and guests easily, such as shared clipboard, shared folder, and so on. To meet these requirements, the host and guest need to know each other and have a way to talk to each other. In VirtualBox architecture, there is a component called <strong>Host-Guest Communication Manager</strong> (<strong>HGCM</strong>). On the host side, VirtualBox implements a service called HGCM service that can serve the requests from the guest. On the guest side, there are a few kernel drivers from VirtualBox that can be used to communicate to the host.</p>
<p>The additional features that VirtualBox provides for the host and guest integration are usually included in a package called <strong>VirtualBox Extension Pack</strong>. In the VirtualBox Extension Pack, it includes the necessary files for both the host side and the guest side. The VirtualBox Extension Pack can be download at <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>.</p>
<p>For the guest side, there are binary tools and source code for device drivers, which are included in a separate distribution package called VirtualBox Guest Additions. There are separate VirtualBox Guest Additions for Windows, Linux, and OS X. There are no Guest Additions for Android. However, since Android uses the Linux kernel, we can build the kernel drivers for Android using the source code for Linux. After we install the VirtualBox Extension Pack, we can find an image file <kbd>VBoxGuestAdditions.iso</kbd>, as follows:</p>
<pre>
<strong>$ cd /usr/share/virtualbox</strong><br/><strong>$ ls</strong><br/><strong>nls                    src                     VBoxSysInfo.sh</strong><br/><strong>rdesktop-vrdp-keymaps  VBoxCreateUSBNode.sh</strong><br/><strong>rdesktop-vrdp.tar.gz   <strong>VBoxGuestAdditions.iso</strong></strong>  
</pre>
<p>We can extract this image file and can find the following files inside VirtualBox Guest Additions:</p>
<pre>
<strong>$ ls</strong><br/><strong>deffiles    routines.sh      vboxadd-x11                       x86</strong><br/><strong>installer   vboxadd          <strong>VBoxGuestAdditions-amd64.tar.bz2</strong></strong><br/><strong>install.sh  vboxadd-service  <strong>VBoxGuestAdditions-x86.tar.bz2</strong></strong>  
</pre>
<p>There are two compressed files: <kbd>VBoxGuestAdditions-amd64.tar.bz2</kbd> and <kbd>VBoxGuestAdditions-x86.tar.bz2</kbd>. As we can see its content from the following screenshot, this is a list of folders and files of the Guest Additions for Intel x86 Linux guest:</p>
<div><img height="470" width="434" class=" image-border" src="img/image_11_004.png"/></div>
<p>VirtualBox Guest Additions</p>
<p>There are source codes for three drivers available in the Guest Additions: <kbd>vboxguest</kbd>, <kbd>vboxsf</kbd>, and <kbd>vboxvideo</kbd>:</p>
<ul>
<li><kbd>vboxguest</kbd>: This module provides the basic services in the guest operating system to communicate to the host.</li>
<li><kbd>vboxsf</kbd>: This module is a kernel driver to provide the capability to share files between host and guest.</li>
<li><kbd>vboxvideo</kbd>: This module is a video driver for the guest. With this driver, we can use graphics hardware acceleration through the host.</li>
</ul>
<p>We will build and integrate these three drivers to x86vbox.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Building VirtualBox Guest Additions</h1>
            

            
                
<p>The only dependency of the drivers in Guest Additions is the kernel source code. It is very easy to build the drivers for Android. To build the Guest Additions, you can get the source code from your VirtualBox installation, or you can get a version from my GitHub as follows:</p>
<pre>
<strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86vbox-eng</strong><br/><strong>$ cd $HOME</strong><br/><strong>$ git clone https://github.com/shugaoye/vboxguest-linux-modules</strong><br/><strong>$ cd vboxguest-linux-modules</strong><br/><strong>$ make BUILD_TARGET_ARCH=x86 KERN_DIR=$OUT/obj/KERNEL_OBJ</strong>  
</pre>
<p>After we have built the drivers successfully, we can find the driver modules as follows:</p>
<pre>
<strong>$ ls</strong><br/><strong>build_in_tmp  Makefile   vboxguest.ko  vboxsf.ko  vboxvideo.ko</strong><br/><strong>LICENSE       vboxguest  vboxsf        vboxvideo</strong>  
</pre>
<p>We can store the kernel modules in a <kbd>vbox</kbd> folder under our <kbd>x86vbox</kbd> device folder, so we can copy them to the filesystem in the build process:</p>
<pre>
<strong>$ croot</strong><br/><strong>$ cd device/generic/x86vbox</strong><br/><strong>$ ls vbox</strong><br/><strong>vboxguest.ko  vboxsf.ko  vboxvideo.ko</strong>  
</pre>
<p>After we have the loadable modules of Guest Additions, we can add them to our x86vbox device Makefile <kbd>x86vbox.mk</kbd>, as follows:</p>
<pre>
... <br/>PRODUCT_COPY_FILES += \ <br/>    device/generic/x86vbox/vbox/vboxguest.ko:system/vendor/vbox/vboxguest.ko \ <br/>    device/generic/x86vbox/vbox/vboxsf.ko:system/vendor/vbox/vboxsf.ko \ <br/>    device/generic/x86vbox/vbox/vboxvideo.ko:system/vendor/vbox/vboxvideo.ko \ <br/>... 
</pre>
<p>These three modules will be copied to the <kbd>/system/vendor/vbox</kbd> folder in the system image.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Integrating vboxsf</h1>
            

            
                
<p>With the loadable module <kbd>vboxsf.ko</kbd>, we have the capability to exchange files between the host and the guest at the runtime of the Android system. To create a shared folder between the host and guest, we need to load the <kbd>vboxsf.ko</kbd> module first.</p>
<p>To use <kbd>vboxsf.ko</kbd>, we need a tool called <kbd>mount.vboxsf</kbd>, which can be used to mount a shared folder on the host filesystem to the Android filesystem. This <kbd>mount.vboxsf</kbd> tool is part of the utilities provided by VirtualBox Guest Additions. We put it under our x86vbox device folder as follows:</p>
<pre>
<strong>$ ls mount.vboxsf/ </strong><br/><strong>Android.mk  mount.vboxsf.c  vbsfmount.h </strong>
</pre>
<p>It includes a C file and a header file. We created the following Android Makefile to build it:</p>
<pre>
LOCAL_PATH:= $(call my-dir) <br/>include $(CLEAR_VARS) <br/><br/>LOCAL_SRC_FILES:= mount.vboxsf.c <br/><br/>LOCAL_CFLAGS:=-O2 -g <br/>#LOCAL_CFLAGS+=-DLINUX <br/><br/>LOCAL_MODULE:=mount.vboxsf <br/>LOCAL_MODULE_TAGS := optional <br/><br/>include $(BUILD_EXECUTABLE) 
</pre>
<p>To include it in the system image, we also need to add it to the <kbd>x86vbox.mk</kbd> Makefile as follows:</p>
<pre>
... <br/>PRODUCT_PACKAGES += \ <br/>    mount.vboxsf \ <br/>... 
</pre>
<p>In order to load <kbd>vboxsf.ko</kbd> during the system boot up, we need to add the loading of <kbd>vboxsf.ko</kbd> to the start up script in <kbd>initrd.img</kbd>. If we recall from <a href="b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml">Chapter 6</a>, <em>Debugging the Boot Up Process Using a Customized Ramdisk</em>, we discussed the init script in the <kbd>initrd.img</kbd>. The shell script function <kbd>load_modules</kbd> is called to load most of the device drivers in the first stage boot up. We can change this script to load VirtualBox device drivers as follows:</p>
<pre>
load_modules() <br/>{ <br/>   if [ -z "$FOUND" ]; then <br/>         auto_detect <br/>   fi <br/><br/>   # 3G modules <br/>   for m in $EXTMOD; do <br/>         busybox modprobe $m <br/>   done <br/><br/>    if [ -n "$VBOX_GUEST_ADDITIONS" ]; then <br/>         echo "Loading VBOX_GUEST_ADDITIONS ..." <br/>         insmod /android/system/vendor/vbox/vboxguest.ko <br/>         insmod /android/system/vendor/vbox/vboxsf.ko <br/>         if [ ! -e /android$SDCARD ]; then <br/>               mkdir /android$SDCARD <br/>               /android/system/bin/mount.vboxsf sdcard /android$SDCARD <br/>         fi <br/>   fi <br/>} 
</pre>
<p>We defined a <kbd>VBOX_GUEST_ADDITIONS</kbd> kernel parameter, which can be used to enable the loading of VirtualBox-specific device drivers. If this kernel parameter is defined, we will load both loadable modules, <kbd>vboxguest.ko</kbd> and <kbd>vboxsf.ko</kbd>. Another kernel parameter, <kbd>SDCARD</kbd>, is also defined so that we can mount the shared folder to be an external SD card storage. The <kbd>SDCARD</kbd> kernel parameter is used by the shell script function <kbd>mount_sdcard</kbd> as well.</p>
<p>To define these two kernel parameters on the kernel command line, we need to change the PXE boot script at <kbd>$HOME/.VirtualBox/TFTP/pxelinux.cfg/default</kbd> as follows:</p>
<pre>
label 1. x86vbox (2 stages boot) <br/>menu x86vbox_initrd <br/>kernel x86vbox/kernel <br/>append ip=dhcp console=ttyS3,115200 androidboot.selinux=permissive buildvariant=eng initrd=x86vbox/initrd.img androidboot.hardware=x86vbox DEBUG=2 SRC=/android-x86vbox ROOT=/dev/sda1 VBOX_GUEST_ADDITIONS=1 SDCARD=vendor DATA=sda2 X86VBOX=1 
</pre>
<p>Pay attention to the two variables <kbd>SDCARD</kbd> and <kbd>VBOX_GUEST_ADDITIONS</kbd>. They are the two new kernel parameters that we added to support the loading of VirtualBox device drivers. To mount the shared folder, we add the following command in the script:</p>
<pre>
/android/system/bin/mount.vboxsf sdcard /android$SDCARD 
</pre>
<p>The first parameter to <kbd>mount.vboxsf</kbd> is the shared folder that we defined in the VirtualBox settings, as shown in the following screenshot:</p>
<div><img height="313" width="481" class=" image-border" src="img/image_11_005.png"/></div>
<p>With all the changes related to the shared folder, we can have a method that can be used to share data between the host and the guest very easily.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Integrating vboxvideo</h1>
            

            
                
<p>In the VirtualBox Guest Additions, there is another device driver that can be used in Android, which is <kbd>vboxvideo.ko</kbd>. This is a device driver for video hardware. It provides a much more powerful video driver compared to the uvesafb that we just discussed in this chapter.</p>
<p>The uvesafb is a standard framebuffer driver based on VESA 2.0 standard and it does not support hardware acceleration on VirtualBox. The <kbd>vboxvideo.ko</kbd> is a DRM/DRI-based video driver with hardware acceleration support.</p>
<div><strong>Direct Rendering Infrastructure</strong> (<strong>DRI</strong>) is a new architecture of the X Window system on the Linux platform to allow <em>X</em> clients to talk to the graphics hardware directly. <strong>Direct Rendering Manager</strong> (<strong>DRM</strong>) is the kernel side of the DRI architecture.</div>
<p>The Android-x86 project is the first open source project that brought Mesa/DRM to the Android platform. This is an open source OpenGL ES implementation for the supported graphics hardware. With the following components, we should be able to support hardware acceleration for OpenGL ES on Android:</p>
<ul>
<li><kbd>external_libdrm</kbd></li>
<li><kbd>external_mesa</kbd></li>
<li><kbd>external_drm_gralloc</kbd></li>
</ul>
<p>We have the DRM driver with <kbd>vboxvideo</kbd> on VirtualBox, but the related implementation still needs to add to <kbd>external_mesa</kbd> and <kbd>external_drm_gralloc</kbd> to support OpenGL ES using the host GPU.</p>
<p>Without the VirtualBox-specific implementation in <kbd>external_mesa</kbd> and <kbd>external_drm_gralloc</kbd>, we can only use the same software-based implementation in Mesa for OpenGL ES and the default Gralloc module, <kbd>gralloc.default.so</kbd>. This is why most VirtualBox-based emulator solutions such as Genymotion, Andy, or AMI DuOS are still using hardware GPU emulation, which is similar to the one we discussed in the <em>Overview of hardware GLES emulation</em> section in <a href="900f7c1a-7db8-4172-899a-8e9a167372ce.xhtml">Chapter 10</a>, <em>Enabling Graphics</em>.</p>
<p>To load <kbd>vboxvideo.ko</kbd>, we need to add these additional three lines in <kbd>load_modules</kbd>:</p>
<pre>
   if [ -n "$VBOX_VIDEO_DRIVER" ]; then <br/>       modprobe ttm <br/>       modprobe drm_kms_helper <br/>       insmod /android/system/vendor/vbox/vboxvideo.ko <br/>   fi 
</pre>
<p>The <kbd>ttm</kbd> and <kbd>drm_kms_helper</kbd> kernel modules are two kernel modules needed by <kbd>vboxvideo.ko</kbd>. We also use a <kbd>VBOX_VIDEO_DRIVER</kbd> kernel parameter to configure the loading of <kbd>vboxvideo.ko</kbd>. With this kernel parameter, we can switch between the uvesafb framebuffer and the VirtualBox framebuffer. After the system boot up, we can see the following log message. We can see that <kbd>vboxvideo</kbd> is loaded successfully:</p>
<pre>
[   25.240357] vboxguest: misc device minor 53, IRQ 20, I/O port d040, MMIO at) <br/>[   25.261044] [drm] Initialized drm 1.1.0 20060810                             <br/>[   25.290777] [drm] VRAM 08000000                                              <br/>[   25.309754] [TTM] Zone  kernel: Available graphics memory: 440884 kiB        <br/>[   25.337733] [TTM] Zone highmem: Available graphics memory: 1034776 kiB       <br/>[   25.349078] [TTM] Initializing pool allocator                                <br/>[   25.349735] fbcon: <strong>vboxdrmfb</strong> (fb0) is primary device                         <br/>[   25.360984] Console: switching to colour frame buffer device 100x37          <br/>[   25.380299] <strong>vboxvideo</strong> 0000:00:02.0: fb0: <strong>vboxdrmfb</strong> frame buffer device       <br/>[   25.388745] [drm] Initialized <strong>vboxvideo</strong> 1.0.0 20130823 for 0000:00:02.0 on m0 
</pre>
<p>From the log message, we can see that a <kbd>vboxdrmfb</kbd> framebuffer device is created by <kbd>vboxvideo</kbd>. We can check the framebuffer settings using <kbd>fbset</kbd> as we did before. We can see that the hardware acceleration is set to true for <kbd>vboxdrmfb</kbd>:</p>
<pre>
<strong>(debug-late)@android:/android # fbset                                          </strong><br/><br/><strong>mode "800x600-0" </strong><br/><strong>        # D: 0.000 MHz, H: 0.000 kHz, V: 0.000 Hz </strong><br/><strong>        geometry 800 600 800 600 32</strong><br/><strong>        timings 0 0 0 0 0 0 0</strong><br/><strong>        accel true</strong><br/><strong>        rgba 8/16,8/8,8/0,0/0</strong><br/><strong>endmode</strong>  
</pre>
<p>We can also check the output from <kbd>/proc/fb</kbd>. Since the output is <kbd>0 vboxdrmfb</kbd>, the <kbd>init_hal_gralloc</kbd> shell function in <kbd>init.sh</kbd> won't load <kbd>uvesafb</kbd>:</p>
<pre>
<strong>(debug-late)@android:/android # cat /proc/fb                                   </strong><br/><strong>0 vboxdrmfb                                      </strong>  
</pre>
<p>With this setup, we can launch x86vbox using the <kbd>vboxvideo</kbd> driver instead of <kbd>uvesafb</kbd>. As I mentioned, there is still a lot of work that needs to be done before we can fully utilize all the potential capabilities from <kbd>vboxvideo</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Building and testing images with VirtualBox Guest Additions</h1>
            

            
                
<p>To build and test the image in this chapter, we can use the <kbd>repo</kbd> tool to retrieve the source code in this chapter as follows:</p>
<p>We can get the source code from GitHub and AOSP using the following command:</p>
<pre>
<strong>$ repo init https://github.com/shugaoye/manifests -b android-7.1.1_r4_ch11_aosp</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>After we get the source code for this chapter, we can set the environment and build the system as follows:</p>
<pre>
<strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86vbox-eng</strong><br/><strong>$ make -j4</strong> 
</pre>
<p>To build <kbd>initrd.img</kbd>, we can run the following command:</p>
<pre>
<strong>$ make initrd USE_SQUASHFS=0</strong>  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we learned the start up process of graphics systems. This includes the OpenGL ES libraries, Gralloc module, and device driver. We discussed the Gralloc module in the last chapter. In this chapter, we analyzed another two components, OpenGL ES libraries and the framebuffer driver. With all this knowledge in mind, we integrated the drivers from VirtualBox Guest Additions to the x86vbox device. In the next chapter, we will start to work on another project to explore how recovery works in Android systems.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>