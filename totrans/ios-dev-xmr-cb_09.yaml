- en: Chapter 9. Interacting with Device Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the device orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the UI orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proximity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the battery information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling motion events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the gyroscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's mobile devices are equipped with very advanced hardware, be it accelerometers
    to detect motion and orientation, proximity sensors, GPS modules and, among many
    other components, sophisticated multitouch screens.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on how to use this hardware within our apps to
    provide the user with an experience that extends into the 3D world. Specifically,
    we will discuss how to adjust the user interface orientation according to the
    position of the device, how to use the proximity sensor, and how to read the battery
    information. In a series of four tasks, we will learn how to capture user touches
    on the screen and recognize gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we will create advanced apps that read the raw data from
    the accelerometer and gyroscope sensors to detect the device motion and rotation
    with detailed and simple guides.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the device orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make an app that is aware of changes in
    the device orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `DeviceOrientationApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label to the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `DeviceOrientationAppViewController` class, override the `ViewWillAppear`
    method and implement it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `ViewWillDisappear` method by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Rotate the simulator by holding the
    *Command* key on your Mac and by pressing the left or right arrow keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the simulator lacks the accelerometer hardware, it supports notifications
    for orientation changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The device orientation notification mechanism can be accessed through the `UIDevice.CurrentDevice`
    static property. To receive notifications, we first need to instruct the runtime
    to issue them. We do this with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This method turns the accelerometer on and starts generating orientation notifications.
    We then need to start observing the notifications in order to respond to changes,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each time the device orientation changes, the observer triggers the anonymous
    method. In the anonymous method, we output the orientation, which we get from
    the `Orientation` property, to the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewWillDisappear` method is the method that is being called when the
    view controller is about to hide (for example, when we push another view controller
    on a navigation controller). Inside it, we make sure that we remove the orientation
    observer, and we instruct the runtime to stop generating orientation notifications
    by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Orientation` property of the `UIDevice` class returns an enumeration of
    the `UIDeviceOrientation` type. Its possible values are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Unknown`: This means that the device orientation is unknown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Portrait`: This means that the device is in its normal portrait orientation,
    with the home button on the bottom side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PortraitUpsideDown`: This means that the device is in an upside-down portrait
    orientation, with the home button on the top side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LandscapeLeft`: This means that the device is in the landscape orientation,
    with the home button on the left side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LandscapeRight`: This means that the device is in the landscape orientation,
    with the home button on the right side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FaceUp`: This means that the device is parallel to the ground, with the screen
    facing up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FaceDown`: This means that the device is parallel to the ground, with the
    screen facing down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FaceUp` and `FaceDown` are two values that cannot be reproduced on the simulator.'
  prefs: []
  type: TYPE_NORMAL
- en: The device orientation and user interface orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The user interface—in this case, the view controller—will also rotate and adjust
    to the new screen orientation by default. It is, however, important to note that
    the device orientation and the user interface orientation can be different. For
    example, the device can be in landscape, with `UIDevice.CurrentDevice.Orientation`
    returning `LandscapeLeft` without any change to the appearance of the view controller.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adjusting the UI orientation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the accelerometer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the UI orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to rotate the user interface according to
    the screen orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `UIOrientationApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label to the view the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the `ShouldAutoRotate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `GetSupportedInterfaceOrientations` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `DidRotate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Rotate the simulator by pressing the
    *Command* key and either the left or right arrow keys. The current user interface
    orientation will be shown on the simulator's screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try rotating the simulator twice to turn the portrait orientation upside down.
    You will notice that the user interface will not rotate to this orientation and
    will remain on the landscape, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/8924OT_09_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On every view controller that is loaded, the system calls the `ShouldAutoRotate`
    method to determine whether it should rotate the specific controller. If the method
    returns `true`, then the system calls the `GetSupportedInterfaceOrientations`
    method to determine which orientations the controller is allowed to be rotated
    to. The `GetSupportedInterfaceOrientations` method implementation is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is an app-wide setting in the `Info.plist` file that takes priority
    over orientations for all view controllers. This can be accessed through the project
    options under the **iOS Application** node. The default setting is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This also explains why our user interface will not rotate when the device is
    turned upside down, despite the fact that we return `UIInterfaceOrientationMask.All`
    from the `GetSupportedInterfaceOrientations` method. To make the view controller
    support the `PortraitUpsideDown` orientation, we have to enable the **Upside Down**
    option through the orientation settings.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if we wanted our user interface to only remain in a specific orientation,
    say, a portrait, we would just return `UIInterfaceOrientationMask.Portrait` from
    the `GetSupportedInterfaceOrientations` method, making sure that at least the
    **Portrait** orientation is enabled in the project settings.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As long as the app supports an orientation, the view controller will adjust
    to it at the runtime, if we want it to. For example, if we would present a second
    view controller modally and we only want that view controller to be shown in the
    landscape orientations, we would implement its `GetSupportedInterfaceOrientations`
    method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: User interface orientation on child controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the project that we created here, if the `UIOrientationAppViewController`
    was presented as a child view controller (for example, through `UINavigationController`),
    its `ShouldAutoRotate` and `GetSupportedInterfaceOrientations` methods would not
    have been called but the ones from `UINavigationController` would have been called
    instead, returning the corresponding default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, to make sure the user interface would rotate according to
    the current controller, we would have to subclass `UINavigationController` and
    override these two methods, returning the corresponding values from the currently
    active view controller in the navigation stack, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This applies to any parent-child controller relationship, for example, if our
    parent controller was `UITabBarController` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Detecting the device orientation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the accelerometer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Navigating through different view controllers* recipe in [Chapter 3](ch03.html
    "Chapter 3. User Interface – View Controllers"), *User Interface – View Controllers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proximity sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to use the proximity sensor to disable the
    device screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `ProximitySensorApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simulator does not support the proximity sensor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, no controls are needed on the view controller. Declare an
    `NSObject` field that will hold the notification observer by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `ViewWillAppear` method of the controller and implement it according
    to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Put your finger over the proximity sensor
    (it is next to the speaker on an iPhone), and watch the **Application Output**
    pad in Xamarin Studio display the sensor state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the functionality of the proximity sensor is quite simple, it provides
    a very important feature. iOS devices have only one button on the front, which
    is the home button. Almost every user-device interaction is based on the touch-sensitive
    screen. This poses a problem on the iPhone; apart from its multiple features,
    it is also a phone. This means that it will most likely spend some time on the
    side of the user's face to make calls.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid accidental virtual buttons being tapped, the proximity sensor gets
    activated when the phone app is running in order to disable the screen when the
    device is near the user's ear or whatever is over the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the proximity sensor, set the property of the `UIDevice.CurrentDevice.ProximityMonitoringEnabled`
    property to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the device does not support the proximity sensor, this property will return
    `false` even after it has been set to `true`. So after setting it to `true`, we
    can check it to see whether the device supports the sensor by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking the support for a proximity sensor, we can add an observer to
    get notified of the sensor''s state by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `ProximityState` property returns `true` if the sensor has turned the screen
    off and `false` if it has turned it back on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proximity sensor usage is not limited to the phone call functionality. For
    example, if you are developing an app that could do some work while the device
    is in the user's pocket or purse, enabling the proximity sensor would help you
    make sure that no accidental controls are tapped. You can even save the battery
    power by just turning the screen off.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Retrieving the battery information* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the battery information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to read the charging states of the device
    and its battery usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `BatteryInfoApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label to the view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the `ViewWillAppear` method in the controller class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. After the app loads, disconnect and/or
    connect the USB cable of the device. The battery level will be displayed on the
    label and the current state will be displayed in the **Application Output** pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can retrieve the battery information through the `UIDevice` class. The first
    thing we have to do is to enable the battery monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On the simulator, which does not support battery monitoring, this property will
    return `false` even after we have set it to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then add an observer for the battery state change notifications, through
    the `UIDevice.BatteryStateDidChangeNotification` key, as indicated in the highlighted
    code in the preceding section. The battery level can be retrieved through the
    `BatteryLevel` property, which returns the charge percentage of the battery in
    the range of `0` through `1` (`0` meaning fully discharged and `1` meaning 100
    percent charged) by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can retrieve the state of the battery through the `BatteryState`
    property by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The possible values of the `BatteryState` property are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Unknown`: This means that the battery state cannot be determined or the battery
    monitoring is disabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unplugged`: This means that the device is running on the battery power'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Charging`: This means that the device battery is getting charged, and the
    USB cable is connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Full`: This means that the device battery is full and the USB cable is connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the battery state, we can get information on its power level. To
    do this, we need to add an observer for the `UIDevice.BatteryLevelDidChangeNotification`
    key, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Disabling battery monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always disable battery monitoring when not needed. The actual monitoring mechanism
    itself consumes a significant amount of battery power.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Proximity sensor* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling motion events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to intercept and respond to shake gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `MotionEventsApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label to the view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `MotionEventsAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Shake the device and watch the output
    on the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also test this app on the simulator. After it loads, navigate to **Hardware**
    | **Shake Gesture** on the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By overriding the motion methods of the `UIViewController` class, we can intercept
    and respond to the motion events sent by the system. Just overriding these methods
    is not enough, though. For a controller to receive the motion events, it needs
    to be the first responder. To make sure that this happens, we first override the
    `CanBecomeFirstResponder` property and return `true` from it, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we make sure that our controller becomes the first responder when its
    view appears, by calling the `BecomeFirstResponder` method in the `ViewDidAppear`
    override, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `ViewDidAppear` method gets called after the view has appeared on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system determines whether a motion is a shake gesture and calls the appropriate
    methods. The methods with which we can override and capture shake gestures are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MotionBegan`: This means that the shaking motion has started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MotionEnded`: This means that the shaking motion has ended'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MotionCancelled`: This means that the shaking motion has been cancelled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the device starts moving, the `MotionBegan` method is called. If the motion
    lasts for about a second or less, the `MotionEnded` method is called. If it lasts
    longer, the system classifies it as not being a shake gesture and calls the `MotionCancelled`
    method. It is advisable to override all the three methods and react accordingly
    when we want to implement the shake gestures in an app.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Motion events are only sent to objects that inherit the `UIResponder` class.
    This includes the `UIView` and `UIViewController` classes.
  prefs: []
  type: TYPE_NORMAL
- en: More information on motion events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The motion event mechanism is fairly simple. It merely detects near-instant
    device shakes, without providing any information on their direction or rate. To
    handle the motion events based on different characteristics, the accelerometer
    can be used in combination.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the accelerometer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to intercept and respond to user touches.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `TouchEventsApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label to the view the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `TouchEventsAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Click-and-drag the cursor sideways
    on the simulator's screen and watch the view's background color gradually change
    from white to black. Note that clicking with the cursor on the simulator screen
    is the equivalent of touching the device's screen with a finger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To respond to user touches, the object that acts as a touch receiver must have
    its `UserInteractionEnabled` property set to `true`. Almost all objects are enabled
    for user interaction by default, except for those whose primary usage is not intended
    for direct user interaction, for example the `UILabel` and the `UIImageView` object.
    We need to set `UserInteractionEnabled` to these objects explicitly if we want
    them to be sensitive to user touches. Apart from this, the objects that can handle
    touch events must inherit from the `UIResponder` class. Note that although the
    `UIViewController` class inherits from `UIResponder` and can therefore capture
    touch events, it does not have a `UserInteractionEnabled` property, and it is
    its main property of `UIView`, which controls the delivery of touch events. What
    this means is that if you override the touch methods of `UIViewController` but
    its view's `UserInteractionEnabled` property is set to `false`, these methods
    will not respond to user touches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods responsible of handling the touch events are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TouchesBegan`: It is called when the user has touched the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchesMoved`: It is called when the user is dragging his/her finger on the
    screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchesEnded`: It is called when the user has lifted his/her finger from the
    screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchesCancelled`: It is called when the touch event has been cancelled by
    a system event, for example, when a notification alert is displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full project can be found in the downloadable source code. The `TouchesMoved`
    method implementation has been explained here.
  prefs: []
  type: TYPE_NORMAL
- en: Every touch method has two parameters. The first parameter is of the `NSSet`
    type and contains the `UITouch` objects. The `NSSet` class represents a collection
    of objects, while the `UITouch` class holds the information for each user touch.
    The second parameter is of the `UIEvent` type and holds the information of the
    actual event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the `UITouch` object related to the actual touch through the
    `NSSet.AnyObject` return value by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns an object of the `NSObject` type, which we convert to `UITouch`.
    We can get the previous and current locations of the touch through the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Both of the preceding methods return a `PointF` struct, which contains the location
    of the touch in the receiver's coordinate system. After receiving the location
    of the touch, we adjust the background color accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example is based on single user touches. To enable a view to respond to
    multiple touches, we have to set its `MultipleTouchEnabled` property to `true`.
    We can then get all the `UITouch` objects in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Getting the tap count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can determine the number of consecutive user taps through the `UITouch.TapCount`
    property inside the `ToucheEnded` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Handling motion events* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Recognizing gestures* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Custom gestures* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to recognize touch gestures and respond
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `GestureApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label to the view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method in the `GestureAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Hold down the *option* key and click-and-drag
    the mouse to perform the equivalent of a pinch on the simulator screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Holding down the Option key and dragging with the mouse cursor on the simulator
    is the equivalent of touching a device''s screen with two fingers, as shown in
    the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/8924OT_09_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the iOS Version 3.2 was released along with the iPad, Apple introduced the
    `UIGestureRecognizer` class and its derivatives. The gesture recognizers make
    use of the multitouch screens on iOS devices. Gestures are basically touch combinations
    that can be performed for specific actions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, pinching on a fullscreen image in the native *Photos* app will
    zoom out. The action of pinching is the gesture that the user performs, while
    the gesture recognizer is responsible for recognizing and delivering the gesture
    event to its receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create a `UIPinchGestureRecognizer` instance, which will
    recognize the pinches performed on the screen. Its instance is created with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The constructor that initializes the instance takes one parameter, which is
    of the `Action<UIPinchGestureRecognizer>` type and represents the method that
    will be called when the recognizer receives a gesture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the method, we read the `State` property of the gesture recognizer object
    and respond accordingly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The state of each gesture recognizer is represented by an enumeration of the
    `UIGestureRecognizerState` type. Its possible values are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Possible`: This indicates that the gesture has not been recognized yet. This
    is the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Began`: This indicates that the gesture has started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Changed`: This indicates that the gesture has changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ended`: This indicates that the gesture has ended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cancelled`: This indicates that the gesture has been canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failed`: This indicates that the gesture cannot be recognized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Recognized`: This indicates that the gesture has been recognized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of gesture recognizers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of gesture recognizers is that they save developers the time to
    create their own gesture recognition mechanisms through the touch events. Furthermore,
    they are based on the gestures that users are accustomed to using on iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Handling touch events* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Custom gestures* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a custom gesture recognizer to create
    our own gesture response mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `CustomGestureApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label to the view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following nested class in the `CustomGestureAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize and add the gesture recognizer in the `ViewDidLoad` method as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Click-and-drag on the simulator's
    screen towards the lower-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a gesture recognizer, we need to declare a class that inherits from
    the `UIGestureRecognizer` class. In this example, we are creating a gesture that
    will be recognized by dragging the finger on the screen towards a 50 x 50 point
    area in the lower-left corner of the screen. The following line of code shows
    the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `UIGestureRecognizer` class contains the same touch methods that we use
    to intercept touches in views. We also have access to the view it was added to
    through its `View` property. Inside the `TouchesBegan` method, we determine the
    initial touch location. If it is outside the lower-left portion of the view, we
    set the `State` property to `Began`. If it is inside the lower-left portion, we
    set the `State` property to `Failed` so that the callback will not be called.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `TouchesEnded` method, we consider the gesture as `Ended` if the
    touch's location was inside the lower-left portion of the view. If it was not,
    the gesture recognition is considered as `Failed`.
  prefs: []
  type: TYPE_NORMAL
- en: The `TouchesMoved` method is where the `Changed` state will be set. For this
    simple gesture recognizer that we are creating, no other logic is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `UIGestureRecognizer` class does not have a constructor that accepts
    an `Action<T>` object for the gesture handler, we initialize it with the default
    constructor and use the `AddTarget` method for this purpose by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference in this case is that the parameter is of the `Action<NSObject>`
    type, which we can cast to our own custom type, as shown in the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a simple gesture recognizer that depends on a single touch. With the
    information provided in the touch methods, we can create more complex gestures
    that will support multiple touches.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of custom gesture recognizers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some views that inherit from the `UIView` class, which, according
    to the Apple developer documentation, should not be subclassed. The `MKMapView`
    class represents one of these views that is used to display the maps. This poses
    a problem if we want to intercept the touch events from these views. Although
    we could use another view over it and intercept that view's touch events, it is
    quite complex (and error prone) to do so. A more simple approach is to create
    a simple custom gesture recognizer and add it to the view that we cannot subclass.
    This way, we can intercept its touches without having to subclass it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Recognizing gestures* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Handling touch events* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to receive the accelerometer events to create
    an app that is aware of the device movement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `AccelerometerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simulator does not support the accelerometer hardware. The project in this
    example will work correctly on a device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two buttons and a label on the view of the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `ViewDidLoad` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Tap the **Start accelerometer** button
    and watch the values get displayed on the label while moving or shaking the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIAccelerometer` class provides access to the accelerometer hardware through
    its `SharedAccelerometer` static property. To activate it, all we need to do is
    to assign a handler to its `Acceleration` event by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the handler, we receive the accelerometer values through the `UIAccelerometerEventArgs.Acceleration`
    property. The property returns an object of the `UIAcceleration` type, which contains
    the accelerometer amount in three properties: `X`, `Y`, and `Z`. These properties
    represent the motion in the *x*-, *y*-, and *z*-axis. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of these values measure the amount of G-force by which the device moved
    on each axis. For example, if `X` has a value of `1`, the device is moving on
    the *x* axis to the right with an acceleration of 1G. If `X` has a value of `-1`,
    the device is moving on the *x* axis to the left with an acceleration of 1G. When
    the device is placed on a table with its back facing the floor and is not moving,
    the normal values of the acceleration should be close or equal to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`X`: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Y`: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z`: `-1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the device is not moving, Z will be `-1` because the device measures
    the earth's gravity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the interval by which the accelerometer will issue the acceleration
    events, by setting its `UpdateInterval` property by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The property accepts a number of type `double`, which represents the interval
    by which the accelerometer will issue its acceleration events in seconds. Care
    must be taken when setting the update interval because the more events the accelerometer
    has to issue for a specific period of time, the more battery power it consumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop using the accelerometer, all we need to do is unhook the handler from
    the `Acceleration` event by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIAcceleration` class contains another useful property, named `Time`. It
    is a `double` that represents the relative time on which the acceleration event
    occurred. It is relative to the CPU time, and it is not suggested that you use
    this value to calculate the exact timestamp of the event.
  prefs: []
  type: TYPE_NORMAL
- en: Consideration when using the accelerometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the iPhone's accelerometer is a very accurate and sensitive sensor,
    it should not be used for precise measurements. Also, the results it produces
    may vary among different iOS devices, even if they're of the same model.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the gyroscope* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the gyroscope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the device's built-in gyroscope.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Xamarin Studio and name it `GyroscopeApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simulator does not support the gyroscope hardware. Also, only newer devices
    contain a gyroscope. If this app is executed on a device without a gyroscope or
    on the simulator, no error will occur but no data will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two buttons and a label to the view the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `MonoTouch.CoreMotion` namespace in the `GyroscopeAppViewController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following private field in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ViewDidLoad` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Tap the **Start gyroscope** button and
    rotate the device in all axes. Watch the values get displayed in the **Application
    Output** pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The gyroscope is a mechanism that measures orientation. Newer iOS devices support
    the gyroscope hardware, along with the accelerometer, to give even more accurate
    measurements of the device motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MonoTouch.CoreMotion` namespace wraps the objects contained in the native
    CoreMotion framework. The process of using the gyroscope hardware in code is similar
    to the one used for the accelerometer. The first difference is that there is no
    single object for the gyroscope in the `UIApplication` class. So, we need to create
    an instance of the `CMMotionManager` class as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like how we use the accelerometer, we can set the interval by which we
    will receive the gyroscope events in seconds by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To start receiving the gyroscope events, we call the object''s `StartGyroUpdates`
    method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This method is overloaded; the first overload is parameterless and when called,
    the values of the gyroscopic measurements are set to the `GyroData` property.
    Using this overload is quite simple and easy, but no events are triggered here,
    and we have to provide a mechanism to read the measurements from the property.
  prefs: []
  type: TYPE_NORMAL
- en: The second overload, which is used in this example, accepts two parameters.
    The first parameter is the `NSOperationQueue` parameter on which the updates will
    occur, and the second parameter is the handler that will be executed when an update
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `NSOperationQueue` class represents an iOS mechanism to manage the `NSOperation`
    objects' execution. We access the runtime's main operation queue through the static
    `NSOperationQueue.MainQueue` property. Basically, this way, we instruct the runtime
    to manage the delivery of the handler in a more effective manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter is a delegate of the `CMGyroHandler` type. Its signature,
    represented by the method we created, is similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMGyroData` object contains the actual measurement values received from
    the gyroscope through its `RotationRate` property. The following code outputs
    the data from the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The rotation rate is reflected on the *x*, *y*, and *z* axis, represented by
    the corresponding `X`, `Y`, and `Z` properties. Each value is the amount of the
    rotation angle per second, which occurred on that axis, in radians.
  prefs: []
  type: TYPE_NORMAL
- en: Although it might seem a bit complicated at first, it is actually quite simple.
    For example, a value of 0.5 in the *z* axis means that the device rotated with
    a rate of 0.5 radians/sec to the left. A value of -0.5 in the *z*-axis means that
    the device rotated with a rate of 0.5 radians/sec to the right. The pattern to
    determine the rotation direction is based on the right-hand rule.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want your app to be available only for devices that support the gyroscope,
    add the `UIRequiredDeviceCapabilities` key in your project's `Info.plist` file
    with the `gyroscope` value. If your app's functionality is based fully on the
    gyroscope, adding this key must be considered essential to avoid the app being
    downloaded by users with older devices, ending up with an app that does not work.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the availability of the gyroscope hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To determine whether the device the app is running on supports the gyroscope
    hardware, check the value of the `GyroAvailable` property of the `CMMotionManager`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Converting radians to degrees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A radian is an angle measurement unit. To convert an angle measurement from
    radians to degrees, consider the following helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the accelerometer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
