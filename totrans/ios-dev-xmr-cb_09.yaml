- en: Chapter 9. Interacting with Device Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。与设备硬件交互
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Detecting the device orientation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测设备方向
- en: Adjusting the UI orientation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整UI方向
- en: The proximity sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离传感器
- en: Retrieving the battery information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取电池信息
- en: Handling motion events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理运动事件
- en: Handling touch events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理触摸事件
- en: Recognizing gestures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别手势
- en: Custom gestures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义手势
- en: Using the accelerometer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: Using the gyroscope
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用陀螺仪
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Today's mobile devices are equipped with very advanced hardware, be it accelerometers
    to detect motion and orientation, proximity sensors, GPS modules and, among many
    other components, sophisticated multitouch screens.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的移动设备配备了非常先进的硬件，无论是用于检测运动和方向的加速度计，还是距离传感器、GPS模块，以及许多其他组件中的复杂多点触控屏幕。
- en: In this chapter, we will focus on how to use this hardware within our apps to
    provide the user with an experience that extends into the 3D world. Specifically,
    we will discuss how to adjust the user interface orientation according to the
    position of the device, how to use the proximity sensor, and how to read the battery
    information. In a series of four tasks, we will learn how to capture user touches
    on the screen and recognize gestures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注如何在我们的应用程序中使用这项硬件，为用户提供一个扩展到3D世界的体验。具体来说，我们将讨论如何根据设备的位置调整用户界面方向，如何使用距离传感器，以及如何读取电池信息。在一系列四个任务中，我们将学习如何捕捉屏幕上的用户触摸并识别手势。
- en: Last but not least, we will create advanced apps that read the raw data from
    the accelerometer and gyroscope sensors to detect the device motion and rotation
    with detailed and simple guides.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将创建高级应用程序，读取加速度计和陀螺仪传感器的原始数据，以详细和简单的指南检测设备运动和旋转。
- en: Detecting the device orientation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测设备方向
- en: In this recipe, we will learn how to make an app that is aware of changes in
    the device orientation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何创建一个能够感知设备方向变化的程序。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `DeviceOrientationApp`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`DeviceOrientationApp`。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a label to the controller.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制器添加一个标签。
- en: 'In the `DeviceOrientationAppViewController` class, override the `ViewWillAppear`
    method and implement it with the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DeviceOrientationAppViewController`类中，重写`ViewWillAppear`方法并使用以下代码实现：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Override the `ViewWillDisappear` method by using the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码重写`ViewWillDisappear`方法：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile and run the app on the simulator. Rotate the simulator by holding the
    *Command* key on your Mac and by pressing the left or right arrow keys.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。通过在Mac上按住*Command*键并按左右箭头键来旋转模拟器。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although the simulator lacks the accelerometer hardware, it supports notifications
    for orientation changes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模拟器缺少加速度计硬件，但它支持方向变化的通知。
- en: 'The device orientation notification mechanism can be accessed through the `UIDevice.CurrentDevice`
    static property. To receive notifications, we first need to instruct the runtime
    to issue them. We do this with the following method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设备方向通知机制可以通过`UIDevice.CurrentDevice`静态属性访问。为了接收通知，我们首先需要指示运行时发出它们。我们使用以下方法来完成：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This method turns the accelerometer on and starts generating orientation notifications.
    We then need to start observing the notifications in order to respond to changes,
    as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法打开加速度计并开始生成方向通知。然后我们需要开始观察通知，以便对变化做出响应，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each time the device orientation changes, the observer triggers the anonymous
    method. In the anonymous method, we output the orientation, which we get from
    the `Orientation` property, to the label.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每当设备方向发生变化时，观察者都会触发匿名方法。在匿名方法中，我们将从`Orientation`属性获取的方向输出到标签。
- en: 'The `ViewWillDisappear` method is the method that is being called when the
    view controller is about to hide (for example, when we push another view controller
    on a navigation controller). Inside it, we make sure that we remove the orientation
    observer, and we instruct the runtime to stop generating orientation notifications
    by using the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewWillDisappear`方法是在视图控制器即将隐藏时被调用的方法（例如，当我们在一个导航控制器上推送另一个视图控制器时）。在其内部，我们确保移除方向观察者，并使用以下代码指示运行时停止生成方向通知：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `Orientation` property of the `UIDevice` class returns an enumeration of
    the `UIDeviceOrientation` type. Its possible values are the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIDevice`类的`Orientation`属性返回`UIDeviceOrientation`类型的枚举。其可能的值如下：'
- en: '`Unknown`: This means that the device orientation is unknown'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unknown`: 这表示设备方向未知'
- en: '`Portrait`: This means that the device is in its normal portrait orientation,
    with the home button on the bottom side'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Portrait`: 这表示设备处于正常的纵向方向，主页按钮在底部'
- en: '`PortraitUpsideDown`: This means that the device is in an upside-down portrait
    orientation, with the home button on the top side'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PortraitUpsideDown`: 这表示设备处于颠倒的纵向方向，主页按钮在顶部'
- en: '`LandscapeLeft`: This means that the device is in the landscape orientation,
    with the home button on the left side'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LandscapeLeft`: 这表示设备处于横屏方向，主页按钮在左侧'
- en: '`LandscapeRight`: This means that the device is in the landscape orientation,
    with the home button on the right side'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LandscapeRight`: 这表示设备处于横屏方向，主页按钮在右侧'
- en: '`FaceUp`: This means that the device is parallel to the ground, with the screen
    facing up'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FaceUp`: 这表示设备与地面平行，屏幕朝上'
- en: '`FaceDown`: This means that the device is parallel to the ground, with the
    screen facing down'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FaceDown`: 这表示设备与地面平行，屏幕朝下'
- en: '`FaceUp` and `FaceDown` are two values that cannot be reproduced on the simulator.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`FaceUp`和`FaceDown`是模拟器上无法复制的两个值。'
- en: The device orientation and user interface orientation
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备方向和用户界面方向
- en: The user interface—in this case, the view controller—will also rotate and adjust
    to the new screen orientation by default. It is, however, important to note that
    the device orientation and the user interface orientation can be different. For
    example, the device can be in landscape, with `UIDevice.CurrentDevice.Orientation`
    returning `LandscapeLeft` without any change to the appearance of the view controller.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面——在这种情况下，视图控制器——将默认旋转并调整到新的屏幕方向。然而，需要注意的是，设备方向和用户界面方向可能不同。例如，设备可以是横屏，`UIDevice.CurrentDevice.Orientation`返回`LandscapeLeft`，而视图控制器的外观没有任何变化。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adjusting the UI orientation* recipe
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整UI方向*配方'
- en: The *Using the accelerometer* recipe
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计*配方'
- en: Adjusting the UI orientation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整UI方向
- en: In this chapter, we will learn how to rotate the user interface according to
    the screen orientation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何根据屏幕方向旋转用户界面。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `UIOrientationApp`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`UIOrientationApp`。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a label to the view the controller.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图控制器中添加一个标签。
- en: 'Override the `ShouldAutoRotate` method:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`ShouldAutoRotate`方法：
- en: '[PRE5]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Override the `GetSupportedInterfaceOrientations` method:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`GetSupportedInterfaceOrientations`方法：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the `DidRotate` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`DidRotate`方法：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile and run the app on the simulator. Rotate the simulator by pressing the
    *Command* key and either the left or right arrow keys. The current user interface
    orientation will be shown on the simulator's screen.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。通过按*Command*键和左箭头键或右箭头键旋转模拟器。当前的用户界面方向将在模拟器屏幕上显示。
- en: 'Try rotating the simulator twice to turn the portrait orientation upside down.
    You will notice that the user interface will not rotate to this orientation and
    will remain on the landscape, as shown in the following screenshot:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试旋转模拟器两次，将纵向方向颠倒。你会注意到用户界面不会旋转到这个方向，而将保持在横屏，如下面的截图所示：
- en: '![How to do it...](img/8924OT_09_01.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/8924OT_09_01.jpg)'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'On every view controller that is loaded, the system calls the `ShouldAutoRotate`
    method to determine whether it should rotate the specific controller. If the method
    returns `true`, then the system calls the `GetSupportedInterfaceOrientations`
    method to determine which orientations the controller is allowed to be rotated
    to. The `GetSupportedInterfaceOrientations` method implementation is shown in
    the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载的每个视图控制器上，系统会调用`ShouldAutoRotate`方法以确定是否应该旋转特定的控制器。如果该方法返回`true`，则系统会调用`GetSupportedInterfaceOrientations`方法以确定控制器可以旋转到哪些方向。以下代码显示了`GetSupportedInterfaceOrientations`方法的实现：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, there is an app-wide setting in the `Info.plist` file that takes priority
    over orientations for all view controllers. This can be accessed through the project
    options under the **iOS Application** node. The default setting is shown in the
    following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`Info.plist`文件中有一个全局设置，它对所有视图控制器的方向设置具有优先权。这可以通过项目选项下的**iOS应用程序**节点访问。默认设置如下截图所示：
- en: '![How it works...](img/8924OT_09_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8924OT_09_02.jpg)'
- en: This also explains why our user interface will not rotate when the device is
    turned upside down, despite the fact that we return `UIInterfaceOrientationMask.All`
    from the `GetSupportedInterfaceOrientations` method. To make the view controller
    support the `PortraitUpsideDown` orientation, we have to enable the **Upside Down**
    option through the orientation settings.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么当设备倒置时，尽管我们从`GetSupportedInterfaceOrientations`方法返回`UIInterfaceOrientationMask.All`，我们的用户界面仍然不会旋转。为了使视图控制器支持`PortraitUpsideDown`方向，我们必须通过方向设置启用**倒置**选项。
- en: Similarly, if we wanted our user interface to only remain in a specific orientation,
    say, a portrait, we would just return `UIInterfaceOrientationMask.Portrait` from
    the `GetSupportedInterfaceOrientations` method, making sure that at least the
    **Portrait** orientation is enabled in the project settings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们想让用户界面只保持特定的方向，比如横屏，我们只需从`GetSupportedInterfaceOrientations`方法返回`UIInterfaceOrientationMask.Portrait`，确保在项目设置中至少启用了**横屏**方向。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'As long as the app supports an orientation, the view controller will adjust
    to it at the runtime, if we want it to. For example, if we would present a second
    view controller modally and we only want that view controller to be shown in the
    landscape orientations, we would implement its `GetSupportedInterfaceOrientations`
    method as shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只要应用支持一个方向，视图控制器就会在运行时调整到它，如果我们想要它这样做的话。例如，如果我们以模态方式呈现第二个视图控制器，并且我们只想在横屏方向显示该视图控制器，我们就会实现它的`GetSupportedInterfaceOrientations`方法，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: User interface orientation on child controllers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子控制器用户界面方向
- en: In the project that we created here, if the `UIOrientationAppViewController`
    was presented as a child view controller (for example, through `UINavigationController`),
    its `ShouldAutoRotate` and `GetSupportedInterfaceOrientations` methods would not
    have been called but the ones from `UINavigationController` would have been called
    instead, returning the corresponding default values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在这里创建的项目中，如果`UIOrientationAppViewController`被呈现为一个子视图控制器（例如，通过`UINavigationController`），它的`ShouldAutoRotate`和`GetSupportedInterfaceOrientations`方法将不会被调用，而是会调用`UINavigationController`的方法，并返回相应的默认值。
- en: 'In this situation, to make sure the user interface would rotate according to
    the current controller, we would have to subclass `UINavigationController` and
    override these two methods, returning the corresponding values from the currently
    active view controller in the navigation stack, as shown in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为了确保用户界面会根据当前控制器旋转，我们不得不子类化`UINavigationController`并重写这两个方法，从导航堆栈中当前活动的视图控制器返回相应的值，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This applies to any parent-child controller relationship, for example, if our
    parent controller was `UITabBarController` and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于任何父子控制器关系，例如，如果我们的父控制器是`UITabBarController`等等。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Detecting the device orientation* recipe
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测设备方向*菜谱'
- en: The *Using the accelerometer* recipe
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计*菜谱'
- en: The *Navigating through different view controllers* recipe in [Chapter 3](ch03.html
    "Chapter 3. User Interface – View Controllers"), *User Interface – View Controllers*
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。用户界面 – 视图控制器")的*通过不同的视图控制器导航*菜谱中，*用户界面 – 视图控制器*
- en: Proximity sensor
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近传感器
- en: In this recipe, we will discuss how to use the proximity sensor to disable the
    device screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何使用接近传感器来禁用设备屏幕。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ProximitySensorApp`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`ProximitySensorApp`。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simulator does not support the proximity sensor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器不支持接近传感器。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'For this project, no controls are needed on the view controller. Declare an
    `NSObject` field that will hold the notification observer by using the following
    command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个项目，在视图控制器上不需要任何控件。使用以下命令声明一个`NSObject`字段，该字段将用于保存通知观察者：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Override the `ViewWillAppear` method of the controller and implement it according
    to the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖控制器中的`ViewWillAppear`方法并按照以下代码实现：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compile and run the app on the device. Put your finger over the proximity sensor
    (it is next to the speaker on an iPhone), and watch the **Application Output**
    pad in Xamarin Studio display the sensor state.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。将手指放在接近传感器上（在iPhone上，它位于扬声器旁边），并观察Xamarin Studio中的**应用程序输出**面板显示的传感器状态。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although the functionality of the proximity sensor is quite simple, it provides
    a very important feature. iOS devices have only one button on the front, which
    is the home button. Almost every user-device interaction is based on the touch-sensitive
    screen. This poses a problem on the iPhone; apart from its multiple features,
    it is also a phone. This means that it will most likely spend some time on the
    side of the user's face to make calls.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管接近传感器的功能相当简单，但它提供了一个非常重要的特性。iOS设备正面只有一个按钮，即主按钮。几乎所有的用户与设备的交互都是基于触摸屏。这在iPhone上造成了一个问题；除了其多种功能外，它还是一部电话。这意味着它很可能会在用户的脸部侧面花费一些时间来进行通话。
- en: To avoid accidental virtual buttons being tapped, the proximity sensor gets
    activated when the phone app is running in order to disable the screen when the
    device is near the user's ear or whatever is over the sensor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外点击虚拟按钮，当手机应用运行时，接近传感器会被激活以禁用屏幕，当设备靠近用户的耳朵或传感器上方的任何物体时。
- en: 'To enable the proximity sensor, set the property of the `UIDevice.CurrentDevice.ProximityMonitoringEnabled`
    property to `true`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用接近传感器，将`UIDevice.CurrentDevice.ProximityMonitoringEnabled`属性的值设置为`true`：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the device does not support the proximity sensor, this property will return
    `false` even after it has been set to `true`. So after setting it to `true`, we
    can check it to see whether the device supports the sensor by using the following
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备不支持接近传感器，即使将其设置为`true`，此属性也会返回`false`。因此，在将其设置为`true`之后，我们可以通过以下代码检查设备是否支持传感器：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After checking the support for a proximity sensor, we can add an observer to
    get notified of the sensor''s state by using the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了接近传感器的支持后，我们可以添加一个观察者，通过以下代码来接收传感器状态的通知：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `ProximityState` property returns `true` if the sensor has turned the screen
    off and `false` if it has turned it back on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProximityState`属性返回`true`表示传感器已关闭屏幕，返回`false`表示它已重新打开。'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The proximity sensor usage is not limited to the phone call functionality. For
    example, if you are developing an app that could do some work while the device
    is in the user's pocket or purse, enabling the proximity sensor would help you
    make sure that no accidental controls are tapped. You can even save the battery
    power by just turning the screen off.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接近传感器的使用不仅限于电话功能。例如，如果你正在开发一个在设备放在用户的口袋或钱包中时可以执行某些工作的应用程序，启用接近传感器可以帮助你确保不会意外点击控制按钮。你甚至可以通过关闭屏幕来节省电池电量。
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Retrieving the battery information* recipe
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取电池信息*配方'
- en: Retrieving the battery information
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取电池信息
- en: In this recipe, we will learn how to read the charging states of the device
    and its battery usage.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何读取设备的充电状态及其电池使用情况。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `BatteryInfoApp`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`BatteryInfoApp`。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a label to the view of the controller.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加一个标签。
- en: 'Override the `ViewWillAppear` method in the controller class as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式覆盖控制器类中的`ViewWillAppear`方法：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Compile and run the app on the device. After the app loads, disconnect and/or
    connect the USB cable of the device. The battery level will be displayed on the
    label and the current state will be displayed in the **Application Output** pad.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。在应用程序加载后，断开并/或连接设备的USB线缆。电池电量将在标签上显示，当前状态将在**应用程序输出**面板中显示。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can retrieve the battery information through the `UIDevice` class. The first
    thing we have to do is to enable the battery monitoring:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`UIDevice`类来检索电池信息。我们必须做的第一件事是启用电池监控：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On the simulator, which does not support battery monitoring, this property will
    return `false` even after we have set it to `true`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持电池监控的模拟器上，即使我们将它设置为`true`，此属性也会返回`false`。
- en: 'We can then add an observer for the battery state change notifications, through
    the `UIDevice.BatteryStateDidChangeNotification` key, as indicated in the highlighted
    code in the preceding section. The battery level can be retrieved through the
    `BatteryLevel` property, which returns the charge percentage of the battery in
    the range of `0` through `1` (`0` meaning fully discharged and `1` meaning 100
    percent charged) by using the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在前面章节中突出显示的代码中通过`UIDevice.BatteryStateDidChangeNotification`键添加一个观察者，来为电池状态变化通知添加观察者。电池电平可以通过`BatteryLevel`属性检索，该属性返回电池的充电百分比，范围在`0`到`1`之间（`0`表示完全放电，`1`表示100%充电），如下面的代码所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we can retrieve the state of the battery through the `BatteryState`
    property by using the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过以下代码使用`BatteryState`属性检索电池的状态：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The possible values of the `BatteryState` property are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatteryState`属性的可能的值如下：'
- en: '`Unknown`: This means that the battery state cannot be determined or the battery
    monitoring is disabled'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unknown`: 这表示无法确定电池状态或电池监控已禁用'
- en: '`Unplugged`: This means that the device is running on the battery power'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unplugged`: 这表示设备正在使用电池供电'
- en: '`Charging`: This means that the device battery is getting charged, and the
    USB cable is connected'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Charging`: 这表示设备电池正在充电，并且USB线已连接'
- en: '`Full`: This means that the device battery is full and the USB cable is connected'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Full`: 这表示设备电池已满，并且USB线已连接'
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Apart from the battery state, we can get information on its power level. To
    do this, we need to add an observer for the `UIDevice.BatteryLevelDidChangeNotification`
    key, as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了电池状态外，我们还可以获取其电量信息。为此，我们需要为`UIDevice.BatteryLevelDidChangeNotification`键添加一个观察者，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Disabling battery monitoring
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用电池监控
- en: Always disable battery monitoring when not needed. The actual monitoring mechanism
    itself consumes a significant amount of battery power.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要时始终禁用电池监控。实际的监控机制本身消耗了大量的电池电量。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Proximity sensor* recipe
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接近传感器* 菜谱'
- en: Handling motion events
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理运动事件
- en: In this recipe, we will learn how to intercept and respond to shake gestures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何拦截和响应摇动手势。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `MotionEventsApp`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`MotionEventsApp`。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a label to the view of the controller.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加一个标签。
- en: 'Enter the following code in the `MotionEventsAppViewController` class:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MotionEventsAppViewController`类中输入以下代码：
- en: '[PRE21]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile and run the app on the device. Shake the device and watch the output
    on the label.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。摇动设备并观察标签上的输出。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also test this app on the simulator. After it loads, navigate to **Hardware**
    | **Shake Gesture** on the menu bar.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在模拟器上测试此应用程序。加载后，在菜单栏上导航到**硬件** | **摇动手势**。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By overriding the motion methods of the `UIViewController` class, we can intercept
    and respond to the motion events sent by the system. Just overriding these methods
    is not enough, though. For a controller to receive the motion events, it needs
    to be the first responder. To make sure that this happens, we first override the
    `CanBecomeFirstResponder` property and return `true` from it, as shown in the
    following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`UIViewController`类的运动方法，我们可以拦截和响应系统发送的运动事件。然而，仅仅重写这些方法是不够的。为了控制器能够接收运动事件，它需要成为第一个响应者。为了确保这一点，我们首先重写`CanBecomeFirstResponder`属性，并从其中返回`true`，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we make sure that our controller becomes the first responder when its
    view appears, by calling the `BecomeFirstResponder` method in the `ViewDidAppear`
    override, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们确保当视图出现时，我们的控制器成为第一个响应者，通过在`ViewDidAppear`重写方法中调用`BecomeFirstResponder`方法，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `ViewDidAppear` method gets called after the view has appeared on the screen.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewDidAppear`方法在视图出现在屏幕上后被调用。'
- en: 'The system determines whether a motion is a shake gesture and calls the appropriate
    methods. The methods with which we can override and capture shake gestures are
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 系统确定一个动作是否是摇动手势，并调用相应的方法。我们可以重写和捕获摇动手势的方法如下：
- en: '`MotionBegan`: This means that the shaking motion has started'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MotionBegan`: 这表示摇动动作已经开始'
- en: '`MotionEnded`: This means that the shaking motion has ended'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MotionEnded`：这意味着震动动作已经结束'
- en: '`MotionCancelled`: This means that the shaking motion has been cancelled'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MotionCancelled`：这意味着震动动作已被取消'
- en: When the device starts moving, the `MotionBegan` method is called. If the motion
    lasts for about a second or less, the `MotionEnded` method is called. If it lasts
    longer, the system classifies it as not being a shake gesture and calls the `MotionCancelled`
    method. It is advisable to override all the three methods and react accordingly
    when we want to implement the shake gestures in an app.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备开始移动时，会调用`MotionBegan`方法。如果运动持续大约一秒或更短，则调用`MotionEnded`方法。如果它持续更长，系统将其分类为不是震动手势，并调用`MotionCancelled`方法。当我们想在应用程序中实现震动手势时，建议重写所有这三个方法并相应地做出反应。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Motion events are only sent to objects that inherit the `UIResponder` class.
    This includes the `UIView` and `UIViewController` classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只有继承自`UIResponder`类的对象才会发送运动事件。这包括`UIView`和`UIViewController`类。
- en: More information on motion events
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于运动事件的信息
- en: The motion event mechanism is fairly simple. It merely detects near-instant
    device shakes, without providing any information on their direction or rate. To
    handle the motion events based on different characteristics, the accelerometer
    can be used in combination.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运动事件机制相当简单。它仅仅检测近瞬间的设备震动，而不提供有关其方向或速率的任何信息。为了根据不同的特性处理运动事件，可以将加速度计与组合使用。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the accelerometer* recipe
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计*菜谱'
- en: Handling touch events
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理触摸事件
- en: In this recipe, we will learn how to intercept and respond to user touches.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何拦截和响应用户触摸。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `TouchEventsApp`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`TouchEventsApp`。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a label to the view the controller.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个标签添加到控制器视图。
- en: 'Enter the following code in the `TouchEventsAppViewController` class:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TouchEventsAppViewController`类中输入以下代码：
- en: '[PRE24]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compile and run the app on the simulator. Click-and-drag the cursor sideways
    on the simulator's screen and watch the view's background color gradually change
    from white to black. Note that clicking with the cursor on the simulator screen
    is the equivalent of touching the device's screen with a finger.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在模拟器的屏幕上点击并拖动光标，观察视图的背景颜色逐渐从白色变为黑色。请注意，在模拟器屏幕上用光标点击相当于用手指触摸设备屏幕。
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To respond to user touches, the object that acts as a touch receiver must have
    its `UserInteractionEnabled` property set to `true`. Almost all objects are enabled
    for user interaction by default, except for those whose primary usage is not intended
    for direct user interaction, for example the `UILabel` and the `UIImageView` object.
    We need to set `UserInteractionEnabled` to these objects explicitly if we want
    them to be sensitive to user touches. Apart from this, the objects that can handle
    touch events must inherit from the `UIResponder` class. Note that although the
    `UIViewController` class inherits from `UIResponder` and can therefore capture
    touch events, it does not have a `UserInteractionEnabled` property, and it is
    its main property of `UIView`, which controls the delivery of touch events. What
    this means is that if you override the touch methods of `UIViewController` but
    its view's `UserInteractionEnabled` property is set to `false`, these methods
    will not respond to user touches.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要响应用户触摸，充当触摸接收器的对象必须将其`UserInteractionEnabled`属性设置为`true`。默认情况下，几乎所有对象都启用了用户交互，除非它们的主要用途不是直接用于用户交互，例如`UILabel`和`UIImageView`对象。如果我们想让这些对象对用户触摸敏感，我们需要明确地将`UserInteractionEnabled`设置为这些对象。除此之外，可以处理触摸事件的对象必须继承自`UIResponder`类。请注意，尽管`UIViewController`类继承自`UIResponder`并且可以捕获触摸事件，但它没有`UserInteractionEnabled`属性，而是它的主要属性`UIView`控制着触摸事件的传递。这意味着，如果你重写了`UIViewController`的触摸方法，但它的视图的`UserInteractionEnabled`属性设置为`false`，这些方法将不会响应用户触摸。
- en: 'The methods responsible of handling the touch events are the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 负责处理触摸事件的方法如下：
- en: '`TouchesBegan`: It is called when the user has touched the screen'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesBegan`：当用户触摸屏幕时被调用'
- en: '`TouchesMoved`: It is called when the user is dragging his/her finger on the
    screen'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesMoved`：当用户在屏幕上拖动手指时被调用'
- en: '`TouchesEnded`: It is called when the user has lifted his/her finger from the
    screen'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesEnded`：当用户从屏幕上抬起手指时调用'
- en: '`TouchesCancelled`: It is called when the touch event has been cancelled by
    a system event, for example, when a notification alert is displayed'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesCancelled`：当触摸事件被系统事件取消时调用，例如，当显示通知警报时'
- en: The full project can be found in the downloadable source code. The `TouchesMoved`
    method implementation has been explained here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目可以在可下载的源代码中找到。`TouchesMoved`方法实现已在下面解释。
- en: Every touch method has two parameters. The first parameter is of the `NSSet`
    type and contains the `UITouch` objects. The `NSSet` class represents a collection
    of objects, while the `UITouch` class holds the information for each user touch.
    The second parameter is of the `UIEvent` type and holds the information of the
    actual event.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个触摸方法都有两个参数。第一个参数是`NSSet`类型，包含`UITouch`对象。`NSSet`类表示一组对象，而`UITouch`类保存每个用户触摸的信息。第二个参数是`UIEvent`类型，包含实际事件的信息。
- en: 'We can retrieve the `UITouch` object related to the actual touch through the
    `NSSet.AnyObject` return value by using the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下代码通过`NSSet.AnyObject`返回值检索与实际触摸相关的`UITouch`对象：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It returns an object of the `NSObject` type, which we convert to `UITouch`.
    We can get the previous and current locations of the touch through the following
    methods:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个`NSObject`类型的对象，我们将它转换为`UITouch`。我们可以通过以下方法获取触摸的先前和当前位置：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both of the preceding methods return a `PointF` struct, which contains the location
    of the touch in the receiver's coordinate system. After receiving the location
    of the touch, we adjust the background color accordingly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法都返回一个`PointF`结构体，其中包含触摸在接收者坐标系中的位置。在接收到触摸位置后，我们相应地调整背景颜色。
- en: There's more...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'This example is based on single user touches. To enable a view to respond to
    multiple touches, we have to set its `MultipleTouchEnabled` property to `true`.
    We can then get all the `UITouch` objects in an array:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例基于单个用户的触摸。为了使视图能够响应多个触摸，我们必须将其`MultipleTouchEnabled`属性设置为`true`。然后我们可以从数组中获取所有的`UITouch`对象：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Getting the tap count
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取点击次数
- en: We can determine the number of consecutive user taps through the `UITouch.TapCount`
    property inside the `ToucheEnded` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`ToucheEnded`方法内部使用`UITouch.TapCount`属性来确定连续用户点击的次数。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Handling motion events* recipe
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理运动事件*食谱'
- en: The *Recognizing gestures* recipe
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别手势*食谱'
- en: The *Custom gestures* recipe
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义手势*食谱'
- en: Recognizing gestures
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别手势
- en: In this recipe, we will discuss how to recognize touch gestures and respond
    accordingly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何识别触摸手势并相应地做出反应。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `GestureApp`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`GestureApp`。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a label to the view of the controller.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加一个标签。
- en: 'Add the following method in the `GestureAppViewController` class:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GestureAppViewController`类中添加以下方法：
- en: '[PRE28]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE29]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Compile and run the app on the simulator. Hold down the *option* key and click-and-drag
    the mouse to perform the equivalent of a pinch on the simulator screen.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。按住*选项*键并点击拖动鼠标以执行模拟器屏幕上的捏合动作。
- en: 'Holding down the Option key and dragging with the mouse cursor on the simulator
    is the equivalent of touching a device''s screen with two fingers, as shown in
    the following screenshot:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模拟器上按住选项键并拖动鼠标光标相当于用两只手指触摸设备的屏幕，如下面的截图所示：
- en: '![How to do it...](img/8924OT_09_03.jpg)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/8924OT_09_03.jpg)'
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As the iOS Version 3.2 was released along with the iPad, Apple introduced the
    `UIGestureRecognizer` class and its derivatives. The gesture recognizers make
    use of the multitouch screens on iOS devices. Gestures are basically touch combinations
    that can be performed for specific actions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 随着iOS 3.2版本的发布，iPad一同推出，苹果公司引入了`UIGestureRecognizer`类及其派生类。手势识别器利用iOS设备上的多点触控屏幕。手势基本上是用于特定动作的触摸组合。
- en: For example, pinching on a fullscreen image in the native *Photos* app will
    zoom out. The action of pinching is the gesture that the user performs, while
    the gesture recognizer is responsible for recognizing and delivering the gesture
    event to its receiver.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在原生*照片*应用程序的全屏图像上缩放手势，将缩小图像。缩放手势是用户执行的手势，而手势识别器负责识别并将手势事件传递给接收器。
- en: 'In this example, we create a `UIPinchGestureRecognizer` instance, which will
    recognize the pinches performed on the screen. Its instance is created with the
    following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`UIPinchGestureRecognizer`实例，它将识别屏幕上执行的手势。其实例是通过以下代码创建的：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The constructor that initializes the instance takes one parameter, which is
    of the `Action<UIPinchGestureRecognizer>` type and represents the method that
    will be called when the recognizer receives a gesture.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化实例的构造函数接受一个参数，该参数为`Action<UIPinchGestureRecognizer>`类型，表示当识别器接收到手势时将被调用的方法。
- en: 'Inside the method, we read the `State` property of the gesture recognizer object
    and respond accordingly, as shown in the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们读取手势识别器对象的`State`属性并根据情况进行响应，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's more...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The state of each gesture recognizer is represented by an enumeration of the
    `UIGestureRecognizerState` type. Its possible values are shown as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个手势识别器的状态由`UIGestureRecognizerState`类型的枚举表示。其可能的值如下所示：
- en: '`Possible`: This indicates that the gesture has not been recognized yet. This
    is the default value.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Possible`：这表示手势尚未被识别。这是默认值。'
- en: '`Began`: This indicates that the gesture has started.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Began`：这表示手势已开始。'
- en: '`Changed`: This indicates that the gesture has changed.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Changed`：这表示手势已改变。'
- en: '`Ended`: This indicates that the gesture has ended.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ended`：这表示手势已结束。'
- en: '`Cancelled`: This indicates that the gesture has been canceled.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cancelled`：这表示手势已被取消。'
- en: '`Failed`: This indicates that the gesture cannot be recognized.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Failed`：这表示无法识别手势。'
- en: '`Recognized`: This indicates that the gesture has been recognized.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recognized`：这表示手势已被识别。'
- en: The advantage of gesture recognizers
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手势识别器的优势
- en: The advantage of gesture recognizers is that they save developers the time to
    create their own gesture recognition mechanisms through the touch events. Furthermore,
    they are based on the gestures that users are accustomed to using on iOS devices.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 手势识别器的优势在于它们可以节省开发者创建自己的手势识别机制的时间，通过触摸事件实现。此外，它们基于用户在iOS设备上习惯使用的手势。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Handling touch events* recipe
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理触摸事件*配方'
- en: The *Custom gestures* recipe
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义手势*配方'
- en: Custom gestures
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义手势
- en: In this recipe, we will learn how to create a custom gesture recognizer to create
    our own gesture response mechanism.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何创建自定义手势识别器以创建我们自己的手势响应机制。
- en: Getting ready
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `CustomGestureApp`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`CustomGestureApp`。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a label to the view of the controller.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加一个标签。
- en: 'Create the following nested class in the `CustomGestureAppViewController` class:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomGestureAppViewController`类中创建以下嵌套类：
- en: '[PRE32]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following method to the class:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到类中：
- en: '[PRE33]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Initialize and add the gesture recognizer in the `ViewDidLoad` method as shown
    in the following code:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，在`ViewDidLoad`方法中初始化并添加手势识别器：
- en: '[PRE34]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile and run the app on the simulator. Click-and-drag on the simulator's
    screen towards the lower-left corner.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在模拟器的屏幕上点击并拖动到左下角。
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To create a gesture recognizer, we need to declare a class that inherits from
    the `UIGestureRecognizer` class. In this example, we are creating a gesture that
    will be recognized by dragging the finger on the screen towards a 50 x 50 point
    area in the lower-left corner of the screen. The following line of code shows
    the class declaration:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建手势识别器，我们需要声明一个继承自`UIGestureRecognizer`类的类。在这个例子中，我们创建了一个手势，用户可以通过在屏幕上拖动手指到屏幕左下角的50
    x 50点区域来识别这个手势。以下代码行显示了类声明：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `UIGestureRecognizer` class contains the same touch methods that we use
    to intercept touches in views. We also have access to the view it was added to
    through its `View` property. Inside the `TouchesBegan` method, we determine the
    initial touch location. If it is outside the lower-left portion of the view, we
    set the `State` property to `Began`. If it is inside the lower-left portion, we
    set the `State` property to `Failed` so that the callback will not be called.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizer` 类包含我们用来在视图中拦截触摸的相同触摸方法。我们还可以通过其 `View` 属性访问它所添加到的视图。在
    `TouchesBegan` 方法中，我们确定初始触摸位置。如果它在视图的左下角外部，我们将 `State` 属性设置为 `Began`。如果它在左下角内部，我们将
    `State` 属性设置为 `Failed`，这样回调就不会被调用。'
- en: Inside the `TouchesEnded` method, we consider the gesture as `Ended` if the
    touch's location was inside the lower-left portion of the view. If it was not,
    the gesture recognition is considered as `Failed`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TouchesEnded` 方法中，如果触摸的位置在视图的左下角内部，我们考虑手势为 `Ended`。如果没有，手势识别被认为是 `Failed`。
- en: The `TouchesMoved` method is where the `Changed` state will be set. For this
    simple gesture recognizer that we are creating, no other logic is needed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchesMoved` 方法是设置 `Changed` 状态的地方。对于这个简单的手势识别器，不需要其他逻辑。'
- en: 'As the `UIGestureRecognizer` class does not have a constructor that accepts
    an `Action<T>` object for the gesture handler, we initialize it with the default
    constructor and use the `AddTarget` method for this purpose by using the following
    code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `UIGestureRecognizer` 类没有接受手势处理程序的 `Action<T>` 对象的构造函数，我们使用默认构造函数初始化它，并使用以下代码通过
    `AddTarget` 方法来达到这个目的：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The only difference in this case is that the parameter is of the `Action<NSObject>`
    type, which we can cast to our own custom type, as shown in the following line
    of code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，唯一的区别是参数是 `Action<NSObject>` 类型，我们可以将其转换为我们的自定义类型，如下面的代码行所示：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: This is a simple gesture recognizer that depends on a single touch. With the
    information provided in the touch methods, we can create more complex gestures
    that will support multiple touches.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的手势识别器，它依赖于单个触摸。通过触摸方法提供的信息，我们可以创建更复杂的支持多个触摸的手势。
- en: Another use of custom gesture recognizers
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义手势识别器的另一种用途
- en: There are some views that inherit from the `UIView` class, which, according
    to the Apple developer documentation, should not be subclassed. The `MKMapView`
    class represents one of these views that is used to display the maps. This poses
    a problem if we want to intercept the touch events from these views. Although
    we could use another view over it and intercept that view's touch events, it is
    quite complex (and error prone) to do so. A more simple approach is to create
    a simple custom gesture recognizer and add it to the view that we cannot subclass.
    This way, we can intercept its touches without having to subclass it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些视图继承自 `UIView` 类，根据苹果开发者文档，这些类不应该被子类化。`MKMapView` 类代表这些用于显示地图的视图之一。如果我们想拦截这些视图的触摸事件，这会引发问题。虽然我们可以在其上使用另一个视图并拦截该视图的触摸事件，但这相当复杂（且容易出错）。一个更简单的方法是创建一个简单的自定义手势识别器并将其添加到我们无法子类化的视图中。这样，我们可以在不子类化的情况下拦截其触摸。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Recognizing gestures* recipe
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别手势* 菜单'
- en: The *Handling touch events* recipe
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理触摸事件* 菜单'
- en: Using the accelerometer
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: In this recipe, we will learn how to receive the accelerometer events to create
    an app that is aware of the device movement.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何接收加速度计事件以创建一个能够感知设备运动的 app。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `AccelerometerApp`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序** 并命名为 `AccelerometerApp`。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simulator does not support the accelerometer hardware. The project in this
    example will work correctly on a device.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器不支持加速度计硬件。本例中的项目将在设备上正确运行。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add two buttons and a label on the view of the controller.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加两个按钮和一个标签。
- en: 'In the `ViewDidLoad` method, add the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中，添加以下代码：
- en: '[PRE38]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the following method in the class:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Compile and run the app on the device. Tap the **Start accelerometer** button
    and watch the values get displayed on the label while moving or shaking the device.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行 app。轻触 **开始加速度计** 按钮，并观察在移动或摇晃设备时值在标签上显示。
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIAccelerometer` class provides access to the accelerometer hardware through
    its `SharedAccelerometer` static property. To activate it, all we need to do is
    to assign a handler to its `Acceleration` event by using the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAccelerometer`类通过其`SharedAccelerometer`静态属性提供对加速度计硬件的访问。要激活它，我们只需要将其`Acceleration`事件分配给一个处理器，使用以下代码：'
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside the handler, we receive the accelerometer values through the `UIAccelerometerEventArgs.Acceleration`
    property. The property returns an object of the `UIAcceleration` type, which contains
    the accelerometer amount in three properties: `X`, `Y`, and `Z`. These properties
    represent the motion in the *x*-, *y*-, and *z*-axis. Consider the following screenshot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器内部，我们通过`UIAccelerometerEventArgs.Acceleration`属性接收加速度计的值。该属性返回一个`UIAcceleration`类型的对象，它包含三个属性：`X`、`Y`和`Z`。这些属性代表*x*轴、*y*轴和*z*轴的运动。考虑以下截图：
- en: '![How it works...](img/8924OT_09_04.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8924OT_09_04.jpg)'
- en: 'Each of these values measure the amount of G-force by which the device moved
    on each axis. For example, if `X` has a value of `1`, the device is moving on
    the *x* axis to the right with an acceleration of 1G. If `X` has a value of `-1`,
    the device is moving on the *x* axis to the left with an acceleration of 1G. When
    the device is placed on a table with its back facing the floor and is not moving,
    the normal values of the acceleration should be close or equal to the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值中的每一个都测量设备在每个轴上移动的G力的大小。例如，如果`X`的值为`1`，则设备在*x*轴上向右移动，加速度为1G。如果`X`的值为`-1`，则设备在*x*轴上向左移动，加速度为1G。当设备背对地面放置在桌子上且不移动时，加速度的正常值应接近或等于以下值：
- en: '`X`: `0`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`: `0`'
- en: '`Y`: `0`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Y`: `0`'
- en: '`Z`: `-1`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Z`: `-1`'
- en: Although the device is not moving, Z will be `-1` because the device measures
    the earth's gravity.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管设备没有移动，但Z将为`-1`，因为设备测量地球的重力。
- en: 'We can set the interval by which the accelerometer will issue the acceleration
    events, by setting its `UpdateInterval` property by using the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置加速度计发布加速度事件的时间间隔来设置，通过使用以下代码设置其`UpdateInterval`属性：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The property accepts a number of type `double`, which represents the interval
    by which the accelerometer will issue its acceleration events in seconds. Care
    must be taken when setting the update interval because the more events the accelerometer
    has to issue for a specific period of time, the more battery power it consumes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性接受一个`double`类型的数字，它表示加速度计在秒内发布加速度事件的时间间隔。设置更新间隔时必须小心，因为加速度计在特定时间内需要发布的更多事件，它消耗的电量就越多。
- en: 'To stop using the accelerometer, all we need to do is unhook the handler from
    the `Acceleration` event by using the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止使用加速度计，我们只需要通过以下代码从`Acceleration`事件中取消绑定处理器：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There's more...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `UIAcceleration` class contains another useful property, named `Time`. It
    is a `double` that represents the relative time on which the acceleration event
    occurred. It is relative to the CPU time, and it is not suggested that you use
    this value to calculate the exact timestamp of the event.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAcceleration`类还包含另一个有用的属性，名为`Time`。它是一个`double`，表示加速度事件发生的相对时间。它是相对于CPU时间的，不建议您使用此值来计算事件的精确时间戳。'
- en: Consideration when using the accelerometer
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用加速度计时的注意事项
- en: Although the iPhone's accelerometer is a very accurate and sensitive sensor,
    it should not be used for precise measurements. Also, the results it produces
    may vary among different iOS devices, even if they're of the same model.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然iPhone的加速度计是一个非常精确和敏感的传感器，但不应该用于精确测量。此外，它产生的结果可能在不同iOS设备之间有所不同，即使它们是同一型号。
- en: See also
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the gyroscope* recipe
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用陀螺仪的食谱
- en: Using the gyroscope
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用陀螺仪
- en: In this recipe, we will learn how to use the device's built-in gyroscope.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用设备的内置陀螺仪。
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Xamarin Studio and name it `GyroscopeApp`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的项目，并将其命名为`GyroscopeApp`。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simulator does not support the gyroscope hardware. Also, only newer devices
    contain a gyroscope. If this app is executed on a device without a gyroscope or
    on the simulator, no error will occur but no data will be displayed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器不支持陀螺仪硬件。此外，只有较新的设备才包含陀螺仪。如果此应用程序在没有陀螺仪的设备或模拟器上运行，则不会发生错误，但不会显示数据。
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add two buttons and a label to the view the controller.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器视图中添加两个按钮和一个标签。
- en: Add the `MonoTouch.CoreMotion` namespace in the `GyroscopeAppViewController.cs`
    file.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GyroscopeAppViewController.cs`文件中添加`MonoTouch.CoreMotion`命名空间。
- en: 'Enter the following private field in the class:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中输入以下私有字段：
- en: '[PRE43]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the `ViewDidLoad` method with the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现`ViewDidLoad`方法：
- en: '[PRE44]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the following method:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE45]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Compile and run the app on the device. Tap the **Start gyroscope** button and
    rotate the device in all axes. Watch the values get displayed in the **Application
    Output** pad.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。轻触**开始陀螺仪**按钮，并在所有轴上旋转设备。观察值在**应用程序输出**面板中显示。
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The gyroscope is a mechanism that measures orientation. Newer iOS devices support
    the gyroscope hardware, along with the accelerometer, to give even more accurate
    measurements of the device motion.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 陀螺仪是一种测量方向的机制。较新的iOS设备支持陀螺仪硬件，以及加速度计，以提供更精确的设备运动测量。
- en: 'The `MonoTouch.CoreMotion` namespace wraps the objects contained in the native
    CoreMotion framework. The process of using the gyroscope hardware in code is similar
    to the one used for the accelerometer. The first difference is that there is no
    single object for the gyroscope in the `UIApplication` class. So, we need to create
    an instance of the `CMMotionManager` class as shown in the following code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreMotion`命名空间封装了原生CoreMotion框架中的对象。在代码中使用陀螺仪硬件的过程与用于加速度计的过程类似。第一个区别是`UIApplication`类中没有针对陀螺仪的单个对象。因此，我们需要创建`CMMotionManager`类的实例，如下面的代码所示：'
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Just like how we use the accelerometer, we can set the interval by which we
    will receive the gyroscope events in seconds by using the following code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们使用加速度计一样，我们可以通过以下代码设置我们将以秒为间隔接收陀螺仪事件：
- en: '[PRE47]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To start receiving the gyroscope events, we call the object''s `StartGyroUpdates`
    method as shown in the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始接收陀螺仪事件，我们调用对象的`StartGyroUpdates`方法，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This method is overloaded; the first overload is parameterless and when called,
    the values of the gyroscopic measurements are set to the `GyroData` property.
    Using this overload is quite simple and easy, but no events are triggered here,
    and we have to provide a mechanism to read the measurements from the property.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法被重载；第一个重载是无参数的，当被调用时，陀螺仪测量值的`GyroData`属性被设置。使用这个重载非常简单且容易，但在这里不会触发任何事件，我们必须提供一个机制来从属性中读取测量值。
- en: The second overload, which is used in this example, accepts two parameters.
    The first parameter is the `NSOperationQueue` parameter on which the updates will
    occur, and the second parameter is the handler that will be executed when an update
    occurs.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重载，在此示例中使用，接受两个参数。第一个参数是更新将发生的`NSOperationQueue`参数，第二个参数是当发生更新时将被执行的处理器。
- en: The `NSOperationQueue` class represents an iOS mechanism to manage the `NSOperation`
    objects' execution. We access the runtime's main operation queue through the static
    `NSOperationQueue.MainQueue` property. Basically, this way, we instruct the runtime
    to manage the delivery of the handler in a more effective manner.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSOperationQueue`类代表iOS管理`NSOperation`对象执行的一种机制。我们通过静态`NSOperationQueue.MainQueue`属性访问运行时的主操作队列。基本上，这种方式，我们指示运行时以更有效的方式管理处理器的传递。'
- en: 'The second parameter is a delegate of the `CMGyroHandler` type. Its signature,
    represented by the method we created, is similar to the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是`CMGyroHandler`类型的委托。它的签名，由我们创建的方法表示，类似于以下代码：
- en: '[PRE49]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `CMGyroData` object contains the actual measurement values received from
    the gyroscope through its `RotationRate` property. The following code outputs
    the data from the property:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMGyroData`对象包含从陀螺仪通过其`RotationRate`属性接收到的实际测量值。以下代码输出属性中的数据：'
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The rotation rate is reflected on the *x*, *y*, and *z* axis, represented by
    the corresponding `X`, `Y`, and `Z` properties. Each value is the amount of the
    rotation angle per second, which occurred on that axis, in radians.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转速率反映在*x*、*y*和*z*轴上，分别由相应的`X`、`Y`和`Z`属性表示。每个值是该轴上每秒发生的旋转角度的数量，以弧度为单位。
- en: Although it might seem a bit complicated at first, it is actually quite simple.
    For example, a value of 0.5 in the *z* axis means that the device rotated with
    a rate of 0.5 radians/sec to the left. A value of -0.5 in the *z*-axis means that
    the device rotated with a rate of 0.5 radians/sec to the right. The pattern to
    determine the rotation direction is based on the right-hand rule.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能看起来有点复杂，但实际上相当简单。例如，*z* 轴上的值为 0.5 表示设备以 0.5 弧度/秒的速度向左旋转。*z*-轴上的值为 -0.5
    表示设备以 0.5 弧度/秒的速度向右旋转。确定旋转方向的模式基于右手定则。
- en: There's more...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you want your app to be available only for devices that support the gyroscope,
    add the `UIRequiredDeviceCapabilities` key in your project's `Info.plist` file
    with the `gyroscope` value. If your app's functionality is based fully on the
    gyroscope, adding this key must be considered essential to avoid the app being
    downloaded by users with older devices, ending up with an app that does not work.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的应用程序仅适用于支持陀螺仪的设备，请在项目的 `Info.plist` 文件中添加 `UIRequiredDeviceCapabilities`
    键，并使用 `gyroscope` 值。如果您的应用程序的功能完全基于陀螺仪，添加此键是必不可少的，以避免应用程序被较老设备的用户下载，最终导致应用程序无法使用。
- en: Determining the availability of the gyroscope hardware
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定陀螺仪硬件的可用性
- en: To determine whether the device the app is running on supports the gyroscope
    hardware, check the value of the `GyroAvailable` property of the `CMMotionManager`
    instance.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定运行应用程序的设备是否支持陀螺仪硬件，请检查 `CMMotionManager` 实例的 `GyroAvailable` 属性值。
- en: Converting radians to degrees
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将弧度转换为度数
- en: 'A radian is an angle measurement unit. To convert an angle measurement from
    radians to degrees, consider the following helper method:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度是角度的测量单位。要将角度测量值从弧度转换为度数，请考虑以下辅助方法：
- en: '[PRE51]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See also
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the accelerometer* recipe
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计* 菜单'
