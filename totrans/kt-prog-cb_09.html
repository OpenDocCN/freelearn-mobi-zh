<html><head></head><body><div><h1 class="header-title">Anko Layouts</h1>
                
            
            
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Setting up Anko library for Anko layouts in Gradle</li>
</ul>
<ul>
<li>Creating user-interface programmatically</li>
</ul>
<ul>
<li>Working with the old code of XML layouts</li>
</ul>
<ul>
<li>Using the provided AnkoComponent interface</li>
</ul>
<ul>
<li>Setting theme for Android views in Anko</li>
</ul>
<ul>
<li style="font-weight: 400">Setting layout parameters for Anko views</li>
</ul>
<ul>
<li style="font-weight: 400">
<p>Adding listeners to Anko views</p>
</li>
<li>
<p>Inserting XML layouts into DSL</p>
</li>
<li>
<p>Converting XML files into DSL</p>
</li>
<li>
<p>Showing Snackbar</p>
</li>
<li>
<p>Showing Toasts</p>
</li>
<li>
<p>Accessing views using synthetic properties</p>
</li>
<li>
<p>Accessing views of view groups using extension functions</p>
</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Anko is a Kotlin library that makes Android development a lot faster and easier. It also makes the code clean and concise. Most of us are used to writing XML layouts for UI in Android, which is redundant and neither type safe nor null safe. It also eats CPU time and battery to parse XML on a device. Some who programmatically write layouts know how large the code becomes, and it is also very difficult to maintain.</p>
<p>With Anko, we can use DSL to define layouts. The advantages of using DSL is that they are easy to read and write and they have no runtime overhead. If you are familiar with Android development and XML layouts, this chapter will help you quickly get started with Anko layouts.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Setting up Anko library for Anko layouts in Gradle</h1>
                
            
            
                
<p>The first and foremost thing to do to start using any library is adding its dependencies to our project so as to be able to use its methods and functionalities in our project. In this recipe, we will explore how to add dependencies of Anko layouts to our project using gradle.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write the code, as it is the latest right now. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+ as we won't be using any code from other recipes. You also need an intermediate understanding of Android development.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will add Anko to our project:</p>
<ol>
<li>We can add all Anko features and components in one go by adding the following line to our <kbd>build.gradle</kbd> dependencies:</li>
</ol>
<pre style="padding-left: 60px">// Anko<br/>compile "org.jetbrains.anko:anko:$anko_version"</pre>
<p style="padding-left: 60px">Here, <kbd>$anko_version</kbd> is the latest version of Anko. You can replace it with the latest version of Anko at this time.</p>
<ol start="2">
<li>After that, sync your <kbd>build.gradle</kbd> file. Now, Anko dependencies have been added to your project. Let's check this by simply using Anko commons to create and show an alert dialog. Create a button in your activity by defining it in your XML layout and adding <kbd>onClickListener</kbd> on it, clicking on which should run the following code:</li>
</ol>
<pre style="padding-left: 60px">alert("This is my message from alert dialog", "An Alert!") {<br/>    yesButton { toast("Thanks for clicking ok") }<br/>    noButton {<br/>        toast("Got it!") }<br/>}.show()</pre>
<ol start="3">
<li>If on clicking the button, an alert shows up that we successfully added Anko library in our project, this is how the alert dialog looks:</li>
</ol>
<div><img height="1280" width="720" src="img/95d25970-98af-4373-b94c-5d9008010679.jpeg"/></div>
<ol start="4">
<li>However, most of the time we just need to add a single feature of Anko to our project. For example, Anko layouts in this case. So let's try to add just Anko layouts library to our project. Remove the previous code from <kbd>build.gradle</kbd> and your <kbd>Activity</kbd> and let's start over.</li>
<li>Now add the following lines to your project's app-level <kbd>build.gradle</kbd> dependencies:</li>
</ol>
<pre style="padding-left: 60px">// Anko Layouts<br/>compile "org.jetbrains.anko:anko-sdk25:$anko_version"<br/>compile "org.jetbrains.anko:anko-appcompat-v7:$anko_version"</pre>
<ol start="6">
<li>Sync your <kbd>build.gradle</kbd> and if there are no errors, you can now use Anko layouts in your project. At this point, we should also add dependencies of Anko coroutines, as we will obviously need listeners on our layouts. You can add those dependencies by adding the following lines to your <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">// Coroutine listeners for Anko Layouts<br/>compile "org.jetbrains.anko:anko-sdk25-coroutines:$anko_version"<br/>compile "org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version"<br/></pre>
<ol start="7">
<li>Done! Now, let's check whether everything is working perfectly. To do that, let's add a basic DSL layout to our main activity. Check out the following code of the <kbd>onCreate()</kbd> method of our target activity:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    verticalLayout {<br/>        button("Hello World button!") {<br/>            onClick { toast("Hello, World!") }<br/>        }<br/>    }<br/>}</pre>
<ol start="8">
<li>Now run the app on your phone; if the layout works correctly, that is, you have a button on your screen with text HELLO WORLD BUTTON!, then we have successfully added Anko layouts dependencies to our project. This is how our layout looks:</li>
</ol>
<div><img height="1288" width="728" src="img/400a93a9-857e-493e-a527-b1b50375d247.jpeg"/></div>
<ol start="9">
<li>Also, on clicking on the button, we get a toast like this:</li>
</ol>
<div><img height="378" width="724" src="img/40644d34-7e53-4a7f-a3f9-74106ff1d2ec.jpeg"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>By adding project dependencies in our <kbd>build.gradle</kbd> file, the amazing gradle takes care of what libraries and dependencies are needed by our project. The dependencies are located by gradle on our machine or in a remote repository, and any transitive dependencies are automatically included. Gradle makes adding project dependencies extremely easy and  quick, and we can invest most of our time in creating our amazing software, rather than maintaining and resolving dependencies that becomes extremely difficult in large projects with lots of dependencies.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>If you do not use Gradle and do not want to use it in your project, you can directly add Anko's library JAR from the <strong>jcenter repository</strong> (<a href="https://jcenter.bintray.com/org/jetbrains/anko/">https://jcenter.bintray.com/org/jetbrains/anko/</a>) as library dependencies.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating user-interface programmatically</h1>
                
            
            
                
<p>Writing UI in XML is not type safe or null safe, and it also eats CPU and battery. Writing UI programmatically (especially in Java) becomes bulky and unmanageable for large and complex UIs. That is when Anko layouts come to the rescue. We can easily create layouts in DSL using Anko layouts, and it also has no runtime overhead. In this recipe, we will see how to create layouts using DSL.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>, in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's start with a simple example where we use Anko to create a layout for our target activity (the activity in which you want to create a layout):</p>
<ol>
<li>Here's the code for the <kbd>onCreate()</kbd> method that you need to put in your target activity:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    verticalLayout {<br/>        padding = dip(20)<br/>        val name = editText {<br/>            hint = "What is your name?"<br/>        }<br/>        val message = editText {<br/>            hint = "Your message"<br/>        }<br/>        button("Send") {<br/>            onClick { toast("Hello, ${name.text} we have recorded your message!") }<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Basically, in the preceding code, we want to create a basic "contact us" form. For this, we have created a vertical linear layout with a 20 dip padding and, inside the vertical linear layout, we have added two edit texts for name and message, respectively. On clicking on the button, we take the data and show the user a confirmation that the message has been recorded through toast. This is how part of the screen looks:</li>
</ol>
<div><img height="1282" width="722" src="img/13c8cc9e-f05b-4991-a1e6-2863d647df53.jpeg"/></div>
<ol start="3">
<li>Anko layouts DSL is a great way to build UI in fewer lines of code. It is simple to read and write, and it's clean and concise. It has no runtime overhead as there is in XML layouts. Anko layouts support XML too, and you can use custom components and also use coroutines for listeners. You can also get a preview of the DSL layout in Android Studio when using <kbd>AnkoComponent</kbd> interface, which we will learn later in this chapter.</li>
</ol>
<ol start="4">
<li>Let's try another example where we fit the preceding layout in a coordinator layout with a toolbar. To be able to use a coordinator layout, we need to add dependencies for Anko design support library. Add the following lines to your <kbd>build.gradle</kbd> and sync your project:</li>
</ol>
<pre style="padding-left: 60px">// Anko layouts design support<br/>compile "org.jetbrains.anko:anko-design:$anko_version"</pre>
<ol start="5">
<li>There are a lot of artifacts by Anko for various Android support libraries out there. The following is the list:</li>
</ol>
<pre style="padding-left: 60px"><strong>// Appcompat-v7 (only Anko Commons)</strong><br/> compile "org.jetbrains.anko:anko-appcompat-v7-commons:$anko_version"<br/><strong>// Appcompat-v7 (Anko Layouts)</strong><br/> compile "org.jetbrains.anko:anko-appcompat-v7:$anko_version"<br/> compile "org.jetbrains.anko:anko-coroutines:$anko_version"<br/><strong>// CardView-v7</strong><br/> compile "org.jetbrains.anko:anko-cardview-v7:$anko_version"<br/><strong>// Design</strong><br/> compile "org.jetbrains.anko:anko-design:$anko_version"<br/> compile "org.jetbrains.anko:anko-design-coroutines:$anko_version"<br/><strong>// GridLayout-v7</strong><br/> compile "org.jetbrains.anko:anko-gridlayout-v7:$anko_version"<br/><strong>// Percent</strong><br/> compile "org.jetbrains.anko:anko-percent:$anko_version"<br/><strong>// RecyclerView-v7</strong><br/> compile "org.jetbrains.anko:anko-recyclerview-v7:$anko_version"<br/> compile "org.jetbrains.anko:anko-recyclerview-v7-coroutines:$anko_version"<br/><strong>// Support-v4 (only Anko Commons)</strong><br/> compile "org.jetbrains.anko:anko-support-v4-commons:$anko_version"<br/><strong>// Support-v4 (Anko Layouts)</strong><br/> compile "org.jetbrains.anko:anko-support-v4:$anko_version"</pre>
<ol start="6">
<li>Now what we need is a coordinator layout that fits the whole width and height of the parent and, inside it, we need an app bar with a toolbar and below the app bar we need our vertical layout from earlier. I suggest that you try to code this one on your own before checking out my method, which is as follows:</li>
</ol>
<pre style="padding-left: 60px">coordinatorLayout {<br/>    fitsSystemWindows = true<br/>    lparams {<br/>        width = matchParent<br/>        height = matchParent<br/>    }<br/>    appBarLayout {<br/>        toolbar {<br/>            setTitleTextColor(Color.WHITE)<br/>            id = R.id.toolbar<br/>            title = resources.getString(R.string.main_activity)<br/>         }.lparams {<br/>             width = matchParent<br/>             height = wrapContent<br/>         }<br/>    }.lparams { width = matchParent }<br/>    verticalLayout {<br/>        verticalLayout {<br/>            background = context.getDrawable(R.color.colorLightGrey)<br/>            gravity = Gravity.CENTER<br/>            textView("logo"){<br/>                textColor = context.getColor(R.color.colorAccent)<br/>                textSize = 24f<br/>            }.lparams(width = wrapContent, height = wrapContent) {<br/>                horizontalMargin = dip(5)<br/>                topMargin = dip(10)<br/>            }<br/>        }.lparams(width = matchParent, height = dip(200)) {<br/>              horizontalMargin = dip(5)<br/>              topMargin = dip(10)<br/>          }<br/>        padding = dip(20)<br/>        val name = themedEditText(theme = R.style.newInput) {<br/>            id = R.id.name<br/>            hint = "What is your name?"<br/>        }<br/>        val message = editText {<br/>            id = R.id.message<br/>            hint = "Your message"<br/>        }<br/>        themedButton("Send", theme = R.style.newButton)                             {<br/>            id = R.id.btn_send<br/>        }<br/>    }.lparams {<br/>          width = matchParent<br/>          height = matchParent<br/>          behavior = AppBarLayout.ScrollingViewBehavior()<br/>      }<br/> }</pre>
<ol start="7">
<li><kbd>lparams</kbd> used in the preceding function is the extension function used to add layout parameter to a view. This is how the layout looks in our app:</li>
</ol>
<div><img height="1282" width="722" src="img/bcc64095-494e-47c4-8b98-60eabc6a28ae.jpeg"/></div>
<p>Creating layouts using DSL is a bit similar to XML itself, which is intentional, given the previous experience of developers with XML, and it also gives us the power to calculate things on the fly, while dynamically adding views.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>XML Parsing is done at compile time (except for a few things). It introduces CPU and battery overheads. For very complex layouts, it also introduces latency in the app and at times, severely affects user experience.</p>
<p>In Anko layouts, the DSL builds the layout at runtime and hence we can include anything. It also avoids runtime overhead, and we can avoid null pointer exception. Also, we do not need casting and can dodge the <kbd>findViewById</kbd> calls as well.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with the old code of XML layouts</h1>
                
            
            
                
<p>The best thing about Anko layouts is the flexibility to be able to work with our XML layouts as well. Also, Anko makes things easier by providing us view properties. In this recipe, we will see how to use XML layouts and still be able to improve things using Anko Layouts.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+ as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>, in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn how to work with XML layouts, along with Anko layouts:</p>
<ol>
<li>Let's start by first having an old XML file to work on. Add the following code to an XML layout that you will add as the content view of your target activity:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout        xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    app:layout_behavior="@string/appbar_scrolling_view_behavior"<br/>    tools:context="android.my_company.com.helloworldapp.MainActivity"<br/>    tools:showIn="@layout/activity_main"<br/>    android:orientation="vertical"<br/>    android:padding="20dp"&gt;<br/><br/>    &lt;EditText<br/>        android:id="@+id/name"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:hint="What is your name?"/&gt;<br/><br/>    &lt;EditText<br/>        android:id="@+id/message"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:hint="Your message"/&gt;<br/><br/>    &lt;Button<br/>        android:id="@+id/btn_send"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:text="Send"/&gt;<br/><br/>&lt;/LinearLayout&gt;</pre>
<ol start="2">
<li>Traditionally, we used <kbd>findViewById()</kbd> and <kbd>onClickListener()</kbd> in our activity to manipulate properties of the elements of layout and handle events. However, with Anko layouts, this becomes as easy as the following:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.activity_main)<br/>    setSupportActionBar(toolbar)<br/><br/>    var name = find&lt;EditText&gt;(R.id.name)<br/>    var msg = find&lt;EditText&gt;(R.id.message)<br/>    var buttonSend = find&lt;Button&gt;(R.id.btn_send)<br/><br/>    buttonSend.onClick {<br/>        toast("Hello, ${name.text} we have recorded your message!")<br/>    }<br/>}</pre>
<ol start="3">
<li class="mce-root">The preceding is the <kbd>onCreate()</kbd> method of the target activity. Note that the <kbd>find()</kbd> method is a lot simpler than <kbd>findViewById()</kbd>.</li>
<li class="mce-root">We can get and set view properties and also attach listeners to view events. Another thing is that the Kotlin's Android extension functions also let us deal with views without using the <kbd>find</kbd> method. Check out the following code, whereby it becomes super easy to get and set view properties using synthetic extension properties:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.activity_main)<br/>    setSupportActionBar(toolbar)<br/>    var nameText = name.text<br/>    var msg = message.text<br/>    btn_send.onClick {<br/>        toast("Hello, $nameText we have recorded your message!")<br/>    }<br/>}</pre>
<ol start="5">
<li>Here, <kbd>name</kbd>, <kbd>message</kbd>, and <kbd>btn_send</kbd> are the IDs of the views in XML layout, respectively.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>Anko provides us with these extension functions and properties that make it easier to access the views. Some of these functions and properties are prearranged into type-safe builders that are generated using Android JAR files.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>It is worth understanding how Kotlin's synthetic properties work. Kotlin generates some extra code that helps us use our views like properties, naming the variables similar to that  of the ID of the view. Basically, it is running <kbd>findViewById()</kbd> the first time we try to access a view as property and storing it in cache so that all the consecutive calls to the same view invoke <kbd>findCachedViewById()</kbd>, thus making the access a lot faster.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the provided AnkoComponent interface</h1>
                
            
            
                
<p>We can define an activity's layout DSL directly in the <kbd>onCreate()</kbd> method, but it is sometimes convenient to separate UI into another class. In this recipe, we will see how to use the <kbd>AnkoComponent</kbd> interface to do that.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+ as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the given steps, we will learn how to work with the AnkoComponent interface:</p>
<ol>
<li>Let's start by adding our UI in a different class that implements the <kbd>AnkoComponent</kbd> interface like this:</li>
</ol>
<pre style="padding-left: 60px">class MainActivityUI : AnkoComponent&lt;MainActivity&gt; {<br/>    override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) {<br/>    verticalLayout {<br/>        padding = dip(20)<br/>        val name = editText {<br/>            id = R.id.name<br/>            hint = "What is your name?"<br/>        }<br/><br/>        val message = editText {<br/>            id = R.id.message<br/>            hint = "Your message"<br/>        }<br/><br/>        button("Send") {<br/>            id = R.id.btn_send<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Note that the preceding class implements the <kbd>AnkoComponent</kbd> interface. We need to override the <kbd>createView()</kbd> method and return DSL layout from it. Now, let's see how to get this layout and set it to our activity. Check out the modified <kbd>onCreate()</kbd> method in our activity:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    MainActivityUI().setContentView(this)<br/>}</pre>
<ol start="3">
<li>Now, let's try to access these views inside our activity, which we should be able to do if the layout has been properly set to our activity. We will access them just as we would have accessed a view from XML layout:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    MainActivityUI().setContentView(this)<br/>    btn_send.onClick { toast("Hello, ${name.text} we have recorded your message!") }<br/>}</pre>
<ol start="4">
<li>The next image is how the screen will look:</li>
</ol>
<div><img height="1280" width="720" src="img/9ac986b5-5853-4125-9aeb-a664d30efc4b.jpeg"/></div>
<ol start="5">
<li>Also, on entering the details and clicking on the button, we see the toast, as follows:</li>
</ol>
<div><img height="350" width="720" src="img/1c4f479b-13d1-44a8-b29f-18d4d93ff86a.jpeg"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>The <kbd>verticalLayout</kbd> (which is a vertical linear layout) block is an extension function provided by Anko, which creates a new view instance and adds it to the parent. There are such extension functions for every view in the Android framework. For example, we used button and edit text as well in the preceding example. We can also use it as <kbd>button()</kbd>, which accepts a string parameter for text on the button or <kbd>button{}</kbd> if we want to set any properties on that view.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>If we use the <kbd>AnkoComponent</kbd> interface for creating our DSL in another class, we can also preview our layout DSL using the Anko support plugin.</p>
<p>For doing so, first add Anko support plugin from plugins in Android Studio settings. After that, put the cursor somewhere inside the <kbd>MainActivityUI</kbd> declaration, open the Anko Layout Preview tool window by clicking on View|Tool Windows|Anko Layout Preview, and press Refresh.</p>
<p class="mce-root">If the layout preview is not being rendered properly, rebuild the project. This is how the window looks:</p>
<div><img height="748" width="1310" src="img/89494c5e-aa01-46f5-a39d-f5675d954d92.png"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Setting theme for Android views in Anko</h1>
                
            
            
                
<p>Our Android apps won't be so beautiful if we won't be able to style our views. Anko layouts give us the power to apply custom themes to our views. In this recipe, we will learn how to create themed views in Anko.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the given steps, we will learn how to set the theme for Android views using Anko:</p>
<ol>
<li>Let's start by first creating a style for a button. Custom styles are created in <kbd>styles.xml</kbd> inside the <kbd>res/values/</kbd> directory. Let's create a button style and name it <kbd>newButton</kbd>. Add the following code in <kbd>styles.xml</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;style name="newButton" parent="android:Widget.Holo.Light.Button"&gt;<br/>    &lt;item name="android:colorButtonNormal"&gt;@color/colorAccent&lt;/item&gt;<br/>    &lt;item name="android:textColor"&gt;@color/white&lt;/item&gt;<br/>&lt;/style&gt;</pre>
<ol start="2">
<li>Now, let's use this style to create a themed button in our target activity. Let's keep our UI in another class using the <kbd>AnkoComponent</kbd> interface. The following is how we create a button with a custom theme in a DSL layout (focus on the bold parts of the code):</li>
</ol>
<pre style="padding-left: 60px">class MainActivityUI : AnkoComponent&lt;MainActivity&gt; {<br/>    override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) {<br/>        verticalLayout {<br/>            padding = dip(20)<br/>            val name = editText {<br/>                id = R.id.name<br/>                hint = "What is your name?"<br/>            }<br/><br/>            val message = editText {<br/>                id = R.id.message<br/>                hint = "Your message"<br/>            }<br/><br/>            <strong>themedButton("Send", theme = R.style.newButton)                                       {<br/>                id = R.id.btn_send<br/>            </strong><strong>}</strong><br/>        }<br/>    }<br/><br/>}</pre>
<ol start="3">
<li>Also, to set this layout of our activity, we add the <kbd>LayoutActivity().setContentView(this)</kbd> line in the <kbd>onCreate()</kbd> method, as follows (focus on the bold parts of the code):</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/><strong>        MainActivityUI().setContentView(this)</strong><br/>        btn_send.onClick { toast("Hello, ${name.text} we have recorded your message!") }<br/>    }</pre>
<ol start="4">
<li>The following is how the top part of our app screen looks, with themed button taking background color as the accent color as defined in our <kbd>colors.xml</kbd> file in the <kbd>res/values/</kbd> directory. The text color is white, just as we set in our custom style:</li>
</ol>
<div><img height="546" width="720" src="img/fa224439-0019-41fd-a6ab-4bec9c3ba685.jpeg"/></div>
<ol start="5">
<li>This is how we set themes on views, by appending themed keywords before the view name and making it camel case. We pass the theme as a parameter to the function.</li>
</ol>
<p>Themed views are also Kotlin extension functions provided by Anko layouts.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Setting layout parameters for Anko views</h1>
                
            
            
                
<p>Without layout parameters, there is not much we can do with our layouts. In this recipe, we will see how to use layout parameters with views in our layout DSL.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn how to set the layout parameters for Anko views:</p>
<ol>
<li>Let's start with creating our view in an external class that inherits from the <kbd>AnkoComponent</kbd> interface. To add layout parameters to a view (which we add using the extension functions provided by Anko), we use the <kbd>lparams()</kbd> extension function, which we add at the end of our view block in DSL, and is something like this:</li>
</ol>
<pre style="padding-left: 60px">val message = editText {<br/>    id = R.id.message<br/>    hint = "Your message"<br/>}<strong>.lparams(){</strong><br/><strong>    // We specify our layout parameters here</strong><br/><strong>}</strong></pre>
<ol start="2">
<li>Let's try a simple example with vertical layouts; check out the following code block (focus on the bold parts of the code):</li>
</ol>
<pre style="padding-left: 60px">verticalLayout {<br/>    verticalLayout {<br/>        background = context.getDrawable(R.color.colorLightGrey)<br/>        gravity = Gravity.CENTER<br/>        textView("logo"){<br/>            textColor = context.getColor(R.color.colorAccent)<br/>            textSize = 24f<br/>        }<strong>.lparams(width = wrapContent, height = wrapContent) {<br/>            horizontalMargin = dip(5)</strong><br/><strong>            topMargin = dip(10)</strong><br/>        <strong>}</strong><br/><br/>    }<strong>.lparams(width = matchParent, height = dip(200)) {<br/>        horizontalMargin = dip(5)</strong><br/><strong>        topMargin = dip(10)</strong><br/>    <strong>}</strong><br/>    padding = dip(20)<br/>    val name = themedEditText(theme = R.style.newInput) {<br/>        id = R.id.name<br/>        hint = "What is your name?"<br/>    }<br/><br/>    val message = editText {<br/>        id = R.id.message<br/>        hint = "Your message"<br/>    }<br/><br/>    themedButton("Send", theme = R.style.newButton) {<br/>        id = R.id.btn_send<br/>    }<br/>}</pre>
<ol start="3">
<li>The <kbd>themedEditText</kbd> and <kbd>themedButton</kbd> extension functions are provided by Anko to create an edit text and button with theme. If you do not wish to use themed views, simply call <kbd>editText()</kbd> and <kbd>button()</kbd> without passing the theme as a parameter.</li>
</ol>
<div><img height="1282" width="722" src="img/c8f5c45a-b5bd-4c55-98dc-066fe7b0e503.jpeg"/></div>
<ol start="4">
<li>Let's go through another example where we have a toolbar with the title of the page in it. Check out the next example that uses coordinator layout, app bar layout, and toolbar. The given code generates the layout as shown in the screenshot following the code:</li>
</ol>
<pre style="padding-left: 60px">coordinatorLayout {<br/>    fitsSystemWindows = true<br/>   <strong> lparams {</strong><br/><strong>        width = matchParent</strong><br/><strong>        height = matchParent</strong><br/><strong>    }</strong><br/>    appBarLayout {<br/>        toolbar {<br/>            setTitleTextColor(Color.WHITE)<br/>            id = R.id.toolbar<br/>            title = resources.getString(R.string.main_activity)<br/>         }.<strong>lparams {</strong><br/><strong>             width = matchParent</strong><br/><strong>             height = wrapContent</strong><br/><strong>         }</strong><br/>    }<strong>.lparams { width = matchParent }</strong><br/>    verticalLayout {<br/>        verticalLayout {<br/>            background = context.getDrawable(R.color.colorLightGrey)<br/>            gravity = Gravity.CENTER<br/>            textView("logo"){<br/>                textColor = context.getColor(R.color.colorAccent)<br/>                textSize = 24f<br/>            }<strong>.lparams(width = wrapContent, height = wrapContent) {</strong><br/><strong>                horizontalMargin = dip(5)</strong><br/><strong>                topMargin = dip(10)</strong><br/><strong>            }</strong><br/>        }<strong>.lparams(width = matchParent, height = dip(200)) {</strong><br/><strong>              horizontalMargin = dip(5)</strong><br/><strong>              topMargin = dip(10)</strong><br/><strong>          }</strong><br/>        padding = dip(20)<br/>        val name = themedEditText(theme = R.style.newInput) {<br/>            id = R.id.name<br/>            hint = "What is your name?"<br/>        }<br/>        val message = editText {<br/>            id = R.id.message<br/>            hint = "Your message"<br/>        }<br/>        themedButton("Send", theme = R.style.newButton)                                                 {<br/>            id = R.id.btn_send<br/>        }<br/>    }<strong>.lparams {</strong><br/><strong>          width = matchParent</strong><br/><strong>          height = matchParent</strong><br/><strong>          behavior = AppBarLayout.ScrollingViewBehavior()</strong><br/><strong>      }</strong><br/> }    </pre>
<p>The following is how the layout looks in our app:</p>
<div><img height="1282" width="722" src="img/a9d7e371-cd4e-4066-9c30-8c3567c14e18.jpeg"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p><kbd>lparams</kbd> is also an Anko extension function that is added to views, and we can define layout parameters as properties. If you omit width and/or height while using <kbd>lparams()</kbd>, their values automatically default to <kbd>wrapContent</kbd>, just like in XML. The parameters passed are named arguments. Some of the properties are <kbd>horizontalMargin</kbd>, <kbd>verticalMargin</kbd>, and <kbd>margin</kbd>. For different layouts, we have different layout parameters, just as in XML. For example, for relative layout, we have <kbd>alignParentBottom()</kbd>, <kbd>alignParentTop()</kbd>, <kbd>alignParentStart()</kbd>,<kbd>leftOf(viewIdOfReferenceView)</kbd>,<kbd>topOf(viewIdOfReferenceView)</kbd> and so on.</p>
<p>Check out the following example, which has the relative layout as root layout:</p>
<pre>class MainActivityUI : AnkoComponent&lt;MainActivity&gt; {<br/>    override fun createView(ui: AnkoContext&lt;MainActivity&gt;) =     with(ui) {<br/>        relativeLayout {<br/>            button("Ok") {<br/>                id = R.id.ok<br/>            }<strong>.lparams { leftOf() }<br/></strong><br/>            button("Cancel")<strong>.lparams { leftOf(R.id.ok) }<br/>            lparams(matchParent, matchParent)</strong><br/>        }<br/>    }<br/>}</pre>
<p>This is how the preceding layout looks:</p>
<div><img height="1282" width="722" src="img/e3d9375a-f000-462e-8451-c24a3885ed22.jpeg"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding listeners to Anko views</h1>
                
            
            
                
<p>We have event listeners on views in Android. Let's understand how Anko makes this easier by providing us with listener helpers.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn how to add an event listener to Anko views:</p>
<ol start="1">
<li>Let's start with a simple example where we listen for click events on a button. Here's the code for attaching an <kbd>onClick</kbd> listener on a button with the <kbd>btn_send</kbd> ID:</li>
</ol>
<pre style="padding-left: 60px">btn_send.onClick { toast("Hello there we have recorded your message!") }<br/></pre>
<ol start="2">
<li>The preceding code is the same as this:</li>
</ol>
<pre style="padding-left: 60px">var btn = find&lt;EditText&gt;(R.id.btn_send)<br/>btn.setOnClickListener(object : OnClickListener {<br/>    override fun onClick(v: View) {<br/>      toast("Hello there we have recorded your message!")<br/>    }<br/>})</pre>
<ol start="3">
<li>Now, let's create a layout having a button and a rating bar. We will attach an <kbd>onLongPress</kbd> listener on the button and an <kbd>onRatingBarChange</kbd> listener on the rating bar. Check out this code:</li>
</ol>
<pre style="padding-left: 60px">verticalLayout {<br/>    padding = dip(20)<br/>    val name = editText {<br/>        id = R.id.name<br/>        hint = "What is your name?"<br/>    }<br/><br/>    val message = editText {<br/>        id = R.id.message<br/>        hint = "Your message"<br/>    }<br/><br/>    button("Send") {<br/>        id = R.id.btn_send<br/>        <strong>onLongClick {</strong><br/><strong>            toast("Hello there we have recorded your message!")</strong><br/><strong>        }</strong><br/>    }<br/><br/>    var rating = ratingBar {<br/>        id = R.id.rating_bar<br/>        <strong>onRatingBarChange { ratingBar, rating, fromUser -&gt;</strong><br/><strong>            toast(rating.toString())</strong><br/><strong>        }</strong><br/>    }.lparams(wrapContent, wrapContent)<br/>}</pre>
<p>Focus on the bold text in the preceding code. We can attach listeners by directly putting them inside the defined views. This is how our layout looks:</p>
<div><img height="1282" width="722" src="img/f3ae98ad-9b75-44c7-9632-e1a10e0a98f7.jpeg"/></div>
<ol start="4">
<li>On long-pressing the button in the preceding screen with text SEND, we see a toast just as expected. Check out the following screen:</li>
</ol>
<div><img height="1282" width="722" src="img/a2c65883-314f-4693-82fe-682536df04a2.jpeg"/></div>
<ol start="5">
<li>Similarly, if we choose a rating from the rating bar, we get a toast for the rating that we chose.</li>
</ol>
<div><img height="1282" width="722" src="img/e419135c-3718-4975-a0c0-eed669200a16.jpeg"/>  <img height="1284" width="724" src="img/8fd219c1-7963-4e9d-9f93-a04814ce2d6e.jpeg"/></div>
<ol start="6">
<li>We can also keep the listeners separate from the layout, as in the following code. However, we do need the ID of the view we are setting the listener on for this to work:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    MainActivityUI().setContentView(this)<br/>    btn_send.onLongClick {<br/>        toast("Hello there we have recorded your message!")<br/>    }<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>Anko provides event listeners as extension functions to help ease the process of adding event listeners. We can also pass coroutines to these listener helpers and partially define listeners that have a lot of methods, that is, we can define each listener method separately and then they are merged by Anko if they are on the same view.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>Coroutines are used for writing asynchronous non-blocking code. You can also say that coroutines are threads managed by the user.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Inserting XML layouts into DSL</h1>
                
            
            
                
<p>Sometimes a situation may arise where we might need to include an XML layout inside a DSL layout. Anko provides a solution for this. In this recipe, we will understand how to include XML layouts into DSL.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+ as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn how to insert an XML layout into a DSL layout:</p>
<ol>
<li>To include an XML layout in a DSL, we use the <kbd>include()</kbd> method. We can add view properties to the view created using the <kbd>include()</kbd> method by simply adding <kbd>{}</kbd> and defining our view properties inside it. We can also add layout parameters to the view, just as we do it in DSL views. Check out the syntax given here:</li>
</ol>
<pre style="padding-left: 60px">include&lt;View&gt;(R.layout.layoutName) {<br/>    id = R.id.someId<br/>    hint = "Some hint"<br/>    text = "Some text"<br/>}.lparams() {}</pre>
<ol start="2">
<li>Let's create a layout in XML, which we will then include in our DSL layout. Let's create a button in a linear layout and save it in a file called <kbd>test.xml</kbd>. Check out the following code for the layout that we will save in <kbd>text.xml</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout <br/>    android:orientation="vertical"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:padding="10dp"&gt;<br/><br/>    &lt;Button<br/>        android:id="@+id/btn_test"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Send"<br/>        android:background="@color/colorAccent"<br/>        android:textColor="@color/white"/&gt;<br/>&lt;/LinearLayout&gt;</pre>
<ol start="3">
<li>The following is how our <kbd>test.xml</kbd> XML layout looks, a button with <kbd>10dp</kbd> space around it:</li>
</ol>
<div><img height="121" width="193" src="img/4db591eb-9f93-410c-b939-9587190c813f.png"/></div>
<ol start="4">
<li>Now you need to try to include the layout you just created in a DSL layout on your own. You can add the DSL layout to the activity's <kbd>onCreate()</kbd> method or in an external class that implements the <kbd>AnkoComponent</kbd> interface. Check out the following code for DSL layout (focus on the bold text in the given code):</li>
</ol>
<pre style="padding-left: 60px">verticalLayout {<br/>    padding = dip(20)<br/>    val name = editText {<br/>        id = R.id.name<br/>        hint = "What is your name?"<br/>    }<br/><br/>    val message = editText {<br/>        id = R.id.message<br/>        hint = "Your message"<br/>    }<br/><br/>    button("Send") {<br/>        id = R.id.btn_send<br/>        onClick {<br/>            toast("Hello there we have recorded your message!")<br/>        }<br/>    }<br/><br/>    <strong>include&lt;View&gt;(R.layout.test) {</strong><br/><strong>        backgroundColor = Color.CYAN</strong><br/><strong>    }.lparams(width = matchParent) { }</strong><br/>}</pre>
<p style="padding-left: 60px">This is how our layout looks after we include <kbd>test.xml</kbd> in our DSL:</p>
<div><img height="1282" width="722" src="img/9a9882dd-1c6a-450e-a8c7-94ed845f05bd.jpeg"/></div>
<ol start="5">
<li>We can attach listeners and get/set properties of included views by accessing them using Kotlin's synthetic properties, using Anko's <kbd>find()</kbd> method, or using the <kbd>findViewById()</kbd>. Each of the preceding methods needs the view to have an ID. Check out the following code for attaching an on-click listener on the button in <kbd>test.xml</kbd> that has a <kbd>btn_test</kbd> ID:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        MainActivityUI().setContentView(this)<br/>        <strong>btn_test.onClick {</strong><br/><strong>            toast("test click")</strong><br/><strong>        }</strong><br/>    }</pre>
<ol start="6">
<li>I have imported all views from <kbd>test.xml</kbd> by importing the synthetic properties of <kbd>test.xml</kbd>, as shown:</li>
</ol>
<pre style="padding-left: 60px">import kotlinx.android.synthetic.main.test.*</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting XML files into DSL</h1>
                
            
            
                
<p>If you are already an Anko fan and would love to port your old projects' XML to DSL without doing it manually, then this recipe will help you learn how to go about doing that.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's start by creating a blank activity and working on the XML layout to have something to convert to DSL. I have the following XML layout that I will convert to DSL next:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.design.widget.CoordinatorLayout <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context="android.my_company.com.helloworldapp.Main2Activity"&gt;<br/><br/>    &lt;android.support.design.widget.AppBarLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:theme="@style/AppTheme.AppBarOverlay"&gt;<br/><br/>        &lt;android.support.v7.widget.Toolbar<br/>            android:id="@+id/toolbar"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="?attr/actionBarSize"<br/>            android:background="?attr/colorPrimary"<br/>            app:popupTheme="@style/AppTheme.PopupOverlay" /&gt;<br/><br/>    &lt;/android.support.design.widget.AppBarLayout&gt;<br/><br/>    &lt;LinearLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:orientation="vertical"<br/>        android:gravity="center"&gt;<br/><br/>        &lt;TextView<br/>            android:id="@+id/text1"<br/>            android:text="@string/hello_calendar"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:layout_margin="@dimen/dp10"<br/>            style="@style/TextAppearance.AppCompat.Title"/&gt;<br/><br/>        &lt;CalendarView<br/>            android:id="@+id/calendarView"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="180dp"<br/>            android:layout_margin="@dimen/dp10"/&gt;<br/><br/>        &lt;Button<br/>            android:id="@+id/btn_done"<br/>            android:background="@color/colorAccent"<br/>            android:text="@string/done"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:layout_margin="@dimen/dp10"/&gt;<br/>    &lt;/LinearLayout&gt;<br/><br/>    &lt;android.support.design.widget.FloatingActionButton<br/>        android:id="@+id/fab"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:layout_gravity="bottom|end"<br/>        android:layout_margin="@dimen/fab_margin"<br/>        app:srcCompat="@android:drawable/ic_dialog_email" /&gt;<br/><br/>&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Showing Snackbar</h1>
                
            
            
                
<p>Snackbars are a great way to show feedback and messages to the users. Snackbars show a message at the bottom of a mobile or lower-left on larger devices. They can also have an action button. They automatically disappear after the timeout or after user interaction or if the user swipes on the snackbar.</p>
<div><img height="120" width="724" src="img/8a787462-2070-41ea-b6be-b5dad2112ea5.jpeg"/></div>
<p>In this recipe, we will learn how to easily show a Snackbar using Anko layouts. Showing Snackbars in the traditional way is a bit long; Anko makes it simpler to quickly show snackbars. Let's see how.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the below steps, we will learn how to show a snackbar using Anko library:</p>
<ol>
<li>Let's create a few buttons, each for different snackbars. We will create a snackbar inside the <kbd>onClick</kbd> listener of each button. Here are the syntaxes of some snackbars. I suggest you try to code this on your own before moving to the solution:</li>
</ol>
<pre style="padding-left: 60px">snackbar(parentView, "feedback message")<br/>snackbar(parentView, R.string.message_string)<br/>longSnackbar(parentView, "longer message")<br/>snackbar(parentView, "message for action snackbbar", "Action name") { doSomething() }</pre>
<ol start="02">
<li>Check out one possible solution:</li>
</ol>
<pre style="padding-left: 60px">verticalLayout {<br/>    id = R.id.rootView<br/>    padding = dip(20)<br/>    button("Simple Snackbar") {<br/>        id = R.id.btn_snack1<br/>        onClick {<br/>            snackbar(rootView, "Hey! I'm a simple snackbar.")<br/>        }<br/>    }<br/><br/>    button("Simple Snackbar using resources") {<br/>        id = R.id.btn_snack2<br/>        onClick {<br/>            snackbar(rootView, R.string.snack_message)<br/>        }<br/>    }<br/><br/>    button("Long Snackbar") {<br/>        id = R.id.btn_snack3<br/>        onClick {<br/>            longSnackbar(rootView, R.string.snack_message)<br/>        }<br/>    }<br/><br/>    button("Action Snackbar") {<br/>        id = R.id.btn_snack3<br/>        onClick {<br/>            longSnackbar(rootView, "Simple action snackbar rocks.",             "Action")<br/>            {<br/>                toast("Let us do some stuff!")<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>This is how the layout looks:</p>
<div><img height="1282" width="722" src="img/7568c19d-9994-4e89-a016-ddd5b36d760a.jpeg"/></div>
<p>The following screenshot is how a snackbar without an action button looks:</p>
<div><img height="1282" width="722" src="img/d50ce622-f5b4-4088-a528-5a692466ad5f.jpeg"/></div>
<p>This is the one with an action button:</p>
<div><img height="1282" width="722" src="img/076740a7-48f0-45e9-bab6-3bf02031e1d2.jpeg"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Showing Toasts</h1>
                
            
            
                
<p>Toasts are used to show feedback or message as a popup in android. Toasts automatically disappear after their timeout. Showing toasts in Anko is extremely easy. Let's see how.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting started</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's create a few buttons in our layout, clicking on them will show a toast:</p>
<ul>
<li>This is the syntax of toasts using Anko:</li>
</ul>
<pre style="padding-left: 60px">toast("a toast message")<br/>toast(R.string.message_string)<br/>longToast("a long duration toast message")</pre>
<p>I suggest that you try showing toasts on the click of a button on your own, before moving on to the solution. Let's make a layout with three buttons that show toast on clicking using the preceding syntaxes.</p>
<p>The following is one way of creating a layout with three buttons where we have put our code to show toast inside <kbd>onClick</kbd> listener of the buttons. You can also put your layout in an external class that implements the <kbd>AnkoComponent</kbd> interface:</p>
<pre>override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        verticalLayout {<br/>            id = R.id.rootView<br/>            padding = dip(20)<br/><br/>            button("Show toast") {<br/>                id = R.id.btn_snack1<br/>                onClick {<br/>                    toast( "Hey! Here is a toast for you.")<br/>                }<br/>            }<br/><br/>            button("Show toast using resource") {<br/>                id = R.id.btn_snack2<br/>                onClick {<br/>                    toast(R.string.toast_message)<br/>                }<br/>            }<br/><br/>            button("Show long toast") {<br/>                id = R.id.btn_snack3<br/>                onClick {<br/>                    longToast(R.string.toast_message)<br/>                }<br/>            }<br/>        }<br/>    }</pre>
<p>The following is how our layout looks, and how the toasts appear on clicking on buttons:</p>
<div><img height="1282" width="722" src="img/febd8d08-1b88-45c1-9bb5-46cfbf5841b6.jpeg"/>   <img height="1282" width="722" src="img/e547fbb8-eac8-4238-bc54-c56b7f2b59ef.jpeg"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Accessing views using synthetic properties</h1>
                
            
            
                
<p>So we know how Anko makes handling views and layouts easy, but Kotlin makes accessing views and getting/setting properties of views real fun. If you have tried using <kbd>findViewById()</kbd>, you already know how error-prone clunky code it is. There are a lot of libraries out there that provide a solution to this, but Kotlin provides a built-in plugin for this issue. Let's understand how to use that.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development. Ensure that you have added Anko layouts dependencies to your project (follow the recipe <em>Setting up Anko library for Anko layouts in gradle</em>,<em> </em>in this chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn how to access views using synthetic properties:</p>
<ol>
<li>Let's start with an XML layout and an activity that uses this XML layout. Start with creating a blank activity and create an XML layout that you wish to work with. I am working with the following layout file:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.design.widget.CoordinatorLayout<br/>    <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context="android.my_company.com.helloworldapp.HelloWorldActivity"&gt;<br/><br/>    &lt;android.support.design.widget.AppBarLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:theme="@style/AppTheme.AppBarOverlay"&gt;<br/><br/>        &lt;android.support.v7.widget.Toolbar<br/>            android:id="@+id/toolbar"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="?attr/actionBarSize"<br/>            android:background="?attr/colorPrimary"<br/>            app:popupTheme="@style/AppTheme.PopupOverlay" /&gt;<br/><br/>    &lt;/android.support.design.widget.AppBarLayout&gt;<br/><br/>    &lt;LinearLayout<br/>        <br/>        <br/>        <br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:orientation="vertical"<br/>        android:background="@color/white"<br/>        app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt;<br/><br/><br/>        &lt;EditText<br/>            android:id="@+id/name"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:hint="What is your name?"/&gt;<br/><br/>        &lt;EditText<br/>            android:id="@+id/message"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:hint="Your message"/&gt;<br/><br/>        &lt;Button<br/>            android:id="@+id/btn_send"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:text="Send"/&gt;<br/><br/>    &lt;/LinearLayout&gt;<br/><br/>&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre>
<ol start="2">
<li>To use synthetic properties of a view, we need to import them inside the activity, as follows:</li>
</ol>
<pre style="padding-left: 60px">import kotlinx.android.synthetic.main.<strong>xml_layout_name</strong>.*</pre>
<ol start="3">
<li>The following is how we can directly use view ID to provide reference to our view and get/set properties of the view:</li>
</ol>
<pre style="padding-left: 60px">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.activity_main2)<br/>    setSupportActionBar(toolbar)<br/><br/>    btn_send.onClick {<br/>        toast("Hey there ${name.text}. We have recorded your message.")<br/>    }<br/>}</pre>
<p>This is how our layout looks and works:</p>
<div><img height="1282" width="722" src="img/e4beab0f-4f11-4d22-a267-4ebb13ebda87.jpeg"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Accessing views of view groups using extension functions</h1>
                
            
            
                
<p>We can use extension functions to add new behaviors to a class that we may not even have access to. We can also add extension functions to view groups. One such view group is recycler view. Let's see how we can access views of a recycler view using extension functions.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Kotlin has some operators that we can use on a class. We will be overloading one of these operators to get views of our view group:</p>
<ol>
<li>We can access views of a view group by overloading the <kbd>get</kbd> operator like this:</li>
</ol>
<pre style="padding-left: 60px">operator fun ViewGroup.get(position: Int): View<br/>{<br/>    return getChildAt(position)<br/>}</pre>
<ol start="2">
<li>Now, in order to get a view from the view group, we can use either of the following methods:</li>
</ol>
<pre style="padding-left: 60px">val view = viewContainer.get(2)<br/>// where 2 is the position for the view we want to access</pre>
<ol start="3">
<li>Alternatively, use the following method because we used operator overloading, and <kbd>el.get(index)</kbd> matches with the array-like <kbd>el[index]</kbd> operation:</li>
</ol>
<pre style="padding-left: 60px">val view = viewContainer[2]<br/>// where 2 is the position for the view we want to access</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Extension functions provide the ability to add new functionalities to a class without modifying the class or inheriting it or using any design pattern. Extension functions are resolved statically and bear no connection with the class they extend.</p>
<p>By operator overloading, Kotlin gives us the ability to provide implementations of a predefined set of operators. To overload an operator, we can use a member function or an extension function, which we used in the preceding case.</p>


            

            
        
    </div>



  </body></html>