<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Activities and Fragments</h1></div></div></div><p>There are very few useful apps that run on just a single screen, or just use a single Activity; and we need a way to switch from one Activity to another and to pass information from one to another. Generally speaking, each new Activity will require its own layout file, but this not always the case; there are times when we want the same layout but with different data and resources. Later in this book, we will be building an app that acts as a tourist guide for some of the world's most famous and visited sites. We will start this journey by building a simple example for just one site that will include an introduction to the <code class="literal">CardView</code> widget introduced in Android 5, and learn how to start one Activity from another.</p><p>We will then take a look at Fragments which allow us to construct layouts in a modular fashion. Fragments behave a little like mini Activities and can be added to Activities dynamically at runtime or can be defined in a layout file like other ViewGroups. We will build a small timekeeping app that uses Fragments to switch between a digital and an analog clock face.</p><p>Next, we will include an Options menu in our app to allow the user to change time-and locale-related settings on their device. We will add action icons to the menu, so that it can be displayed <a id="id77" class="indexterm"/>on what was, prior to Lollipop, called the Action Bar. Finally, we will take advantage of the Action Bar's replacement, the Toolbar, customizing it so that it can be placed anywhere on a screen and contain far more functionality than its predecessor.</p><p>In this chapter, we will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add a <code class="literal">CardView</code></li><li class="listitem" style="list-style-type: disc">Give the <code class="literal">CardView</code> a layout</li><li class="listitem" style="list-style-type: disc">Add an image</li><li class="listitem" style="list-style-type: disc">Create a second Activity and Layout</li><li class="listitem" style="list-style-type: disc">Use XML to define <code class="literal">onClick</code> behavior</li><li class="listitem" style="list-style-type: disc">Program the two activities to work together</li><li class="listitem" style="list-style-type: disc">Use Fragments to dynamically change layouts</li><li class="listitem" style="list-style-type: disc">Explore the Translations Editor</li><li class="listitem" style="list-style-type: disc">Add static fragments with XML</li><li class="listitem" style="list-style-type: disc">Include an Options menu</li><li class="listitem" style="list-style-type: disc">Access user settings with intents</li><li class="listitem" style="list-style-type: disc">Add menu icons to the action bar</li><li class="listitem" style="list-style-type: disc">Replace the action bar with a custom toolbar</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Adding a CardView widget</h1></div></div></div><p>Unlike the views <a id="id78" class="indexterm"/>we have already met, <code class="literal">CardView</code> does not come included in the standard SDK libraries but rather as part of the (Lollipop specific) V7 Support Libraries and not available from the graphic layout design mode; therefore, it requires<a id="id79" class="indexterm"/> a little more work to apply one in a layout.</p><div><ol class="orderedlist arabic"><li class="listitem">Start a new Android project.</li><li class="listitem">Set the <strong>Application name:</strong> to <code class="literal">Stonehenge Guide</code>, although you can call it anything you like.</li><li class="listitem">Select the <strong>Phone and Tablet</strong> form factor and <strong>Blank Activity</strong> from the next page.</li><li class="listitem">Leave the other options as they are and wait for the project to build.</li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file in design view and delete the <code class="literal">"Hello World!"</code> text view that was automatically generated when we created the project.</li><li class="listitem">For completeness, also delete the <code class="literal">"Hello World!"</code> string resource in the <code class="literal">res/value/strings.xml</code> file.</li><li class="listitem">Edit the <code class="literal">styles.xml</code> (v21) file and create a <code class="literal">colors.xml</code> file to implement a Material Design color scheme, as we did in the last chapter.</li><li class="listitem">Open the <code class="literal">Gradle Scripts/build.gradle (Module: app)</code> file from the project explorer:<div><img src="img/B04321_03_01.jpg" alt="Adding a CardView widget"/></div></li><li class="listitem">Edit the <code class="literal">dependencies</code> section to match the following snippet:<div><pre class="programlisting">dependencies {
  compile fileTree(dir: 'libs', include: ['*.jar'])
  compile 'com.android.support:cardview-v7:22.0.+'
}</pre></div></li><li class="listitem">Synchronize<a id="id80" class="indexterm"/> the project via the toolbar icon shown here:<div><img src="img/B04321_03_02.jpg" alt="Adding a CardView widget"/></div></li><li class="listitem">Open <code class="literal">app/res/values/dimens.xml</code> and add the following three new dimension resources:<div><pre class="programlisting">&lt;dimen name="card_height"&gt;200dp&lt;/dimen&gt;
&lt;dimen name="card_corner_radius"&gt;4dp&lt;/dimen&gt;
&lt;dimen name="card_elevation"&gt;3dp&lt;/dimen&gt;</pre></div></li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file from <code class="literal">app/res/layout</code> and add the following <code class="literal">CardView</code> code, so that the finished layout looks like this:<div><pre class="programlisting">&lt;RelativeLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:paddingBottom="@dimen/activity_vertical_margin"
  android:paddingLeft="@dimen/activity_horizontal_margin"
  android:paddingRight="@dimen/activity_horizontal_margin"
  android:paddingTop="@dimen/activity_vertical_margin"
  tools:context=".MainActivity"&gt;

  <strong>&lt;android.support.v7.widget.CardView </strong>
    <strong>android:layout_width="match_parent"</strong>
    <strong>android:layout_height="@dimen/card_height"</strong>
    <strong>android:layout_gravity="center"</strong>
    <strong>card_view:cardCornerRadius="@dimen/card_corner_radius"</strong>
    <strong>card_view:cardElevation="@dimen/card_elevation"&gt;</strong>
  <strong>&lt;/android.support.v7.widget.CardView&gt;</strong>

&lt;/RelativeLayout&gt;</pre></div></li></ol></div><p>We created<a id="id81" class="indexterm"/> this project in very much the same way we did the last, and it is very useful to have initial activity and layout files created for us; this can save us a lot of time, when setting up most new projects.</p><p>As already mentioned, <code class="literal">CardView</code> is not a part of the standard libraries, which is why we had to include it in a build file, and we will have to do the same thing when we apply the other new Lollipop widget, <code class="literal">RecyclerView</code>. It is because of this that we had to <strong>Synchronize</strong> the project again, so that the build engine knows what libraries to load, in very much the same way that one might import a Java library. In this case, we could have just rebuilt  the project from the <strong>Build</strong> | <strong>Rebuild Project</strong> menu item, but this won't always be the case, and it is a good idea to get into the habit of a full synchronization, as this not only rebuilds our project but also checks for other possible errors such as missing resource definitions.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Note that, when we added values to the <code class="literal">dimens.xml</code> file, there is also a <code class="literal">dimens.xml (w820dp)</code> file. This is used when designing layouts for tablets and devices wider than 820 pixels, where the margins and padding we set for smaller devices might look wrong.</p></div></div><p>It will be immediately evident from examining the XML code for the <code class="literal">CardView</code>, that it is implemented in quite a different way from the widgets we have dealt with so far. Including elements from an external library like this is very straightforward, and although we will not be covering it in this book, it is useful to know that there are a number of third-party libraries available that include many features otherwise unavailable through the standard SDK.</p><p>The <code class="literal">CardView</code> comes with two properties exclusive to Lollipop that we have not yet come across: <code class="literal">cardCornerRadius</code> and <code class="literal">cardElevation</code>. The purpose of these properties is obvious, but it is worth noting that the effect of changing them does not show in the preview pane<a id="id82" class="indexterm"/> and that increasing elevation only affects the widget's shadow but not its size.</p><div><img src="img/B04321_03_03.jpg" alt="Adding a CardView widget"/></div><p>Having created a <code class="literal">CardView</code> as a container, it's now time to provide it with some content.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Adding images and text to the layout</h1></div></div></div><p>We will now use our <code class="literal">CardView</code> to display some basic information, namely a photo, a title and a short<a id="id83" class="indexterm"/> piece of text. To do this, you will need to<a id="id84" class="indexterm"/> locate where the studio stores your<a id="id85" class="indexterm"/> project files. This directory will be<a id="id86" class="indexterm"/> called <code class="literal">AndroidStudioProjects</code> and will more than likely be located in your Home directory or your specified save location.</p><div><ol class="orderedlist arabic"><li class="listitem">Locate your <code class="literal">AndroidStudioProjects</code> directory, and open the <code class="literal">\StonehengeGuide\app\src\main\res\drawable</code> folder. This can be done by right-clicking on the drawable in the project explorer and selecting <strong>Show in Explorer</strong> from the menu.</li><li class="listitem">Find an image and save it in the <code class="literal">drawable</code> directory. Any image will do; the one I use here is called <code class="literal">stonehenge.png</code> and is roughly 640 x 480 pixels.</li><li class="listitem">Open your <code class="literal">res/values/strings.xml</code> file and add the following strings:<div><pre class="programlisting">&lt;string name="title_text"&gt;Stonehenge&lt;/string&gt;
&lt;string name="detail_text"&gt;One of the most famous sites in the world, Stonehenge is a prehistoric monument located in Wiltshire, England, about 2 miles west of Amesbury and 8 miles north of Salisbury.&lt;/string&gt;</pre></div></li><li class="listitem">Open the <code class="literal">res/values/dimens.xml</code> file and add the following dimensions:<div><pre class="programlisting">&lt;dimen name="frame_width"&gt;160dp&lt;/dimen&gt;
&lt;dimen name="card_padding"&gt;8dp&lt;/dimen&gt;</pre></div></li><li class="listitem">We need to place a <code class="literal">RelativeLayout</code> inside our <code class="literal">CardView</code>. This is not possible <a id="id87" class="indexterm"/>from graphic design <a id="id88" class="indexterm"/>mode, so drag a <code class="literal">RelativeLayout</code> <a id="id89" class="indexterm"/>anywhere <a id="id90" class="indexterm"/>on the screen and then edit the XML code so that the card looks like this:<div><pre class="programlisting">&lt;android.support.v7.widget.CardView 
  
  android:id="@+id/main_card_view"
  android:layout_width="match_parent"
  android:layout_height="200dp"
  android:layout_gravity="center"
  card_view:cardCornerRadius="3dp"
  card_view:cardElevation="4dp"&gt;

  <strong>&lt;RelativeLayout</strong>
    <strong>android:layout_width="match_parent"</strong>
    <strong>android:layout_height="match_parent"</strong>
    <strong>android:padding="@dimen/card_padding"&gt;</strong>
  <strong>&lt;/RelativeLayout&gt;</strong>

&lt;/android.support.v7.widget.CardView&gt;</pre></div></li><li class="listitem">Next, we will populate this <code class="literal">RelativeLayout</code> with a <code class="literal">FrameLayout</code> containing an <code class="literal">ImageView</code> and two TextViews, so that it looks like this:<div><img src="img/B04321_03_04.jpg" alt="Adding images and text to the layout"/></div></li></ol></div><p>The<a id="id91" class="indexterm"/> best way to demonstrate the other <a id="id92" class="indexterm"/>settings and properties is with the<a id="id93" class="indexterm"/> full code for the <code class="literal">RelativeLayout</code> inside<a id="id94" class="indexterm"/> the <code class="literal">CardView</code>:</p><div><pre class="programlisting">&lt;RelativeLayout
  android:layout_height="match_parent"
  android:layout_width="match_parent"
  android:padding="@dimen/card_padding"&gt;

  &lt;FrameLayout
    android:id="@+id/frameLayout"
    android:layout_alignParentStart="true"
    android:layout_centerVertical="true"
    android:layout_height="match_parent"
    android:layout_width="@dimen/frame_width"&gt;

    &lt;ImageView
      android:clickable="false"
      android:id="@+id/imageView"
      android:layout_gravity="left|center_vertical"
      android:layout_height="wrap_content"
      android:layout_width="wrap_content"
      android:src="img/stonehenge" /&gt;
  &lt;/FrameLayout&gt;

  &lt;TextView
    android:id="@+id/title_text_view"
    android:layout_alignParentTop="true"
    android:layout_height="wrap_content"
    android:layout_marginLeft="@dimen/card_padding"
    android:layout_toEndOf="@+id/frameLayout"
    android:layout_width="wrap_content"
    android:text="@string/title_text"
    android:textAppearance="?android:attr/textAppearanceLarge" /&gt;

  &lt;TextView
    android:id="@+id/my_text_view"
    android:layout_below="@+id/title_text_view"
    android:layout_height="wrap_content"
    android:layout_marginLeft="@dimen/card_padding"
    android:layout_toEndOf="@+id/frameLayout"
    android:layout_width="wrap_content"
    android:text="@string/detail_text"
    android:textAppearance="?android:attr/textAppearanceSmall" /&gt;

&lt;/RelativeLayout&gt;</pre></div><p>As we saw, any image file placed within a <code class="literal">drawable</code> directory in our project, becomes accessible to <a id="id95" class="indexterm"/>us in the same way that other <a id="id96" class="indexterm"/>resources do. Images placed in this folder will<a id="id97" class="indexterm"/> be available to our apps, regardless <a id="id98" class="indexterm"/>of the device they are running on. You will have noticed that there are four other drawable directories, such as the <code class="literal">drawable-xxhdpi</code> folder. Theses are particularly useful when it comes to building apps to run on a wide variety of screen densities for two reasons. Firstly, they allow us to include high-quality images for users whose devices support such screens, and secondly, they can save memory on devices that have lower screen densities as Android only loads images that can be supported by each particular physical screen.</p><p>Most of the layout features we encountered here we already met in the previous chapters and there is not much to explain, other than perhaps the <code class="literal">ImageView</code>. It is worth noting that, as well as using <code class="literal">android:src</code> to associate our photo with the <code class="literal">ImageView</code>, we could also have used <code class="literal">android:background</code>, which performs a very similar function, although it does not respect the original aspect ratio of the image. Having created our Layout, we can now move on to adding another Activity.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Creating a second Activity</h1></div></div></div><p>So far, our app does<a id="id99" class="indexterm"/> nothing other than display information. So, next we will add some functionality by making it so that, when the user taps the image, a larger version of the picture will be<a id="id100" class="indexterm"/> shown in an another Activity. As you will see, creating new Activities with the Android Studio is very simple.</p><div><ol class="orderedlist arabic"><li class="listitem">Right-click the Java node of the project explorer and select <strong>New</strong> | <strong>Activity</strong> | <strong>Blank Activity</strong>.<div><img src="img/B04321_03_06.jpg" alt="Creating a second Activity"/></div></li><li class="listitem">In the resultant wizard, enter <code class="literal">ImageActivity</code> as the <strong>Activity Name:</strong>, <code class="literal">activity_image</code> as the <strong>Layout Name:</strong>, <code class="literal">image_menu</code> as the <strong>Menu Resource Name</strong>, and leave <strong>Title:</strong> as it is.</li><li class="listitem">Open the <code class="literal">activity_image.xml</code> file and place a single <code class="literal">ImageView</code> inside the layout, as below:<div><pre class="programlisting">&lt;ImageView
  android:id="@+id/large_image_view"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_centerHorizontal="true"
  android:layout_centerVertical="true"
  android:src="img/stonehenge"
  android:onClick="returnToMainActivity"/&gt;</pre></div></li><li class="listitem">Add the following string resource:<div><pre class="programlisting">&lt;string name="title_activity_image"&gt;Stonehenge&lt;/string&gt;</pre></div></li><li class="listitem">Open the <code class="literal">MainActivity</code> Java file and add the following code under the line <code class="literal">setContentView(R.layout.activity_main);</code> in the <code class="literal">onCreate()</code> method:<div><pre class="programlisting">ImageView mainImageView;
mainImageView = (ImageView) findViewById(R.id.imageView);

mainImageView.setOnClickListener(new View.OnClickListener() {

  @Override
  public void onClick(View v) {
    startActivity(new Intent(getApplicationContext(), ImageActivity.class));
  }

});</pre></div></li><li class="listitem">Open the <code class="literal">ImageActivity</code> Java file and add the following public method to the class:<div><pre class="programlisting">public void returnToMainActivity(View v) {
  startActivity(new Intent(getApplicationContext(), MainActivity.class));
}</pre></div></li><li class="listitem">Run the app on a device or an emulator.</li></ol></div><p>The new Activity wizard conveniently created both a Java Activity and a Layout XML file for us, but it is not always necessary to have a <code class="literal">Layout</code> file associated with every Activity. Often we can use the same layout for many Activities, providing each Java Activity has a way of selecting which data to access and display.</p><p>Without us <a id="id101" class="indexterm"/>realizing it, when we created our new Activity, the wizard also modified the manifest file to include the new Activity. It is worth taking a look at, because there will be times when you will not use the wizard to create an Activity and in such cases it will be necessary to modify the <code class="literal">AndroidManifest.xml</code> file by hand.</p><div><pre class="programlisting">&lt;activity
  android:name=".MainActivity"
  android:label="@string/app_name" &gt;
  &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;activity
  android:name=".ImageActivity"
  android:label="@string/title_activity_image" &gt;
&lt;/activity&gt;</pre></div><p>Our second Activity's Layout file contains just a single view, but there is a significant difference from the views we've explored so far, and this is the use of the <code class="literal">android:onClick</code> property. Previously we have used <code class="literal">View.OnClickListener()</code> to control how a widget behaves when clicked on. Declaring this in XML offers us an alternative way of doing this and although it lacks some of the flexibility of the Java version, it is simple and quick to use. All we had to do was declare the method called when the widget is clicked on and then add that method in Java, which here we called <code class="literal">returnToMainActivity()</code>.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>In the previous chapters, we had the user click on a <code class="literal">Button</code> widget and, although this seems like an obvious choice, it is well worth noting that almost any view or widget can respond to click events.</p></div></div><p>The <code class="literal">StartActivity()</code> method takes an <code class="literal">Intent</code> as its argument. This is a vital object in any Android app and is worth taking a quick look at, as it is not only essential when working with Activities but also services and broadcasts, which form the other two main components of most apps.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>
<strong>Services</strong> are similar to threads and run in the background and <strong>Broadcasts</strong> are system-wide <a id="id102" class="indexterm"/>messages that can potentially be received and acted upon by <a id="id103" class="indexterm"/>any app.</p></div></div><p>
<strong>Intents</strong> are<a id="id104" class="indexterm"/> basically descriptions of the operations we want our app to perform. They are formed of two parts, and action and the data to be acted upon. There are several <code class="literal">Intent()</code> constructors and here, we used <code class="literal">Intent(String action, Uri data)</code>. Being able to start one <a id="id105" class="indexterm"/>Activity from another is useful in many situations and here we set it in motion with a method, called by a click. There is of course, another familiar input feature that is found in nearly every mobile app, the menu, which is what we will look at next.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Applying Fragments</h1></div></div></div><p>Using two or <a id="id106" class="indexterm"/>more Activities to create separate screens is a straightforward way to include multiple pages in our apps. However, it is not the only method, and the system also provides the <strong>Fragment</strong> classes. Fragments are similar to ViewGroups; in that they exist as part of an Activity, but the way that they are created and destroyed makes them behave more like mini Activities. Unlike Activities, we can also have more than one Fragment to a screen.</p><p>There are two ways to deploy Fragments in an Android app. Firstly they can be added directly to our layout XML files with the <code class="literal">&lt;fragment&gt;</code> tag and they can also be added and removed dynamically at run time. Although we will now look at both these techniques, it is the second, dynamic method that makes Fragments so flexible and useful.</p><p>Along with the usual main Activity layout and code, each Fragment also has an XML and a Java component, making the coding a little more complex than when working with Activities alone. In the following exercise, we will create a simple app that lets us add and replace fragments during runtime.</p><div><ol class="orderedlist arabic"><li class="listitem">Start a new Android Studio project.</li><li class="listitem">Select the <strong>Blank Activity</strong> template (not <strong>Blank Activity with Fragment</strong>), call the project <code class="literal">Fragment Example</code>, or something like that, and open the <code class="literal">activity_main.xml</code> file.</li><li class="listitem">Change from a <code class="literal">RelativeLayout</code> to a <code class="literal">Linear</code> one by editing the code directly. The editor should change the closing tag to match as you type.</li><li class="listitem">Set a vertical orientation for the layout with this line:<div><pre class="programlisting">android:orientation="vertical"</pre></div></li><li class="listitem">Replace the <code class="literal">TextView</code> with these two buttons:<div><pre class="programlisting">&lt;Button
  android:id="@+id/button_analog"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:text="@string/button_analog_text" /&gt;

&lt;Button
  android:id="@+id/button_digital"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:text="@string/button_digital_text" /&gt;</pre></div></li><li class="listitem">Click <a id="id107" class="indexterm"/>on the line <code class="literal">android:text="Analog";</code> an amber quick fix will appear in the gutter, like below:<div><img src="img/B04321_03_07.jpg" alt="Applying Fragments"/></div></li><li class="listitem">Click on it select <strong>Extract string resource</strong>, and in the resultant dialog name the <a id="id108" class="indexterm"/>string <code class="literal">button_analog_text</code>.</li><li class="listitem">Do the same with the other button, calling it <code class="literal">button_digital_text</code>, and beneath these buttons add this <code class="literal">FrameLayout</code>:<div><pre class="programlisting">&lt;FrameLayout
  android:id="@+id/fragment_container"
  android:layout_width="match_parent"
  android:layout_height="match_parent" /&gt;</pre></div></li><li class="listitem">Right-click on the <code class="literal">layout</code> folder in the project explorer and select <strong>New</strong> | <strong>New resource file</strong>. Call it <code class="literal">fragment_analog</code> and give it a <code class="literal">RelativeLayout</code> root element, as follows:<div><img src="img/B04321_03_08.jpg" alt="Applying Fragments"/></div></li><li class="listitem">Open the<a id="id109" class="indexterm"/> file and insert this <code class="literal">AnalogClock</code> inside the root element:<div><pre class="programlisting">&lt;AnalogClock
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_centerHorizontal="true"
  android:layout_centerVertical="true" /&gt;</pre></div></li><li class="listitem">Select <code class="literal">fragment_analog.xml</code> in the project explorer and create a copy with <em>Ctrl</em> + <em>C</em> and <em>Ctrl</em> + <em>V</em>, naming the copy <code class="literal">fragment_digital.xml</code>.</li><li class="listitem">In this new file, replace the <code class="literal">AnalogClock</code> with this <code class="literal">TextClock</code>:<div><pre class="programlisting">&lt;TextClock
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_centerHorizontal="true"
  android:layout_centerVertical="true"
  android:textSize="48sp" /&gt;</pre></div></li><li class="listitem">Locate and select the folder that contains your <code class="literal">MainActivity.java</code> file in the project explorer. It will have the same name as your package.</li><li class="listitem">From its context menu, select <strong>New</strong> | <strong>Java Class</strong> and call it <code class="literal">FragmentAnalog</code>. Fill out the class like so:<div><pre class="programlisting">public class FragmentAnalog extends Fragment {

  @Override
  public View onCreateView(LayoutInflater inflater,
    ViewGroup container,
    Bundle savedInstanceState) {
    return inflater.inflate(R.layout.fragment_analog, container, false);
  }
}</pre></div></li><li class="listitem">Make a <a id="id110" class="indexterm"/>copy of this file and call it <code class="literal">FragmentDigital.java</code>.</li><li class="listitem">Change only the layout reference in the return statement:<div><pre class="programlisting">return inflater.inflate(R.layout.<strong>fragment_digital</strong>, container, false);</pre></div></li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file and change the class declaration so that it implements a click listener, like below:<div><pre class="programlisting">public class MainActivity extends Activity implements View.OnClickListener</pre></div></li><li class="listitem">This will generate an error and a red quick fix. Select <strong>Implement methods</strong> to add the <code class="literal">onClick()</code> method to the class.</li><li class="listitem">Add these <code class="literal">Button</code> fields to the class:<div><pre class="programlisting">private Button analogButton, digitalButton;</pre></div></li><li class="listitem">Include these four lines at the end of the <code class="literal">onCreate()</code> method:<div><pre class="programlisting">analogButton = (Button) findViewById(R.id.button_analog);
analogButton.setOnClickListener(this);
digitalButton = (Button) findViewById(R.id.button_digital);
digitalButton.setOnClickListener(this)</pre></div></li><li class="listitem">Complete the <code class="literal">onClick()</code> method like this:<div><pre class="programlisting">@Override
public void onClick(View v) {
  Fragment fragment;
  if (v == analogButton) {
    fragment = new AnalogFragment();
  } else {
    fragment = new DigitalFragment();
  }
  replaceFragment(fragment);
}</pre></div></li><li class="listitem">Implement the <code class="literal">replaceFragment()</code> method like below:<div><pre class="programlisting">public void replaceFragment(Fragment fragment) {
  FragmentManager manager = getFragmentManager();
  FragmentTransaction transaction = manager.beginTransaction();
  transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
  transaction.replace(R.id.fragment_container,fragment);
  transaction.addToBackStack(null);
  transaction.commit();
}</pre></div></li><li class="listitem">You <a id="id111" class="indexterm"/>can now run the app on a device or an emulator.<div><img src="img/B04321_03_09.jpg" alt="Applying Fragments"/></div></li></ol></div><p>We started this exercise by creating a simple layout, but we also used a handy shortcut to avoid having <a id="id112" class="indexterm"/>
<strong>hardcoded</strong> strings in our layouts. Doing this makes creating translated versions of our apps very simple and saves a lot of work when creating alternative layouts. It is not necessary for exercises such as those in this book to follow this practice, and to save time we will not concern ourselves with it further.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>The Translations Editor can be opened by right-clicking on the <code class="literal">res/values/strings.xml</code> file in the project explorer and selecting <strong>Open Translation Editor (Preview)</strong>. This editor makes translating Android apps very straightforward.</p></div></div><p>We also added an <a id="id113" class="indexterm"/>empty <strong>FrameLayout</strong> to serve as the container for our fragments we could have used any ViewGroup, but the FrameLayout is the simplest. Fragments are like Activities in that they have both an XML and a Java component, and here we created two very simple fragments just to see how they can be included and replaced dynamically. Fragments can of course contain many widgets and views, all of which can be interacted with in the usual ways and controlled with code in their respective Java files. Fragments, like Activities, have a life cycle and associated callbacks like the <code class="literal">onCreate()</code> method, and here we <a id="id114" class="indexterm"/>used <code class="literal">onCreateView()</code>, which is called when an attempt to inflate the Fragment is made. It is important to note that, although Fragments can, and usually do, contain all kinds of code, they should not communicate directly with each other. This should be done from the Activity containing them.</p><p>You will have noticed, that the way we<a id="id115" class="indexterm"/> implemented our <strong>OnClickListener</strong> here differed from the way we did in the previous chapter, where we implemented it directly on the view to be clicked on. Here, the OnClickListener is part of the whole class. This method is generally preferred and despite the small amount of extra work required to calculate which widget was clicked on, it is usually a far tidier solution, especially for very complex and interactive layouts.</p><p>
<strong>FragmentManager</strong> and <strong>FragmentTransaction</strong> are the tools we use to directly manipulate <a id="id116" class="indexterm"/>our Fragments. The first two lines, where these are defined, set the<a id="id117" class="indexterm"/> transaction in process, although no action is taken until <code class="literal">commit()</code> is called. We called <code class="literal">replace(layout, fragment)</code> to switch between our displays but we could also have used <code class="literal">add()</code> with the same arguments or <code class="literal">remove()</code> with only the Fragment.</p><p>The use of <code class="literal">addToBackStack()</code> is very important as, without it, a user pressing the back button on their device will be taken back to the previous Activity and not the previous Fragment, which, most of the time, will be what we want. Another interesting note is that the manager and transaction commands can be chained, and if we wanted we could replace all six lines with just this one:</p><div><pre class="programlisting">getFragmentManager().beginTransaction()
    .transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)
    .replace(R.id.fragment_container, fragment)
    .addToBackStack(null)
    .commit();</pre></div><p>The fade transition was not strictly necessary, as the system usually handles transitions between Activities and Fragments intelligently, but here there would have been none. There is a lot more that can be done with the FragmentManager and FragmentTransaction and the full <a id="id118" class="indexterm"/>documentation can be found at <a class="ulink" href="http://developer.android.com/reference/android/app/FragmentManager.html">developer.android.com/reference/android/app/FragmentManager.html</a> and <a class="ulink" href="http://developer.android.com/reference/android/app/FragmentTransaction.html">developer.android.com/reference/android/app/FragmentTransaction.html</a>. Next, we need to<a id="id119" class="indexterm"/> take a look at another way to apply Fragments in our apps.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Adding static Fragments</h2></div></div></div><p>We cannot complete this introduction to Fragments without looking quickly at the other way that they<a id="id120" class="indexterm"/> can be implemented,  as static layouts defined <a id="id121" class="indexterm"/>as <code class="literal">&lt;fragment&gt;</code> tags in XML files. Although these Fragments lack the flexibility of the dynamic sort we just encountered, they are nevertheless extremely useful, in particular when it comes to complex multi-pane apps where different Fragments perform very different functions. Not only does this help keep our code organized, it is also far less resource-hungry than a complicated network of nested ViewGroups.</p><p>To best see how this is done, start a project using the <strong>Blank Activity with Fragment</strong> template and take a look at the <code class="literal">activity_main.xml</code> file.</p><div><pre class="programlisting">&lt;fragment 
  
  android:id="@+id/fragment"
  android:name="com.example.kyle.staticfragmentexample.MainActivityFragment"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  tools:layout="@layout/fragment_main" /&gt;</pre></div><p>This demonstrates how a static Fragment can be included in a standard layout file. It shows which layout is to be inflated inside it with <code class="literal">tools:layout</code> and which Java class controls it with <code class="literal">android:name</code>. Several Fragments can be combined this way, along with ViewGroups and Views to create complex Activities.</p><p>It is worth taking a look at both Java classes and the other XML file in this template, to see how the other components work. You will be familiar now with most of it, due to the work we have just completed. Do not close the project just for now, as we are going to use it to see how to add a menu.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Adding menus and toolbars</h1></div></div></div><p>Nearly all mobile <a id="id122" class="indexterm"/>apps contain some form of global menu that provides access to<a id="id123" class="indexterm"/> functions required throughout the app. Menus can be opened in several ways on Android apps, but most commonly used is the <strong>Options menu</strong><a id="id124" class="indexterm"/> which is accessed from the toolbar or action bar. Options menu items can also appear on the toolbar, as text or graphically.</p><p>First, we will add a basic drop-down toolbar menu to implement the functions currently provided by the two buttons. Open the project from the <strong>Fragments</strong> section and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">res/menu/menu_main.xml</code> file.</li><li class="listitem">Replace the existing <code class="literal">&lt;item&gt;</code> tag with these three:<div><pre class="programlisting">&lt;item
  android:id="@+id/menu_date"
  android:orderInCategory="100"
  android:showAsAction="never"
 android:title="Date and Time" /&gt;

&lt;item
  android:id="@+id/menu_location"
  android:orderInCategory="100"
  android:showAsAction="never"
  android:title="Location" /&gt;

&lt;item
  android:id="@+id/menu_sleep"
  android:orderInCategory="100"
  android:showAsAction="never"
  android:title="Sleep" /&gt;</pre></div></li><li class="listitem">Menus <a id="id125" class="indexterm"/>can <a id="id126" class="indexterm"/>be previewed in the same way as the layouts, by opening the preview pane:<div><img src="img/B04321_03_10.jpg" alt="Adding menus and toolbars"/></div></li><li class="listitem">Open the <code class="literal">MainActivity</code> file and locate the <code class="literal">onOptionsItemSelected()</code> method.</li><li class="listitem">Rewrite it to look like this:<div><pre class="programlisting">@Override
public boolean onOptionsItemSelected(MenuItem item) {
  Fragment fragment;

  int id = item.getItemId();
  switch (id) {
    case R.id.menu_date:
      startActivity(new Intent(android.provider.Settings.ACTION_DATE_SETTINGS));
      break;
    case R.id.menu_location:
      startActivity(new Intent(android.provider.Settings.ACTION_LOCALE_SETTINGS));
      break;
    case R.id.menu_sleep:
      startActivity(new Intent(android.provider.Settings.ACTION_SOUND_SETTINGS));
      break;
  }

  return super.onOptionsItemSelected(item);
}</pre></div></li><li class="listitem">Run the<a id="id127" class="indexterm"/> app<a id="id128" class="indexterm"/> on a device and use the menu to open date, locale, and volume settings.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Adding menu items to the menu XML files</h2></div></div></div><p>Each item<a id="id129" class="indexterm"/> requires a title and an ID. We can change the order the items appear in with the <code class="literal">orderInCategory</code> attribute with ascending integer values ordering items from top to bottom (and left to right on the toolbar). Menu items can be categorized and ordered separately by nesting them inside <code class="literal">&lt;group&gt;</code> tags.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>Sub-menus can be created by embedding a <code class="literal">&lt;menu&gt;</code> tag, with its own items inside an <code class="literal">&lt;item&gt;</code> tag.</p></div></div><p>As we will see shortly, menu items can be displayed on the toolbar in the same way they were on the Action bar in versions of Android older that API 21. This can be done with the <code class="literal">showAsAction</code> attribute; if you still have the project open, it is worth running the app again with this value set to <code class="literal">always</code> and <code class="literal">ifRoom</code>, to see the effect this has. Doing this simply moves our menu options to the bar, but we can also use icons to represent our options; this, along with the new features of the Android 5 toolbar, is what we will explore next.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Configuring the toolbar</h2></div></div></div><p>As already <a id="id130" class="indexterm"/>mentioned, Android 5 introduced a replacement for the Action bar at the top of many app screens: the toolbar. The toolbar does performs all the same functions as its predecessor, such as displaying menu options and other frequently performed actions, but is far more customizable. Most interestingly, the toolbar can now be placed anywhere on the screen.</p><p>In this next exercise, we will add our menus to the toolbar as icons; include navigation, logo, and titles on the toolbar; and then place it at the bottom of our screen.</p><p>Toolbar icons need to comply with some specific material design guidelines, a complete guide to which can be found at <a class="ulink" href="http://www.google.com/design/spec/style/icons.html">http://www.google.com/design/spec/style/icons.html</a>. Basically, they need to be simple, single-color symbols on a transparent background. To begin with, you can download purpose-built system icons for specific screen densities from <a class="ulink" href="http://www.google.com/design/icons/">http://www.google.com/design/icons/</a>. Below are the three that were download for this project, along with the names used in the next exercise.</p><div><img src="img/B04321_03_11.jpg" alt="Configuring the toolbar"/></div><p>Download or find something similar of a pixel density that is suitable for the devices you are developing for. Then carry out the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project we were just working on and copy your icons into the <code class="literal">drawable</code> folder.</li><li class="listitem">Open the <code class="literal">menu_main.xml</code> file and add the following line into the <code class="literal">menu_date</code> item:<div><pre class="programlisting">android:icon="@drawable/time"</pre></div></li><li class="listitem">Do the same for the location and sleep icons in their respective item tags.</li><li class="listitem">Change all three items' <code class="literal">android:showAsAction</code> attribute from <code class="literal">"never"</code> to <code class="literal">"ifRoom"</code>.</li><li class="listitem">If you wish to see how your brand colors will appear against your action icons, apply a material theme as we have before, and run the app to see how your icons look.<div><img src="img/B04321_03_12.jpg" alt="Configuring the toolbar"/></div></li><li class="listitem">Now open the <code class="literal">main_activity.xml</code> file.</li><li class="listitem">Insert<a id="id131" class="indexterm"/> this <code class="literal">Toolbar</code> above the two buttons:<div><pre class="programlisting">&lt;Toolbar 
  android:id="@+id/toolbar"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:background="?android:attr/colorPrimary"
  android:elevation="4dp"
  android:minHeight="?android:attr/actionBarSize" /&gt;</pre></div></li><li class="listitem">Open the <code class="literal">res/values/styles/styles.xml (v21)</code> file and edit the <code class="literal">AppTheme</code> definition like this:<div><pre class="programlisting">name="AppTheme" parent="android:Theme.Material.Light.<strong>NoActionBar</strong>"</pre></div></li><li class="listitem">You will need another image for the logo here. This does not have to be plain and simple but should not contain text, and it should be around 96 x 96 px, depending on your device's pixel density. If you want to save time, use one of the other images in the <code class="literal">setLogo()</code> command in step 11.</li><li class="listitem">Open the <code class="literal">MainActivity</code> file and add this field:<div><pre class="programlisting">Private Toolbar toolbar;</pre></div></li><li class="listitem">Then, add these lines to the <code class="literal">onCreate()</code> method:<div><pre class="programlisting">toolbar = (Toolbar) findViewById(R.id.toolbar);
setActionBar(toolbar);
getActionBar().setTitle("Clock");
toolbar.setSubtitle("tells the time");
toolbar.setLogo(R.drawable.clock_logo);</pre></div></li><li class="listitem">In the <code class="literal">activity_main.xml</code> file, remove the padding from the root layout.</li><li class="listitem">That's it. You <a id="id132" class="indexterm"/>can now run the app, with an output something like this:<div><img src="img/B04321_03_13.jpg" alt="Configuring the toolbar"/></div></li></ol></div><p>Adding option menu items to the action bar is done simply by setting <code class="literal">showAsAction</code> to <code class="literal">ifRoom</code> or <code class="literal">always</code>, and we could have included both text and icon with <code class="literal">withText</code>. This provides a handy way to present options to the user, but it is transformed into a far more powerful tool once we can define it in a layout and refer to it from Java. This means we can place it anywhere on our screen and place anything inside it. We could add an <code class="literal">ImageView</code> or <code class="literal">Button</code>, simply by adding that element inside the <code class="literal">Toolbar</code> element in XML. Once we have a reference in Java, we can add click listeners or any other method, just as we<a id="id133" class="indexterm"/> can with other components.</p><p>We needed to remove the original action bar by changing the theme to <code class="literal">Material.Light.NoActionBar</code>, although we could have kept it and added a toolbar and of course, we can have two or more toolbars, perhaps even contained in a <code class="literal">Fragment</code> and replacing each other to create a more dynamic interface. We also had to remove padding from the parent layout, so as to have it plush to the edges like a traditional action bar and we set its elevation so that it looks like the action bar we are used to.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>We have covered a lot in this chapter, starting with an introduction to the <code class="literal">CardView</code> widget and the new features incorporated in Android 5, such as the ability to elevate it and other views so that they appear to float above the screen. We saw how to add image files to a project and how we can optimize such images so as to efficiently match the screen density of the user's device. We saw how to include new Activities and how to use XML (as well as Java) to control how widgets and views behave when clicked on. The chapter also covered one of the many ways that Activities can communicate with one another.</p><p>We went on to explore another way to add flexibility to our apps with the <code class="literal">Fragment</code> classes which have much of the functionality of Activities but can be combined in one layout and treated like ViewGroups.</p><p>Finally, we investigated the relationship between <strong>Options menu</strong> and the action bar and saw how the toolbar introduced in Android 5 can be thought of as a part of our activity rather than a fixed widget stuck to the top of it.</p><p>Having grasped some of the more important fundamentals of Android programming, we can now go on to consider how to build more sophisticated apps that incorporate larger data sets, and how to utilize more of the technologies found in today's mobile devices.</p></div></body></html>