<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Sprites</h1></div></div></div><p>In the previous chapter, we set up our first scene, learned about the rendering of nodes in a scene, added multiple scenes in a project, and learned about doing transitions from one scene to another.</p><p>In this chapter, we will learn about sprites. A sprite<a id="id106" class="indexterm"/> is a two-dimensional image, integrated into scene. A collection of sprites is called <a id="id107" class="indexterm"/>
<strong>sprite sheet</strong>. Here we will learn about how to add sprites in a game, positioning a sprite, texture atlases, and how to transform a sprite in our game.</p><p>In Sprite Kit, a game is based on the node tree hierarchy. Scene<a id="id108" class="indexterm"/> acts as a root node and other nodes added to it are child nodes. Once all nodes are rendered into scene, we get the view. Sprites are also added to a game as a node; Sprite Kit provide us <code class="literal">SKSpriteNode</code> class for this purpose. In the previous chapter, we added background sprite and play button sprite by making the <code class="literal">SKSpriteNode</code> reference and adding it to the respective scenes. Now we will discover more about what Sprite Kit provided us in the <code class="literal">SKSpriteNode</code> class, and what else we can do with it.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>SKSpriteNode</h1></div></div></div><p>The <code class="literal">SKSpriteNode</code> class<a id="id109" class="indexterm"/> is a root node class which is used to draw texture images with many customizations; it is inherited from the <code class="literal">SKNode</code> class. We can simply draw an image, or we can add some effects, such as custom shader or shadows to it. For this, we have to first know about the <code class="literal">SKSpriteNode</code> class and the functionality it offers.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Initializing a sprite</h2></div></div></div><p>To make a sprite in a<a id="id110" class="indexterm"/> game, we have to make an instance of the <code class="literal">SKSpriteNode</code> class. Sprite Kit<a id="id111" class="indexterm"/> provides us with many ways to initialize an instance of the <code class="literal">SKSpriteNode</code> class. Some of them are as follows:</p><div><pre class="programlisting">init(name: String){
  //it is designated initializer . initialization part

}
convenience init(){
  //Calling the Designated Initializer in same class
  self.init(name: "Hello")
}</pre></div><p>In Swift, one has to initialize a class by making an object of structure. There are two initializers provided for this purpose, that is, designated initializers and convenience initializers.</p><p>Designated initializers perform actual initialization for class properties. Now the question arises, "why convenience initializers are required?" During programming, sometimes, convenience initializers are very useful as they require less input parameters, and hand over actual initialization to designated initializers.</p><p>Some examples of initializers<a id="id112" class="indexterm"/> in Swift are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">convenience init(color color:UIColor!, size size: CGSize)</code>: This is used to initialize a <a id="id113" class="indexterm"/>colored sprite. If you want to make a sprite without using any texture and only by color, you can use this. It takes color and size as a parameter and returns a newly initialized sprite object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">convenience init(imageNamed name: String)</code>: This initializer assigns texture to sprites. A sprite will be assigned texture from image name, which initializes the color of a sprite to white.</li><li class="listitem" style="list-style-type: disc"><code class="literal">convenience init(texture texture: SKTexture!)</code>: This initializer takes an existing texture sprite and returns a newly initialized sprite. The size of the sprite is set to the dimensions of the texture, and the color of the sprite is set to white <code class="literal">(1.0, 1.0, 1.0)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init(texture texture: SKTexture!,color color: UIColor!,size size: CGSize)</code>: As explained earlier, this initializer requires convenience initializers as its parameter, so this is a designated initializer. Now, our <em>Platformer</em> game sprite will be initialized to the desired texture, color, and size. It returns a newly initialized sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">convenience init(texture texture: SKTexture!,size size: CGSize)</code>: This takes texture and size as parameters and returns a newly initialized sprite. </li><li class="listitem" style="list-style-type: disc"><code class="literal">convenience init(imageNamed name: String, normalMapped generateNormalMap: Bool)</code>: This takes an image name and a Boolean value as a parameter and returns a newly initialized object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">convenience init(texture texture: SKTexture!,normalMap normalMap: SKTexture?)</code>: This <a id="id114" class="indexterm"/>takes two textures as parameters, one<a id="id115" class="indexterm"/> for sprite drawing and another for adding lighting behavior to the sprite. It returns a newly initialized sprite.</li></ul></div><p>After learning about<a id="id116" class="indexterm"/> initialization of <code class="literal">SKSpriteNode</code>, now it is time to get <a id="id117" class="indexterm"/>ourselves familiar with some physical properties of <code class="literal">SKSpriteNode</code>, such as <code class="literal">size</code>, <code class="literal">anchorPoint</code>, and so on.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>The properties of SKSpriteNode</h1></div></div></div><p>Let us discuss the <a id="id118" class="indexterm"/>properties of <code class="literal">SKSpriteNode</code> in the following sections.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Physical</h2></div></div></div><p>Let us look at some physical properties<a id="id119" class="indexterm"/> of<code class="literal"> SKSpriteNode</code>: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">size</code>: This property<a id="id120" class="indexterm"/> determines the size of a sprite in points. In our <code class="literal">GameScene</code> and <code class="literal">MenuScene</code> classes, we use this property in the background sprite to cover the screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AnchorPoint</code>: An anchor <a id="id121" class="indexterm"/>point is a point of co-ordinate related to sprite. Say, for example, co-ordinates for each corner of a sprite are <code class="literal">(0,0)</code>, <code class="literal">(1,0)</code>, <code class="literal">(0,1)</code>, and <code class="literal">(1,1)</code> representing corners bottom left, bottom right, top left, and top right respectively. These points of reference can be assigned as anchor points to draw a sprite on screen in respect. An assigned anchor point will position a sprite on screen, accordingly.<p>For example, assume that our anchor point for a sprite is <code class="literal">(0,0)</code>. If we position this sprite on screen, it will place itself from co-ordinate <code class="literal">(0,0)</code>, that is, bottom left. To position a sprite from the centre, we need to assign the anchor point co-ordinate <code class="literal">(0.5, 0.5)</code>.</p></li></ul></div><p>But to add another node to<a id="id122" class="indexterm"/> this sprite, co-ordinate <code class="literal">(0,0)</code> of that node will be on the sprite's anchor point. What happens when we add scene to the view is that, co-ordinate <code class="literal">(0,0)</code> of scene, becomes the default anchor point.</p><p>Physical properties of a sprite were well discussed under <code class="literal">size</code> and <code class="literal">anchorPoint</code>. Now it is time to discuss some properties which are related to texture in a sprite.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Texture</h2></div></div></div><p>It is an optional <a id="id123" class="indexterm"/>property in the <code class="literal">SKSpriteNode</code> class; that means it can be nil or will have texture. If it is nil, then the sprite will be drawn by using its <code class="literal">color</code> property in a rectangular shape, otherwise the sprite will be drawn using this texture.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>centerRect</h2></div></div></div><p>This property is a very useful <a id="id124" class="indexterm"/>tool for creating rectangular buttons or any other fixed size elements in scene. When you use the <code class="literal">centerRect</code> property, you are actually controlling the scaling factor of texture for a rectangular portion specified by coordinates.</p><p>By default, the rectangle covers the whole texture; that's why entire texture is stretched. But if this rectangle covers only a portion of the texture, then the texture could be visualized in a <code class="literal">3 * 3</code> grid, accounting this rectangle in the middle of the grid and drawing a line from its every edge on each side.</p><div><img src="img/4201_03_03.jpg" alt="centerRect"/><div><p>Original image</p></div></div><p>If we try to stretch the<a id="id125" class="indexterm"/> texture in both directions, then it will follow the rules given as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The middle portion of the grid will stretch on each side, horizontally and vertically</li><li class="listitem" style="list-style-type: disc">All 4 corner portions of the grid will not be stretched</li><li class="listitem" style="list-style-type: disc">The upper and lower middle parts of the grid will be stretched horizontally<div><img src="img/4201_03_05.jpg" alt="centerRect"/><div><p>Image stretched horizontally from the centre</p></div></div></li><li class="listitem" style="list-style-type: disc">The left and right middle parts of the grid will be stretched vertically<div><img src="img/4201_03_04.jpg" alt="centerRect"/><div><p>Image stretched vertically from the centre</p></div></div></li></ul></div><p>And, the following is another case where the image is stretched both vertically and horizontally:</p><div><img src="img/4201_03_06.jpg" alt="centerRect"/><div><p>Image stretched both vertically and horizontally from the centre</p></div></div><p>This is a very useful <a id="id126" class="indexterm"/>property to achieve some specific behavior of texture, such as making a health bar in the game, where we don't want to stretch the corner side of the texture, so that if they are rounded, they should not be deformed.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Color</h2></div></div></div><p>
<code class="literal">SKSpriteNode</code> has some color properties<a id="id127" class="indexterm"/> too. Let's read in detail about them:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">color</code>: This<a id="id128" class="indexterm"/> property is used to give color to a sprite. For example, you need to change the color of your sprite when the health bar is reduced to 50 percent, 25 percent, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">colorBlendFactor</code>: This is <a id="id129" class="indexterm"/>used to control the color blending with the sprite texture. It can have a value between <code class="literal">0.0</code> to <code class="literal">1.0</code> (inclusive); <code class="literal">0.0</code> is default. If the value is <code class="literal">0.0,</code> that means the <code class="literal">color</code> property is ignored and texture values are used unmodified. If you increase the value, more color will be added to the sprite. For example, we can use this property to blend more color in our character with an increasing number of hits to the character:<div><img src="img/4201_03_07.jpg" alt="Color"/><div><p>Color effects due to change in value for colorBlendFactor</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">blendMode</code>: This<a id="id130" class="indexterm"/> property is used to blend <a id="id131" class="indexterm"/>sprites according to scene. Every pixel color of a sprite and the color of the corresponding scene pixel under it, is compared by Sprite Kit renderer to assign a resulting color to the sprite. This property is very useful when you add a lighting effect or flash effect to your scene.</li></ul></div><p>In iOS 8, some lighting properties were added to generate a light and shadow effect on the sprites. Let's have a look at them:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">lightingBitMask</code>: This <a id="id132" class="indexterm"/>property is<a id="id133" class="indexterm"/> used to show a lighting effect on the sprite, and is tested against light's <code class="literal">categoryBitMask</code> property by a logical AND operation. If the value is nonzero, the sprite will light up, or else it will remain unaffected by the light. Its default value is <code class="literal">0x00000000</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">shadowedBitMask</code>: This <a id="id134" class="indexterm"/>determines whether the sprite will be affected by the shadow generated by the light or not. This property is tested against light's <code class="literal">categoryBitMask</code> property by a logical AND operation. If the value is nonzero, the sprite will the drawn using a shadowed effect, or else it will remain unaffected by the light. Its default value is <code class="literal">0x00000000</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">shadowCastBitMask</code>: This<a id="id135" class="indexterm"/> determines whether or not the sprite will block the light and cast the shadow. This property is tested against light's <code class="literal">categoryBitMask</code> property by a logical AND operation. If the value is nonzero, the sprite will cast a shadow past itself, or else it will remain unaffected by the light. Its default value is <code class="literal">0x00000000</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">normalTexture</code>: A<a id="id136" class="indexterm"/> normal map texture is used when a sprite is lit, giving it a more realistic look with shadows and spectacular highlights. The texture must be a normal map texture.</li></ul></div><p>Along with the <a id="id137" class="indexterm"/>lighting property, with iOS 8, the shader property was also introduced to customize the rendering effects.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Shader</h2></div></div></div><p>The shader property<a id="id138" class="indexterm"/> is exclusively discussed in <a class="link" href="ch07.html" title="Chapter 7. Particle Effects and Shaders">Chapter 7</a>, <em>Particle Effects and Shaders</em>.</p><p>These are <code class="literal">SKSpriteNode</code> properties, by which we can use sprites by customizing them as we desire. The majority of a game consists of sprites, so it is important to know these properties and how we can use them. Now, it is time to use these properties in our game and see what effects they produce.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Adding a sprite without using textures</h1></div></div></div><p>Mostly in a game, we<a id="id139" class="indexterm"/> add texture to our sprite, but we can also make a sprite without using textures. A texture property is an optional property in the <code class="literal">SKSpriteNode</code> class. If texture is nil, that means we have no texture to stretch, so the contract parameter is ignored. Let's open our <code class="literal">GameScene.swift</code> file and make a variable of <code class="literal">SKSpriteNode</code>, just below the <code class="literal">backgroundNode</code> declaration:</p><div><pre class="programlisting">var spriteWithoutTexture : SKSpriteNode?</pre></div><p>Now, with the preceding declaration, we have declared <code class="literal">spriteWithoutTexture</code> as optional. Since we have declared it optional, texture need not require a value. Now under <code class="literal">didMoveToView</code>, add following function:</p><div><pre class="programlisting">  func addSpriteWithoutTexture(){
    spriteWithoutTexture = SKSpriteNode(texture: nil, color: UIColor.redColor(), size: CGSizeMake(100, 100))
    addChild(spriteWithoutTexture!)
  }</pre></div><p>After that, call this function inside <code class="literal">didMoveToView()</code>, below the <code class="literal">addBackGround()</code> function:</p><div><pre class="programlisting">addSpriteWithoutTexture()</pre></div><p>Now tap on play and see what happens. In our <code class="literal">GameScene</code> there is no change. Well that's not what we desire. Actually, we missed the <code class="literal">z</code> position of our texture. That's why it is rendering behind the background and not showing to us. Add this line in our <code class="literal">addSpriteWithoutTexture()</code> function, before <code class="literal">addChild(spriteWithoutTexture!)</code>:</p><div><pre class="programlisting">spriteWithoutTexture!.zPosition=1;</pre></div><p>Run it. You will see a red square in the middle of the screen.</p><p>The code is self-explanatory. We made an instance of <code class="literal">SKSpriteNode</code> by instantiating it. We are passing nil as parameter for texture, meaning we don't want texture for this sprite. As we have made this sprite reference optional, we will have to unwrap it before using any <code class="literal">SKSpriteNode</code> properties, and we do so by using the <code class="literal">!</code> mark after <code class="literal">spriteWithoutTexture</code>.</p><p>We can also initialize <a id="id140" class="indexterm"/>in another way. Delete the <code class="literal">texture</code> parameter from the initialization part:</p><div><pre class="programlisting">spriteWithoutTexture = SKSpriteNode(texture: nil, color: UIColor.redColor(), size: CGSizeMake(100, 100))</pre></div><p>Change the preceding initialization part as shown in the following:</p><div><pre class="programlisting">spriteWithoutTexture = SKSpriteNode(color: UIColor.redColor(), size: CGSizeMake(100, 100))</pre></div><p>Run the code and it will produce the same result as the previous one. It automatically assigns nil to texture, and initializes a sprite with a color and the specified bounds. Let's do something interesting with it.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Changing the color property</h2></div></div></div><p>We are going to use <a id="id141" class="indexterm"/>
<code class="literal">color</code> property to change color when a user taps on this sprite. For this, first give a name to <code class="literal">spriteWithoutTexture</code>, so that we can recognize a tap on it:</p><div><pre class="programlisting">spriteWithoutTexture!.name = "HELLO"</pre></div><p>Add the following function in the <code class="literal">GameScene.swift</code> file to change color, as shown in the following code:</p><div><pre class="programlisting">var </pre></div><p>Now, we use the <code class="literal">touchesBegan</code> function to detect touch by a user (as it was used previously in the <code class="literal">MenuScene</code> class):</p><div><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
   for touch: AnyObject in touches{ currentno = 0;
func changeColor(){
    switch(currentno%3){
    case 0:
        spriteWithoutTexture!.color = UIColor.redColor()
    case 1:
        spriteWithoutTexture!.color = UIColor.greenColor()
    case 2:
        spriteWithoutTexture!.color = UIColor.blueColor()
    default :
        spriteWithoutTexture!.color = UIColor.blackColor()

    }
}

       let location = touch.locationInNode(self)
       let node = self.nodeAtPoint(location)
                    if node.name == spriteWithoutTexture!.name {
                        currentno++
                        changeColor()
                    }
   }
}</pre></div><p>Now, after running <a id="id142" class="indexterm"/>Xcode, click on the colorful area in <code class="literal">GameScene</code>. You will see that area changing its color.</p><p>In this code, when a user taps on the sprite, it will add a value to the current one and call the <code class="literal">changeColor()</code> function. In the <code class="literal">changeColor()</code> function, we have taken a <code class="literal">switch</code> case to determine the color property of <code class="literal">spriteWithoutTexture</code>. In Swift, <code class="literal">switch</code> case is used as in many other languages. We don't have to use the <code class="literal">break</code> statement. Every <code class="literal">switch</code> statement must be <em>exhaustive</em>. That means, we have to make every single case check for switch case. Hence, we have to write a <code class="literal">default</code> value for every switch case.</p><p>If our texture is not nil, we can use the <code class="literal">colorBlendFactor</code> property to colorize the texture. We can use it for a tinting effect, such as damage taken in the game; <code class="literal">colorBlendFactor</code> is ignored if texture is nil. Its default value is <code class="literal">0.0</code>, which means that the texture should<a id="id143" class="indexterm"/> remain unmodified. When we increase the value, texture color is replaced with the blended color.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Changing colorBlendFactor in MenuScene</h2></div></div></div><p>Let's add a tint to our <a id="id144" class="indexterm"/>play button. Open <code class="literal">MenuScene</code> and define a variable named <code class="literal">tintChanger</code> inside the <code class="literal">MenuScene</code> class as optional <code class="literal">Float</code>, so that we won't need to assign a value to it in the initializer: </p><div><pre class="programlisting">var tintChanger : Float?</pre></div><p>Add the following function in the <code class="literal">MenuScene</code> class:</p><div><pre class="programlisting">func tintPlayButton(){
    if PlayButton.colorBlendFactor &gt;= 1{
        tintChanger = -0.02
    }
    else if PlayButton.colorBlendFactor &lt;= 0{
        tintChanger = 0.02
    }
    PlayButton.colorBlendFactor += CGFloat(tintChanger!)
}</pre></div><p>Call it from the <code class="literal">update</code> function:</p><div><pre class="programlisting">override func update(currentTime: NSTimeInterval) {
     tintPlayButton()
}</pre></div><p>Now run Xcode. You will see the <strong>Play</strong> button appearing and disappearing respectively.</p><p>In this code, we just make a <code class="literal">Float</code> type variable. In our <code class="literal">tintPlayButton</code> function, we check if the value of its <code class="literal">colorBlendFactor</code> property is between <code class="literal">1</code> to <code class="literal">0</code>.</p><p>Now let's give it a color, inside the <code class="literal">addChildToScene</code> function:</p><div><pre class="programlisting">  PlayButton.color = UIColor.redColor()</pre></div><p>Run it and you will see the <strong>Play</strong> button changing its color from the original one to reddish. Now, it's time to see the position property in action.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Changing the position of a sprite</h2></div></div></div><p>Now, have a look at <a id="id145" class="indexterm"/>the <code class="literal">position</code> property of <code class="literal">SKSpriteNode</code>. Let's open <code class="literal">GameScene</code> again, as we are going to see the <code class="literal">spriteWithoutTexture.position</code> property and the ways we can set it. Add this function below <code class="literal">changeColor</code>:</p><div><pre class="programlisting">func changePosition(){
    switch(currentno%3){
    case 0:
        spriteWithoutTexture!.position = CGPointZero

    case 1:
        spriteWithoutTexture!.position = CGPointMake(self.size.width/2-spriteWithoutTexture!.size.width/2, 0)
    case 2:
        spriteWithoutTexture!.position = CGPointMake
        (-self.size.width/2+spriteWithoutTexture!.size.width/2, 0)
    default :
        spriteWithoutTexture!.position = CGPointMake(0, 0)

    }
}</pre></div><p>And call it just below the <code class="literal">changeColor()</code> call.</p><div><pre class="programlisting">changePosition()</pre></div><p>Now if you will run it and tap inside your game scene, you will see <code class="literal">spriteWithoutTexture</code> changing its position and toggling between them.</p><p>The most part of the code is the same as in <code class="literal">changecolor(),</code> except the position. In <code class="literal">case 0</code>, we set its position to <code class="literal">CGPointZero</code>. Position is measured in the <code class="literal">CGPoint</code> unit. <code class="literal">CGPointZero</code> is equivalent to <code class="literal">CGPointMake(0, 0)</code>. The position of a sprite depends on its <code class="literal">anchorPoint</code> as well as its parent <code class="literal">anchorPoint</code>.</p><p>As we define <code class="literal">GameScene</code> <code class="literal">anchorPoint</code> to <code class="literal">(0.5 , 0.5)</code>, it means any other node which will be added to <code class="literal">GameScene</code> will have the starting <code class="literal">position(0,0)</code>, from the middle of the screen. That's why the background and <code class="literal">spriteWithoutTexture (0,0)</code> co-ordinate will be in middle of the screen.</p><p>Now, as we specified the <code class="literal">anchorPoint</code> of <code class="literal">spriteWithoutTexture</code>, it will take its default value of <code class="literal">(0.5,0.5)</code>. This means that its <code class="literal">anchorPoint</code> will be in the center of it. Hence, in <code class="literal">case 0</code>, it is rendering in the middle of the screen symmetrically. In <code class="literal">case 1</code> and <code class="literal">case 2</code>, we just moved it to the right middle corner and left middle corner of the screen.</p><p>Let's try to<a id="id146" class="indexterm"/> change <code class="literal">anchorPoint</code> and see what happens. Add this line inside <code class="literal">addSpriteWithoutTexture</code>:</p><div><pre class="programlisting">spriteWithoutTexture!.anchorPoint = CGPointZero</pre></div><p>Now run it.</p><div><img src="img/4201_03_01.jpg" alt="Changing the position of a sprite"/><div><p>Before tap</p></div></div><div><img src="img/4201_03_02.jpg" alt="Changing the position of a sprite"/><div><p>After tap</p></div></div><p>You will see that <a id="id147" class="indexterm"/>all the positions are not as they were before. Can you guess the reason for this?</p><p>In the preceding code line, we assigned the new value <code class="literal">(0,0)</code> to <code class="literal">spriteWithoutTexture</code>, which will remove its default value <code class="literal">(0.5,0.5)</code>. This means that its <code class="literal">anchorPoint</code> will not start from its middle. It will start from the bottom left of this. To visualize it, consider your sprite's top right corner as <code class="literal">1,1</code>, and bottom left corner as <code class="literal">0,0</code>. Now if you will set <code class="literal">anchorPoint</code> to <code class="literal">0,0</code>,<code class="literal"> </code>it will be at the bottom left of the sprite. If you will take it to <code class="literal">0,1</code>, it will be at the top left. For <code class="literal">1,1</code>, it will at the top right and for <code class="literal">1,0</code>, it will at the bottom right. You can change it to whatever value you like, such as negative <code class="literal">(-1,-2)</code> and so on.</p><p>Now, we can see that setting <code class="literal">anchorPoint</code> becomes easy once we are familiar with co-ordinate numbers on the screen. So, let's test ourselves by setting the <code class="literal">spriteWithoutTexture</code> position to what it was before, using <code class="literal">0,0</code> as <code class="literal">anchorPoint</code>. Replace the <code class="literal">changePosition</code> function from this:</p><div><pre class="programlisting">func changePosition(){
    switch(currentno%3){
    case 0:
        spriteWithoutTexture!.position = CGPointMake
(-spriteWithoutTexture!.size.width/2,
-spriteWithoutTexture!.size.height/2)

    case 1:
        spriteWithoutTexture!.position = CGPointMake(self.size.width/2-spriteWithoutTexture!.size.width,
-spriteWithoutTexture!.size.height/2)
    case 2:
         spriteWithoutTexture!.position = CGPointMake
(-self.size.width/2, -spriteWithoutTexture!.size.height/2)
    default :
         spriteWithoutTexture!.position = CGPointMake(0, 0)

    }
}</pre></div><p>Add the following<a id="id148" class="indexterm"/> line inside the <code class="literal">addSpriteWithoutTexture()</code> function:</p><div><pre class="programlisting">spriteWithoutTexture!.position = CGPointMake
(-spriteWithoutTexture!.size.width/2,
-spriteWithoutTexture!.size.height/2)</pre></div><p>Now run it. You will see the same result as before, in your <code class="literal">GameScene</code>.</p><p>In this code, we made a little adjustment. We want <code class="literal">spriteWithoutTexture</code> to be positioned in the center. As its <code class="literal">anchorPoint</code> is <code class="literal">(0,0)</code>, its bottom left corner will be in the middle of the screen. So, to show it in the middle of the screen, we have to set its position by subtracting half of each width and height with the middle screen points, which are <code class="literal">0,0</code>. Same goes for the left and right position of the <code class="literal">sprite</code>.</p><p>Now, just try to set <code class="literal">MenuScene anchorPoint</code> to <code class="literal">(1,1)</code>, inside the <code class="literal">GameViewController.swift</code> file, and try to adjust the button and background position by yourself. If you are unable to do so, just add the following code inside the <code class="literal">addChildToScene</code> function:</p><div><pre class="programlisting"> Background.position = CGPointMake(-self.size.width/2,
-self.size.height/2)
 PlayButton.position = CGPointMake(-self.size.width/2,
-self.size.height/2)</pre></div><p>Now, if you run this code, you will notice the same result as before. After positioning, let's talk about<a id="id149" class="indexterm"/> resizing a sprite.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Resizing a sprite</h2></div></div></div><p>As the <code class="literal">SKSpriteNode</code> class <a id="id150" class="indexterm"/>is inherited from the <code class="literal">SKNode</code> class, it also inherits <code class="literal">xScale</code> and <code class="literal">yScale</code> properties from the <code class="literal">SKNode</code> class. In our scene, we have given the background the same width as our view. We will achieve the same result as before, if we use its original size and scale its width and height. Open the <code class="literal">GameScene</code> class and update the <code class="literal">addBackGround</code> function as follows:</p><div><pre class="programlisting">func addBackGround() {
    backgroundNode.zPosition = 0

    var scaleX =  self.size.width/backgroundNode.size.width
    var scaleY =  self.size.height/backgroundNode.size.height
    backgroundNode.xScale = scaleX
    backgroundNode.yScale = scaleY
    addChild(backgroundNode)
}</pre></div><p>We have modified the function, <code class="literal">addBackGround()</code>. to enable our game to detect the screen dimensions of our device. This gives portability to our game (for example, the iPhone 5 and iPhone 6 have different screen dimensions). Now this function will return two float values as the ratio of screen size and background size in both width and height. After setting those to <code class="literal">backgroundNode.xScale</code> and <code class="literal">backgroundNode.yScale</code>, if you run this code, you will get the same result as before.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Working with texture objects</h1></div></div></div><p>When a sprite is created, Sprite Kit <a id="id151" class="indexterm"/>creates a texture also. But sometime we require texture to do some complex work, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Changing the sprite</li><li class="listitem" style="list-style-type: disc">Animation</li><li class="listitem" style="list-style-type: disc">Using the same texture between multiple sprites</li><li class="listitem" style="list-style-type: disc">Rendering a node tree into a texture like a screen shot</li></ul></div><p>To make this simple, Sprite Kit provides us the <code class="literal">SKTexture</code> class. We can make an object of this class and use it as we want.</p><p>Open your <code class="literal">MenuScene.swift</code> file and make a reference of <code class="literal">SKTexture</code>:</p><div><pre class="programlisting">let testingTexture : SKTexture

Now initialize it inside init code block

init(size:CGSize, playbutton:String, background:String) {
     PlayButton = SKSpriteNode(imageNamed: playbutton)
     Background = SKSpriteNode(imageNamed: background)
     MyPlayButton = SKSpriteNode(imageNamed: playbutton)
     testingTexture = SKTexture(imageNamed: playbutton)
     super.init(size:size)
}</pre></div><p>Let's make a function<a id="id152" class="indexterm"/> call, <code class="literal">generateTestTexture</code>, and call it from <code class="literal">didMoveToView</code>:</p><div><pre class="programlisting">override func didMoveToView(view: SKView) {
    addChildToScene();
    PlayButton.name = "PLAY"
    generateTestTexture()
}
    func generateTestTexture(){

        for var i = 0 ; i &lt; 10; i++ {
            var temp = SKSpriteNode(texture: testingTexture)
            temp.xScale = 100/temp.size.width
            temp.yScale = 50/temp.size.height
            temp.zPosition = 2
            temp.position = CGPointMake(-self.size.width + CGFloat (100 * i), -self.size.height/2)
            addChild(temp)
        }
}</pre></div><p>Run it and you will see many play textures in a sequence. We have made these using only one texture. Earlier, we were making the <code class="literal">SKSpriteNode</code> object from an image name, allowing Sprite Kit to create texture. Now we are assigning a texture to the <code class="literal">SKNode</code> object, which was created by us. Now, as we have done many customizations with sprites, let's have a look at the texture atlas.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>What is a texture atlas?</h2></div></div></div><p>A game's performance is <a id="id153" class="indexterm"/>dependent on the number of sprites used in it. The fewer the number of sprites, the more performance it gives. For this purpose, Sprite Kit provides texture atlases, which pack our image files automatically into one or more large images.</p><p>It provides us with a way to improve the performance of our game by drawing multiple images with a single draw call. When the game is in the development phase, compiler goes through every folder to find the folders with the <code class="literal">*.atlas</code> format. When those folders are identified, all of the images inside them are combined into one or more large image files. So, if you want to use this, place your images inside a folder and then rename it by suffixing <code class="literal">.atlas</code> to its name.</p><p>Now, we are going to add a player to <code class="literal">GameScene</code>. Let's take the player's all idle state images to a folder, and name it <code class="literal">idle.atlas</code>.</p><p>Now in Xcode, in <strong>Project Navigator</strong>, right-click on your project and select <strong>Add to Project</strong>:</p><div><img src="img/4201_03_08.jpg" alt="What is a texture atlas?"/></div><p>Select the directory (not the files) and click on <strong>Add</strong>. Defaults should be OK, but make sure it's set to copy.</p><div><img src="img/4201_03_09.jpg" alt="What is a texture atlas?"/></div><p>Now we are going to <a id="id154" class="indexterm"/>add a player to our <code class="literal">GameScene</code>. Open <code class="literal">GameScene</code> and create the function, <code class="literal">addPlayer</code>:</p><div><pre class="programlisting">func addPlayer(){
    var player = SKSpriteNode(imageNamed:"bro5_idle0001")

    player.position = CGPoint(x:0,y:0)
    player.zPosition = 2;
    self.addChild(player)
  }</pre></div><p>Comment on the <code class="literal">addSpriteWithoutTexture</code> function and call the <code class="literal">addPlayer</code> function. Your function will look as follows:</p><div><pre class="programlisting">override func didMoveToView(view: SKView) {
        addBackGround()
        //addSpriteWithoutTexture()
        addPlayer();
    }</pre></div><p>Convert to comment tap part from <code class="literal">touchesBegan</code> in the code. So that we don't get stuck if a touch occurs; otherwise the image of the player may obstruct the touch:</p><div><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches{
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            // if node.name == spriteWithoutTexture!.name {
            //    currentno++
            //    changeColor()
            //    changePosition()
           
            //}
        }
    }</pre></div><p>Now, run it and see. You <a id="id155" class="indexterm"/>will see the player in the middle of the screen.</p><p>In this code, we made a <code class="literal">SKSpriteNode</code> instance by passing an image name inside it. It will search for the Atlas for that image. But if we have an identically named image inside our project, this image will be loaded instead of the texture atlas. You have to use whatever the name of your image is.</p><p>When we put images inside a folder with <code class="literal">.atlas</code> extension, Xcode generates one or more big images by combining all the images into one.</p><div><ol class="orderedlist arabic"><li class="listitem">To see that packed image, go to your <code class="literal">Products</code> folder in your project.</li><li class="listitem">Right-click on the <code class="literal">.app</code> file there and click on <strong>Show in Finder</strong>, so that we can go to its directory.</li><li class="listitem">Now, right-click on the <code class="literal">.app</code> file and select <strong>Show Package Contents</strong>.</li><li class="listitem">After that, go to <strong>Contents</strong> | <strong>Resources</strong> | <code class="literal">*.atlasc</code>. Here you will see two files, an image, and a plist. If you will look at the image, you will find that images are combined into a texture, which has its height and width in the power of 2. If you will open the plist, you will see that it contains the position of images inside the packed texture, so that we can access them directly using Texture Atlas.</li></ol></div><p>You can access <a id="id156" class="indexterm"/>texture atlas also. Let's use <code class="literal">TextureAtlas</code> and do something on tap:</p><div><ol class="orderedlist arabic"><li class="listitem">First of all make a texture atlas reference in <code class="literal">GameScene</code>:<div><pre class="programlisting">let myAtlas = SKTextureAtlas(named:"idle.atlas")</pre></div></li><li class="listitem">After that, make a player reference outside of function so that we can use it in another function too:<div><pre class="programlisting">var player :SKSpriteNode?</pre></div></li><li class="listitem">Now edit the <code class="literal">addPlayer</code> function as follows:<div><pre class="programlisting"> func addPlayer(){
     player = SKSpriteNode(texture: myAtlas.textureNamed("bro5_idle0001"))
     player!.position = CGPoint(x:0,y:0)
     player!.zPosition = 2;
     player!.name = "Player"
     self.addChild(player!)
  }</pre></div></li><li class="listitem">Make the function, <code class="literal">changeSpriteFromTextureAtlas()</code>, and call it from <code class="literal">touchesBegan</code>. Now, it should look like the following lines:<div><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches{
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == player!.name {
               currentno++
               changeSpriteFromTextureAtlas()
            }
        }
    }
    func changeSpriteFromTextureAtlas(){
        switch(currentno%3){
        case 0:
            player!.texture = myAtlas.textureNamed("bro5_idle0001")
        case 1:
             player!.texture = myAtlas.textureNamed("bro5_idle0004")
        case 2:
             player!.texture = myAtlas.textureNamed("bro5_idle0007")
        default :
           break

        }

    }</pre></div></li><li class="listitem">Now, run and tap on the player. You will see that the player changes its sprite on tap.</li></ol></div><p>We have<a id="id157" class="indexterm"/> created the <code class="literal">SKTextureAtlas</code> reference. We named it as <code class="literal">atlas</code> file and added it to project. Now we can fetch the image from the texture atlas file. This is the way through which we can directly access the texture atlas. Texture atlases are very useful to make animation sequences or level generations from tiles. We will talk about animation in further chapters.</p><p>Now, as we are using textures to make sprites, sometimes we might need to preload textures into memory. Let's discuss this in detail.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Preloading textures into memory</h1></div></div></div><p>Sprite Kit performs <a id="id158" class="indexterm"/>memory management very well. When a texture is <a id="id159" class="indexterm"/>needed to be rendered in scene, but is not prepared, Sprite Kit loads it into memory, and uploads it to the graphics hardware by converting it to a usable form. If many unloaded textures are needed at once, it might slow down the game. To avoid this, we need to preload textures before using them, especially in larger or more complex games.</p><p>This problem may arise when a user has to go from the level screen to the game screen. As the game screen may have many textures, it will need to load and might be slow due to the loading of texture. To avoid this, we can use the <code class="literal">SKTexture class preloadTextures(_:withCompletionHandler:)</code> function. It takes an array of SKTexture and a block, which is called after all the texture is loaded. So, we can use this block to load a scene.</p><p>For a small game, we<a id="id160" class="indexterm"/> can load all the textures at once, at game launch <a id="id161" class="indexterm"/>time. For a larger game, we will need to split the textures into different levels according to scene and other such criteria. The textures which are not useful to a level are discarded to save memory. And if the game is too big, we will need to load textures dynamically as the game runs.</p><p>As we load textures, we also need to remove the unnecessary textures from memory too. When a texture is loaded into memory, it stays there until its reference <code class="literal">SKTexture</code> object is deleted. To delete an <code class="literal">SKTexture</code> object, we have to remove the reference from it; this will make the texture unload from the memory.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Summary</h1></div></div></div><p>In this chapter, we read about sprites in detail. We learned about how to initialize a sprite, and about the sizing and positioning of a sprite. We also learned about the various color properties of the sprite. The lighting and shader properties were also discussed. Finally, we discussed about the <code class="literal">Texture</code> object, usage of the texture atlas, and preloading of the texture into memory.</p><p>In the next chapter, we will be learning about nodes and various other concepts of the tree node structure.</p></div></body></html>