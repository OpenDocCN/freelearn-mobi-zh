- en: Gameplay, UI, and Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created basic gameplay and made sure the correct
    animation was triggered and the controls are in place. In this chapter, we will
    finish up the game play by adding a proper game loop so that there is a start,
    scoring, and gameover.
  prefs: []
  type: TYPE_NORMAL
- en: For the scoring, we will initially use debug to log out the health of the player
    and the AI. Later, we will look at Unity's **Graphical User Interface** (**GUI**)
    system and add a health indicator for both the player and the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will also look at the Unity's particle system and the different
    parameters that we can manipulate to get the desired particle effect for the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up the gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Unity GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding GUI for health and gameover condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Particle Effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating confetti Particle Effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finishing up gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To track the player and enemy's health, we need variables to track how much
    health both have and how much damage both can do to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, open up `playerScript` and add variables called `health` and `damage`
    at the top of the class. Then, set the value of the `health` variable to 100 and
    that of the `damage` variable to 10\. So, the player will start with a health
    of 100, and when they hit the enemy, they will do a damage of 10 to the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, add the same code as that of `playerScript` class to the `enemyScipt` class
    as well. Since we want to be fair, we will set the enemy''s health to be 100 as
    well and set the damage that they can do to 10\. Make sure you use the `public`
    access specifier because only then we will be able to access the health variable
    when we try to access it in other classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever the player/enemy takes a hit, we have to make sure that the health
    is reduced by the amount of damage that other player/enemy can inflict on them.
    So, in the section of the `Update` function, when we check whether the player
    or the enemy is getting hit, we have to reduce the amount of health by the damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `enemyScript` class, for checking if the enemy is hit, change the code
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We get the access to the player script by getting the `gameobject` player and
    adding the `GetComponent` component of the player script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have access to the script, we can get the amount of damage the player
    can do and reduce the current health of the enemy by the amount of damage. Now,
    move to `playerScript`, as we have to implement the same in the player script
    as well when the player gets hit by the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will get access to the enemy script so that we can get the enemy damage
    as we did in the enemy script. Once we have access to the `damage` variable, we
    will reduce the health of the player by the amount of damage that was set in the
    enemy script. Now, you can run the game and the `Debug.log` script. The `Player
    Health` and `Enemy Health` entities seem to be getting affected, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have the player and enemy health being calculated, we can set the game
    over condition. Once the player's health or enemy's health gets less than or equal
    to zero, it is game over.
  prefs: []
  type: TYPE_NORMAL
- en: The gameloop is the controller by the third script. We will call this script
    `gameScript`.
  prefs: []
  type: TYPE_NORMAL
- en: It is a very simple script that gets access to both `playerScript` and `enemyScript`,
    and it checks for the health of both the player and the enemy. Once either of
    the player or enemy script becomes less than zero, it announces that the game
    is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will create a new script called `gameScript` and add the following lines
    of code to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the class, we created three variables. The first two are for getting
    access to the player and enemy scripts. The third variable is a public Boolean
    that sets whether the game is over or not. Since it is the start of the game and
    it is not over yet, we set it to false at the start.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Start` function, we found the player and the enemy and got access to
    the individual scripts using the get component function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `Update` function ,we first checked whether the game is not over.
    If it is not over, then we get the player's and enemy's health and store it in
    a local variable called `playerHealth` and `enemyHealth`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We then do a check if the player health or the enemy health is less than or
    equal to 0\. If that is the case then we set the `bGameover` Boolean variable
    to `true` and the `Debug.log` is called, that it is gameover.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the script to actually run it needs to be attached to an object in the
    scene. It could be a dummy object or any other object in the scene. Luckily we
    have a camera that is just sitting there and is part of the scene. So, we will
    attach the `gameScript` to the camera as a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the script is attached to the camera run the game and see if it reaches
    gameover condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_002.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice now that even though the game is over, the enemy keeps punching
    the player and the player can still punch the enemy. We don't want this as it
    may lead to some unnecessary bugs in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the player and enemy scripts, we need to get access to the `gameScript` class
    and make sure that once it is gameover, nothing updates. In the player''s class,
    we will create a new `GameObject` called `mainCamera` at the top of the class
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `Update` function, we get access to the `gameScript` complement of the
    camera and then whatever is in the `Update` function, we put it in an `if` condition,
    which will check whether the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the game is not over, then everything inside the `if` condition will be
    updated. Otherwise, it will skip through and not update. Here is the updated `Update`
    function (no pun intended):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to do the similar operations on enemy script as well. Here is
    the updated code for the enemy class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on a random number going from one to three, we will choose whether
    the AI will punch, defend, or be idle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Shuffle` function rearranges the initial array so that we get a different
    set of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Unity uGUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the introduction of the Unity's **uGUI** system, it has been very convenient
    to set up GUI elements in Unity. We will look at how uGUI works and how to display
    image and text on to the scene. We will also see how to change the text dynamically
    in the next topic when we implement the health for the player and the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the UI elements in Unity are present in the GameObject dropdown in the
    menu in Unity, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can create three types of basic UI elements: Text, Image, and Raw Image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Text option in the menu is a basic text element used to display text-like
    score, health, energy, and so on. So, like any text element, you can specify text
    height and font, such as bold or italic. When you create a new text element, there
    are options such as Canvas, Text, and EventSystem added for each text element
    that you add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When a new text UI element is created, it is placed at the center by default,
    with the default text New Text, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Canvas option in the menu represents where the text component exists in
    the scene and is also responsible for rendering the text on to the scene. Components
    to the canvas element can also be added directly by right-clicking on it. You
    can also add empty game objects to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Canvas is made up three scripts: Canvas, Canvas Scalar, and Graphics Ray Caster.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the canvas is set to Screenspace Overlay. There is also Screenspace
    Camera and World Space options. In Screenspace Overlay, the text will set on top
    of everything in the scene irrespective of whether the camera is in focus. This
    is used in traditional games where the UI needs to sit on top of the game.
  prefs: []
  type: TYPE_NORMAL
- en: If you want different UIs depending on which camera is selected, you can use
    ScreenSpace Camera and then you can attach different UIs to the cameras. To navigate
    between the different UIs, you will go back and forth between the cameras for
    the two UIs.
  prefs: []
  type: TYPE_NORMAL
- en: In World Space, the canvas is placed with respect to the world position. So,
    you can place the button or text in 3D space and position it accordingly. You
    can move, rotate, and scale the text as well. The user will still be able to navigate
    and use the UI element. This gives absolute freedom to place the UI element wherever
    you want in the 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: You can select the Pixel Perfect option if you want your text to be aligned
    to a pixel grid. Canvas Scalar will scale the text up and down based on the resolution.
    By default, it is set to Constant Pixel Size. You can also set it to Scale with
    Screen Size or Constant Physical size.
  prefs: []
  type: TYPE_NORMAL
- en: The Graphics RayCaster script is responsible for getting input from the keyboard,
    mouse, or touch. If removed, the UI element will no longer accept mouse clicks
    and keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about the EventSystem option, let us look at the EventSystem components.
  prefs: []
  type: TYPE_NORMAL
- en: 'An EventSystem is also created. The event system handles input from mouse,
    keyboard, and controllers. If you want certain events to be triggers at the click
    of the mouse, this would be specified here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Whenever you create and new UI component and new Canvas and EventSystem is
    automatically created. Select the text so that we can have a closer look at the
    component in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_008.png)'
  prefs: []
  type: TYPE_IMG
- en: A UI game object is just like any other game object, but unlike others, it has
    `RectTransform` instead of a regular transform, has a Canvas Renderer, and also
    has a Text (Script) option attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: Rect Transform is made up of different properties. The important one is positions;
  prefs: []
  type: TYPE_NORMAL
- en: 'the others are width and height. These depend on how our anchors are set up.
    By default, Rect Transform is set to middle and center. You can click on the Anchor
    Presents option to change the preset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Changing Anchor Presets will also affect the X and Y positions of the button
    or text on the scene. Anchors can also be manually changed as per your requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_010.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will talk about the Pivot field. The pivot is the position around which
    the UI will rotate. Then, there are Rotate and Scale fields, which work as other
    transform objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the Text Script. The Text Script has a text box. This is
    where you can type whatever text you want be displayed on to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: After that, there is the Character section. Here, you can change the property
    of the character. You can change the font, font style--that is, if you want normal,
    bold, or italic; size of the font--and line spacing. Note that Unity doesn't let
    you set the distance between the characters horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: The Paragraph section lets you control the position, color, and material of
    the paragraph itself. You can center align the paragraph, set the horizontal and
    vertical overflow, or set it to best fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of a Text, if you add an Image UI element, Canvas and EventSystem are
    maintained, but the image itself has the usual Rect Transform and Canvas Renderder
    properties. Instead of the Text (Script), there is an Image (Script) that is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_011.png)'
  prefs: []
  type: TYPE_IMG
- en: Image (Script) has fewer objects in it. We have the Source Image option in which
    you can specify the image to be displayed. You can change the color or material
    of the image as well.
  prefs: []
  type: TYPE_NORMAL
- en: With all this information, let's add player and enemy text and also a gameover
    text overlay, which will appear once the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: Adding GUI for health and gameover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the game scene, add three texts and name them `enemyHealthText`, `playerHealthText`,
    and `gameOverText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The enemyHealthText text is positioned, as shown in the following screenshot,
    with the anchor at the center and the font height set to 32\. The rest are set
    to default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The playerHealthText text is set at a position, as shown in the following screenshot,
    with text height changed to 32:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_013.png)'
  prefs: []
  type: TYPE_IMG
- en: The text color has been changed to blue for the enemy and red for the player.
    The gameoverText text is set to the middle of the canvas, with text height set
    to 75 and the color set to a nice purple so that it is easily visible.
  prefs: []
  type: TYPE_NORMAL
- en: In the Text field, add the text GAME OVER!!!, as shown in the following screenshot:.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_014.png)'
  prefs: []
  type: TYPE_IMG
- en: One thing we haven't seen yet is how to control the text by code. Let's see
    next how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the gameScript script, add three public variables of type `Text`, as given
    the following code snippet. This will hold the text object from the `Text` UI
    elements created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to add the UI namespace at the top of the class for it to
    work, so add the following line at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `Update` function, after we get the health values from the enemy
    and the player, assign the values to the newly created text variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainCamera` on which `gameScript` is attached, make sure you drag and drop
    enemyHealthText (Text), playerHealthText (Text), and gameOverText (Text) from
    the Hierarchy on to the script component, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, to make sure that the gameover text only appears once it is game over,
    in the start function of gameScript, disable `gameOverText`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Update`  function, once the `bGameover` Boolean variable is set to
    `true`, enable the `gameOverText` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the game, you will see the score getting updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the game is over, you will see the gameover text overlay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_017.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we are done with the gameplay, let's add some effects to the scene
    using Particle Effect.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Particle Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle Effects are a very big part of a game experience; they add ambience
    to the game or let us know that something special is going to happen or is happening.
    We see particles in the form of dust, clouds, rain, and also in the form of the
    celebration that happens at the end of the game. They can really be whatever you
    plan to make of them. For the purpose of our game, we are going to add confetti
    at the gameover.
  prefs: []
  type: TYPE_NORMAL
- en: 'A particle system in Unity is also a game object, so to create a particle system,
    go to the GameObject menu and select the Particle System option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_018.png)'
  prefs: []
  type: TYPE_IMG
- en: Press the *F* key on the keyboard to highlight the Particle System option as
    it might be created away from the main camera. In my case, it was created at 900,
    300, and -26\. Don't worry about the positioning of the particle. We will manually
    change where we want the particle to be created at the end when we want it to
    be spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you zoom in on the Particle System, you will see a cone shape and see
    particles coming out of the shape. The cone specifies the shape of the emitter,
    and the white particles are the actual particles that are emitted from the Particle
    System. This is represented by the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_019.png)'
  prefs: []
  type: TYPE_IMG
- en: Like any game object, you will also see three arrows that let you position the
    particle system. You also need to press the *Q*, *W*, and *E* keys to position,
    rotate, and scale the size of the emitter, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Once you select Particle System in the Hierarchy, it will show how the particles
    will be created in the scene. If you select some other object or deselect the
    Particle System, the animation stops. So, if you would like to preview how the
    particles are getting created, then select the Particle System in the Hierarchy
    to get a preview of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some of the important parameters that you can modify in the Inspector
    pane for the Particle System:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Like all other game objects, you can position, rotate, and scale the Particle
    System, the first set of parameters are as shown in the following screenshot.
    These parameters control how the particles are initially created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A brief description of all the parameters is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duration: This specifies for how long initially the particles are created.
    By default, it is set to 5 seconds. At present, you won''t see a difference as
    looping is enabled. If you disable looping, then if you select Particle System
    in the Hierarchy, you will see that the particles emit for 5 seconds and then
    stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looping: This should be disabled if you don''t want the particles to be spawned
    continuously. So, if you want a burst of particles, disable looping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prewarm: This parameter loads the particles beforehand so that it won''t look
    as if the particles are getting generated at the start of the scene. For example,
    if you have a water fall particle system and when the scene loads, it should look
    as if the water fall was running before the scene was loaded. If the waterfall
    starts to form just after the scene was loaded, it won''t look practical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Delay: You can set the particles form after a delay in using this parameter.
    Right now the particles start forming right after you click the particle system
    in the hierarchy, but if you want the particles to be formed a second after, then
    you will type `1.0` and the particles will form a second after you click the Particle
    System.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Lifetime: Each particle lasts for a certain period of time and then it
    gets deleted from the scene. By default, the particle is always set to be deleted
    after 5 seconds. If you want the particle to last longer in the scene, this parameter
    can be changed to cater to your needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Speed: This is the initial speed of each particle. By default, this is
    also set to 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Size: This is the initial size of the particle. By default, it is set
    to 1\. It is the particle object in the initial size that it was created. If you
    created particles bigger and you would like to reduce the size by half, you will
    type in 0.5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Rotation: If you want the particles to be generated at an angle in which
    they were created, then you can set the angle here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Randomize Rotation: If you want the particles to be created at different angles,
    then you can specify the angle here. Unlike start rotation, which would create
    all the particles at the same angle, randomize rotation will create each particle
    at a different angle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Color: This specifies the initial color in which each of the particles
    is created. By default, it is set to white. You can change the color by clicking
    on the white bar and specifying the color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_05_022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Gravity Modifier: This enables gravity. By default, the value is set to 0,
    meaning that there is no gravity. If you set the value to 1, you have enabled
    gravity to the maximum. You can also set the value to between zero and one for
    an appropriate gravity level as you desire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simulation Space: This specifies all the changes that are made after the each
    particle locally; that is, with respect to the origin of individual particle.
    By default, set it to local.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simulation Speed: This specifies the speed at which the simulation is calculated.
    You can speed up or slow down the simulation. This is useful to see how your particles
    will behave if you have a particle system that takes time to mature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scale Mode: Set this to local. This specifies that the scale affects each particle
    with respect to the particle''s origin and not the origin of the emitter or the
    world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Play on Awake: The particles system becomes active as soon as the scene starts.
    If you don''t wish the particle to start immediately at the start of the scene,
    then you need to uncheck this parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Max Particles: This is the maximum number of particles that can be present
    in the scene at a time. By default, set it to 1,000\. This should be kept as minimum
    as possible as it would significantly reduce the performance of the game, because
    the more particles you have in the scene, the more render calls are required and
    more calculation is required for each particle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Auto Random: Seed generates a seed to automatically randomize the spawn and
    movement of each of the particle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next set of parameters is optional and requires checking and unchecking
    if you would like to enable or disable these features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Emission: This specifies the amount of particles getting generated in a second.
    The Rate over Time option is set to 10, meaning there are 10 particles generated
    in a span of 1 second. If you set it to 1, then you will see 1 particle each second.
    The Rate over Distance option will work only when World Space Simulation is used.
    In the Bursts mode, you can create a burst of particle depending on the duration
    that you initially set. So, here, when you click on the + icon, it will create
    30 particles every 5 seconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_05_023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Shape: This specifies the shape of the particle system itself. By default,
    it is set to Cone. Since the Particle System is the shape of the cone, you can
    see that the particles are generated and move upward in the specified shape. If
    you want the particle to spread in all directions, then you can specify sphere.
    You can also select between box, mesh, circle, and edge. By selecting mesh, you
    can specify a certain mesh and let the particle be generated from that specified
    mesh shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other parameters as well, such as angle, radius.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Emit from: This specifies from where the particles will be generated from,
    such as Base, Base Shell, Volume, and Volume Shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also randomize the direction or align to a specific direction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_05_024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Velocity over Lifetime: If you would like the velocity to be changed over time,
    then you can specify here. If not specified, then the speed would be kept constant,
    and it would be the same that was set initially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limit velocity Over Lifetime: This can limit the speed of the particle so that
    once the particle has reached a specific speed over lifetime, it is set either
    to that speed or slowly reduces over time to the initial speed set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inherit Velocity: This controls the speed of the particle depending on the
    speed of the emitter itself. The faster the emitter moves, the faster the particles
    are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Force Over Lifetime: This sets the force of each particle over the lifetime.
    So, the particle will move faster over a period of time if this value is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Color Over Lifetime: The color of each particle can be changed depending on
    when it was generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Color by Speed: The color of each particle is specified by the speed of the
    particle itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, we have size and rotation, which are either controlled by what stage
    they are in their lifetime or the speed at which they are moving:'
  prefs: []
  type: TYPE_NORMAL
- en: 'External Force: You can simulate the exertion of external force on the particle
    by changing the multiplier on the external force, for example, the case of wind.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Noise: You can also generate randomness using noise, which will use perlin
    noise-like texture to create random movement and behavior of the particles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_05_025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Collision: The particles as of yet won''t react to other objects in the scene,
    so if you place an object in from of the particle, the particle would just go
    through the object. When you enable collision, the particle will collide with
    the object instead of going through it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_05_026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Triggers: Particles can also be used as triggers if the Triggers option setting
    is turned on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_05_027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sub Emitter: Each particle can also emit objects when you enable the Sub Emitter
    option. Also, each particle will also emit other particles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Texture Sheet Animation: Instead of static images, you can also specify a texture
    sheet so that each particle is animated instead of displaying a static image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_05_028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lights and Trils: Each particle can also have a light source and trails attached
    to them to make the scene more eye catching and pretty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Renderer: This specifies a lot of parameters like the shape of the particle
    itself, if it needs to be a billboard or a mesh. So, in a mesh, you can specify
    3D objects such as a box, sphere, cone, and the normal direction of the particle
    and the material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can specify the sort mode, minimum and maximum particle size, alignment,
    and pivot. Each particle and cast receiving shadows has light probes, reflects
    light probes, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_029.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating confetti Particle Effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the confetti, we create a Particle System as usual. For the initial values,
    we keep the position to be 0,0,-7.5\. For rotation and scale value, we keep at
    default.
  prefs: []
  type: TYPE_NORMAL
- en: We keep the duration at 4 and uncheck the Looping option as we don't want the
    confetti to be created over and over. Start Delay is set to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Start Speed is set to 5 and 3D Start Size is set to 0.25 in the `X`, `Y`, and
    `Z` directions. The 3D Start Rotation option is disabled. Start Rotation and Randomize
    Rotation are set to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Start Color is set to randomize between two colors, red and blue. Gravity Multipler
    is set to 0.125, and we want the confetti to fall down after it has reached its
    maximum height.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the initial values are set to default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_030.png)'
  prefs: []
  type: TYPE_IMG
- en: Emission is set to 20 for Rate over Time, and Shape is set to Cone.
  prefs: []
  type: TYPE_NORMAL
- en: To make the confetti more colorful and also change color over time, the color
    over lifetime is changed. So, change it to your needs. The Color over Speed parameter
    is also changed similarly. Both are set to Random Between 2 Gradients.
  prefs: []
  type: TYPE_NORMAL
- en: Size over lifetime is changed so that the size of the particles changes over
    time. Size is set to a curve so that the particle starts out small and then becomes
    full size at the end of the lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape of the curve is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Rotation over Lifetime and Rotation by Speed options are set to 45 so that
    the particles rotate in air once created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For Renderer, I wanted to take 3D objects as particles, so I selected Mesh,
    and for Mesh, I selected Cube, Cylinder, and Sphere by clicking the + sign at
    the bottom. Rest of the values are kept as default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_033.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our Particle System is created. We will now create a prefab object in
    the `Assets` folder and drag the Particle System in it so that we can instantiate
    the prefab at gameover. Call the prefab particleSystem. You will notice that once
    you drag the Particle System into the prefab, it becomes blue, as shown in the
    following screenshot. Now, delete the Particle System from the Hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_034.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next in gameScript, create a new `GameObject` at the top and call it `particlePrefab`
    and make the variable `public`, as given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Update`  function, after the `gameover` Boolean variable is set to
    instantiate the particle prefab as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to drag and drop the particleSystem prefab on to Particle Prefab
    in the gameScript script component that is attached to the MainCamera:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_035.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when you run the game and when it is gameover, you will have a nice confetti
    Particle System:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_036.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to add in a GUI element to show the player's and
    enemy's health and also added the gameover text so that we know that it is the
    end of the game. We also added a very basic particle system just to demonstrate
    the ability to add particles. You can go in and change the particle system to
    see what more can be done.
  prefs: []
  type: TYPE_NORMAL
- en: The gameplay is over, and next, we can see how to add in scenes to the game,
    so we will create a main menu scene, which will show at the start of the game.
    We will also see how to add buttons so that at the click of the play button, the
    scene will swap to the gameplay scene.
  prefs: []
  type: TYPE_NORMAL
