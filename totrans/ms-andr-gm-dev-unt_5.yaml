- en: Gameplay, UI, and Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法、UI和效果
- en: In the previous chapter, we created basic gameplay and made sure the correct
    animation was triggered and the controls are in place. In this chapter, we will
    finish up the game play by adding a proper game loop so that there is a start,
    scoring, and gameover.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了基本游戏玩法并确保触发了正确的动画，控制也到位。在本章中，我们将通过添加适当的游戏循环来完成游戏玩法，以便有开始、得分和游戏结束。
- en: For the scoring, we will initially use debug to log out the health of the player
    and the AI. Later, we will look at Unity's **Graphical User Interface** (**GUI**)
    system and add a health indicator for both the player and the enemy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于得分，我们最初将使用debug来记录玩家和AI的健康状态。稍后，我们将探讨Unity的**图形用户界面**（**GUI**）系统并为玩家和敌人添加健康指示器。
- en: Finally, we will also look at the Unity's particle system and the different
    parameters that we can manipulate to get the desired particle effect for the game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将探讨Unity的粒子系统以及我们可以操纵的不同参数，以获得游戏所需的粒子效果。
- en: 'This chapter includes the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Finishing up the gameplay
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成游戏玩法
- en: Understanding Unity GUI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Unity GUI
- en: Adding GUI for health and gameover condition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加健康和游戏结束条件的GUI
- en: Introduction to Particle Effects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子效果简介
- en: Creating confetti Particle Effect
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建烟花粒子效果
- en: Finishing up gameplay
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成游戏玩法
- en: To track the player and enemy's health, we need variables to track how much
    health both have and how much damage both can do to each other.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪玩家和敌人的健康状态，我们需要变量来追踪他们各自的健康值以及他们能对彼此造成多少伤害。
- en: 'For this, open up `playerScript` and add variables called `health` and `damage`
    at the top of the class. Then, set the value of the `health` variable to 100 and
    that of the `damage` variable to 10\. So, the player will start with a health
    of 100, and when they hit the enemy, they will do a damage of 10 to the enemy:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，打开`playerScript`并在类的顶部添加名为`health`和`damage`的变量。然后，将`health`变量的值设置为100，将`damage`变量的值设置为10。因此，玩家将以100的健康值开始，当他们击中敌人时，将对敌人造成10点的伤害：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, add the same code as that of `playerScript` class to the `enemyScipt` class
    as well. Since we want to be fair, we will set the enemy''s health to be 100 as
    well and set the damage that they can do to 10\. Make sure you use the `public`
    access specifier because only then we will be able to access the health variable
    when we try to access it in other classes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，将`playerScript`类的相同代码添加到`enemyScipt`类中。由于我们希望公平，我们将敌人的健康值也设置为100，并将他们能造成的伤害设置为10。请确保使用`public`访问修饰符，因为只有这样我们才能在其他类中访问健康变量：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, whenever the player/enemy takes a hit, we have to make sure that the health
    is reduced by the amount of damage that other player/enemy can inflict on them.
    So, in the section of the `Update` function, when we check whether the player
    or the enemy is getting hit, we have to reduce the amount of health by the damage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当玩家/敌人受到攻击时，我们必须确保他们的健康值会因其他玩家/敌人能对他们造成的伤害量而减少。因此，在`Update`函数的章节中，当我们检查玩家或敌人是否被击中时，我们必须通过伤害量来减少健康值。
- en: 'In the `enemyScript` class, for checking if the enemy is hit, change the code
    as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`enemyScript`类中，为了检查敌人是否被击中，更改代码如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We get the access to the player script by getting the `gameobject` player and
    adding the `GetComponent` component of the player script.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过获取`gameobject`玩家和添加玩家脚本的`GetComponent`组件来获取对玩家脚本的访问权限。
- en: 'Once we have access to the script, we can get the amount of damage the player
    can do and reduce the current health of the enemy by the amount of damage. Now,
    move to `playerScript`, as we have to implement the same in the player script
    as well when the player gets hit by the enemy:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得对脚本的访问权限，我们就可以获取玩家能造成的伤害量，并通过伤害量减少敌人的当前健康值。现在，转到`playerScript`，因为当玩家被敌人击中时，我们同样需要在玩家脚本中实现这一点：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we will get access to the enemy script so that we can get the enemy damage
    as we did in the enemy script. Once we have access to the `damage` variable, we
    will reduce the health of the player by the amount of damage that was set in the
    enemy script. Now, you can run the game and the `Debug.log` script. The `Player
    Health` and `Enemy Health` entities seem to be getting affected, as shown in the
    following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将获取对敌人脚本的访问权限，以便我们可以获取与在敌人脚本中相同的方式获取敌人伤害。一旦我们获取了`damage`变量，我们将通过在敌人脚本中设置的伤害量减少玩家的健康值。现在，你可以运行游戏并执行`Debug.log`脚本。`Player
    Health`和`Enemy Health`实体似乎受到了影响，如下面的截图所示：
- en: '![](img/image_05_001.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_001.png)'
- en: Once we have the player and enemy health being calculated, we can set the game
    over condition. Once the player's health or enemy's health gets less than or equal
    to zero, it is game over.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算出玩家和敌人的生命值，我们就可以设置游戏结束条件。一旦玩家的生命值或敌人的生命值小于或等于零，就是游戏结束。
- en: The gameloop is the controller by the third script. We will call this script
    `gameScript`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环是由第三个脚本控制的。我们将把这个脚本称为`gameScript`。
- en: It is a very simple script that gets access to both `playerScript` and `enemyScript`,
    and it checks for the health of both the player and the enemy. Once either of
    the player or enemy script becomes less than zero, it announces that the game
    is over.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的脚本，它能够访问`playerScript`和`enemyScript`，并检查玩家和敌人的生命值。一旦玩家或敌人的脚本中的任何一个小于零，它就会宣布游戏结束。
- en: 'So, we will create a new script called `gameScript` and add the following lines
    of code to the script:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个新的脚本，称为`gameScript`，并将以下代码行添加到脚本中：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the top of the class, we created three variables. The first two are for getting
    access to the player and enemy scripts. The third variable is a public Boolean
    that sets whether the game is over or not. Since it is the start of the game and
    it is not over yet, we set it to false at the start.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的顶部，我们创建了三个变量。前两个是为了获取访问玩家和敌人脚本。第三个是一个公共布尔变量，用于设置游戏是否结束。由于游戏刚开始，还没有结束，我们在开始时将其设置为`false`。
- en: In the `Start` function, we found the player and the enemy and got access to
    the individual scripts using the get component function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start`函数中，我们找到了玩家和敌人，并使用获取组件函数访问了各自的脚本。
- en: Then, in the `Update` function ,we first checked whether the game is not over.
    If it is not over, then we get the player's and enemy's health and store it in
    a local variable called `playerHealth` and `enemyHealth`, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Update`函数中，我们首先检查游戏是否没有结束。如果没有结束，我们就获取玩家和敌人的生命值，并将其分别存储在名为`playerHealth`和`enemyHealth`的局部变量中。
- en: We then do a check if the player health or the enemy health is less than or
    equal to 0\. If that is the case then we set the `bGameover` Boolean variable
    to `true` and the `Debug.log` is called, that it is gameover.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着检查玩家生命值或敌人生命值是否小于或等于0。如果是这种情况，我们将`bGameover`布尔变量设置为`true`，并调用`Debug.log`，表示游戏结束。
- en: Now for the script to actually run it needs to be attached to an object in the
    scene. It could be a dummy object or any other object in the scene. Luckily we
    have a camera that is just sitting there and is part of the scene. So, we will
    attach the `gameScript` to the camera as a component.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让脚本真正运行，它需要附加到场景中的某个对象上。这可能是一个虚拟对象或场景中的任何其他对象。幸运的是，我们有一个就坐在那里并且是场景一部分的相机。因此，我们将`gameScript`附加到相机作为一个组件。
- en: 'Once the script is attached to the camera run the game and see if it reaches
    gameover condition:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本附加到相机上，运行游戏并查看它是否达到游戏结束条件：
- en: '![](img/image_05_002.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_002.png)'
- en: You will notice now that even though the game is over, the enemy keeps punching
    the player and the player can still punch the enemy. We don't want this as it
    may lead to some unnecessary bugs in the game.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会注意到，尽管游戏已经结束，敌人仍然在攻击玩家，而玩家仍然可以攻击敌人。我们不希望这样，因为这可能会导致游戏中出现一些不必要的错误。
- en: 'So, in the player and enemy scripts, we need to get access to the `gameScript` class
    and make sure that once it is gameover, nothing updates. In the player''s class,
    we will create a new `GameObject` called `mainCamera` at the top of the class
    as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在玩家和敌人脚本中，我们需要访问`gameScript`类，并确保一旦游戏结束，就没有任何更新。在玩家的类中，我们将在类的顶部创建一个新的`GameObject`，名为`mainCamera`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `Update` function, we get access to the `gameScript` complement of the
    camera and then whatever is in the `Update` function, we put it in an `if` condition,
    which will check whether the game is over.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`函数中，我们获取了相机的`gameScript`组件，然后无论`Update`函数中有什么，我们都将其放入一个`if`条件中，该条件将检查游戏是否结束。
- en: 'If the game is not over, then everything inside the `if` condition will be
    updated. Otherwise, it will skip through and not update. Here is the updated `Update`
    function (no pun intended):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏没有结束，那么`if`条件内的所有内容都将更新。否则，它将跳过并不会更新。以下是更新的`Update`函数（没有双关语的意思）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we have to do the similar operations on enemy script as well. Here is
    the updated code for the enemy class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要对敌人脚本执行类似的操作。以下是敌人类的更新代码：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Depending on a random number going from one to three, we will choose whether
    the AI will punch, defend, or be idle:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据从1到3的随机数，我们将选择AI是出拳、防御还是闲置：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Shuffle` function rearranges the initial array so that we get a different
    set of random numbers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shuffle`函数重新排列初始数组，以便我们得到一组不同的随机数：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Understanding Unity uGUI
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Unity uGUI
- en: With the introduction of the Unity's **uGUI** system, it has been very convenient
    to set up GUI elements in Unity. We will look at how uGUI works and how to display
    image and text on to the scene. We will also see how to change the text dynamically
    in the next topic when we implement the health for the player and the enemy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Unity的**uGUI**系统的引入，在Unity中设置GUI元素变得非常方便。我们将探讨uGUI的工作原理以及如何在场景中显示图像和文本。我们还将看到如何在下一个主题中动态更改文本，当我们实现玩家和敌人的健康值时。
- en: 'All the UI elements in Unity are present in the GameObject dropdown in the
    menu in Unity, as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的所有UI元素都显示在Unity菜单中的GameObject下拉列表中，如下面的截图所示：
- en: '![](img/image_05_003.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_003.png)'
- en: 'You can create three types of basic UI elements: Text, Image, and Raw Image.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建三种基本UI元素：文本、图像和原始图像。
- en: 'The Text option in the menu is a basic text element used to display text-like
    score, health, energy, and so on. So, like any text element, you can specify text
    height and font, such as bold or italic. When you create a new text element, there
    are options such as Canvas, Text, and EventSystem added for each text element
    that you add:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单中的Text选项是一个基本的文本元素，用于显示类似分数、健康、能量等的文本。因此，就像任何文本元素一样，您可以指定文本高度和字体，例如粗体或斜体。当您创建一个新的文本元素时，为每个添加的文本元素添加了Canvas、Text和EventSystem等选项：
- en: '![](img/image_05_004.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_004.png)'
- en: 'When a new text UI element is created, it is placed at the center by default,
    with the default text New Text, as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的文本UI元素时，它默认放置在中心，默认文本为“New Text”，如下面的截图所示：
- en: '![](img/image_05_005.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_005.png)'
- en: 'The Canvas option in the menu represents where the text component exists in
    the scene and is also responsible for rendering the text on to the scene. Components
    to the canvas element can also be added directly by right-clicking on it. You
    can also add empty game objects to it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单中的Canvas选项表示文本组件在场景中的位置，并负责将文本渲染到场景中。也可以通过右键单击它直接向画布元素添加组件。您还可以向其中添加空游戏对象：
- en: '![](img/image_05_006.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_006.png)'
- en: 'Canvas is made up three scripts: Canvas, Canvas Scalar, and Graphics Ray Caster.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas由三个脚本组成：Canvas、Canvas Scalar和Graphics Ray Caster。
- en: By default, the canvas is set to Screenspace Overlay. There is also Screenspace
    Camera and World Space options. In Screenspace Overlay, the text will set on top
    of everything in the scene irrespective of whether the camera is in focus. This
    is used in traditional games where the UI needs to sit on top of the game.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，画布设置为ScreenSpace Overlay。还有ScreenSpace Camera和World Space选项。在ScreenSpace
    Overlay中，文本将置于场景中的所有内容之上，无论摄像头是否聚焦。这在传统游戏中使用，其中UI需要位于游戏之上。
- en: If you want different UIs depending on which camera is selected, you can use
    ScreenSpace Camera and then you can attach different UIs to the cameras. To navigate
    between the different UIs, you will go back and forth between the cameras for
    the two UIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要根据所选的摄像头来使用不同的用户界面，您可以使用ScreenSpace Camera，然后可以为不同的摄像头附加不同的用户界面。要在不同的用户界面之间导航，您需要在两个用户界面对应的摄像头之间来回切换。
- en: In World Space, the canvas is placed with respect to the world position. So,
    you can place the button or text in 3D space and position it accordingly. You
    can move, rotate, and scale the text as well. The user will still be able to navigate
    and use the UI element. This gives absolute freedom to place the UI element wherever
    you want in the 3D space.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在世界空间中，画布是根据世界位置放置的。因此，您可以在3D空间中放置按钮或文本，并相应地定位它们。您还可以移动、旋转和缩放文本。用户仍然能够导航和使用UI元素。这为放置UI元素提供了在3D空间中任意位置的绝对自由。
- en: You can select the Pixel Perfect option if you want your text to be aligned
    to a pixel grid. Canvas Scalar will scale the text up and down based on the resolution.
    By default, it is set to Constant Pixel Size. You can also set it to Scale with
    Screen Size or Constant Physical size.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望文本对齐到像素网格，可以选择Pixel Perfect选项。Canvas Scalar会根据分辨率放大或缩小文本。默认情况下，它设置为常量像素大小。您也可以将其设置为与屏幕大小成比例或常量物理大小。
- en: The Graphics RayCaster script is responsible for getting input from the keyboard,
    mouse, or touch. If removed, the UI element will no longer accept mouse clicks
    and keyboard events.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Graphics RayCaster脚本负责从键盘、鼠标或触摸获取输入。如果移除，UI元素将不再接受鼠标点击和键盘事件。
- en: Talking about the EventSystem option, let us look at the EventSystem components.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论事件系统选项时，让我们看看事件系统组件。
- en: 'An EventSystem is also created. The event system handles input from mouse,
    keyboard, and controllers. If you want certain events to be triggers at the click
    of the mouse, this would be specified here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还创建了一个EventSystem。事件系统处理来自鼠标、键盘和控制器的事件。如果您想在某些事件在鼠标点击时触发，这里将指定：
- en: '![](img/image_05_007.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_007.png)'
- en: 'Whenever you create and new UI component and new Canvas and EventSystem is
    automatically created. Select the text so that we can have a closer look at the
    component in detail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您创建一个新的UI组件和新的Canvas时，EventSystem也会自动创建。选择文本，这样我们就可以详细查看组件：
- en: '![](img/image_05_008.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_008.png)'
- en: A UI game object is just like any other game object, but unlike others, it has
    `RectTransform` instead of a regular transform, has a Canvas Renderer, and also
    has a Text (Script) option attached to it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: UI游戏对象就像任何其他游戏对象一样，但与它们不同的是，它有一个`RectTransform`而不是常规变换，有一个Canvas Renderer，并且还附加了一个文本（脚本）选项。
- en: Rect Transform is made up of different properties. The important one is positions;
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Rect Transform由不同的属性组成。其中重要的是位置；
- en: 'the others are width and height. These depend on how our anchors are set up.
    By default, Rect Transform is set to middle and center. You can click on the Anchor
    Presents option to change the preset:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的是宽度和高度。这些取决于我们的锚点如何设置。默认情况下，Rect Transform设置为居中和中心。您可以点击锚点选项来更改预设：
- en: '![](img/image_05_009.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_009.png)'
- en: 'Changing Anchor Presets will also affect the X and Y positions of the button
    or text on the scene. Anchors can also be manually changed as per your requirement:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更改锚点预设也会影响场景中按钮或文本的X和Y位置。锚点也可以根据您的需求手动更改：
- en: '![](img/image_05_010.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_010.png)'
- en: Next, we will talk about the Pivot field. The pivot is the position around which
    the UI will rotate. Then, there are Rotate and Scale fields, which work as other
    transform objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论枢轴字段。枢轴是UI将围绕其旋转的位置。然后，还有旋转和缩放字段，它们与其他变换对象类似。
- en: Now, let's look at the Text Script. The Text Script has a text box. This is
    where you can type whatever text you want be displayed on to the scene.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看文本脚本。文本脚本有一个文本框。这就是您可以输入要在场景中显示的任何文本的地方。
- en: After that, there is the Character section. Here, you can change the property
    of the character. You can change the font, font style--that is, if you want normal,
    bold, or italic; size of the font--and line spacing. Note that Unity doesn't let
    you set the distance between the characters horizontally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，是角色部分。在这里，您可以更改角色的属性。您可以更改字体、字体样式--即如果您想要正常、粗体或斜体；字体大小--以及行间距。请注意，Unity不允许您设置字符的水平间距。
- en: The Paragraph section lets you control the position, color, and material of
    the paragraph itself. You can center align the paragraph, set the horizontal and
    vertical overflow, or set it to best fit.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 段落部分允许您控制段落本身的位置、颜色和材质。您可以居中对齐段落，设置水平和垂直溢出，或设置为最佳拟合。
- en: 'Instead of a Text, if you add an Image UI element, Canvas and EventSystem are
    maintained, but the image itself has the usual Rect Transform and Canvas Renderder
    properties. Instead of the Text (Script), there is an Image (Script) that is added:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您添加一个图像UI元素，Canvas和EventSystem会保持不变，但图像本身具有通常的Rect Transform和Canvas Renderer属性。代替文本（脚本），有一个图像（脚本）被添加：
- en: '![](img/image_05_011.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_011.png)'
- en: Image (Script) has fewer objects in it. We have the Source Image option in which
    you can specify the image to be displayed. You can change the color or material
    of the image as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图像（脚本）包含较少的对象。我们有源图像选项，其中您可以指定要显示的图像。您还可以更改图像的颜色或材质。
- en: With all this information, let's add player and enemy text and also a gameover
    text overlay, which will appear once the game is over.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了所有这些信息之后，让我们添加玩家和敌人文本，以及一个游戏结束文本覆盖层，该覆盖层将在游戏结束后出现。
- en: Adding GUI for health and gameover
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加健康和游戏结束的GUI
- en: In the game scene, add three texts and name them `enemyHealthText`, `playerHealthText`,
    and `gameOverText`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏场景中，添加三个文本并分别命名为`enemyHealthText`、`playerHealthText`和`gameOverText`。
- en: 'The enemyHealthText text is positioned, as shown in the following screenshot,
    with the anchor at the center and the font height set to 32\. The rest are set
    to default:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人生命值文本（enemyHealthText）的位置，如以下截图所示，锚点位于中心，字体高度设置为32。其余的设置为默认：
- en: '![](img/image_05_012.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_012.png)'
- en: 'The playerHealthText text is set at a position, as shown in the following screenshot,
    with text height changed to 32:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家生命值文本（playerHealthText）被设置在以下截图所示的位置，文本高度更改为32：
- en: '![](img/image_05_013.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_013.png)'
- en: The text color has been changed to blue for the enemy and red for the player.
    The gameoverText text is set to the middle of the canvas, with text height set
    to 75 and the color set to a nice purple so that it is easily visible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人的文本颜色已更改为蓝色，玩家的文本颜色为红色。游戏结束文本（gameoverText）被设置为画布的中间，文本高度设置为75，颜色设置为漂亮的紫色，以便易于识别。
- en: In the Text field, add the text GAME OVER!!!, as shown in the following screenshot:.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本字段中添加文本GAME OVER!!!，如下截图所示：
- en: '![](img/image_05_014.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_014.png)'
- en: One thing we haven't seen yet is how to control the text by code. Let's see
    next how to do that.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到的是如何通过代码控制文本。让我们看看接下来如何做到这一点。
- en: 'In the gameScript script, add three public variables of type `Text`, as given
    the following code snippet. This will hold the text object from the `Text` UI
    elements created:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在gameScript脚本中，添加三个类型为`Text`的公共变量，如下代码片段所示。这将保存从`Text` UI元素创建的文本对象：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will also need to add the UI namespace at the top of the class for it to
    work, so add the following line at the top of the class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在类的顶部添加UI命名空间，以便它能够正常工作，因此请在类的顶部添加以下行：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, in the `Update` function, after we get the health values from the enemy
    and the player, assign the values to the newly created text variables as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Update`函数中，在我们从敌人和玩家获取生命值之后，将值分配给新创建的文本变量，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `MainCamera` on which `gameScript` is attached, make sure you drag and drop
    enemyHealthText (Text), playerHealthText (Text), and gameOverText (Text) from
    the Hierarchy on to the script component, as shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainCamera`上，其中附加了`gameScript`，确保你将敌人生命值文本（Text）、玩家生命值文本（Text）和游戏结束文本（Text）从层次结构拖放到脚本组件上，如下截图所示：
- en: '![](img/image_05_015.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_015.png)'
- en: 'Finally, to make sure that the gameover text only appears once it is game over,
    in the start function of gameScript, disable `gameOverText`, as shown in the following
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了确保游戏结束文本仅在游戏结束时出现，在gameScript的start函数中禁用`gameOverText`，如下代码所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `Update`  function, once the `bGameover` Boolean variable is set to
    `true`, enable the `gameOverText` as shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`函数中，一旦将`bGameover`布尔变量设置为`true`，启用`gameOverText`，如下代码所示：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, if you run the game, you will see the score getting updated:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏，你会看到分数正在更新：
- en: '![](img/image_05_016.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_016.png)'
- en: 'Once the game is over, you will see the gameover text overlay:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束后，你将看到游戏结束文本叠加：
- en: '![](img/image_05_017.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_017.png)'
- en: Now that we are done with the gameplay, let's add some effects to the scene
    using Particle Effect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了游戏玩法，让我们使用粒子效果为场景添加一些效果。
- en: Introduction to Particle Effects
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子效果简介
- en: Particle Effects are a very big part of a game experience; they add ambience
    to the game or let us know that something special is going to happen or is happening.
    We see particles in the form of dust, clouds, rain, and also in the form of the
    celebration that happens at the end of the game. They can really be whatever you
    plan to make of them. For the purpose of our game, we are going to add confetti
    at the gameover.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子效果是游戏体验的重要组成部分；它们为游戏增添氛围，或让我们知道即将发生或正在发生某些特别的事情。我们以尘埃、云、雨的形式看到粒子，也在游戏结束时的庆祝活动中看到。它们可以真正地成为你计划制作的一切。为了我们游戏的目的，我们将在游戏结束时添加纸屑。
- en: 'A particle system in Unity is also a game object, so to create a particle system,
    go to the GameObject menu and select the Particle System option:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的粒子系统也是一个游戏对象，因此要创建粒子系统，请转到GameObject菜单并选择粒子系统选项：
- en: '![](img/image_05_018.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_018.png)'
- en: Press the *F* key on the keyboard to highlight the Particle System option as
    it might be created away from the main camera. In my case, it was created at 900,
    300, and -26\. Don't worry about the positioning of the particle. We will manually
    change where we want the particle to be created at the end when we want it to
    be spawned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 按下键盘上的 *F* 键以突出显示粒子系统选项，因为它可能是在远离主相机的地方创建的。在我的例子中，它是在 900，300 和 -26 处创建的。不用担心粒子的定位。当我们想要粒子在最后被生成时，我们将手动更改其位置。
- en: 'Once you zoom in on the Particle System, you will see a cone shape and see
    particles coming out of the shape. The cone specifies the shape of the emitter,
    and the white particles are the actual particles that are emitted from the Particle
    System. This is represented by the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你放大粒子系统，你会看到一个圆锥形，并看到粒子从形状中出来。圆锥指定了发射器的形状，而白色的粒子是实际从粒子系统中发射出来的粒子。这由以下截图表示：
- en: '![](img/image_05_019.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_019.png)'
- en: Like any game object, you will also see three arrows that let you position the
    particle system. You also need to press the *Q*, *W*, and *E* keys to position,
    rotate, and scale the size of the emitter, respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何游戏对象一样，你也会看到三个箭头，这些箭头让你能够定位粒子系统。你还需要按下 *Q*、*W* 和 *E* 键来分别定位、旋转和缩放发射器的大小。
- en: Once you select Particle System in the Hierarchy, it will show how the particles
    will be created in the scene. If you select some other object or deselect the
    Particle System, the animation stops. So, if you would like to preview how the
    particles are getting created, then select the Particle System in the Hierarchy
    to get a preview of it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在层次结构中选择粒子系统，它将显示粒子在场景中是如何创建的。如果你选择其他对象或取消选择粒子系统，动画将停止。因此，如果你想预览粒子是如何创建的，那么请在层次结构中选择粒子系统以预览其效果。
- en: 'Let''s see some of the important parameters that you can modify in the Inspector
    pane for the Particle System:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可以在粒子系统的检查器面板中修改的一些重要参数：
- en: '![](img/image_05_020.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_020.png)'
- en: 'Like all other game objects, you can position, rotate, and scale the Particle
    System, the first set of parameters are as shown in the following screenshot.
    These parameters control how the particles are initially created:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有其他游戏对象一样，你可以定位、旋转和缩放粒子系统，第一组参数如下所示。这些参数控制粒子最初是如何创建的：
- en: '![](img/image_05_021.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_021.png)'
- en: 'A brief description of all the parameters is given here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了所有参数的简要描述：
- en: 'Duration: This specifies for how long initially the particles are created.
    By default, it is set to 5 seconds. At present, you won''t see a difference as
    looping is enabled. If you disable looping, then if you select Particle System
    in the Hierarchy, you will see that the particles emit for 5 seconds and then
    stop.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间：此参数指定粒子最初创建的持续时间。默认情况下，它设置为 5 秒。目前，由于启用了循环，你不会看到任何区别。如果你禁用循环，那么如果你在层次结构中选择粒子系统，你会看到粒子发射
    5 秒后停止。
- en: 'Looping: This should be disabled if you don''t want the particles to be spawned
    continuously. So, if you want a burst of particles, disable looping.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：如果你不希望粒子持续生成，则应禁用此选项。因此，如果你想产生粒子爆发，请禁用循环。
- en: 'Prewarm: This parameter loads the particles beforehand so that it won''t look
    as if the particles are getting generated at the start of the scene. For example,
    if you have a water fall particle system and when the scene loads, it should look
    as if the water fall was running before the scene was loaded. If the waterfall
    starts to form just after the scene was loaded, it won''t look practical.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预热：此参数在场景开始之前加载粒子，这样就不会看起来像粒子是在场景开始时生成的。例如，如果你有一个瀑布粒子系统，当场景加载时，它应该看起来像瀑布在场景加载之前就已经在运行了。如果瀑布是在场景加载后立即开始形成，那么它看起来就不太实际。
- en: 'Start Delay: You can set the particles form after a delay in using this parameter.
    Right now the particles start forming right after you click the particle system
    in the hierarchy, but if you want the particles to be formed a second after, then
    you will type `1.0` and the particles will form a second after you click the Particle
    System.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始延迟：你可以使用此参数设置粒子在一段时间后形成。目前，粒子在你点击层次结构中的粒子系统后立即开始形成，但如果你想让粒子在点击粒子系统后一秒形成，那么你需要输入
    `1.0`，粒子将在你点击粒子系统后一秒形成。
- en: 'Start Lifetime: Each particle lasts for a certain period of time and then it
    gets deleted from the scene. By default, the particle is always set to be deleted
    after 5 seconds. If you want the particle to last longer in the scene, this parameter
    can be changed to cater to your needs.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始寿命：每个粒子持续一段时间后从场景中删除。默认情况下，粒子总是设置为在5秒后删除。如果您希望粒子在场景中持续更长时间，则可以更改此参数以满足您的需求。
- en: 'Start Speed: This is the initial speed of each particle. By default, this is
    also set to 5.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始速度：这是每个粒子的初始速度。默认情况下，这也设置为5。
- en: 'Start Size: This is the initial size of the particle. By default, it is set
    to 1\. It is the particle object in the initial size that it was created. If you
    created particles bigger and you would like to reduce the size by half, you will
    type in 0.5.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始大小：这是粒子的初始大小。默认情况下，它设置为1。这是在初始大小下创建的粒子对象。如果您创建了更大的粒子并希望将其大小减半，则输入0.5。
- en: 'Start Rotation: If you want the particles to be generated at an angle in which
    they were created, then you can set the angle here.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始旋转：如果您希望粒子以创建时的角度生成，则可以在此设置角度。
- en: 'Randomize Rotation: If you want the particles to be created at different angles,
    then you can specify the angle here. Unlike start rotation, which would create
    all the particles at the same angle, randomize rotation will create each particle
    at a different angle.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机化旋转：如果您希望粒子以不同的角度创建，则可以在此指定角度。与开始旋转不同，开始旋转会创建所有粒子以相同的角度，而随机化旋转将为每个粒子创建不同的角度。
- en: 'Start Color: This specifies the initial color in which each of the particles
    is created. By default, it is set to white. You can change the color by clicking
    on the white bar and specifying the color.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始颜色：这指定了每个粒子创建时的初始颜色。默认情况下，它设置为白色。您可以通过单击白色条并指定颜色来更改颜色。
- en: '![](img/image_05_022.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_022.png)'
- en: 'Gravity Modifier: This enables gravity. By default, the value is set to 0,
    meaning that there is no gravity. If you set the value to 1, you have enabled
    gravity to the maximum. You can also set the value to between zero and one for
    an appropriate gravity level as you desire.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力修改器：这启用了重力。默认情况下，值设置为0，表示没有重力。如果您将值设置为1，则已启用最大重力。您还可以将值设置为介于零和一之间的适当重力水平，以满足您的需求。
- en: 'Simulation Space: This specifies all the changes that are made after the each
    particle locally; that is, with respect to the origin of individual particle.
    By default, set it to local.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟空间：这指定了在每个粒子局部之后所做的所有更改；即，相对于单个粒子的原点。默认情况下，设置为局部。
- en: 'Simulation Speed: This specifies the speed at which the simulation is calculated.
    You can speed up or slow down the simulation. This is useful to see how your particles
    will behave if you have a particle system that takes time to mature.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟速度：这指定了模拟计算的速度。您可以加快或减慢模拟速度。这对于查看您的粒子系统成熟所需时间的行为非常有用。
- en: 'Scale Mode: Set this to local. This specifies that the scale affects each particle
    with respect to the particle''s origin and not the origin of the emitter or the
    world.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放模式：将其设置为局部。这指定了缩放会影响每个粒子相对于粒子的原点，而不是发射器或世界的原点。
- en: 'Play on Awake: The particles system becomes active as soon as the scene starts.
    If you don''t wish the particle to start immediately at the start of the scene,
    then you need to uncheck this parameter.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景开始时播放：粒子系统会在场景开始时立即激活。如果您不希望粒子在场景开始时立即启动，则需要取消选中此参数。
- en: 'Max Particles: This is the maximum number of particles that can be present
    in the scene at a time. By default, set it to 1,000\. This should be kept as minimum
    as possible as it would significantly reduce the performance of the game, because
    the more particles you have in the scene, the more render calls are required and
    more calculation is required for each particle.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大粒子数：这是场景中一次可以存在的最大粒子数。默认情况下，设置为1,000。这应该尽可能保持最小，因为它会显着降低游戏性能，因为场景中的粒子越多，所需的渲染调用就越多，每个粒子的计算也越多。
- en: 'Auto Random: Seed generates a seed to automatically randomize the spawn and
    movement of each of the particle.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动随机：种子生成一个种子以自动随机化每个粒子的生成和移动。
- en: 'The next set of parameters is optional and requires checking and unchecking
    if you would like to enable or disable these features:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数集是可选的，如果您想启用或禁用这些功能，则需要检查和取消选中：
- en: 'Emission: This specifies the amount of particles getting generated in a second.
    The Rate over Time option is set to 10, meaning there are 10 particles generated
    in a span of 1 second. If you set it to 1, then you will see 1 particle each second.
    The Rate over Distance option will work only when World Space Simulation is used.
    In the Bursts mode, you can create a burst of particle depending on the duration
    that you initially set. So, here, when you click on the + icon, it will create
    30 particles every 5 seconds:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射量：这指定了每秒生成的粒子数量。时间速率选项设置为10，意味着在1秒内生成10个粒子。如果您将其设置为1，那么您将每秒看到1个粒子。距离速率选项仅在启用世界空间模拟时生效。在爆发模式中，您可以根据最初设置的持续时间创建粒子爆发。因此，在此处，当您点击加号图标时，它将每5秒生成30个粒子：
- en: '![](img/image_05_023.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_023.png)'
- en: 'Shape: This specifies the shape of the particle system itself. By default,
    it is set to Cone. Since the Particle System is the shape of the cone, you can
    see that the particles are generated and move upward in the specified shape. If
    you want the particle to spread in all directions, then you can specify sphere.
    You can also select between box, mesh, circle, and edge. By selecting mesh, you
    can specify a certain mesh and let the particle be generated from that specified
    mesh shape.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状：这指定了粒子系统的形状。默认情况下，它设置为圆锥形。由于粒子系统的形状是圆锥形，您可以看到粒子从指定的形状中生成并向上移动。如果您想让粒子向所有方向扩散，则可以指定球体。您还可以选择盒子、网格、圆形和边缘。通过选择网格，您可以指定一个特定的网格，并让粒子从该指定的网格形状生成。
- en: There are other parameters as well, such as angle, radius.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他参数，例如角度、半径。
- en: 'Emit from: This specifies from where the particles will be generated from,
    such as Base, Base Shell, Volume, and Volume Shell.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射位置：这指定了粒子将从哪里生成，例如基础、基础壳体、体积和体积壳体。
- en: 'You can also randomize the direction or align to a specific direction:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以随机化方向或对齐到特定方向：
- en: '![](img/image_05_024.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_024.png)'
- en: 'Velocity over Lifetime: If you would like the velocity to be changed over time,
    then you can specify here. If not specified, then the speed would be kept constant,
    and it would be the same that was set initially.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期内速度：如果您想改变速度随时间变化，则可以在此处指定。如果没有指定，则速度将保持恒定，并且将与最初设置的速度相同。
- en: 'Limit velocity Over Lifetime: This can limit the speed of the particle so that
    once the particle has reached a specific speed over lifetime, it is set either
    to that speed or slowly reduces over time to the initial speed set.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期内限制速度：这可以限制粒子的速度，使得一旦粒子在生命周期内达到特定的速度，它将被设置为该速度，或者随着时间的推移缓慢地降低到初始设置的速度。
- en: 'Inherit Velocity: This controls the speed of the particle depending on the
    speed of the emitter itself. The faster the emitter moves, the faster the particles
    are.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承速度：这根据发射器的速度来控制粒子的速度。发射器移动得越快，粒子就移动得越快。
- en: 'Force Over Lifetime: This sets the force of each particle over the lifetime.
    So, the particle will move faster over a period of time if this value is set.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期内力：这设置了每个粒子在生命周期内的力。因此，如果这个值被设置，粒子将在一段时间内移动得更快。
- en: 'Color Over Lifetime: The color of each particle can be changed depending on
    when it was generated.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期内着色：每个粒子的颜色可以根据其生成的时间进行更改。
- en: 'Color by Speed: The color of each particle is specified by the speed of the
    particle itself.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据速度着色：每个粒子的颜色由粒子自身的速度指定。
- en: 'Similarly, we have size and rotation, which are either controlled by what stage
    they are in their lifetime or the speed at which they are moving:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们还有大小和旋转，这些由它们在其生命周期中的阶段或移动速度控制：
- en: 'External Force: You can simulate the exertion of external force on the particle
    by changing the multiplier on the external force, for example, the case of wind.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部力：您可以通过改变外部力的乘数来模拟对粒子施加的外部力，例如风的情况。
- en: 'Noise: You can also generate randomness using noise, which will use perlin
    noise-like texture to create random movement and behavior of the particles:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 噪声：您还可以使用噪声生成随机性，这将使用类似Perlin噪声的纹理来创建粒子的随机运动和行为：
- en: '![](img/image_05_025.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_025.png)'
- en: 'Collision: The particles as of yet won''t react to other objects in the scene,
    so if you place an object in from of the particle, the particle would just go
    through the object. When you enable collision, the particle will collide with
    the object instead of going through it:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞：到目前为止，粒子不会对场景中的其他对象做出反应，所以如果你在粒子前面放置一个对象，粒子就会穿过该对象。当你启用碰撞时，粒子会与对象碰撞而不是穿过它：
- en: '![](img/image_05_026.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_026.png)'
- en: 'Triggers: Particles can also be used as triggers if the Triggers option setting
    is turned on:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器：如果触发器选项设置被打开，粒子也可以用作触发器：
- en: '![](img/image_05_027.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_027.png)'
- en: 'Sub Emitter: Each particle can also emit objects when you enable the Sub Emitter
    option. Also, each particle will also emit other particles.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子发射器：当你启用子发射器选项时，每个粒子也可以发射对象。此外，每个粒子也会发射其他粒子。
- en: 'Texture Sheet Animation: Instead of static images, you can also specify a texture
    sheet so that each particle is animated instead of displaying a static image:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理表动画：除了静态图像外，你还可以指定一个纹理表，以便每个粒子可以动画化，而不是显示静态图像：
- en: '![](img/image_05_028.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_028.png)'
- en: 'Lights and Trils: Each particle can also have a light source and trails attached
    to them to make the scene more eye catching and pretty.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光源和尾迹：每个粒子也可以附加光源和尾迹，使场景更加引人注目和美观。
- en: 'Renderer: This specifies a lot of parameters like the shape of the particle
    itself, if it needs to be a billboard or a mesh. So, in a mesh, you can specify
    3D objects such as a box, sphere, cone, and the normal direction of the particle
    and the material.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染器：这指定了许多参数，例如粒子本身的形状，是否需要是广告牌或网格。因此，在网格中，你可以指定3D对象，如盒子、球体、圆锥体，以及粒子的法向和材质。
- en: 'You can specify the sort mode, minimum and maximum particle size, alignment,
    and pivot. Each particle and cast receiving shadows has light probes, reflects
    light probes, and so on:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定排序模式、最小和最大粒子大小、对齐和中心点。每个粒子以及接收阴影的投射都有光探针、反射光探针等：
- en: '![](img/image_05_029.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_029.png)'
- en: Creating confetti Particle Effect
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建五彩纸屑粒子效果
- en: For the confetti, we create a Particle System as usual. For the initial values,
    we keep the position to be 0,0,-7.5\. For rotation and scale value, we keep at
    default.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于五彩纸屑，我们像往常一样创建一个粒子系统。对于初始值，我们将位置保持在0,0,-7.5。对于旋转和缩放值，我们保持默认设置。
- en: We keep the duration at 4 and uncheck the Looping option as we don't want the
    confetti to be created over and over. Start Delay is set to 0.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将持续时间保持在4，并取消选中“循环”选项，因为我们不希望五彩纸屑反复创建。起始延迟设置为0。
- en: Start Speed is set to 5 and 3D Start Size is set to 0.25 in the `X`, `Y`, and
    `Z` directions. The 3D Start Rotation option is disabled. Start Rotation and Randomize
    Rotation are set to 0.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 起始速度设置为5，3D起始大小在`X`、`Y`和`Z`方向上设置为0.25。3D起始旋转选项被禁用。起始旋转和随机旋转设置为0。
- en: Start Color is set to randomize between two colors, red and blue. Gravity Multipler
    is set to 0.125, and we want the confetti to fall down after it has reached its
    maximum height.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 起始颜色设置为在两种颜色之间随机，红色和蓝色。重力乘数设置为0.125，我们希望五彩纸屑在达到最大高度后开始下落。
- en: 'The rest of the initial values are set to default:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的初始值都设置为默认值：
- en: '![](img/image_05_030.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_030.png)'
- en: Emission is set to 20 for Rate over Time, and Shape is set to Cone.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间设置为20，形状设置为圆锥形。
- en: To make the confetti more colorful and also change color over time, the color
    over lifetime is changed. So, change it to your needs. The Color over Speed parameter
    is also changed similarly. Both are set to Random Between 2 Gradients.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使五彩纸屑更加多彩，并且随时间改变颜色，将“生命周期中的颜色”更改为所需颜色。因此，根据需要更改它。颜色随速度参数也以类似方式更改。两者都设置为“在两个渐变之间随机”。
- en: Size over lifetime is changed so that the size of the particles changes over
    time. Size is set to a curve so that the particle starts out small and then becomes
    full size at the end of the lifecycle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 随时间变化的大小被更改，以便粒子的尺寸随时间变化。大小设置为曲线，这样粒子在生命周期开始时较小，然后在生命周期结束时变为全尺寸。
- en: 'The shape of the curve is as shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的形状如下截图所示：
- en: '![](img/image_05_031.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_031.png)'
- en: 'The Rotation over Lifetime and Rotation by Speed options are set to 45 so that
    the particles rotate in air once created:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期中的旋转和速度旋转选项设置为45，这样粒子在创建后会在空中旋转一次：
- en: '![](img/image_05_032.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_032.png)'
- en: 'For Renderer, I wanted to take 3D objects as particles, so I selected Mesh,
    and for Mesh, I selected Cube, Cylinder, and Sphere by clicking the + sign at
    the bottom. Rest of the values are kept as default:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渲染器，我想将3D对象作为粒子，所以我选择了Mesh，对于Mesh，我通过点击底部的+号选择了Cube、Cylinder和Sphere。其余的值保持默认：
- en: '![](img/image_05_033.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_033.png)'
- en: 'Now, our Particle System is created. We will now create a prefab object in
    the `Assets` folder and drag the Particle System in it so that we can instantiate
    the prefab at gameover. Call the prefab particleSystem. You will notice that once
    you drag the Particle System into the prefab, it becomes blue, as shown in the
    following screenshot. Now, delete the Particle System from the Hierarchy:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的粒子系统已经创建。我们将在`Assets`文件夹中创建一个预制件对象，并将粒子系统拖放到其中，以便在游戏结束时实例化预制件。将预制件命名为particleSystem。你会注意到，一旦将粒子系统拖放到预制件中，它就会变成蓝色，如下面的截图所示。现在，从层次结构中删除粒子系统：
- en: '![](img/image_05_034.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_034.png)'
- en: 'Next in gameScript, create a new `GameObject` at the top and call it `particlePrefab`
    and make the variable `public`, as given in the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在gameScript中，在顶部创建一个新的`GameObject`，命名为`particlePrefab`，并将变量设置为`public`，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `Update`  function, after the `gameover` Boolean variable is set to
    instantiate the particle prefab as following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`函数中，在将`gameover`布尔变量设置为实例化粒子预制件之后：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Don''t forget to drag and drop the particleSystem prefab on to Particle Prefab
    in the gameScript script component that is attached to the MainCamera:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将particleSystem预制件拖放到MainCamera附加的游戏脚本组件中的Particle Prefab上：
- en: '![](img/image_05_035.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_035.png)'
- en: 'Now, when you run the game and when it is gameover, you will have a nice confetti
    Particle System:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行游戏并且游戏结束时，你将有一个漂亮的纸屑粒子系统：
- en: '![](img/image_05_036.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_036.png)'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to add in a GUI element to show the player's and
    enemy's health and also added the gameover text so that we know that it is the
    end of the game. We also added a very basic particle system just to demonstrate
    the ability to add particles. You can go in and change the particle system to
    see what more can be done.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何添加一个GUI元素来显示玩家和敌人的生命值，并且添加了游戏结束文本，以便我们知道游戏已经结束。我们还添加了一个非常基础的粒子系统，只是为了展示添加粒子的能力。你可以进入并更改粒子系统，看看还能做些什么。
- en: The gameplay is over, and next, we can see how to add in scenes to the game,
    so we will create a main menu scene, which will show at the start of the game.
    We will also see how to add buttons so that at the click of the play button, the
    scene will swap to the gameplay scene.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏玩法已经结束，接下来我们可以看看如何将场景添加到游戏中，因此我们将创建一个主菜单场景，它将在游戏开始时显示。我们还将了解如何添加按钮，以便在点击播放按钮时，场景将切换到游戏玩法场景。
