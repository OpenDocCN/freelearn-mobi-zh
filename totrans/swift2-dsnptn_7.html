<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Behavioral Patterns – Iterator, Mediator, and Observer</h1></div></div></div><p>This chapter presents you with three other behavioral patterns, which support communication between objects. Objects keep their independence and sometimes their anonymity. The iterator pattern is often used with array, collection, and dictionary objects. The mediator allows communication between two objects without knowing each other's identities and the observer patterns mirror the publish/subscribe methodologies that are well known in distributed systems.</p><p>This chapter is divided in three sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The iterator pattern</li><li class="listitem" style="list-style-type: disc">The mediator pattern</li><li class="listitem" style="list-style-type: disc">The observer pattern</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec33"/>The iterator pattern</h1></div></div></div><p>This <a class="indexterm" id="id333"/>pattern is <a class="indexterm" id="id334"/>commonly used in many languages with an array or a collection of objects. It allows iteration over a list of objects contained in a collection.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec120"/>Roles</h2></div></div></div><p>The iterator pattern<a class="indexterm" id="id335"/> allows you to iterate sequentially over an aggregated object of objects without having to know how the collection is structured.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec121"/>Design</h2></div></div></div><p>Here, you'll find <a class="indexterm" id="id336"/>the generic UML class diagram of the pattern, but note that we will not implement it using this way.</p><p>Indeed, Swift provides some types that will simplify the implementation of the iterator pattern, without having to produce all of the needed requirements by hand.</p><p>Why reinvent the wheel? The following figure represents the generic UML class diagram:</p><div><img alt="Design" src="img/4852_07_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec122"/>Participants</h2></div></div></div><p>As with every <a class="indexterm" id="id337"/>pattern described up to now, I will tell you what the participants in this pattern are even if we will not see all of them in our implementation of the pattern:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Collection</code>: This <a class="indexterm" id="id338"/>is an abstract class that implements the association of the collection with items and the <code class="literal">CreateIterator()</code> method</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteCollection</code>: This is<a class="indexterm" id="id339"/> concrete collection subclass that link the <code class="literal">CurrentItem</code> object to a <code class="literal">ConcreteItem</code> object and the <code class="literal">Iterator</code> interface to the <code class="literal">ConcreteIterator</code> objec<code class="literal">t</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Iterator</code>: This is<a class="indexterm" id="id340"/> the abstract class, which implements the association of the iterator and the collection items and methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteIterator</code>: This<a class="indexterm" id="id341"/> is a concrete subclass that links our <code class="literal">currentItem</code> to the <code class="literal">ConcreteItem</code> object</li><li class="listitem" style="list-style-type: disc"><code class="literal">Item</code>: This is the <a class="indexterm" id="id342"/>abstract class of the collection items</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteItem</code>: This is<a class="indexterm" id="id343"/> a concrete <code class="literal">Item</code> subclass used by <code class="literal">ConcreteIterator</code> and <code class="literal">ConcreteCollection</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec123"/>Collaboration</h2></div></div></div><p>The iterator <a class="indexterm" id="id344"/>keeps in memory the current item in the collection. It can also calculate and predict the next object of the iteration.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec124"/>Illustration</h2></div></div></div><p>You are <a class="indexterm" id="id345"/>developing a game in which you can have up to say, four players. You want to be able to iterate over all the four players to do something. In our sample, we will display the name of each player.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec125"/>Implementation</h2></div></div></div><p>The <a class="indexterm" id="id346"/>implementation provided here comes from ideas discovered on the Lilly Labs website at <a class="ulink" href="http://lillylabs.no/2014/09/30/make-iterable-swift-collection-type-sequencetype/">http://lillylabs.no/2014/09/30/make-iterable-swift-collection-type-sequencetype/</a>.</p><p>Well, given our illustration what we want to be able to do is to iterate using a <code class="literal">for…in</code> loop construct.</p><p>All thanks to Swift, we have some elements that will simplify the implementation of this pattern.</p><p>Indeed, Swift proposes a <code class="literal">SequenceType</code> protocol and an <code class="literal">AnyGeneratorType&lt;T&gt;</code> class, which implements the <code class="literal">GeneratorType</code> protocol.</p><p>The <code class="literal">SequenceType</code> protocol defines a protocol that allows us to iterate over elements of a collection using the <code class="literal">for…in</code> loop construct. It requires that the class implements the <code class="literal">generate()</code> method, which returns an object conforming to the <code class="literal">GeneratorType</code> protocol.</p><p>
<code class="literal">AnyGenerator&lt;T&gt;</code> is a class that conforms to the <code class="literal">GeneratorType</code> protocol, where <code class="literal">&lt;T&gt;</code> means <code class="literal">Item</code> of any type.</p><p>Having said this, how do we use all of the preceding functions to easily iterate over a collection of any type? Let's say, we have the following class:</p><div><pre class="programlisting">class Player {
  var name: String!
  
  init(name: String) {
   self.name = name
  }
}</pre></div><p>Therefore, we <a class="indexterm" id="id347"/>define a simple <code class="literal">Player</code> class where we pass a string in the constructor, which corresponds to the name of the player.</p><p>We suppose that we have four players in our game and want to be able to iterate over each of them to display their name.</p><p>Therefore, the final code to test will be something like the following:</p><div><pre class="programlisting">for player in players {
  print("analysing \(player.name)")
}</pre></div><p>Now, how to complete our code with a bonus, something that will works with any class that we want to iterate over? Well, we will use another concept provided by Swift: <strong>extension</strong>.</p><p>The first thing to be done is to create an object or struct that we will let us iterate over any class type:</p><div><pre class="programlisting">struct OurCollection&lt;T&gt; {
  let items: [T]
} </pre></div><p>Therefore, we define a struct that we call <code class="literal">OurCollection</code>, where items are of type <code class="literal">T</code>.</p><p>Now, we will be able to write the following:</p><div><pre class="programlisting">let player1 = Player(name: "Helmi")
let player2 = Player(name: "Raphael")
let player3 = Player(name: "Adrien")
let player4 = Player(name: "Alain")


let players = OurCollection(items:[player1,player2, player3, player4])</pre></div><p>However, the <code class="literal">for…in</code> loop will still not work, as shown in the following screenshot:</p><div><img alt="Implementation" src="img/4852_07_02.jpg"/></div><p>Even though, the players don't implement the <code class="literal">SequenceType</code> protocol. Here is the magic:</p><div><pre class="programlisting">extension OurCollection: SequenceType {
  typealias Generator = AnyGenerator&lt;T&gt;
  
  func generate() -&gt; Generator {
    var i = 0
    return anyGenerator {
      return i &gt;= self.items.count ? nil : self.items[i++]
    }
  }
}</pre></div><p>Wow! Lot of new things here:</p><p>First, we <a class="indexterm" id="id348"/>create an extension of the <code class="literal">OurCollection</code> struct by telling that we want to implement the <code class="literal">SequenceType</code> protocol.</p><p>So we implement the <code class="literal">generate()</code> method, which will return the next type <code class="literal">T</code> object in the iteration. Also, note the line:</p><div><pre class="programlisting">
<strong>  func generate() -&gt; Generator {</strong>
</pre></div><p>Generator is an alias of <code class="literal">AnyGenerator&lt;T&gt;</code>:</p><div><pre class="programlisting">  typealias Generator = AnyGenerator&lt;T&gt;</pre></div><p>We use this to simplify the writing. We can remove the type alias statement and write:</p><div><pre class="programlisting">
<strong>func generate() -&gt; AnyGenerator&lt;T&gt; {</strong>
</pre></div><p>Another function is the <code class="literal">anyGenerator</code> function tha you see here:</p><div><pre class="programlisting">
<strong>    return anyGenerator {</strong>
<strong>      return i &gt;= self.items.count ? nil : self.items[i++]</strong>
<strong>    }</strong>
</pre></div><p>The Swift 2.0 documentation says that the <code class="literal">anyGenerator</code> function has the following signature:</p><div><pre class="programlisting">func anyGenerator&lt;Element&gt;(body: () -&gt; Element?) -&gt; AnyGenerator&lt;Element&gt;</pre></div><p>The purpose of this function is to return a <code class="literal">GeneratorType</code> instance whose <code class="literal">next</code> method invokes <code class="literal">body</code> and returns the result.</p><p>So here, we start from index <code class="literal">0</code> to index <code class="literal">self.items.count</code> value and add the <code class="literal">sel.items[i++]</code> in the new <code class="literal">GeneratorType</code> instance. The new <code class="literal">GeneratorType</code> instance is returned when <code class="literal">i</code> is superior to a number of elements in the items array.</p><p>We can also write the function such as:</p><div><pre class="programlisting">  func generate() -&gt; Generator {
    var i = 0
   let seq = anyGenerator {i &lt; self.items.count ? self.items[i++] : nil}
    return seq
 }</pre></div><p>And also like this:</p><div><pre class="programlisting">  func generate() -&gt; Generator {
    var i = 0
   return anyGenerator {i &lt; self.items.count ? self.items[i++] : nil}
 }</pre></div><p>Here, we use a <a class="indexterm" id="id349"/>closure with the <code class="literal">anyGenerator</code> function to return a new sequence of elements that we can iterate over. Our final code is as follows:</p><div><pre class="programlisting">import Foundation

struct OurCollection&lt;T&gt; {
  let items: [T]
}

class Player {
  var name: String!
  
  init(name: String) {
   self.name = name
  }
}


extension OurCollection: SequenceType {
  typealias Generator = AnyGenerator&lt;T&gt;
  
  func generate() -&gt; Generator{
    var i = 0
    // Construct a AnyGenerator&lt;T&gt; instance, passing a closure
    // that returns the next type T object in the iteration
    return anyGenerator {
      return i &gt;= self.items.count ? nil : self.items[i++]
    }
  }
}


let player1 = Player(name: "Helmi")
let player2 = Player(name: "Raphael")
let player3 = Player(name: "Adrien")
let player4 = Player(name: "Alain")


let players = OurCollection(items:[player1,player2, player3, player4])

for player in players {
  print("Name: \(player.name)")
}</pre></div><p>Open the <code class="literal">iteratorPattern</code> project, build <a class="indexterm" id="id350"/>and run it. You will now see the following result:</p><div><img alt="Implementation" src="img/4852_07_03.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec34"/>The mediator pattern</h1></div></div></div><p>The <a class="indexterm" id="id351"/>mediator pattern<a class="indexterm" id="id352"/> is used to reduce the coupling between classes that communicate with each other.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec126"/>Roles</h2></div></div></div><p>This <a class="indexterm" id="id353"/>pattern constructs an object, which manages the communication between two or more classes.</p><p>These classes don't know each other's implementation. The message is sent from the class to the mediator object.</p><p>The mediator pattern defines an object that encapsulates how a set of objects will communicate with each other. Mediator promotes loose coupling by keeping objects from referring to each other explicitly and it also lets you vary their interaction independently.</p><p>The mediator is an intermediary used to decouple many peers. This pattern can be used when we want to design reusable components but dependencies between the potentially reusable pieces demonstrate the "spaghetti code" phenomenon.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec127"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id354"/> following class diagram presents the generic structure of the mediator pattern:</p><div><img alt="Design" src="img/4852_07_04.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec128"/>Participants</h2></div></div></div><p>In this pattern, we find the following <a class="indexterm" id="id355"/>participants:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Mediator</code>: This defines the <a class="indexterm" id="id356"/>mediator interface to communicate with elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteMediator</code>: This implements the coordination between elements and manages associations with elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">Elements</code>: This is <a class="indexterm" id="id357"/>the element abstract class, which introduces common attributes, properties, and methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteElement1</code> and <code class="literal">ConcreteElement2</code>: These are<a class="indexterm" id="id358"/> concretes element classes, which <a class="indexterm" id="id359"/>communicate with the mediator instead of communicating with the other elements</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec129"/>Collaboration</h2></div></div></div><p>The elements <a class="indexterm" id="id360"/>send messages to the mediator and receive message from it. The mediator implements the collaboration and coordination between the elements.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec130"/>Illustration</h2></div></div></div><p>You <a class="indexterm" id="id361"/>are writing a system that allows users to communicate with each other. Communication is not sent directly from a peer to another. We will use some mediators that will manage all users and the communication between them.</p><p>For this, each user managed by the mediator will be registered (added) to the mediator. Then, when a user sends a message, we will pass the mediator object as an argument informing the system that this is the message that will broadcast that message to all other users managed by the mediator calling the <code class="literal">receiveMessage</code> function.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec131"/>Implementation</h2></div></div></div><p>Open the<a class="indexterm" id="id362"/> <code class="literal">MediatorPattern</code> Xcode project. This is a command line project that is organized as the following screenshot:</p><div><img alt="Implementation" src="img/4852_07_05.jpg"/></div><p>The organization <a class="indexterm" id="id363"/>of our project is not more than what we have already described with the participants in the class diagram. We retrieve, the <code class="literal">MediatorProtocol</code> and <code class="literal">ConcreteMediator</code> object in the <code class="literal">Mediator</code> folder, our <code class="literal">Elements</code> and concrete elements <code class="literal">UserProtocol</code> and <code class="literal">User</code> are in the <code class="literal">Elements</code> folder and last, the <code class="literal">main.swift </code>file contains our client code to simulate the project.</p><p>First, we define <code class="literal">userProtocol</code>, in the <code class="literal">UserProtocol.swift</code> file:</p><div><pre class="programlisting">protocol UserProtocol {
  func sendMessage(mediator:MediatorProtocol, message:AnyObject)
  func receiveMessage(message:AnyObject)
}</pre></div><p>The <code class="literal">sendMessage</code> method will be used to tell the mediator passed in an argument what the message of the current <code class="literal">concreteUser</code> is. The <code class="literal">receiveMessage</code> method will be raised when the mediator broadcasts the message to all users.</p><p>Then, in the <code class="literal">User.swift</code> file, we implement our protocol, as shown:</p><div><pre class="programlisting">class User: UserProtocol {
  var name: String
  
  init(name: String){
   self.name = name
  }
  
  func sendMessage(mediator:MediatorProtocol, message:AnyObject){
    mediator.broadcastMessage(self, message: message as AnyObject)
  }
  
  func receiveMessage(message:AnyObject){
    print("\(self.name) received \(String(message))")
  }
}</pre></div><p>Here, we add <a class="indexterm" id="id364"/>an argument in the constructor to pass the name of the user.</p><p>In the <code class="literal">sendMessage</code> method, we see that we are calling the <code class="literal">broadcastMessage</code> method of the mediator passed in the argument.</p><p>When raised, the <code class="literal">receiveMessage</code> method will display the name of the current user and also the message that was received.</p><p>Next, lets see how <code class="literal">MediatorProtocol</code> is defined:</p><div><pre class="programlisting">protocol MediatorProtocol {
  var users:[UserProtocol]? { get }
  
  func broadcastMessage(sender:UserProtocol, message:AnyObject)
  func register(users: UserProtocol)
}</pre></div><p>The <code class="literal">MediatorProtocol</code> manages the collection of elements; here, it is <code class="literal">Users</code>. It can also broadcast a particular message to a user.</p><p>To add a user to the collection of users managed by the mediator, we add a <code class="literal">Register</code> method.</p><p>Let's see how we have implemented all of this in the <code class="literal">Mediator.swift</code> file:</p><div><pre class="programlisting">class Mediator: MediatorProtocol {
  private let queue = dispatch_queue_create("MediatorPattern", DISPATCH_QUEUE_CONCURRENT)
  var users:[UserProtocol]? = [User]()
  
  func broadcastMessage(sender:UserProtocol, message:AnyObject){
    dispatch_barrier_sync(self.queue, { () in

      guard let users = self.users else {
        return
      }

      for u in users{
        if u as! User !== sender as! User {
          u.receiveMessage(message)
        }
      }
      
    })
  }
  func register(user: UserProtocol){
    dispatch_barrier_sync(self.queue, { () in
      users?.append(user)
    })
  }
}</pre></div><p>First, we <a class="indexterm" id="id365"/>initialize a <code class="literal">User</code> array that is ready to manage a collection of user.</p><p>In the <code class="literal">register</code> method, we receive a user argument, which is added to the collection managed by the mediator.</p><p>Then, the <code class="literal">broadcastMessage</code> method:</p><div><pre class="programlisting">    guard let users = users else {
      return
    }</pre></div><p>We need to make sure that the <code class="literal">user</code> array has not a <code class="literal">nil</code> value, if this is the case we then do nothing by leaving the method invoking the <code class="literal">return</code> keyword.</p><p>Then, we iterate over all the users in the collection and if the current user of the iteration is different from the user sending the message (sender), then we call the <code class="literal">receiveMessage</code> method of the current user, along with the message to be transmitted.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>
<strong>Concurrency protection</strong>
</p><p>You probably have seen the following line:</p><div><pre class="programlisting">  private let queue = dispatch_queue_create("MediatorPattern", DISPATCH_QUEUE_CONCURRENT)</pre></div><p>We need to create concurrency protection in this pattern when various users try to access the same user at the same time, so we use a technology developed by Apple: Grand Central Dispatch which allow specific tasks in a program that can be run in parallel to be queued up for execution and, depending on availability of processing resources, scheduling them to execute on any of the available processor cores.</p><p>With this line, we initialize <code class="literal">queue</code> as a concurrent queue using <code class="literal">dispatch_queue_create</code>. The first parameter simply describes what our queue is (it could be helpful when you are debugging your code) and the second parameter specifies that we want our queue to be concurrent.</p><p>Next, we want to protect the access to our code where arrays are read and written. For this, GCD provides an elegant solution of creating read/write lock using dispatch barrier. So we use <code class="literal">dispatch_barrier_sync</code> to pass our queue and the statement to execute by the queue. Since, the code we have written is a barrier closure, this will never run simultaneously with any other closure in queue . To see more about Grand Central Dispatch : <a class="ulink" href="http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1">http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1</a>
</p></div></div><p>All our participants are now in place. We will now try all of this in the <code class="literal">main.swift</code> file. We create four users, each with a name:</p><div><pre class="programlisting">var user1 = User(name: "Julien")
var user2 = User(name: "Helmi")
var user3 = User(name: "Adrien")
var user4 = User(name: "Raphael")</pre></div><p>Then, we <a class="indexterm" id="id366"/>instantiate our first mediator and add the first three users we have just created to the collection of users managed by <code class="literal">mediator1</code>:</p><div><pre class="programlisting">var mediator1 = Mediator()
mediator1.register(user1)
mediator1.register(user2)
mediator1.register(user3)</pre></div><p>Now, we want to test that <code class="literal">user1</code> can send a message to <code class="literal">user2</code> and <code class="literal">user3</code>. We only need to invoke the <code class="literal">sendMessage</code> method of <code class="literal">user1</code> passing the <code class="literal">mediator1</code> and the message to be sent:</p><div><pre class="programlisting">user1.sendMessage(mediator1, message: "message1 from \(user1.name)")</pre></div><p>So, in this case only <code class="literal">user2</code> (Helmi) and <code class="literal">user3</code> (Adrien) should receive the message from <code class="literal">user1</code> (Julien).</p><p>We want to try the pattern with another mediator but with only two users: <code class="literal">user2</code> and <code class="literal">user4</code>:</p><div><pre class="programlisting">var mediator2 = Mediator()
mediator2.register(user2)
mediator2.register(user4)

user2.sendMessage(mediator2, message: "message 2 from \(user2.name)")</pre></div><p>Here, only <code class="literal">user4</code> (Raphael) should receive the message from <code class="literal">user2</code> (Helmi).</p><p>Build and run the project. You should now be able to see the following result in the console dialog:</p><div><img alt="Implementation" src="img/4852_07_06.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec35"/>The observer pattern</h1></div></div></div><p>The <a class="indexterm" id="id367"/>observer pattern<a class="indexterm" id="id368"/> is another behavioral pattern that is often used in networked system where a subject (the server) will notify some client. The iOS makes large use of this pattern through <code class="literal">NSNotificationCenter</code> object.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec132"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id369"/>observer pattern creates dependence between a subject and observer so that the observer is notified in order to update their state each time the subject is modified.</p><p>This composition means that observer does not need to ask the current state of the subject. They only need to register to its notifications.</p><p>This pattern can be used when:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A state modification inside the object needs to update other objects dynamically</li><li class="listitem" style="list-style-type: disc">An object wants to prevent other objects without the need to know the type (without having to be high coupled with them)</li><li class="listitem" style="list-style-type: disc">We do not want to merge two objects into one</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec133"/>Design</h2></div></div></div><p>The following <a class="indexterm" id="id370"/>diagram represents the UML class diagram of the observer pattern:</p><div><img alt="Design" src="img/4852_07_07.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec134"/>Participants</h2></div></div></div><p>This pattern is composed of the<a class="indexterm" id="id371"/> following participants:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Subject</code>: This defines the <a class="indexterm" id="id372"/>methods needed to add, remove, and notify observers.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteSubject</code>: This <a class="indexterm" id="id373"/>implements the <code class="literal">Subject</code> methods. It sends a notification when its state is modified.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Observer</code>: This<a class="indexterm" id="id374"/> is a common interface having an <code class="literal">update()</code> method, which will be invoked by the subject when the observer needs to be notified about the modification of the subject.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteObserver1</code> and <code class="literal">ConcreteObserver2</code>: This<a class="indexterm" id="id375"/> implements<a class="indexterm" id="id376"/> the <code class="literal">update()</code> method.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec135"/>Collaboration</h2></div></div></div><p>The <code class="literal">ConcreteSubject</code> class <a class="indexterm" id="id377"/>notifies the observers when its internal state is modified. When a concrete observer receives this notification, it is updated consequently. To complete the update, it can invoke some subject methods that give access to its state.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec136"/>Illustration</h2></div></div></div><p>You <a class="indexterm" id="id378"/>are working on a new website where you want to allow internet users to communicate each other through a chat system. Your first job will be to provide a room, the entry point of all Internet users. Each time a new user joins the room, every user is notified.</p><p>The observer pattern is fully appropriated to implement the code, which solves this problem.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec137"/>Implementation</h2></div></div></div><p>Open the <code class="literal">ObserverPattern</code> Xcode <a class="indexterm" id="id379"/>project to see the current structure of our code:</p><div><img alt="Implementation" src="img/4852_07_08.jpg"/></div><p>We will retrieve the <code class="literal">Subject</code> folder and <code class="literal">Observers</code> folder, where we will find the participants of our pattern. The <code class="literal">Helpers</code> folder contains a class that we will use later when sending a message.</p><p>The <code class="literal">Extension</code> folder contains an array extension that is required to make it possible for us to remove a particular object from the collection of users managed by the subject.</p><p>Lastly, we find the <code class="literal">main.swift</code> file used to simulate interactions.</p><p>So, let us begin our code by defining our observer in the <code class="literal">UserProtocol.Swift</code> file:</p><div><pre class="programlisting">protocol UserProtocol {
  func update(object:AnyObject)
}</pre></div><p>We simply<a class="indexterm" id="id380"/> define an update method with an object as an argument. The implementation of the <code class="literal">UserProtocol</code> will be like this:</p><div><pre class="programlisting">class User: UserProtocol{
  let name: String!
  
  init(name: String) {
    self.name = name
  }
  
  func update(object:AnyObject) {
    let info = object as! Info
    print("\(self.name) notified that \(info.message) have status \(info.status) on \(info.date.description)")
  }
}</pre></div><p>We pass a name in the constructor of the <code class="literal">User</code> object.</p><p>Then, in the <code class="literal">update</code> method, we prepare a message that will be displayed on the console. We downcast our object of type <code class="literal">AnyObject</code> to an <code class="literal">Info</code> object; this object is a helper. You will find its code in the <code class="literal">Helper</code> folder in the <code class="literal">Info.swift</code> file:</p><div><pre class="programlisting">class Info {
  var date = NSDate()
  var message:String!
  var status:InfoStatus!
  
  init(msg: String, status:InfoStatus) {
    self.message = msg
    self.status = status
  }
}</pre></div><p>The <code class="literal">Info</code> object contains three values: a date, message, and status.</p><p>The date is the current date and is defined when the <code class="literal">Info</code> object is initialized. The message is a string received in argument during initialization of the info object and the status is an enumeration passed in an argument during the initialization of the object and it can have the following value:</p><div><pre class="programlisting">enum InfoStatus {
  case Join
  case Leave
}</pre></div><p>Now, we only have to define our Subject protocol, and implement it in our concrete Subject. The Subject represents the object that need to be observed.</p><p>Our Subject definition is available in the <code class="literal">RoomProtocol.swift</code> file in the <code class="literal">Subject</code> folder:</p><div><pre class="programlisting">protocol RoomProtocol {
  func addObserver(user: User)
  func removeObserver(user: User)
  func notifyObserver(object: AnyObject)
}</pre></div><p>These three <a class="indexterm" id="id381"/>methods are the minimum necessary to any subject in an observer pattern.</p><p>The <code class="literal">addObserver</code> function lets you register an observer in the collection of observers managed by the subject.</p><p>The <code class="literal">removeObserver</code> method is used to remove an observer from the collection managed by the subject.</p><p>Last, the <code class="literal">notifyObserver</code> method is used to notify all our observers.</p><p>The implementation will be found in the <code class="literal">Room.swift</code> file, as shown:</p><div><pre class="programlisting">class Room: RoomProtocol {
  
  private var users = [User]()
  
  func addObserver(user: User) {
    users.append(user)
    let info = Info(msg: "\(user.name)", status: .Join)
    notifyObserver(info)
  }
  
  func removeObserver(user: User) {
    users.removeObject(user)
    let info = Info(msg: "\(user.name)", status: .Leave)
    notifyObserver(info)
  }
  
  func notifyObserver(object: AnyObject){
    for u in users {
      u.update(object)
    }
  }
}</pre></div><p>Here, you retrieve the three methods, in the two first one; you see a call to the <code class="literal">notifyObserver</code> method.</p><p>All the users <a class="indexterm" id="id382"/>will be notified each time the <code class="literal">addObserver</code> or <code class="literal">removeObserver</code> method is called because the <code class="literal">addObserver</code> method is called when a new user joins the room and we display the <code class="literal">Join</code> status in the <code class="literal">Info</code> message. With the same principle, we display the <code class="literal">Leave</code> status when the <code class="literal">removeObserver</code> method is called.</p><p>The <code class="literal">notifiyObserver</code> method receives an object of type <code class="literal">AnyObject</code> as an argument that will be propagated over the update method of each user object available in the collection managed by the <code class="literal">Room</code> method.</p><p>Time for us to now write our demo code, open the <code class="literal">main.swift</code> file, and write the code.</p><p>First, we initialize our <code class="literal">Room</code> method and four internet users:</p><div><pre class="programlisting">let room = Room()
let user1 = User(name:"Julien")
let user2 = User(name:"Alain")
let user3 = User(name:"Helmi")
let user4 = User(name:"Raphael")</pre></div><p>Then, we register each user to the room:</p><div><pre class="programlisting">room.addObserver(user1)
room.addObserver(user2)
room.addObserver(user3)
room.addObserver(user4)</pre></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Each time the <code class="literal">addObserver</code> method is called, all the currently registered users will be notified that the current registered user has joined.</p><p>So, when <code class="literal">room.addObserver(user1)</code> is called, only <code class="literal">user1</code> will be notified, but when <code class="literal">user2</code> is registered, <code class="literal">user1</code> and <code class="literal">user2</code> will be notified and so on.</p></div></div><p>Now, we remove <code class="literal">user2</code>, <code class="literal">user3</code>, and <code class="literal">user1</code> in this order:</p><div><pre class="programlisting">room.removeObserver(user2)
room.removeObserver(user3)
room.removeObserver(user1)</pre></div><p>To complete our sample, we register <code class="literal">user2</code> once more:</p><div><pre class="programlisting">room.addObserver(user2)</pre></div><p>Let us now build and run the project. You will get the following result:</p><div><img alt="Implementation" src="img/4852_07_09.jpg"/></div><p>Here, we see all<a class="indexterm" id="id383"/> the notifications. The first line corresponds to the first <code class="literal">addObserver</code> called. The next two lines correspond to the second <code class="literal">addObserver</code> called, and so on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Summary</h1></div></div></div><p>A comparison between the mediator pattern and the observer pattern shows some of the similarities and differences. Both patterns facilitate the communication between the objects and both decouple the link between the sender and the receiver. The main difference is that in the mediator pattern, there is a notion of the participants and they communicate with each other using the mediator as a central hub, whereas in the observer pattern, there is a clear distinction between the sender and the receiver, and the receiver merely listens to the changes in the sender.</p><p>The communication in the mediator pattern is easier to understand. Elements send messages to a mediator and the transmission of the information further to whoever is currently in the group is handled there, in one place.</p><p>In the observer pattern, observers wait to be invoked with information from more than one subject. The coupling is closer in the mediator than in the observer.</p><p>This concludes this chapter. In the last chapter, we will talk about the last three behavioral patterns the: visitor pattern, the interpreter pattern, and the memento pattern.</p></div></body></html>