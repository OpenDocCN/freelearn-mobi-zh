- en: Chapter 13. Getting Location and Using Geofencing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 获取位置和使用地理围栏
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to get the last location
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取最后位置
- en: Resolving problems reported with the GoogleApiClient OnConnectionFailedListener
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决GoogleApiClient OnConnectionFailedListener报告的问题
- en: How to receive location updates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何接收位置更新
- en: Create and monitor a Geofence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并监控地理围栏
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Location awareness offers many benefits to an app, so many in fact that even
    desktop apps now attempt to get the user's location. Location uses ranges from
    turn-by-turn directions, "find the nearest" applications, alerts based on location,
    and there are now even location-based games that get you out exploring with your
    device.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 位置感知为应用提供了许多好处，实际上如此之多，以至于现在甚至桌面应用也试图获取用户的位置。位置的使用范围从逐个方向指示，到“查找最近的”应用程序，基于位置的警报，现在甚至还有基于位置的游戏，让你用设备探索世界。
- en: The Google APIs offer many rich features for creating location-aware applications
    and mapping features. Our first recipe *How to get the last location* will look
    at obtaining the last known location as stored on the device. If your app is not
    location intensive, this may provide an ideal way to get the user's location without
    a large resource overhead. If you need constant updates, then turn to the *How
    to receive location updates* recipe. Though constant location updates requires
    more resources, users are likely to understand when you're giving them turn-by-turn
    directions. If you are requesting location updates for a proximity location, take
    a look at using the Geofence option instead, in the *Create and monitor a Geofence*
    recipe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Google API提供了许多丰富的功能，用于创建具有位置感知的应用程序和地图功能。我们的第一个配方*如何获取最后位置*将探讨如何获取存储在设备上的最后已知位置。如果你的应用不是位置密集型，这可能提供了一种在不大量消耗资源的情况下获取用户位置的理想方式。如果你需要持续更新，那么请转向*如何接收位置更新*配方。虽然持续的位置更新需要更多资源，但用户可能会在你提供逐个方向指示时理解这一点。如果你需要请求接近位置的位置更新，请查看*创建和监控地理围栏*配方中的Geofence选项。
- en: All the recipes in this chapter use the Google Libraries. If you have not already
    downloaded the SDK Packages, follow the instructions from Google.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有配方都使用Google库。如果你还没有下载SDK包，请按照Google的说明操作。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Add SDK Packages from [http://developer.android.com/sdk/installing/adding-packages.html](http://developer.android.com/sdk/installing/adding-packages.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://developer.android.com/sdk/installing/adding-packages.html](http://developer.android.com/sdk/installing/adding-packages.html)添加SDK包。
- en: 'Now that you have the location, there''s a good chance you''ll want to map
    it as well. This is another area where Google makes this very easy on Android
    using the Google Maps API. To get started with Google Maps, take a look at the
    **Google Maps Activity** option when creating a new project in Android Studio.
    Instead of selecting **Blank Activity**, as we normally do for these recipes,
    choose **Google Maps Activity**, as shown in this screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经获得了位置，很可能你还会想将其映射出来。这也是Google在Android上使用Google Maps API使这一过程变得非常简单的一个领域。要开始使用Google
    Maps，请在新项目创建时查看Android Studio中的**Google Maps Activity**选项。不要选择**空白活动**，正如我们通常在这些配方中所做的那样，选择**Google
    Maps Activity**，如以下截图所示：
- en: '![Introduction](img/B05057_13_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/B05057_13_1.jpg)'
- en: How to get the last location
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何获取最后位置
- en: 'We''ll start this chapter with a simple recipe that is commonly needed: how
    to get the last known location. This is an easy way to use APIs with very little
    overhead resource drain. (This means, your app won''t be responsible for killing
    the battery.)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，介绍一个常见的简单配方：如何获取最后已知的位置。这是一种使用API且资源消耗非常小的简单方法。（这意味着，你的应用不会负责耗尽电池。）
- en: This recipe also provides a good introduction to setting up the Google Location
    APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方还提供了设置Google位置API的良好介绍。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `GetLastLocation`. Use
    the default **Phone & Tablet** options, and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为：`GetLastLocation`。使用默认的**手机和平板**选项，当提示选择**活动类型**时，选择**空活动**。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll add the necessary permissions to the Android Manifest, then we''ll
    create a layout with a `Button` and a `TextView` element. Finally, we''ll create
    a `GoogleAPIClient` API to access the last location. Open the Android Manifest
    and follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加必要的权限到AndroidManifest.xml文件中，然后创建一个包含`Button`和`TextView`元素的布局。最后，我们将创建一个`GoogleAPIClient`
    API来访问最后的位置。打开AndroidManifest.xml文件，按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Under the **Gradle Scripts** section, open the **build.gradle (Module: app)**
    file, as shown in this screenshot:![How to do it...](img/B05057_13_2.jpg)'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 **Gradle Scripts** 部分，打开 **build.gradle (Module: app)** 文件，如图所示：![如何做...](img/B05057_13_2.jpg)'
- en: 'Add the following statement to the `dependencies` section:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `dependencies` 部分添加以下语句：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with the following
    XML:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将现有的 `TextView` 替换为以下XML：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并添加以下全局变量：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the class for `ConnectionCallbacks`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ConnectionCallbacks` 的类：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the class to handle the `OnConnectionFailedListener` callback:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理 `OnConnectionFailedListener` 回调的类：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following code to the existing `onCreate()` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 方法中：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the method to set up `GoogleAPIClient`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加设置 `GoogleAPIClient` 的方法：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following method for the button click:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮点击添加以下方法：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行应用在设备或模拟器上了。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before we can call the `getLastLocation()` method, we need to set up `GoogleApiClient`.
    We call the `GoogleApiClient.Builder` method in our `setupGoogleApiClient()` method,
    then connect to the library. When the library is ready, it calls our `ConnectionCallbacks.onConnected()`
    method. For demonstration purposes, this is where we enable the button. (We'll
    use this callback in later recipes to start additional features.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够调用 `getLastLocation()` 方法之前，我们需要设置 `GoogleApiClient`。我们在 `setupGoogleApiClient()`
    方法中调用 `GoogleApiClient.Builder` 方法，然后连接到库。当库准备好时，它调用我们的 `ConnectionCallbacks.onConnected()`
    方法。出于演示目的，这就是我们启用按钮的地方。（我们将在后面的菜谱中使用这个回调来启动其他功能。）
- en: We used a button to show we can call `getLastLocation()` on demand; it's not
    a one-time call. The system is responsible for updating the location and may return
    the same last location on repeated calls. (This can be seen in the timestamp—it's
    the location timestamp, not the timestamp when the button is pressed.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个按钮来展示我们可以按需调用 `getLastLocation()`；这不是一次性的调用。系统负责更新位置，并且可能在重复调用时返回相同的位置。（这可以在时间戳中看到——这是位置时间戳，而不是按钮按下时的时间戳。）
- en: This approach of calling the location on demand can be useful in situations
    where you only need the location when something happens in your app (such as geocoding
    an object). Since the system is responsible for the location updates, your app
    will not be responsible for a battery drain from location updates.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种按需调用位置的方法在您只需要在应用中发生某些事件时（例如对对象进行地理编码）需要位置的情况下很有用。由于系统负责位置更新，您的应用将不会因位置更新而耗电。
- en: 'The accuracy of the location object we receive is based on our permission setting.
    We used `ACCESS_COARSE_LOCATION`, but if we want higher accuracy, we can request
    `ACCESS_FINE_LOCATION` instead, with the following permission:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的位置对象的精度基于我们的权限设置。我们使用了 `ACCESS_COARSE_LOCATION`，但如果我们想要更高的精度，我们可以请求 `ACCESS_FINE_LOCATION`，如下所示权限：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, to keep the code focused on `GoogleApiClient`, we just wrap the `getLastLocation()`
    with `SecurityException`. In a production application, you should check and request
    the permission as shown in the previous chapter. (See *The new run-time permission
    model*.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使代码专注于 `GoogleApiClient`，我们只需将 `getLastLocation()` 包装在 `SecurityException`
    中。在生产应用中，您应该检查并请求权限，如前一章所示。（参见 *新的运行时权限模型*。）
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If a problem occurs when connecting to the `GoogleApiClient`, the `OnConnectionFailedListener`
    is called. In this example, we display a Toast. The next recipe, *Resolving problems
    reported with the GoogleApiClient OnConnectionFailedListener*, will show a more
    robust way to handle this situation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接到 `GoogleApiClient` 时出现问题，将调用 `OnConnectionFailedListener`。在这个例子中，我们显示一个Toast。下一个菜谱，*解决GoogleApiClient
    OnConnectionFailedListener报告的问题*，将展示处理这种情况的更健壮的方法。
- en: Testing the location can be a challenge since it's difficult to actually move
    the device when testing and debugging. Fortunately, we have the ability to simulate
    GPS data with the emulator. (It is possible to create mock locations on a physical
    device as well, but it's not as easy.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试位置可能是一个挑战，因为在测试和调试时很难实际移动设备。幸运的是，我们有能力使用模拟器模拟GPS数据。（在物理设备上创建模拟位置也是可能的，但并不容易。）
- en: Mock locations
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟位置
- en: 'There are three ways to simulate locations with the emulator:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟器模拟位置有三种方法：
- en: Android Studio
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio
- en: DDMS
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDMS
- en: The `Geo` command through Telnet
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Telnet的 `Geo` 命令
- en: 'To set a mock location in Android Studio, follow these steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中设置模拟位置，请按照以下步骤操作：
- en: Navigate to **Tools** | **Android** | **Android Device Monitor**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **工具** | **Android** | **Android 设备监控器**。
- en: Select the **Emulator Control** tab in the device window.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备窗口中选择 **模拟器控制** 选项卡。
- en: Enter GPS coordinates under **Location Controls**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **位置控制** 下输入 GPS 坐标。
- en: 'Here''s a screenshot showing the **Location** **Controls**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示 **位置** **控制** 的截图：
- en: '![Mock locations](img/B05057_13_3.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![模拟位置](img/B05057_13_3.jpg)'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Not that simulating the location works by sending GPS data. Therefore, for your
    app to receive the mock location, it will need to be receiving GPS data. Testing
    `lastLocation()` may not send the mock GPS data since it doesn't rely solely on
    the GPS for determining the device location. Try the mock location with the recipe
    *How to receive Location Updates* where we can request the priority. (We can't
    force the system to use any specific location sensor, we can only make a request.
    The system will choose the optimum solution to deliver the results.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非通过发送 GPS 数据来模拟位置有效。因此，为了让您的应用接收模拟位置，它需要接收 GPS 数据。测试 `lastLocation()` 可能不会发送模拟
    GPS 数据，因为它并不完全依赖于 GPS 来确定设备位置。尝试使用 *如何接收位置更新* 的配方来使用模拟位置，我们可以在其中请求优先级。（我们无法强制系统使用任何特定的位置传感器，我们只能提出请求。系统将选择最佳解决方案来提供结果。）
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *The new Android 6.0 run-time permission model* recipe in [Chapter 14](ch14.html
    "Chapter 14. Getting your app ready for the Play Store"), *Getting Your App Ready
    for the Play Store*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 14 章 [“为 Play 商店准备您的应用”](ch14.html "第 14 章。为 Play 商店准备您的应用") 的 *“新的 Android
    6.0 运行时权限模型”* 配方中，*“为 Play 商店准备您的应用”*
- en: 'Setting up Google Play Services: [https://developers.google.com/android/guides/setup](https://developers.google.com/android/guides/setup)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Google Play 服务：[https://developers.google.com/android/guides/setup](https://developers.google.com/android/guides/setup)
- en: 'The **FusedLocationProviderApi** interface: [https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FusedLocationProviderApi** 接口：[https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi)'
- en: Resolving problems reported with the GoogleApiClient OnConnectionFailedListener
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 GoogleApiClient OnConnectionFailedListener 报告的问题
- en: With the constantly changing nature of Google APIs, your users are likely to
    attempt to use your application, but not be able to because their files are out
    of date. In the previous example, we just show a Toast, but we can do better.
    We can use the `GoogleApiAvailability` library to display a dialog to help the
    user resolve the problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Google API 的不断变化，您的用户可能会尝试使用您的应用程序，但由于他们的文件过时，可能无法使用。在之前的示例中，我们只显示了一个 Toast，但我们可以做得更好。我们可以使用
    `GoogleApiAvailability` 库来显示一个对话框，以帮助用户解决问题。
- en: We'll continue with the previous recipe and add code to the `onConnectionFailed()`
    callback. We'll use the error result to display additional information to the
    user to resolve their problem.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前的配方，并向 `onConnectionFailed()` 回调中添加代码。我们将使用错误结果向用户显示额外的信息以解决问题。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe will continue from the previous recipe, *How to get the last location*.
    If you are loading the project from the downloaded source files, it is called
    `HandleGoogleAPIError`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将从之前的配方 *如何获取最后位置* 继续进行。如果您是从下载的源文件加载项目，它被称为 `HandleGoogleAPIError`。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since we are continuing from the previous recipe, we''ll only cover the steps
    necessary to update the previous code. Open `ActivityMain.java` and follow these
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在继续之前的配方，我们只需涵盖更新之前代码所需的步骤。打开 `ActivityMain.java` 并按照以下步骤操作：
- en: 'Add the following lines to the global class variables:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到全局类变量中：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following method to show the Google API error dialog:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加以显示 Google API 错误对话框：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following code to override `onActivityResult()`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加以覆盖 `onActivityResult()`：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `onConnectionFailed()`, replace the existing line of code calling Toast,
    using the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onConnectionFailed()` 中，替换现有的调用 Toast 的代码行，使用以下代码：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序在设备或模拟器上了。
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Instead of displaying the error message with a Toast as we did before, we now
    check `connectionResult` to see what we can do. The `GoogleAPIClient` uses the
    `connectionResult` to indicate possible courses of action. We can call the `hasResolution()`
    method, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前使用 Toast 显示错误消息不同，我们现在检查 `connectionResult` 来查看我们可以做什么。`GoogleAPIClient`
    使用 `connectionResult` 来指示可能的行动方案。我们可以调用 `hasResolution()` 方法，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the response is `true`, then it's something the user can resolve, such as
    enabling the location service. If the response is `false`, we get an instance
    of the `GoogleApiAvailability` and call the `getErrorDialog()` method. When finished,
    our `onActivityResult()` callback is called, where we reset `mResolvingError`
    and, if successful, attempt to reconnect.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应是 `true`，那么这是用户可以解决的问题，例如启用位置服务。如果响应是 `false`，我们得到一个 `GoogleApiAvailability`
    实例并调用 `getErrorDialog()` 方法。完成后，我们的 `onActivityResult()` 回调被调用，其中我们重置 `mResolvingError`，如果成功，尝试重新连接。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you do not have a device with an older Google API for testing, you can try
    testing on an emulator with an older Google API version.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有设备用于测试较旧的 Google API，你可以尝试在具有较旧 Google API 版本的模拟器上测试。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If your application is using fragments, you can get a dialog fragment instead,
    using this code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序正在使用片段，你可以使用此代码获取一个对话框片段：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Accessing Google APIs: [https://developers.google.com/android/guides/api-client](https://developers.google.com/android/guides/api-client)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Google API：[https://developers.google.com/android/guides/api-client](https://developers.google.com/android/guides/api-client)
- en: How to receive location updates
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何接收位置更新
- en: If your application needs frequent location updates, your application can request
    periodic updates. This recipe will demonstrate this using the `requestLocationUpdates()`
    method from `GoogleApiClient`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要频繁的位置更新，你的应用程序可以请求周期性更新。这个菜谱将使用 `GoogleApiClient` 的 `requestLocationUpdates()`
    方法来演示这一点。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `LocationUpdates`. Use
    the default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目并命名为：`LocationUpdates`。使用默认的 **Phone & Tablet** 选项，并在提示
    **Activity Type** 时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since we are receiving updates from the system, we won''t need a button for
    this recipe. Our layout will consist of just the `TextView` to see the location
    data. Open the Android Manifest and follow these steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从系统中接收更新，我们不需要为这个菜谱添加按钮。我们的布局将只包含 `TextView` 来查看位置数据。打开 AndroidManifest.xml
    并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open the file `build.gradle (Module: app)` and add the following statement
    to the `dependencies` section:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开文件 `build.gradle (Module: app)` 并在 `dependencies` 部分添加以下语句：'
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with the following
    XML:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将现有的 `TextView` 替换为以下 XML：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并添加以下全局变量：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the following `LocationListener` class:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `LocationListener` 类：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `ConnectionCallbacks` class to receive the location updates:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ConnectionCallbacks` 类来接收位置更新：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create an `OnConnectionFailedListener` class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `OnConnectionFailedListener` 类：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code to the existing `onCreate()` callback:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 回调中：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the `setupLocationRequest()` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `setupLocationRequest()` 方法：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is similar to the *How to get the last location* recipe, as we need
    to set up the `GoogleApiClient` as we did before. But, instead of calling the
    `lastLocation()` method on demand, we call the `requestLocationUpdates()` method
    to receive periodic location updates through the `LocationListener` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱与 *如何获取最后位置* 菜谱类似，因为我们需要像之前一样设置 `GoogleApiClient`。但是，我们不是在需要时调用 `lastLocation()`
    方法，而是调用 `requestLocationUpdates()` 方法通过 `LocationListener` 类接收周期性的位置更新。
- en: 'The `requestLocationUpdates()` method requires three parameters:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestLocationUpdates()` 方法需要三个参数：'
- en: '`GoogleApiClient`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoogleApiClient`'
- en: '`LocationRequest`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationRequest`'
- en: '`LocationListener`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationListener`'
- en: 'We create the `GoogleApiClient` as we did before. This is the code to create
    our `LocationRequest`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样创建 `GoogleApiClient`。这是创建我们的 `LocationRequest` 的代码：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When calling `setInterval()`, it's generally best to use the slowest delay that
    works for your purposes, as it requires less device resources. The same idea applies
    when calling `setPriority()`. The third parameter, the `LocationListener`, is
    where we define the callback method `onLocationChanged()`. Here we just display
    the location data along with the location timestamp.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `setInterval()` 时，通常最好使用最慢的延迟，这样对设备资源的需求更少。当调用 `setPriority()` 时，这个想法同样适用。第三个参数，即
    `LocationListener`，是我们定义回调方法 `onLocationChanged()` 的地方。在这里，我们只是显示位置数据以及位置时间戳。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Unlike the previous Android APIs, the `GoogleApiClient` API does not allow the
    selection of specific sensors for the location updates. As mentioned in the *Mock
    Locations* section of *How to get the last Location*, using `LocationRequest.PRIORITY_HIGH_ACCURACY`
    along with the `ACCESS_FINE_LOCATION` permission should use the GPS sensor. Refer
    to the *Mock Locations* section for instructions on simulating your location.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 Android API 不同，`GoogleApiClient` API 不允许选择特定的传感器进行位置更新。如 *如何获取最后位置* 部分的
    *模拟位置* 所述，使用 `LocationRequest.PRIORITY_HIGH_ACCURACY` 与 `ACCESS_FINE_LOCATION`
    权限应使用 GPS 传感器。请参阅 *模拟位置* 部分以获取模拟位置的说明。
- en: Stop receiving location updates
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 停止接收位置更新
- en: 'When your application no longer needs location updates, call the `removeLocationUpdates()`
    method, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序不再需要位置更新时，调用 `removeLocationUpdates()` 方法，如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Generally, you would want to disable updates when your application is no longer
    in the foreground, but this depends on your specific application requirements.
    If your application needs constant updates, it may be more desirable to create
    a background service to handle the callbacks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你的应用程序不再在前台时，你会想要禁用更新，但这取决于你具体的应用程序需求。如果你的应用程序需要持续更新，可能更希望创建一个后台服务来处理回调。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Developer Docs: onLocationChanged** at [https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html](https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：onLocationChanged** 在 [https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html](https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html)'
- en: Create and monitor a Geofence
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和监控地理围栏
- en: 'If your application needs to know when the user enters a certain location,
    there''s an alternative to having to continuously check the user location: Geofencing.
    A Geofence is a location (latitude and longitude) along with a radius. You can
    create a Geofence and let the system notify you when the user enters the location
    proximity you specified. (Android currently allows up to 100 Geofences per user.)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要知道用户何时进入某个特定位置，有一个替代方案，即不需要持续检查用户的位置：地理围栏。地理围栏是一个位置（纬度和经度）以及一个半径。你可以创建一个地理围栏，并让系统在用户进入你指定的位置附近时通知你。（Android
    目前允许每个用户最多 100 个地理围栏。）
- en: 'Geofence properties include:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 地理围栏属性包括：
- en: '**Location**: The longitude and latitude'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：经度和纬度'
- en: '**Radius**: The size of the circle (in meters)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**：圆的大小（以米为单位）'
- en: '**Loitering delay** : How long the user may remain within the radius before
    sending notifications'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逗留延迟**：用户在发送通知之前可以在半径内停留多长时间'
- en: '**Expiration**: How long until the Geofence automatically expires'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期时间**：地理围栏自动过期前的时间'
- en: '**Transition** **type**: These are listed as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡** **类型**：以下列出了这些类型：'
- en: '`GEOFENCE_TRANSITION_ENTER`'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GEOFENCE_TRANSITION_ENTER`'
- en: '`GEOFENCE_TRANSITION_EXIT`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GEOFENCE_TRANSITION_EXIT`'
- en: '`INITIAL_TRIGGER_DWELL`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INITIAL_TRIGGER_DWELL`'
- en: This recipe will show you how to create a Geofence object and use it to create
    an instance of `GeofencingRequest`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示如何创建地理围栏对象，并使用它来创建 `GeofencingRequest` 的实例。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `Geofence`. Use the default
    **Phone & Tablet** options and select **Empty Activity** when prompted for **Activity
    Type**.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为：`Geofence`。使用默认的 **Phone & Tablet** 选项，并在提示 **Activity
    Type** 时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We won''t need a layout for this recipe as we''ll use Toasts and Notifications
    for the user interaction. We will need to create an additional Java class for
    `IntentService`, which handles the Geofence alerts. Open the Android Manifest
    and follow these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为这个菜谱创建布局，因为我们将会使用 Toasts 和通知来进行用户交互。我们需要创建一个额外的 Java 类来处理 `IntentService`，它负责处理地理围栏警报。打开
    Android Manifest 并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE27]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Open the file `build.gradle (Module: app)` and add the following statement
    to the `dependencies` section:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开文件 `build.gradle (Module: app)` 并在 `dependencies` 部分添加以下语句：'
- en: '[PRE28]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new Java class called `GeofenceIntentService` and extend the `IntentService`
    class. The declaration will look as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Java 类 `GeofenceIntentService` 并扩展 `IntentService` 类。声明如下：
- en: '[PRE29]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following constructor:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下构造函数：
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add `onHandleIntent()` to receive the Geofence alert:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `onHandleIntent()` 以接收地理围栏警报：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the `sendNotification()` method to display the message to the user:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `sendNotification()` 方法以向用户显示消息：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open the Android manifest and add the following within the `<application>`
    element, at the same level as the `<activity>` element:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Android 清单并在 `<application>` 元素内添加以下内容，与 `<activity>` 元素处于同一级别：
- en: '[PRE33]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并添加以下全局变量：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the following `ResultCallback` class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `ResultCallback` 类：
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a `ConnectionCallbacks` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ConnectionCallbacks` 类：
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create an `OnConnectionFailedListener` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `OnConnectionFailedListener` 类：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following code to the existing `onCreate()` callback:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 回调中：
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the method to setup the `GoogleAPIClient`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加设置 `GoogleAPIClient` 的方法：
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the `setupGoogleApiClient()` method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `setupGoogleApiClient()` 方法：
- en: '[PRE40]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a pending intent with the following method:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法创建一个挂起意图：
- en: '[PRE41]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the `geofence` object and add it to a list for the request:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `geofence` 对象并将其添加到请求的列表中：
- en: '[PRE42]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the `createGeofencingRequest()` method as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式创建 `createGeofencingRequest()` 方法：
- en: '[PRE43]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序在设备或模拟器上。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we add the `ACCESS_FINE_LOCATION` permission as this is required for
    Geofencing. We set up the `GoogleApiClient` as we've done in previous recipes
    and wait until `onConnected()` is called to set up the `GeofencingApi`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加 `ACCESS_FINE_LOCATION` 权限，因为这是地理围栏所必需的。我们设置 `GoogleApiClient`，就像我们在之前的菜谱中所做的那样，并等待
    `onConnected()` 被调用以设置 `GeofencingApi`。
- en: 'Before we can call the `GeofencingApi.addGeofences()` method, we have to prepare
    three objects:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以调用 `GeofencingApi.addGeofences()` 方法之前，我们必须准备三个对象：
- en: '`GoogleApiClient`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoogleApiClient`'
- en: Geofence Request
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理围栏请求
- en: Pending Intent
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬挂意图
- en: We already created the `GoogleApiClient`, which we saved in the `mGoogleApiClient`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `GoogleApiClient`，并将其保存在 `mGoogleApiClient` 中。
- en: 'To create the Geofence Request, we use the `GeofencingRequest.Builder`. The
    builder requires the list of Geofence objects, which are created in the `createGeofenceList()`
    method. (Even though we are only creating a single Geofence object, the builder
    requires a list, so we just add our single Geofence to an `ArrayList`.) Here is
    where we set the Geofence properties:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地理围栏请求，我们使用 `GeofencingRequest.Builder`。构建器需要地理围栏对象的列表，这些对象是在 `createGeofenceList()`
    方法中创建的。（尽管我们只创建了一个地理围栏对象，但构建器需要一个列表，所以我们只需将我们的单个地理围栏添加到 `ArrayList` 中。）这就是我们设置地理围栏属性的地方：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Only the Loitering delay is optional, but we need it since we are using the
    `DWELL` transition. When calling `setTransitionTypes()`, we can combine multiple
    transition types using the `OR` operator, shown with the pipe. Here''s an example
    using `ENTER` and `EXIT` instead:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 只有逗留延迟是可选的，但由于我们正在使用 `DWELL` 转换，我们需要它。当调用 `setTransitionTypes()` 时，我们可以使用 `OR`
    运算符组合多个转换类型，如下所示，这里使用 `ENTER` 和 `EXIT` 作为示例：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For this example, we used the same default latitude and longitude as the emulator.
    Change these values as needed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们使用了与模拟器相同的默认纬度和经度。根据需要更改这些值。
- en: Our call to `Geofence.Builder()` creates the Geofence object. With the Geofence
    list ready, we call the `GeofencingRequest.Builder` and set our initial trigger
    to `INITIAL_TRIGGER_DWELL`. (If you change the preceding transition types, you
    may want to change the initial trigger as well.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `Geofence.Builder()` 的调用创建了地理围栏对象。有了准备好的地理围栏列表，我们调用 `GeofencingRequest.Builder`
    并将我们的初始触发设置为 `INITIAL_TRIGGER_DWELL`。（如果您更改了前面的转换类型，您可能还想更改初始触发。）
- en: The last object we need is a Pending Intent, which is how the system will notify
    our app when the Geofence criteria are met. We created the `GeofenceIntentService`
    to handle the Geofence intent by sending a notification to the user. (For more
    information on notifications, refer to the *Lights, Action, and Sound Redux using
    Notifications* recipe in [Chapter 7](ch07.html "Chapter 7. Alerts and Notifications"),
    *Alerts and Notifications*.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个对象是Pending Intent，这是系统在地理围栏条件满足时通知我们的应用的方式。我们创建了`GeofenceIntentService`来处理地理围栏意图，通过向用户发送通知来处理。（有关通知的更多信息，请参阅第7章中的*使用通知的“灯光、动作和声音重置”配方*，*警报和通知*。）
- en: With all three objects created, we just call `LocationServices.GeofencingApi.addGeofences()`
    and wait for the notification to arrive.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了所有三个对象后，我们只需调用`LocationServices.GeofencingApi.addGeofences()`并等待通知到达。
- en: There's more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To stop receiving Geofence notifications, you can call the `removeGeofences()`
    method with either the `RequestID` parameter or `PendingIntent`. The following
    example uses the same `PendingIntent` method we used for the notification:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止接收地理围栏通知，你可以使用`removeGeofences()`方法，并传入`RequestID`参数或`PendingIntent`。以下示例使用了与通知相同的`PendingIntent`方法：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The `Geofence.Builder` class at: [https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html](https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Geofence.Builder`类位于：[https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html](https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html)'
- en: 'The `GeofencingRequest.Builder` class at: [https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder](https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeofencingRequest.Builder`类位于：[https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder](https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder)'
