- en: Enabling Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we learnt how to boot the x86vbox device using PXE and
    NFS. We can boot the device to an embedded Linux environment, which is the first
    stage of the Android-x86 boot. In this stage, we can use a debug console to verify
    the status of the system so that we can make sure everything is right before we
    start the real Android system. In this chapter, we will talk about the first issue
    we meet during Android system boot up. This is about how to enable the Android
    graphics system for the x86vbox device. We will cover the following topics in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Android graphics architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into graphics HAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the Android emulator graphics HAL for comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graphics system probably is the most complicated software stack in the Android
    system architecture.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see, the content in this chapter is much longer than the rest. Reading
    and understanding the content in this chapter may be harder. What I suggest is
    that you can open a source code editor and load the relevant source code while
    you read this chapter. This will help you a lot to understand the source code
    and the points that I want to address in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Android graphics architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The graphics system in Android is similar to the architecture that we discussed
    in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml), *Discovering Kernel,
    HAL, and Virtual Hardware*. There we used goldfish lights HAL as an example to
    do a detailed analysis from the application level to the HAL and device driver
    layer. This analysis helps us to understand the Android architecture vertically.
  prefs: []
  type: TYPE_NORMAL
- en: However, the graphics system could be the most complicated system in the Android
    architecture. It would require another book to give a detailed introduction to
    the Android graphics system. The focus of this book is on how we can port Android
    systems to a new hardware platform. To focus on this goal, we will address the
    graphics HAL in this chapter instead of discussing the entire graphics system.
    The graphics system will work if we can choose the right graphics HAL and configure
    it right.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Google documents about the implementation of graphics, Android
    graphics support requires the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: EGL driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 1.x driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 2.0 driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 3.x driver (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulkan (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gralloc HAL implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware Composer HAL implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding list, OpenGL ES implementation is the most complicated component
    in the graphics system. We will discuss how it is chosen and integrated in an
    Android emulator and Android-x86\. We won't go into the details of how to analyze
    the OpenGL ES implementation, but we will have an overview about the underlying
    OpenGL ES libraries. OpenGL ES 1.x and 2.0 must be supported in an Android system.
    OpenGL ES 3.x is an optional component at the moment. EGL driver is usually implemented
    as part of the OpenGL ES implementation and we will see this when we discuss the
    Android emulator and Android-x86 (x86vbox) graphics system.
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan is a new generation of GPU API from Khronos Group. Vulkan is new and
    optional and was only introduced in Android 7\. Covering Vulkan is beyond the
    scope of this book, so we won't discuss it. Gralloc HAL is the one that handles
    the graphics hardware and it is our focus for a deep analysis. In most of the
    porting work of the graphics system, Gralloc HAL is the key to enabling graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware composer is part of the graphics HAL. However, it is not a component
    that we must have for Android emulator or Android-x86\. The **Hardware Composer**
    (**HWC**) HAL is used to composite surfaces to the screen. The HWC abstracts objects
    such as overlays and helps offload some work that would normally be done with
    OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Android graphics architecture
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding Android graphics architecture diagram, we can
    also divide related components into different layers in the Android architecture
    as we did in previous chapters. This architecture diagram is a simplified view
    of a graphics system. **SurfaceFlinger** is the system service to the application
    layer for graphics-related system support. **SurfaceFlinger** will connect to
    the **OpenGL ES** library and **HAL** layer components to perform the actual work.
    In the **HAL**, we have **HWC**, **gralloc**, and a vender-specific GPU library
    that will talk to the drivers in the kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into graphics HAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we have an overview of graphics system architecture, we will analyze
    the Gralloc module, which is the graphics HAL. In the AOSP source code, the skeleton
    of Gralloc HAL implementation can be found at the following folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$AOSP/hardware/libhardware/modules/gralloc`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a general implementation that provides a reference for developers to
    create their own Gralloc module. Gralloc will access framebuffer and GPU to provide
    services to the upper layer. In this section, we will analyze this general implementation
    first. After the analysis of this general Gralloc HAL module, we will introduce
    the Gralloc HAL of the Android emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the Gralloc module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When application developers draw images to the screen, there are two ways to
    do it. They can use Canvas or OpenGL. Beginning in Android 4.0, both methods use
    hardware acceleration by default. To use hardware acceleration, we need to use
    Open GL libraries and eventually the Gralloc module will be loaded as part of
    the graphics system initialization. As we saw in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml),
    *Discovering Kernel, HAL, and Virtual Hardware*, each HAL module has a reference
    ID that can be used by the `hw_get_module` function to load it to memory. The
    `hw_get_module` function is defined in the `$AOSP/hardware/libhardware/hardware.c`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In `hw_get_module`, it actually calls another function, `hw_get_module_by_class`,
    to do the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, it tries to find the Gralloc module shared library
    using the following names in `/system/lib/hw` or `/vendor/lib/hw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If any of the preceding files exist, they will call the `load` function to
    load the shared library. If none of them exist, a default shared library, `gralloc.default.so`,
    will be used. The hardware module ID for Gralloc is defined in the `gralloc.h`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `load` function will call `dlopen` to load the library and will call `dlsym`
    to get the address of the data structure `hw_module_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After we get the address of the data structure `hw_module_t`, we can call the
    `open` method defined in Gralloc HAL to initialize the framebuffer and GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml),
    *Discovering Kernel, HAL, and Virtual Hardware*, the hardware vendor needs to
    implement three HAL data structures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the HAL shared library is loaded, the data structure `hw_module_t` is
    used to discover the HAL module, as we can see in the preceding code snippet.
    Each HAL module should implement an `open` method in the data structure `hw_module_methods_t`,
    which is responsible for the initialization of hardware. We can see that the `gralloc_device_open`
    function is defined as the `open` method in the following code snippet for the
    Gralloc module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the data structure `hw_module_methods_t`, the `open` method is assigned as
    a static function, `gralloc_device_open`. The `HAL_MODULE_INFO_SYM` symbol is
    defined as `struct private_module_t`.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that we actually cast the `HAL_MODULE_INFO_SYM_AS_STR` symbol
    to `hw_module_t`, while we loaded the Gralloc module. In this default Gralloc
    module, the data structure `hw_module_t` is implemented using another two inherited
    data structures, `private_module_t` and `gralloc_module_t`. Let's look at the
    relationship between `private_module_t`, `gralloc_module_t`, and `hw_module_t`.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel a little lost with the analysis, I suggest you look at the source
    code while you read this section. If you don't have the AOSP source code available,
    there is a very good cross-reference site for AOSP code at [http://xref.opersys.com/](http://xref.opersys.com/).
  prefs: []
  type: TYPE_NORMAL
- en: You can visit this site and search for the data structures that we are discussing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data structure `private_module_t` is defined in the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$AOSP/hardware/libhardware/modules/gralloc/gralloc_priv.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the first base field, or member variable in C++ terms, is the
    data structure `gralloc_module_t`. The second member variable framebuffer is a
    pointer of data type `private_handle_t`. It is a handle pointing to the framebuffer
    and we will explore it later.
  prefs: []
  type: TYPE_NORMAL
- en: The member variable `flags` is used to indicate whether the system can support
    double buffering. If it is supported the `PAGE_FLIP` bit is set to 1; otherwise,
    it is set to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The `numBuffers` member variable indicates the number of buffers in the framebuffer.
    It is related to the visible resolution and virtual resolution. For example, if
    the visible resolution of the display is 800 x 600, the virtual resolution can
    be 1600 x 600\. In this case, the framebuffer can have two buffers for the display
    and the system can support double buffers for the display.
  prefs: []
  type: TYPE_NORMAL
- en: The `bufferMask` member variable is used to mark the use of buffers in a framebuffer
    device. If we assume there are two buffers in the framebuffer, the `bufferMask`
    variable can have four values in binary 00, 01, 10, and 11\. The value 00 indicates
    both buffers are empty. The value 01 means the first buffer is in use and the
    second buffer is empty. The value 10 means the first buffer is empty and the second
    buffer is in use. The value 11 means both buffers are busy.
  prefs: []
  type: TYPE_NORMAL
- en: The `lock` member variable is used to protect access to `private_module_t`.
  prefs: []
  type: TYPE_NORMAL
- en: The `currentBuffer` member variable is used to track the current buffer for
    rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The `info` and `finfo` member variables are data types `fb_var_screeninfo` and
    `fb_fix_screeninfo`. They are used to store the properties of the display device.
    The properties in `fb_var_screeninfo` are programmable while the properties in
    `fb_fix_screeninfo` are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: The `xdpi` and `ydpi` member variables are used to describe the pixel density
    in terms of horizontal and vertical.
  prefs: []
  type: TYPE_NORMAL
- en: The `fps` member variable is the refresh rate of the display in frames per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gralloc_module_t` data structure is defined in the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$AOSP/hardware/libhardware/include/hardware/gralloc.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we expect, the first field in `gralloc_module_t` is `hw_module_t` from the
    preceding code snippet. The relationship among these three data structures is
    similar to the following UML class diagram in object-oriented notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Relationship between Gralloc data structures
  prefs: []
  type: TYPE_NORMAL
- en: This is the way to simulate inheritance relationships in the C language. In
    this way, we can cast data types of `private_module_t` to `gralloc_module_t` or
    `hw_module_t`.
  prefs: []
  type: TYPE_NORMAL
- en: A set of member functions is defined in `gralloc_module_t`. We will look at
    four of them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `registerBuffer` and `unregisterBuffer` member functions are used to register
    or unregister a buffer. To register a buffer, we map a buffer to the process space
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `lock` and `unlock` member functions are used to lock or unlock a buffer.
    The buffer is described using `buffer_handle_t` as a parameter of the function.
    We can use the `l`, `t`, `w`, and `h` parameters to provide the position and the
    size of the buffer. After the buffer is locked, we can get the address of the
    buffer in the `vaddr` output parameter. We should unlock the buffer after use.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing GPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have talked about HAL data structures `hw_module_t` and `hw_module_methods_t`
    for the Gralloc module. The last one, `hw_device_t`, is initialized in the `open`
    method of the Gralloc HAL module. Now we can look at the `open` method of the
    Gralloc module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see here, the `gralloc_device_open` function can be used to initialize
    two kinds of device, `GRALLOC_HARDWARE_GPU0` and `GRALLOC_HARDWARE_FB0`, according
    to the `name` input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the initialization of the GPU0 device first. The output parameter
    of the `open` method is the address of the `hw_device_t` data structure. After
    the calling applications get an instance of `hw_device_t`, they can use the hardware
    device to do their work. In the `open` method of Gralloc HAL, it allocates the
    memory for the `gralloc_context_t` data structure first. After that, it populates
    its `device` member variable and assigns the output parameter to the address of
    the `dev->device.common` member variable. As we expect, the output is the address
    of an `hw_device_t` instance. Let''s look at the relationship between `gralloc_context_t`,
    `alloc_device_t`, and `hw_device_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding diagram, the first field or member variable
    of `gralloc_context_t` is `device`, which is data type `alloc_device_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the definition of the `alloc_device_t` data structure. It
    is defined in the `gralloc.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the data type of the first field of `alloc_device_t` is `hw_device_t`.
    This is the technique for simulating inheritance relationships in the C language
    that we mentioned when we discussed the relationship between `private_module_t`,
    `gralloc_module_t` and `hw_module_t`.
  prefs: []
  type: TYPE_NORMAL
- en: The `alloc` and `free` methods of the Gralloc device are implemented in the
    `gralloc_alloc` and `gralloc_free` functions in the `gralloc.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we call the `open` method of the Gralloc module with the `name` value as
    `GRALLOC_HARDWARE_FB0`, it will initialize the framebuffer device. The `fb_device_open`
    function is called to open the framebuffer device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fb_device_open` function is implemented in the `framebuffer.cpp` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `fb_device_open` function, it allocates memory for the `fb_context_t`
    data structure. After that, it populates the fields in the data structure. As
    we discussed in the GPU0 initialization, we expect the output as an instance of
    the `hw_device_t` data structure so that the caller can use the framebuffer device
    through the `hw_device_t` HAL data structure. We have a similar inheritance relationship
    between these three data structures, `fb_context_t`, `framebuffer_device_t`, and
    `hw_device_t`, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Relationship between fb_context_t, framebuffer_device_t, and hw_device_t
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fb_context_t` data structure includes `framebuffer_device_t` as the first
    field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In turn, the `framebuffer_device_t` data structure includes `hw_device_t` as
    the first field, so `fb_context_t` can be used as either `framebuffer_device_t`
    or `hw_device_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the rest of the fields in `framebuffer_device_t`, they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flags`: Used to describe some attributes of the framebuffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` and `height`: Dimensions of the framebuffer in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stride`: Framebuffer stride in pixels or the number of pixels per line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: Framebuffer pixel format. It can be `HAL_PIXEL_FORMAT_RGBX_8888`,
    `HAL_PIXEL_FORMAT_565`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xdpi` and `ydpi`: Resolution of the framebuffer''s display panel in pixels
    per inch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fps`: Display panel refresh rate in frames per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minSwapInterval`: Minimum swap interval supported by this framebuffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxSwapInterval`: Maximum swap interval supported by this framebuffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numFramebuffers`: Number of framebuffers supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before it can fill in all the fields of `framebuffer_device_t`, the `fb_device_open`
    function calls a `mapFrameBuffer` function to get the information about the framebuffer.
    Besides getting framebuffer information, this `mapFrameBuffer` function also maps
    the framebuffer to the current process space so that the current process can use
    it. In Android, the Gralloc module is owned and managed by SurfaceFlinger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `mapFrameBuffer` function now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, `mapFrameBuffer` acquires a mutex first and calls another function,
    `mapFrameBufferLocked`, to do the rest of the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `mapFrameBufferLocked` function, it checks whether there is a `/dev/graphics/fb0`
    or `/dev/fb0` device node. If the device node exists, it tries to open it and
    stores the file descriptor in the `fd` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it will use `ioctl` commands to get framebuffer information. There are
    two framebuffer data structures, `fb_fix_screeninfo` and `fb_var_screeninfo`,
    which can be used to communicate with framebuffer. The `fb_fix_screeninfo` data
    structure stores fixed framebuffer information and the `fb_var_screeninfo` data
    structure stores programmable framebuffer information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After it gets the framebuffer information, it tries to set the virtual resolution
    of the framebuffer device. The `xres` and `yres` fields are used to store the
    visible resolution of the framebuffer device while the `xres_virtual` and `yres_virtual`
    fields are used to store the virtual resolution of the framebuffer device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the virtual resolution, it tries to increase the virtual vertical resolution
    as the `info.yres * NUM_BUFFERS` value. `NUM_BUFFERS` is a macro for the number
    of buffers that can be used in the framebuffer devices. In our case, the `NUM_BUFFERS`
    value is `2`, so we can use the double buffer technology for the display. It sets
    the virtual resolution using the `ioctl` command `FBIOPUT_VSCREENINFO`. If it
    can set the virtual resolution successfully, it will set the `PAGE_FLIP` bit in
    `flags`; otherwise, it will clear the `PAGE_FLIP` bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After it sets the virtual resolution, it will calculate the refresh rate. To
    understand the calculation of the refresh rate, you can refer to the document
    in the Linux kernel source code at `Documentation/fb/framebuffer.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, it will calculate the pixel density for both horizontal and vertical.
    It also converts the refresh rate to frames per second and stores this to `fps`.
    After it has all the information, it will store them to the fields of the data
    structure, `private_module_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it will map the framebuffer to the process address space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The size of the framebuffer by virtual resolution is `finfo.line_length * info.yres_virtual`.
    The value of `finfo.line_length` is equal to the number of bytes per line and
    the value of `info.yres_virtual` is the number of lines per frame. In order to
    do memory mapping, we have to round the size to the page boundary using the `roundUpToPageSize`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The actual number of buffers that can be used in the framebuffer device is `info.yres_virtual`
    divided by `info.yres` and it is stored in the `numBuffers` field. The `bufferMask`
    field is set to 0 and this means all buffers are empty and can be used.
  prefs: []
  type: TYPE_NORMAL
- en: It calls the `mmap` system call to map the framebuffer to the current process
    address space. The starting address of the framebuffer in the current process
    address space is `vaddr`, which is returned from the `mmap` system call. It is
    stored to the `framebuffer->base` field, so that the Gralloc module can use it
    to allocate buffers for the applications later.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have completed the analysis of the `mapFrameBuffer` function.
    This function is the one that is responsible for most of the work in initializing
    framebuffer devices in the Gralloc HAL module.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating and releasing the graphic buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this chapter, we have discussed loading the Gralloc module and the
    `open` method provided by the Gralloc module. Let''s now review the points when
    the upper layer loads, initializes, and uses the Gralloc module:'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Gralloc module is used mostly by `SurfaceFlinger`. `SurfaceFlinger`
    uses Gralloc; when it creates an instance of `FramebufferNativeWindow`, in the
    `FramebufferNativeWindow` constructor, it will call `hw_get_module` to get an
    instance of `hw_module_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `hw_module_t` data structure, it has a field called `methods` with data
    type `hw_module_methods_t`. In `hw_module_methods_t`, it has an `open` method
    that returns a `hw_device_t` data structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `hw_device_t`, `SurfaceFlinger` can use the `alloc` and `free` methods
    inside `hw_device_t` to allocate or release graphic buffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at how the Gralloc module allocates and releases graphic buffers
    in this section. We will look at the source code of `gralloc_alloc` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, the `alloc` method is implemented
    in the `gralloc_alloc` function. `gralloc_alloc` has the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev`: It has an `alloc_device` data type that inherits from `hw_device_t`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` : It is the width of the graphic buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h`: It is the height of graphic buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format` : It defines the color format of pixels. For example, the format can
    be `HAL_PIXEL_FORMAT_RGBA_8888`, `HAL_PIXEL_FORMAT_RGB_888`, `HAL_PIXEL_FORMAT_RGB_565`,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usage` : It defines the use of graphic buffer. For example, if the `GRALLOC_USAGE_HW_FB`
    bit is set, the buffer will be allocated from the framebuffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pHandle` : It has a `buffer_handle_t` data type. We will discuss the details
    of this data structure. It is used to store the allocated buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pStride` : The number of pixels per line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `gralloc_alloc`, it checks the format of pixels to decide the size of pixels.
    It can be 32 bits, 24 bits, 16 bits, and so on. The size of the pixel is stored
    in the `bpp` variable. The `bpr` variable is the number of bytes per line and
    it is calculated using `w` multiplied by `bpp`. The `bpr` variable needs to be
    aligned to four bytes boundary for memory allocation. The size of the buffer can
    be calculated using `h` multiplied by `bpr`.
  prefs: []
  type: TYPE_NORMAL
- en: After the size of the buffer is calculated, it will call the `gralloc_alloc_framebuffer`
    or `gralloc_alloc_buffer` functions according to the `GRALLOC_USAGE_HW_FB` bit.
  prefs: []
  type: TYPE_NORMAL
- en: The graphic buffer that is allocated by `gralloc_alloc` is stored in the `buffer_handle_t`
    data type. `buffer_handle_t` is defined as a pointer of `native_handle`. `native_handle`
    is used as a parent class of `private_handle_t`. `private_handle_t` is the actual
    data type used to manage the graphic buffer and it is a hardware-dependent data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Relationship between private_handle_t and native_handle
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows the relationship between `private_handle_t` and
    `native_handle`. The following is the definition of `native_handle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `version` field is set to the size of `native_handle`. The `numFds` and
    `numInts` fields describe the number of file descriptors and integers in the `data`
    array. The `data` array is used to store hardware-specific information, which
    we can see in the following definition of `private_handle_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `fd` member variable is a file descriptor that is used to describe a framebuffer
    or shared memory region. The `magic` member variable is stored as a magic number
    defined in the `sMagic` static variable. The `flags` member variable is used to
    describe the type of graphic buffer. For example, if it is equal to `PRIV_FLAGS_FRAMEBUFFER`,
    this buffer is allocated from framebuffer. The `size` member variable is the size
    of the graphic buffer. The `offset` member variable is the offset from the starting
    address in memory. The `base` member variable is the address allocated for the
    buffer. The `pid` member variable is the process ID of the creator of the graphic
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor fills in the member variables of `native_handle`. The `validate`
    member function is used to validate whether the graphic buffer is an instance
    of `private_handle_t` or not.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the Gralloc module that we are analyzing is the
    default implementation in AOSP, and is built as `galloc.default.so`. In this implementation,
    GPU is not used and the buffer will be allocated either in the framebuffer or
    shared memory. Even though this is not the ideal case for performance, it has
    the least hardware dependency, which is good as a reference to understand a more
    complicated Gralloc module implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating from framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see from the `gralloc_alloc` function, when the `usage` bit is set
    to `GRALLOC_USAGE_HW_FB`, the `gralloc_alloc_framebuffer` function is called.
    The `gralloc_alloc_framebuffer` function will allocate the buffer from the framebuffer
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`gralloc_alloc_framebuffer` acquires a mutex first and calls to another function,
    `gralloc_alloc_framebuffer_locked`. In the locked version, it calls to a `mapFrameBufferLocked`
    function, which we analyzed before to get the framebuffer information and map
    it to the current process address space.'
  prefs: []
  type: TYPE_NORMAL
- en: It will check whether the framebuffer device can support double buffering or
    not. If it can support double buffering, it creates a new `private_handle_t` instance
    and fills in the information in this instance and returns to the caller. If the
    buffer is allocated from the framebuffer device, it will mark the `flags` member
    variable of `private_handle_t` to `PRIV_FLAGS_FRAMEBUFFER`. It will also set the
    framebuffer `usage` status in `bufferMask`, which is a member variable of `private_module_t`.
  prefs: []
  type: TYPE_NORMAL
- en: If it cannot support double buffering, it calls to `gralloc_alloc_buffer` to
    allocate a buffer from the system memory and returns to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating from system memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `usage` bit is not set to `GRALLOC_USAGE_HW_FB` or the system cannot
    support double buffering, we have to allocate the buffer from system memory using
    `gralloc_alloc_buffer`. Let''s look at the implementation of `gralloc_alloc_buffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In `gralloc_alloc_buffer`, it rounds up the buffer size to the page size first.
    Then it creates an anonymous shared memory region using `ashmem_create_region`.
    It creates a new `private_handle_t` instance to represent this shared memory region.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shared memory region is described as a file descriptor. To use it, we
    need to map it to the current process address space. This is done with the `mapBuffer`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`mapBuffer` calls to another function, `gralloc_map`, to do the memory mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In `grallo_map`, if the file descriptor in `private_handle_t` is a framebuffer
    device, we don't have to do the mapping again, since the framebuffer is initialized
    and mapped to the `SurfaceFlinger` address space in `fb_device_open`, as we analyzed
    before.
  prefs: []
  type: TYPE_NORMAL
- en: If it is a shared memory region, it needs to be mapped to the current process
    address space using the `mmap` system function.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing graphic buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, the Gralloc module can be used to allocate and release
    graphic buffers. Now that we have learnt how to allocate buffers from framebuffer
    devices or system memory, let's have a look at how to release graphic buffers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To release graphic buffers, the `gralloc_free` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To release a graphic buffer, the buffer is described using `buffer_handle_t`.
    `gralloc_free` will validate the buffer first using the `private_handle_t::validate`
    static function.
  prefs: []
  type: TYPE_NORMAL
- en: The `handle` parameter can be cast to a pointer of `private_handle_t` as we
    recall from the discussion on `private_handle_t` and `native_handle` previously.
    If the `flags` field of `hnd` is `PRIV_FLAGS_FRAMEBUFFER`, it means the buffer
    is allocated from the framebuffer device. It will update `bufferMask` to release
    it from the framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the buffer is allocated from system memory, it will call the `terminateBuffer`
    function to release the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `terminateBuffer` function calls to another function, `gralloc_unmap`,
    to release the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In `gralloc_unmap`, again, it checks that this buffer is not from the framebuffer
    and it calls the `munmap` system function to release it.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed previously in this chapter, the Gralloc module can support
    two kinds of device: Gralloc devices and framebuffer devices. In the `open` method
    of the Gralloc device, it creates a device named `GRALLOC_HARDWARE_GPU0` and supports
    two methods, `alloc` and `free`, as we can see in the following snippet. We have
    discussed both methods in detail earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `open` method of the framebuffer device, it creates a device named `GRALLOC_HARDWARE_FB0`
    and supports four methods `close`, `setSwapInterval`, `post`, and `setUpdateRect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to the AOSP source code or the following URL for information
    about the implementation of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp](http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `post` method, which is implemented in `fb_post`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After an application has prepared the graphic buffer, it needs to post the buffer
    to the display so that users can see it on the screen. This `fb_post` function
    is used to display the graphic buffer to the screen. It takes two parameters,
    `dev` and `buffer`. The `dev` parameter is the pointer of an instance of the data
    structure of `framebuffer_device_t`, which was discussed previously (refer to
    the diagram about the relationship between `fb_context_t` and `framebuffer_device_t`).
    As per the previous discussion, `dev` can be cast to `ctx`, which is a pointer
    of `fb_context_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have an instance of the device, we can get the instance of the Gralloc
    module from it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Another parameter is `buffer` and it has a `buffer_handle_t` data type. It includes
    the buffer to be posted. As we discussed previously, it can be cast as a point
    of `private_handle_t` and it is stored in the `hnd` variable. This buffer can
    be a graphic buffer in system memory or it can be part of the framebuffer. Based
    on the value of the `hnd->flags` member variable, we can find out what kind of
    buffer it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is a buffer as part of the framebuffer, we need to activate it as the
    buffer for the display. This can be done using the framebuffer''s `ioctl` function.
    To call the `ioctl` function, we need a data structure of `fb_var_screeninfo`
    and this can be found in `m->info`. To swap the buffer in double buffering, we
    just need to set the vertical offset and activate it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is a buffer allocated in system memory, we need to copy it to the framebuffer.
    In this case, it tries to lock both the graphic buffer and framebuffer first,
    and then it copies the graphic buffer using `memcpy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Graphics HAL of the Android emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have analyzed the default Gralloc module implementation, we want to
    briefly look at another Gralloc module implementation so that we can compare how
    a Gralloc module should be implemented on varying Graphic hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The Gralloc module we will analyze in this section is the Gralloc module used
    by the Android emulator. The default Gralloc module `gralloc.default.so` only
    uses framebuffer devices and it doesn't use GPU. If the default Gralloc module
    is used, OpenGL support has to be implemented in the software layer. This is the
    case with VirtualBox for the time being, since there is no Mesa/DRM-compliant
    implementation in the VirtualBox host side for OpenGL. This doesn't mean VirtualBox
    doesn't support OpenGL. It does support OpenGL and 3D hardware acceleration, but
    the implementation is not compliant with the open source Mesa/DRM architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in this topic about OpenGL support on VirtualBox, you
    may read the following threads in the Android-x86 discussion group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI](https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI)'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of hardware GLES emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3D graphics support on Andriod emulator is implemented in different ways as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`: This is the default mode. This is also called hardware GLES emulation.
    It uses specific translator libraries to convert guest EGL/GLES commands into
    host GL ones. This requires valid OpenGL drivers installed on the host machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swiftshader`: This is a software library for high-performance graphics rendering
    on the CPU. It takes advantage of SIMD on modern CPUs to perform graphics rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mesa`: This is deprecated. It is a software library using the Mesa3D library.
    It is slower than swiftshader mode, and slower than the `host` mode by a large
    margin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`guest`: This is a pure software implementation on the guest side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To choose a graphic mode in the emulator, you can either specify it on the
    command line with the `-gpu` option or define it in the `config.ini` configuration
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will look at the Gralloc module implementation in the `host` mode here.
    In the hardware GLES emulation, there are several host "translator" libraries
    implemented: EGL, GLES 1.1, and GLES 2.0 ABIs (Application Binary Interface) defined
    by Khronos. These libraries translate the corresponding function calls into calls
    to the appropriate host OpenGL APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: There are the same set of system libraries implemented inside the emulated guest
    system for EGL, GLES 1.1, and GLES 2.0 ABIs. They collect the sequence of EGL/GLES
    function calls and translate them into a custom wire protocol stream that is sent
    to the emulator program through a high-speed communication channel called a "QEMU
    pipe." The pipe is implemented with a custom kernel driver and it can provide
    a very fast channel for communication between the host and the guest system. I
    have given a brief introduction about the QEMU pipe in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml),
    *Discovering Kernel, HAL, and Virtual Hardware* and you can refer to it for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_006.png)'
  prefs: []
  type: TYPE_IMG
- en: Hardware GLES emulation
  prefs: []
  type: TYPE_NORMAL
- en: You can find the preceding diagram in the emulator source code at `$AOSP/external/qemu/distrib/android-emugl/DESIGN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The emulator source code is not downloaded using the manifest file in this
    chapter. You can refer to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN](https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or you can get the entire repository using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding diagram shows components on both the host (emulator) side and
    the guest side for the GLES emulation. We may treat the host side implementation
    as GPU, and **QEMU PIPE** is the connection between GPU and CPU. There are two
    things that need to access GPU for 3D graphics acceleration: the Gralloc module
    and the vendor library. The vendor library here refers to the hardware GLES emulation
    library for Android emulator. The Gralloc module is the one that we want to explore
    in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GLES hardware emulation Gralloc module is very similar to the default Gralloc
    module that we have discussed in this chapter. It needs to implement the following
    three HAL data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For the first data structure, `hw_module_t`, both Gralloc modules have their
    own implementation called `private_module_t`, which is inherited from `hw_module_t`,
    but the definitions are different, as we can see in the following snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `private_module_t` in the default Gralloc module is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `private_module_t` in the GLES emulation Gralloc module is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `hw_device_t` data structure implementation, we can get the details
    from the following table. We can create two kinds of devices, `GPU0` and `FB0`,
    using the `open` method in the `hw_module_methods_t` data structure. In both implementations,
    data structures inherited from `hw_device_t` are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **hw_device_t in** **Gralloc module** | **GPU0** | **FB0** |'
  prefs: []
  type: TYPE_TB
- en: '| Android emulator | `gralloc_device_t` | `fb_device_t` |'
  prefs: []
  type: TYPE_TB
- en: '| Default Gralloc | `gralloc_context_t` | `fb_context_t` |'
  prefs: []
  type: TYPE_TB
- en: 'We have analyzed both `gralloc_context_t` and `fb_context_t` in the *Initializing
    GPU* section. We can look at the definitions of `gralloc_device_t` and `fb_device_t`
    in the following GLES emulation implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Initializing GPU0 and FB0 in GLES emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, device initialization is done in the `open` method defined in the
    `hw_module_methods_t` data structure. Let''s look at the implementation of the
    `open` method in GLES emulation. It is implemented in the `gralloc_device_open`
    function, as we can see in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is part of the `GPU0` initialization. Before it creates
    the devices for `GPU0` or `FB0`, it will call a `fallback_init` function to check
    the system settings for hardware emulation. In `fallback_init`, it will check
    a `ro.kernel.qemu.gles` system property. If this property is set to 0, the GPU
    emulation will be disabled. The default Gralloc module will be used. In this case,
    the `open` method defined in the default Gralloc module, `sFallback`, will be
    called.
  prefs: []
  type: TYPE_NORMAL
- en: For the `GPU0` initialization, it will check whether the device name is equal
    to `GRALLOC_HARDWARE_GPU0` or not. If it is `GPU0`, it will get the host connection
    first. The host connection is the QEMU pipe link between the host and the guest
    system as we discussed before.
  prefs: []
  type: TYPE_NORMAL
- en: After that, it initializes the `GPU0` device as the initialization process that
    we discussed for the default Gralloc module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s have a look at the `FB0` initialization as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the `FB0` initialization, it tries to get the host connection and an `rcEnc`
    pointer, which is an instance of the `renderControl_encoder_context_t` data structure,
    using the `DEFINE_AND_VALIDATE_HOST_CONNECTION` macro. With `rcEnc`, it can get
    the framebuffer attributes (`width`, `height`, `xdpi`, `ydpi`, `fps`, `min_si`,
    and `max_si`) from the host connection. After that, it creates an instance of
    the `fb_device_t` data structure and fills in the framebuffer attributes in this
    instance of `fb_device_t`.
  prefs: []
  type: TYPE_NORMAL
- en: GPU0 device implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did for the default Gralloc module, we will analyze the `alloc` and `free`
    methods in the `GPU0` device. The `alloc` method is implemented in the `gralloc_alloc`
    function. The `gralloc_alloc` function is much longer than the one in the default
    Gralloc module, but it basically does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks the `usage` parameter and decides the pixel format to decide the size
    of the pixel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to the information provided by the `usage` parameter, `w`, `h`, `format`,
    and `usage` create a shared memory region and allocate buffers in the host side
    (GPU).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores both the shared memory region and host side (GPU) buffer information
    in the Gralloc device data structure `grdev`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the code for `gralloc_alloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code of `gralloc_alloc`, it creates an instance of data structure
    `gralloc_device_t` first. After that, it checks the `usage` and `format` parameters
    to decide the size of the pixels and the corresponding GLES color format and pixel
    type to store in the `bpp`, `glFormat`, and `glType` variables. With the necessary
    information, it can calculate the size of the shared memory that needs to be allocated
    for the graphic buffer and stores it in the `ashmem_size` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the shared memory size `ashmem_size`, it allocates a shared memory region
    using the `ashmem_create_region` function and it obtains the shared memory region
    as an `fd` file descriptor. To store the shared memory region and the GPU buffer
    (the host side buffer), which we will discuss now, it creates an instance of the
    `cb_handle_t` data structure. If we recall, we used the `private_handle_t` data
    structure in the default Gralloc module to represent an allocated graphic buffer.
    Here, `cb_handle_t` is an equivalent of `private_handle_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because `cb_handle_t` is a large data structure, in the preceding code snippet
    we did not show all the member functions of `cb_handle_t`. From the member variables,
    we can see that they are similar to `private_handle_t`. You can refer to the section
    on `private_handle_t` for an explanation of most member variables. Pay attention
    to the last member variable, `hostHandle`, which is used to store the buffer allocated
    on GPU (the host side in GLES emulation). If you are interested in host side GLES
    emulation, you can refer to the QEMU source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the last piece of code for `gralloc_alloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After the buffer is allocated on GPU and the shared memory region is acquired
    from the system memory, they are stored in the `grdev` variable and added to a
    linked list node to the double linked list in `gralloc_device_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `free` method of `gralloc_device_t`, it is much simpler than `alloc`.
    To save space, I won''t list the source code here. The `free` method is implemented
    in the `gralloc_free` function. What it does is:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate the `buffer_handle_t` point to a valid `cb_handle_t` data structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release the buffer on the host side (GPU), calling the `rcCloseColorBuffer`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Un-map the buffer in the shared memory region and release the shared memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the node from the linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Free the memory used by the `cb_handle_t` data structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FB0 device implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the implementation of the `FB0` device, we will look at the `post` method
    as we did for the default Gralloc module analysis. This is implemented in the
    `fb_post` function and we can look at the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: What it does is very simple; it increases the post count of the buffer and calls
    to the `rcFBpost` function to update the buffer in GPU.
  prefs: []
  type: TYPE_NORMAL
- en: We have completed our analysis of Android emulator graphics HAL now. I hope
    the analysis of the generic graphics HAL and Android emulator graphics HAL has
    helped you understand the graphics HAL in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored and reviewed two Gralloc HAL module implementations,
    the default Gralloc module and the one used by Android emulator. The default Gralloc
    HAL uses framebuffer devices only and the OpenGLES support uses a software implementation.
    The one used by Android emulator is a hardware emulation on the host side. The
    implementation is similar to the GPU-based Gralloc module.
  prefs: []
  type: TYPE_NORMAL
- en: Since graphics systems are so complex, we will continue exploring this topic
    a little more when looking at VirtualBox-specific implementation in the next chapter.
    We will explain the loading process of Gralloc HAL and OpenGL ES libraries. We
    will build a VirtualBox extension pack for Android so that we can utilize the
    capability provided by VirtualBox.
  prefs: []
  type: TYPE_NORMAL
