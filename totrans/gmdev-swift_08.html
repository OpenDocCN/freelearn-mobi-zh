<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Polishing to a Shine – HUD, Parallax Backgrounds, Particles, and More</h1></div></div></div><p>Our core gameplay mechanics are in place; now we can improve the overall user experience. We will turn our focus to the non-gameplay features that make our games shine. To start, we will add a <a id="id284" class="indexterm"/>heads-up display (<strong>HUD</strong>) to display the player's health and coin count. Then, we will implement multiple layers of parallax background to add depth and immersion to the game world. We will also explore SpriteKit's particle system, and use a particle emitter to add production value to the game. Combined, these steps will add to the fun of the gameplay experience, invite the player deeper into the game world, and impart a professional, polished feeling to our app.</p><p>The topics in this chapter include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding a HUD</li><li class="listitem" style="list-style-type: disc">Parallax background layers</li><li class="listitem" style="list-style-type: disc">Using the particle system</li><li class="listitem" style="list-style-type: disc">Granting safety as the game starts</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Adding a heads-up display</h1></div></div></div><p>Our game <a id="id285" class="indexterm"/>needs a HUD to show the player's current health and coin score. We can use hearts to indicate health – like classic games in the past – and draw text to the screen with <code class="literal">SKLabelNode</code> to display the number of coins collected.</p><p>We will attach the HUD to the scene itself, instead of to the <code class="literal">world</code> node, since it does not move as the player flies forward. We do not want to block the player's vision of upcoming obstacles to the right, so we will place the HUD elements in the top left corner of the screen.</p><p>When we are<a id="id286" class="indexterm"/> finished, our HUD will look like this (after the player collects 110 coins and sustains one point of damage):</p><div><img src="img/Image_B04532_08_01.jpg" alt="Adding a heads-up display"/></div><p>To implement the<a id="id287" class="indexterm"/> HUD, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to add the HUD art assets into the game. In the asset pack, find the <code class="literal">HUD.atlas</code> texture atlas and add it to your project.</li><li class="listitem">Next, we will create a <code class="literal">HUD</code> class to handle all of the HUD logic. Add a new Swift file to your project, <code class="literal">HUD.swift</code>, and add the following code to begin work on the <code class="literal">HUD</code> class:<div><pre class="programlisting">import SpriteKit

class HUD: SKNode {
    var textureAtlas:SKTextureAtlas = 
        SKTextureAtlas(named:"hud.atlas")
    // An array to keep track of the hearts:
    var heartNodes:[SKSpriteNode] = []
    // An SKLabelNode to print the coin score:
    let coinCountText = SKLabelNode(text: "000000")
}</pre></div></li><li class="listitem">We need an initializer-style function to create a new <code class="literal">SKSpriteNode</code> for each heart shape and configure the new <code class="literal">SKLabelNode</code> for the coin counter. Add a function named <code class="literal">createHudNodes</code> to the <code class="literal">HUD</code> class, as follows:<div><pre class="programlisting">func createHudNodes(screenSize:CGSize) {
    // --- Create the coin counter ---
    // First, create and position a bronze coin icon:
    let coinTextureAtlas:SKTextureAtlas = 
        SKTextureAtlas(named:"goods.atlas")
    let coinIcon = SKSpriteNode(texture: 
        coinTextureAtlas.textureNamed("coin-bronze.png"))
    // Size and position the coin icon:
    let coinYPos = screenSize.height - 23
    coinIcon.size = CGSize(width: 26, height: 26)
    coinIcon.position = CGPoint(x: 23, y: coinYPos)
    // Configure the coin text label:
    coinCountText.fontName = "AvenirNext-HeavyItalic"
    coinCountText.position = CGPoint(x: 41, y: coinYPos)
    // These two properties allow you to align the text
    // relative to the SKLabelNode's position:
    coinCountText.horizontalAlignmentMode = 
        SKLabelHorizontalAlignmentMode.Left
    coinCountText.verticalAlignmentMode = 
        SKLabelVerticalAlignmentMode.Center
    // Add the text label and coin icon to the HUD:
    self.addChild(coinCountText)
    self.addChild(coinIcon)
    
    // Create three heart nodes for the life meter:
    for var index = 0; index &lt; 3; ++index {
        let newHeartNode = SKSpriteNode(texture: 
            textureAtlas.textureNamed("heart-full.png"))
        newHeartNode.size = CGSize(width: 46, height: 40)
        // Position the hearts below the coin counter:
        let xPos = CGFloat(index * 60 + 33)
        let yPos = screenSize.height - 66
        newHeartNode.position = CGPoint(x: xPos, y: yPos)
        // Keep track of nodes in an array property:
        heartNodes.append(newHeartNode)
        // Add the heart nodes to the HUD:
        self.addChild(newHeartNode)
    }
}</pre></div></li><li class="listitem">We also need a <a id="id288" class="indexterm"/>function that the <code class="literal">GameScene</code> class can call to update the coin counter label. Add a new function to the <code class="literal">HUD</code> class named <code class="literal">setCoinCountDisplay</code>, as follows:<div><pre class="programlisting">func setCoinCountDisplay(newCoinCount:Int) {
    // We can use the NSNumberFormatter class to pad
    // leading 0's onto the coin count:
    let formatter = NSNumberFormatter()
    formatter.minimumIntegerDigits = 6
    if let coinStr = formatter.stringFromNumber(newCoinCount) {
        // Update the label node with the new coin count:
        coinCountText.text = coinStr
    }
}</pre></div></li><li class="listitem">We will also<a id="id289" class="indexterm"/> need a function to update the heart graphic when the player's health changes. Add a new function to the <code class="literal">HUD</code> class named <code class="literal">setHealthDisplay</code>, as follows:<div><pre class="programlisting">func setHealthDisplay(newHealth:Int) {
    // Create a fade SKAction to fade out any lost hearts:
    let fadeAction = SKAction.fadeAlphaTo(0.2, 
        duration: 0.3)
    // Loop through each heart and update its status:
    for var index = 0; index &lt; heartNodes.count; ++index {
        if index &lt; newHealth {
            // This heart should be full red:
            heartNodes[index].alpha = 1
        }
        else {
            // This heart should be faded:
            heartNodes[index].runAction(fadeAction)
        }
    }
}</pre></div></li><li class="listitem">Our <code class="literal">HUD</code> class is complete. Next, we will wire it up in the <code class="literal">GameScene</code> class. Open <code class="literal">GameScene.swift</code> and add a new property to the <code class="literal">GameScene</code> class, instantiating an instance of the <code class="literal">HUD</code> class:<div><pre class="programlisting">let hud = HUD()</pre></div></li><li class="listitem">We need to place the <code class="literal">HUD</code> node into the scene, on top of the other game objects. Add this code at the bottom of the <code class="literal">GameScene didMoveToView</code> function:<div><pre class="programlisting">// Create the HUD's child nodes:
hud.createHudNodes(self.size)
// Add the HUD to the scene:
self.addChild(hud)
// Position the HUD above any other game element
hud.zPosition = 50</pre></div></li><li class="listitem">We are ready to send health and coin updates to the <code class="literal">HUD</code>. First, we will update the <code class="literal">HUD</code> with health updates when the player takes damage. Inside the <code class="literal">GameScene didBeginContact</code> function, locate the contact cases where the player takes<a id="id290" class="indexterm"/> damage – when he or she touches the ground or an enemy – and add this new code (in bold), to send health updates to the <code class="literal">HUD</code>:<div><pre class="programlisting">case PhysicsCategory.ground.rawValue:
    player.takeDamage()
<strong>    hud.setHealthDisplay(player.health)</strong>
case PhysicsCategory.enemy.rawValue:
    player.takeDamage()
<strong>    hud.setHealthDisplay(player.health)</strong>
</pre></div></li><li class="listitem">Finally, we will update the <code class="literal">HUD</code> whenever the player collects a coin. Locate the contact case where the player contacts a coin and call the <code class="literal">HUD setCoinCountDisplay</code> function (new code in bold) as follows:<div><pre class="programlisting">case PhysicsCategory.coin.rawValue:
    // Try to cast the otherBody's node as a Coin:
    if let coin = otherBody.node as? Coin {
        coin.collect()
        self.coinsCollected += coin.value
<strong>        hud.setCoinCountDisplay(self.coinsCollected)</strong>
    }</pre></div></li><li class="listitem">Run the project and you should see your coin counter and health meter appear in the upper left hand corner, as seen in this screenshot:<div><img src="img/Image_B04532_08_02.jpg" alt="Adding a heads-up display"/></div></li></ol></div><p>Great job! Our HUD is complete. Next, we will build our background layers.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Parallax background layers</h1></div></div></div><p>Parallax adds the<a id="id291" class="indexterm"/> feeling of depth to your game by drawing separate background layers and moving them past the camera at varying speeds. Very slow backgrounds give the illusion of distance, while fast moving backgrounds appear to be very close to the player. We can enhance the effect by painting faraway objects with increasingly desaturated colors.</p><p>In our game, we will achieve the parallax effect by attaching our backgrounds to the world, then slowly pushing the backgrounds to the right as the world moves left. As the world moves to the left (bringing the backgrounds with it), we will move the background's <em>x</em> position to the right so that the total movement is less than for the normal game objects. The result will be background layers that appear to move more slowly than the rest of our game, and thus appear farther away.</p><p>In addition, each background will only be 3000 points wide, but will jump forward at precise intervals to loop seamlessly, in a similar way to the <code class="literal">Ground</code> class.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec79"/>Adding the background assets</h2></div></div></div><p>First, add the art <a id="id292" class="indexterm"/>by following these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your project's <code class="literal">Images.xcassets</code> file in Xcode.</li><li class="listitem">In the provided game assets, locate the four background images in the <code class="literal">Backgrounds</code> folder.</li><li class="listitem">Drag and drop the four backgrounds into the left pane of the <code class="literal">Images.xcassets</code> file.</li></ol></div><p>You should see the backgrounds appear in the left pane as shown here:</p><div><img src="img/Image_B04532_08_03.jpg" alt="Adding the background assets"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec80"/>Implementing a background class</h2></div></div></div><p>We will need a new <a id="id293" class="indexterm"/>class to manage the repositioning logic for parallax and seamless looping. We can instantiate a new instance of a <code class="literal">Background</code> class for each background layer. To create the <code class="literal">Background</code> class, add a new Swift file, <code class="literal">Background.swift</code>, to your project, using the following code:</p><div><pre class="programlisting">import SpriteKit

class Background: SKSpriteNode {
    // movementMultiplier will store a float from 0-1 to indicate
    // how fast the background should move past.
    // 0 is full adjustment, no movement as the world goes past
    // 1 is no adjustment, background passes at normal speed
    var movementMultiplier = CGFloat(0)
    // jumpAdjustment will store how many points of x position
    // this background has jumped forward, useful for calculating
    // future seamless jump points:
    var jumpAdjustment = CGFloat(0)
    // A constant for background node size:
    let backgroundSize = CGSize(width: 1000, height: 1000)
    
    func spawn(parentNode:SKNode, imageName:String, 
        zPosition:CGFloat, movementMultiplier:CGFloat) {
        // Position from the bottom left:
        self.anchorPoint = CGPointZero
        // Start backgrounds at the top of the ground (y: 30)
        self.position = CGPoint(x: 0, y: 30)
        // Control the order of the backgrounds with zPosition:
        self.zPosition = zPosition
        // Store the movement multiplier:
        self.movementMultiplier = movementMultiplier
        // Add the background to the parentNode:
        parentNode.addChild(self)
        
        // Build three child node instances of the texture,
        // Looping from -1 to 1 so the backgrounds cover both
        // forward and behind the player at position zero.
        // closed range operator: "..." includes both endpoints:
        for i in -1...1 {
            let newBGNode = SKSpriteNode(imageNamed: imageName)
            // Set the size for this node from constant: 
            newBGNode.size = backgroundSize
            // Position these nodes by their lower left corner:
            newBGNode.anchorPoint = CGPointZero
            // Position this background node:
            newBGNode.position = CGPoint(
                x: i * Int(backgroundSize.width), y: 0)
            // Add the node to the Background:
            self.addChild(newBGNode)
        }
    }
    
    // We will call updatePosition every frame to
    // reposition the background:
    func updatePosition(playerProgress:CGFloat) {
        // Calculate a position adjustment after loops and 
        // parallax multiplier:
        let adjustedPosition = jumpAdjustment + playerProgress * 
            (1 - movementMultiplier)
        // Check if we need to jump the background forward:
        if playerProgress - adjustedPosition &gt; 
            backgroundSize.width {
            jumpAdjustment += backgroundSize.width
        }
        // Adjust this background forward as the world 
        // moves back so the background appears slower:
        self.position.x = adjustedPosition
    }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec81"/>Wiring up backgrounds in the GameScene class</h2></div></div></div><p>We need to make three <a id="id294" class="indexterm"/>code additions to the <code class="literal">GameScene</code> class to wire up our backgrounds. First, we will create an array to keep track of the backgrounds. Next, we will spawn the backgrounds as the scene begins. Finally, we can call the <code class="literal">Background</code> class <code class="literal">updatePosition</code> function from the <code class="literal">GameScene didSimulatePhsyics</code> function to reposition the backgrounds before every frame. Follow these steps to wire up the backgrounds:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new array property on the <code class="literal">GameScene</code> class itself to store our backgrounds, as shown here:<div><pre class="programlisting">var backgrounds:[Background] = []</pre></div></li><li class="listitem">At the bottom of the <code class="literal">didMoveToView</code> function, instantiate and spawn our four backgrounds:<div><pre class="programlisting">// Instantiate four Backgrounds to the backgrounds array:
for i in 0...3 {
    backgrounds.append(Background())
}
// Spawn the new backgrounds:
backgrounds[0].spawn(world, imageName: "Background-1", zPosition: -5, movementMultiplier: 0.75)
backgrounds[1].spawn(world, imageName: "Background-2", zPosition: -10, movementMultiplier: 0.5)
backgrounds[2].spawn(world, imageName: "Background-3", zPosition: -15, movementMultiplier: 0.2)
backgrounds[3].spawn(world, imageName: "Background-4", zPosition: -20, movementMultiplier: 0.1)</pre></div></li><li class="listitem">Lastly, add the following code at the bottom of the <code class="literal">didSimulatePhysics</code> function to reposition the backgrounds before each frame:<div><pre class="programlisting">// Position the backgrounds:
for background in self.backgrounds {
    background.updatePosition(playerProgress)
}</pre></div></li><li class="listitem">Run the project. You should see the four background images as separate layers behind the action, moving past with a parallax effect. This screenshot shows the backgrounds as they should appear in your game:<div><img src="img/Image_B04532_08_04.jpg" alt="Wiring up backgrounds in the GameScene class"/></div></li></ol></div><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>If you are using the iOS simulator to test your game, it is normal to experience a lowered frame rate after adding these large background textures to the game. The game will still run well on iOS devices.</p></div></div><p>Excellent! You <a id="id295" class="indexterm"/>have successfully implemented your background system. The background makes Pierre Penguin's world feel full, adding immersion to the game. Next, we will use a particle emitter to add a trail behind Pierre – a fun addition that helps the player master the controls.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Checkpoint 8-A</h1></div></div></div><p>To download my project to this point, visit this URL:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-8">http://www.thinkingswiftly.com/game-development-with-swift/chapter-8</a>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Harnessing SpriteKit's particle system</h1></div></div></div><p>SpriteKit includes<a id="id296" class="indexterm"/> a powerful particle system that makes<a id="id297" class="indexterm"/> it easy to add exciting graphics to your game. Particle emitter nodes create many small instances of an image that combine together to create a great-looking effect. You can use emitter nodes to generate snow, fire, sparks, explosions, magic, and other useful effects that would otherwise require a lot of effort.</p><p>For our game, you<a id="id298" class="indexterm"/> will learn to use an emitter node to create a trail of small dots behind Pierre Penguin as he flies, making it easier for the player<a id="id299" class="indexterm"/> to learn how their taps influence Pierre's flight path.</p><p>When we are finished, Pierre's dot trail will look something like this:</p><div><img src="img/Image_B04532_08_05.jpg" alt="Harnessing SpriteKit's particle system"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec82"/>Adding the circle particle asset</h2></div></div></div><p>Each particle <a id="id300" class="indexterm"/>system emits multiple versions of a single image in order to create a cumulative particle effect. In our case, the image is a simple circle. To add the circle image to the game, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Images.xcassets</code> file in Xcode.</li><li class="listitem">Locate the <code class="literal">dot.png</code> image in the <code class="literal">Particles</code> folder of the provided game assets.</li><li class="listitem">Drag and drop the image file into the left pane of <code class="literal">Images.xcassets</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec83"/>Creating a SpriteKit Particle File</h2></div></div></div><p>Xcode<a id="id301" class="indexterm"/> provides an excellent UI for creating and editing particle systems. To use the UI, we will add a new <strong>SpriteKit Particle File</strong> to our project. Follow these steps to add the new file:</p><div><ol class="orderedlist arabic"><li class="listitem">Start by adding a new file to your project and locating the <strong>SpriteKit Particle File</strong> type. You can find this template under the <strong>Resource</strong> category, as shown here:<div><img src="img/Image_B04532_08_06.jpg" alt="Creating a SpriteKit Particle File"/></div></li><li class="listitem">In the following prompt, select <strong>Snow</strong> as the <strong>Particle Template</strong>.</li><li class="listitem">Name the file <code class="literal">PierrePath.sks</code> and click <strong>Create</strong> to add the new file to your project.</li></ol></div><p>Xcode will open the new particle emitter in the main frame, which should look something like this:</p><div><img src="img/Image_B04532_08_07.jpg" alt="Creating a SpriteKit Particle File"/><div><p>Previewing the Snow template in Xcode's particle editor</p></div></div><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>At the time of writing, Xcode's particle editor remains quirky. If you do not see the white snow particle effect in the middle, try clicking anywhere in the dark gray center area to reposition the particle emitter – occasionally it does not start where expected.</p><p>This is also useful for testing setting changes without overlap from old particles. Simply click anywhere in the editor to reposition the emitter.</p></div></div><p>Make sure you<a id="id302" class="indexterm"/> have the right-hand sidebar turned on by lighting up the Utilities button in the upper right corner of Xcode, as shown here:</p><div><img src="img/Image_B04532_08_08.jpg" alt="Creating a SpriteKit Particle File"/></div><p>You can use the Utilities sidebar to edit the animation qualities of the particle emitter. You can edit several properties: the number of particles, the lifetime of a particle, how fast the particles move, how they scale up or down, and so on. This is a fantastic tool because you can see immediate feedback from your changes. Feel free to experiment by changing the particle properties.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec84"/>Configuring the path particle settings</h2></div></div></div><p>To create Pierre's dot trail, update <a id="id303" class="indexterm"/>your particle settings to match the settings shown in this screenshot:</p><div><img src="img/Image_B04532_08_09.jpg" alt="Configuring the path particle settings"/></div><p>You have the correct settings when your editor shows a tiny white circle with no apparent movement.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Adding the particle emitter to the game</h2></div></div></div><p>We will attach<a id="id304" class="indexterm"/> our new emitter to the <code class="literal">Player</code> node, so the emitter will create new white circles wherever the player flies. We can easily reference the emitter design we just created in the editor from our code. Open <code class="literal">Player.swift</code> and add this code at the bottom of the <code class="literal">spawn</code> function:</p><div><pre class="programlisting">// Instantiate a SKEmitterNode with the PierrePath design:
let dotEmitter = SKEmitterNode(fileNamed: "PierrePath.sks")
// Place the particle zPosition behind the penguin:
dotEmitter.particleZPosition = -1
// By adding the emitter node to the player, the emitter will move 
// with the penguin and emit new dots wherever the player moves
self.addChild(dotEmitter)
// However, the particles themselves should attach to the world,
// so they trail behind as the player moves forward.
// (Note that self.parent refers to the world node)
dotEmitter.targetNode = self.parent</pre></div><p>Run the project. You should see the white dots trailing behind Pierre, as shown here:</p><div><img src="img/Image_B04532_08_10.jpg" alt="Adding the particle emitter to the game"/></div><p>Good work. Now the player can see where they have flown, which is both fun and instructive. The feedback from the dots will help the player learn the sensitivity of the control system and thus master the game more quickly.</p><p>This is just one of many special effects you can create with particle emitter nodes. You can explore other creative possibilities now that you know how to create, edit, and place particle emitters in the world. Other fun ideas include sparks when Pierre bumps into enemies, or gentle snow falling in the background.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Granting safety as the game starts</h1></div></div></div><p>You may have<a id="id305" class="indexterm"/> noticed that Pierre Penguin quickly falls to the ground as soon as you launch the game, which is not much fun. Instead, we can launch Pierre into a graceful looping arc as the game starts to give the player a moment to prepare for flight. To do so, open <code class="literal">Player.swift</code> and add this code at the bottom of the <code class="literal">spawn</code> function:</p><div><pre class="programlisting">// Grant a momentary reprieve from gravity:
self.physicsBody?.affectedByGravity = false
// Add some slight upward velocity:
self.physicsBody?.velocity.dy = 50
// Create a SKAction to start gravity after a small delay:
let startGravitySequence = SKAction.sequence([
    SKAction.waitForDuration(0.6),
    SKAction.runBlock {
        self.physicsBody?.affectedByGravity = true
    }])
self.runAction(startGravitySequence)</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Checkpoint 8-B</h1></div></div></div><p>To download my project to this point, visit this URL:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-8">http://www.thinkingswiftly.com/game-development-with-swift/chapter-8</a>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Summary</h1></div></div></div><p>We brought the game world to life in this chapter. We drew a HUD to show the player their remaining health and coin score, added parallax backgrounds to increase the depth and immersion of the world, and learned to use particle emitters to create special graphics in our games. In addition, we added a small delay before gravity drags our hero down at the beginning of each flight. Our game is fun and looking great!</p><p>Next, we need a menu so we can restart the game without rebuilding the project or manually closing the application. In <a class="link" href="ch09.html" title="Chapter 9. Adding Menus and Sounds">Chapter 9</a>, <em>Adding Menus and Sounds</em>, we will design a start menu, add a retry button when the player dies, and play sounds and music to create a deeper gameplay experience.</p></div></body></html>