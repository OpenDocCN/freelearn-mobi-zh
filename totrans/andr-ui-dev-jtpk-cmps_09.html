<html><head></head><body><div><div><h1 id="_idParaDest-93"><a id="_idTextAnchor119"/>Chapter 7: Tips, Tricks, and Best Practices</h1>
			<p>In <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>, we combined several key techniques of Jetpack Compose such as state hoisting, app theming, and navigation in a real-world example. <code>ComposeUnitConverter</code> stores state in a <code>ViewModel</code> and eventually persists it using the <em class="italic">Repository</em> pattern. In this chapter, I show you how to pass objects to a <code>ViewModel</code> upon instantiation and use these objects to load and save data. In <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, we examined features of well-behaved composable functions. Composables should be free of side effects to make them reusable and easy to test. However, there are situations when you need to either react to or initiate state changes that happen outside the scope of a composable function. We will cover this at the end of this chapter.</p>
			<p>These are the main sections of this chapter:</p>
			<ul>
				<li><a id="_idTextAnchor120"/>Persisting and retrieving state</li>
				<li><a id="_idTextAnchor121"/>Keeping your composables responsive</li>
				<li>Understanding side effects</li>
			</ul>
			<p>We start by continuing the exploration of the <code>ViewModel</code> pattern we began in the <em class="italic">Using a ViewModel</em> section of <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>. This time, we will add business logic to the <code>ViewModel</code> and inject an object that can persist and retrieve data.</p>
			<p>The <em class="italic">Keeping your composables responsive</em> section revisits one of the key requirements of a composable function. As recomposition can occur very often, composables must be as fast as possible. This greatly influences what the code may and may not do. Long-running tasks—for example, complex computations or network calls—should not be invoked synchronously.</p>
			<p>The <em class="italic">Understanding side effects</em> section covers situations when you need to either react to or initiate state changes that happen outside the scope of a composable function. For example, we will be using <code>LaunchedEffect</code> to start and stop complex computations.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor122"/>Technical requirements</h1>
			<p>The <em class="italic">Persisting and retrieving state</em> and <em class="italic">Keeping your composables responsive</em> sections further discuss the sample <code>ComposeUnitConverter</code> app. The <em class="italic">Understanding side effects</em> section is based on the <code>EffectDemo</code> sample. Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em> for information about how to install and set up Android Studio and how to get the repository accompanying this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_07">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_07</a>.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor123"/>Persisting and retrieving state</h1>
			<p>State is<a id="_idIndexMarker264"/> app data that may change over time. In a Compose app, state is typically <a id="_idIndexMarker265"/>represented as instances of <code>State</code> or <code>MutableState</code>. If such objects are used inside composable functions, a recomposition is triggered upon state changes. If a state is passed to several composables, all of them may be recomposed. This leads to the <em class="italic">state hoisting</em> principle: state is passed to composable functions rather than being remembered inside them. Often, such state is remembered in the composable that is the parent of the ones using the state. An alternative approach is to implement an architectural pattern called <code>ViewModel</code>. It is used in many <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) frameworks on various platforms. On Android, it has been available since 2017 as part of the <strong class="bold">Android Architecture Components</strong>.</p>
			<p>The general idea of a <code>ViewModel</code> is to combine data and access logic that is specific to a certain part of an app. Depending on the platform, this may be a screen, a window, a dialog, or another similar top-level container. On Android, it's usually an activity. The data is observable, so UI elements can register and get notified upon changes. How the observable pattern is implemented depends on the platform. The Android Architecture Components introduced <code>LiveData</code> and <code>MutableLiveData</code>. In the <em class="italic">Surviving configuration changes</em> section of <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>, I showed you how to use them inside a <code>ViewModel</code> to store data that survives device rotations and how to connect <code>LiveData</code> instances to composable functions.</p>
			<p>Here's a brief recap: to connect <code>LiveData</code> objects to the Compose world, we first obtain a <code>ViewModel</code> instance using <code>androidx.lifecycle.viewmodel.compose.viewModel()</code>, and then invoke the <code>observeAsState()</code> extension function on a property of the <code>ViewModel</code>. The returned state is read-only, so if a composable wants to update the property, it must call a setter that needs to be provided by the <code>ViewModel</code>.</p>
			<p>So far, I have not explained how to persist state and restore it later. To put it another way: where do <code>ViewModel</code> instances get the initial values for their data, and what do they do upon changes? Let's find out in the next section.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor124"/>Injecting objects into a ViewModel</h2>
			<p>If a <code>ViewModel</code> wants <a id="_idIndexMarker266"/>to load and save data, it may need to access <a id="_idIndexMarker267"/>a database, the local filesystem, or some remote web service. Yet, it should be irrelevant for the <code>ViewModel</code> how reading and writing data works behind the scenes. The Android Architecture Components suggest implementing the <em class="italic">Repository</em> pattern. A repository abstracts the mechanics of loading and saving data and makes it available through a collection-like interface. You can find out more about the Repository pattern at <a href="https://martinfowler.com/eaaCatalog/repository.html">https://martinfowler.com/eaaCatalog/repository.html</a>.</p>
			<p>You will see shortly what the implementation of a simple repository may look like, but first, I need to show you how to pass objects to a <code>ViewModel</code> upon instantiation. <code>viewModel()</code> receives a <code>factory</code> parameter of type <code>ViewModelProvider.Factory</code>. It is used to create <code>ViewModel</code> instances. If you pass <code>null</code> (the default value), a built-in default factory is used. <code>ComposeUnitConverter</code> has two screens, so its factory must be able to create <code>ViewModel</code> instances for each screen. </p>
			<p>Here's what <code>ViewModelFactory</code> looks like:</p>
			<pre>class ViewModelFactory(private val repository: Repository)
 :ViewModelProvider.NewInstanceFactory() {
  override fun &lt;T : ViewModel?&gt; create(modelClass:
 Class&lt;T&gt;): T =
    if (modelClass.isAssignableFrom
     (TemperatureViewModel::class.java))
      TemperatureViewModel(repository) as T
    else
      DistancesViewModel(repository) as T
}</pre>
			<p><code>ViewModelFactory</code> extends the <code>ViewModelProvider.NewInstanceFactory</code> static class and overrides the <code>create()</code> method (which belongs to the parent <code>Factory</code> interface). The <code>modelClass</code> represents the <code>ViewModel</code> to be created. Therefore, if the following code is <code>true</code>, then we instantiate <code>TemperatureViewModel</code> and pass <code>repository</code>:</p>
			<pre>modelClass.isAssignableFrom
 (TemperatureViewModel::class.java)</pre>
			<p>This parameter <a id="_idIndexMarker268"/>was passed to the constructor of <code>ViewModelFactory</code>. Otherwise, a <code>DistancesViewModel</code> instance is created. Its constructor also <a id="_idIndexMarker269"/>receives <code>repository</code>. If your factory needs to differentiate between more <code>ViewModel</code> instances, you will probably use a <code>when</code> instead.</p>
			<p>Next, let's look at my <code>Repository</code> class to find out how <code>ComposeUnitConverter</code> loads and saves data. You can see this in the following code snippet:</p>
			<pre>class Repository(context: Context) {
    private val prefs =
        PreferenceManager.getDefaultSharedPreferences(context)
    fun getInt(key: String, default: Int) = 
        prefs.getInt(key, default)
    fun putInt(key: String, value: Int) {
        prefs.edit().putInt(key, value).apply()
    }
    fun getString(key: String, 
        default: String) = prefs.getString(key, default)
    fun putString(key: String, value: String) {
        prefs.edit().putString(key, value).apply()
    }
}</pre>
			<p><code>Repository</code> uses <a id="_idIndexMarker270"/>Jetpack Preference. This library is a replacement<a id="_idIndexMarker271"/> for the platform classes and interfaces inside the <code>android.preference</code> package, which was deprecated with <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) level 29.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Both the platform classes and the library are designed for user settings. You should not use them to access more complex data, larger texts, or images. Record-like data is best kept in an SQLite database, whereas files are ideal for large texts or images.</p>
			<p>To use Jetpack Preference, we need to add an implementation dependency to <code>androidx.preference:preference-ktx</code> in the module-level <code>build.gradle</code> file. <code>getDefaultSharedPreferences()</code> requires an instance of <code>android.content.Context</code>, which is passed to the constructor of <code>Repository</code>.</p>
			<p>Before we move on, let's recap what I showed you so far, as follows:</p>
			<ul>
				<li><code>TemperatureViewModel</code> and <code>DistancesViewModel</code> receive a <code>Repository</code> instance in their constructor.</li>
				<li><code>Repository</code> receives a <code>Context</code> object.</li>
				<li><code>ViewModel</code> instances are decoupled from activities. They survive configuration changes.</li>
			</ul>
			<p>The last bullet point has an important consequence regarding the context we can pass to the repository. Let's find out more in the next section.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor125"/>Using the factory</h2>
			<p>Here's how both the repository and<a id="_idIndexMarker272"/> factory are created:</p>
			<pre>class ComposeUnitConverterActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val factory =
      ViewModelFactory(Repository(applicationContext))
    setContent {
      ComposeUnitConverter(factory)
    }
  }
}</pre>
			<p>Both <code>Repository</code> and <code>ViewModelFactory</code> are ordinary objects, so they are simply instantiated, passing the required parameters to them.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It may be tempting to pass <code>this</code> (the calling activity) as the context. However, as <code>ViewModel</code> instances survive configuration changes (that is, the recreation of an activity), the context may change. If it does, the repository would be accessing a no longer available activity. By using <code>applicationContext</code>, we make sure that this issue does not occur.</p>
			<p><code>ComposeUnitConverter()</code> is the root of the composable hierarchy. It passes the factory to <code>ComposeUnitConverterNavHost()</code>, which in turn uses it inside <code>composable {}</code> as a parameter for the screens, as illustrated in the following code snippet:</p>
			<pre>composable(ComposeUnitConverterScreen.route_temperature) {
  TemperatureConverter(
    viewModel = viewModel(factory = factory)
  )
}</pre>
			<p>In this section, I showed you how to inject a repository object into a <code>ViewModel</code> using simple constructor invocation. If your app relies on a <code>ViewModel</code> uses the repository.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor126"/>Keeping your composables responsive</h1>
			<p>When implementing <a id="_idIndexMarker273"/>composable functions, you should always keep in mind that their main purpose is to declare the UI and to handle user interactions. Ideally, anything needed to achieve this is passed to the composable, including state and logic (such as click handlers), making it stateless. If state is needed only inside a composable, the function may keep state temporarily using <code>remember {}</code>. Such composables<a id="_idIndexMarker274"/> are called <code>ViewModel</code>, composables must interact with it. So, the <code>ViewModel</code> code must be fast, too.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor127"/>Communicating with ViewModel instances</h2>
			<p>Data inside <a id="_idIndexMarker275"/>a <code>ViewModel</code> should be observable. <code>ComposeUnitConverter</code> uses <code>LiveData</code> and <code>MutableLiveData</code> from the Android Architecture Components to achieve this. You can choose other implementations of the <em class="italic">Observer</em> pattern, provided there is a way to obtain <code>State</code> or <code>MutableState</code> instances that are updated upon changes in the <code>ViewModel</code>. This is beyond the scope of this book. <code>TemperatureViewModel</code> is the <code>ViewModel</code> for the <code>TemperatureConverter()</code> composable function.</p>
			<p>Let's look at its implementation. In the following code snippet, I omitted code related to the <code>scale</code> property for brevity. You can find the full implementation in the GitHub repository:</p>
			<pre>class TemperatureViewModel(private val repository:
 Repository): ViewModel() {
  ...
<strong class="bold">  private val _temperature: MutableLiveData&lt;String&gt;</strong>
<strong class="bold">             = MutableLiveData(</strong>
<strong class="bold">                repository.getString("temperature", "")</strong>
<strong class="bold">  )</strong>
<strong class="bold">  val temperature: LiveData&lt;String&gt;</strong>
<strong class="bold">    get() = _temperature</strong>
  fun getTemperatureAsFloat(): Float
          = (_temperature.value ?: "").let {
    return try {
      it.toFloat()
    } catch (e: NumberFormatException) {
      Float.NaN
    }
  }
<strong class="bold">  fun setTemperature(value: String) {</strong>
<strong class="bold">    _temperature.value = value</strong>
<strong class="bold">    repository.putString("temperature", value)</strong>
<strong class="bold">  }</strong>
<strong class="bold">  fun convert() = getTemperatureAsFloat().let {</strong>
    if (!it.isNaN())
      if (_scale.value == R.string.celsius)
        (it * 1.8F) + 32F
      else
        (it - 32F) / 1.8F
    else
      Float.NaN
  }
}</pre>
			<p><code>ViewModel</code> instances present their data through pairs of variables, as follows:</p>
			<ul>
				<li>A public read-only property (<code>temperature</code>)</li>
				<li>A private writeable backing variable (<code>_temperature</code>)</li>
			</ul>
			<p>Properties are <a id="_idIndexMarker276"/>not changed by assigning a new value but by invoking some setter functions (<code>setTemperature()</code>). You can find an explanation of why this is the case in the <em class="italic">Using a ViewModel</em> section of <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>. There may be additional functions that can be invoked by the composable—for example, logic to convert a temperature from °C to °F (<code>convert()</code>) should not be part of the composable code. The same applies to format conversions (from <code>String</code> to <code>Float</code>). These are best kept in the <code>ViewModel</code>.</p>
			<p>Here's how the <code>ViewModel</code> is used from a composable function:</p>
			<pre>@Composable
fun TemperatureConverter(viewModel: TemperatureViewModel) {
  …
  val currentValue = viewModel.temperature.observeAsState(
                        viewModel.temperature.value ?: "")
  val scale = viewModel.scale.observeAsState(
                 viewModel.scale.value ?: R.string.celsius)
  var result by remember { mutableStateOf("") }
  val calc = {
    val temp = viewModel.convert()
    result = if (temp.isNaN())
      ""
    else
      "$temp${
        if (scale.value == R.string.celsius)
          strFahrenheit
        else strCelsius
      }"
  }
  …
  Column(
    …
  ) {
    TemperatureTextField(
      temperature = currentValue,
      modifier = Modifier.padding(bottom = 16.dp),
      callback = calc,
      viewModel = viewModel
    )
    …
    Button(
      onClick = calc,
      …
    if (result.isNotEmpty()) {
      Text(
        text = result,
        style = MaterialTheme.typography.h3
      )
    }
    …</pre>
			<p>Have you noticed<a id="_idIndexMarker277"/> that <code>TemperatureConverter()</code> receives its <code>ViewModel</code> as a parameter?</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You should provide a default value (<code>viewModel()</code>) for preview and testability, if possible. However, this doesn't work if the <code>ViewModel</code> requires a repository (as in my example) or other constructor values.</p>
			<p><code>State</code> instances are obtained by invoking <code>observeAsState()</code> of <code>ViewModel</code> properties (<code>temperature</code> and <code>scale</code>), which are <code>LiveData</code> instances. The code assigned to <code>calc</code> is executed when either the <code>result</code>, a state being used in a <code>Text()</code> composable. Please note that the <code>calc</code> lambda expression calls the <code>convert()</code> function of <code>ViewModel</code> function to get the converted temperature. You should always try to remove business logic from composables and instead put it inside the <code>ViewModel</code>.</p>
			<p>So far, I showed you how to observe changes in the <code>ViewModel</code> and how to invoke logic inside it. There is one piece left: changing a property. In the preceding code snippet, <code>TemperatureTextField()</code> receives the <code>ViewModel</code>. Let's see what it does with it here:</p>
			<pre>@Composable
fun TemperatureTextField(
  temperature: State&lt;String&gt;,
  modifier: Modifier = Modifier,
  callback: () -&gt; Unit,
  viewModel: TemperatureViewModel
) {
  TextField(
    value = temperature.value,
    onValueChange = {
      viewModel.setTemperature(it)
    },
    …</pre>
			<p>Whenever the text<a id="_idIndexMarker278"/> changes, <code>setTemperature()</code> is invoked with the new value. Please recall that the setter does the following:</p>
			<pre>_temperature.value = value</pre>
			<p>The <code>ViewModel</code> updates the value of the <code>_temperature</code> (<code>MutableLiveData</code>) backing variable. As the <code>temperature</code> public property references <code>_temperature</code>, its observers (in my example, the state returned by <code>observeAsState()</code> in <code>TemperatureConverter()</code>) are notified. This triggers a recomposition.</p>
			<p>In this section, we focused on how communication flows between composable functions and <code>ViewModel</code> instances. Next, we examine what can go wrong if the <code>ViewModel</code> breaks the contract with the composable and what you can do to prevent this.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor128"/>Handling long-running tasks</h2>
			<p>Composable functions actively<a id="_idIndexMarker279"/> interact with a <code>ViewModel</code> by setting new values for properties (<code>setTemperature()</code>) and by invoking functions that implement business logic (<code>convert()</code>). As recompositions can occur frequently, these functions may be called very often. Consequently, they must return very fast. This surely is the case for simple arithmetic, such as converting between °C and °F.</p>
			<p>On the other hand, some algorithms may become increasingly time-consuming for certain inputs. Here's an example. Fibonacci numbers can be computed recursively and iteratively. While a recursive algorithm is simpler to implement, it takes much longer for large numbers. If a synchronous function call does not return in a timely fashion, it may affect how the user perceives your app. You can test this by adding <code>while (true) ;</code> as the first line of code inside <code>convert()</code>. If you then run <code>ComposeUnitConverter</code>, enter some number, and press <strong class="bold">Convert</strong>, the app will no longer respond.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Potentially long-running tasks must be implemented asynchronously.</p>
			<p>To avoid situations <a id="_idIndexMarker280"/>where the app is not responding because a computation takes too much time, you must decouple the computation from delivering the result. This is done with just a few steps, as follows:</p>
			<ol>
				<li>Provide the result as an observable property.</li>
				<li>Compute the result using a coroutine or a Kotlin flow.</li>
				<li>Once the computation is finished, update the <code>result</code> property.</li>
			</ol>
			<p>Here's a sample implementation taken from <code>DistancesViewMod<a id="_idTextAnchor129"/>el</code>:</p>
			<pre>private val _convertedDistance: MutableLiveData&lt;Float&gt;
                = MutableLiveData(Float.NaN)
val convertedDistance: LiveData&lt;Float&gt;
  get() = _convertedDistance
fun convert() {
  getDistanceAsFloat().let {
    viewModelScope.launch {
      _convertedDistance.value = if (!it.isNaN())
        if (_unit.value == R.string.meter)
          it * 0.00062137F
        else
          it / 0.00062137F
      else
        Float.NaN
    }
  }
}</pre>
			<p><code>viewModelScope</code> is available via an implementation dependency to <code>androidx.lifecycle:lifecycle-viewmodel-ktx</code> in the module-level <code>build.gradle</code> file. <code>convert()</code> spawns a coroutine, which will update the value of <code>_convertedDistance</code> once the computation is finished. Composable functions can observe changes by invoking <code>observeAsState()</code> on the <code>convertedDistance</code> public property. But how do you access <code>convertedDistance</code> and <code>convert()</code>? Here's a code <a id="_idIndexMarker281"/>snippet from <code>DistancesConverter.kt</code>:</p>
			<pre>val convertedValue by
        viewModel.<strong class="bold">convertedDistance</strong>.observeAsState()
val result by remember(convertedValue) {
  mutableStateOf(
    if (convertedValue?.isNaN() != false)
      ""
    else
      "$convertedValue ${
        if (unit.value == R.string.meter)
          strMile
        else strMeter
      }"
  )
}
val calc = {
  viewModel.<strong class="bold">convert()</strong>
}</pre>
			<p><code>result</code> receives the text to be output once a distance has been converted, so it should update itself whenever <code>convertedValue</code> changes. Therefore, I pass <code>convertedValue</code> as a key to <code>remember {}</code>. Whenever the key changes, the <code>mutableStateOf()</code> lambda expression is recomputed, so <code>result</code> gets updated. <code>calc</code> is invoked when the <code>convertedValue</code>.</p>
			<p>In this section, I have<a id="_idIndexMarker282"/> often used the term <em class="italic">computation</em>. Computation does not only mean arithmetic. Accessing databases, files, or web services may also consume considerable resources and be time-consuming. Such operations must be executed asynchronously. Please keep in mind that long-running tasks may not be part of the <code>ViewModel</code> itself but be invoked from it (for example, a repository). Consequently, such code must be fast too. My <code>Repository</code> implementation accesses the <code>Preferences</code> API synchronously for simplicity. Strictly speaking, even such basic operations should be asynchronous.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Jetpack DataStore allows you to store key-value pairs or typed objects with protocol buffers. It uses Kotlin coroutines and Flow to store data asynchronously. You can find more information about Jetpack DataStore<a id="_idIndexMarker283"/> at <a href="https://developer.android.com/topic/libraries/architecture/datastore">https://developer.android.com/topic/libraries/architecture/datastore</a>.</p>
			<p>This concludes our look at the communication between composable functions and <code>ViewModel</code> instances. In the next section, I will introduce you to composables that do not emit UI elements but cause side effects to run when a composition completes.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor130"/>Understanding side effects</h1>
			<p>In the <em class="italic">Using Scaffold() to structure your screen</em> section of <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>, I showed you how to display a snack bar using <code>rememberCoroutineScope {}</code> and <code>scaffoldState.snackbarHostState.showSnackbar()</code>. As <code>showSnackbar()</code> is a suspending function, it must be called from a coroutine or another suspending function. Therefore, we created and remembered <code>CoroutineScope</code> using <code>rememberCoroutineScope()</code> and invoked its <code>launch {}</code> function. </p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor131"/>Invoking suspending functions</h2>
			<p>The <code>LaunchedEffect()</code> composable is <a id="_idIndexMarker284"/>an alternative approach for spawning a suspending function. To see how it works, let's look at the <code>LaunchedEffectDemo()</code> composable. It belongs to the <code>EffectDemo</code> sample, as illustrated in the following screenshot: </p>
			<div><div><img src="img/B17505_07_01.jpg" alt="Figure 7.1 – The EffectDemo sample showing LaunchedEffectDemo()&#13;&#10;" width="1068" height="573"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – The EffectDemo sample showing LaunchedEffectDemo()</p>
			<p><code>LaunchedEffectDemo()</code> implements a counter. Once the <strong class="bold">Start</strong> button has been clicked, a counter is incremented every second. Clicking on <strong class="bold">Restart</strong> resets the counter. <strong class="bold">Stop</strong> terminates it. The code<a id="_idIndexMarker285"/> to achieve this is illustrated in the following snippet:</p>
			<pre>@Composable
fun LaunchedEffectDemo() {
   var clickCount by rememberSaveable { mutableStateOf(0) }
   var counter by rememberSaveable { mutableStateOf(0) }
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Row {
            Button(onClick = {
                clickCount += 1
            }) {
                Text(
                    text = if (clickCount == 0)
                      stringResource(id = R.string.start)
                    else
                      stringResource(id = R.string.restart)
                )
            }
            Spacer(modifier = Modifier.width(8.dp))
            Button(enabled = clickCount &gt; 0,
                onClick = {
                    clickCount = 0
                }) {
                Text(text = stringResource(id =
                              R.string.stop))
            }
            if (clickCount &gt; 0) {
                <strong class="bold">LaunchedEffect(clickCount)</strong> {
                    counter = 0
<strong class="bold">                    while (isActive) {</strong>
<strong class="bold">                        counter += 1</strong>
<strong class="bold">                        delay(1000)</strong>
<strong class="bold">                    }</strong>
                }
            }
        }
        Text(
            text = "$counter",
            style = MaterialTheme.typography.h3
        )
    }
}</pre>
			<p><code>clickCount</code> counts how often <code>0</code>. A value greater than <code>0</code> indicates that another remembered variable (<code>counter</code>) should be increased every second. This is done by a suspending function that is passed to <code>LaunchedEffect()</code>. This composable is used to safely call suspend functions from inside a composable. Let's see how it works.</p>
			<p>When <code>LaunchedEffect()</code> enters the composition (<code>if (clickCount &gt; 0) …</code>), it launches a coroutine with the block of code passed as a parameter. The coroutine will be cancelled if <code>LaunchedEffect()</code> leaves the composition (<code>clickCount &lt;= 0</code>). Have you noticed that it receives one parameter? If <code>LaunchedEffect()</code> is recomposed with different keys (my example uses just one, but you can pass more if needed), the<a id="_idIndexMarker286"/> existing coroutine will be canceled and a new one is started.</p>
			<p>As you have seen, <code>LaunchedEffect()</code> makes it easy to start and restart asynchronous tasks. The corresponding coroutines are cleaned up automatically. But what if you need to do some additional housekeeping (such as unregistering listeners) when keys change or when the composable leaves the composition? Let's find out in the next section.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor132"/>Cleaning up with DisposableEffect()</h2>
			<p>The <code>DisposableEffect()</code> composable function runs code when its key changes. Additionally, you can pass a lambda expression for cleanup<a id="_idIndexMarker287"/> purposes. It will be executed when the <code>DisposableEffect()</code> function leaves the composition. The code is illustrated in the following snippet:</p>
			<pre>DisposableEffect(clickCount) {
  println("init: clickCount is $clickCount")
  onDispose {
    println("dispose: clickCount is $clickCount")
  }
}</pre>
			<p>A message starting with <code>init:</code> will be printed each time <code>clickCount</code> changes (that is, when <code>dispose:</code> will appear when <code>clickCount</code> changes or when <code>DisposableEffect()</code> leaves the composition.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><code>DisposableEffect()</code> <em class="italic">must</em> include an <code>onDispose {}</code> clause as the final statement in its block.</p>
			<p>I have given you two<a id="_idIndexMarker288"/> hands-on examples that use side effects in a Compose app. The <code>Effect</code> APIs contain several other useful composables—for example, you can use <code>SideEffect()</code> to publish Compose state to non-Compose parts of your app, and <code>produceState()</code> allows you to convert non-Compose state into <code>State</code> instances.</p>
			<p>You can find additional information about the <code>Effect</code> APIs<a id="_idIndexMarker289"/> at <a href="https://developer.android.com/jetpack/compose/side-effects">https://developer.android.com/jetpack/compose/side-effects</a>.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor133"/>Summary</h1>
			<p>This chapter covered additional aspects of the <code>ComposeUnitConverter</code> example. We continued the exploration of the <code>ViewModel</code> pattern we began looking at in the <em class="italic">Using a ViewModel</em> section of <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>. This time, we added business logic to the <code>ViewModel</code> and injected an object that can persist and retrieve data.</p>
			<p>The <em class="italic">Keeping your composables responsive</em> section revisited one of the key requirements of a composable function. Recomposition can occur very often, therefore composables must be as fast as possible, which dictates what code inside them may and may not do. I showed you how a simple loop can cause a Compose app to stop responding, and how coroutines counteract this.</p>
			<p>In the final main section, <em class="italic">Understanding side effects</em>, we examined so-called side effects and used <code>LaunchedEffect</code> to implement a simple counter.</p>
			<p>In <a href="B17505_08_ePub.xhtml#_idTextAnchor135"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with Animations</em>, you will learn how to show and hide UI elements with animations. We will spice up transitions through visual effects and use animation to visualize state changes.</p>
		</div>
	</div></body></html>