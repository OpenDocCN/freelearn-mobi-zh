# <st c="0">9</st>

# <st c="1">使用Swift Charts创建动态图表</st>

**<st c="42">Swift Charts</st>** <st c="55">是苹果的一个框架，允许</st> <st c="91">我们以美丽和富有表现力的图表展示数据。</st> <st c="147">与图表一起工作不是一个次要的话题——数据是移动应用中的一个基本主题，展示洞察力和趋势的快速信息对于我们的应用</st> <st c="323">用户体验至关重要。</st>

<st c="339">在本章中，我们将涵盖以下主题：</st> <st c="375">以下内容：</st>

+   <st c="392">了解为什么我们需要在应用中使用图表</st> <st c="429">我们的应用中</st>

+   <st c="437">了解Swift</st> <st c="456">Charts框架</st>

+   <st c="472">创建条形图、折线图、饼图、面积图和</st> <st c="523">点图</st>

+   <st c="535">使用图表可视化函数</st> <st c="558">图表</st>

+   <st c="569">使用ChartProxy实现图表的</st> <st c="614">用户交互</st>

+   <st c="630">通过遵循</st> <st c="702">可绘制协议</st>允许不同数据类型与图表一起工作

<st c="720">在我们创建第一个图表之前，让我们了解图表为什么很重要以及它们带来了什么价值。</st>

# <st c="823">技术要求</st>

<st c="846">对于本章，您必须从苹果的</st> <st c="924">App Store</st>下载Xcode版本15.0或更高版本。</st>

<st c="934">您还需要运行最新的macOS版本（Ventura或更高版本）。</st> <st c="1007">只需在App Store中搜索Xcode，选择并下载最新版本。</st> <st c="1092">启动Xcode，并遵循系统可能提示的任何其他安装说明。</st> <st c="1195">一旦Xcode完全启动，您就准备好</st> <st c="1239">开始了。</st>

<st c="1245">从以下GitHub</st> <st c="1297">链接</st>下载示例代码：[<st c="1303">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm)

# <st c="1402">为什么需要图表？</st>

<st c="1414">以下内容可能不是</st> <st c="1448">特定于移动端的章节，但仍然非常重要。</st> <st c="1509">许多应用以文本方式显示有用的信息，例如表格、列表或网格。</st> <st c="1598">虽然以列表或网格的形式显示信息可能有益，但用这种方式讲述故事要困难得多。</st>

<st c="1710">用户有时难以处理信息的文本表示，而将其可视化可能有助于他们获得有趣的见解并做出决策。</st> <st c="1867">可能会有不同类型的见解，这些见解可以是数据点之间的关系、趋势和</st> <st c="1971">重复的模式。</st>

<st c="1989">由于屏幕尺寸和信息在网格中展示的挑战，数据在手机上可能更难消化。</st> <st c="2127">然而，屏幕尺寸并不是手机唯一的挑战——用户通常期望快速了解数据洞察，而不是分析电子表格。</st> <st c="2273">移动用户体验与桌面体验不同，因为它们有不同的用例和行为。</st> <st c="2370">由于这种差异，图表在移动应用中的价值甚至比在桌面应用中更大，因为它们提供了一种以视觉方式展示信息的方法。</st> <st c="2490">信息。</st>

<st c="2511">尽管如此，避免过度使用图表或在图表比表格或列表更有意义的地方使用图表是至关重要的。</st> <st c="2627">例如，一个显示用户最新交易的银行应用会使用列表而不是图表。</st> <st c="2734">列表是一种以可扫描的格式展示原始数据的好方法，它既交互性强，又允许用户执行操作或查看更多细节。</st> <st c="2867">更多信息。</st>

<st c="2880">正如我们已经有列表、表格和集合视图一样，我们现在有了 Swift Charts，这是一个专门用于以信息丰富、可视化方式展示数据的框架。</st> <st c="3020">方式。</st>

# <st c="3035">介绍 Swift Charts 框架</st>

<st c="3074">创建简单易用的图表一直是一个挑战。</st> <st c="3115">与表格、集合视图或列表不同，大多数第三方图表框架</st> <st c="3223">从未在</st> **<st c="3246">UIKit/SwiftUI</st>**<st c="3259">中感觉自然。</st>

<st c="3260">在 iOS 16 中，苹果公司宣布了 Swift Charts，这是一个 SwiftUI 框架，它以图表的形式展示结构化数据，并且非常适合在 SwiftUI 视图中使用。</st> <st c="3371">很好地</st> <st c="3384">适应了 SwiftUI 视图。</st>

<st c="3397">让我们看看一个</st> <st c="3424">条形图</st> <st c="3429">的例子：</st>

[PRE0]

<st c="3821">尽管代码示例看起来很长，但它简单易读易懂。</st> <st c="3900">此示例显示了一个</st> `<st c="3924">BarMark</st>` <st c="3931">图表，展示了不同水果的销售数据。</st> <st c="3982">它有一个</st> `<st c="3991">Sales</st>` <st c="3996">结构，包含特定水果类型的单一销售信息，以及一个</st> `<st c="4080">data</st>` <st c="4084">数组，包含关于几种</st> <st c="4137">水果类型的销售信息。</st>

<st c="4149">在 SwiftUI 的主体部分，我们添加了一个名为</st> <st c="4193">`<st c="4201">Chart</st>` <st c="4206">`的新视图，并将</st> `<st c="4216">data</st>` <st c="4220">数组作为参数。</st> <st c="4243">在那个</st> `<st c="4255">Chart</st>` <st c="4260">视图中，我们添加了一个</st> `<st c="4276">BarMark</st>` <st c="4283">视图——一种以条形展示数据信息的方式——传递来自我们</st> `<st c="4371">Sales</st>` <st c="4376">结构体的</st> `<st c="4347">x</st>` <st c="4348">和</st> `<st c="4353">y</st>` <st c="4354">值。</st>

*<st c="4384">图9</st>**<st c="4393">.1</st>* <st c="4395">显示了结果：</st>

![图9.1：条形标记图表](img/B21795_09_1.jpg)

<st c="4422">图9.1：条形标记图表</st>

*<st c="4449">图9</st>**<st c="4458">.1</st>* 显示了我们的代码结果——一个包含图例和标题的三个红色条形图视图。<st c="4542">我们可以看到创建图表有多容易，就像我们创建</st> `<st c="4625">列表</st>` <st c="4629">或</st> `<st c="4635">垂直堆叠</st>` <st c="4641">视图</st>一样。

<st c="4647">让我们探索和学习如何创建不同的图表类型，并了解</st> <st c="4727">它们的用法。</st>

# <st c="4739">创建图表</st>

<st c="4755">在我们继续之前，让我们了解</st> <st c="4792">Swift Charts框架中图表的视图结构。</st> <st c="4854">正如我们从最后一个代码示例中可以看到的，图表视图被称为</st> `<st c="4921">Chart</st>`<st c="4926">：</st>

[PRE1]

<st c="5014">图表中的每个数据点</st> <st c="5030">被称为</st> `<st c="5138">条形标记</st>` <st c="5145">类型。</st> <st c="5152">如果图表接收一个数组作为参数，它会在幕后执行一个</st> `<st c="5213">ForEach</st>` <st c="5220">循环并创建</st> <st c="5253">几个标记。</st>

<st c="5267">实际上，我们可以编写与以下相同的代码：</st> <st c="5309">：</st>

[PRE2]

<st c="5441">在这个代码示例中，我们使用之前相同的数据数组，使用一个</st> `<st c="5522">ForEach</st>` <st c="5529">循环迭代它，并为每个数组项创建一个</st> `<st c="5549">条形标记</st>` <st c="5556">视图。</st> <st c="5583">这个例子对于理解图表是如何构建的至关重要，这样我们就可以在未来自定义和配置</st> <st c="5678">它们。</st>

<st c="5698">现在，让我们进一步探索</st> `<st c="5722">条形标记</st>` <st c="5729">图表</st> <st c="5736">。</st>

## <st c="5749">创建条形标记图表</st>

<st c="5772">我们可以使用基于</st> `<st c="5786">条形标记</st>`<st c="5793">的图表</st> <st c="5806">来比较不同的数据点，例如销售额和各国人口规模。</st> <st c="5893">我们看到了创建具有多个条形标记的图表是多么简单。</st>

<st c="5955">然而，使用条形标记视图创建图表的工作还没有结束。</st> <st c="6023">我们还有更多选项来扩展这个标记，以提供更多信息。</st>

<st c="6097">我们将从一个堆叠的条形图开始。</st>

### <st c="6135">添加堆叠标记</st>

<st c="6156">标准标记代表二维数据点，比较一个值与另一个值。</st> <st c="6202">有时，数据集可能有一个更深层的故事，因为每个条形可能由几个值组成。</st>

例如，让我们拿我们刚刚创建的销售图表来讨论苹果的销售情况。</st> <st c="6434">苹果销售当前值为50件。</st> <st c="6480">也许我们想展示这个值是如何在绿色和红色苹果之间分配的。</st> <st c="6563">在这种情况下，我们可以使用</st> <st c="6590">堆叠标记。</st>

<st c="6603">现在，我们将向我们的</st> <st c="6641">现有图表</st> 添加一个堆叠条形图。

<st c="6656">首先，我们需要调整</st> <st c="6681">我们的</st> `<st c="6686">Sales</st>` <st c="6691">结构以包含我们的</st> <st c="6717">fruit color：</st>

[PRE3]

<st c="6845">现在，我们已经向</st> `<st c="6870">fruitColor</st>` <st c="6880">属性添加到</st> `<st c="6897">Sales</st>` <st c="6902">结构中，我们可以更新</st> <st c="6928">我们的数据集：</st>

[PRE4]

<st c="7153">目前，我们的更新后的数据集</st> <st c="7184">有两个与苹果销售相关的记录，每个记录都包含</st> <st c="7245">销售的颜色。</st>

<st c="7256">现在我们已经有了所有需要的数据，让我们创建一个图表并将每个属性分配给图表中的正确角色：</st>

[PRE5]

<st c="7523">在这个代码示例中，我们唯一的不同之处在于</st> `<st c="7580">foregroundStyle</st>` <st c="7595">视图修改器，它有助于区分不同的水果颜色。</st> <st c="7671">让我们看看</st> *<st c="7695">图9</st>**<st c="7703">.2</st>*<st c="7705">的结果。</st>

![图9.2：堆叠条形图视图](img/B21795_09_2.jpg)

<st c="7712">图9.2：堆叠条形图视图</st>

<st c="7740">在</st> *<st c="7744">图9</st>**<st c="7752">.2</st>*<st c="7754">中，我们可以看到苹果条形图是由两种类型的值构建的。</st> <st c="7822">蓝色代表绿色苹果，绿色代表</st> <st c="7881">红色苹果。</st>

<st c="7892">我们看到了当我们添加具有相同</st> <st c="7930">x</st> <st c="7945">值的几个标记时，图表框架知道如何将它们堆叠在一起。</st>

<st c="8009">接下来，让我们看看当我们没有向我们的</st> *<st c="8057">y</st>* <st c="8058">值添加数据时会发生什么。</st>

### <st c="8082">添加一维条形标记</st>

<st c="8102">大多数图表都是二维的，这意味着</st> <st c="8143">它们有一个</st> *<st c="8157">x</st>* <st c="8158">和</st> *<st c="8163">y</st>* <st c="8164">轴，用于比较不同的数据类别。</st> <st c="8211">然而，我们可以专注于一个类别（这意味着图表将只有一个</st> *<st c="8287">y</st>* <st c="8288">轴值）并创建一个</st> <st c="8314">一维图表。</st>

<st c="8336">例如，让我们从上一个例子中的苹果类别开始，并尝试基于它创建一个一维条形图。</st> <st c="8440">。</st>

<st c="8446">首先，让我们丰富我们的数据，并添加</st> `<st c="8484">黄色</st>` <st c="8490">作为额外的</st> <st c="8508">水果颜色：</st>

[PRE6]

<st c="8714">我们的数据集现在包括</st> <st c="8738">的</st> `<st c="8743">绿色</st>`<st c="8748">、</st> `<st c="8750">红色</st>`<st c="8753">，和</st> `<st c="8759">黄色</st>` <st c="8765">水果</st> <st c="8771">颜色。</st>

<st c="8779">接下来，让我们创建我们的图表，但这次，我们不会定义</st> <st c="8841">的</st> *<st c="8845">y</st>*<st c="8846">-轴：</st>

[PRE7]

<st c="8957">在这个代码示例中，我们只传递了</st> `<st c="8999">x</st>` `<st c="9000">BarMark</st>` <st c="9007">参数。</st> <st c="9019">然而，如果我们检查</st> `<st c="9046">BarMark</st>` <st c="9053">标题，我们可以看到有一个只需要</st> `<st c="9118">x</st>` <st c="9119">参数的方法：</st>

[PRE8]

Chart(data) {

                BarMark(

                    x: .value("Qty", $0.qty)

                )

                .foregroundStyle(by: .value("Color",

                $0.fruitColor))

            } <st c="10118">.chartForegroundStyleScale(["Green" :</st>

<st c="10155">Color.green, "Red" : Color.red,</st>

<st c="10218">chartForegroundStyleScale</st>函数是一个我们可以应用于Chart和不同<st c="10312">ShapeStyle</st>协议的视图修改器。在这种情况下，我们使用反映水果颜色的颜色并提高清晰度。

            *<st c="10431">图9</st>**<st c="10440">.4</st>* <st c="10442">显示了如何将颜色匹配到</st> <st c="10503">名称后图表的外观：</st>

            ![图9.4：具有自定义颜色的1D图表](img/B21795_09_4.jpg)

            <st c="10547">图9.4：具有自定义颜色的1D图表</st>

            <st c="10588">我们可以使用</st> `<st c="10600">chartForegroundStyleScale</st>` <st c="10625">不仅适用于1D图表，也适用于所有其他类型的</st> <st c="10678">图表。</st>

            <st c="10688">我们看到了如何</st> <st c="10699">使用BarMarks</st> <st c="10715">进行堆叠和一维标记。</st> <st c="10755">另一种我们可以使用BarMarks的方法是用于区间</st> <st c="10807">条形图。</st>

            <st c="10818">添加区间条形图</st>

            <st c="10845">我们使用</st> **<st c="10853">区间条形图</st>** <st c="10872">来表示按区间分组的数据，例如</st> <st c="10898">时期、年龄组、或</st> <st c="10920">数值范围。</st>

            <st c="10965">例如，假设我们想显示一份工人及其在一天中工作的时间间隔的列表。</st>

            <st c="11080">首先，让我们创建一个表示一系列</st> <st c="11138">工作时段的数据集：</st>

[PRE9]

            <st c="11610">数据</st> `<st c="11628">数组中的每个项目</st>` <st c="11632">代表一名员工的工时。</st> <st c="11681">请注意，我们并不关心项目的顺序——Charts框架负责正确地排序它们。</st> <st c="11795">然而，我们关心与员工姓名的一致性，因此Charts框架也可以正确地</st> <st c="11904">分组</st> <st c="11905">这些项目。</st>

            <st c="11914">让我们看看我们如何基于</st> <st c="11941">那个数据集</st> <st c="11965">构建</st> <st c="11969">一个区间图表：</st>

[PRE10]

            <st c="12114">在这个代码示例中，我们创建了一个包含新参数的BarMark初始化器——</st>`<st c="12198">xStart</st>`<st c="12205">，它表示区间开始的价值，</st> `<st c="12261">xEnd</st>`<st c="12265">，详细说明它结束的位置，以及</st> `<st c="12296">y</st>`<st c="12297">，员工的姓名。</st>

            <st c="12319">现在，让我们看看当我们运行它时区间图表看起来像什么（</st>*<st c="12379">图9</st>**<st c="12388">.5</st>*<st c="12390">）：</st>

            ![图9.5：一个区间图表](img/B21795_09_5.jpg)

            <st c="12444">图9.5：一个区间图表</st>

            <st c="12473">在</st> *<st c="12477">图9</st>**<st c="12485">.5</st>*<st c="12487">中，我们可以看到一个时间线，其中每个员工都代表一行，他们的工作周期是这个时间线中的</st><st c="12600">区间。</st> <st c="12622">区间条形图是一个复杂的组件的例子，从头开始构建可能很复杂，而Charts框架可以简化</st> <st c="12771">这个过程。</st>

            <st c="12783">BarMark看起来是一个非常灵活的图表类型，这也是它如此常见的原因之一。</st> <st c="12878">它允许我们展示不同类型的信息，无论是比较值还是随时间变化的不同趋势，在堆叠、一维或</st> <st c="13019">区间布局中。</st>

            <st c="13036">然而，有时，选择一个更具体的图表</st> <st c="13077">来更精确地表达数据</st> <st c="13107">可能是一个更好的选择。</st>

            <st c="13143">所以，让我</st><st c="13156">们设置</st> <st c="13164">LineMark图表。</st>

            <st c="13179">创建LineMark图表</st>

            <st c="13204">在表格中展示数据的一个挑战是展示趋势和模式。</st> <st c="13245">尽管BarMark图表类型比表格做得更好，但还有更好的方法来展示趋势，尤其是在处理大量</st> <st c="13439">信息时。</st>

            <st c="13454">为了更有效地展示趋势和模式，我们可以使用LineMark图表，它使用表示一系列</st> <st c="13590">数据点的线来表示数据。</st>

            <st c="13602">让我们以一个显示随时间变化的手机销售图表为例。</st> <st c="13670">我们创建了一个名为</st> `<st c="13698">SalesFigure</st>` <st c="13709">的结构</st>，其中包含有关产品类型、销售日期和</st> <st c="13790">总金额的信息：</st>

[PRE11]

            <st c="13915">现在我们有了结构，让我们创建</st> <st c="13958">我们的数据集，就像我们在所有</st> <st c="13990">之前的示例中所做的那样：</st>

[PRE12]

            <st c="14450">`salesFigures`</st> <st c="14455">变量包含有关四天销售的信息。</st> <st c="14467">LineMark图表适合处理多个条目，但我们只使用四个进行</st> <st c="14611">演示目的。</st>

            <st c="14634">现在，让我们使用</st> `<st c="14658">salesFigures</st>` <st c="14670">变量通过</st> `<st c="14701">LinkMark</st>` <st c="14709">视图连接到一个图表：</st>

[PRE13]

            <st c="14809">我们在图表内创建了一个LineMark，将日期设置为</st> *<st c="14872">x</st>* <st c="14873">轴，数量设置为</st> *<st c="14901">y</st>* <st c="14902">轴。</st> <st c="14909">运行此代码应显示一个类似于</st> *<st c="14966">图9</st>**<st c="14974">.6</st>*<st c="14976">:</st>

            ![图9.6：一个LineMark图表](img/B21795_09_6.jpg)

            <st c="15010">图9.6：一个LineMark图表</st>

            <st c="15038">图</st> *<st c="15052">9</st>**<st c="15060">.6</st>* <st c="15062">显示了数据集期间手机销售的下降趋势。</st> <st c="15129">关于折线图的好处是，它很容易比较一个LineMark与另一个。</st> <st c="15213">我们只需要更新我们的数据集。</st> <st c="15257">因此，让我们也添加平板电脑销售以与</st> <st c="15308">手机销售进行比较：</st>

[PRE14]

            <st c="15771">在这个代码示例中，我们通过向数组中添加平板电脑销售数据项来更新</st> <st c="15804">我们的数据集。</st>

            <st c="15866">为了使图表在两种产品类型之间区分开来，我们使用</st> `<st c="15936">foregroundStyle</st>` <st c="15951">视图修饰符：</st>

[PRE15]

let data: [最喜欢的水果] = [

        最喜欢的水果（名称："Apple"，价值：30）,

        最喜欢的水果（名称："Banana"，价值：25）,

        最喜欢的水果（名称："Orange"，价值：20）,

        最喜欢的水果（名称："Strawberries"，价值：15）,

        最喜欢的水果（名称："Grapes"，价值：10）

    ]

[PRE16]

图表（数据）{item in <st c="18384">扇形标记（角度：.value("Value", item.value))</st> .foregroundStyle(by: .value("Fruit",

                    item.name))

        }

[PRE17]

图表（数据）{item in

    扇形标记（角度：.value("Value", item.value)，<st c="19020">内半径：50</st>）

    .foregroundStyle(by: .value("Fruit", item.name))

}

[PRE18]

图表（销售数据）{ data in <st c="20522">AreaMark</st>(

                x: .value("Date", data.day),

                y: .value("Sales", data.amount)

            )

            .foregroundStyle(by: .value("Product",

            data.product))

        }

[PRE19]

struct StudentData: Identifiable {

    var id: UUID = UUID()

    var hoursStudied: Double

    var examScore: Double

}

let studentDataSet: [StudentData] = [

    学生数据（学习时长：1.7小时，考试成绩：61.8分）,

    学生数据（学习时长：7.9小时，考试成绩：78.6分）,

    学生数据（学习时长：4.1小时，考试成绩：44.3分）,

    学生数据（学习时长：4.7小时，考试成绩：63.4分）,

    学生数据（学习时长：7.8小时，考试成绩：90.4分）,

    学生数据（学习时长：8.6小时，考试成绩：83.2分）,

    学生数据（学习时长：2.8小时，考试成绩：29.7分）,

    学生数据（学习时长：6.3小时，考试成绩：72.9分）,

    学生数据（学习时长：6.4小时，考试成绩：73.8分）,

    `)`

`<st c="28753">chartOverlay</st> view modifier in this code example.` 

[PRE20]

`<st c="29988">图 9.14：图表和 chartOverlay 结构</st>`

`<st c="23025">y: .value("score", $0.examScore))</st>` }

[PRE21]

`}`

        `return sin(x)`

    `Chart { <st c="25162">AreaPlot</st>(x:"x", y:"y") { x in`

`Chart(studentDataSet) { <st c="22979">PointMark(x: .value("hours", $0.hoursStudied),`

[PRE22]

`y: .value("amount", $0.amount)`

        `return sin(x)`

    `.foregroundStyle(by: .value("Product",`

`}`

[PRE23]

`Chart(salesFigures){}`

            `<st c="29629">我们将根据用户的</st>` `<st c="29680">点击位置</st>` 

                `x: .value("time", $0.day),`

                `]`

            `}`

            `<st c="28801">我们可以看到</st>` `<st c="28818">chartOverlay</st>` `<st c="28830">附带了一个</st>` `<st c="28844">代理</st>` `<st c="28849">变量，它就是之前讨论过的</st>` `<st c="28873">ChartProxy</st>` `<st c="28883">组件。</st>`

            `$0.product))`

        `<st c="28644">.chartOverlay { proxy in`

`StudentData(hoursStudied: 6.1, examScore: 77.6)`

            `LineMark(`

            `<st c="28915">ChartOverlay</st>` `<st c="28928">不是一个视图，而是一个视图修饰符，它允许我们在图表中添加新的视图。</st>` `<st c="29004">因此，为了识别手势并添加一个仪表，我们可以添加一个带有拖动手势的透明视图，并添加一个</st>` `<st c="29107">仪表视图：</st>`

[PRE24]

            `Chart { <st c="24633">LinePlot</st>(x:"x", y:"y") { x in`

[PRE25]

            `![图 9.14：图表和 chartOverlay 结构](img/B21795_09_14.jpg)`

            `<st c="29420">在这个代码示例中，我们添加了一个</st>` `<st c="29454">ZStack</st>` `<st c="29460">视图，它有一个清晰的矩形覆盖整个图表，在其上方是一个红色的仪表视图。</st>` `<st c="29554">仪表视图</st>` `<st c="29569">x</st>` `<st c="29570">轴是一个</st>` `<st c="29581">状态变量：</st>`

            `<st c="29924">要查看我们的视图结构，请看</st>` `<st c="29960">图</st>**<st c="29968">9</st>**<st c="29971">.14</st>` `<st c="29971">：</st>`

            `<st c="30310">响应用户的手势</st>`

            `}`

            `<st c="30034">图</st>**<st c="30043">9</st>**<st c="30046">.14</st>` `<st c="30046">显示了我们的图表视图和通过</st>` `<st c="30105">chartOverlay</st>` `<st c="30117">视图修饰符添加的矩形。</st>` `<st c="30133">我们还可以看到它们是通过</st>` `<st c="30183">代理对象连接的。</st>`

            `<st c="30196">此外，我们还添加了</st>` `<st c="30211">一个拖动手势</st>` `<st c="30226">到矩形上。</st>` `<st c="30245">让我们看看如何使用它来相应地改变我们的仪表</st>` `<st c="30289">位置。</st>`

            `<st c="29694">注意，我们使用了我们的</st>` `<st c="29719">代理</st>` `<st c="29724">对象来确定</st>` `<st c="29744">仪表视图的图表大小。</st>` `<st c="29780">这是一个关键的代理</st>` `<st c="29801">使用，因为我们还需要在其他场合使用它，例如在特定位置显示不同视图的计算。</st>`

            `<st c="30343">为了响应用户的手势</st>` `<st c="30376">并将水平仪表移动到最接近的数据点，我们需要实现</st>` `<st c="30459">onChanged</st>` `<st c="30468">闭包：</st>`

[PRE26]

            <st c="30689">The</st> `<st c="30694">onChanged</st>` <st c="30703">closure implementation does</st> <st c="30732">three things:</st>

                +   <st c="30745">首先，它</st> *<st c="30756">根据点击位置和代理找到最近的销售额数据点</st>* <st c="30790">。 <st c="30836">我们将在一分钟内介绍</st> `<st c="30856">getClosestDateForLocation</st>` <st c="30881">函数。</st>

                +   <st c="30903">在我们根据点击位置找到最近的销售数据点后，我们使用代理对象来</st> *<st c="31007">检索它在图表上的位置</st>* <st c="31028">。 <st c="31043">代理的一个功能是将数据点转换为位置，反之亦然。</st>

                +   <st c="31128">当我们获得最近的数据点位置时，我们通过设置</st> `<st c="31226">markerX</st>` <st c="31233">状态变量</st>来调整尺子位置。

            <st c="31249">这段代码是使用代理对象可以做什么的一个很好的</st> <st c="31278">示例。</st>

            <st c="31333">有关代理对象的使用，让我们看看</st> `<st c="31377">getClosestDateForLocation</st>` <st c="31402">函数。</st>

            <st c="31412">找到用户触摸点最近的数据点</st>

            <st c="31463">`<st c="31468">getClosestDateForLocation</st>` <st c="31493">`函数的目标是</st> <st c="31507">根据一个特定的位置找到最近的数据点。</st> <st c="31569">`根据一个特定的位置找到最近的数据点。</st>

            <st c="31587">该函数接收两个参数 - 位置（</st>`<st c="31641">CGFloat</st>`<st c="31649">）和</st> <st c="31660">代理对象：</st>

[PRE27]

            <st c="32079">记住我们的图表看起来像什么 -</st> *<st c="32121">y</st>* <st c="32122">轴代表时间线，而</st> *<st c="32161">x</st>* <st c="32162">轴代表特定日期的总销售额。</st>

            <st c="32214">因此，我们可以使用代理对象来找到特定</st> `<st c="32279">x</st>` <st c="32280">值的日期，这是我们</st> <st c="32303">的第一步：</st>

[PRE28]

            <st c="32359">代理的</st> `<st c="32371">value(atX:)</st>` <st c="32382">函数计算特定</st> `<st c="32433">x</st>` <st c="32434">值的日期值。</st>

            <st c="32441">然而，返回的值是任意的；为了定位最近的数据点，我们必须遍历我们的数据集并搜索最近的</st> `<st c="32581">SalesFigure</st>` <st c="32592">对象。</st> <st c="32601">一旦确定，函数就可以返回它。</st>

            <st c="32650">尽管允许用户与图表交互并不复杂，但它包括一些有趣的视图修改器和对象，使我们能够访问图表数据，执行计算，并显示叠加 UI 组件。</st> <st c="32866">我们不必仅仅为了交互而使用</st> `<st c="32891">代理</st>` <st c="32896">对象和</st> `<st c="32912">chartOverlay</st>` <st c="32924">视图修改器——我们可以显示更多信息，改进图表设计，在罕见的情况下，甚至可以</st> <st c="33054">创建自己的图表。</st>

            <st c="33064">到目前为止，我们使用的是具有基础类型的数据集 –</st> `<st c="33118">String</st>`<st c="33124">,</st> `<st c="33126">Double</st>`<st c="33132">, 和</st> `<st c="33138">Date</st>`<st c="33142">。然而，当我们查看 Swift Charts 框架的头文件时，我们发现</st> <st c="33212">一些有趣的东西：</st>

[PRE29]

            <st c="33415">似乎不同的图表函数</st> <st c="33458">只与符合</st> `<st c="33500">Plottable</st>` <st c="33509">协议的类型一起工作。</st> <st c="33520">让我们来看看</st> <st c="33540">那是什么。</st>

            <st c="33548">符合 Plottable 协议</st>

            <st c="33585">到目前为止，我们一直假设</st> <st c="33630">我们抛到图表上的任何数据集都会工作。</st> <st c="33684">然而，我们发现代理对象可以执行一些有趣的计算，而这些计算用任何数据都是不可能完成的，这也是我们数据类型需要支持在</st> <st c="33885">图表中绘制能力的原因之一。</st>

            <st c="33893">因此，Swift Charts 框架只与符合</st> `<st c="33979">Plottable</st>` <st c="33988">协议的数据类型一起工作，这允许数据在</st> <st c="34032">图表中绘制。</st>

            <st c="34040">首先，每个原始数据类型已经符合</st> `<st c="34098">Plottable</st>` <st c="34107">协议。</st> <st c="34118">此外，我们在上一个示例中使用的</st> `<st c="34128">Date</st>` <st c="34132">类也符合</st> `<st c="34188">Plottable</st>` <st c="34197">协议。</st> <st c="34208">我们甚至可以在苹果</st> <st c="34242">头文件中看到这一点：</st>

[PRE30]

            <st c="34367">然而，仅与原始类型或 Foundation 类型一起工作并不</st> <st c="34432">总是实用。</st>

            <st c="34449">以，例如，我们的</st> `<st c="34479">Sales</st>` <st c="34484">结构体</st> 从 *<st c="34504">Adding Stacked</st>* *<st c="34519">Marks</st>* <st c="34524">部分：</st>

[PRE31]

            <st c="34648">将</st> `<st c="34662">itemType</st>` <st c="34670">属性声明为字符串</st> <st c="34691">并不总是最佳实践。</st> <st c="34723">通常，类型是封闭列表的一部分，使用字符串可能会导致拼写错误和重复。</st> <st c="34819">我们可能更愿意使用枚举，因为它</st> <st c="34872">更适合处理类型列表：</st>

[PRE32]

            <st c="35098">在这个例子中，我们创建了一个</st> `<st c="35129">FruitType</st>` <st c="35138">枚举来替换来自 `<st c="35178">String</st>` 的</st> `<st c="35159">itemType</st>` <st c="35167">类型。</st>

            <st c="35185">我们的下一步是使</st> `<st c="35215">FruitType</st>` <st c="35224">枚举符合</st> `<st c="35241">Plottable</st>`<st c="35250">:</st>

[PRE33]

            <st c="35332">在这个例子中，我们使用了</st> `<st c="35362">primitivePlottable</st>` <st c="35380">变量获取器来返回类型的原始值。</st> <st c="35435">这将使</st> `<st c="35455">FruitType</st>` <st c="35464">类型有资格在 Charts 中使用。</st>

            <st c="35504">尽管不是每种类型都可以在图表中使用，但我们可以轻松地使它们有资格。</st> <st c="35543">遵守</st> `<st c="35621">Plottable</st>` <st c="35630">协议既简单又直接，并允许我们在图表中使用自定义类型。</st> <st c="35713">这样，我们就可以在我们的图表中使用几乎任何我们想要的数据类型。</st>

            <st c="35727">总结</st>

            <st c="35735">Swift Charts 框架非常令人兴奋。</st> <st c="35776">它允许我们使用简单的数据集创建令人惊叹的图表，这使得展示数据洞察、趋势和比较变得容易得多。</st>

            <st c="35919">本章回顾了 Swift Charts 框架的不同图表类型，包括 BarMark、LineMark、SectorMark、AreaMark 和 PointMark。</st>

            <st c="36064">我们还讨论了每个图表的不同用途和目标，学习了如何自定义它们，并添加了用户交互以增加更多功能。</st> <st c="36207">最后，我们回顾了</st> `<st c="36233">Plottable</st>` <st c="36242">协议，它允许我们的图表使用几乎任何我们想要的数据类型。</st> <st c="36314">到目前为止，我们应该能够快速在我们的</st> <st c="36367">应用中实现图表。</st>

            <st c="36380">我们的下一章包括一个高级但非常强大的主题——</st> <st c="36445">Swift 宏。</st>

[PRE34]

[PRE35]

# <st c="0">第二部分：使用高级技术完善你的 iOS 开发</st>

<st c="61">在本部分，你将提升你的 iOS 开发技能，并探索高级主题，如 Swift 宏、测试、Combine、架构、**<st c="198">机器学习</st>**（**<st c="216">ML</st>**<st c="218">）和 AI。</st> <st c="230">如果你想要充分利用 iOS 18，这部分内容是必读的。</st>

<st c="295">本节包含以下章节：</st>

+   [*<st c="341">第 10 章</st>*](B21795_10.xhtml#_idTextAnchor329)<st c="352">，*<st c="354">Swift 宏</st>* 

+   [*<st c="367">第 11 章</st>*](B21795_11.xhtml#_idTextAnchor346)<st c="377">，*<st c="379">使用 Combine 创建管道</st>* 

+   [*<st c="411">第 12 章</st>*](B21795_12.xhtml#_idTextAnchor369)<st c="421">，*<st c="423">利用 Apple 智能和 ML 变得聪明</st>* 

+   [*<st c="466">第13章</st>*](B21795_13.xhtml#_idTextAnchor401)<st c="476">,</st> *<st c="478">通过应用意图将您的应用暴露给Siri</st>*

+   [*<st c="521">第14章</st>*](B21795_14.xhtml#_idTextAnchor430)<st c="531">,</st> *<st c="533">使用Swift测试提高应用质量</st>*

+   [*<st c="577">第15章</st>*](B21795_15.xhtml#_idTextAnchor463)<st c="588">,</st> *<st c="590">探索iOS架构</st>*
