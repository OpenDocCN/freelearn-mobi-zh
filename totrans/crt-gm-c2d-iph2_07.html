<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Playing Pool, Old School</h1></div></div></div><p>In this chapter we will be developing another project using the Box2D physics engine. Our emphasis in this chapter will be on how to easily implement multiple control methods, as well as alternate rule sets.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using sensors</li><li class="listitem" style="list-style-type: disc">Implementing multiple control schemes</li><li class="listitem" style="list-style-type: disc">Designing a rules engine</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>The game is…</h1></div></div></div><p>Our game in this chapter is an old-school, <a id="id1575" class="indexterm"/>
<a id="id1576" class="indexterm"/>top-down pool game. While our goal is to have suitably realistic movements, our emphasis will be on a fun arcade-style game. The main reason for this is it is impossible to accurately simulate the physics of a physical pool table without using a full 3D environment. Since we are working in 2D, we will not have features such as backspin, putting "English" on the ball, and so forth. We will also be using "bar room" variations on the games we implement. We have made this choice because there are literally hundreds of variations of each established game, so we are opting for "more fun" rather than "official rules". The game will be a pass-and-play two player game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Overall design</h1></div></div></div><p>To make a 2D pool game, there are really only a few objects we will need to render on the screen. The table will be made of the side rails and the pockets. <a id="id1577" class="indexterm"/>The rest of the table, as far as we are concerned, is just graphic fluff. Of course, we will need to build the 15 numbered pool balls and the cue ball. We will also need a cue stick, which we will create as a sprite but it will not be a body in the Box2D physics simulation. Why not? If we were to create the pool cue as a physics-enabled body, then we would have to consider the "unintended hits" of the pool cue running into other (non-cue ball) balls on the table. While this might happen on a real table, it is generally undesirable. Instead, we will use the pool cue as a visual "marker" of the planned shot, with the distance from the ball acting as our measure of the strength of the shot. Most of the interactions on the pool table will be handled by the Box2D simulation itself, so that will be the easy part.</p><p>We will focus more on the control mechanisms and the rules engine in this chapter. We will adopt two different touch-based control mechanisms, and <a id="id1578" class="indexterm"/>we will build a rules engine that can play "bar style" Eight Ball as well as Nine Ball. As we said in the introduction, we are using "bar rules" as a baseline approach. Feel free to extend the rules engine however you see fit to play pool your way.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Building the table</h1></div></div></div><p>Our first task at hand is to build the pool table. We will start by <a id="id1579" class="indexterm"/>looking at our definitions, because we will be using these extensively throughout this chapter:</p><p>
<strong>Filename:</strong> <a id="id1580" class="indexterm"/>
<a id="id1581" class="indexterm"/>
<code class="literal">OPDefinitions.h</code>
</p><div><pre class="programlisting">// Audio definitions
#define SND_BUTTON @"button.caf"

// Box2D definition
#define PTM_RATIO 32

// Define the pocket's tag
#define kPocket 500

typedef enum {
    kBallNone = -1,
    kBallCue = 0,
    kBallOne,
    kBallTwo,
    kBallThree,
    kBallFour,
    kBallFive,
    kBallSix,
    kBallSeven,
    kBallEight,
    kBallNine,
    kBallTen,
    kBallEleven,
    kBallTwelve,
    kBallThirteen,
    kBallFourteen,
    kBallFifteen
} BallID;

typedef enum {
    kRackTriangle = 50,
    kRackDiamond,
    kRackFailed
} RackLayoutType;


typedef enum {
    kStripes = 100,
    kSolids,
    kOrdered,
    kStripesVsSolids,
    kNone
} GameMode;</pre></div><p>You should be familiar with <code class="literal">typedef</code> <code class="literal">enum</code> statements <a id="id1582" class="indexterm"/>
<a id="id1583" class="indexterm"/>by now. We create the <code class="literal">BallID</code> type to represent the numbered balls for simplicity. To be able to easily convert from <code class="literal">NSInteger</code> values to <code class="literal">BallID</code> values, we set the numbered balls to equal the number on the balls. The cue is zero, and we also keep a reference for <code class="literal">kBallNone</code> as <code class="literal">-1</code> so we can cover our bases (useful when detecting a table scratch). We <a id="id1584" class="indexterm"/>define two types of <code class="literal">RackLayoutType</code>, <a id="id1585" class="indexterm"/>
<a id="id1586" class="indexterm"/>diamond and triangle. We also set our <code class="literal">GameMode</code> to be stripes, solids, ordered, or stripes versus solids. We use this last value to identify the game before anyone has pocketed any stripes or solids (also known as the table being "open"). We also have the <code class="literal">#define</code> statement to define the <code class="literal">kPocket</code> as <code class="literal">500</code>. <a id="id1587" class="indexterm"/>We will use this in our collision detection to determine when a ball hits a pocket. Finally, there is also the <code class="literal">PTM_RATIO</code>
<a id="id1588" class="indexterm"/>
<a id="id1589" class="indexterm"/>, which you should be familiar with from <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, <em>Brick Breaking Balls with Box2D</em>, which defines the Points-To-Meters ratio.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec91"/>The Box2D world</h2></div></div></div><p>With any Box2D simulation, we need to define a world for the <a id="id1590" class="indexterm"/>bodies to inhabit. (If you need to brush up on the Box2D world and the structures inside it, <a id="id1591" class="indexterm"/>please go back and re-read the <em>Box2D: a primer</em> section in <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, <em>Brick Breaking Balls with Box2D</em>.)</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) initWorld
{
  b2Vec2 gravity;
  gravity.Set(0.0f, 0.0f);
  world = new b2World(gravity);
  
  // Do we want to let bodies sleep?
  world-&gt;SetAllowSleeping(true);
  world-&gt;SetContinuousPhysics(true);
    
    // Create contact listener
    contactListener = new OPContactListener();
    world-&gt;SetContactListener(contactListener);
}</pre></div><p>As we did in <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, we define our world with zero gravity, since we do not want any downward force on our environment. We allow bodies to sleep, and we allow the continuous physics to run, which will increase the accuracy of the simulation. Finally, we establish a contact listener. For this game, we use a nearly identical contact listener to the one in <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, <em>Brick Breaking Balls with Box2D</em>. The only difference is we have changed the naming convention from BR… to OP… for all the elements in it. We will not repeat the code here, <a id="id1592" class="indexterm"/>so please feel free to refer to <a id="id1593" class="indexterm"/>that chapter or to the source code bundle for this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Building the rails</h2></div></div></div><p>The rails are one of the most interacted elements on the pool <a id="id1594" class="indexterm"/>table, so we will build them first. Since the physical properties of all six rails are the same, <a id="id1595" class="indexterm"/>we will build a single method to create a rail and pass parameters to that method to create each rail. We'll look at the "core code" first:</p><p>
<strong>Filename:</strong> <a id="id1596" class="indexterm"/>
<a id="id1597" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createRailWithImage:(NSString*)img atPos:(CGPoint)pos withVerts:(b2Vec2*)verts {
    // Create the rail
    PhysicsSprite *rail = [PhysicsSprite
                 spriteWithSpriteFrameName:img];
    [rail setPosition:pos];
    [poolsheet addChild: rail];
    
    // Create rail body
    b2BodyDef railBodyDef;
    railBodyDef.type = b2_staticBody;
    railBodyDef.position.Set(pos.x/PTM_RATIO, 
                             pos.y/PTM_RATIO);
    railBodyDef.userData = rail;
    b2Body *railBody = world-&gt;CreateBody(&amp;railBodyDef);
    
    // Store the body in the sprite
    [rail setPhysicsBody:railBody];
    
    // Build the fixture
    b2PolygonShape railShape;
    int num = 4;

    railShape.Set(verts, num);
    
    // Create the shape definition and add it to the body
    b2FixtureDef railShapeDef;
    railShapeDef.shape = &amp;railShape;
    railShapeDef.density = 50.0f;
    railShapeDef.friction = 0.3f;
    railShapeDef.restitution = 0.5f;
    railBody-&gt;CreateFixture(&amp;railShapeDef);  
}</pre></div><p>This method takes three arguments: the name of the sprite image, the position for the sprite and body, and an array of <code class="literal">verts</code> to define the shape of the rail. The rails are defined using the <a id="id1598" class="indexterm"/>
<a id="id1599" class="indexterm"/>
<code class="literal">PhysicsSprite</code> class, which we also saw in <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, <em>Brick Breaking Balls with Box2D</em>. A <code class="literal">PhysicsSprite</code> object, as you may recall, is like a normal <code class="literal">CCSprite</code>, except it holds a reference to the body attached to it. Cocos2d will automatically keep the sprite's <a id="id1600" class="indexterm"/>position and rotation in sync with the underlying Box2D body.</p><p>For the rails, we build the sprite using the passed image name, and then build the associated body. After the body is built, we attach the body to the sprite with the <code class="literal">setPhysicsBody</code> method. <a id="id1601" class="indexterm"/>
<a id="id1602" class="indexterm"/>Next, we define the shape for the rail. Because the rails are very simple shapes, we know that we only need four <code class="literal">verts</code> to define each rail. When we define the fixture, we set a pretty high density of <code class="literal">50.0f</code>, a moderate friction of <code class="literal">0.3f</code>, and an in-the-middle value for restitution of <code class="literal">0.5f</code>. These have been tweaked during play testing to give a good "bounciness" to the rails that feels more like a real table.</p><p>Now we can look at how we call this method to define the six rails for the table:</p><p>
<strong>Filename:</strong> <a id="id1603" class="indexterm"/>
<a id="id1604" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createRails {
    // Top left rail
    CGPoint railPos1 = ccp(58,338);
    b2Vec2 vert1[] = {
        b2Vec2(5.5f / PTM_RATIO, -84.0f / PTM_RATIO),
        b2Vec2(4.5f / PTM_RATIO, 80.0f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, 87.0f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, -87.0f / PTM_RATIO)
    };
    [self createRailWithImage:@"rail1.png" atPos:railPos1 withVerts:vert1];

    // Bottom left rail
    CGPoint railPos2 = ccp(58,142);
    b2Vec2 vert2[] = {
        b2Vec2(5.5f / PTM_RATIO, 84.5f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, 86.5f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, -86.5f / PTM_RATIO),
        b2Vec2(5.5f / PTM_RATIO, -78.5f / PTM_RATIO)
    };
    [self createRailWithImage:@"rail2.png" atPos:railPos2 withVerts:vert2];
    
    // Bottom rail
    CGPoint railPos3 = ccp(160,44);
    b2Vec2 vert3[] = {
        b2Vec2(-88.5f / PTM_RATIO, -5.5f / PTM_RATIO),
        b2Vec2(88.5f / PTM_RATIO, -5.5f / PTM_RATIO),
        b2Vec2(81.5f / PTM_RATIO, 5.5f / PTM_RATIO),
        b2Vec2(-81.5f / PTM_RATIO, 5.5f / PTM_RATIO)
    };    
    [self createRailWithImage:@"rail3.png" atPos:railPos3 withVerts:vert3];
    
    // Bottom right rail
    CGPoint railPos4 = ccp(262,142);
    b2Vec2 vert4[] = {
        b2Vec2(5.5f / PTM_RATIO, -86.0f / PTM_RATIO),
        b2Vec2(5.5f / PTM_RATIO, 86.0f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, 85.0f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, -78.0f / PTM_RATIO)
    };    
    [self createRailWithImage:@"rail4.png" atPos:railPos4 withVerts:vert4];
    
    // Top right rail
    CGPoint railPos5 = ccp(262,338);
    b2Vec2 vert5[] = {
        b2Vec2(5.5f / PTM_RATIO, 86.5f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, 78.5f / PTM_RATIO),
        b2Vec2(-5.5f / PTM_RATIO, -85.5f / PTM_RATIO),
        b2Vec2(5.5f / PTM_RATIO, -86.5f / PTM_RATIO)
    };    
    [self createRailWithImage:@"rail5.png" atPos:railPos5 withVerts:vert5];
    
    // Top rail
    CGPoint railPos6 = ccp(160,436);
    b2Vec2 vert6[] = {
        b2Vec2(89.0f / PTM_RATIO, 6.0f / PTM_RATIO),
        b2Vec2(-89.0f / PTM_RATIO, 6.0f / PTM_RATIO),
        b2Vec2(-82.0f / PTM_RATIO, -5.0f / PTM_RATIO),
        b2Vec2(81.0f / PTM_RATIO, -5.0f / PTM_RATIO)
    };    
    [self createRailWithImage:@"rail6.png" atPos:railPos6 withVerts:vert6];
}</pre></div><p>This looks like a lot of code to begin with, but it is the same pattern repeated six times to accommodate each rail.</p><p>For each rail, we define the position based on the center point of the sprite, as we are using the default centered anchor point for the rails. We then <a id="id1605" class="indexterm"/>define the array of four <code class="literal">verts</code> that define the four sides of each rail. You will notice that they are not square, as we need the <a id="id1606" class="indexterm"/>tapered ends around the pockets to make a smoother "mouth" for each pocket. Finally, we <a id="id1607" class="indexterm"/>
<a id="id1608" class="indexterm"/>call the <code class="literal">createRailWithImage</code> method we just reviewed. We now have our rails, which look like this:</p><div><img src="img/9007_07_01.jpg" alt="Building the rails"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Building pockets</h2></div></div></div><p>Now that we have our rails built, we need to add the only other "interactive" elements of the table itself, the pockets. We will also use a similar two-method <a id="id1609" class="indexterm"/>approach to build them, as the only <a id="id1610" class="indexterm"/>difference in the pockets is their location.</p><p>
<strong>Filename:</strong> <a id="id1611" class="indexterm"/>
<a id="id1612" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createPocketAtPos:(CGPoint)pos {
    // Create sprite and add it to layer
    CCSprite *pocket = [CCSprite
           spriteWithSpriteFrameName:@"whitespeck.png"];
    pocket.position = pos;
    pocket.tag = kPocket;
    [pocket setColor:ccBLACK];
    [self addChild:pocket z:0];

    // Create a pocket body
    b2BodyDef pocketBodyDef;
    pocketBodyDef.type = b2_dynamicBody;
    pocketBodyDef.position.Set(pos.x/PTM_RATIO, 
                             pos.y/PTM_RATIO);
    pocketBodyDef.userData = pocket;
    b2Body *pocketBody = world-&gt;CreateBody(&amp;pocketBodyDef);
    
    //Create a circle shape
    b2CircleShape circle;
    circle.m_radius = 7.0/PTM_RATIO;
    
    //Create fixture definition and add to body
    b2FixtureDef pocketFixtureDef;
    pocketFixtureDef.shape = &amp;circle;
    pocketFixtureDef.isSensor = YES;

    pocketBody-&gt;CreateFixture(&amp;pocketFixtureDef);
}</pre></div><p>Here we follow the same basic formula we used for the rails. We build a sprite, body, shape, and fixture. Even though we don't technically need a sprite for the pocket, we will use our trusty <code class="literal">whitespeck.png</code> that we used heavily in <a class="link" href="ch06.html" title="Chapter 6. Cycles of Light">Chapter 6</a>, <em>Cycles of Light</em>. In this case, we color it black, so that it disappears into the pocket. (For debugging, it is also helpful to change it to a brighter color, so that you can see where the pockets are.) So why use it at all? We like using a sprite here because it allows <a id="id1613" class="indexterm"/>us to add a tag, <code class="literal">kPocket</code>, to the <a id="id1614" class="indexterm"/>sprite. This makes the collisions a little simpler, as we will be able to use sprite tags for all objects whose collisions we care about (pockets and balls only). </p><p>You may notice that, unlike the rails, we don't need this to be "physics enabled", so the pocket sprites are using normal <code class="literal">CCSprite</code> classes instead of <a id="id1615" class="indexterm"/>
<a id="id1616" class="indexterm"/>
<code class="literal">PhysicsSprite</code> classes. When we define the shape for the pocket, we use a circle with a radius of <code class="literal">7.0</code>. This is because we need a larger target to detect a ball in pocket. We made these circles a little smaller than the actual physical size of the pockets on the table, because we want to allow balls to hang on the edge of the pocket, just as they do on a real table.</p><p>Finally, when we define the <code class="literal">pocketFixtureDef</code>, you will notice we did not use any of the usual values such as <code class="literal">density</code>, <code class="literal">friction</code>, or <code class="literal">restitution</code>. This is because we do not want the pockets to participate in the "bouncing around" of the physics simulation. Instead, we simply set <code class="literal">isSensor</code> to <code class="literal">YES</code>. A sensor is a physics object that registers in the collision handler, but does not actually have any physical "presence" in the world. We will register a contact when something touches the sensor, but other objects will be able to pass through the sensor.</p><p>Now we can look at the second method used to drive the creation of the <a id="id1617" class="indexterm"/>pocket sensors:</p><p>
<strong>Filename:</strong> <a id="id1618" class="indexterm"/>
<a id="id1619" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createPockets {
    // Left top pocket
    [self createPocketAtPos:ccp(57,437)];

    // Left middle pocket
    [self createPocketAtPos:ccp(52,240)];
    
    // Left bottom pocket
    [self createPocketAtPos:ccp(57,43)];

    // Right top pocket
    [self createPocketAtPos:ccp(265,437)];
    
    // Right middle pocket
    [self createPocketAtPos:ccp(272,240)];
    
    // Right bottom pocket
    [self createPocketAtPos:ccp(265,43)];
}</pre></div><p>Compared to the extra code we needed to build the rails in their second method, this one is really simple. We have six pockets, so we simply call the previous <a id="id1620" class="indexterm"/>method and pass it the coordinates for the pocket, and we're done.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Creating the cue stick</h2></div></div></div><p>The cue stick is purely cosmetic. We will be controlling the "hitting" of the cue ball programmatically, and the cue stick is used as an aiming point of reference only. Nevertheless, without a cue stick, the game wouldn't "feel" like pool. <a id="id1621" class="indexterm"/>The cue stick will be on the screen only during aiming, and will be faded out when we make the shot. Because the cue <a id="id1622" class="indexterm"/>stick is deeply connected with the way the controls are built, we will save the discussion on how the cue stick will be used for later in the chapter. For now, let's take a look at how we build it:</p><p>
<strong>Filename:</strong> <a id="id1623" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createPoolCue {
    poolcue = [CCSprite
         spriteWithSpriteFrameName:@"cue_stick.png"];
    [poolcue setAnchorPoint:ccp(0.5,1)];
    [poolcue setVisible:NO];
    [poolsheet addChild:poolcue z:50];
}</pre></div><p>As it is primarily cosmetic, we use a normal <code class="literal">CCSprite</code>. We set the <code class="literal">anchorPoint</code> property to the tip of the cue (centered at the top). As we rotate the cue stick, this will allow it to pivot on its tip. We also set the visible property to <code class="literal">NO</code>, <a id="id1624" class="indexterm"/>because the stick will only be made visible when needed.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Loading the rules</h1></div></div></div><p>We won't be able to progress much farther without discussing the <a id="id1625" class="indexterm"/>rules engine. Some of the configuration of the game, including what type of rack we use for the balls, is controlled by the <a id="id1626" class="indexterm"/>rules. We will be using a separate "rules" class, <code class="literal">OPRulesBase</code>. Let's look at the complete header for this class first:</p><p>
<strong>Filename:</strong> <a id="id1627" class="indexterm"/>
<a id="id1628" class="indexterm"/>
<code class="literal">OPRulesBase.h</code>
</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "cocos2d.h"
#import "OPDefinitions.h"

@interface OPRulesBase : CCNode {
    RackLayoutType rackStyle;
    BallID lastBall;
    BOOL orderedBalls;
    GameMode gameMode;
    BOOL replaceBalls;
    BOOL isBreak;
    GameMode player1Goal;
    GameMode player2Goal;
    BallID nextOrderedBall; // Number of next ball
    NSInteger currentPlayer;
    BOOL isTableScratch;
}

@property (nonatomic, assign) RackLayoutType rackStyle;
@property (nonatomic, assign) BallID lastBall;
@property (nonatomic, assign) BOOL orderedBalls;
@property (nonatomic, assign) GameMode gameMode;
@property (nonatomic, assign) BOOL replaceBalls;
@property (nonatomic, assign) NSInteger currentPlayer;
@property (nonatomic, assign) BOOL isTableScratch;
@property (nonatomic, assign) GameMode player1Goal;
@property (nonatomic, assign) GameMode player2Goal;
@property (nonatomic, assign) BallID nextOrderedBall;

-(id) initWithRulesForGame:(NSString*)gameName;
-(BOOL) isLegalFirstHit:(BallID)firstBall;
-(BOOL) didSinkValidBall:(NSArray*)ballArray;
-(BOOL) didSinkLastBall:(NSArray*)ballArray;
-(BOOL) didSinkCueBall:(NSArray*)ballArray;
-(BOOL) isValidLastBall:(NSArray*)ballsSunk
           withBallsOnTable:(NSArray*)ballsOnTable;
-(void) findNextOrderedBall:(NSArray*)tableBalls;

@end</pre></div><p>The first five variables are all parameters we need to define the rules of the game. Because these will all be used from the <a id="id1629" class="indexterm"/>
<a id="id1630" class="indexterm"/>
<code class="literal">OPPlayfieldLayer</code> class, we must make them all properties as well. The other variables you see will be explained later in the discussion as we use them. The classes in this header give you a little bit of a "sneak preview" on how we will approach the full rules engine implementation later in <a id="id1631" class="indexterm"/>the chapter. As you can see, most <a id="id1632" class="indexterm"/>of the classes are "questioning" methods to "ask" the rules engine about the status of various conditions. These methods will vary based on the type of game, which is why these "question methods" are part of the rules engine.</p><p>As we move to the implementation file, we will begin by looking at the custom <code class="literal">init</code> method we will use for the rules:</p><p>
<strong>Filename:</strong> <a id="id1633" class="indexterm"/>
<a id="id1634" class="indexterm"/>
<code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(id) initWithRulesForGame:(NSString*)gameName {
    if(self = [super init]) {
        // Load the rules for the game chosen
        [self loadRulesWith:gameName];
        
        isTableScratch = NO;
        isBreak = YES;
    }
    return self;
}</pre></div><p>This is a pretty simple <code class="literal">init</code> method<a id="id1635" class="indexterm"/>
<a id="id1636" class="indexterm"/> that calls the <a id="id1637" class="indexterm"/>
<a id="id1638" class="indexterm"/>
<code class="literal">loadRulesWith:gameName</code> method, and sets a couple of starting values for the table variables (<code class="literal">isTableScratch</code> and <code class="literal">isBreak</code>). Before we get to the <a id="id1639" class="indexterm"/>
<a id="id1640" class="indexterm"/>
<code class="literal">loadRulesWith</code> method, there are other methods we need to review first:</p><p>
<strong>Filename:</strong> <a id="id1641" class="indexterm"/>
<a id="id1642" class="indexterm"/>
<code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(id) readPlist:(NSString*) fileName {
  NSData *plistData;
  NSString *error;
  NSPropertyListFormat format;
  id plist;
  
    // Assumes filename is part of the main bundle
  NSString *localizedPath = [[NSBundle mainBundle]
            pathForResource:fileName ofType:@"plist"];
  plistData = [NSData dataWithContentsOfFile:localizedPath];
  plist = [NSPropertyListSerialization
            propertyListFromData:plistData
            mutabilityOption:NSPropertyListImmutable
            format:&amp;format errorDescription:&amp;error];
  
  if (!plist) {
    NSLog(@"Error reading plist from file '%s', error '%s'",
            [localizedPath UTF8String], [error UTF8String]);
  }
  return plist;
}

-(NSDictionary*)getDictionaryFromPlist:(NSString*)fileName {
    return (NSDictionary*)[self readPlist:fileName];
}</pre></div><p>The <code class="literal">readPlist</code> and <code class="literal">getDictionaryFromPlist</code> methods we have seen before, also in the <em>Brick breaker</em> section in <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, <em>Brick Breaking Balls with Box2D</em>. The <code class="literal">readPlist</code> method <a id="id1643" class="indexterm"/>will load the named plist into memory, and return it as a general type <code class="literal">id</code>. The <a id="id1644" class="indexterm"/>
<a id="id1645" class="indexterm"/>
<code class="literal">getDictionaryFromPlist</code> method casts the result of <code class="literal">readPlist</code> as an <code class="literal">NSDictionary</code>, and returns it to the calling method. That's all it takes to get our plist into an <code class="literal">NSDictionary</code>.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Rules.plist</h2></div></div></div><p>Before we go any further into the loader, we should see <a id="id1646" class="indexterm"/>what the plist for our rules actually looks <a id="id1647" class="indexterm"/>like. This is the plist itself:</p><div><img src="img/9007_07_02.jpg" alt="Rules.plist"/></div><p>As you can see from the plist, the first level in the structure is the named game (<strong>Eight Ball</strong>, <strong>Nine Ball</strong>), and inside those Dictionaries are a set of Strings and Booleans that define the details of the game. Because we have chosen to represent the <code class="literal">RackStyle</code> and <code class="literal">GameMode</code> elements as strings, we will need to convert <a id="id1648" class="indexterm"/>those into something more usable by the engine.</p><p>Now we have the pieces together to understand the <a id="id1649" class="indexterm"/>
<a id="id1650" class="indexterm"/>
<code class="literal">loadRulesWith</code> method.</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(void) loadRulesWith:(NSString*)listKey {
    // Load the rules plist
    NSDictionary *ruleBook = [NSDictionary
                dictionaryWithDictionary:
                [self getDictionaryFromPlist:@"rules"]];
    NSDictionary *theseRules = [NSDictionary
                dictionaryWithDictionary:
                [ruleBook objectForKey:listKey]];
    self.rackStyle = [self convertRackType:
                [theseRules objectForKey:@"RackStyle"]];
    self.lastBall = (BallID)[[theseRules
                objectForKey:@"LastBall"] integerValue];
    self.orderedBalls = [[theseRules
                objectForKey:@"OrderedBalls"] boolValue];
    self.gameMode = [self convertGameMode:[theseRules
                objectForKey:@"GameMode"]];
    self.replaceBalls = [[theseRules
                objectForKey:@"ReplaceBalls"] boolValue];
    
    player1Goal = gameMode;
    player2Goal = gameMode;
    
    if (self.gameMode == kOrdered) {
        nextOrderedBall = kBallOne;
    }
    
    currentPlayer = 1;
}</pre></div><p>We begin by loading in the <code class="literal">rules.plist</code> using the <code class="literal">getDictionaryFromPlist</code> method. We load the rules into the <a id="id1651" class="indexterm"/>
<a id="id1652" class="indexterm"/>
<code class="literal">ruleBook</code> dictionary, and then we create another dictionary, <code class="literal">theseRules</code>, which gets the named game dictionary from inside our <code class="literal">ruleBook</code> dictionary. From there, we begin populating our base rules properties from that "game level" dictionary. Because an <a id="id1653" class="indexterm"/>
<a id="id1654" class="indexterm"/>
<code class="literal">NSDictionary</code> stores objects only, we have to convert the values for several of the keys before we can insert them into the properties. For <code class="literal">LastBall</code>, we convert the object to the <code class="literal">integerValue</code> of the object (which is stored as an <code class="literal">NSNumber</code>). You will notice that we convert this to an integer, but then we cast it to a <code class="literal">BallID</code> type when we set the property's value. This is <a id="id1655" class="indexterm"/>where the numeric representations we set in the <code class="literal">typedef</code> <code class="literal">enum</code> in the <code class="literal">OPDefinitions.h</code> file come in handy. Because, for example, <code class="literal">kBallNine</code> is internally represented as the integer <code class="literal">9</code>, we can freely bridge across these data types. Had we used other values for the <code class="literal">typedef</code> <code class="literal">enum</code>, we would have been forced to do some more complex conversions, probably with an <a id="id1656" class="indexterm"/>extended <code class="literal">switch</code> statement. Similarly, we get the <code class="literal">boolValue</code> of both the <code class="literal">OrderedBalls</code> and <a id="id1657" class="indexterm"/>
<a id="id1658" class="indexterm"/>
<code class="literal">ReplaceBalls</code> keys, so they will "fit" into our Boolean properties.</p><p>The other two rule properties need special consideration. Because we have chosen to store those as strings in the <code class="literal">rules.plist</code>, we have to do string comparison to convert them into the values our game wants to use. Let's look at the conversion methods now:</p><p>
<strong>Filename:</strong> <a id="id1659" class="indexterm"/>
<a id="id1660" class="indexterm"/>
<code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(RackLayoutType) convertRackType:(NSString*)rackStr {
    if ([rackStr isEqualToString:@"kRackDiamond"]) {
        return kRackDiamond;
    } else if ([rackStr isEqualToString:@"kRackTriangle"]) {
        return kRackTriangle;
    } else {
        NSLog(@"unknown rack type %@ in the plist.", rackStr);
    }
    return kRackFailed;
}

-(GameMode) convertGameMode:(NSString*)gameStr {
    if ([gameStr isEqualToString:@"Ordered"]) {
        return kOrdered;
    }
    else if ([gameStr isEqualToString:@"StripesVsSolids"]) {
        return kStripesVsSolids;
    }
    return kNone;
}</pre></div><p>For both of these methods, we pass it the string that comes from the dictionary, and compare the strings to our defined values. We can then return the <code class="literal">typedef</code> <code class="literal">enum</code> values that correspond to the chosen options. We could have avoided this by storing the rack types and game modes as numbers in the plist, but that makes the human reading (and writing) of the plist less easy to understand. Because we only perform these comparisons when loading the rules, there is no performance drawback on using this slower approach.</p><p>In the final lines of the <a id="id1661" class="indexterm"/>
<a id="id1662" class="indexterm"/>
<code class="literal">loadRulesWith</code> method, we assign the current <code class="literal">gameMode</code> (that we just loaded) to the <code class="literal">player1Goal</code> and <code class="literal">player2Goal</code> properties. This identifies for the players what their goal in the game is going to be. Why is this at a player level? It really comes down to the inherent complexity in the game of Eight Ball, <a id="id1663" class="indexterm"/>where one player will be shooting for stripes, and the other for solids. Before any balls are sunk, the table is "open", so all shots (except for the last ball) are legal. So, in this case, the starting game is "Stripes vs Solids" for both players, until the game progresses to the point where one is deemed to have a goal of "Stripes" and the other "Solids".</p><p>We also check if the <code class="literal">gameMode</code> is <code class="literal">kOrdered</code>. This <a id="id1664" class="indexterm"/>means that balls will be sunk in numeric order. If this is the case, the <code class="literal">nextOrderedBall</code> variable is set to <code class="literal">kBallOne</code>. If the game is anything else, <code class="literal">nextOrderedBall</code> will be ignored. Finally, <code class="literal">currentPlayer</code> always starts as player 1.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Rack 'em up</h1></div></div></div><p>Now that we know what type of game we will be playing, we have enough information to build the rack on the table. First we need to know how to build the balls.</p><p>
<strong>Filename:</strong> <a id="id1665" class="indexterm"/>
<a id="id1666" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createBall:(BallID)ballID AtPos:(CGPoint)startPos {
    // Create the filename
    NSString *ballImg = [NSString
                      stringWithFormat:@"ball_%i.png",ballID];
    
    // Create sprite and add it to layer
    OPBall *ball = [OPBall spriteWithSpriteFrameName:ballImg];
    ball.position = startPos;
    ball.tag = ballID;
    [self addChild:ball z:10];
    
    // Create ball body
    b2BodyDef ballBodyDef;
    ballBodyDef.type = b2_dynamicBody;
    ballBodyDef.position.Set(startPos.x/PTM_RATIO,
                             startPos.y/PTM_RATIO);
    ballBodyDef.userData = ball;
    b2Body *ballBody = world-&gt;CreateBody(&amp;ballBodyDef);
    
    // Store the body in the sprite
    [ball setPhysicsBody:ballBody];
    
    //Create a circle shape
    b2CircleShape circle;
    circle.m_radius = 7.5/PTM_RATIO;  // 7.5 point radius
    
    //Create fixture definition and add to body
    b2FixtureDef ballFixtureDef;
    ballFixtureDef.shape = &amp;circle;
    ballFixtureDef.density = 1.0f;
    ballFixtureDef.friction = 0.5f;
    ballFixtureDef.restitution = 0.9f;
    
    ballBody-&gt;CreateFixture(&amp;ballFixtureDef);
    ballBody-&gt;SetFixedRotation(false);
    ballBody-&gt;SetLinearDamping(0.7f);
    ballBody-&gt;SetAngularDamping(0.5f);
    ballBody-&gt;SetBullet(TRUE);
    
    if (ballID == kBallCue) {
        cueBallBody = ballBody;
    }
}</pre></div><p>This is similar to the builders we used to create the rails and pockets, with a few exceptions. We pass both the <a id="id1667" class="indexterm"/>
<a id="id1668" class="indexterm"/>
<code class="literal">BallID</code> and <a id="id1669" class="indexterm"/>
<a id="id1670" class="indexterm"/>
<code class="literal">startPos</code> variables to this method, so we know which ball to build, and where to build it. We use the class <code class="literal">OPBall</code>, which is a subclass of <code class="literal">PhysicsSprite</code>, to represent the balls. The <code class="literal">OPBall</code> class is a direct pass-through of the <a id="id1671" class="indexterm"/>
<a id="id1672" class="indexterm"/>
<code class="literal">PhysicsSprite</code>, with no added functionality. We do this because we gain the ability in the collision handler to use the <a id="id1673" class="indexterm"/>
<a id="id1674" class="indexterm"/>
<code class="literal">isMemberOfClass</code> method to determine if the object is a ball or not. If we designed the collision handler differently, we could have used <code class="literal">PhysicsSprite</code> for the balls instead.</p><p>For the rest of the ball instantiation, we follow the pattern of building a body, assigning it to the sprite, creating the fixture, and attaching it to the body. We use a <code class="literal">density</code> of <code class="literal">1.0f</code>, a <code class="literal">friction</code> of <code class="literal">0.5f</code>, and a <code class="literal">restitution</code> of <code class="literal">0.9f</code> to give a good "pool ball feel" to the fixtures. We then use a few additional members of the body object that we haven't really used before. We turn off <a id="id1675" class="indexterm"/>
<a id="id1676" class="indexterm"/>
<code class="literal">SetFixedRotation</code>, so the balls will be able to rotate, rather than remaining at their original rotation. We set the linear damping to <code class="literal">0.7f</code>, and the angular damping to <code class="literal">0.5f</code>. Together, these will help simulate the effect of the balls rolling on the table felt. This is the one place in this game where we are "faking" the physics world, because we are not actually creating a table top object. Linear damping will slow the ball's forward progress, and angular damping will help slow the ball's rotation. Together with the fixture's settings, these provide a fairly realistic feel for a pool table.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Building the rack </h2></div></div></div><p>Now we can build the rack. Let's look at the <a id="id1677" class="indexterm"/>
<a id="id1678" class="indexterm"/>code:</p><p>
<strong>Filename:</strong> <a id="id1679" class="indexterm"/>
<a id="id1680" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createRackWithLayout:(RackLayoutType)rack {
    // Define the standard ball positions
    CGPoint footSpot = ccp(160,335);
    CGPoint r1b1 = ccp(153,348);
    CGPoint r1b2 = ccp(167,348);
    CGPoint r2b1 = ccp(146,361);
    CGPoint r2b2 = ccp(160,361);
    CGPoint r2b3 = ccp(174,361);
    CGPoint r3b1 = ccp(139,374);
    CGPoint r3b2 = ccp(153,374);
    CGPoint r3b3 = ccp(167,374);
    CGPoint r3b4 = ccp(181,374);
    CGPoint r4b1 = ccp(132,388);
    CGPoint r4b2 = ccp(146,388);
    CGPoint r4b3 = ccp(160,388);
    CGPoint r4b4 = ccp(174,388);
    CGPoint r4b5 = ccp(188,388);
    
    switch (rack) {
        case kRackTriangle:
            // Build a standard triangle rack
            [self createBall:kBallNine AtPos:footSpot];
            [self createBall:kBallSeven AtPos:r1b1];
            [self createBall:kBallTwelve AtPos:r1b2];
            [self createBall:kBallFifteen AtPos:r2b1];
            [self createBall:kBallEight AtPos:r2b2];
            [self createBall:kBallOne AtPos:r2b3];
            [self createBall:kBallSix AtPos:r3b1];
            [self createBall:kBallTen AtPos:r3b2];
            [self createBall:kBallThree AtPos:r3b3];
            [self createBall:kBallFourteen AtPos:r3b4];
            [self createBall:kBallEleven AtPos:r4b1];
            [self createBall:kBallTwo AtPos:r4b2];
            [self createBall:kBallThirteen AtPos:r4b3];
            [self createBall:kBallFour AtPos:r4b4];
            [self createBall:kBallFive AtPos:r4b5];
            break;
        case kRackDiamond:
            // Build a diamond rack
            [self createBall:kBallOne AtPos:footSpot];
            [self createBall:kBallFive AtPos:r1b1];
            [self createBall:kBallSeven AtPos:r1b2];
            [self createBall:kBallEight AtPos:r2b1];
            [self createBall:kBallNine AtPos:r2b2];
            [self createBall:kBallThree AtPos:r2b3];
            [self createBall:kBallTwo AtPos:r3b2];
            [self createBall:kBallSix AtPos:r3b3];
            [self createBall:kBallFour AtPos:r4b3];
            break;
        default:
            break;
    }
}</pre></div><p>In this method, we first define the positions where the balls will be located. We use a shorthand notation for most of the <code class="literal">CGPoint</code> positions. The abbreviation means row and ball in row, so <code class="literal">r1b1</code> is the leftmost ball in the first row past the foot spot (the foot spot is the front "point" of the rack). We define all the positions first, and <a id="id1681" class="indexterm"/>then check which rack we want. If we called for a triangle rack (as in Eight Ball), then <a id="id1682" class="indexterm"/>we will fill in every position with a ball. If we need a triangle rack (used in Nine Ball), then we only use 9 of the 15 positions defined. The positions, you will notice, are actually a little too close together. This is intentional, because Box2D will nudge the balls a <a id="id1683" class="indexterm"/>little bit so they all fit. The end result is that the balls are all touching, which is known as a "tight rack" in pool.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Player HUD</h1></div></div></div><p>As we are building a two-player game, let's take a quick <a id="id1684" class="indexterm"/>look at how we build the Heads-Up Display to <a id="id1685" class="indexterm"/>provide feedback to the players:</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) createPlayerScores {
    CCLabelTTF *player1 = [CCLabelTTF
                           labelWithString:@"P1"
                           fontName:@"Verdana"
                           fontSize:14];
    [player1 setPosition:ccp(20,460)];
    [self addChild:player1];
    
    CCLabelTTF *player2 = [CCLabelTTF
                           labelWithString:@"P2"
                           fontName:@"Verdana"
                           fontSize:14];
    [player2 setPosition:ccp(300,460)];
    [self addChild:player2];
    
    player1TargetLbl = [CCLabelTTF
                        labelWithString:@" "
                        fontName:@"Verdana" fontSize:8];
    [player1TargetLbl setPosition:ccp(20,440)];
    [self addChild:player1TargetLbl z:2];
    
    player2TargetLbl = [CCLabelTTF
                        labelWithString:@" "
                        fontName:@"Verdana" fontSize:8];
    [player2TargetLbl setPosition:ccp(300,440)];
    [self addChild:player2TargetLbl z:2];
    markPlayer = [CCSprite spriteWithSpriteFrameName:
                  @"whitespeck.png"];
    [markPlayer setColor:ccGREEN];
    [markPlayer setPosition:ccp(20,450)];
    [markPlayer setScaleX:10 * CC_CONTENT_SCALE_FACTOR()];
    [self addChild:markPlayer z:2];
    
    // Update the display
    if ([rules orderedBalls]) {
        CCLabelTTF *nextBallLbl = [CCLabelTTF
                            labelWithString:@"Next Ball"
                            fontName:@"Verdana"
                            fontSize:12];
        [nextBallLbl setPosition:ccp(122,470)];
        [self addChild:nextBallLbl z:100];
    }
}</pre></div><p>We build simple labels to identify player 1 and player 2, and we also create target labels, which we will use to identify "stripes" or "solids" for the player. We use our <code class="literal">whitespeck.png</code> image again, this time to make a nice green line that will identify which player's turn it is, using the <code class="literal">markPlayer</code> variable<a id="id1686" class="indexterm"/>
<a id="id1687" class="indexterm"/> to hold that sprite. Finally, if we are playing a game with ordered balls, we also add the legend <strong>Next Ball</strong> at the top of the display. As we have discussed the goals a few times, let's see <a id="id1688" class="indexterm"/>how they are identified for the players:</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) updatePlayerGoals {
    // Update the stripes/solids display for the players
    if ([rules player1Goal] == kStripes) {
        [player1TargetLbl setString:@"Stripes"];
        [player2TargetLbl setString:@"Solids"];
    } else if ([rules player1Goal] == kSolids) {
        [player1TargetLbl setString:@"Solids"];
        [player2TargetLbl setString:@"Stripes"];
    }
    
    // Update the display
    if ([rules orderedBalls]) {
        // Update the ordered ball goals, if applicable
        [rules findNextOrderedBall:
                    [self ballSpritesOnTable]];
        if (nextGoal != nil) {
            [nextGoal removeFromParentAndCleanup:YES];
        }
        // Create the filename
        NSString *ballImg = [NSString stringWithFormat:
                        @"ball_%i.png",
                        (BallID)[rules nextOrderedBall]];
        // Create sprite and add it to layer
        nextGoal = [CCSprite spriteWithSpriteFrameName:
                    ballImg];
        [nextGoal setPosition:ccp(160,470)];
        [self addChild:nextGoal]; 
    }
}</pre></div><p>Referring back to our discussion in the rules about player goals, here we simply check each player's goal. Depending on if it has been set to stripes or solids, we update the appropriate target labels to display to the users what they are shooting for. Then we check if it is a game with ordered balls. If it is, we check with the rules engine to determine what the lowest numbered ball on the table is, and we add an image of that ball to the top of the display, next to the <strong>Next Ball</strong> label. You will notice we <a id="id1689" class="indexterm"/>
<a id="id1690" class="indexterm"/>call the <code class="literal">ballSpritesOnTable</code> method, so we should go there now:</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(NSArray*) ballSpritesOnTable {
    // Returns an array of all ball sprites on the table
    NSMutableArray *currentBalls = [[[NSMutableArray alloc]
                          initWithCapacity:16] autorelease];
    
    for(b2Body *b = world-&gt;GetBodyList(); b;b=b-&gt;GetNext()) {
        if (b-&gt;GetUserData() != nil) {
            OPBall *aBall = (OPBall*)b-&gt;GetUserData();
            if (aBall.tag &lt; 100) {
                [currentBalls addObject:aBall];
            }
        }
    }
    return currentBalls;
}</pre></div><p>Here we iterate through all the bodies in the Box2D world, and find those that have sprites attached. You will notice we check to make sure the <code class="literal">tag</code> is lower than <code class="literal">100</code>. This is because the pockets also have sprites attached, but we set the <code class="literal">#define</code> for <code class="literal">kPocket</code> to be <code class="literal">500</code>, so we don't accidentally add a pocket sprite to the array. With <a id="id1691" class="indexterm"/>all balls accounted for, we return an <code class="literal">NSArray</code> to the calling method.</p><p>The only significant player method we have left is the active player change:</p><p>
<strong>Filename:</strong> <a id="id1692" class="indexterm"/>
<a id="id1693" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) playerChange {
    if ([rules currentPlayer] == 1) {
        [self displayMessage:@"Player 2's turn" userDismiss:NO];
        [rules setCurrentPlayer:2];
        [markPlayer setPosition:ccp(300,450)];
    } else {
        [self displayMessage:@"Player 1's turn" userDismiss:NO];
        [rules setCurrentPlayer:1];
        [markPlayer setPosition:ccp(20,450)];
    }
}</pre></div><p>This is a short and sweet method. If it is currently player 1's turn, we change the <code class="literal">currentPlayer</code> to player 2, and vice versa. We move the <code class="literal">markPlayer</code> sprite to the appropriate side of the display (below the P1 or P2 labels), and we call the <code class="literal">displayMessage</code> <a id="id1694" class="indexterm"/>
<a id="id1695" class="indexterm"/>method to give feedback to the players.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Displaying messages</h2></div></div></div><p>Throughout the game, there are many times we need to present messages to the player. Rather than building the same basic message display repeatedly, <a id="id1696" class="indexterm"/>we have consolidated that functionality in the <code class="literal">displayMessage</code> and <a id="id1697" class="indexterm"/>
<a id="id1698" class="indexterm"/>
<code class="literal">dismissMessage</code> methods.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) displayMessage:(NSString*)msg
             userDismiss:(BOOL)userDismiss {
    // If there is a current message, wait for it
    if (isDisplayingMsg) {
        CCDelayTime *del = [CCDelayTime
                            actionWithDuration:0.1];
        CCCallBlock *retry = [CCCallBlock
                              actionWithBlock:^{
          [self displayMessage:msg
                   userDismiss:userDismiss];
        }];
        [self runAction:[CCSequence actions:del,
                         retry, nil]];
        return;
    }
    isDisplayingMsg = YES;
    isUserDismissMsg = userDismiss;
    
    // Create the message label &amp; display it
    message = [CCLabelTTF labelWithString:msg
                                 fontName:@"Verdana"
                                 fontSize:20];
    [message setPosition:ccp(size.width/2,
                             size.height/2)];
    [self addChild:message z:20];
    
    // If userDismiss is NO, set a 2 second destruct
    if (userDismiss == NO) {
        CCDelayTime *wait = [CCDelayTime
                             actionWithDuration:2.0f];
        CCCallFunc *dismiss = [CCCallFunc
                    actionWithTarget:self
                    selector:@selector(dismissMessage)];
        [self runAction:[CCSequence actions:wait,
                         dismiss, nil]];
    }
}</pre></div><p>In this method, we first check to make sure we are not already displaying a message. If we are (as indicated by the <a id="id1699" class="indexterm"/>
<a id="id1700" class="indexterm"/>
<code class="literal">isDisplayingMsg</code> Boolean variable), then we wait for <code class="literal">0.1</code> second and call it again with the same parameters. If there is no message displaying, we create a label with the requested message and display it on the screen. If the <code class="literal">userDismiss</code> is <code class="literal">NO</code>, then we set a 2 second timer and then call <code class="literal">dismissMessage</code>. If the <code class="literal">userDismiss</code> is <code class="literal">YES</code>, then the message will be displayed until the <a id="id1701" class="indexterm"/>user touches the screen to dismiss it.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) dismissMessage {
    isDisplayingMsg = NO;
    [message removeFromParentAndCleanup:YES];
}</pre></div><p>The <code class="literal">dismissMessage</code> method is simple. If we didn't need to have the user dismiss option, then we could have easily embedded this in a <code class="literal">CCCallBlock</code> action in the <code class="literal">displayMessage</code> method, but we wanted the extra flexibility here.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Collision handling</h1></div></div></div><p>Before we get to the final stretch covering the controls and the rest of the rules engine, we now know enough about our game that we can implement the collision detection, which uses the same contact listener we used in <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, <em>Brick Breaking Balls with Box2D</em>. <a id="id1702" class="indexterm"/>We will look at the <a id="id1703" class="indexterm"/>
<a id="id1704" class="indexterm"/>
<a id="id1705" class="indexterm"/>
<code class="literal">update</code> method in pieces, so we can discuss it along the way:</p><p>
<strong>Filename:</strong> <a id="id1706" class="indexterm"/>
<a id="id1707" class="indexterm"/>
<code class="literal">OPPlayfieldLayer.mm</code> (<code class="literal">update</code>, part 1)</p><div><pre class="programlisting">-(void) update: (ccTime) dt
{
  int32 velocityIterations = 30;
  int32 positionIterations = 30;
  
  // Instruct the world to perform a single step
  world-&gt;Step(dt, velocityIterations, positionIterations);	

    // Evaluate all contacts
    std::vector&lt;b2Body *&gt;toDestroy;
  std::vector&lt;OPContact&gt;::iterator pos;
  for (pos = contactListener-&gt;_contacts.begin();
     pos != contactListener-&gt;_contacts.end(); pos++) {
    OPContact contact = *pos;
    
        // Get the bodies involved in this contact
    b2Body *bodyA = contact.fixtureA-&gt;GetBody();
    b2Body *bodyB = contact.fixtureB-&gt;GetBody();
        
        // Get the sprites attached to these bodies
        CCSprite *spriteA = (CCSprite*)bodyA-&gt;GetUserData();
        CCSprite *spriteB = (CCSprite*)bodyB-&gt;GetUserData();</pre></div><p>The first important thing to see here is that we have really ramped up the number of iterations that the simulation uses in each step, to increase the accuracy of the simulation. As we only have a small number of bodies, it does not adversely affect performance.</p><p>We step the world forward and then, using C++ vectors, we iterate through all the contacts that have been collected by the contact listener. For each <a id="id1708" class="indexterm"/>contact, we get the bodies and their related sprites, which we store in <code class="literal">bodyA</code>, <code class="literal">bodyB</code>, <code class="literal">spriteA</code>, and <code class="literal">spriteB</code>. We hold the sprites as <code class="literal">CCSprite</code> objects, because we can't be sure which subclass of <code class="literal">CCSprite</code> the object will be.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code> (<code class="literal">update</code>, part 2)</p><div><pre class="programlisting">        // Look for balls touching the pocket sensor
        if ([spriteA isMemberOfClass:[OPBall class]] &amp;&amp;
            spriteB.tag == kPocket) {
            if (std::find(toDestroy.begin(),
                          toDestroy.end(),
                          bodyA) == toDestroy.end()) {
                toDestroy.push_back(bodyA);
            }
        }
        // Check the same collision with opposite A/B
        else if (spriteA.tag == kPocket &amp;&amp; [spriteB
                    isMemberOfClass:[OPBall class]]) {
            if (std::find(toDestroy.begin(),
                          toDestroy.end(),
                          bodyB) == toDestroy.end()) {
                toDestroy.push_back(bodyB);
            }
        }
        if ([spriteA isMemberOfClass:[OPBall class]] &amp;&amp;
            [spriteB isMemberOfClass:[OPBall class]]) {
            // Two balls collided
            // Let's store the FIRST collision
            if ((spriteA.tag == kBallCue ||
                 spriteB.tag == kBallCue) &amp;&amp;
                firstHit == kBallNone) {
                if (spriteA.tag == kBallCue) {
                    firstHit = (BallID)spriteB.tag;
                } else {
                    firstHit = (BallID)spriteA.tag;
                }
            }
        }
  }    </pre></div><p>In this section, we compare <code class="literal">spriteA</code> and <code class="literal">spriteB</code> to see if one of them is an <code class="literal">OPBall</code> object, and the other has a tag of <a id="id1709" class="indexterm"/>
<a id="id1710" class="indexterm"/>
<code class="literal">kPocket</code>. If this is true, then a ball has landed in a pocket, so we add the ball to the <code class="literal">toDestroy</code> vector to deal with later. As you probably recall from <a class="link" href="ch05.html" title="Chapter 5. Brick Breaking Balls with Box2D">Chapter 5</a>, <em>Brick Breaking Balls with Box2D</em>, we cannot guarantee in which order the bodies will be reported to us, so we have to check everything in both ways.</p><p>The next check is to determine if two balls collided with each other. If there are two balls, then we check to see if one of them is the cue ball. If it is, and this is the first contact of the cue ball with another ball since the cue ball was last hit, then we keep a reference to that tag in the variable <code class="literal">firstHit</code>. Why do we do this? Pool <a id="id1711" class="indexterm"/>has a rule that requires you to hit your own ball first, before the cue ball touches any other balls. By storing the first ball touched in the <code class="literal">firstHit</code> variable, we will be able to properly track what the cue ball hit first. We will use this information later.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code> (<code class="literal">update</code>, part 3)</p><div><pre class="programlisting">    // Destroy any bodies &amp; sprites we need to get rid of
    std::vector&lt;b2Body *&gt;::iterator pos2;
    for(pos2 = toDestroy.begin(); pos2 != toDestroy.end();
                                                  ++pos2) {
        b2Body *body = *pos2;
        if (body-&gt;GetUserData() != NULL) {
            OPBall *sprite = (OPBall *) body-&gt;GetUserData();
            [self sinkBall:sprite];
        }        
        world-&gt;DestroyBody(body);
    }
    
    if ([self isTableMoving]) {
        self.isTouchBlocked = YES;
    } else {
        self.isTouchBlocked = NO;

        // Table is done.  Let's resolve the action.
        if (pendingTable) {
            [self checkTable];
            pendingTable = NO;
        }
    }
}</pre></div><p>In this final section of the <code class="literal">update</code> method, we proceed to destroy any bodies (balls) that were added to the <code class="literal">toDestroy</code> vector, and we send the corresponding sprites to the <code class="literal">sinkBall</code> method.</p><p>We then check if the table is moving, that is, are any balls still rolling. If there are, we block any user input (with the <a id="id1712" class="indexterm"/>
<a id="id1713" class="indexterm"/>
<code class="literal">isTouchBlocked</code> Boolean variable), and then we call the <a id="id1714" class="indexterm"/>
<a id="id1715" class="indexterm"/>
<code class="literal">checkTable</code> method to see what happened. We use the <code class="literal">pendingTable</code> variable <a id="id1716" class="indexterm"/>
<a id="id1717" class="indexterm"/>to allow us to only check the status of the table when everything is at rest. We will set <code class="literal">pendingTable</code> to <code class="literal">YES</code> when we take a shot, and this section will <a id="id1718" class="indexterm"/>wait until everything is settled, and then check the table once.</p><p>We will get to the <code class="literal">checkTable</code> method later, but for now let's look at the <code class="literal">sinkBall</code> and <code class="literal">isTableMoving</code> <a id="id1719" class="indexterm"/>
<a id="id1720" class="indexterm"/>methods to see how they work:</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) sinkBall:(OPBall*)thisBall {

    // Keep the ball in the temp array
    [ballsSunk addObject:thisBall];
    
    // Destroy The Sprite
    [thisBall removeFromParentAndCleanup:YES];
}</pre></div><p>If we wanted to do something fancy with the balls that are sunk, this would be the place. For our game, we are quite content with simply having the balls added to the <code class="literal">ballsSunk</code> array and then remove the ball from the layer.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(BOOL) isTableMoving {
    for(b2Body *b = world-&gt;GetBodyList(); b;b=b-&gt;GetNext()) {
        // See if the body is still noticeably moving
        b2Vec2 vel = b-&gt;GetLinearVelocity();

        if (vel.Length() &gt; 0.005f) {
            return YES;
        }
    }
    return NO;
}</pre></div><p>To check if the table is moving, we could simply poll to see if all bodies are sleeping. The problem with this approach is that it takes a while for physics bodies to completely stop and go to sleep. Through testing, we determined that this was too long and boring. So instead, we check the velocity length of each body. If the value is greater than <code class="literal">0.005f</code>, then the ball is still noticeably moving. Below that speed, everything is <a id="id1721" class="indexterm"/>crawling slowly enough for us to proceed with checking the table.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Building the control base</h1></div></div></div><p>We are now to the point where we can build the controls for the player. As we said in the introduction, we will be building two control schemes. <a id="id1722" class="indexterm"/>The first is what we call "one touch". This controller will track from the moment the touch is detected until it is <a id="id1723" class="indexterm"/>released. While the touch is on the screen, we will update the cue stick to follow the touch, aiming at the cue ball. When the touch is ended (finger lifted) we will take the shot from the position of the cue stick, and the distance from the cue ball will determine the strength of the shot.</p><p>The second control scheme, which we call "two touch", will be similar in the way it tracks the shot, but it will not automatically take the shot when the touch is lifted. Instead, a button that says <strong>Shoot!</strong> will appear at the bottom of the screen, and touching that button will take the shot.</p><p>Both control schemes share some code, so we have created the <code class="literal">OPControlBase</code> class, which we will then subclass with <code class="literal">OPControlOneTouch</code> and <code class="literal">OPControlTwoTouch</code> to handle the specifics of those two control schemes. <a id="id1724" class="indexterm"/>We will start by looking at the <code class="literal">OPControlBase</code> class:</p><p>
<strong>Filename:</strong> <code class="literal">OPControlBase.h</code>
</p><div><pre class="programlisting">@class OPPlayfieldLayer;

@interface OPControlBase : CCLayer {
    OPPlayfieldLayer *mp; // Main playfield
    float shotLength; // Length of the stroke
    CGPoint plannedHit; // Where the cue will hit
    CCLabelTTF *shootButton; // Only used by 2 touch
    CGPoint aimAtPoint; // Point the cue will aim at
    CCSprite *cueBallInHand; // For placing the cue ball
}

@property (nonatomic, assign) OPPlayfieldLayer *mp;
@property (nonatomic, assign) float shotLength;
@property (nonatomic, assign) CGPoint plannedHit;
@property (nonatomic, assign) CGPoint aimAtPoint;

-(void) updateCueAimFromLoc:(CGPoint)convLoc;
-(void) hideCue;

@end</pre></div><p>In the header we can see the variables we need to track for both control schemes. We will keep a reference to the main playfield layer, since we need to interact with it. We keep track of the <a id="id1725" class="indexterm"/>
<a id="id1726" class="indexterm"/>
<code class="literal">shotLength</code> variable (used as the strength), the <code class="literal">plannedHit</code> variable (the point we will hit from), and the <a id="id1727" class="indexterm"/>
<a id="id1728" class="indexterm"/>
<code class="literal">aimAtPoint</code> variable, which will be the cue ball's position. We also have the <code class="literal">cueBallInHand</code> sprite.<a id="id1729" class="indexterm"/>
<a id="id1730" class="indexterm"/> This will be used when we are positioning the cue ball on the table, as we really don't need or want an <a id="id1731" class="indexterm"/>actual physics object to ram into other balls as the player is moving the cue ball around.</p><p>
<strong>Filename:</strong> <a id="id1732" class="indexterm"/>
<a id="id1733" class="indexterm"/>
<code class="literal">OPControlBase.mm</code>
</p><div><pre class="programlisting">-(void) updateCueAimFromLoc:(CGPoint)convLoc {
    // Position the cue at the cue ball
    CGPoint offset = ccpSub(aimAtPoint,convLoc);
    CGPoint approach = ccpNormalize(offset);
    
    // Move the cue into the right angle
    [mp.poolcue setPosition:ccpSub(aimAtPoint, offset)];
    [mp.poolcue setVisible:YES];
    [mp.poolcue setRotation:
     (-1 * CC_RADIANS_TO_DEGREES(
                            ccpToAngle(approach))) + 90];
    
    // Calculate the power of the hit
    shotLength = sqrtf((offset.x* offset.x) +
                       (offset.y*offset.y)) - 4.5;
    
    // We limit how far away the cue can be
    if (shotLength &gt; 75 || shotLength &lt; 4) {
        // We reject this hit
        [self hideCue];
        return;
    } else {
        // Calculate the planned hit
        float hitPower = shotLength / 6;
        plannedHit = ccp(hitPower * approach.x,
                         hitPower * approach.y);
        mp.isHitReady = YES;
        shootButton.visible = YES;
    }
}</pre></div><p>This is the primary method that is shared between the two control schemes. The input parameter, <code class="literal">convLoc</code>, is the converted location from the touch handler, which we will pass here after the necessary conversions to OpenGL space. We determine the <code class="literal">offset</code> as a subtraction of the <code class="literal">aimAtPoint</code> position (the cue ball) from the <code class="literal">convLoc</code> position (touch location). We then use the <code class="literal">ccpNormalize</code> function to convert that <code class="literal">offset</code> into the smallest possible coordinates that still represent the angle desired. This will allow us to control the power of the hit ourselves, without having to compensate for the distance in our calculations.</p><p>Using the <code class="literal">mp</code> variable as a reference to the main playfield layer, we proceed to move the pool cue to the correct location, and we use the <a id="id1734" class="indexterm"/>
<a id="id1735" class="indexterm"/>
<code class="literal">ccpToAngle</code> function to convert the <code class="literal">approach</code> variable to something more useful. This creates a value in radians. We use <code class="literal">CC_RADIANS_TO_DEGREES()</code> <a id="id1736" class="indexterm"/>
<a id="id1737" class="indexterm"/>to convert this to a degree-based angle, and add it to <code class="literal">90</code> (which we need to accommodate the rotation of our graphic for the cue stick), and multiply the whole thing by <code class="literal">-1</code>. This gives us the correct angle we need to make the cue stick point at the cue ball from the point we are currently touching.</p><p>We then calculate the <code class="literal">shotLength</code> value using some simple geometry. If the length is less than <code class="literal">4</code> (too close to the ball) or greater than <code class="literal">75</code> (too far away to be sensible), we reject the hit and hide the cue stick. Otherwise, we calculate the <code class="literal">hitPower</code> (the <code class="literal">shotLength</code> divided by <code class="literal">6</code>, to make it a more sensible power level), and we use that to determine the planned hit. This method does not actually make the shot. Rather, it updates the visuals and generates all the calculations we need to be <a id="id1738" class="indexterm"/>ready to make the shot. The astute reader will also notice that we are setting the <a id="id1739" class="indexterm"/>
<a id="id1740" class="indexterm"/>
<code class="literal">shootButton</code> sprite to be visible. This is only in existence in our two touch control class, so in the case of the one touch control, this call will send a message to a <code class="literal">nil</code> object, which is completely ignored.</p><p>
<strong>Filename:</strong> <code class="literal">OPControlBase.mm</code>
</p><div><pre class="programlisting">-(void) hideCue {
    // Hide the pool cue
    [mp.poolcue setPosition:CGPointZero];
    [mp.poolcue setVisible:NO];
    [mp.poolcue setOpacity:255];
    
    // There is not a valid hit
    // Reset all hit vars
    mp.isHitReady = NO;
    plannedHit = CGPointZero;
    shotLength = 0;
    
    // Hide the shoot button
    shootButton.visible = NO;
}</pre></div><p>The <code class="literal">hideCue</code> method <a id="id1741" class="indexterm"/>
<a id="id1742" class="indexterm"/>takes away the cue stick and resets all variables to baseline values because we don't have any shot to make. This is important to do here, because this will be called not only after the shot is made, but also when the shot is invalidated (stick too far away, and so on). We are again adjusting the <code class="literal">shootButton</code> sprite's <a id="id1743" class="indexterm"/>visibility, if the button's sprite exists. If it doesn't exist, then this line is ignored automatically.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec98"/>One-touch control</h2></div></div></div><p>We will look at the one touch control first. The class <a id="id1744" class="indexterm"/>
<a id="id1745" class="indexterm"/>
<code class="literal">OPControlOneTouch</code> is a subclass of <code class="literal">OPControlBase</code>, but does not have any additional <a id="id1746" class="indexterm"/>
<a id="id1747" class="indexterm"/>
<a id="id1748" class="indexterm"/>variables needed.</p><p>
<strong>Filename:</strong> <code class="literal">OPControlOneTouch.mm</code>
</p><div><pre class="programlisting">-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {
    // Reject touches for now
    if (mp.isTouchBlocked) {
        return NO;
    }
    if (mp.isUserDismissMsg) {
        [mp dismissMessage];
        [mp setIsUserDismissMsg:NO];
        return NO;
    }
    // The next touch returns to the menu
    if (mp.isGameOver) {
        [mp returnToMainMenu];
        return YES;
    }
    // Determine touch position
    CGPoint loc = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:loc];
    // If there was a scratch, the cue is in hand
    if (mp.isBallInHand) {
        cueBallInHand = [CCSprite
             spriteWithSpriteFrameName:@"ball_0.png"];
        [cueBallInHand setPosition:convLoc];
        [mp addChild:cueBallInHand z:10];
        return YES;
    }
    // Check if the touch is on the table
    if (CGRectContainsPoint([[mp table] boundingBox],
             convLoc)) {
        // Store the point we are aiming at
        aimAtPoint = [mp getCueBallPos];
        
        // Update the cue position
        [self updateCueAimFromLoc:convLoc];
        return YES;
    }
    return NO;
}</pre></div><p>We begin the <a id="id1749" class="indexterm"/>
<a id="id1750" class="indexterm"/>
<code class="literal">ccTouchBegan</code> method by checking for a couple of special cases. If <code class="literal">isTouchBlocked</code> is <code class="literal">YES</code> on the main playfield, then we reject the touch. We then check for any user-dismissed messages, to see if we need to clear those messages. If the main playfield has the <code class="literal">isGameOver</code> flag set, then the next <a id="id1751" class="indexterm"/>
<a id="id1752" class="indexterm"/>touch will return to the main menu. We now convert the touch location to the <code class="literal">convLoc</code> variable using the standard coordinate transforms. If the player should have the cue ball in hand (after a scratch), then the touch will create a new <a id="id1753" class="indexterm"/>
<a id="id1754" class="indexterm"/>
<code class="literal">cueBallInHand</code> sprite. Finally, if the <a id="id1755" class="indexterm"/>touch is inside the table, then we set the <code class="literal">aimAtPoint</code> position to be the cue ball's position, and we call the <code class="literal">updateCueAimFromLoc</code> method we discussed earlier.</p><p>
<strong>Filename:</strong> <code class="literal">OPPControlOneTouch.mm</code>
</p><div><pre class="programlisting">-(void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event {
    // Determine touch position
    CGPoint loc = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:loc];
    // If there was a scratch, the cue is in hand
    if (mp.isBallInHand) {
        [cueBallInHand setPosition:convLoc];
        return;
    }
    [self updateCueAimFromLoc:convLoc];
}</pre></div><p>The <code class="literal">ccTouchMoved</code> <a id="id1756" class="indexterm"/>
<a id="id1757" class="indexterm"/>method follows the same approach as the <code class="literal">ccTouchBegan</code> method. If the ball is in hand, then the touch movement will move the <code class="literal">cueBallInHand</code> sprite to the touched location, so the ball will follow the touch. If the ball is not in hand, then we again call <code class="literal">updateCueAimFromLoc</code> to update the cue stick.</p><p>
<strong>Filename:</strong> <code class="literal">OPControlTouchOne.mm</code>
</p><div><pre class="programlisting">-(void) ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {
    // If there was a scratch, the cue is in hand
    if (mp.isBallInHand) {
        [mp createBall:kBallCue AtPos:[cueBallInHand
                                            position]];
        [cueBallInHand removeFromParentAndCleanup:YES];
        mp.isBallInHand = NO;
    }
    // Only make the shot if it is in the legal range
    if (shotLength &gt; 75 || shotLength &lt; 4) {
        // Reject the shot
    }
    else {
        // Take the shot
        [mp makeTheShot];
    }
}</pre></div><p>The final method of our control is <a id="id1758" class="indexterm"/>
<a id="id1759" class="indexterm"/>
<code class="literal">ccTouchEnded</code>, which makes the shot when the touch is lifted. For this controller, we want this to cause the shot to be made. As in the previous two touch methods, we first check if the ball is in hand. If it is, then we call the main playfield to create a new "real" cue ball at that location, and discard the <code class="literal">CCSprite</code> we were using to represent it. Here we also check the <code class="literal">shotLength</code> value to make sure it is not too long, to avoid a shot being made with an invisible cue stick. (Without this check, the shot will still be made, whether you can see the stick or not!) <a id="id1760" class="indexterm"/>Finally, we call to the main playfield to actually make the shot. Before we move on to see the two touch controls, <a id="id1761" class="indexterm"/>
<a id="id1762" class="indexterm"/>let's go back to the main playfield and see what the <code class="literal">makeTheShot</code> method does:</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) makeTheShot {
    // Reset the "first hit" var
    firstHit = kBallNone;
    
    // The controller tells us where to aim
    CGPoint aimPoint = [contr aimAtPoint];

    // Set up the pool cue animation
    CCMoveTo *move = [CCMoveTo actionWithDuration:0.05
                                         position:aimPoint];
    CCCallBlock *hitIt = [CCCallBlock actionWithBlock:^{
        // Get ready to hit the ball
        b2Vec2 impulse = b2Vec2(contr.plannedHit.x,
                                contr.plannedHit.y);
        b2Vec2 aim = b2Vec2(aimPoint.x / PTM_RATIO,
                            aimPoint.y / PTM_RATIO);
        // Hit it
        cueBallBody-&gt;ApplyLinearImpulse(impulse, aim);
    }];
    CCDelayTime *wait = [CCDelayTime actionWithDuration:0.1];
    CCFadeOut *fadeCue = [CCFadeOut actionWithDuration:0.4];
    CCCallBlock *checkTbl = [CCCallBlock actionWithBlock:^{
        pendingTable = YES;
    }];
    CCCallFunc *hideCue = [CCCallFunc actionWithTarget:contr
                            selector:@selector(hideCue)];
    [poolcue runAction:[CCSequence actions:move, hitIt,
                     wait, fadeCue, hideCue, checkTbl,  nil]];
}</pre></div><p>When we make the shot, we set our <code class="literal">aimPoint</code> to match the controller's <code class="literal">aimAtPoint</code> (that is, the cue ball). We create a sequence of actions to give the illusion of hitting the ball with the cue stick. First, we move the stick rapidly at the <code class="literal">aimPoint</code>, then we use a <code class="literal">CCCallBlock</code> action to apply a linear impulse on the ball, and then we fade the cue out. As we have seen before, the <code class="literal">CCCallBlock</code> action here is effectively used to avoid the need to build another method. Everything inside the <code class="literal">^{ }</code> will be executed when this block is called in the sequence. Here it simply sets the <a id="id1763" class="indexterm"/>
<a id="id1764" class="indexterm"/>
<code class="literal">pendingTable</code> variable to <code class="literal">YES</code>.</p><p>The linear impulse is set using the <a id="id1765" class="indexterm"/>
<a id="id1766" class="indexterm"/>
<code class="literal">plannedHit</code> variable from the control class, and it applies it directly at the center of the cue ball. (Yes, pool <a id="id1767" class="indexterm"/>purists, we are aware of the effects of hitting the cue ball off-center. For this game, we have opted to not include any offset controls. It's arcade pool, not a true pool simulator, after all!) You will notice that we add an additional <code class="literal">CCDelayTime</code> action after we fade out the cue, and then set the <code class="literal">pendingTable</code> to <code class="literal">YES</code>. Why do we do this? We need the <code class="literal">pendingTable</code> variable set to <code class="literal">YES</code> so the <code class="literal">checkTable</code> in the <code class="literal">update</code> method will work correctly when the table comes to rest. However, if we set it as soon as this method is called, the table checking will happen before the shot is made, because the table will still technically be "at rest" for the first half second or so of the action. As we need the balls to be moving before we set this variable, embedding it into the action sequence seemed like a natural fit.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Two-touch control</h2></div></div></div><p>Our second control method will use two touches, but <a id="id1768" class="indexterm"/>much of the "plumbing" is very similar <a id="id1769" class="indexterm"/>
<a id="id1770" class="indexterm"/>to the one touch controller. Let's take a look and then discuss:</p><p>
<strong>Filename:</strong> <code class="literal">OPControlTwoTouch.mm</code>
</p><div><pre class="programlisting">-(id) init {
    if(self = [super init]) {
        shootButton = [CCLabelTTF labelWithString:@"Shoot!"
                 fontName:@"Verdana" fontSize:20];
        [shootButton setAnchorPoint:ccp(0.5,0)];
        [shootButton setPosition:ccp(160,0)];
        [shootButton setVisible:NO];
        [self addChild:shootButton z:10];
    }
    return self;
}</pre></div><p>The first difference is that we are using our own <code class="literal">init</code> method for the two touch control. This <code class="literal">init</code>, as you can see, simply creates the <a id="id1771" class="indexterm"/>
<a id="id1772" class="indexterm"/>
<strong>Shoot!</strong> button, and positions it at the bottom center of the screen, and sets its <a id="id1773" class="indexterm"/>
<a id="id1774" class="indexterm"/>
<code class="literal">visible</code> property to <code class="literal">NO</code>. We could recreate it each time we need it, but that seems wasteful, so we build it <a id="id1775" class="indexterm"/>once, and toggle the visible property when we need it.</p><p>The two touch control scheme in action looks as follows:</p><div><img src="img/9007_07_03.jpg" alt="Two-touch control"/></div><p>
<strong>Filename:</strong> <a id="id1776" class="indexterm"/>
<a id="id1777" class="indexterm"/>
<code class="literal">OPControlTwoTouch.mm</code>
</p><div><pre class="programlisting">-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {
    // Reject touches for now
    if (mp.isTouchBlocked) {
        return NO;
    }
    if (mp.isUserDismissMsg) {
        [mp dismissMessage];
        [mp setIsUserDismissMsg:NO];
        return YES;
    }
    // If game over splash is finished, next touch
    // returns to the menu
    if (mp.isGameOver) {
        [mp returnToMainMenu];
        return YES;
    }
    // Determine touch position
    CGPoint loc = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:loc];
    // If there was a scratch, the cue is in hand
    if (mp.isBallInHand) {
        cueBallInHand = [CCSprite
           spriteWithSpriteFrameName:@"ball_0.png"];
        [cueBallInHand setPosition:convLoc];
        [mp addChild:cueBallInHand z:10];
        return YES;
    }
    // If we are tracking the aim
    aimAtPoint = [mp getCueBallPos];
    // Check if the Shoot Button was touched
    if (CGRectContainsPoint([shootButton boundingBox],
                   convLoc)) {
        [mp makeTheShot];
        return YES;
    }
    // Check if the touch is on the table
    if (CGRectContainsPoint([[mp table] boundingBox],
                   convLoc)) {
        // Update the cue position
        [self updateCueAimFromLoc:convLoc];
        return YES;
    }
    return NO;
}</pre></div><p>In <code class="literal">ccTouchBegan</code>, we follow the same code structure up to and including the <code class="literal">isBallInHand</code> variable evaluation. It is after that point that we see the differences. We still set the <code class="literal">aimAtPoint</code> <a id="id1778" class="indexterm"/>
<a id="id1779" class="indexterm"/>variable to the cue ball's position, but then we check to see if the shoot button was touched. If it was, then we call <code class="literal">makeTheShot</code>. <a id="id1780" class="indexterm"/>If there was any other <a id="id1781" class="indexterm"/>
<a id="id1782" class="indexterm"/>touch on the table, then we update the cue stick's position.</p><p>
<strong>Filename:</strong> <code class="literal">OPControlTwoTouch.mm</code>
</p><div><pre class="programlisting">-(void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event {
    // Determine touch position
    CGPoint loc = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:loc];
    
    // If there was a scratch, the cue is in hand
    if (mp.isBallInHand) {
        [cueBallInHand setPosition:convLoc];
        return;
    }
    
    // If not ball in hand, control the cue
    [self updateCueAimFromLoc:convLoc];
}</pre></div><p>This method is exactly the same as the one touch version of this method. It will track the touch, and keep updating the cue stick (and all the power and distance variables) as the touch moves.</p><p>
<strong>Filename:</strong> <code class="literal">OPControlTwoTouch.mm</code>
</p><div><pre class="programlisting">-(void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {
    // If there was a scratch, the cue is in hand
    if (mp.isBallInHand) {
        [mp createBall:kBallCue AtPos:[cueBallInHand position]];
        [cueBallInHand removeFromParentAndCleanup:YES];
        mp.isBallInHand = NO;
    }
}</pre></div><p>Because we are not causing any automatic shot to happen when you release your touch, the only handling we need in the <a id="id1783" class="indexterm"/>
<a id="id1784" class="indexterm"/>
<code class="literal">ccTouchEnded</code> method is the <a id="id1785" class="indexterm"/>handling for the <code class="literal">ballInHand</code> situation.</p><p>That's all we need to do for both control schemes. Looking over the code, there are some similarities where it would be possible to refactor so that the two touch class is a subclass of the one touch class (or vice versa), but we wanted to keep <a id="id1786" class="indexterm"/>
<a id="id1787" class="indexterm"/>the two separate to make it easier to add other control schemes later on without having too much tangled code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>The rules engine</h1></div></div></div><p>We are nearing the end of our journey through the pool hall. <a id="id1788" class="indexterm"/>There is still one gaping hole in our game: the logic of the rules engine and how we use it. Earlier, we saw how we load the rules into our <code class="literal">OPRulesBase</code> class, and we have done a little in the <a id="id1789" class="indexterm"/>
<a id="id1790" class="indexterm"/>
<code class="literal">OPPlayfieldLayer</code> class with using the player goals to update the player's display. We will dig into the rules <a id="id1791" class="indexterm"/>engine with the smaller, simpler methods first.</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(GameMode) getCurrentPlayerGoal {
    if (currentPlayer == 1) {
        return player1Goal;
    } else {
        return player2Goal;
    }
}</pre></div><p>Because every rule in the game of pool will depend on which player is taking their turn (especially in the case of Eight Ball), this is our helper method to determine what the current player's goal really is. This will be used by several of the other methods in this class.</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(BOOL) didSinkLastBall:(NSArray*)ballArray {
    for (OPBall *aBall in ballArray) {
        if (aBall.tag == lastBall) {
            return YES;
        }
    }
    // Last ball not sunk
    return NO;
}</pre></div><p>This is the first of the "asking" methods we talked about earlier. We pass this method a <code class="literal">ballArray</code>, and "ask" if it contains the ball that was <a id="id1792" class="indexterm"/>identified as the <code class="literal">lastBall</code> in the <code class="literal">rules.plist</code>. In Eight Ball, this is the ball numbered 8. In Nine Ball, this is the ball numbered 9. In other games of your own making, it could be anything. You might ask, what exactly is in the <code class="literal">ballArray</code>? When we call this method during the <code class="literal">checkTable</code> method (we'll see this soon), we will be passing the <a id="id1793" class="indexterm"/>
<a id="id1794" class="indexterm"/>
<code class="literal">ballsSunk</code> array to this method, so it knows what balls were sunk during this turn only.</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(BOOL) didSinkCueBall:(NSArray*)ballArray {
    for (OPBall *aBall in ballArray) {
        if (aBall.tag == kBallCue) {
            return YES;
        }
    }
    // Cue ball not sunk
    return NO;
}</pre></div><p>This is the same idea as the <a id="id1795" class="indexterm"/>
<a id="id1796" class="indexterm"/>
<code class="literal">didSinkLastBall</code> method, except this time we are strictly checking to see if the cue ball was sunk, which is a scratch. Now we can move on to the slightly larger, more complex methods.</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(BOOL) isLegalFirstHit:(BallID)firstBall {
    // Reset the value
    isTableScratch = NO;
    
    if (firstBall == kBallNone) {
        // Table scratch if nothing touched
        isTableScratch = YES;
        return NO;
    }
    GameMode currGoal = [self getCurrentPlayerGoal];

    switch (currGoal) {
        case kStripesVsSolids:
            // lastBall cannot be hit first
            return firstBall != kBallEight;
        case kStripes:
            // Striped ball hit first to be legal.
            return firstBall &gt; kBallEight;
        case kSolids:
            // Solid ball hit first to be legal.
            return firstBall &lt; kBallEight;
        case kOrdered:
            if (firstBall == nextOrderedBall || isBreak) {
                // The correct next number was hit first,
                // Or this was the break shot
                isBreak = NO;
                return YES;
            }
            break;
        default:
            // No goal set, all balls are legal
            return NO;
            break;
    }
    return NO;
}</pre></div><p>Here we pass this method the <code class="literal">firstBall</code> variable, which is the ball identified as the first ball hit in the <code class="literal">update</code> method we saw earlier. This is the first ball that the cue ball impacted. If the <code class="literal">firstBall</code> variable is set to the default <code class="literal">kBallNone</code>, it means the cue ball didn't hit any other balls, so this is a table scratch. If it is, <a id="id1797" class="indexterm"/>we store that in the <a id="id1798" class="indexterm"/>
<a id="id1799" class="indexterm"/>
<code class="literal">isTableScratch</code> variable so we can use it later.</p><p>We then run through a <code class="literal">switch</code> statement on the goal for the current player. If the game is still <code class="literal">kStripesVsSolids</code> (so the table is open), then any ball except the ball numbered 8 is legal. If the goal is stripes, the ball number must be above 8. If the goal is solids, the ball number must be a lower number than the 8. Finally, if the game is ordered, then the first ball must be the <code class="literal">nextOrderedBall</code> <em>or</em> <code class="literal">isBreak</code> must be true (that is, it is the break shot, so anything is legal to hit first).</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(BOOL) didSinkValidBall:(NSArray*)ballArray {
    GameMode currGoal = [self getCurrentPlayerGoal];
    
    for (OPBall *aBall in ballArray) {
        switch (currGoal) {
            case kStripes:
                // Striped ball dropped to be legal.
                return aBall.tag &gt; kBallEight;
            case kSolids:
                // Solid ball dropped to be legal.
                return aBall.tag &lt; kBallEight;
            case kOrdered:
                // The correct next number must be sunk.
                return aBall.tag == nextOrderedBall;
            case kStripesVsSolids:
                // lastBall cannot be hit first
                // everything else is valid
                if (aBall.tag == lastBall) {
                    return NO;
                } else {
                    return YES;
                }
                break;
            default:
                // No goal set, all balls are legal
                return NO;
                break;
        }
    }
    return NO;
}</pre></div><p>The <code class="literal">didSinkValidBall</code> <a id="id1800" class="indexterm"/>
<a id="id1801" class="indexterm"/>method is used to parse out whether the player sank a ball that was valid for them. We again receive the <code class="literal">ballsSunk</code> array as a parameter and iterate through all balls in the array. We go through a <code class="literal">switch</code> statement to determine what their current goal is, and go through a similar check to see if the ball was valid. Since we are iterating through the entire array of sunk balls, at least one ball sunk must be valid for the player, in order to return a <code class="literal">YES</code> to the calling method. The one major difference is that here we are also checking to see if the ball sunk has the same value as the <code class="literal">lastBall</code> variable. Unless we are trying to sink the last ball, that is not a <a id="id1802" class="indexterm"/>valid play, so it will return <code class="literal">NO</code>.</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(BOOL) isValidLastBall:(NSArray*)ballsSunk
           withBallsOnTable:(NSArray*)ballsOnTable {
    // Are all other balls for this player sunk already?
    GameMode currGoal = [self getCurrentPlayerGoal];
    
    switch (currGoal) {
        case kSolids:
            for (OPBall *aBall in ballsOnTable) {
                if (aBall.tag &lt; lastBall) {
                    // Solids left on table.  Illegal.
                    return NO;
                }
            }
            return YES;
            break;
        case kStripes:
            for (OPBall *aBall in ballsOnTable) {
                if (aBall.tag &gt; lastBall &amp;&amp; aBall.tag &lt; 100) {
                    // Solids left on table.  Illegal.
                    return NO;
                }
            }
            return YES;
            break;
        case kOrdered:
            for (OPBall *aBall in ballsOnTable) {
               if (aBall.tag != lastBall &amp;&amp; aBall.tag &lt; 100) {
                    // Balls left on table.  Illegal.
                    return NO;
               }
            }
            return YES;
            break;
        default:
            return NO;
            break;
    }
    return NO;
}</pre></div><p>The last major method in this class is <code class="literal">isValidLastBall:withBallsOnTable:</code>. This again follows a similar pattern to the other classes we have reviewed. In this case, we are looking through the balls that are still on the table, rather than the balls that were sunk. This will only be evaluated if the <code class="literal">lastBall</code> was sunk, so we are more concerned with what's left on the table. If we are playing Eight Ball, for example, and the current player is playing solids, then there must not be any ball numbered lower than the <code class="literal">lastBall</code> left on the table. If we are playing an ordered game, then all of the balls on the table must be sunk already.</p><p>There is only one small but very useful method left in the <code class="literal">OPRulesBase</code> class, so let's look at it before we return to the playfield:</p><p>
<strong>Filename:</strong> <code class="literal">OPRulesBase.mm</code>
</p><div><pre class="programlisting">-(void) findNextOrderedBall:(NSArray*)tableBalls {
    // Look for each ball, from lowest to highest
    for (int i = 1; i &lt; 16; i++) {
        for (OPBall *aBall in tableBalls) {
            if (aBall.tag == i) {
                nextOrderedBall = (BallID)i;
                return;
            }
        }
    }
}</pre></div><p>When you're playing an ordered ball game, like Nine Ball, the player must always aim at the lowest numbered ball. Since balls can be sunk out of order, we can not simply increment the ball number as the next ball. Instead, we look for <a id="id1803" class="indexterm"/>each ball, starting at number 1 and continuing to 15, and checking the <code class="literal">tableBalls</code> array to see what the lowest numbered ball on the table really is. When we find a ball, we set that value to the <code class="literal">nextOrderedBall</code> variable, and return control to the calling method.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Putting balls back</h1></div></div></div><p>Before we move to the <a id="id1804" class="indexterm"/>
<a id="id1805" class="indexterm"/>
<code class="literal">checkTable</code> method to tie it all together, we have one more method in the playfield to see. As we have a rule defined as <code class="literal">ReplaceBalls</code>, we need a way to put illegally sunk balls back on the table. This is defined in the plist, so you can set this to your favorite rules. Playing "bar style", this is usually not an option, as coin-operated tables do not allow you to retrieve balls once they are sunk.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void)putBallsBackOnTable:(NSMutableArray*)ballArray {
    // We put the balls we need back on the table,
    // following racking positions, if the rules specify
    if ([rules replaceBalls]) {
        NSMutableArray *deleteArray = 
                 [[NSMutableArray alloc] init];
        
        // First we make sure the cue is NOT in the array
        for (OPBall *aBall in ballArray) {
            // If it is, we add it to the delete array
            if (aBall.tag == kBallCue) {
                [deleteArray addObject:aBall];
            }
        }
        
        // Delete any flagged balls from the array
        [ballArray removeObjectsInArray:deleteArray];
        [deleteArray release];
        CGPoint footSpot = ccp(160,335);
        
        CGPoint r1b1 = ccp(153,348);
        CGPoint r1b2 = ccp(167,348);
        
        CGPoint r2b1 = ccp(146,361);
        CGPoint r2b2 = ccp(160,361);
        CGPoint r2b3 = ccp(174,361);
        
        for (int i = 0; i &lt; [ballArray count]; i++) {
            OPBall *thisBall = [ballArray objectAtIndex:i];
            BallID newBall = (BallID)thisBall.tag;
            
            switch (i) {
                case 0:
                    // foot spot
                    [self createBall:newBall AtPos:footSpot];
                    break;
                case 1:
                    // r1b1
                    [self createBall:newBall AtPos:r1b1];
                    break;
                case 2:
                    // r1b2
                    [self createBall:newBall AtPos:r1b2];
                    break;
                case 3:
                    // r2b1
                    [self createBall:newBall AtPos:r2b1];
                    break;
                case 4:
                    // r2b2
                    [self createBall:newBall AtPos:r2b2];
                    break;
                case 5:
                    // r2b3
                    [self createBall:newBall AtPos:r2b3];
                    break;
                default:
                    break;
            }
        }
    }
}</pre></div><p>We receive the <code class="literal">sunkBalls</code> array as the parameter passed as <code class="literal">ballArray</code> to this method. If the rules specify <code class="literal">replaceBalls</code> = <code class="literal">YES</code>, then we first look through the balls to make sure the cue ball is not in the array. If it is, we delete it from the <code class="literal">ballArray</code>. We then iterate through all balls in the <code class="literal">ballArray</code>, and put them back on the table following the same positioning we used when we first built the rack. If they are too close to other balls on the table, they will be nudged out of the way by Box2D. We have made the decision that there is probably very little likelihood of there being six or more balls that need to be replaced at the same time, so we have capped this method to only replace the first six balls. Realistically, three is probably the highest number of balls we have ever seen that need to be replaced, and that is a rare occurrence.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Checking the table</h1></div></div></div><p>We have finally reached the <a id="id1806" class="indexterm"/>
<a id="id1807" class="indexterm"/>
<code class="literal">checkTable</code> method. As you recall, <a id="id1808" class="indexterm"/>this is called by the <code class="literal">update</code> method after the balls have come to rest after a shot. This is where the rest of the game<a id="id1809" class="indexterm"/> interacts with the rules engine, so we will take this method in pieces.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.m</code> (<code class="literal">checkTable</code>, part 1)</p><div><pre class="programlisting">-(void) checkTable {
    NSInteger currPlayer = [rules currentPlayer];

    BOOL isValidFirst = NO;
    BOOL isValidSink = NO;
    BOOL isLastBall = NO;
    BOOL isTableScratch = NO;
    BOOL isScratch = NO;
    BOOL replaceBalls = NO;
    BOOL isPlayerChange = NO;
    BOOL isValidLastBall = NO;
    BOOL playerLoses = NO;
    
    isValidFirst = [rules isLegalFirstHit:firstHit];
    isValidSink = [rules didSinkValidBall:ballsSunk];
    isTableScratch = [rules isTableScratch];
    isLastBall = [rules didSinkLastBall:ballsSunk];
    isScratch = [rules didSinkCueBall:ballsSunk];
    isValidLastBall = [rules isValidLastBall:ballsSunk
           withBallsOnTable:[self ballSpritesOnTable]];</pre></div><p>We begin by setting up a lot of Boolean variables to hold the "answers" from the method calls to the rules engine. We then go through each of the conditions <a id="id1810" class="indexterm"/>from the rules engine and populate the Boolean variables with the returned values from those methods.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code> (<code class="literal">checkTable</code>, part 2)</p><div><pre class="programlisting">    if (isLastBall) {
        if (isValidLastBall) {
            if (isScratch) {
                // Player loses
                playerLoses = YES;
            } else {
                // Player wins
                isGameOver = YES;
                [self gameOverWithWinner:
                    [rules currentPlayer]];
                return;
            }
        } else {
            // player loses
            playerLoses = YES;
        }
    }
    if (playerLoses) {
        isGameOver = YES;
        [self displayMessage:@"Fail!" userDismiss:NO];
        [self gameOverWithLoser:[rules currentPlayer]];
        return;
    }</pre></div><p>The entirety of the <code class="literal">checkTable</code> method has to be specifically ordered to make sure that the highest priority events are handled first. The first check we make is to see if the <code class="literal">lastBall</code> was sunk. If it was, we then check <code class="literal">isValidLastBall</code> to see if this was a legal sinking of the <code class="literal">lastBall</code>. Then we further check to see if the player scratched at the same time. If it is a valid last ball and the player did not scratch, then the game is over – the current player wins. Otherwise, the player has sunk the <code class="literal">lastBall</code> too early in the game, and they have lost. If the player loses, we display a <a id="id1811" class="indexterm"/>disparaging <a id="id1812" class="indexterm"/>message, and end the game, declaring their opponent a winner.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code> (<code class="literal">checkTable</code>, part 3)</p><div><pre class="programlisting">    if (isScratch) {
        [self displayMessage:@"Scratched" userDismiss:NO];
        [self displayMessage:@"Place the cue ball"
                   userDismiss:NO];
        replaceBalls = YES;
        isBallInHand = YES;
        isPlayerChange = YES;
    }
    else if (isTableScratch) {
        replaceBalls = YES;
        [self displayMessage:@"table scratch" userDismiss:NO];
        isPlayerChange = YES;
    }
    else if (isValidFirst == NO) {
        replaceBalls = YES;
        [self displayMessage:@"wrong first ball hit"
                 userDismiss:NO];
        isPlayerChange = YES;
    }</pre></div><p>If the player scratched (without the last ball being sunk), we let the player know they scratched, and the cue ball is now in hand for the other player. We also identify that we need to <code class="literal">replaceBalls</code> (if the option is set), and that we need to change players.</p><p>If the player did not scratch (cue ball in a pocket), but did table scratch (cue ball did not touch any other balls), then we simply change players. You will notice that this section is a chain of <a id="id1813" class="indexterm"/>
<a id="id1814" class="indexterm"/>
<code class="literal">if…else </code>statements, because these conditions are all mutually exclusive, and we don't need to check the remaining conditions if we have <a id="id1815" class="indexterm"/>met an earlier one.</p><p>Next we check to see if the player did not hit a valid first ball (they hit an opponent's ball first), then we call <code class="literal">replaceBalls</code>, display a message, and indicate a player change.</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code> (<code class="literal">checkTable</code>, part 4)</p><div><pre class="programlisting">    else if (isValidSink) {
        if (currPlayer == 1) {
            [p1BallsSunk addObjectsFromArray:ballsSunk];
            
            // If there is nothing set, choose
            if ([rules player1Goal] == kStripesVsSolids) {
                OPBall *aBall = [p1BallsSunk objectAtIndex:0];
                if (aBall.tag &lt; 8) {
                    [rules setPlayer1Goal:kSolids];
                    [rules setPlayer2Goal:kStripes];
                } else {
                    [rules setPlayer1Goal:kStripes];
                    [rules setPlayer2Goal:kSolids];
                }
            }
        }
        else {
            [p2BallsSunk addObjectsFromArray:ballsSunk];
            
            // If there is nothing set, choose
            if ([rules player2Goal] == kStripesVsSolids) {
                OPBall *aBall = [p2BallsSunk objectAtIndex:0];
                if (aBall.tag &lt; 8) {
                    [rules setPlayer2Goal:kSolids];
                    [rules setPlayer1Goal:kStripes];
                } else {
                    [rules setPlayer2Goal:kStripes];
                    [rules setPlayer1Goal:kSolids];
                }
            }
        }
    } else {
        // Nothing dropped, but the hit was OK.
        // Change players
        isPlayerChange = YES;
    }
    
    // If we need to put balls back on the table
    if (replaceBalls) {
        [self putBallsBackOnTable:ballsSunk];
    }
    
    if (isPlayerChange) {
        [self playerChange];
    }
    
    // Clear the array for the next turn
    [ballsSunk removeAllObjects];
    
    // Update goal displays as needed
    [self updatePlayerGoals];
}</pre></div><p>In this final section of code, if <code class="literal">isValidSink</code> is <code class="literal">YES</code>, then we add the balls sunk by the player to their own <code class="literal">ballsSunk</code> array, and if their goal is still <code class="literal">kStripesVsSolids</code>, then we look at the first ball sunk, and that determines whether they are stripes or solids.</p><p>If nothing of interest happened, we simply change players.</p><p>The remaining checks in this method are to handle the <code class="literal">isPlayerChange</code> and <code class="literal">replaceBalls</code> conditions we set earlier in the method, if needed. <a id="id1816" class="indexterm"/>With that, the core gameplay is complete, and we're ready to play some pool!</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec74"/>The playfield init method</h1></div></div></div><p>We have omitted some small areas of code, specifically those related to the main menu itself. We have built convenience methods to start the <a id="id1817" class="indexterm"/>game with a specified rule set and a specified control scheme. (If you want to see these in detail, <a id="id1818" class="indexterm"/>please refer to the code bundle for this chapter.) There's really nothing that we haven't done before in earlier chapters, but we will briefly go over the <a id="id1819" class="indexterm"/>
<a id="id1820" class="indexterm"/>
<code class="literal">initWithControl:andRules:</code> method of the <code class="literal">OPPlayfieldLayer</code> class, so you can see how we have structured the initialization of the game:</p><p>
<strong>Filename:</strong> <code class="literal">OPPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(id) initWithControl:(NSString*)controls andRules:(NSString*)gameRules {
    if(self = [super init]) {
        size = [[CCDirector sharedDirector] winSize];
        
        // Load the spritesheet
        [[CCSpriteFrameCache sharedSpriteFrameCache]
             addSpriteFramesWithFile:@"poolsheet.plist"];
        poolsheet = [CCSpriteBatchNode
             batchNodeWithFile:@"poolsheet.png"];
        
        // Add the batch node to the layer
        [self addChild:poolsheet z:1];
        
        
        table = [CCSprite
           spriteWithSpriteFrameName:@"table.png"];
        [table setPosition:ccp(size.width/2, size.height/2)];
        [poolsheet addChild:table];
        
        isGameOver = NO;
        isTouchBlocked = NO;
        isHitReady = NO;
        firstHit = kBallNone;
        
        ballsSunk = [[NSMutableArray alloc] init];
        p1BallsSunk = [[NSMutableArray alloc] init];
        p2BallsSunk = [[NSMutableArray alloc] init];
        // Start up the interface control structure
        if ([controls isEqualToString:@"One Touch"]) {
            // Add the controls
            contr = [[OPControlOneTouch alloc] init];
        } else if ([controls isEqualToString:@"Two Touch"])  {
            // Add the controls
            contr = [[OPControlTwoTouch alloc] init];
        } else {
            [self displayMessage:@"Failed To Find Controls"
                        userDismiss:YES];
        }
        contr.mp = self;
        [self addChild:contr z:20];
        
        // Load the rules
        rules = [[OPRulesBase alloc]
                 initWithRulesForGame:gameRules];
 
        // Set up the Box2D world
        [self initWorld];
        
        // Build the table features
        [self createRails];
        [self createPockets];
        
        [self createPoolCue];
        [self createPlayerScores];
        
        // Cue ball setup
        [self displayMessage:@"Place the cue ball"
                     userDismiss:NO];
        isBallInHand = YES;

        // Build the variable elements
        [self createRackWithLayout:rules.rackStyle];
        
        // Update goal displays
        [self updatePlayerGoals];
        
        // Schedule the update method
        [self scheduleUpdate];
    }
    return self;
}</pre></div><p>As you can see, we call our custom <code class="literal">init</code> method with <code class="literal">NSString</code> representations of the control and rule names. We do this for clarity's sake more than for compact programming. As we discussed in the review of the <code class="literal">rules.plist</code> design, we sometimes need to sacrifice some small amount of optimizations in favor of readable code. Isn't it easier to know that the rule set we want is "Eight Ball" rather than game number 1? If these were checks that were happening repeatedly throughout the game, we would never make this performance trade-off. However, in all cases where we have used these strings, the code is run once per game, so the microseconds it takes does not <a id="id1821" class="indexterm"/>
<a id="id1822" class="indexterm"/>impact performance at all.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Summary</h1></div></div></div><p>Well, we have covered a lot of code in this chapter. We have come back to Box2D after being away from it for a while, and we have built a pretty fun pool game. Along the way, we have explored alternate control schemes, how to make the same engine run with different game rules with a minimum of messy code in the core class, and hopefully learned a few new approaches to coding issues, too. Did we build a world-class pool simulator? Absolutely not. We built a fun game that you, the reader, can expand on and explore on your own. There are many ways you could expand on this game. Add new rules to play pool your way. We kept arrays of each player's sunken balls, but we never did anything interesting with them. (That was intentional.) Perhaps you could draw images of the balls from those arrays on the screen to show who sank which balls? The possibilities are there, and by now you should be ready to hack and slash at the code and make it your own.</p><p>In the next chapter we will be building a top-down shooter, using tile maps and onscreen joysticks. It also has a strange fruit versus vegetable theme, just for fun. See you there!</p></div></body></html>