["```swift\nlet array: [Int]\nlet index = array.indexOf(3445)\n```", "```swift\nvar numbers: Set = [1, 1, 2, 3, 3, 4]\n// {2, 3, 1, 4}\n```", "```swift\n    numbers.insert(10)\n    ```", "```swift\n    let number = numbers.contains(10)\n    let foundIndex =  numbers.indexOf(101)\n    let start: SetIndex = numbers.startIndex\n    let first = numbers[start]\n    ```", "```swift\n    let number = numbers.remove(27)\n    let number = numbers.removeAtIndex(numbers.startIndex)\n    ```", "```swift\nlet set = makeRandomSet(size)\nlet otherSet = makeRandomSet(set.count)\n\nset.union(otherSet)\nset.subtract(otherSet)\nset.intersect(otherSet)\nset.exclusiveOr(otherSet)\n```", "```swift\nfunc union<S : SequenceType where Element == Element>(sequence: S) -> Set<Element>\n```", "```swift\nlet set = makeRandomSet(size)\nlet otherSequence = makeRandomArray(set.count)\n\nset.union(otherSequence)\n...\n```", "```swift\nfunc isSubsetOf<S : SequenceType where Element == Element>(sequence: S) -> Bool\n```", "```swift\nlet set = makeRandomSet()\n\nvar otherSequence = Array(set)\notherSequence.append(random())\nset.isSubsetOf(otherSequence)\n\nvar otherSet = set\notherSet.insert(random())\nset.isSubsetOf(otherSequence)\n```", "```swift\nvar capital = [\"Germany\" : \"Berlin\", \"France\"  : \"Paris\"]\n\ncapital[\"Norway\"] = \"Oslo\"\ncapital.removeValueForKey(\"France\")\ncapital[\"France\"] = nil\n\nif let index = capital.indexForKey(\"Spain\") {\n  print(\"found Spain at: \\(index)\")\n}\ncapital.values\n```", "```swift\nlet array = [Int]()\nlet set = Set<Int>()\nlet dic = [String : Int]()\n```", "```swift\nvar array = [Int]()\narray.reserveCapacity(500_000)\n\nvar set = Set<Int>(minimumCapacity: 500_000)\nvar dic = [String : Int](minimumCapacity: 500_000)\n```", "```swift\nvar array = [Int](count: 500_000, repeatedValue: 0)\narray[i] = 10\n```", "```swift\nfunc useCollection<T: CollectionType>(x: T) {\n  print(\"collection has \\(x.count) elements\")\n}\n\nlet array = [1, 2, 3]\nlet set: Set = [2, 2, 3, 4, 5]\nlet dic = [\"A\" : 1, \"B\" : 2]\n\nuseCollection(array)\nuseCollection(set)\nuseCollection(dic)\n```", "```swift\nextension CollectionType {\n  var middle: Self.Index.Distance {\n    return count / 2\n  }\n}\n\narray.middle\nset.middle\ndic.middle\n```", "```swift\nextension Dictionary {\n  var middle: Dictionary.Index.Distance {\n    print(\"Dictionary middle\")\n    return count / 2 + 100 // :( wrong middle index \n  }\n}\ndic.middle // 101 :)\n```", "```swift\narray.isEmpty\nset.isEmpty\ndic.isEmpty\n\narray.dropFirst(1)\nset.dropFirst(1)\ndic.dropFirst(1)\n```", "```swift\nlet array = [1.0, 2.0]\nlet result = array.map { $0 + 3.0 }\nresult // [4.0, 5.0]\n\nlet sum = array.reduce(0, combine: +)\nsum // 3\n```", "```swift\nlet array = [1.0, 2.0]\nvar result = [Double](count: array.count, repeatedValue: 0.0)\n\nvar add = 3.0\nvDSP_vsaddD(array, 1, &add, &result, 1, vDSP_Length(array.count))\nresult // [4.0, 5.0]\n\nvar sum = 0.0\nvDSP_sveD(array, 1, &sum, vDSP_Length(array.count))\nsum // 3\n```", "```swift\nlet array = makeRandomDoubleArray(size)\nvar result = [Double]()\n\nmeasure(\"map\") {\n  result = array.map { $0 + 3.0 }\n}\n\n// vDSP Version\nlet array = makeRandomDoubleArray(size)\nvar result = [Double](count : array.count, repeatedValue : 0.0)\nvar add = 3.0\n\nmeasure(\"vDSP_vsaddD\") {\n  vDSP_vsaddD(array, 1, &add, &result, 1, vDSP_Length(array.count))\n}\n```", "```swift\nimport Surge\nlet numbers = makeRandomDoubleArray(size)\nlet sum = Surge.sum(numbers)\n```"]