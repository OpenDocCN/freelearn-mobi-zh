["```swift\n struct MyWidget: Widget {\n    let kind: String = \"MyWidget\"\n    var body: some WidgetConfiguration { <st c=\"7999\">StaticConfiguration(kind: kind, provider:</st>\n <st c=\"8040\">Provider()) { entry in</st>\n <st c=\"8063\">MyWidgetEntryView(entry: entry)</st>\n <st c=\"8095\">.containerBackground(.fill.tertiary, for:</st>\n <st c=\"8136\">.widget)</st>\n <st c=\"8144\">}</st>\n <st c=\"8146\">.configurationDisplayName(\"My Widget\")</st> .description(\"This is an example widget.\")\n    }\n}\n```", "```swift\n .supportedFamilies([.systemMedium])\n```", "```swift\n struct EventEntry: TimelineEntry {\n    let date: Date\n    let nextEvent: String\n}\nstruct Provider: TimelineProvider {\n    func placeholder(in context: Context) -> EventEntry {\n        EventEntry(date: Date(), nextEvent: \"Loading\")\n    }\n    func getSnapshot(in context: Context, completion:\n      @escaping (EventEntry) -> Void) {\n        let entry = EventEntry(date: Date(), nextEvent: \"Go\n          to the book store\")\n        completion(entry)\n    }\n    func getTimeline(in context: Context, completion:\n      @escaping (Timeline<EventEntry>) -> Void) {\n        let entries: [EventEntry] = getListOfEnties()\n        let timeline = Timeline(entries: entries, policy:\n          .atEnd)\n        completion(timeline)\n    }\n    func getListOfEnties()->[EventEntry] {\n      …\n    }\n}\n```", "```swift\n var date: Date { get }\n```", "```swift\n func getTimeline(in context: Context, completion: @escaping\n    (Timeline<EventEntry>) -> Void) {\n        let entries: [EventEntry] = getListOfEntries()\n        let timeline = Timeline(entries: entries, policy:\n          .atEnd)\n        completion(timeline)\n    }\n```", "```swift\n func placeholder(in context: Context) -> EventEntry {\n        EventEntry(date: Date(), nextEvent: \"English\n          class\")\n    }\n```", "```swift\n func getSnapshot(in context: Context, completion:\n      @escaping (EventEntry) -> Void) {\n        let entry = EventEntry(date: Date(), nextEvent: \"Go\n          to the book store\")\n        completion(entry)\n    }\n```", "```swift\n     struct EventEntry: TimelineEntry {\n        let date: Date\n        let nextEvent: String\n        var relevance: TimelineEntryRelevance? }\n    let entry = EventEntry(date: date, nextEvent: \"Go to\n      the book store\", <st c=\"21823\">relevance:</st>\n    <st c=\"21897\">relevance</st> property to our <st c=\"21923\">EventEntry</st> struct and set a score of <st c=\"21960\">1.0</st>. It is worth noting that any efforts to manipulate the system and set high scores for all entries won’t succeed – Apple has built an algorithm that filters out widgets that have unrealistic values. As with many iOS frameworks, this is a situation where we need to follow the platform’s intended usage guidelines.\n    ```", "```swift\n StaticConfiguration(kind: kind, provider: Provider()) {\n    entry in <st c=\"22809\">MyWidgetEntryView(entry: entry)</st>\n <st c=\"22840\">.containerBackground(.fill.tertiary, for:</st>\n <st c=\"22881\">.widget)</st> }\n```", "```swift\n struct MyWidgetEntryView: View { <st c=\"24370\">let entry:</st> EventEntry\n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"Next Event:\")\n                .font(.headline)\n            Text(<st c=\"24486\">entry.nextEventTitle</st>)\n                .font(.title)\n                .foregroundColor(.blue)\n            Text(\"Time: \\(<st c=\"24562\">entry.nextEventTime</st>)\")\n                .font(.subheadline)\n            Spacer()\n        }\n        .padding()\n    }\n}\n```", "```swift\n @State private var isRed = false\n    var body: some View {\n        VStack {\n            Color(isRed ? .red : .blue)\n                .frame(width: 100, height: 100)\n                .cornerRadius(10)\n            Button(\"Change Color\") { <st c=\"26898\">withAnimation {</st>\n <st c=\"26913\">self.isRed.toggle()</st>\n <st c=\"26933\">}</st> }\n        }\n    }\n```", "```swift\n Color(isRed ? .red : .blue)\n                .frame(width: 100, height: 100)\n                .cornerRadius(10)\n <st c=\"27367\">.contentTransition(.opacity)</st> Button(\"Change Color\") {\n                withAnimation() {\n                    self.isRed.toggle()\n                }\n            }\n```", "```swift\n Text(text)<st c=\"27818\">withAnimation()</st> function, it will change its content with a nice numeric transition (you can try it yourself). If you are not familiar with the <st c=\"27962\">withAnimation</st> function, *<st c=\"27986\">Chapter 6</st>* provides a brief discussion on it.\n\t\t\t<st c=\"28030\">In widgets, all we need to do is to add these to views with content that is based on our timeline entry, and SwiftUI will take care of the</st> <st c=\"28170\">animation itself.</st>\n\t\t\t<st c=\"28187\">Look at our widget again, now</st> <st c=\"28218\">with</st> `<st c=\"28223\">contentTransition</st>`<st c=\"28240\">:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"28469\">Even though</st> <st c=\"28482\">there is no state or</st> `<st c=\"28503\">withAnimation</st>` <st c=\"28516\">function, the</st> `<st c=\"28531\">nextEvent</st>` <st c=\"28540\">title will animate its transition.</st> <st c=\"28576\">The</st> `<st c=\"28580\">contentTransiton</st>` <st c=\"28596\">view modifier has additional options, such as opacity and symbol effects.</st> <st c=\"28671\">Despite the fact that it is not designed explicitly for widgets, it’s the best way to make our widgets</st> <st c=\"28774\">more alive.</st>\n\t\t\t<st c=\"28785\">Customize our widget</st>\n\t\t\t<st c=\"28806\">Up until now, we have discussed widgets based on a</st> `<st c=\"28858\">staticConfiguration</st>`<st c=\"28877\">. The</st> `<st c=\"28883\">staticConfiguration</st>` <st c=\"28902\">set is great for most widgets.</st> <st c=\"28934\">However, there are cases where we</st> <st c=\"28968\">want to provide our users the ability to customize</st> <st c=\"29019\">and configure t</st><st c=\"29034\">heir widgets with</st> <st c=\"29053\">additional entities.</st>\n\t\t\t<st c=\"29073\">Going back to our calendar widget, we want to allow the user to filter the next event information based on a</st> <st c=\"29183\">specific calendar.</st>\n\t\t\t<st c=\"29201\">To do that, we’ll start by creating a new file and add a struct called</st> `<st c=\"29273\">CalendarWidgetIntent</st>` <st c=\"29293\">that conforms</st> <st c=\"29308\">to</st> `<st c=\"29311\">WidgetConfigurationIntent</st>`<st c=\"29336\">.</st>\n\t\t\t<st c=\"29337\">Adding intent</st>\n\t\t\t<st c=\"29351\">A</st> `<st c=\"29354\">WidgetConfigurationIntent</st>` <st c=\"29379\">is an App Intent we can use to configure widgets, and our</st> `<st c=\"29438\">CalendarWidgetIntent</st>` <st c=\"29458\">contains all the configuration information</st> <st c=\"29502\">we need.</st>\n\t\t\t<st c=\"29510\">Here is</st> <st c=\"29519\">a basic</st> `<st c=\"29527\">CalendarWidgetIntent</st>` <st c=\"29547\">implementation:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"29743\">In the preceding code, we can see</st> <st c=\"29778\">two properties:</st>\n\n\t\t\t\t*   `<st c=\"29793\">title</st>` <st c=\"29799\">– The title of the intent.</st> <st c=\"29827\">It is important to note that we don’t see the title in the widget configuration string but rather in Siri Shortcuts.</st> <st c=\"29944\">But we must add it since it is part of the</st> `<st c=\"29987\">AppIntent</st>` <st c=\"29996\">protocol (the</st> `<st c=\"30011\">WidgetConfigurationIntent</st>` <st c=\"30036\">inheritance from</st> `<st c=\"30054\">AppIntent</st>` <st c=\"30063\">protocol).</st>\n\t\t\t\t*   `<st c=\"30074\">calendar</st>`<st c=\"30083\">– This is the widget parameter that allows the user to configure the calendar the event belongs to.</st> <st c=\"30184\">We can see that the</st> `<st c=\"30204\">calendar</st>` <st c=\"30212\">variable is prefixed by the</st> `<st c=\"30241\">@Parameter</st>` <st c=\"30251\">macro, which manages this property for the</st> <st c=\"30295\">user’s configuration.</st>\n\n\t\t\t<st c=\"30316\">Now, let’s add the</st> <st c=\"30336\">App Intent.</st>\n\t\t\t<st c=\"30347\">Adding AppEntity</st>\n\t\t\t<st c=\"30364\">As you</st> <st c=\"30372\">have noticed, the calendar variable is based on a type</st> <st c=\"30427\">called</st> `<st c=\"30434\">CalendarEntity</st>`<st c=\"30448\">.</st>\n\t\t\t<st c=\"30449\">If we want to support our own entity type, it needs to conform to</st> `<st c=\"30516\">AppEntity</st>`<st c=\"30525\">. Let’s see the</st> `<st c=\"30541\">CalendarEntity</st>` <st c=\"30555\">type implementation:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"30852\">The</st> `<st c=\"30857\">CalendarEntity</st>` <st c=\"30871\">struct represents the data model for the</st> `<st c=\"30913\">intent</st>` <st c=\"30919\">parameter.</st> <st c=\"30931\">First, we need to add the parameters we need in order to support the item when displaying</st> <st c=\"31021\">the widget, such as</st> `<st c=\"31041\">id</st>` <st c=\"31043\">and</st> `<st c=\"31048\">name</st>`<st c=\"31052\">. Next, we’ll add some representation variables, such as</st> `<st c=\"31109\">typeDisplayRepresentation</st>` <st c=\"31134\">and</st> `<st c=\"31139\">displayRepresentation</st>`<st c=\"31160\">.</st>\n\t\t\t<st c=\"31161\">Finally, we’ll add a static variable that handles the actual data fetching, and that’s the</st> `<st c=\"31253\">defaultQuery</st>` <st c=\"31265\">property.</st> <st c=\"31276\">Remember that the user needs to select the desired calendar based on a list of calendars.</st> <st c=\"31366\">To do that, we need to provide</st> *<st c=\"31397\">WidgetKit</st>* <st c=\"31407\">with a way to query our data to support the selection</st> <st c=\"31461\">UI flow.</st>\n\t\t\t<st c=\"31469\">So, what does the query look like?</st> <st c=\"31505\">Let’s</st> <st c=\"31511\">find out.</st>\n\t\t\t<st c=\"31520\">Building the EntityQuery</st>\n\t\t\t<st c=\"31545\">Sometimes, having a</st> <st c=\"31566\">list of options for the user relies on a data store, and sometimes on</st> <st c=\"31636\">static information.</st>\n\t\t\t<st c=\"31655\">Regardless of the model type, if we want to provide options to the user, we need to have a simple and effective interface to work with, and that’s what the</st> `<st c=\"31812\">EntityQuery</st>` <st c=\"31823\">protocol</st> <st c=\"31833\">is for.</st>\n\t\t\t<st c=\"31840\">In our current</st> `<st c=\"31856\">AppIntent</st>` <st c=\"31865\">example, we let the user choose one of its calendars, so we need to build a struct named</st> `<st c=\"31955\">CalendarQuery</st>` <st c=\"31968\">that conforms</st> <st c=\"31983\">to</st> `<st c=\"31986\">EntityQuery</st>`<st c=\"31997\">.</st>\n\t\t\t<st c=\"31998\">Let’s look</st> <st c=\"32010\">at a simple</st> `<st c=\"32022\">CalendarQuery</st>` <st c=\"32035\">example:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"32352\">Assume that</st> `<st c=\"32365\">allCalendars</st>` <st c=\"32377\">is an array containing all the</st> <st c=\"32409\">user calendars.</st>\n\t\t\t<st c=\"32424\">In this case,</st> `<st c=\"32439\">CalendarQuery</st>` <st c=\"32452\">implements three methods.</st> <st c=\"32479\">Let’s quickly go</st> <st c=\"32496\">over them:</st>\n\n\t\t\t\t*   `<st c=\"32506\">entities(for identifiers:)</st>` <st c=\"32533\">– This function returns calendar entities based on a list of IDs.</st> *<st c=\"32600\">WidgetKit</st>* <st c=\"32610\">uses it to show the</st> <st c=\"32630\">selected calendar</st>\n\t\t\t\t*   `<st c=\"32647\">suggestedEntities()</st>` <st c=\"32667\">– This returns the list of entities in the</st> <st c=\"32711\">pop-up menu</st>\n\t\t\t\t*   `<st c=\"32722\">defaultResult()</st>` <st c=\"32738\">– This returns the value when nothing</st> <st c=\"32777\">is selected</st>\n\n\t\t\t<st c=\"32788\">Now, let’s</st> <st c=\"32800\">see how it looks (</st>*<st c=\"32818\">Figure 5</st>**<st c=\"32827\">.3</st>*<st c=\"32829\">):</st>\n\t\t\t![Figure 5.3: The widget configuration menu](img/B21795_05_3.jpg)\n\n\t\t\t<st c=\"32885\">Figure 5.3: The widget configuration menu</st>\n\t\t\t<st c=\"32926\">In</st> *<st c=\"32930\">Figure 5</st>**<st c=\"32938\">.3</st>*<st c=\"32940\">, we can see the</st> `<st c=\"33153\">Bool</st>` <st c=\"33157\">or</st> `<st c=\"33161\">String</st>`<st c=\"33167\">, and</st> *<st c=\"33173\">WidgetKit</st>* <st c=\"33183\">will create their corresponding</st> <st c=\"33215\">input control.</st>\n\t\t\t<st c=\"33229\">Let’s flip to the other side now and go to the widget UI to use the</st> `<st c=\"33298\">AppEntity</st>` <st c=\"33307\">the</st> <st c=\"33312\">user selected.</st>\n\t\t\t<st c=\"33326\">Using the AppEntity in our Widget</st>\n\t\t\t<st c=\"33360\">Going back</st> <st c=\"33372\">to our widget code, let’s examine the widget configuration</st> <st c=\"33431\">code again:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"33606\">The</st> `<st c=\"33611\">AppIntentConfiguration</st>` <st c=\"33633\">struct has an important property, which is the intent type it uses, and in this case, it is</st> `<st c=\"33726\">CalendarWidgetIntent</st>`<st c=\"33746\">. If we go back to the</st> *<st c=\"33769\">Customize our widget</st>* <st c=\"33789\">section, we can see that</st> `<st c=\"33815\">CalendarWidgetIntent</st>` <st c=\"33835\">contains all the information we need to present our widget according to the</st> <st c=\"33912\">user configuration.</st>\n\t\t\t<st c=\"33931\">Indeed, the timeline provider is now conforming to a different protocol,</st> `<st c=\"34005\">AppIntentTimelineProvider</st>`<st c=\"34030\">, which supports the intent configuration now.</st> <st c=\"34077\">Let’s see how it creates</st> <st c=\"34102\">a timeline:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"34290\">We can see that the timeline function inside</st> `<st c=\"34336\">ConfigurableProvider</st>` <st c=\"34356\">now receives the configuration parameter.</st> <st c=\"34399\">From this point, all we need to do is use the information we have inside the configuration and create the relevant</st> <st c=\"34514\">timeline entries.</st>\n\t\t\t<st c=\"34531\">By now, we know how to set up a new widget, animate it, create its timeline, and even let the user configure it.</st> <st c=\"34645\">Next, we’ll learn how to ensure our widgets stay up</st> <st c=\"34697\">to date.</st>\n\t\t\t<st c=\"34705\">Keeping our widgets up to date</st>\n\t\t\t<st c=\"34736\">We have learned that we need to look ahead and create a timeline with different entries and dates to</st> <st c=\"34838\">keep our widget up to date.</st> <st c=\"34866\">But how does our widget work under</st> <st c=\"34901\">the hood?</st>\n\t\t\t<st c=\"34910\">Widgets don’t get any running time – once we generate the timeline entries,</st> *<st c=\"34987\">WidgetCenter</st>* <st c=\"34999\">generates their different views, keeps them persistently, and just switches them according to the</st> <st c=\"35098\">provided timeline.</st>\n\t\t\t<st c=\"35116\">So, there’s no way to update our widget without reloading the timeline, and when we created our timeline, we had to define its</st> <st c=\"35244\">reload policy:</st>\n\n```", "```swift\n WidgetCenter.shared\n```", "```swift\n func getConfigurations() { <st c=\"36157\">WidgetCenter.shared.getCurrentConfigurations</st> { result\n      in\n        if let widgets = try? result.get() {\n            // handle our widgets\n        }\n    }\n}\n```", "```swift\n WidgetCenter.shared.reloadTimelines(ofKind: \"MyWidget\")\n```", "```swift\n func getTimeline(in context: Context, <st c=\"38465\">getTimeline</st> function is an asynchronous function. It means that when we build our timeline, we can perform async operations such as open URL sessions and fetching data.\n\t\t\t<st c=\"38633\">Let’s see an example of requesting the next</st> <st c=\"38678\">calendar events:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"39230\">The</st> `<st c=\"39235\">getTimeline</st>` <st c=\"39246\">function implementation is similar to the previous</st> `<st c=\"39298\">getTimeline</st>` <st c=\"39309\">implementation we saw in the</st> *<st c=\"39339\">Generating a timeline</st>* <st c=\"39360\">section, and this time, we are fetching the</st> <st c=\"39405\">events using the</st> `<st c=\"39422\">calendarService</st>` <st c=\"39437\">instance.</st> <st c=\"39448\">The</st> `<st c=\"39452\">calendarService</st>` <st c=\"39467\">goes to our server and returns an array of events.</st> <st c=\"39519\">Afterward, we loop the events, generate timeline entries, and return a timeline using the</st> `<st c=\"39609\">completion</st>` <st c=\"39619\">block.</st>\n\t\t\t<st c=\"39626\">Up until now, we have seen how to create a widget, animate it, and ensure it is updated as much as we can.</st> <st c=\"39734\">But if we want to make our widget shine, we need to add some</st> <st c=\"39795\">user-interactive capabilities.</st>\n\t\t\t<st c=\"39825\">Interacting with our widget</st>\n\t\t\t<st c=\"39853\">Besides</st> <st c=\"39862\">providing us with a glance at our app information, widgets are a great way to open our app in a specific location or manipulate data without even opening</st> <st c=\"40016\">the app.</st>\n\t\t\t<st c=\"40024\">As mobile developers, we sometimes wonder why implementing user interaction with a widget is such a big deal.</st> <st c=\"40135\">After all, our users interact with our app daily, so why is it such a problem?</st> <st c=\"40214\">But when we remember that widgets don’t really run, we can understand</st> <st c=\"40284\">the challenge.</st>\n\t\t\t<st c=\"40298\">The most basic way we have to allow interaction with our widgets is by using</st> <st c=\"40376\">deep links.</st>\n\t\t\t<st c=\"40387\">Opening a specific screen using links</st>\n\t\t\t<st c=\"40425\">If you are not familiar with the concept of deep links, now is the time to straighten things out.</st> <st c=\"40524\">A deep</st> <st c=\"40531\">link is a link that opens our app on a specific screen.</st> <st c=\"40587\">Today’s deep links format is similar to website URLs.</st> <st c=\"40641\">For example, a deep link that opens our app in a specific calendar event screen can look something</st> <st c=\"40740\">like this:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"40800\">To do that, the app needs to do</st> <st c=\"40833\">three things:</st>\n\n\t\t\t\t*   *<st c=\"40846\">Register to that specific domain</st>* <st c=\"40879\">by placing a special JSON file on the</st> <st c=\"40918\">relevant server</st>\n\t\t\t\t*   <st c=\"40933\">Add the domain</st> *<st c=\"40949\">entitlement</st>* <st c=\"40960\">to</st> <st c=\"40964\">our app</st>\n\t\t\t\t*   <st c=\"40971\">Respond to</st> *<st c=\"40983\">launching the app from a deep link</st>*<st c=\"41017\">, parse the URL, and direct the user to the corresponding location within</st> <st c=\"41091\">the app</st>\n\n\t\t\t<st c=\"41098\">To learn more about deep links, I recommend reading about it in the Apple</st> <st c=\"41173\">Developer website:</st>\n\t\t\t[<st c=\"41191\">https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content</st>](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content)\n\t\t\t<st c=\"41290\">Going back to our topic, let’s see an example of adding a deep link to our</st> `<st c=\"41366\">Next</st>` `<st c=\"41371\">Event</st>` <st c=\"41376\">widget:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"41663\">In the</st> <st c=\"41671\">preceding code example, we can see that we added a view modifier called</st> `<st c=\"41743\">widgetURL</st>` <st c=\"41752\">to the</st> `<st c=\"41760\">Next Event</st>` `<st c=\"41770\">Text</st>` <st c=\"41775\">component.</st>\n\t\t\t<st c=\"41786\">The</st> `<st c=\"41791\">Next Event</st>` `<st c=\"41801\">Text</st>` <st c=\"41806\">component is indeed the view that accepts the user’s touch and opens the app in the specific deep link.</st> <st c=\"41911\">But when the widget is small (</st>`<st c=\"41941\">.systemSmall</st>`<st c=\"41953\">), we can add only one deep link that is acceptable in the</st> <st c=\"42013\">whole widget.</st>\n\t\t\t<st c=\"42026\">In widgets with medium and large sizes, we can add multiple links to</st> <st c=\"42096\">multiple components.</st>\n\t\t\t<st c=\"42116\">It is worth noting that in terms of security, deep links work even when the device is locked, but require</st> *<st c=\"42223\">FaceID</st>* <st c=\"42229\">or passcode when tapping</st> <st c=\"42255\">on them.</st>\n\t\t\t<st c=\"42263\">In iOS 17, deep links are not the only option we have to allow users to interact with our widget, as it is possible to add buttons and toggles</st> <st c=\"42407\">as well.</st>\n\t\t\t<st c=\"42415\">Adding interactive capabilities</st>\n\t\t\t<st c=\"42447\">Deep links</st> <st c=\"42459\">in widgets are great, but they have one big problem – tapping on the widget always opens the app.</st> <st c=\"42557\">But, sometimes, we want to update data or confirm something without entering the app.</st> <st c=\"42643\">For example, maybe we want to accept a calendar invitation, approve a payment, or mark a task</st> <st c=\"42737\">as completed.</st>\n\t\t\t<st c=\"42750\">Because</st> <st c=\"42759\">widgets don’t actually run, it’s a challenge to respond to a user interaction.</st> <st c=\"42838\">Fortunately, there is a solution that we have already encountered in configurable widgets, and that’s</st> <st c=\"42940\">App Intents.</st>\n\t\t\t<st c=\"42952\">Using App Intents to add interactive widgets</st>\n\t\t\t<st c=\"42997\">App Intents</st> <st c=\"43010\">made especially for this kind of use case – to allow runtime for</st> <st c=\"43075\">specific actions.</st>\n\t\t\t<st c=\"43092\">So, how do App Intents help us?</st> <st c=\"43125\">Let’s look at</st> *<st c=\"43139\">Figure 5</st>**<st c=\"43147\">.4</st>*<st c=\"43149\">:</st>\n\t\t\t![Figure 5.4: App Intent event flow](img/B21795_05_4.jpg)\n\n\t\t\t<st c=\"43315\">Figure 5.4: App Intent event flow</st>\n\t\t\t<st c=\"43348\">In</st> *<st c=\"43352\">Figure 5</st>**<st c=\"43360\">.4</st>*<st c=\"43362\">, we can see that the first stage is tapping on a button inside the widget.</st> <st c=\"43438\">Starting from iOS 17, the</st> *<st c=\"43464\">WidgetKit</st>* <st c=\"43474\">framework has its own type of button, which can be linked to a specific</st> <st c=\"43546\">App Intent:</st>\n\n```", "```swift\n struct MyWidgetIntent: AppIntent {\n    init() {\n    }\n    var eventID: String = \"\"\n    init(eventID: String) {\n        self.eventID = eventID\n    }\n    static var title: LocalizedStringResource = \"Changing '\n      event alarm settings.\" func perform() async throws -> some IntentResult {\n        // working with EventKit and updating the event alarm data. return .result()\n    }\n}\n```", "```swift\n struct MaindoorControl: ControlWidget {\n    var body: some ControlWidgetConfiguration {\n        StaticControlConfiguration(\n            kind: \"com.avitsadok.MaindoorControl\"\n        ) {\n// rest of the widget goes here\n        }\n    }\n}\n```", "```swift\n struct MaindoorControl: ControlWidget {\n    var body: some ControlWidgetConfiguration {\n        StaticControlConfiguration(\n            kind: \"com.avitsadok.MaindoorControl\"\n        ) { <st c=\"47918\">ControlWidgetToggle(</st>\n <st c=\"47938\">\"Main door control\",</st>\n <st c=\"47959\">isOn: HouseManager.shared.isOpen,</st>\n <st c=\"47993\">action: MaindoorIntent()</st>\n <st c=\"48018\">) { isOn in</st>\n <st c=\"48030\">Label(isOn ?</st> <st c=\"48044\">\"Opened\" : \"Closed\",</st>\n <st c=\"48064\">systemImage: isOn ?</st>\n <st c=\"48084\">\"door.left.hand.open\" :</st>\n <st c=\"48108\">\"door.left.hand.closed\")</st>\n <st c=\"48133\">}</st> }\n    }\n}\n```", "```swift\n struct MaindoorIntent: SetValueIntent {\n    static let title: LocalizedStringResource = \"Maindoor\n      opening\"\n    @Parameter(title: \"is open\")\n    var value: Bool\n    func perform() throws -> some IntentResult {\n      HouseManager.shared.isOpen = value\n        return .result()\n    }\n}\n```", "```swift\n\n```", "```swift\n\n```"]