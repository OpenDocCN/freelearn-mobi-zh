- en: Building an Android Application – Tetris
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a concise look at crucial topics pertaining
    to the core Kotlin language. These topics took us through the fundamentals of
    Kotlin as well as the powerful object-oriented programming approach to software
    development it puts at our disposal. In this chapter, we will put the knowledge
    we gained from the previous chapter to good use by developing an Android application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Android application components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing layouts with XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String and dimension resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling input events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn these topics through a hands-on approach by implementing the layouts
    and components of a classic game, Tetris, in the form of an Android application.
    As we are developing the game in the form of an Android application, before proceeding
    further, it is imperative that we do a brief overview of the Android operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Android – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is a Linux-based mobile operating system developed and maintained by
    Google and created primarily to power smart mobile devices such as mobile phones
    and tablets. The primary interface to interact with the Android operating system
    is **Graphic User Interface** (**GUI**)-based. Users of devices powered by Android
    manipulate and interact with the operating system environment primarily via a
    visual touch-based interface by performing gestures such as taps and swipes on
    the display.
  prefs: []
  type: TYPE_NORMAL
- en: Software can be installed on the Android OS in the form of apps. An app is an
    application that runs within an environment and performs one or more tasks for
    the achievement of a goal or a collection of goals. The ability to install applications
    on mobile devices presented a huge opportunity to both users and application developers.
    Users take advantage of the features provided by apps to achieve day-to-day goals
    and developers take advantage of the demand for software applications by developing
    apps that meet user needs and perhaps make a profit.
  prefs: []
  type: TYPE_NORMAL
- en: To developers, Android provides a vast array of tools and utilities for the
    development of high-performance applications. These applications can target different
    markets such as recreation, enterprise, and e-commerce. Applications can also
    come in the form of games.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, we will explore a number of these tools and
    utilities, which are provided by the Android application framework, in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Application components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Android application framework provides us with a number of components we
    can utilize to build a user interface for the *Tetris* application. A component
    in Android is a reusable program template or object that can be used to define
    aspects of an application. Some important components provided by the Android application
    framework are:'
  prefs: []
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intent filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An activity is an Android component that is central to the implementation of
    application flow and component-to-component interaction. Activities are implemented
    in the form of classes. An instance of an activity is used by the Android system
    for code initiation.
  prefs: []
  type: TYPE_NORMAL
- en: An activity is important in the creation of applications' user interfaces. It
    provides a window upon which user interface elements can be drawn. Simply put,
    application screens are created with the use of activities in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An intent facilitates inter-activity communication. Intents can be considered
    messengers within an Android application. They are messaging objects that are
    used to request actions from application components. Intents can be used for actions,
    such as requesting the start of an activity and delivering broadcasts, within
    the Android system environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of intents. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit intents**: These are messenger objects that do not specifically
    identify an application component to perform an action, but specify an action
    to be performed and allow a component that may exist in another application to
    perform the action. The components that can handle an action requested implicitly
    are identified by the Android system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicit intents**: These intents specify explicitly the application component
    that should perform an action. These can be used to perform actions, such as starting
    an activity, within your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f0e21b8-c0d5-40f4-967a-dbb1591fcf97.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Intent filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An intent filter is a declaration in the application manifest file that specifies
    the type of intent that a component would like to receive. This is useful in a
    number of cases, such as a scenario in which you want an activity in your application
    to handle a specific action requested by components in another application. For
    this case, an intent filter can be declared in the application manifest for the
    activity you want to handle the external request. If you do not want an activity
    to handle implicit intents, you simply do not declare an intent filter for it.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fragment is an application component that represents a part of a user interface
    that exists within an activity. Similar to an activity, a fragment possesses a
    layout that can be modified and is drawn on the activity window.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike most other components, a service does not provide a user interface. Services
    are used to perform background processes in an application. A service does not
    need the application that created it to be in the foreground to run.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A loader is a component that enables the loading of data from a data source,
    such as a content provider, for later display in an activity or fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Content providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These components help an application control access to data resources stored
    either within the application or within another app. In addition, a content provider
    facilitates the sharing of data with another application via an exposed application
    programming interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0d35c91-ba13-4e6f-bb8e-258a71de14b5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding Tetris
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before attempting to develop the *Tetris* game as an Android application, we
    need to understand the game, its rules, and its constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tetris is a matching puzzle video game that makes use of tiles. The name *Tetris* is
    derived from the words tetra – the Greek numerical prefix for four – and tennis.
    The tiles in Tetris combine to make up tetrominoes which are geometric shapes
    composed of four squares connected orthogonally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab15a72f-e060-49d0-b916-5c009ee66f94.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tetris tetrominoes
  prefs: []
  type: TYPE_NORMAL
- en: In Tetris, a random sequence of tetrominoes fall down upon a playing field.
    These tetrominoes can be manipulated by the player. A number of motions can be
    performed on each tetromino piece. Pieces can be moved to the left, to the right,
    and rotated. In addition, the speed of descent of each piece can be sped up. The
    objective of the game is to create an uninterrupted horizontal line of ten cells
    with the descending pieces. When such a line is created, the line is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how Tetris works, let's get into the specifics
    in order to build the user interface of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, the user interface is the means by which the user
    of an application interacts with the app. It cannot be overstated how important
    the user interface of an application is. Before embarking on the process of actually
    coding a user interface, it may be helpful to make a graphical representation
    of the UI to be implemented. This can be done with different tools, such as Photoshop,
    but for this case, a simple sketch is sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/616a3515-92ed-4bb0-9961-2dcf96290bed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding sketch, we can see that we will need two distinct screens
    in this application: the landing screen and the game screen where the actual gameplay
    will happen. These two screens will require two separate activities. We''ll call
    these two activities `MainActivity` and `GameActivity`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainActivity` will serve as the entry point of our application. It will contain
    the user interface and all logic pertaining to our landing screen. As we can observe
    in our sketch, the UI of the landing screen contains the application title, a
    view that shows the user their current high score, and three buttons performing
    different actions. The **NEW GAME** button, as the name implies, will lead the
    user to the activity in which the gaming takes place. **RESET SCORE** will reset
    the score of the user to zero and **EXIT** will close the application.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameActivity` will be the programmatic template of the game screen. In this
    activity, we will create the views and logical interactions between the user and
    the game. The UI of this activity contains an action bar with the title of the
    application displayed on it, two text views that display the current score of
    the user and their high score, and a layout element in which the Tetris gameplay
    will happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the activities that are needed in this application and have
    a rough idea of how we want our user interface to look when viewed by the user,
    we can get into the actual implementation of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android project in Android Studio and give it the name `Tetris
    no activity`. Once the IDE window opens, you will notice that the project structure
    is similar to the one in [Chapter 1](kt-prog-ex_ch01.html), *The Fundamentals*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is add `MainActivity` to our project. We want
    `MainActivity` to be an empty activity. We can add `MainActivity` to our project
    by right-clicking on our source package and selecting New | Activity | Empty Activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/660f01bc-7f6d-41b1-92f6-ed430a78bdab.png)'
  prefs: []
  type: TYPE_IMG
- en: Name the activity `MainActivity`, and ensure the Generate Layout File, Launcher
    Activity, and Backwards Compatibility (AppCompat) checkboxes are ticked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon the addition of the activity to your project, navigate to its layout resource
    file. It should look similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Line one of the resource file specifies the XML version utilized in the file
    as well as the character encoding used. `utf-8` is used for character encoding
    in this file. **UTF** stands for **Unicode Transformation Format**. It is an encoding
    format that can be as compact as **American Standard Code for Information Interchange**
    (**ASCII**)—the most common character format for text files—and can contain any
    Unicode character. The next eight lines define a `ConstraintLayout` to be rendered
    in the UI of `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the `ConstraintLayout` in a bit more detail before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: ConstraintLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `ConstraintLayout` is a type of view group that allows the flexible positioning
    and resizing of application widgets. Various types of constraints can be used
    on a `ConstraintLayout`. Some examples are.
  prefs: []
  type: TYPE_NORMAL
- en: Margins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A margin is a space that exists between two layout elements. When a side margin
    is set on an element, it is applied to its corresponding layout constraints, if
    one is available, by adding the margin as a space between the target side and
    the source side (the side of the element adding the margin):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/327b1c36-3ba4-442c-94ad-e1636cf52590.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chains are constraints that provide group-like behavior in a single axis. The
    axis may be either horizontal or vertical:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b6ac711-a5da-410c-8181-940451fe853e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A collection of elements is a chain if they are all connected bidirectionally.
  prefs: []
  type: TYPE_NORMAL
- en: Dimension constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These constraints concern the sizes of widgets placed in a layout. Dimension
    constraints can be set on widgets, and using a `ConstraintLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb8e12b-2dee-4c96-9ad3-b8a9eba807e9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A dimension constraint
  prefs: []
  type: TYPE_NORMAL
- en: 'The dimensions of a widget can be specified by the use of `android:layout_width`
    and `android:layout_height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In a number of cases, you may want a widget to have the same dimension as its
    parent view group. This can be done by assigning the `match_parent` value to the
    dimension attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you want a widget''s dimensions not to be fixed but rather
    to wrap the elements contained within it, the `wrap_content` value should be assigned
    to the dimension attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a better understanding of the `ConstraintLayout`, as well
    as widget constraints, let''s take another look at our `activity_main.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the `ConstraintLayout` element, we can immediately notice that its
    width and height dimensions have been set to `match_parent`. This means that the
    `ConstraintLayout` dimensions are set to match those of the current window. The
    attributes that have the `xmlns: prefix` are used to define XML namespaces. Values
    set for all XML namespace attributes are namespace URIs. **URI** is short for
    **Uniform Resource Identifier** and, as the name suggests, it identifies a resource
    required by the namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: The `tools:context` attribute is typically set to the root element in an XML
    layout file and specifies the activity that the layout is associated with—in this
    case, `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand what''s going on in the `activity_main.xml` layout,
    let''s add some layout elements to it. From our sketch, we can see that all layout
    elements are placed in a vertical arrangement. We can do this with the use of
    a `LinearLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we want the `LinearLayout` to have the same dimensions as its parent, we
    set both `android:layout_width` and `android:layout_height` to `match_parent`.
    Next, we specify the edge constraints of the `LinearLayout` using the `app:layout_constraintBottom_toBottomOf`,
    `app:layout_constraintLeft_toLeftOf`, `app:layout_constraintRight_toRightOff`,
    and `app:layout_constraintTop_toTopOf` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '`app:layout_constraintBottom_toBottomOf`: Aligns the bottom edge of the element
    to the bottom of another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app:layout_constraintLeft_toLeftOf`: Aligns the left edge of an element to
    the left of another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app:layout_constraintRight_toRightOf`: Aligns the right edge of an element
    to the right of another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app:layout_constraintTop_toTopOf`: Aligns the top of an element to the top
    of another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, all edges of the `LinearLayout` are aligned to the edge of its
    parent—the `ConstraintLayout`. `android:layout_marginVertical` adds a margin of
    `16dp` to the top and bottom of the element.
  prefs: []
  type: TYPE_NORMAL
- en: Defining dimension resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically in a layout file, we can have numerous elements that specify the
    same constraint values to attributes. Such values should be added to a dimensions
    resource file. Let''s go ahead and create a dimensions resource file now. In your
    application project view, navigate to res | values and create a new value resource
    file in the directory with the name `dimens`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d00b3027-dcc5-4e87-b5dc-7ed1e81add26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Leave all other file attributes at their default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d65e90ef-cba6-421f-b705-80e468e39fb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the file upon its creation. Its content should be similar to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of `dimens.xml` declares the XML version and character encoding
    used within the file. The second line contains a `<resources>` resources tag.
    Our dimensions will be declared within this tag. Add a few dimension values, as
    demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: New dimensions are declared using the `<dimen>` tag. Dimension names should
    typically be written in snake case. The value for a dimension is added within
    the opening `<dimen>` and closing `</dimens>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added a few dimensions, we can use them in our linear layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've gotten our `LinearLayout` view group set up and now we need to add the
    required layout views to it. Before we do that, we need to understand the concepts
    of views and view groups.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view is a layout element that occupies a set area of the screen and is responsible
    for drawing and event handling. View is the base class for UI elements or widgets
    such as text fields, input fields, and buttons. All views extend the View class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views can be created within an XML layout in a source file. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides creating views directly in a layout file, they can also be created
    programmatically within program files. For example, a text view can be made by
    creating an instance of the `TextView` class and passing a `context` to its constructor.
    This is demonstrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: View groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view group is a special kind of view that is capable of containing views.
    A view group that contains one or more views is commonly referred to as a parent
    view and the views contained as its children views. A view group is the parent
    class of several other view containers. Some examples of view groups are `LinearLayout`,
    `CoordinatorLayout`, `ConstriantLayout`, `RelativeLayout`, `AbsoluteLayout`, `GridLayout`,
    and `FrameLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'View groups can be created within an XML layout in a source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to views, view groups can be created programmatically within component
    classes. In the following code snippet, a linear layout is made by creating an
    instance of the `LinearLayout` class and passing the `context` of `MainActivity`
    to its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Having understood the concepts of views and view groups, we can add a few more
    views to our layout. Text views are added to a layout with the `<TextView>` element
    and buttons are added with the `<Button>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As our sketch outlines, we have added two text views to hold the application
    title and the high score, as well as three buttons to execute the required actions.
    We have made use of two new attributes. These attributes are `android:id` and
    `android:layout_weight`. The `android:id` attribute is used to set a unique identifier
    for an element in a layout. No two elements in the same layout can have the same
    ID. The `android:layout_weight` attribute is used to specify a precedence value
    for how much space a view should take in its parent container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, two child views are contained by a linear layout.
    The button explicitly sets both its dimensional constraints to `70dp` and `40dp`.
    The view, on the other hand, has its width explicitly set to `70dp` and has its
    height set to `0dp`. As a result of the presence of an `android:layout_weight`
    attribute set to `1`,  the view's height is set to cover all remaining space in
    the parent view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand fully what is going on in our layout, we can take a
    look at the layout design preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/057ee4c5-fa77-4f91-b564-96a0ef0fa8cd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that something seems off. Unlike our sketch, our layout items are
    not centered but aligned to the right. We can solve this by using the `android:gravity`
    attribute in our linear layout view groups. In the following code snippet, we
    make use of the `android:gravity` attribute to center layout widgets within both
    linear layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of `android:gravity` being set to `center`, widgets are properly
    aligned as we would like. The effects of applying the `android:gravity` view groups
    to our layout view groups can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de72ca44-34bf-4185-9b8a-9e977acb4fa4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining string resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up till now, we have been passing hardcoded strings as values to element attributes
    that require text to be set. This is not best practice and generally should be
    avoided. Instead, string values should be added in a string resource file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default file for string resources is `strings.xml` and this can be found
    in the `res` | `values` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e6592a2-1b40-4883-ad52-ff6e9dd2e3c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'String values are added as string resources using the `<string>` XML tag. We
    need to add string resources for all string values we have used thus far. Add
    the following code to your string resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is necessary to edit our `MainActivity` layout file to exploit these
    created resources. A string resource can be referenced with `@strings/` prefixing
    the string resource name. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Handling input events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the cycle of a user's interaction with an application, a means by which the
    user can provide some form of input for the execution of a process is by interacting
    with a widget. These inputs can be captured with events. In Android applications,
    events are captured from the specific view object that the user interacts with.
    The required structures and procedures necessary for input event handling are
    provided by the View class.
  prefs: []
  type: TYPE_NORMAL
- en: Event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event listener is a procedure in an application program that waits for a
    UI event to occur. There are many types of events that can be emitted within an
    application. Some common events are click events, touch events, long click events,
    and text change events.
  prefs: []
  type: TYPE_NORMAL
- en: In order to capture a widget event and perform an action upon its occurrence,
    a listener for the event must be set to the view. This can be achieved by invoking
    a view's set. `Listener()` method and passing either a lambda or a reference to
    a function to the method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the capturing of a click event done on a
    button. A lambda is passed to the `setOnClickListener` method of the view class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A reference to a function can be passed in place of a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Many listener setter methods are available in the view class. Some examples
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setOnClickListener()`: Sets a function to be invoked upon the click of a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOnContextClickListener()`: Sets a function to be invoked upon the context
    click of a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOnCreateContextMenuListener()`: Sets a function to be invoked upon the
    creation of a view''s context menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOnDragListener()`: Sets a function to be invoked on the occurrence of a
    drag event on a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOnFocusChangeListener()`: Sets a function to be called on the focus change
    of a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOnHoverChangeListener()`: Sets a function to be called when a hover event
    occurs on a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOnLongClickListener()`: Sets a function to be invoked on the occurrence
    of a long click event on a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOnScrollChangeListener()`: Sets a function to be invoked when the scroll
    positions (X or Y) of a view change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event listener is a procedure in an application program that waits for a
    UI event to occur.
  prefs: []
  type: TYPE_NORMAL
- en: As we now have a good understanding of how to handle input events, we can go
    on to implement some logic in our `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main activity screen contains an app bar. We need to hide this layout element
    as our view does not require it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ed808ff-d61d-46e1-92b6-a53c7eb037cf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Appbar
  prefs: []
  type: TYPE_NORMAL
- en: 'An app bar is also referred to as an action bar. Action bars are instances
    of the `ActionBar` class. The instance of the action bar widget in a layout can
    be retrieved via the `supportActionBar` accessor variable. The following code
    retrieves the action bar, and hides it if a null reference is not returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Though the preceding code performs what is necessary, its length can be reduced
    considerably by exploiting Kotlin''s type-safe system, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If `supportActionBar` is not a null object reference, the `hide()` method will
    be invoked if nothing else happens. This will prevent the raising of a null pointer
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create object references for the widgets that exist in our layouts.
    This is necessary for many reasons, such as listener registration. Object references
    of a view can be retrieved by passing the resource ID of the view to `findViewById()`.
    We add object references to `MainActivity` (existing in the `MainActivity.kt`
    file) in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have object references to our user interface elements in place,
    we need to handle some of their events. We must set click listeners for all buttons
    in the layout (there's no point having a button that does nothing when clicked,
    after all).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we stated earlier on, the New Game button has the sole task of navigating
    the user to the game activity (where game play takes place). In order to do this,
    we will need to utilize an explicit intent. Add a private function containing
    the logic to be executed on the click of the New Game button to `MainActivity` (in
    the `MainActivity.kt` file) and set a reference to the function via `setOnClickListener()`
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new empty activity and name it `GameActivity`. Once the activity is
    created, we can utilize an intent to launch the activity on the click of the New
    Game button, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the function body creates a new instance of the Intent class
    and passes the current context and the required activity class to the constructor.
    Notice we passed `this` as the first argument to the constructor. The `this` keyword
    is used to refer to the current instance in which `this` is called. Hence, we
    are actually passing the current activity (`MainActivity`) as the first argument
    to the constructor.  At this point, you might be asking why we are passing an
    activity as the first argument of the `Intent` constructor when it requires a
    context as its first argument. This is because all activities are extensions of
    the `Context` abstract class. Hence, all activities are in their own rights contexts.
  prefs: []
  type: TYPE_NORMAL
- en: The `startActivity()` method is called to launch an activity from which no result
    is expected. When an intent is passed as its only argument, it starts an activity
    from which it expects no result. Go ahead and run the application to observe the
    effect of the button click.
  prefs: []
  type: TYPE_NORMAL
- en: '`Context` is an abstract class in the Android application framework. The implementation
    of a context is provided by the Android system. `Context` allows access to application-specific
    resources. `Context` also allows access to calls for application-level operations
    such as launching activities, sending broadcasts, and receiving intents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the following functions for the clicks of the EXIT and
    RESET SCORE buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The call to `System.exit()` in the `onBtnExitClick` function stops further execution
    of the program and exits it when the `0` integer is passed as its argument. The
    last thing we need to do concerning handling click events is to implement the
    logic to perform the reset of high scores. To do this, we need to implement some
    logic for data storage first to store the high score. We will do this using `SharedPreferences`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SharedPreferences` is an interface for storing, accessing, and modifying data.
    The `SharedPreferences` APIs enable data storage in sets of key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set up a simple utility to handle our data storage needs for this app
    utilizing the `SharedPreferences` interface. Create a package in the project''s
    source directory with the name `storage` (right-click the source directory and
    select New | Package):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2132e50-d9a0-46cf-b802-4643842164c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create a new Kotlin class named `AppPreferences` within the `storage`
    package. Type the following code into the class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, a `Context` is required to be passed to the class'
    constructor upon creation of an instance of the class. Context provides access
    to the `getSharedPreferences()` method, which retrieves a specified preference
    file. The preference file is identified by the name in the string passed as the
    `getSharedPreferences()` method's first argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `saveHighScore()` function takes an integer – the high score to be saved
    – as its only argument. `data.edit()` returns an `Editor` object that permits
    the modification of a preference file. The editor's `putInt()` method is called
    in order to store an integer within the preference file. The first argument passed
    to `putInt()` is a string representing the key that will be used to access the
    stored value. The second argument to the method is the integer to be stored –
    in this case, the high score.
  prefs: []
  type: TYPE_NORMAL
- en: '`getHighScore()` returns the high score by calling `data.getInt()`. `getInt()`
    is a function implemented by `SharedPreferences` that provides read access to
    a stored integer value. `HIGH_SCORE` is the unique identifier of the value to
    be retrieved. The `0` passed to the function''s second argument specifies a default
    value to be returned in the scenario that no value corresponding to the specified
    key exists.'
  prefs: []
  type: TYPE_NORMAL
- en: '`clearHighScore()` resets the high score to zero by simply overwriting the
    value corresponding to the `HIGH_SCORE` key with `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `AppPreferences` utility class in place, we can finish
    up the `onBtnResetScoreClick()` function in `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now when the high score reset button is clicked, the high score is reset to
    zero. You'll want to give the user some sort of feedback when such actions occur.
    We can utilize a `Snackbar` to provide this user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the `Snackbar` class within an Android application, the Android
    design support library dependency must be added to the module-level Gradle build
    script. Do this by adding the following line of code under the dependencies closure
    of `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have added the line, your module-level `build.gradle` script should
    look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the alterations, sync your project by clicking Sync Now on the
    flash message that appears within the editor window, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb1ca54d-53b2-4534-9973-b61efe103f00.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Without further ado, let''s modify our `onBtnResetClick()` to provide user
    feedback in the form of a `Snackbar` after a score reset has been performed by
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on RESET SCORE successfully resets the high score of the player as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/879f5463-2612-4e88-a174-5204c5e9092e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before moving further, you''ll want to update the text displayed in the high
    score text view of the `MainActivity` layout to reflect the reset score. This
    can be done by changing the text contained in the text view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the game activity layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have successfully created the layout for main activity. Before we
    conclude this chapter, it is imperative we create the layout for `GameActivity`
    as well. Go ahead and open `activity_game.xml` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Most view attributes used in this layout have already previously been used and
    as such do not need further explanation. The only exceptions are the `android:background`
    and `android:layout_weightSum` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The `android:background` attribute is used to set the background color of a
    view or view group. `#e8e8e8` and `#000` were passed as values in the two instances
    where `android:background` is used in the layout. `#e8e8e8` is the hex color code
    for gray and `#000` the hex code for black.
  prefs: []
  type: TYPE_NORMAL
- en: '`android:layout_weightSum` defines the maximum weight sum in a view group and
    is calculated as the sum of the `layout_weight` values of all child views in a
    view group. The first linear layout in `activity_game.xml` declares the weight
    sum of all child views to be `10`. As such, the immediate children of the linear
    layout have layout weights of `1` and `9`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We made use of three string resources that we have not previously added to
    our string resources file. Go ahead and add the following string resources to
    `strings.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add some simple logic to game activity for the population
    of the high score and current score text views, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, object references to layout view elements are
    created. In addition, we declare the `updateHighScore()` and `updateCurrentScore()`
    functions. These two functions are invoked on the creation of the view. They set
    the default scores displayed in the current score and high score text views declared
    in the layout file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the changes made to the project and build and run the application. Click
    on the New Game button once the application starts to view the layout we just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e0507ef-a29d-4ca8-b038-8f7bf5e0280e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The right-hand side of the layout that contains no content is the area in which
    the Tetris game play will happen. We will implement this in chapter 3: Implementing
    Tetris Logic and Functionality. The final thing we must understand before moving
    to the next chapter is the app manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: The app manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app manifest is an XML file that is present in every Android application.
    It is located in the manifests of an application''s root folder. The `manifest`
    file holds crucial information pertaining to an application on the Android operating
    system. The information contained in an application''s `androidManifest.xml` must
    be read by the Android system before an application can be run. Some of the information
    that must be registered in the app manifest are:'
  prefs: []
  type: TYPE_NORMAL
- en: The Java package name for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The activities present in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services that are used in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intent filters that direct implicit intents to an activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descriptions of the broadcast receivers used in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data pertaining to content providers present in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes that implement the various application components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The permissions that are required by an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of the app manifest file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The general structure of the `androidManifest.xml` file is shown in the following
    code snippet. The snippet contains all possible elements and declarations that
    can exist in the `manifest` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from the preceding code snippet, a vast array of elements can
    appear in the `manifest` file. Many of these elements will be covered in this
    book. As a matter of fact, a number of these manifest elements have already been
    used in our Tetris application. Go ahead and open the `androidManifest.xml` file
    of Tetris. The contents of the file should be similar to what is contained in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements used in the preceding `manifest` file – in alphabetical order
    – are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<action>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<activity>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<application>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<category>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<intent-filter>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<manifest>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <action>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is used to add an action to an intent filter. The `<action>` element is
    always a child element to an `<intent-filter>` element. An intent filter should
    contain one or more of these elements. If no action element is declared for an
    intent filter, the filter accepts no `Intent` objects. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `name` attribute is an attribute that specifies the name of the
    action being handled.
  prefs: []
  type: TYPE_NORMAL
- en: <activity>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This element declares an activity existing in an application. All activities
    must be declared in the app manifest in order to be seen by the Android system.
    `<activity>` is always placed within a parent `<application>` element. The following
    code snippet shows the declaration of an activity within a manifest file using
    the `<activity>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `name` attribute in the preceding code snippet is an attribute that specifies
    the name of the class that implements the activity being declared.
  prefs: []
  type: TYPE_NORMAL
- en: <application>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This element is the declaration of the application. It contains subelements
    that declare the components existing in the application. The following code demonstrates
    the use of `<application>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<application>` element in the preceding snippet makes use of four attributes.
    These attributes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:allowBackup`: It is used to specify whether the application is allowed
    to take part in the backup and restore infrastructure. When set to `true`, the
    application can be backed up by the Android system. Otherwise, if this attribute
    is set to `false`, no backup of the application will ever be created by the Android
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:icon`: It specifies the icon resource for the application. It can
    also be used to specify icon resources for application components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:label`: It specifies a default label for the application as a whole.
    It can also be used to specify default labels for application components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:roundIcon`: It specifies an icon resource to be used when a circular
    icon resource is required. When an app icon is requested by a launcher, the Android
    framework returns either `android:icon` or `android:roundIcon`; which is returned
    depends on the device build configuration. As either can be returned, it is important
    to specify a resource for both attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:supportsRtl`: It specifies whether an application is willing to support
    **right-to-left** (**RTL**) layouts. The application is set to support it when
    this attribute is set to `true`. Otherwise, the application does not support RTL
    layouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:theme`: It specifies a style resource defining a default theme for
    all activities in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <category>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This element is a child element to `<intent-filter>`. It is used to specify
    a category name to its parent intent filter component.
  prefs: []
  type: TYPE_NORMAL
- en: <intent-filter>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specifies the type of intent that activity, service, and broadcast receiver
    components can respond to. An intent filter is always declared within a parent
    component with the `<intent-filter>` element.
  prefs: []
  type: TYPE_NORMAL
- en: <manifest>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the root element of the app manifest file. It contains a single `<application>`
    element and specifies the `xmlns:android` and `package` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took a closer look at the Android application framework.
    In the process, we learned about several things, such as the seven fundamental
    Android app components: activities, intents, intent filters, fragments, services,
    loaders, and content providers.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we took a close look at the process of creating a layout, the constraint
    layout, types of layout constraints that exist, string, dimension resources, views,
    view groups, and working with `SharedPreferences`. In the next chapter, we will
    delve further into the world of Tetris and implement the gameplay as well as critical
    application logic.
  prefs: []
  type: TYPE_NORMAL
