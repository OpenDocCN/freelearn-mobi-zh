<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Data Management</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating files</li><li class="listitem" style="list-style-type: disc">Using a SQLite database</li><li class="listitem" style="list-style-type: disc">Preparing for iCloud support</li><li class="listitem" style="list-style-type: disc">iCloud key/value data storage</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Introduction</h1></div></div></div><p>Almost every application needs to have permanent data storage on the filesystem. In this chapter, we will discuss different ways of storing data. We will see how to create a <strong>SQLite database</strong><a id="id286" class="indexterm"/> and manage data with it from within an iPhone application. Also, we will learn how to use an already existing database in a project.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>SQLite (<a class="ulink" href="http://www.sqlite.org">http://www.sqlite.org</a>) is a self-contained transactional database<a id="id287" class="indexterm"/> system. Each database is saved in a standalone file and <a id="id288" class="indexterm"/>there is no database server. In iOS, SQLite support is native.</p></div></div><p>Following <a id="id289" class="indexterm"/>SQLite, we will have a look at <strong>iCloud storage</strong> and how to incorporate it in our apps.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Creating files</h1></div></div></div><p>In this recipe, we<a id="id290" class="indexterm"/> will learn how to create files on the filesystem of iOS devices.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec146"/>Getting ready</h2></div></div></div><p>Create a new iPhone<strong> Single View Application</strong> in Xamarin Studio and name it <code class="literal">FileCreationApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec147"/>How to do it…</h2></div></div></div><p>Follow the<a id="id291" class="indexterm"/> ensuing steps to complete this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">FileCreationAppViewController.xib</code> file in Interface Builder.</li><li class="listitem">Add a button and a label on its view.</li><li class="listitem">Back in Xamarin Studio, enter the following code in the <code class="literal">ViewDidLoad</code> method of the controller class:<div><pre class="programlisting">string filePath = Path.Combine (Environment.GetFolderPath(Environment.SpecialFolder.Personal), "MyFile.txt");
using (StreamWriter sw = new StreamWriter (filePath))
{
  sw.WriteLine ("Some text in file!");
}
this.btnShow.TouchUpInside += (s, e) =&gt; {
  using (StreamReader sr = new StreamReader (filePath))
  {
    this.labelStatus.Text = sr.ReadToEnd ();
  }
};</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap the button to fill the label with the contents of the file.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec148"/>How it works...</h2></div></div></div><p>As one can see from the preceding code, we can use standard classes from the <code class="literal">System.IO namespace</code>, just like in desktop applications. We will set a path for the file we want to save. We will do this in the following line of code:</p><div><pre class="programlisting">string filePath = Path.Combine (Environment.GetFolderPath(Environment.SpecialFolder.Personal), "MyFile.txt");</pre></div><p>In iOS, we do not have access to the whole filesystem, not even inside the application bundle. An exception will occur if we try to write inside a folder we do not have access to. So we use the <code class="literal">static Environment.GetFolderPath(SpecialFolder)</code> method and retrieve the <code class="literal">Personal</code> special folder, that corresponds to our app's <code class="literal">Documents</code> folder. Note the use of <code class="literal">Path.Combine(string, string)</code> that combines two strings and returns a path. After that, we create a new instance of the <code class="literal">StreamWriter</code> class as follows:</p><div><pre class="programlisting">using (StreamWriter sw = new StreamWriter (filePath))
{
  sw.WriteLine ("Some text in file!");
}</pre></div><p>We write some text in the file with its <code class="literal">WriteLine(string)</code> method. To retrieve the text from the file, we <a id="id292" class="indexterm"/>create a new instance of the <code class="literal">StreamReader</code> class and read the text with its <code class="literal">ReadLine </code>method using the following code:</p><div><pre class="programlisting">using (StreamReader sr = new StreamReader (filePath))
{
  this.labelMessage.Text = sr.ReadToEnd ();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec149"/>There's more...</h2></div></div></div><p>Practically, every available class in the <code class="literal">System.IO</code> namespace will work on Xamarin.iOS, as long as we have access to the target folder. </p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec38"/>The Documents folder</h3></div></div></div><p>An app bundle's <code class="literal">Documents</code> folder is relevant to the app alone. If the app is uninstalled from the<a id="id293" class="indexterm"/> device, its contents are also removed. Files created in this folder are automatically backed up to iCloud, unless we explicitly request that a particular file is excluded. This can be done by skipping the backup attribute of the file. For example, if we wanted to exclude the <code class="literal">MyFile.txt</code> file that we created, we would have to add the following code:</p><div><pre class="programlisting">NSError error = NSFileManager.SetSkipBackupAttribute(filePath, true);
if (null == error) {
  // Success
}</pre></div><p>If the file does not exist when we call this method, the <code class="literal">error</code> object will contain the appropriate error information.</p><p>If we would like to include a file to iCloud backup, we would just have to call the preceding method, passing <code class="literal">false</code> as the second argument.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>It is important that we consider skipping the backup attribute for large files. Apple will reject apps that contain large files to be backed up to iCloud.</p><p>iCloud backup is the automatic procedure of iOS backup feature. It is primarily used for<a id="id294" class="indexterm"/> restoring a device from iCloud. Other than excluding or including files from iCloud backups, we have no other access to it. It is also different from iCloud storage, which we have access to and will be discussing later in this chapter.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>The Caches folder</h3></div></div></div><p>The <code class="literal">Caches</code> folder (<code class="literal">Library/Caches/</code>) can be used for storing application-specific data that can be <a id="id295" class="indexterm"/>easily recreated by the application. Files in this folder are not backed up to iCloud and can be deleted by the system, if there is need for more space.</p><p>We can get the full path of the <code class="literal">Caches</code> folder in an iOS app, through the <code class="literal">Environment.SpecialFolder.InternetCache</code> value, as shown in the following code:</p><div><pre class="programlisting">string cachesFolder = Environment.GetFolderPath(Environment.SpecialFolder.InternetCache);</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec150"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>iCloud key/value data storage</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Using a SQLite database</h1></div></div></div><p>In this recipe, we will learn how to create a SQLite database file. We will create a table, insert some<a id="id296" class="indexterm"/> data into it, and then query the table to display the data on screen.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec151"/>Getting ready</h2></div></div></div><p>Create a new iPhone<strong> Single View Application</strong> in Xamarin Studio and name it <code class="literal">SQLiteApp</code>. Add three buttons and a label on the view controller. Do not forget to connect them to the outlets.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec152"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add references to the assemblies <code class="literal">Mono.Data.Sqlite</code> and <code class="literal">System.Data</code>. The following screenshot shows how to add a reference to the project:<div><img src="img/8924OT_04_01.jpg" alt="How to do it..."/></div></li><li class="listitem">For<a id="id297" class="indexterm"/> creating the database and the table, enter the following method in the <code class="literal">SQLiteAppViewController</code> class:<div><pre class="programlisting">private void CreateSQLiteDatabase (string databaseFile)
{
  try
  {
    if (!File.Exists (databaseFile))
    {
      SqliteConnection.CreateFile (databaseFile);
      using (SqliteConnection sqlCon = new SqliteConnection (String.Format ("Data Source = {0};", databaseFile)))
      {
        sqlCon.Open ();
        using (SqliteCommand sqlCom = new SqliteCommand (sqlCon))
        {
          sqlCom.CommandText = "CREATE TABLE Customers (ID INTEGER PRIMARY KEY, FirstName VARCHAR(20), LastName VARCHAR(20))";
          sqlCom.ExecuteNonQuery ();
        }
        sqlCon.Close ();
      }
      this.lblStatus.Text = "Database created!";
    } else {
      this.lblStatus.Text = "Database already exists!";
    }
  } catch (Exception ex) {
    this.lblStatus.Text = String.Format ("Sqlite error: {0}", ex.Message);
  }
}</pre></div></li><li class="listitem">Add the following method for inserting data to the database:<div><pre class="programlisting">private void InsertData(string databaseFile) {
  try {
    if (File.Exists(databaseFile)) {
      using (SqliteConnection sqlCon = new SqliteConnection(String.Format("Data Source = { 0};", databaseFile))) {
        sqlCon.Open();
        using (SqliteCommand sqlCom = new SqliteCommand(sqlCon)) {
          sqlCom.CommandText = "INSERT INTO Customers (FirstName, LastName) VALUES ('Dimitris', 'Tavlikos')";
          sqlCom.ExecuteNonQuery();
          }
        sqlCon.Close();
      }
      this.lblStatus.Text = "Inserted 1 row.";
    }  else {
      this.lblStatus.Text = "Database file does not exist!";
    }
  }  catch (Exception ex) {
    this.lblStatus.Text = String.Format("Sqlite error: { 0}", ex.Message);
  }
}</pre></div></li><li class="listitem">Add the <a id="id298" class="indexterm"/>following method for querying the data from the database:<div><pre class="programlisting">private void QueryData(string databaseFile) {
  try {
    if (!File.Exists(databaseFile)) {
      using (SqliteConnection sqlCon = new SqliteConnection(String.Format("Data Source = { 0};", databaseFile))) {
          sqlCon.Open();
        using (SqliteCommand sqlCom = new SqliteCommand(sqlCon)) {
          sqlCom.CommandText = "SELECT * FROM Customers WHERE FirstName='Dimitris'";
          using (SqliteDataReader dbReader = sqlCom.ExecuteReader()) {
            while (dbReader.Read()) {
              this.lblStatus.Text = String.Format("First name: { 0}\ nLast name: { 1}", dbReader["FirstName"], dbReader["LastName"]);
            }
          }
        }
      }
    }  else {
      this.lblStatus.Text = "Database file does not exist!";
    }
  }  catch (Exception ex) {
    this.lblStatus.Text = String.Format("Sqlite error: { 0}", ex.Message);
  }
}</pre></div></li><li class="listitem">Add the <a id="id299" class="indexterm"/>following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">string sqlitePath = Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.Personal), "MyDB.db3");
this.btnCreate.TouchUpInside += (s, e) =&gt; this.CreateSQLiteDatabase (sqlitePath);
this.btnInsert.TouchUpInside += (s, e) =&gt; this.InsertData(sqlitePath);
this.btnQuery.TouchUpInside += (s, e) =&gt; this.QueryData(sqlitePath);</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap each button in sequence, to create, insert, and query the data from the database.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec153"/>How it works...</h2></div></div></div><p>iOS provides native support for SQLite databases. We can access SQLite databases with Mono's <code class="literal">Mono.Data.Sqlite</code> namespace:</p><div><pre class="programlisting">using Mono.Data.Sqlite;</pre></div><p>Inside the <code class="literal">CreateSQLiteDatabase</code> method, we first check if the file already exists using the following code so as to avoid destroying any data:</p><div><pre class="programlisting">if (!File.Exists (databaseFile))</pre></div><p>Then we can continue with the creation of the database. We first create the file with the <code class="literal">SqliteConnection.CreateFile(string)</code> static method using the following code:</p><div><pre class="programlisting">SqliteConnection.CreateFile (databaseFile);</pre></div><p>We connect to the newly created file by initializing a <code class="literal">SqliteConnection</code> object and calling its <code class="literal">Open()</code> method. The connection string for a SQLite database is <code class="literal">Data Source =</code> followed by the filename of the database, as shown in the following code:</p><div><pre class="programlisting">using (SqliteConnection sqlCon = new SqliteConnection (String.Format ("Data Source = {0};", databaseFile)))
  sqlCon.Open();</pre></div><p>To create a<a id="id300" class="indexterm"/> table in the database, a <code class="literal">SqliteCommand</code> object is initialized. We pass a standard SQL string to its <code class="literal">CommandText</code> property and call the <code class="literal">ExecuteNonQuery()</code> method to execute the SQL as shown in the following code:</p><div><pre class="programlisting">sqlCom.CommandText = "CREATE TABLE Customers (ID INTEGER PRIMARY KEY, FirstName VARCHAR(20), LastName VARCHAR(20))";
sqlCom.ExecuteNonQuery ();</pre></div><p>To insert data to the database, we use the following code in the <code class="literal">InsertData</code> method:</p><div><pre class="programlisting">sqlCom.CommandText = "INSERT INTO Customers (FirstName, LastName) VALUES ('Dimitris', 'Tavlikos')";
sqlCom.ExecuteNonQuery();</pre></div><p>Finally, we query the data through a <code class="literal">SELECT</code> statement and retrieve it with the help of <code class="literal">SqliteDataReader</code>, as shown in the following code:</p><div><pre class="programlisting">sqlCom.CommandText = "SELECT * FROM Customers WHERE FirstName='Dimitris'";
using (SqliteDataReader dbReader = sqlCom.ExecuteReader()) {
  while (dbReader.Read()) {
    this.lblStatus.Text = String.Format("First name: {0}\nLast name: {1}", dbReader["FirstName"], dbReader["LastName"]);
  }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec154"/>There's more...</h2></div></div></div><p>Note the usage of a <code class="literal">try-catch</code> block. It is provided to display a message to the user if something goes wrong with the creation of the database.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>SQL table creation</h3></div></div></div><p>In this<a id="id301" class="indexterm"/> recipe, we have created a simple table for our database with the name <code class="literal">Customers</code>. It contains three fields. The <code class="literal">FirstName</code> and <code class="literal">LastName</code> parameters are of type <code class="literal">VARCHAR(20)</code> while <code class="literal">ID</code> is of type <code class="literal">INTEGER</code> and is also the <code class="literal">PRIMARY KEY</code> of the table.</p><p>Apart from using SQL commands to create tables, we can create a SQLite database with various commercial or free GUI tools. A simple search on the internet will yield various results.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec155"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating files</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Displaying data in a table</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Displaying Data">Chapter 5</a>, <em>Displaying Data</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Preparing for iCloud support</h1></div></div></div><p>With the release of iOS 5, Apple introduced iCloud. iCloud is a service that provides cloud storage to iOS users, in a variety of configurations. For app development, we can use iCloud storage to save information that can be shared among different instances of our app <a id="id302" class="indexterm"/>running on different devices under the same user account. In this<a id="id303" class="indexterm"/> recipe, we will learn how to prepare an app to provide iCloud storage support.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec156"/>Getting ready</h2></div></div></div><p>Create a new iPhone<strong> Single View Application</strong> in Xamarin Studio and name it <code class="literal">KeyValueApp</code>. For this recipe, an App ID with iCloud enabled needs to exist on the developer account. Refer to <a class="link" href="ch14.html" title="Chapter 14. Deploying">Chapter 14</a>, <em>Deploying</em>, for more information on how to create an App ID.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec157"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Double-click on the <code class="literal">Entitlements.plist</code> file to open it in Xamarin Studio. </li><li class="listitem">Check the <strong>Enable iCloud</strong> checkbox.</li><li class="listitem">If it asks you to choose an account, select your Apple developer account from the list.</li><li class="listitem">After enabling iCloud, the <strong>Use key-value store</strong> checkbox should appear. Enable it. The <strong>Entitlements.plist</strong> file settings should now look like the following screenshot:<div><img src="img/8924OT_04_02.jpg" alt="How to do it..."/></div></li><li class="listitem">In the project options, under <strong>iPhone Bundle Signing</strong>, select <strong>Entitlements.plist</strong> for the <strong>Custom entitlements</strong> field. It is important to perform this step, despite the fact that the field might already be set.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec158"/>How it works...</h2></div></div></div><p>Enabling iCloud <a id="id304" class="indexterm"/>support is simply a matter of setting the appropriate setting for our project. By checking the <strong>Enable iCloud</strong> and <strong>Use key-value store</strong> checkboxes, Xamarin Studio adds the necessary keys in the <strong>Entitlements.plist</strong> file, that will allow the app to use iCloud storage.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec159"/>There's more...</h2></div></div></div><p>Although we can run iCloud-enabled apps on the simulator, the iCloud functionality will not work.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec160"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating profiles</em> recipe in <a class="link" href="ch14.html" title="Chapter 14. Deploying">Chapter 14</a>, <em>Deploying</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>iCloud key/value storage</h1></div></div></div><p>In this recipe, we will learn how to save and retrieve small amounts of data that are suitable <a id="id305" class="indexterm"/>for storing app settings or anything that would be useful to be shared among different devices.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>Apps can only store up to a total of 1 MB of data with key/value store, in up to 1024 keys. So it cannot be used to back up files or similar functionality.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec161"/>Getting ready</h2></div></div></div><p>We will<a id="id306" class="indexterm"/> need two devices under the same iCloud account to actually see iCloud storage in action. On one device we will save some data, and on the second device we will load the data. If only one device is available, it is not an issue as it will work flawlessly because the data will just be loaded from local storage, instead of iCloud.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec162"/>How to do it...</h2></div></div></div><p>The following are the steps to complete the recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new iPhone<strong> Single View Application</strong> in Xamarin Studio and enable it for iCloud, as shown in the previous recipe. Name the project <code class="literal">KeyValueApp</code>.</li><li class="listitem">Add two buttons and one label on the view controller.</li><li class="listitem">Add the following code in the view controller's <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.btnSave.TouchUpInside += (s, e) =&gt; {
  NSUbiquitousKeyValueStore kvStore = NSUbiquitousKeyValueStore.DefaultStore;
  kvStore.SetString("LastSavedSearch", "How to implement iCloud");
  kvStore.Synchronize();
  this.lblStatus.Text = "Saved!";
};
this.btnLoad.TouchUpInside += (s, e) =&gt; {
  NSUbiquitousKeyValueStore kvStore = NSUbiquitousKeyValueStore.DefaultStore;
  this.lblStatus.Text = string.Format("Last saved search is: {0}", kvStore.GetString("LastSavedSearch");
};</pre></div></li><li class="listitem">Compile and run the app on the device. Tap the <strong>Save</strong> button to save the key and value to iCloud.</li><li class="listitem">Tap the <strong>Load</strong> button to display the data on the label.</li><li class="listitem">If there is access to a second device, run the app on it and tap the <strong>Load</strong> button. The data will be retrieved from iCloud and displayed on the screen of the second device.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec163"/>How it works...</h2></div></div></div><p>To save key/value pairs to iCloud, we use the <code class="literal">NSUbiquitousKeyValueStore</code> class, which is responsible for handling the data. We retrieve the default key value store through the <code class="literal">DefaultStore</code> static property and call its <code class="literal">Save</code> method, as shown in the following code:</p><div><pre class="programlisting">NSUbiquitousKeyValueStore kvStore = NSUbiquitousKeyValueStore.DefaultStore;
kvStore.Save("LastSavedSearch", "How to implement iCloud ");</pre></div><p>Calling<a id="id307" class="indexterm"/> the <code class="literal">Save</code> method pushes the data in a queue for being saved locally and then uploaded to iCloud. The <code class="literal">Synchronize</code> method syncs the key/value store and can basically be used to speed up the process of syncing the data. However, calling the method does not mean that the data will be synced right away. iOS is responsible for when the data will be synced and we have no control over it. However, iCloud is designed to provide a seamless syncing experience, so the delays are usually unnoticeable:</p><div><pre class="programlisting">kvStore.Synchronize();</pre></div><p>To load the data from iCloud, we simply call the <code class="literal">GetString</code> method, passing the key for which to retrieve the data using the following code:</p><div><pre class="programlisting">kvStore.GetString("LastSavesSearch");</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec164"/>There's more...</h2></div></div></div><p>iCloud key/value store only accepts a specific set of values, which are of the following types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">double</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">bool</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">long</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NSObject[]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NSDictionary</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NSData</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">string</code></li></ul></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>Getting notified on key/value store changes</h3></div></div></div><p>We can also <a id="id308" class="indexterm"/>get notified of when a key/value pair or set of pairs have been changed on another device. To do this, we need to add a notification observer, as shown in the following code:</p><div><pre class="programlisting">NSObject coudObserver = NSUbiquitousKeyValueStore.Notifications.ObserveDidChangeExternally((s, e) =&gt; {
  if (e.ChangeReason == NSUbiquitousKeyValueStoreChangeReason.
    ServerChange) {
    e.ChangeKeys.Foreach(k =&gt; Console.WriteLine("Key changed: {0}", k));
  }
};</pre></div><p>The<a id="id309" class="indexterm"/> <code class="literal">NSUbiquitousKeyValueStoreChangeReason</code> enumeration contains the following values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>ServerChange</strong>: It <a id="id310" class="indexterm"/>shows if a value was changed on another device or not.</li><li class="listitem" style="list-style-type: disc"><strong>QuotaViolationChange</strong>: The quota limit was reached. Some key/value pairs need to be removed.</li><li class="listitem" style="list-style-type: disc"><strong>InitialSyncChange</strong>: A key/value pair was discarded as the initial iCloud setup on the device has not been completed.</li><li class="listitem" style="list-style-type: disc"><strong>AccountChange</strong>: The user has changed the iCloud account on the device. The whole key/value store is replaced with the one from the new iCloud account.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec165"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Preparing for iCloud</em> <em>support</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Creating profiles</em> recipe in <a class="link" href="ch14.html" title="Chapter 14. Deploying">Chapter 14</a>, <em>Deploying</em></li></ul></div></div></div></body></html>