<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer043">
			<h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor102"/>4</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor103"/>Peer-to-Peer and Client-Server Architecture</h1>
			<p>This chapter explores two fundamental architectural patterns for organizing and structuring communication systems: <strong class="bold">peer-to-peer</strong> (<strong class="bold">P2P</strong>) and <strong class="bold">client-server</strong> architectures. These architectural patterns have significantly impacted the way we design and implement various modern <span class="No-Break">network systems.</span></p>
			<p>This chapter provides a comprehensive understanding of the P2P and client-server architectures, in terms of their principles, characteristics, and applications. Afterward, we will compare and identify the crucial differences between these two approaches and analyze their respective strengths <span class="No-Break">and limitations.</span></p>
			<p>We will cover the trade-offs and pros and cons of the P2P and client-server architectures. More importantly, we will discuss factors to consider when deciding between these two models, with the desired system quality attributes such as scalability, fault tolerance, security, and control. We will also explore the possibility of a hybrid model for flexibility <span class="No-Break">and adaptability.</span></p>
			<p>In this chapter, you will learn about the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>A real-life example of a <span class="No-Break">networked system</span></li>
				<li><span class="No-Break">Client-server architecture</span></li>
				<li><span class="No-Break">P2P architecture</span></li>
				<li>Comparison between client-server and <span class="No-Break">P2P architectures</span></li>
			</ul>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>You can find all the code files used in this chapter on <span class="No-Break">GitHub:</span><span class="No-Break"> </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4"><span class="No-Break">https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4</span></a></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor105"/>A real-life example of a networked system</h1>
			<p>We will use the same real-life <a id="_idIndexMarker269"/>example that we have been using in previous chapters. Households in a village exchange services with each other. Each household has an isolated copy of the software that keeps the records of the contract for <span class="No-Break">exchanged services.</span></p>
			<p>They are suffering an ongoing problem; that is, sometimes two households that exchanged services have a discrepancy between the contract records kept in their own copy of the software. This has caused a few disputes <span class="No-Break">among households.</span></p>
			<p>An engineer wants to eliminate<a id="_idIndexMarker270"/> these disputes by synchronizing the contracts between two copies of the software. The synchronization requires two copies of the software to be connected. An oversimplified interaction of the synchronization is illustrated in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B21737_04_1.jpg" alt="Figure 4.1 – Synchronization of contracts for exchanged services among households" width="805" height="796"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Synchronization of contracts for exchanged services among households</p>
			<p>In the diagram, <em class="italic">Household A</em> sends the details of the contract to <em class="italic">Household B</em>. The received contract is compared against the contract stored locally in <em class="italic">Household B</em>. <em class="italic">Household B</em> resolves the conflicts for any differences found. The revised contract (<em class="italic">contract’</em>) is then sent to <em class="italic">Household A</em>. <em class="italic">Household A</em> also compares the contracts and resolves any conflicts. <em class="italic">Household A</em> sends another revised contract (<em class="italic">contract’’</em>) to <em class="italic">Household B</em>. This time, <em class="italic">Household B</em> does not find any differences and therefore acknowledges <em class="italic">Household A</em> with the contract. <em class="italic">Household A</em> receives the acknowledgment from <em class="italic">Household B</em> and sends a final acknowledgment that both households have synchronized <span class="No-Break">the contract.</span></p>
			<p>Given that we have a way to synchronize contracts between two copies of the software, we still need a way for them to discover each other <span class="No-Break">and communicate.</span></p>
			<p>We are going to<a id="_idIndexMarker271"/> explore the P2P and client-server architectures in the next section and relate them to the context of solving the problem in <span class="No-Break">this example.</span></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor106"/>Client-server architecture</h1>
			<p>Client-server architecture is a model for organizing distributed systems and computer networks. In this architecture, the roles of the client and the server are clearly defined, and each component plays at least one<a id="_idIndexMarker272"/> <span class="No-Break">of them.</span></p>
			<p>Clients are devices or components that request resources or services, and servers are the devices or components that serve requests or provide services. An example of client-server architecture over the internet is illustrated in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B21737_04_2.jpg" alt="Figure 4.2 – Client-server architecture (C1)" width="665" height="803"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Client-server architecture (C1)</p>
			<p>Usually, clients are everyday user-facing devices such as laptops, phones, and televisions. They tend to be lightweight devices with limited computation power, and they usually only need to be available during communication <span class="No-Break">with servers<a id="_idTextAnchor107"/>.</span></p>
			<p>Servers are devices dedicated to serving requests and are usually hosted in the cloud or data centers. They usually have more computational power, more storage, and more network bandwidth, and are <a id="_idIndexMarker273"/>highly available to serve requests from clients. Systems with client-server architecture start with servers being available to serve requests <span class="No-Break">from clients.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor108"/>Interactions between clients and servers</h2>
			<p>Interactions between clients and <a id="_idIndexMarker274"/>servers fall into a request-response model. Clients send to servers a request that identifies a resource or specifies the details of the service needed. Servers receive the request, validate it, process it, and send back a corresponding response containing the requested resources or the outcome of <span class="No-Break">the service.</span></p>
			<p>Note that clients always initiate the interaction and have the knowledge of how to locate the servers. On the contrary, servers only know the location of the client within the context of the <span class="No-Break">corresponding request.</span></p>
			<p>As a result, the resources or services provided are centralized in servers. Clients do not directly communicate with other clients. Any resource that might need to be shared among clients is hosted on servers and is available to be requested by <span class="No-Break">clients instead.</span></p>
			<p>This architecture results in much higher and broader non-functional requirements for servers compared to clients. We are now going to discuss some of the key system quality attributes <span class="No-Break">in servers.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor109"/>Availability</h2>
			<p>Servers usually need to be available <a id="_idIndexMarker275"/>as much as possible, so they are operational to serve requests from clients whenever required. Typically, this means there are redundant instances of the servers running at the same time. There might be a failover mechanism to route requests to an available server, a backup system to recover the last known state of the server, and monitoring tools to proactively ensure servers <span class="No-Break">are up.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor110"/>Performance</h2>
			<p>Servers are centralized to serve numerous clients at the same time. Being fast and efficient is paramount to<a id="_idIndexMarker276"/> sustaining servers to be operational. Latency and throughput are the two major system quality attributes <span class="No-Break">for performance.</span></p>
			<p>Latency under client-server <a id="_idIndexMarker277"/>architecture is the total time that has elapsed between a request being sent from a client and the corresponding response being received by a client. Throughput is the number of requests that arrive in servers per <span class="No-Break">time unit.</span></p>
			<p>The performance of servers depends on multiple factors, such as processing power, memory, network bandwidth, and disk I/O. There are usually multiple components in servers that contribute to performance-related system quality attributes, such as filesystems, databases, messaging middleware, and even <span class="No-Break">third-party systems.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor111"/>Scalability</h2>
			<p>Servers sometimes need to cope with a<a id="_idIndexMarker278"/> growing and shrinking number of client requests. Here are some common approaches to <span class="No-Break">managing this.</span></p>
			<p>A load balancer can be deployed to distribute the requests from clients to a pool of servers. It keeps track of the health and traffic of each server instance so it can aim to route requests to the less busy server and archive an equal workload <span class="No-Break">among servers.</span></p>
			<p>Servers can be horizontally scaled by running more instances to distribute the load, or vertically scaled by upgrading the hardware capabilities <span class="No-Break">of servers.</span></p>
			<p>There should also be a configuration of a minimum or desired number of running server instances, so the number of servers can drop when the load is <span class="No-Break">not heavy.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor112"/>Security</h2>
			<p>The requests are centralized to be<a id="_idIndexMarker279"/> served in servers and the corresponding data is also centralized in servers. Security becomes of significant importance. There are at least four major areas <span class="No-Break">to address.</span></p>
			<p>Firstly, servers should only process incoming requests that come from identifiable clients. Clients need to be authenticated by various means, such as passwords or multi-factor verifications. The details of the approaches will be covered in <a href="B21737_14.xhtml#_idTextAnchor442"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><span class="No-Break">.</span></p>
			<p>Servers should also have control over which requests can be accepted by which client. For example, a normal client cannot access system settings while an administrator client can. Clients are usually authorized by internal processes not visible outside servers, so clients are not able to bypass <span class="No-Break">the checks.</span></p>
			<p>The data in the request and <a id="_idIndexMarker280"/>response payload may contain personal or sensitive information that requires protection. In these cases, the communication between clients and servers may require encryption in an agreed-upon protocol. The encryption method may be personalized so that a client’s data cannot be read by <span class="No-Break">other clients.</span></p>
			<p>Servers will also <a id="_idIndexMarker281"/>need to have a basic <a id="_idIndexMarker282"/>defense against common malicious attacks, for example, <strong class="bold">denial of service</strong> (<strong class="bold">DOS</strong>), <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>), and <strong class="bold">man in the </strong><span class="No-Break"><strong class="bold">middle</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">MitM</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor113"/>Server discovery</h2>
			<p>Clients need to locate an available <a id="_idIndexMarker283"/>server to send their requests. There are several common <span class="No-Break">discovery mechanisms:</span></p>
			<ol>
				<li>Static and hardcoded addresses as <span class="No-Break">client configurations</span></li>
				<li><strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>), which <a id="_idIndexMarker284"/>translates server IP addresses into human-readable <span class="No-Break">domain names</span></li>
				<li>Dynamic DNS services that dynamically change the <span class="No-Break">server addresses</span></li>
				<li>Service registry services that allow clients to query the appropriate server to <span class="No-Break">connect to</span></li>
				<li>Load balancers that distribute requests from clients to a pool of <span class="No-Break">available servers</span></li>
				<li>Service mesh, which abstracts service discovery, load balancing, and other network concerns with a dedicated <span class="No-Break">infrastructure layer</span></li>
			</ol>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor114"/>Common client-server architectures</h2>
			<p>There are many variations of architecture styles that handle the communication between clients <span class="No-Break">and servers:</span></p>
			<ol>
				<li><strong class="bold">As an exchange of representations of resources</strong>: <strong class="bold">Representational state transfer</strong> (<strong class="bold">REST</strong>) is a popular <a id="_idIndexMarker285"/>client-server architecture that focuses on the exchange of resources using <a id="_idIndexMarker286"/>standard HTTP methods such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PATCH</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">As remote procedure calls (RPCs)</strong>: An RPC sees a request from a client as an action to perform, and therefore the URLs usually end with a verb (e.g. <strong class="source-inline">/place</strong> or <strong class="source-inline">/update</strong>) while using mostly only the GET and POST <span class="No-Break">HTTP methods.</span></li>
				<li><strong class="bold">As asynchronous messages</strong>: In this architecture, clients and servers do not directly contact each other. Instead, they communicate through messaging infrastructure as queues <span class="No-Break">and topics.</span></li>
				<li><strong class="bold">As two-way dedicated connections</strong>: Clients and servers open a dedicated channel over a <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) connection to communicate. This style <a id="_idIndexMarker287"/>of communication is usually seen in systems that require lower latency and <span class="No-Break">frequent messaging.</span></li>
			</ol>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor115"/>The client-server solution</h2>
			<p>We are going to apply the client-server <a id="_idIndexMarker288"/>architecture to solve the real-life example of service contract synchronization between two households. It is recommended to draft the interactions between clients and servers before coding. Let us assume HTTP as the <span class="No-Break">communication protocol.</span></p>
			<p>We will use REST architecture in this solution. We need to define endpoints that are provided by servers so clients can use these endpoints to facilitate the <span class="No-Break">necessary communication.</span></p>
			<h3>Step 1 – defining client-server communication</h3>
			<p>Let us illustrate a sample scenario of <span class="No-Break">client-server communication:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B21737_04_3.jpg" alt="Figure 4.3 – Sample client-server interaction for service contract synchronization" width="922" height="1292"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Sample client-server interaction for service contract synchronization</p>
			<p>The following are the<a id="_idIndexMarker289"/> messages sent between clients <span class="No-Break">and servers:</span></p>
			<ol>
				<li><em class="italic">Household A</em> submits a draft of a service contract <span class="No-Break">to servers.</span></li>
				<li><em class="italic">Household B</em> gets the service contract drafted by <em class="italic">Household A</em> <span class="No-Break">from servers.</span></li>
				<li><em class="italic">Household B</em> revises the service contract and submits it <span class="No-Break">to servers.</span></li>
				<li><em class="italic">Household A</em> gets the service contract revised by <em class="italic">Household B</em> <span class="No-Break">from servers.</span></li>
				<li><em class="italic">Household A</em> acknowledges to the servers that it agrees with the <span class="No-Break">service contract.</span></li>
				<li><em class="italic">Household B</em> gets the service contract agreed by <em class="italic">Household A</em> <span class="No-Break">from servers.</span></li>
				<li><em class="italic">Household B</em> acknowledges to the servers that it agrees with the <span class="No-Break">service contract.</span></li>
				<li><em class="italic">Household A</em> gets the service contract agreed upon by both households from <span class="No-Break">the servers.</span></li>
			</ol>
			<p>From these messages, we can define a<a id="_idIndexMarker290"/> few HTTP endpoints to be called <span class="No-Break">by clients:</span></p>
			<ul>
				<li><strong class="source-inline">PUT /contracts/{id}</strong>: Submit a draft or revised <span class="No-Break">service contract</span></li>
				<li><strong class="source-inline">GET /contracts/{id}</strong>: Get a <span class="No-Break">service contract</span></li>
				<li><strong class="source-inline">PATCH /contracts/{id}/agreedAt</strong>: Acknowledge agreeing to a <span class="No-Break">service contract</span></li>
			</ul>
			<p>Here, <strong class="source-inline">{id}</strong> is the unique identifier of the resource as the <span class="No-Break">service contract.</span></p>
			<h3>Step 2 – defining a message payload</h3>
			<p>The message payload used for <strong class="source-inline">PUT</strong> and <strong class="source-inline">GET</strong> endpoints needs to be defined. The service contract itself is the <a id="_idIndexMarker291"/>resource, so its model is the payload. The <strong class="source-inline">PATCH</strong> endpoint does not need to return a payload. The payload will be defined<a id="_idIndexMarker292"/> using the <strong class="bold">OpenAPI 3.0</strong> model, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
    Party:
      type: object
      properties:
        householdName:
          type: string
        service:
          type: string
        agreedAt:
          type: string
          format: date-time
    ServiceContract:
      type: object
      properties:
        id:
          type: integer
          format: int32
        partyA:
          $ref: '#/components/schemas/Party'
        partyB:
          $ref: '#/components/schemas/Party'</pre>			<p>For simplicity’s sake, the <strong class="source-inline">ServiceContract</strong> class is defined by an integer ID and two parties. Each party has<a id="_idIndexMarker293"/> the name of the household, the service provided, and an optional time when the household agrees with the <span class="No-Break">service contract.</span></p>
			<h3>Step 3 – defining API specifications</h3>
			<p>Even though the three HTTP endpoints were identified in <em class="italic">step 1</em>, it is necessary to go into the details of each endpoint and define them as <span class="No-Break">API specifications.</span></p>
			<p>Let us assume that only the two<a id="_idIndexMarker294"/> households in the service contract can see the service contract. This means we need certain ways to authenticate and authorize the <strong class="source-inline">GET</strong> endpoint. In this example, we enforce that the <strong class="source-inline">GET</strong> request should include a header to specify which household requests it. In production<a id="_idIndexMarker295"/> systems, it should use something more secure, such as a <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) issued by a trusted <strong class="bold">identity and access management</strong> (<strong class="bold">IAM</strong>) system and the decoded token contains claims that would reveal the <a id="_idIndexMarker296"/><span class="No-Break">household name.</span></p>
			<p>Therefore, there are two input parameters for the <strong class="source-inline">GET</strong> endpoint, as described here in the OpenAPI <span class="No-Break">3.0 model:</span></p>
			<pre class="source-code">
      parameters:
        - in: path
          name: id
          required: true
          schema:
            type: integer
        - in: header
          name: household
          required: true
          schema:
            type: string</pre>			<p>The first input parameter is the identifier of the service contract, shown in the URI path. The second input parameter is <a id="_idIndexMarker297"/>the household name, found in <span class="No-Break">the header.</span></p>
			<p>As for the response, we need to consider the success and failure cases. The possible outcomes should be captured as HTTP status codes in the response, documented in the OpenAPI 3.0 model <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ServiceContract'
        '400':
          description: Failed request validation
        '403':
          description: Not authorized
        '404':
         description: Service contract not found</pre>			<p>The request can be valid, and the service contract exists, therefore an HTTP status code of <strong class="source-inline">200</strong> (OK) and the payload of the service contract are returned. The request could be initiated by a household not mentioned in the service contract, and therefore it is not authorized and an HTTP status code of 403 (Forbidden) is returned. Or the service contract of the given ID simply<a id="_idIndexMarker298"/> does not exist, and an HTTP status code of <strong class="source-inline">404</strong> (Not Found) <span class="No-Break">is returned.</span></p>
			<p>The <strong class="source-inline">PUT</strong> endpoint uses the same URI path variables and header values as the <strong class="source-inline">GET</strong> endpoint, and in addition, a request body, which is the service <span class="No-Break">contract itself:</span></p>
			<pre class="source-code">
      requestBody:
        description: The service contract to be created or updated
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ServiceContract'
        required: true</pre>			<p>The request body is the <strong class="source-inline">ServiceContract</strong> component itself, so the schema refers to the specification of <span class="No-Break">the component.</span></p>
			<p>The response of the <strong class="source-inline">PUT</strong> endpoint is quite different from the <strong class="source-inline">GET</strong> endpoint. All the different scenarios are captured by the HTTP status codes in <span class="No-Break">the response:</span></p>
			<pre class="source-code">
      responses:
        '200':
          description: Service contract updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ServiceContract'
        '201':
          description: Service contract created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ServiceContract'
        '400':
          description: Failed request validation
        '403':
          description: Not authorized</pre>			<p>Firstly, the service contract in the request payload may have used the same household names for both parties, and therefore it is not valid and an HTTP status code of <strong class="source-inline">400</strong> (Bad Request) is returned. Also, if the household name in the header does not appear in the service contract’s party section, then<a id="_idIndexMarker299"/> it is not authorized, and an HTTP status code of <strong class="source-inline">403</strong> (Forbidden) is returned. If the request is valid, there are two outcomes. If a new service contract is created in servers, the HTTP status code <strong class="source-inline">201</strong> (Created) is returned with the service contract as the payload. If an existing one is updated, then the HTTP status code <strong class="source-inline">200</strong> (OK) is returned instead, together with the service contract as <span class="No-Break">the payload.</span></p>
			<p>The final endpoint, the <strong class="source-inline">PATCH</strong> endpoint, is simple. It uses the exact same set of input parameters as the <strong class="source-inline">GET</strong> endpoint, as there is no need for a request body and the request merely needs to identify an existing service contract. All responses are <span class="No-Break">specified here:</span></p>
			<pre class="source-code">
      responses:
        '204':
          description: Agreed service contract
        '400':
          description: Failed request validation
        '403':
          description: Not authorized
        '404':
          description: Service contract not found</pre>			<p>The failed outcomes in the response of the <strong class="source-inline">PATCH</strong> endpoint are the same as the <strong class="source-inline">GET</strong> endpoint, in identifying an existing service contract. But the successful outcome of the <strong class="source-inline">PATCH</strong> endpoint is different<a id="_idIndexMarker300"/> from the other two endpoints, because it has no request body, and therefore an HTTP status code of <strong class="source-inline">204</strong> (No Content) <span class="No-Break">is returned.</span></p>
			<h3>Step 4 – server development</h3>
			<p>Now that we have the API specifications, we <a id="_idIndexMarker301"/>are ready to develop server endpoints. The corresponding entities need to be defined <span class="No-Break">in Kotlin:</span></p>
			<pre class="source-code">
data class ServiceContract(
    val id: Int,
    val partyA: Party,
    val partyB: Party,
)
data class Party(
    val householdName: String,
    val service: String,
    val agreedAt: Instant? = null,
)</pre>			<p>Note that this is semantically equivalent to the OpenAPI 3.0 <span class="No-Break">component definitions.</span></p>
			<p>It is recommended to use a highly available storage system to keep service contracts permanently, for example, a database. However, in this example, we simplify the repository to keep service contracts <span class="No-Break">in memory:</span></p>
			<pre class="source-code">
val contracts = ConcurrentHashMap&lt;Int, ServiceContract&gt;()</pre>			<p>This thread-safe in-memory map uses <a id="_idIndexMarker302"/>the integer IDs of the service contract as the keys and the <strong class="source-inline">ServiceContract</strong> objects as <span class="No-Break">the values.</span></p>
			<p>In this example, <strong class="bold">http4k</strong> is used as the <a id="_idIndexMarker303"/>server framework because of its small code footprint. We need to set up the means to read and write different values. This is achieved by declaring a<a id="_idIndexMarker304"/> couple of <strong class="bold">http4k Lenses</strong> to validate and transform the payload into <span class="No-Break">type-safe structures:</span></p>
			<pre class="source-code">
val serviceContractLens = Body.auto&lt;ServiceContract&gt;().toLens()
val householdHeader = Header.required("household")</pre>			<p>Here, we have the Lens for <strong class="source-inline">ServiceContract</strong> objects as the body and the household name in the header. They will be used in the actual <span class="No-Break">endpoint implementations.</span></p>
			<p>http4k configures endpoint routing by simply declaring an <strong class="source-inline">HTTPHandler</strong> using the <span class="No-Break"><strong class="source-inline">route()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
val app: HttpHandler =
    routes(
...
)</pre>			<p>Inside the <strong class="source-inline">route()</strong> function, a list of endpoints is declared and the details of the implementation are defined. The following are the implementation details of the <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> endpoint:</span></p>
			<pre class="source-code">
"/contracts/{id}" bind GET to { request -&gt;
    val household = householdHeader(request)
    val id = request.path("id")?.toInt()
    val contract = id?.let { contracts[it] }
    if (contract == null) {
        Response(NOT_FOUND).body("Service contract of ID $id not found")
    } else if (contract.partyA.householdName != household &amp;&amp; contract.partyB.householdName != household) {
        Response(FORBIDDEN).body("Household $household is not allowed to see the service contract of ID $id")
    } else {
        Response(OK).with(serviceContractLens of contract)
    }
}</pre>			<p>This implementation defines the routing URI of <strong class="source-inline">GET /contracts/{id}</strong>. Then, it uses the http4k Lens defined previously to read the household name from the header. The service contract ID is also read from the <span class="No-Break">path variable.</span></p>
			<p>Then there is an attempt to get the <strong class="source-inline">ServiceContract</strong> object from the in-memory map we defined previously. If the object is not found, an HTTP status of <strong class="source-inline">404</strong> (Not Found) is returned. If the service contract is found, but the household name in the header is not that of either <a id="_idIndexMarker305"/>party of the service contract, then an HTTP status of <strong class="source-inline">403</strong> (Forbidden) is returned. Otherwise, everything is fine, and an HTTP status of <strong class="source-inline">200</strong> (OK) is returned with the response body transformed from the <strong class="source-inline">ServiceContract</strong> object by the http4k Lens <span class="No-Break">defined previously.</span></p>
			<p>The <strong class="source-inline">PUT</strong> endpoint is also <span class="No-Break">defined similarly:</span></p>
			<pre class="source-code">
"/contracts/{id}" bind PUT to { request -&gt;
    val household = householdHeader(request)
    val lens = Body.auto&lt;ServiceContract&gt;().toLens()
    val id = request.path("id")?.toInt()
    val contract = lens(request)°
    if (id == null || id != contract.id) {
        Response(BAD_REQUEST).body("Service contract ID in the payload and the URI path do not match")
    } else if (contract.partyA.householdName == contract.partyB.householdName) {
        Response(BAD_REQUEST).body("Service contract must have two different household: $household")
    } else if (contract.partyA.householdName != household &amp;&amp; contract.partyB.householdName != household) {
        Response(FORBIDDEN).body("Household $household is not allowed to update the service contract of ID $id")
    } else {
        val previous = contracts.put(contract.id, contract)
        val status = if (previous == null) CREATED else OK
        Response(status).with(serviceContractLens of contract)
    }
}</pre>			<p>However, the <strong class="source-inline">PUT</strong> endpoint transforms the request body into a <strong class="source-inline">ServiceContract </strong>object with the <span class="No-Break">http4k Lens.</span></p>
			<p>The service contract ID from the <a id="_idIndexMarker306"/>URI path variable is checked against the <strong class="source-inline">ServiceContract</strong> object to ensure that the ID is the same as the <strong class="source-inline">id</strong> field inside the object. Also, there is a validation to ensure that household names in each party of the <strong class="source-inline">ServiceContract</strong> object are different. Any validation failures here would result in returning an HTTP status code of <strong class="source-inline">400</strong> (<span class="No-Break">Bad Request).</span></p>
			<p>Like the <strong class="source-inline">GET</strong> endpoint, there is a check to ensure the household name in the header matches that of one of the parties in the <strong class="source-inline">ServiceContract</strong> object; otherwise, an HTTP status code of <strong class="source-inline">403</strong> (Forbidden) <span class="No-Break">is returned.</span></p>
			<p>Afterward, the <strong class="source-inline">ServiceContract</strong> object is put into the in-memory map. The <strong class="source-inline">put</strong> function returns the previous value associated with the key. If the previous value is <strong class="source-inline">null</strong>, then an HTTP status of <strong class="source-inline">201</strong> (Created) is returned; otherwise, an HTTP status of <strong class="source-inline">200</strong> (OK) is returned. Both cases come with the response body transformed from the <strong class="source-inline">ServiceContract</strong> object by the http4k Lens <span class="No-Break">defined previously.</span></p>
			<p>The last endpoint, <strong class="source-inline">PATCH</strong>, has a very similar implementation to the <strong class="source-inline">GET</strong> endpoint in the first half. The same input parameters are read, and the servers attempt to get the <strong class="source-inline">ServiceContract</strong> object from <a id="_idIndexMarker307"/>the in-memory map. The first part of the implementation ends with the <span class="No-Break">necessary validations:</span></p>
			<pre class="source-code">
"/contracts/{id}/agreedAt" bind PATCH to { request -&gt;
    val household = householdHeader(request)
    val id = request.path("id")?.toInt()
    val contract = id?.let { contracts[id] }
    if (contract == null) {
        Response(NOT_FOUND).body("Service contract of ID $id not found")
    } else if (contract.partyA.householdName != household &amp;&amp; contract.partyB.householdName != household) {
        Response(FORBIDDEN).body("Household $household is not allowed to see the service contract of ID $id")</pre>			<p>After validating the request, the household that agrees to the contract is located. An <strong class="source-inline">agreedAt</strong> timestamp is set to the relevant party of the contract. Also, the revised contract is put to the shared <strong class="source-inline">ConcurrentHashMap</strong> <span class="No-Break">previously declared:</span></p>
			<pre class="source-code">
    } else {
        val now = Instant.now()
        val revisedContract =
            if (contract.partyA.householdName == household) {
                contract.copy(partyA = contract.partyA.copy(agreedAt = now))
            } else {
                contract.copy(partyB = contract.partyB.copy(agreedAt = now))
            }
        contracts[contract.id] = revisedContract
        Response(NO_CONTENT).with(serviceContractLens of contract)
    }
}</pre>			<p>The second part of the implementation focuses on adding the <strong class="source-inline">agreedAt</strong> timestamp to the correct party of the <strong class="source-inline">ServiceContract</strong> object. Since validation has passed to ensure that the household is either one of the two, the servers determine which one it is and create a variant of the original <strong class="source-inline">ServiceContract</strong> object, with the <strong class="source-inline">agreedAt</strong> timestamp set to the <a id="_idIndexMarker308"/>current timestamp, using the <strong class="source-inline">copy</strong> function. The value in memory is then updated. An HTTP status code of <strong class="source-inline">204</strong> (No Content) is <span class="No-Break">then returned.</span></p>
			<p>Finally, there is the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
fun main() {
    val printingApp: HttpHandler = PrintRequest().then(app)
    val server = printingApp.asServer(Undertow(9000)).start()
}</pre>			<p>The <strong class="source-inline">main</strong> function launches the server and starts listening to requests incoming on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">9000</strong></span><span class="No-Break">.</span></p>
			<h3>Step 5 – client development</h3>
			<p>As mentioned earlier, clients always initiate interactions <a id="_idIndexMarker309"/>with servers. So, the client implementation in this example reflects the client-server interaction in the sequence diagram in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.3</em>. For simplicity reasons, we use a <strong class="source-inline">main</strong> function to simulate both households in this example. We<a id="_idIndexMarker310"/> start with creating <a id="_idIndexMarker311"/>an HTTP client <span class="No-Break">using </span><span class="No-Break"><strong class="bold">OKHTTP</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
val client: HttpHandler = OkHttp()
val printingClient: HttpHandler = PrintResponse().then(client)</pre>			<p>Then, the initial service contract drafted by <em class="italic">Household A</em> <span class="No-Break">is created:</span></p>
			<pre class="source-code">
val initialContractDraftedByHouseholdA =
    ServiceContract(
        id = 1,
        partyA = Party("A", "Plumbing"),
        partyB = Party("B", "Cleaning"),
    )
printingClient(
    Request(PUT, "http://localhost:9000/contracts/1").with(
        householdHeader of "A",
        Body.json().toLens() of
            initialContractDraftedByHouseholdA.asJsonObject(),
    ),
)</pre>			<p>Then, the initial service contract is submitted to servers by calling the <strong class="source-inline">PUT</strong> endpoint. Subsequently, <em class="italic">Household B</em> received the initial service contract by calling the <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> endpoint:</span></p>
			<pre class="source-code">
val contractReceivedByB =
    serviceContractLens(
        printingClient(
            Request(GET, "http://localhost:9000/contracts/1").with(householdHeader of "B"),
        ),
    )
val contractRevisedByB =
    contractReceivedByB.copy(
        partyB = contractReceivedByB.partyB.copy(service = "Babysitting"),
    )
printingClient(
    Request(PUT, "http://localhost:9000/contracts/1").with(
        householdHeader of "B",
        Body.json().toLens() of
            contractRevisedByB.asJsonObject(),
    ),
)</pre>			<p><em class="italic">Household B</em> revises the <a id="_idIndexMarker312"/>contract and submits the revised contract to the server by calling the <strong class="source-inline">PUT</strong> endpoint. Then, <em class="italic">Household A</em> receives the revised contract by calling the <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> endpoint:</span></p>
			<pre class="source-code">
val contractReceivedByA =
    serviceContractLens(
        printingClient(
            Request(GET, "http://localhost:9000/contracts/1").with(householdHeader of "A"),
        ),
    )
printingClient(Request(PATCH, "http://localhost:9000/contracts/1/agreedAt").with(householdHeader of "A"))</pre>			<p><em class="italic">Household A</em> is happy with the revised contract. <em class="italic">Household A</em> acknowledges its agreement to the service contract through the servers, by calling the <strong class="source-inline">PATCH</strong> endpoint. Now it is <em class="italic">Household B</em>’s turn to <a id="_idIndexMarker313"/>receive and acknowledge the <span class="No-Break">service contract:</span></p>
			<pre class="source-code">
val revisedContractReceivedByB =
    serviceContractLens(
        printingClient(
            Request(GET, "http://localhost:9000/contracts/1").with(householdHeader of "B"),
        ),
    )
if (revisedContractReceivedByB.partyA.agreedAt != null) {
    printingClient(Request(PATCH, "http://localhost:9000/contracts/1/agreedAt").with(householdHeader of "B"))
}</pre>			<p><em class="italic">Household B</em> sees that <em class="italic">Household A</em> agreed to the service contract. <em class="italic">Household B</em> then also acknowledges its agreement to the service contract through the servers, by calling the <strong class="source-inline">PUT</strong> endpoint. Finally, it comes back to <em class="italic">Household A</em> to receive the service contract agreed by <span class="No-Break">both households:</span></p>
			<pre class="source-code">
val contractAgreedByBoth =
    serviceContractLens(
        printingClient(
            Request(GET, "http://localhost:9000/contracts/1").with(householdHeader of "A"),
        ),
    )</pre>			<p>The client-service interaction in this example has concluded. The service contract between <em class="italic">Household A</em> and <em class="italic">Household B</em> is mutually agreed upon <span class="No-Break">and synchronized.</span></p>
			<p>Throughout this example implementation, we <a id="_idIndexMarker314"/>demonstrated how to divide the roles of clients and servers in solving the service contract synchronization problem with the <span class="No-Break">client-server architecture.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor116"/>What systems use client-server architecture?</h2>
			<p>Client-server architecture is widely used in<a id="_idIndexMarker315"/> many systems. Here are a couple <span class="No-Break">of examples:</span></p>
			<ul>
				<li><strong class="bold">B2C systems</strong>: Most <strong class="bold">business-to-customer</strong> (<strong class="bold">B2C</strong>) systems use client-server architecture, where the client is either<a id="_idIndexMarker316"/> a web browser or a mobile application. A client holds very little data, only data about the user. Meanwhile, servers hold most of the data of <span class="No-Break">all clients.</span></li>
				<li><strong class="bold">B2B systems</strong>: Most <strong class="bold">business-to-business</strong> (<strong class="bold">B2B</strong>) systems use client-server architecture, where a part of the business <a id="_idIndexMarker317"/>system of a firm acts as a client to servers of another business system of another firm. These systems share some data because of the communication between clients <span class="No-Break">and servers.</span></li>
				<li><strong class="bold">Online gaming</strong>: Many online <a id="_idIndexMarker318"/>games use client-server architecture to maintain a shared state of the game among multiple players. The game client runs on players’ devices and <a id="_idIndexMarker319"/>communicates with the game server to synchronize states and interact with <span class="No-Break">other players.</span></li>
				<li><strong class="bold">Financial service systems</strong>: Finance services are heavily regulated by various authorities and there are strict rules on how the data is stored and distributed. Client-server architecture can keep unnecessary data away from clients and have servers keeping sensitive data and complying with regulatory and <span class="No-Break">audit controls.</span></li>
				<li><strong class="bold">Instant messaging, chat, and email systems</strong>: Popular messaging platforms such as Slack, WhatsApp, Discord, and Microsoft Outlook use the client-server architecture. Clients connect to the servers to send and receive messages to other clients, broadcast messages to a group of clients, share files, and participate in <span class="No-Break">real-time chat.</span></li>
			</ul>
			<p>Coming next, we will explore another option, P2P architecture, and how the same problem of the households and their service contracts can be <span class="No-Break">solved differently.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor117"/>P2P architecture</h1>
			<p>P2P architecture is rooted in the idea of<a id="_idIndexMarker320"/> the absence of a centralized authority for coordination. A P2P network is formed of numerous nodes (“peers”) that have equal roles in communicating with <span class="No-Break">one another.</span></p>
			<p>Each node can request resources or services from other nodes, while also providing resources or services to other nodes. This distributed nature of P2P networks enables efficient resource sharing and collaboration <span class="No-Break">among participants.</span></p>
			<p>There is no hard non-functional requirement on the computational power, storage, and network bandwidth for each node coming from the P2P architecture. However, consistency is a major non-functional concern in many <span class="No-Break">P2P systems.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor118"/>Consistency</h2>
			<p>There is no central authority or server that <a id="_idIndexMarker321"/>controls the data in a P2P system. Each node stores and manages its own data, and the nodes communicate directly with each other to share and synchronize information. This distributed nature of P2P systems brings several <span class="No-Break">consistency challenges:</span></p>
			<ul>
				<li><strong class="bold">Data replication and concurrency control</strong>: A node in a P2P system often replicates its data across multiple nodes to improve availability and fault tolerance. This replication can lead to inconsistencies if the data is modified at different nodes at the same time. It is crucial that updates are propagated to all relevant nodes in a <span class="No-Break">timely manner.</span><p class="list-inset">Moreover, if multiple nodes update the same data at the same time, there is a conflict about which update should take place. Implementing effective concurrency control mechanisms, such as locking, versioning, or conflict resolution strategies, is necessary to maintain <span class="No-Break">data consistency.</span></p></li>
				<li><strong class="bold">Eventual consistency</strong>: In a distributed network where nodes are spread out, delays and partitions can<a id="_idIndexMarker322"/> occur, making it difficult to achieve strong and immediate consistency. Instead, <strong class="bold">peer-to-peer</strong> (<strong class="bold">P2P</strong>) systems focus on eventual consistency, meaning<a id="_idIndexMarker323"/> that a consistent state will eventually be reached after some time, even in the presence of network disruptions or <span class="No-Break">node failures.</span></li>
				<li><strong class="bold">Causal consistency</strong>: Another option for consistency is causal consistency, where related events are received by all nodes in the same order, and unrelated events are received in <span class="No-Break">any order.</span></li>
				<li><strong class="bold">Consensus and Quorum</strong>: In some P2P systems, all nodes must reach a specific state or be updated before changes are accepted. This is known as the consensus approach. Alternatively, a <a id="_idIndexMarker324"/>quorum-based approach requires agreement from only a majority of nodes. Both methods help maintain a certain level of consistency but introduce extra coordination and <span class="No-Break">communication overhead.</span></li>
				<li><strong class="bold">Merkle trees and hashing</strong>: Merkle trees or hash-based approaches can be used to efficiently detect and resolve inconsistencies in the distributed data, allowing nodes to quickly identify and synchronize their data. These approaches are widely used in decentralized systems such as <span class="No-Break">blockchain networks.</span></li>
			</ul>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor119"/>Bootstrapping and node discovery</h2>
			<p>A P2P network starts with the first node available, and then other nodes join. This process is called <strong class="bold">bootstrapping</strong>. Before a <a id="_idIndexMarker325"/>new node joins an existing<a id="_idIndexMarker326"/> P2P network, the new <a id="_idIndexMarker327"/>node must somehow discover at least one other node in the network. We will now cover several node <span class="No-Break">discovery mechanisms.</span></p>
			<h3>Static</h3>
			<p>The most basic way to discover a node is that each node has the addresses of all other nodes in static configurations. The <a id="_idIndexMarker328"/>obvious limitation of this approach is the number of nodes that can be configured. The limitation of IP addresses can be overcome <a id="_idIndexMarker329"/>by techniques such as <strong class="bold">relay servers</strong>, <strong class="bold">network address translation</strong> (<strong class="bold">NAT</strong>), and <strong class="bold">hole-punching</strong>. This is about storage and memory limitations to <a id="_idIndexMarker330"/>hold the addresses of all nodes in <a id="_idIndexMarker331"/><span class="No-Break">each node.</span></p>
			<p>A P2P network with static node discovery can be bootstrapped by attempting to connect each node from the <span class="No-Break">static configuration.</span></p>
			<h3>Centralized directory</h3>
			<p>Contrary to the concept of <a id="_idIndexMarker332"/>decentralization, some P2P networks have a centralized directory that maintains a list of active nodes in the network. That means the network starts with the centralized directory being available. When a node joins the network, it lists itself as available in the directory. Also, each node can get a list of available nodes from the <span class="No-Break">centralized directory.</span></p>
			<p>The centralized directory falls into the category of servers, which requires very different system quality attributes from other nodes. For example, the centralized directory must be highly available; otherwise, it cannot accept new nodes or provide a list of <span class="No-Break">available nodes.</span></p>
			<h3>Multicast or broadcast</h3>
			<p>In a private or <strong class="bold">local area network</strong> (<strong class="bold">LAN</strong>), a P2P <a id="_idIndexMarker333"/>network can be established by having each node send broadcast or multicast messages to all other nodes. A couple of nodes can decide to respond, and the <a id="_idIndexMarker334"/>originator node is able to discover them. The network is started the first time a node is discovered. This discovery mechanism is suitable only for small networks with a limited number <span class="No-Break">of nodes.</span></p>
			<p>Multicast networks <a id="_idIndexMarker335"/>usually use <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) as the transport protocol. This is usually configured in a designated subnet to avoid broadcast floods and limit <span class="No-Break">security risks.</span></p>
			<h3>Kademlia</h3>
			<p><strong class="bold">Kademlia</strong> is a specification of the <a id="_idIndexMarker336"/>network structure and message protocol that is used in P2P networks. A <strong class="bold">distributed hash table</strong> (<strong class="bold">DHT</strong>) emerges across multiple nodes in the<a id="_idIndexMarker337"/> network. The network usually uses multicast UDP as the <span class="No-Break">transport protocol.</span></p>
			<p>Each node has a node ID, which<a id="_idIndexMarker338"/> is usually an unsigned big random integer number. The node ID prefix is used to calculate a hash value using a universal hash function. The hash value translates to a bucket in the hash table, and this is how each node maintains the IDs of other nodes in its local hash table and uses it as a <span class="No-Break">routing table.</span></p>
			<p>When a node joins the network, it broadcasts its node ID to all nodes in the network. Then, other nodes find a bucket to keep the ID of the new node in their <span class="No-Break">routing tables.</span></p>
			<p>Node IDs that are close to each other have their buckets close to each other as well. The “distance” between two node IDs <a id="_idIndexMarker339"/>calculated by the <strong class="bold">exclusive OR</strong> (<strong class="bold">XOR</strong>) function is used for node discovery. When a node wants to discover another node in the network, it starts from the bucket that is closest to its node ID and iteratively finds a responsive node by traversing buckets, from the closest to the <span class="No-Break">farthest away.</span></p>
			<h3>Exchanging information with other nodes</h3>
			<p>Nodes can share their<a id="_idIndexMarker340"/> own nodes among themselves as well. The exchange among nodes comes with a <span class="No-Break">few variations.</span></p>
			<p>If the P2P network has a well-known structure, such as a DHT, a node can crawl the structure using a certain protocol to query nodes for information about other nodes. The downside is that a newly joined node would still need another mechanism to get an initial list <span class="No-Break">of nodes.</span></p>
			<p>A newly joined node can also contact a few bootstrapping nodes to query information about other nodes. This does, however, rely on the availability of the well-known <span class="No-Break">bootstrapping nodes.</span></p>
			<p>A gossip protocol can also be employed among nodes to periodically share information with a few random neighbor nodes. The information should collectively spread like gossiping or an epidemic, though it takes some time to emerge. This protocol scales very well from small to big networks. It is also fault-tolerant, which means if a neighbor node fails, other neighbor nodes would still be able to provide <span class="No-Break">alternative information.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor120"/>Communication among nodes</h2>
			<p>Once a node has<a id="_idIndexMarker341"/> information on how to contact other nodes in the network, it can <span class="No-Break">initiate communication.</span></p>
			<h3>Direct communication with IP addresses</h3>
			<p>The most basic form of communication between two nodes is to have one node directly contact another node using<a id="_idIndexMarker342"/> an IP address. This approach is often used in small networks or LANs. Nodes in the network use transport protocols such as TCP for more reliable and ordered messages, or they use UDP for faster and <span class="No-Break">unordered messages.</span></p>
			<h3>Hole-punching</h3>
			<p>For a node under one local <a id="_idIndexMarker343"/>network to connect to another node under <a id="_idIndexMarker344"/>another local network, the nodes are not able to use IP addresses for direct communication. Let us consider the situation in the following sample network topology. See <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B21737_04_4.jpg" alt="Figure 4.4 – A sample network topology with home networks" width="1299" height="1163"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – A sample network topology with home networks</p>
			<p><em class="italic">Node 1</em> has no direct way to<a id="_idIndexMarker345"/> communicate with <em class="italic">Node 2</em> via the internet, since both nodes are behind their own home networks. However, if the <a id="_idIndexMarker346"/>home networks and <strong class="bold">internet service provider</strong> (<strong class="bold">ISP</strong>) networks support NAT, then <strong class="bold">hole-punching</strong> can be employed to allow <em class="italic">Node 1</em> to indirectly communicate<a id="_idIndexMarker347"/> with <em class="italic">Node 2</em> with this <span class="No-Break">relay mechanism.</span></p>
			<p>NAT is a mechanism that translates local network addresses to public and global IP addresses. As a result, both <em class="italic">Node 1</em> and <em class="italic">Node 2</em> have their own global IP addresses, and they can communicate with each other. This is illustrated in the <span class="No-Break">diagram here:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B21737_04_5.jpg" alt="Figure 4.5 – A sample network topology with home networks and NATs" width="1628" height="1137"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – A sample network topology with home networks and NATs</p>
			<p><em class="italic">Node 1</em> has opened its port <strong class="source-inline">443</strong> to receive messages and can be located by the private IP address <strong class="source-inline">192.168.1.10</strong> under its home network. Its home network has a NAT mapping of <strong class="source-inline">192.168.1.10:443</strong> (as an<a id="_idIndexMarker348"/> internal address) to <strong class="source-inline">10.168.3.234:80006</strong> (as an external address). Then, the ISP network also has a NAT mapping of an internal address of <strong class="source-inline">10.168.3.234:80006</strong> to a global address of <strong class="source-inline">108.27.39.3:24390</strong>. <em class="italic">Node 2</em> has a similar NAT mapping path except its global address <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">23.1.80.0:2877</strong></span><span class="No-Break">.</span></p>
			<p>From this point, we can start the hole-punching in steps, and assume <em class="italic">Node 1</em> has already discovered <em class="italic">Node 2</em>’s global address. Firstly, <em class="italic">Node 1</em> contacts its home network with the source local address (<em class="italic">Node 1</em>) and the target global address (<em class="italic">Node 2</em>). Then, the home network relays this information and contacts its ISP <span class="No-Break">network similarly.</span></p>
			<p>The ISP network where <em class="italic">Node 1</em> originated then contacts another ISP network where <em class="italic">Node 2</em> originated, using the <span class="No-Break">global address.</span></p>
			<p>The ISP network where <em class="italic">Node 2</em> originated contacts the target local home network with the translated address local to the ISP network. Then, the home network contacts the target <em class="italic">Node 2</em> in its network with the translated address local to the <span class="No-Break">home network.</span></p>
			<p>The NATs punch temporary <em class="italic">holes</em> in their respective tables where they translate internal and external addresses. As a result, <em class="italic">Node A</em> and <em class="italic">Node B</em> can establish communication with multiple networks and NATs in the middle to <span class="No-Break">relay messages.</span></p>
			<p>Note that hole-punching <a id="_idIndexMarker349"/>behind firewalls would not work if the firewalls were stateless. Stateless firewalls do not track connections and do not remember the translations <span class="No-Break">of addresses.</span></p>
			<h3>Publish-subscribe</h3>
			<p><strong class="bold">Publish-subscribe</strong> is an alternative model for P2P communication, where node discovery is not necessary. Instead, nodes <a id="_idIndexMarker350"/>publish messages to specific topics of interest, and other nodes subscribed to those<a id="_idIndexMarker351"/> topics would receive the messages. If the messages are delivered with a broker, then nodes still need to know the address of the broker to publish and receive messages. Publish-subscribe removes the need for node discovery and spreads information efficiently to <span class="No-Break">relevant receivers.</span></p>
			<p>An example of a publish-subscribe architecture with a broker is shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B21737_04_6.jpg" alt="Figure 4.6 – Publish-subscribe architecture" width="1108" height="497"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Publish-subscribe architecture</p>
			<p>The publisher does not know the subscribers. It knows the address of the broker and the topic where a message should be published. Subscribers register their interests in certain topics with the broker and receive messages associated with <span class="No-Break">the topics.</span></p>
			<p>The broker is a type of infrastructure middleware that receives messages from publishers. It stores the messages and manages subscriptions by subscribers. Most importantly, it routes messages to the appropriate subscribers based on their <span class="No-Break">registered interests.</span></p>
			<p>Now, we are going to<a id="_idIndexMarker352"/> delve into the implementation of the<a id="_idIndexMarker353"/> <span class="No-Break">P2P solution.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor121"/>The P2P solution</h2>
			<p>We are going to apply the P2P<a id="_idIndexMarker354"/> architecture to solve a real-life example of service contract synchronization between two households. For simplicity’s sake, let us assume the two households have already discovered each other and their devices run in the same <span class="No-Break">local network.</span></p>
			<h3>Step 1 – defining P2P communication</h3>
			<p>We are going to draft the interactions<a id="_idIndexMarker355"/> between nodes before coding. Let us assume that UDP is used as the communication protocol. Nodes communicate directly with each other, using IP addresses and ports. See <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B21737_04_7.jpg" alt="Figure 4.7 – Sample P2P interaction service contract synchronization" width="778" height="846"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Sample P2P interaction service contract synchronization</p>
			<p>The following are the messages sent between the nodes of <em class="italic">Household A</em> and <em class="italic">Household B</em> as described in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
			<ol>
				<li><em class="italic">Household A</em> submits a draft of a service contract to <span class="No-Break"><em class="italic">Household B</em></span><span class="No-Break">.</span></li>
				<li><em class="italic">Household B</em> revises the service contract and submits it to <span class="No-Break"><em class="italic">Household A</em></span><span class="No-Break">.</span></li>
				<li><em class="italic">Household A</em> acknowledges<a id="_idIndexMarker356"/> to <em class="italic">Household B</em> that it agrees with the <span class="No-Break">service contract.</span></li>
				<li><em class="italic">Household B</em> acknowledges to <em class="italic">Household A</em> that it agrees with the <span class="No-Break">service contract.</span></li>
			</ol>
			<p>After the communication protocol is defined, the message’s payload should be defined as the <span class="No-Break">next step.</span></p>
			<h3>Step 2 – defining the message payload</h3>
			<p>From the communication<a id="_idIndexMarker357"/> defined previously, the only message that passes around is the service contract itself. The model of the service contract remains <span class="No-Break">the same:</span></p>
			<pre class="source-code">
data class ServiceContract(
    val id: Int,
    val partyA: Party,
    val partyB: Party,
)
data class Party(
    val householdName: String,
    val service: String,
    val agreedAt: Instant? = null,
)</pre>			<p>In this example, we externalize the <strong class="source-inline">ServiceContract</strong> class as a byte array to be sent across <span class="No-Break">the wire.</span></p>
			<h3>Step 3 – peer development</h3>
			<p>Let us start with scaffolding some necessary transport functions for nodes to communicate using UDP. As a<a id="_idIndexMarker358"/> node can produce and consume a message, it seems sensible to define a generic UDP node class <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class UdpNode&lt;T&gt;(
    val address: SocketAddress,
    val convertor: DtoConvertor&lt;T&gt;,
    val transformer: (T) -&gt; T?,
) {
    private val inbound: ByteBuffer = convertor.allocate()
    private val outbound: ByteBuffer = convertor.allocate()
    private var channel: DatagramChannel? = null</pre>			<p>The <strong class="source-inline">UdpNode</strong> class<a id="_idIndexMarker359"/> uses the <strong class="bold">Non-Blocking Input/Output</strong> (<strong class="bold">NIO</strong>) package to support three <span class="No-Break">major functions:</span></p>
			<ul>
				<li>Bootstrapping <span class="No-Break">the node</span></li>
				<li>Sending a message to a <span class="No-Break">target node</span></li>
				<li>Receiving a message from <span class="No-Break">another node</span></li>
			</ul>
			<p>While supporting these functions, the <strong class="source-inline">UdpNode</strong> class should only be changed if the transport mechanism needs to change, leaving it with a single responsibility of addressing concerns at the transport<a id="_idIndexMarker360"/> level, and conforming to the <span class="No-Break"><strong class="bold">single-responsibility principle</strong></span><span class="No-Break">.</span></p>
			<p>Therefore, the serialization and deserialization of the <strong class="source-inline">ServiceContract</strong> class is delegated to the <strong class="source-inline">DtoConvertor</strong> interface with generic type <strong class="source-inline">T</strong>, so the <strong class="source-inline">UdpNode</strong> class is not coupled to the <span class="No-Break"><strong class="source-inline">ServiceContract</strong></span><span class="No-Break"> class.</span></p>
			<p>The handling of and responding to a <strong class="source-inline">ServiceContract</strong> object is an application-level concern, and this concern is delegated to a transformer lambda from <span class="No-Break">the constructor.</span></p>
			<p>The <strong class="source-inline">start</strong> function of the <strong class="source-inline">UdpNode</strong> class is simple. It binds the node to the configured address and gets it ready to consume <span class="No-Break">a message:</span></p>
			<pre class="source-code">
    fun start() {
        channel =
            DatagramChannel.open()
                .bind(address)
     }</pre>			<p>The <strong class="source-inline">produce</strong> function clears the outbound buffer before it calls <strong class="source-inline">DtoConvertor</strong> to write on it. Then, the buffer is <a id="_idIndexMarker361"/>sent to <span class="No-Break">the channel:</span></p>
			<pre class="source-code">
    fun produce(
        payload: T,
        target: SocketAddress,
    ): Int {
        outbound.clear()
        convertor.toBuffer(payload, outbound)
        outbound.flip()
        return channel!!.send(outbound, target)
    }</pre>			<p>The <strong class="source-inline">consume</strong> function clears the inbound buffer first, then the channel receives the byte array and writes it to the buffer. Then, <strong class="source-inline">DtoConvertor</strong> is called to convert the byte array into a <span class="No-Break"><strong class="source-inline">ServiceContract</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
    fun consume(): Int {
        return channel?.let { c -&gt;
            inbound.clear()
            val address: SocketAddress = c.receive(inbound)
            inbound.rewind()
            val received = convertor.fromBuffer(inbound)
            transformer(received)?.let { transformed -&gt;
                produce(transformed, address)
            }
        } ?: 0
    }
}</pre>			<p>The transformer lambda is called to determine the response to the <strong class="source-inline">ServiceContract</strong> object. If the response is <strong class="source-inline">null</strong>, then nothing happens. If the response is another <strong class="source-inline">ServiceContract</strong> object, then the <strong class="source-inline">produce</strong> function is called to send the response back to<a id="_idIndexMarker362"/> the node that sends the <span class="No-Break">original message.</span></p>
			<p>Another important class in this example is <strong class="source-inline">DtoConvertor</strong>. It is designed to be generic and to encapsulate the serialization and deserialization of a generic type, <strong class="source-inline">E</strong>, to a byte array. There are only <span class="No-Break">three functions:</span></p>
			<pre class="source-code">
interface DtoConvertor&lt;E&gt; {
    fun allocate(): ByteBuffer
    fun toBuffer(dto: E, buffer: ByteBuffer)
    fun fromBuffer(buffer: ByteBuffer): E
}</pre>			<p>The <strong class="source-inline">allocate</strong> function<a id="_idIndexMarker363"/> creates a <strong class="source-inline">ByteBuffer</strong> that is large enough to hold the designated type. The <strong class="source-inline">toBuffer</strong> function writes a <strong class="bold">data transfer object</strong> (<strong class="bold">DTO</strong>) of type <strong class="source-inline">E</strong> to <strong class="source-inline">ByteBuffer</strong>, and the <strong class="source-inline">fromBuffer</strong> function reads a DTO of type <strong class="source-inline">E</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">ByteBuffer</strong></span><span class="No-Break">.</span></p>
			<p>A Kotlin singleton, <strong class="source-inline">ServiceContractConvertor</strong>, is declared to implement the <strong class="source-inline">DtoConvertor</strong> interface with the <span class="No-Break"><strong class="source-inline">ServiceContract</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
object ServiceContractConvertor : DtoConvertor&lt;ServiceContract&gt; {
    override fun allocate(): ByteBuffer {
        return ByteBuffer.allocate(1024)
    }</pre>			<p>The <strong class="source-inline">toBuffer</strong> function writes each field in a <strong class="source-inline">ServiceContract</strong> object in a <span class="No-Break">certain order:</span></p>
			<pre class="source-code">
    override fun toBuffer(dto: ServiceContract, buffer: ByteBuffer) { buffer.putInt(dto.id).putParty(dto.partyA).putParty(dto.partyB)
    }
    private fun ByteBuffer.putParty(dto: Party): ByteBuffer = putString(dto.householdName).putString(dto.service).putInstant(dto.agreedAt)
    private fun ByteBuffer.putInstant(dto: Instant?): ByteBuffer =
        if (dto == null) {
            putChar(ABSENT)
        } else {
            putChar(PRESENT).putLong(dto.epochSecond)
        }
    private fun ByteBuffer.putString(dto: String): ByteBuffer = putInt(dto.length).put(dto.toByteArray())</pre>			<p>The <strong class="source-inline">fromBuffer</strong> function <a id="_idIndexMarker364"/>reads from a <strong class="source-inline">ByteBuffer</strong> each field of the <strong class="source-inline">ServiceContract</strong> object in the same order and returns <span class="No-Break">the object:</span></p>
			<pre class="source-code">
    override fun fromBuffer(buffer: ByteBuffer): ServiceContract = ServiceContract(buffer.getInt(), buffer.getParty(), buffer.getParty())
    private fun ByteBuffer.getParty(): Party = Party(getString(), getString(), getInstant())
    private fun ByteBuffer.getInstant(): Instant? =
        if (getChar() == PRESENT) {
            Instant.ofEpochSecond(getLong())
        } else {
            null
        }
    private fun ByteBuffer.getString(): String {
        val bytes = ByteArray(getInt())
        get(bytes)
        return String(bytes)
    }</pre>			<p>Finally, there are two <strong class="source-inline">main</strong> functions, one for <em class="italic">Household A</em> and one for <em class="italic">Household B</em>, to represent how each of them<a id="_idIndexMarker365"/> negotiates the <span class="No-Break">service contract.</span></p>
			<p><em class="italic">Household A</em>’s behaviors are defined in the following code block, and then the node <span class="No-Break">starts listening:</span></p>
			<pre class="source-code">
fun main() {
    val node =
        UdpNode(
            InetSocketAddress(HOST_A, PORT_A),
            ServiceContractConvertor,
        ) { it.receivedByHouseholdA() }
    node.start()</pre>			<p><em class="italic">Household A</em> does not respond to a <strong class="source-inline">ServiceContract</strong> object under the <span class="No-Break">following circumstances:</span></p>
			<ol>
				<li>The same household name appears in <span class="No-Break">both parties</span></li>
				<li>Both households have already agreed to <span class="No-Break">the contract</span></li>
				<li><em class="italic">Household A</em> is not involved in <span class="No-Break">any party</span></li>
			</ol>
			<p>Otherwise, <em class="italic">Household A</em> agrees <a id="_idIndexMarker366"/><span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ServiceContract</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    val contract =
        ServiceContract(
            id = 1,
            partyA = Party(HOUSEHOLD_A, PLUMBING, null),
            partyB = Party(HOUSEHOLD_B, CLEANING, null),
        )
    node.produce(contract, InetSocketAddress(HOST_B, PORT_B))
    println("Submitted service contract: ${contract.id}")
    loopForever(1000) { node.consume() }
}
private fun ServiceContract.receivedByHouseholdA() =
    if (bothPartiesHaveDifferentNames().not() ||
        partyAgreed(HOUSEHOLD_A) ||
        isHouseholdInvolved(HOUSEHOLD_A).not()
    ) {
        println("No response to service contract: $this")
        null
    } else {
        println("Agreed to service contract: $id")
        agree(HOUSEHOLD_A) { Instant.now() }
    }</pre>			<p>Then, <em class="italic">Household A</em> sends the draft contract to <em class="italic">Household B</em>. At the end, <em class="italic">Household A</em> enters an infinite loop to try to <a id="_idIndexMarker367"/>consume any <span class="No-Break">further messages.</span></p>
			<p>On the other hand, <em class="italic">Household B</em> has its behaviors defined in another <strong class="source-inline">main</strong> function and then it <span class="No-Break">starts listening:</span></p>
			<pre class="source-code">
fun main() {
    val node =
        UdpNode(
            InetSocketAddress(HOST_B, PORT_B),
            ServiceContractConvertor,
        ) { it.receivedByHouseholdB() }
    node.start()
    loopForever(1000) { node.consume() }
}
fun ServiceContract.receivedByHouseholdB() =
    if (bothPartiesHaveDifferentNames().not() ||
        partyAgreed(HOUSEHOLD_B) ||
        isHouseholdInvolved(HOUSEHOLD_B).not()
    ) {
        println("No response to service contract: ${this}")
        null
    } else if (serviceReceivedBy(HOUSEHOLD_B) == CLEANING) {
        println("Submitted revised service contract: $id")
        withReceivedService(HOUSEHOLD_B, BABYSITTING)
    } else if (serviceReceivedBy(HOUSEHOLD_B) == BABYSITTING) {
        println("Agreed to service contract: $id")
        agree(HOUSEHOLD_B) { Instant.now() }
    } else {
        println("No response to service contract: $id")
        null
    }</pre>			<p>Similarly, <em class="italic">Household B</em> does not respond to a <strong class="source-inline">ServiceContract</strong> object under the following <span class="No-Break">circumstances:</span></p>
			<ul>
				<li>The same household <a id="_idIndexMarker368"/>name appears in both parties as it is <span class="No-Break">not valid</span></li>
				<li>Both households have already agreed to <span class="No-Break">the contract</span></li>
				<li><em class="italic">Household B</em> is not involved in <span class="No-Break">any party</span></li>
			</ul>
			<p><em class="italic">Household B</em> would revise the service received in the contract from <em class="italic">Cleaning</em> to <em class="italic">Babysitting</em>, and <em class="italic">Household B</em> would accept if the service received <span class="No-Break">were </span><span class="No-Break"><em class="italic">Babysitting</em></span><span class="No-Break">.</span></p>
			<p>When both <strong class="source-inline">main</strong> functions run, we should see the two nodes representing <em class="italic">Household A</em> and <em class="italic">Household B</em> negotiating the service contract. Eventually, the service contract is mutually agreed upon and synchronized. We should see an output <span class="No-Break">like this:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Household A:</p>
			<pre class="console">
Started on $localhost/127.0.0.1:7001
Submitted service contract: 1
Agreed to the service contract: 1
No response to service contract: ServiceContract</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Household B:</p>
			<pre class="console">
Submitted to revised service contract: 1
Agreed to service contract: 1</pre>			<p>At this point, we have demonstrated how to solve the service contract synchronization problem using UDP. To fully demonstrate the P2P network, there must be numerous nodes available to send and receive messages in a multicast UDP network. Moreover, there should be a data <a id="_idIndexMarker369"/>replication and consistency mechanism among <span class="No-Break">the nodes.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor122"/>What systems use P2P architecture?</h2>
			<p>P2P architecture is used in a few common systems, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Napster</strong> was one of the earliest P2P systems that was commonly used by people to share files on<a id="_idIndexMarker370"/> the internet. Napster used a centralized directory server to maintain an index of available files<a id="_idIndexMarker371"/> and <span class="No-Break">their locations.</span></li>
				<li><strong class="bold">BitTorrent</strong> is a popular P2P protocol used to distribute large files on the internet. It breaks down large files into<a id="_idIndexMarker372"/> smaller pieces and allows each piece to be shared independently. Users download and upload these pieces simultaneously. Upon completion, BitTorrent combines the pieces back into a file for users. BitTorrent has reduced the need for centralization for <span class="No-Break">file sharing.</span></li>
				<li><strong class="bold">Decentralized finance</strong> (<strong class="bold">DeFi</strong>) is a more<a id="_idIndexMarker373"/> recent example. Cryptocurrencies such as <strong class="bold">Bitcoin</strong> and <strong class="bold">Ethereum</strong> operate on P2P networks. Nodes in the<a id="_idIndexMarker374"/> network communicate and validate transactions without relying on a <a id="_idIndexMarker375"/>central authority, using a consensus algorithm. This distributed and synchronized share state enables decentralized and trustless digital <span class="No-Break">currency systems.</span></li>
			</ul>
			<p>We are now going to compare the two architectures, client-server and P2P, to see which architecture is more useful in <span class="No-Break">certain circumstances.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor123"/>Comparison between client-server and P2P architectures</h1>
			<p>Client-server and P2P architectures<a id="_idIndexMarker376"/> should be seen as a spectrum of models ranging from centralization to decentralization, with a lot of viable hybrid models in between the two. See <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B21737_04_8.jpg" alt="Figure 4.8 – The spectrum from decentralized to centralized architectures" width="1544" height="313"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The spectrum from decentralized to centralized architectures</p>
			<p>Centralized architectures have simpler ways of achieving strong consistency, and decentralized architectures have more complex ways of achieving usually <span class="No-Break">weaker consistency.</span></p>
			<p>Client-server architectures are useful in the <span class="No-Break">following circumstances:</span></p>
			<ul>
				<li>There is a need for central control and management, typically applicable to industries <span class="No-Break">under regulations</span></li>
				<li>There are mission-critical processes that require systems to be highly available, resilient, <span class="No-Break">and consistent</span></li>
				<li>There is a lot of data to be collected and correlated, and the data needs to be consistent, replicated, secure, and accessed in a <span class="No-Break">secure manner</span></li>
			</ul>
			<p>On the contrary, P2P architectures <a id="_idIndexMarker377"/>are useful in the <span class="No-Break">following circumstances:</span></p>
			<ul>
				<li>There is a need to avoid the high cost of hosting servers and to make use of the existing resources of the <span class="No-Break">peer nodes</span></li>
				<li>There is a need to share resources freely without central control <span class="No-Break">or censorship</span></li>
				<li>There is a need to avoid relying on a subset of processing that could result in total <span class="No-Break">system failure</span></li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor124"/>Summary</h1>
			<p>We have delved into two important architectures, <strong class="bold">client-server</strong> and <strong class="bold">P2P</strong>, with the context of solving the synchronization problem of a real-life example of a service contract <span class="No-Break">between households.</span></p>
			<p>We have covered how systems of each architecture can be bootstrapped, and which system quality attributes are required for <span class="No-Break">each architecture.</span></p>
			<p>We have also demonstrated in Kotlin code how the synchronization problem can be solved by <span class="No-Break">each architecture.</span></p>
			<p>We have described a couple of real-life systems that employ client-server and P2P architectures. We have also compared <span class="No-Break">the two.</span></p>
			<p>You should now have a brief understanding of the two architectures and what problems they solve, and also be able to reason which architecture can be used in <span class="No-Break">different situations.</span></p>
			<p>In the coming chapter, we are going to explore the architecture patterns often used in <span class="No-Break">the frontend.</span></p>
		</div>
	</div></div></body></html>