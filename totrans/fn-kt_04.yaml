- en: Functions, Function Types, and Side Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数、函数类型和副作用
- en: Functional programming revolves around the concepts of immutability and functions.
    We learned about immutability in the last chapter; we also got a glimpse of pure
    functions while discussing immutability. Pure functions are basically one of the
    many types (but probably the most important one) that functional programming has
    to offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程围绕不可变性和函数的概念展开。我们在上一章学习了不可变性；在讨论不可变性时，我们也对纯函数有了一定的了解。纯函数基本上是函数式编程提供的许多类型（但可能是最重要的一种）之一。
- en: This chapter will revolve around functions. To go into depth on functional programming,
    you need a strong base in functions. To get your concepts clear, we will start
    with ordinary Kotlin functions and then gradually move on to discuss abstract
    concepts on functions that functional programming defines. We will also see their
    implementation in Kotlin.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将围绕函数展开。要深入了解函数式编程，你需要对函数有坚实的基础。为了使你的概念清晰，我们将从普通的 Kotlin 函数开始，然后逐步讨论函数式编程定义的抽象函数概念。我们还将看到它们在
    Kotlin 中的实现。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Functions in Kotlin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 中的函数
- en: Function types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型
- en: Lambda
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda
- en: High order functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Understanding side effects and pure functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解副作用和纯函数
- en: So, let's get started by defining functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从定义函数开始。
- en: Functions in Kotlin
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 中的函数
- en: Functions are one of the most important parts of programming. We write tons
    of functions every week for our projects. Functions are also a part of the fundamentals
    of programming. To learn functional programming, we must have our concepts clear
    with regard to functions. In this section, we will cover the basics of functions,
    in order to get you brushed up and ready for the next sections in this chapter,
    where we will be discussing abstract functional concepts and their implementation
    in Kotlin.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程中最重要的一部分。我们每周都要为我们的项目编写大量的函数。函数也是编程基础的一部分。为了学习函数式编程，我们必须对函数的概念有清晰的认识。在本节中，我们将介绍函数的基础知识，以便让你为下一节做好准备，在下一节中，我们将讨论抽象的函数概念及其在
    Kotlin 中的实现。
- en: So, let's start by defining functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先定义函数。
- en: A **function** is a block of organized, reusable code that is used to perform
    a single, related action.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**是一块组织良好、可重用的代码块，用于执行单个、相关的操作。'
- en: 'Not very clear? We will explain, but first, let''s learn why we should write
    functions. In short, what is the functionality of a function? Have a look:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不太清楚？我们将解释，但首先，让我们了解为什么我们应该编写函数。简而言之，函数的功能是什么？看看：
- en: Functions allow us to break the program into a bunch of steps and substeps
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数允许我们将程序分解成一系列步骤和子步骤
- en: Functions encourages code reuse
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数鼓励代码重用
- en: Functions, if used properly, help us keep the code clean, organized, and easy
    to understand
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正确使用，函数可以帮助我们保持代码的整洁、有序和易于理解
- en: Functions make testing (unit testing) easy, testing each small part of the program
    is easier than the complete program in a single go
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数使测试（单元测试）变得容易，测试程序的小部分比一次性测试整个程序要容易
- en: 'In Kotlin, a function generally looks like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，函数通常看起来像以下这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Kotlin, a function declaration starts with the `fun` keyword, followed by
    the function name, then braces. Inside the braces, we can specify function arguments
    (optional). After the braces, there would be a colon (`:`) and return type, which
    specifies the datatype of the value/object to be returned (you can skip return
    type if you don't plan to return anything from the function; in that case, the
    default return type `Unit` will be assigned to the function). After those, there
    would be the function body, covered in curly braces (curly braces are also optional
    for Single-Expression functions, covered next in[ Chapter 5](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml),
    *More on Functions*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，函数声明以 `fun` 关键字开头，后跟函数名，然后是括号。在括号内，我们可以指定函数参数（可选）。括号之后，会有一个冒号（`:`）和返回类型，它指定了要返回的值/对象的类型（如果你不打算从函数中返回任何内容，可以省略返回类型；在这种情况下，函数将被分配默认返回类型
    `Unit`）。之后，会有函数体，用花括号括起来（对于单表达式函数，花括号是可选的，将在[第 5 章](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml)中介绍，*更多关于函数的内容*)。
- en: '`Unit` is a datatype in Kotlin. `Unit` is a singleton instance of itself and
    holds a value that is `Unit` itself. `Unit` corresponds to `void` in Java, but
    it''s quite different than `void`. While `void` means nothing in Java and `void`
    cannot contain anything, we have `Nothing` in Kotlin for that purpose, which indicates
    that a function would never complete successfully (due to an exception or an infinite
    loop).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit` 是 Kotlin 中的一个数据类型。`Unit` 是其自身的单例实例，并持有 `Unit` 自身的值。`Unit` 对应于 Java 中的
    `void`，但它与 `void` 非常不同。虽然 `void` 在 Java 中意味着没有东西，且 `void` 不能包含任何东西，但在 Kotlin 中我们有
    `Nothing` 用于此目的，它表示函数永远不会成功完成（由于异常或无限循环）。'
- en: Now, what are those return types, parameters (arguments), and function bodies?
    Let's explore them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，那些返回类型、参数（参数）和函数体是什么？让我们来探索它们。
- en: 'The following is a more realistic function example than the abstract one previously
    shown:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个比之前展示的抽象函数更现实的函数示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, have a look at the following explanations for each parts of a function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下关于函数各部分的解释：
- en: '**Function arguments/parameters**: These are the data (unless lambda) for the
    function to work on. In our example, `a` and `b` are the function parameters.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数参数/参数**：这些是函数要处理的数据（除非是 lambda）。在我们的例子中，`a` 和 `b` 是函数参数。'
- en: '**Function body**: Everything we write inside the curly braces of a function
    is called the **function body**. It is the part of a function, where we write
    the logic or set of instructions to accomplish a particular task. In the preceding
    example, two lines inside the curly braces is the function body.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数体**：我们写在函数花括号内的所有内容都称为 **函数体**。它是函数的一部分，我们在其中编写逻辑或指令集以完成特定任务。在前面的例子中，花括号内的两行是函数体。'
- en: '**Return statement, datatype**: If we are willing to return some value from
    the function, we have to declare the datatype of the value we are willing to return;
    that datatype is called the `return` type—in this case, `Int` is the `return`
    type and `return result` is the return statement, it enables you to return a value
    to the calling function.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回语句，数据类型**：如果我们愿意从函数中返回某个值，我们必须声明我们愿意返回的值的类型；这个类型被称为 `return` 类型——在这种情况下，`Int`
    是 `return` 类型，`return result` 是返回语句，它使您能够向调用函数返回一个值。'
- en: We can make the previous example shorter by removing `val result = a+b` and
    replacing the return statement with `return a+b`. In Kotlin, we can further shorten
    this example, as we will see in [Chapter 5](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml), *More
    on Functions*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除 `val result = a+b` 并用 `return a+b` 替换返回语句来使前面的例子更短。在 Kotlin 中，我们可以进一步缩短这个例子，正如我们将在第
    5 章 [更多关于函数](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml) 中看到的。
- en: While writing functions is easy, Kotlin makes it easier for you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写函数很容易，但 Kotlin 使之更加容易。
- en: 'Kotlin has bundled various features with functions that make a developer''s
    life easier. The following is a brief list of the features bundled with Kotlin:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 将各种功能捆绑到函数中，使开发者的生活更加轻松。以下是 Kotlin 捆绑的特性的简要列表：
- en: Single-expression functions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单表达式函数
- en: Extension functions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Inline functions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数
- en: Infix notation and more
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中缀表示法及其他
- en: We will cover them in detail in the *Lambda, Generics, Recursions, Corecursion*
    section of [Chapter 5](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml), *More on Functions*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 5 章 [更多关于函数](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml) 的 *Lambda，泛型，递归，核心递归*
    部分详细介绍它们。
- en: Returning two values from a function
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数中返回两个值
- en: 'While, generally, a function can return only a single value, in Kotlin, by
    leveraging the benefits of the `Pair` type and destructuring declarations, we
    can return two variables from a function. Consider the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，通常函数只能返回单个值，但在 Kotlin 中，通过利用 `Pair` 类型的优势和结构化声明的优势，我们可以从函数中返回两个变量。考虑以下示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding program, on comment `(1)`, we created a function that would
    return a `Pair<Int,String>` value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，在注释 `(1)` 处，我们创建了一个将返回 `Pair<Int,String>` 值的函数。
- en: On comment `(2)`, we used that function in a way that seems like it returns
    two variables. Actually, destructuring declarations allows you to destructure
    a `data class`/`Pair` and get its underlying values in standalone variables. When
    this feature is used with functions, it seems like the function is returning multiple
    values, though it returns only one value that is a `Pair` value or another `data
    class`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(2)`中，我们以似乎返回两个变量的方式使用了该函数。实际上，解构声明允许你解构一个`data class`/`Pair`并获取其底层值作为独立的变量。当这个特性与函数一起使用时，它似乎函数返回多个值，尽管它只返回一个值，这个值是一个`Pair`值或另一个`data
    class`。
- en: Extension functions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Kotlin provides us with extension functions. What are they? They are like an
    ad hoc function on top of an existing datatype/class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin为我们提供了扩展函数。它们是什么？它们是在现有数据类型/类之上的一种临时函数。
- en: 'For example, if we want to count the number of words in a string, the following
    would be a traditional function to do it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想计算字符串中的单词数，以下是一个传统的函数来完成这个任务：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We would pass a `String` to a function, have our logic count the words, and
    then we would return the value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会将一个`String`传递给一个函数，让我们的逻辑计算单词数，然后我们会返回这个值。
- en: But don't you feel like it would always be better if there was a way that this
    function could be called on the `String` instance itself? Kotlin allows us to
    perform such an action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不觉得如果有一种方法可以直接在`String`实例上调用这个函数会更好吗？Kotlin允许我们执行这样的操作。
- en: 'Have a look at the following program:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下程序：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Have a careful look at the function declaration. We declared the function as
    `String.countWords()`, not just `countWords` as it was previously; that means
    it should be called on a `String` instance now, just like the member functions
    of `String` class. Just like the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看函数声明。我们声明了函数为`String.countWords()`，而不是像之前那样只是`countWords`；这意味着现在应该在一个`String`实例上调用它，就像`String`类的成员函数一样。就像以下代码：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can check out the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看以下输出：
- en: '![](img/f9e6f9a3-0d06-4c1e-8b44-51ac459c9c36.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9e6f9a3-0d06-4c1e-8b44-51ac459c9c36.png)'
- en: Default arguments
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'We may have a requirement where we want to have an optional parameter for a
    function. Consider the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个要求，即希望函数有一个可选参数。考虑以下示例：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We want to make `anotherNumber` parameter optional; we want it to be `0`, if
    it is not passed as an argument. The traditional way is to have another overloaded
    function without any parameters, which would call this function with `0`, like
    the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`anotherNumber`参数是可选的；如果我们没有将其作为参数传递，我们希望它是`0`。传统的方法是有一个没有参数的重载函数，它会用`0`调用这个函数，如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, in Kotlin, things are quite easy and straightforward and they don't
    require us to define the function again just to make an argument optional. For
    making arguments optional, Kotlin provides us with default arguments, by which
    we can specify a default value of a function right away at the time of declaration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Kotlin中，事情相当简单直接，并且它们不需要我们再次定义函数来仅使参数可选。为了使参数可选，Kotlin为我们提供了默认参数，通过它我们可以在声明函数时立即指定默认值。
- en: 'The following is the modified function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是被修改后的函数：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We would use the `main` function as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会使用`main`函数如下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the first one, we skipped the argument and for the second one, we provided
    `6`. So, for the first one, the output should be true (as `5` is really greater
    than `0`), while for the second one, it should be false (as `5` isn't greater
    than `6`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个，我们跳过了参数，对于第二个，我们提供了`6`。所以，对于第一个，输出应该是true（因为`5`确实大于`0`），而对于第二个，它应该是false（因为`5`不大于`6`）。
- en: 'The following screenshot output confirms the same:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图输出确认了相同的结果：
- en: '![](img/ae55b51d-74ec-41b4-963e-629fa7f51823.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae55b51d-74ec-41b4-963e-629fa7f51823.png)'
- en: Nested functions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: Kotlin allows you to nest functions, one within another. We can declare and
    use a function within another function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin允许你在函数内部嵌套函数，我们可以在另一个函数内部声明和使用函数。
- en: When you declare a function within another function, the nested functions, visibility
    will stay exclusively within the parent function and cannot be accessed from outside.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在另一个函数内部声明一个函数时，嵌套函数的可见性将仅限于父函数，并且不能从外部访问。
- en: 'So, let''s have an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们举一个例子：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding program, we declared and used a function—`nested()`—inside
    the `main` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们在`main`函数内部声明并使用了一个函数——`nested()`。
- en: 'The following is the output, if you''re curious:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你好奇的输出：
- en: '![](img/e86a63ad-5bd7-4a67-88f2-9fc3e1427bdb.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e86a63ad-5bd7-4a67-88f2-9fc3e1427bdb.png)'
- en: So, as we've got our basics brushed up in functions, let's move forward in functional
    programming. In the following section, we will learn about function types.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在函数的基本知识上已经做好准备，让我们继续学习函数式编程。在下一节中，我们将学习函数类型。
- en: Function types in functional programming
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程中的函数类型
- en: One of the main objectives of functional programming is to implement modular
    programming. Side effects (a functional term, defined later in this chapter) are
    often sources of bugs; functional programming wants you to avoid side effects
    totally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的主要目标之一是实现模块化编程。副作用（一个将在本章后面定义的功能性术语）通常是bug的来源；函数式编程希望你能完全避免副作用。
- en: 'To achieve that, functional programming has defined the following types of
    functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，函数式编程定义了以下类型的函数：
- en: Lambda functions as property
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数作为属性
- en: High order functions
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Pure functions
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Partial functions
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分函数
- en: In this section, we will discuss each of these concepts in order to get a solid
    grip on functional programming paradigms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将按顺序讨论这些概念，以便对函数式编程范式有一个牢固的把握。
- en: So, let's get started with lambda.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从lambda开始吧。
- en: Lambda
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda
- en: Lambda, which can also be called **anonymous functions**, has a first-class
    citizen support in Kotlin. While, in Java, lambda is only supported starting with
    Java 8, in Kotlin, you can use Kotlin with JVM 6 onwards, so there's really no
    barrier for lambda in Kotlin.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda，也可以称为**匿名函数**，在Kotlin中具有一等公民的支持。而Java中，lambda的支持是从Java 8开始的，在Kotlin中，你可以从JVM
    6开始使用Kotlin，因此在Kotlin中实际上没有lambda的障碍。
- en: Now, we were talking about lambda, anonymous classes (or objects) and anonymous
    functions, but what are they? Let us explore.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在谈论lambda、匿名类（或对象）和匿名函数，但它们究竟是什么呢？让我们来探索一下。
- en: To be generic, lambda or lambda expressions generally means **anonymous functions**,
    that is, functions without names, which can be assigned to variables, passed as
    arguments, or returned from another function. It is a kind of nested function,
    but is more versatile and more flexible. You can also say all the lambda expressions
    are functions, but not every function is a lambda expression. Being anonymous
    and unnamed brings a lot of benefits to lambda expressions, which we will discuss
    soon.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通用，lambda或lambda表达式通常指的是**匿名函数**，即没有名称的函数，可以被赋值给变量、作为参数传递或从另一个函数返回。它是一种嵌套函数，但更灵活、更灵活。你还可以说所有的lambda表达式都是函数，但并非所有函数都是lambda表达式。匿名和无名称给lambda表达式带来了很多好处，我们将在下面讨论。
- en: As I mentioned earlier, not all languages support lambda and Kotlin is one of
    rarest languages, and it provides extensive support for lambda.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，并非所有语言都支持lambda，Kotlin是其中最罕见的一种语言，它为lambda提供了广泛的支持。
- en: So, why is it called lambda? Let us dig up a bit of history now.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么叫lambda呢？现在让我们挖掘一点历史吧。
- en: 'Lambda, Λ, **λ** (uppercase Λ, lowercase λ) is the 11^(th) letter of the Greek
    alphabet. Pronunciation: lám(b)da.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda，Λ，**λ**（大写Λ，小写λ）是希腊字母的第11个字母。发音：lám(b)da。
- en: 'Source: [https://en.wikipedia.org/wiki/Lambda](https://en.wikipedia.org/wiki/Lambda)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://en.wikipedia.org/wiki/Lambda](https://en.wikipedia.org/wiki/Lambda)
- en: During the 1930s, Alonzo Church, who was at that time studying mathematics at
    Princeton University, used the Greek alphabet, specifically lambda, to denote
    what he called **functions**. The thing to note is that, at that time, there were
    only anonymous functions in computing; the concept of modern-day named functions
    were yet to come.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪30年代，当时在普林斯顿大学学习数学的Alonzo Church，使用希腊字母，特别是lambda，来表示他所称的**函数**。需要注意的是，当时计算机中只有匿名函数；现代命名函数的概念尚未出现。
- en: So, with this practice of Alonzo Church, the word lambda got attached to anonymous
    functions (then the only type of function) which is, to date, referred to in the
    same way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着Alonzo Church的这种实践，lambda这个词就与匿名函数（那时唯一的函数类型）联系在了一起，时至今日，它仍然以同样的方式被引用。
- en: Alonzo Church (June 14, 1903-August 11, 1995), was an American mathematician
    and logician who made major contributions to mathematical logic and the foundations
    of theoretical computer science. He is best known for the lambda calculus, *Church-Turing*
    thesis, proving the undecidability of the *Entscheidungsproblem*, *Frege-Church*
    ontology, and the *Church-Rosser* theorem. He also worked on philosophy of language
    (for example, Church, 1970).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 阿隆佐·丘奇（1903年6月14日-1995年8月11日），是一位美国数学家和逻辑学家，他对数学逻辑和理论计算机科学的基础做出了重大贡献。他最著名的是λ演算、*丘奇-图灵*猜想、证明*决定问题*的不可判定性、*弗雷格-丘奇*本体论和*丘奇-罗素*定理。他还从事语言哲学的研究（例如，丘奇，1970年）。
- en: 'Source: [https://en.wikipedia.org/wiki/Alonzo_Church](https://en.wikipedia.org/wiki/Alonzo_Church)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://en.wikipedia.org/wiki/Alonzo_Church](https://en.wikipedia.org/wiki/Alonzo_Church)
- en: Don't you think we have had enough of theories? Shouldn't we now focus on learning
    what lambda actually is, or what, exactly, it looks like? We will have a look
    at how lambdas look in Kotlin, but we would prefer to introduce you to lambda
    in Java first, and later in Kotlin, to make you fully understand how much power
    lambdas possess in Kotlin and what exactly is meant by first-class citizen support.
    You'll also learn the difference between lambda in Java and Kotlin.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你不觉得我们已经对理论足够了吗？我们不应该现在专注于学习lambda实际上是什么，或者它究竟看起来像什么吗？我们将查看Kotlin中lambda的样子，但我们更愿意先向您介绍Java中的lambda，然后在Kotlin中介绍，以便您完全理解lambda在Kotlin中拥有多大的力量，以及“一等公民”支持的确切含义。您还将了解Java和Kotlin中lambda的区别。
- en: 'Consider the following Java example. It''s a simple example, where we are passing
    an instance of an interface to a method and, in that method, we are calling a
    method from the instance:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Java示例。这是一个简单的例子，其中我们将接口的一个实例传递给一个方法，并在该方法中调用该实例的方法：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, in this program, `SomeInterface` is an interface (the inner interface of
    `LambdaIntroClass`) with a single method—`doSomeStuff()`. The static method (it's
    static to make it easily accessible by the `main` method) `invokeSomeStuff` takes
    an instance of `SomeInterface` and calls its method `doSomeStuff()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，`SomeInterface`是一个接口（`LambdaIntroClass`的内部接口），只有一个方法——`doSomeStuff()`。静态方法`invokeSomeStuff`（为了使它可以通过`main`方法轻松访问而设置为静态）接受`SomeInterface`的一个实例，并调用其`doSomeStuff()`方法。
- en: 'It was a simple example; now, let''s make it simpler: let''s add lambda to
    it. Have a look at the following updated code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子；现在，让我们让它更简单：让我们给它添加lambda表达式。看看以下更新的代码：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, here, the definition of `SomeInterface` and `invokeSomeStuff()` stays the
    same. The only difference is on passing the instance of `SomeInterface`. Instead
    of creating an instance of `SomeInstance` with a new `SomeInstance`, what we wrote
    is an expression (in bold) that looks pretty much like mathematical function expressions
    (except obviously the `System.out.println()`). That expression is called a **lambda
    expression**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，`SomeInterface`和`invokeSomeStuff()`的定义保持不变。唯一的不同之处在于传递`SomeInterface`的实例。我们不是用一个新的`SomeInstance`创建`SomeInstance`的实例，而是写了一个表达式（粗体），这个表达式看起来非常像数学函数表达式（除了显然的`System.out.println()`）。这个表达式被称为**lambda表达式**。
- en: Wasn't that fantastic? You didn't need to create an instance of the interface,
    then override the method and all that stuff. What you did is a simple expression.
    That expression would be used as the method body of the `doSomeStuff()` method
    inside the interface.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 难道这不是很棒吗？你不需要创建接口的实例，然后重写方法等所有这些操作。你所做的是一个非常简单的表达式。这个表达式将被用作接口内部`doSomeStuff()`方法的主体。
- en: 'The output for both the programs is identical; it is as shown in the following
    screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 两个程序输出的结果相同；如下截图所示：
- en: '![](img/8b2507fe-ff5a-4106-8227-846e71d7eb23.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b2507fe-ff5a-4106-8227-846e71d7eb23.png)'
- en: Java doesn't have any types for lambda; you can only use lambda to create instances
    of classes and interfaces on the go. The only benefit of lambda in Java is that
    it makes Java programs easier to read (by humans) and reduces line counts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Java没有lambda的类型；你只能使用lambda在运行时创建类和接口的实例。Java中lambda的唯一好处是它使Java程序更容易阅读（对人类来说），并减少了行数。
- en: We cannot actually blame Java for that. After all, Java is basically a purely
    object-oriented language. Kotlin, on the other hand, is a perfect blend of object-oriented
    and functional programming paradigms; it brings both the worlds closer together.
    In our words, Kotlin is the best language if you want to get started with functional
    programming with previous knowledge of object-oriented programming.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不能责怪 Java。毕竟，Java 基本上是一种纯面向对象的语言。另一方面，Kotlin 是面向对象和函数式编程范式的完美结合；它将这两个世界更紧密地联系在一起。用我们的话说，如果你想在了解面向对象编程的基础上开始函数式编程，Kotlin
    是最好的语言。
- en: 'So, no more lectures, let us move on to the code. Let us now have a look how
    the same program would look in Kotlin:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不再有讲座了，让我们继续看代码。现在让我们看看同样的程序在 Kotlin 中的样子：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Yes, that's the complete program (well, except the `import` statements and package
    name). I know you're a bit confused; you're asking if it is really the same program?
    Where is the interface definition then? Well, in Kotlin that is not actually required.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是完整的程序（好吧，除了 `import` 语句和包名）。我知道你有点困惑；你在问这真的是同一个程序吗？接口定义在哪里呢？嗯，在 Kotlin
    中实际上并不需要。
- en: The `invokeSomeStuff()` function is actually a high-order function (covered
    next); we pass our lambda there and it directly calls the function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeSomeStuff()` 函数实际上是一个高阶函数（将在下一节中介绍）；我们向那里传递我们的 lambda，它直接调用该函数。'
- en: Brilliant, isn't it? Kotlin has a bunch of features with lambda. Let us have
    a look at them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？Kotlin 有很多与 lambda 相关的特性。让我们看看它们。
- en: Function as property
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为属性
- en: Kotlin also allows us to have functions as properties. Functions as properties
    means that a function can be used as a property.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还允许我们将函数作为属性。函数作为属性意味着函数可以用作属性。
- en: 'For instance, take the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下示例：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding program, we created a property, `sum`, which will actually
    hold a function to add two numbers passed to it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个属性 `sum`，它实际上将持有一个用于添加传递给它的两个数字的函数。
- en: While `sum` is a `val` property, what it holds is a function (or lambda) and
    we can call that function just like the usual function we call; there are no differences
    there at all.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `sum` 是一个 `val` 属性，但它持有的是一个函数（或 lambda），我们可以像调用常规函数一样调用这个函数；这里没有任何区别。
- en: 'If you''re curious, the following is the output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，以下就是输出：
- en: '![](img/19f84162-6dd6-4c54-9bb2-87a1876a3a39.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19f84162-6dd6-4c54-9bb2-87a1876a3a39.png)'
- en: Now, let us discuss the syntax of lambda.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 lambda 的语法。
- en: In Kotlin, a lambda always stays embraced by the curly braces. This makes a
    lambda easy to identify, unlike in Java, where parameters/arguments reside outside
    the curly braces. In Kotlin, parameters/arguments reside inside curly braces separated
    by (`->`) from the logic of the function. The last statement in a lambda (which
    may just be a variable/property name or another function call) is considered as
    the return statement. So, whatever is the evaluation of the last statement of
    a lambda is the return value of a lambda.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，lambda 总是包含在大括号内。这使得 lambda 很容易识别，与 Java 不同，在 Java 中参数/参数位于大括号之外。在
    Kotlin 中，参数/参数位于大括号内，由 (`->`) 与函数的逻辑分开。lambda 中的最后一个语句（可能只是一个变量/属性名或另一个函数调用）被视为返回语句。所以，lambda
    最后一个语句的评估结果就是 lambda 的返回值。
- en: Also, if your function is a single parameter function, you can also skip the
    property name. So, how can you use that parameter if you don't specify the name?
    Kotlin provides you with a default `it` property for single parameter lambdas
    where you don't specify the property name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的函数是单参数函数，你也可以省略属性名。那么，如果你不指定名称，你如何使用那个参数呢？Kotlin 为你提供了一个默认的 `it` 属性，用于单参数
    lambda，其中你未指定属性名。
- en: 'So, let''s modify the previous lambda to add it. Have a look at the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们修改之前的 lambda 来添加它。看看下面的代码：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We skipped the complete program and output, as they remain the same.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过了完整的程序和输出，因为它们保持不变。
- en: You must have noticed that we assigned the function parameters value to another
    `var` property (both when the parameter was named and when we denoted with `it`).
    The reason is that, in Kotlin, function parameters are immutable, but with the
    reverse number program, we needed a way to change the value; so, we assigned the
    value to a `var` property, which is mutable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了，我们将函数参数的值赋给了另一个 `var` 属性（无论是当参数被命名还是用 `it` 表示时）。原因是，在 Kotlin 中，函数参数是不可变的，但与反向数字程序相比，我们需要一种改变值的方法；因此，我们将值赋给一个可变的
    `var` 属性。
- en: 'Now, you have lambda as properties, but what about their datatypes? Every property/variable
    has a datatype (even if the type is inferred), so what about lambdas? Let''s have
    a look at the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有了lambda作为属性，但它们的数据类型是什么呢？每个属性/变量都有一个数据类型（即使类型是推断的），那么lambda呢？让我们看看以下示例：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding program, we declared a `reverse` property as a function. In
    Kotlin, when you're declaring a property as a function, you should mention the
    datatypes of parameters/arguments inside braces, followed by an arrow and then
    the return type of the function; if the function is not planned to return something,
    you should mention `Unit`. While declaring a function as a property, you need
    not specify the parameter/argument name and while defining/assigning the function
    to the property, you can skip providing datatypes of the property.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们声明了一个`reverse`属性作为函数。在Kotlin中，当你将属性声明为函数时，你应该在括号内提及参数/参数的数据类型，然后是一个箭头，然后是函数的返回类型；如果函数不打算返回任何内容，你应该提及`Unit`。在将函数声明为属性时，你不需要指定参数/参数的名称，而在定义/分配函数到属性时，你可以省略提供属性的数据类型。
- en: 'The following is the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/643690f0-41fa-4752-88a9-e5b67d54c8a6.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/643690f0-41fa-4752-88a9-e5b67d54c8a6.png)'
- en: So, we have a good concept of lambda and functions as properties in Kotlin.
    Now, let us move ahead with high order functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在Kotlin中对lambda和函数作为属性有了一个很好的理解。现在，让我们继续探讨高阶函数。
- en: High order functions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: A high order function is a function which accepts another function as a parameter
    or returns another function. We just saw how we can use a function as a property,
    so it's quite easy to see that we can accept another function as a parameter or
    that we can return another function from a function. As stated previously, technically
    the function that receives or returns another function (it may be more than one)
    or does both is called a **high-order** **function**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一个接受另一个函数作为参数或返回另一个函数的函数。我们刚刚看到我们可以如何将函数用作属性，所以很容易看出我们可以接受另一个函数作为参数，或者我们可以从函数中返回另一个函数。如前所述，技术上接收或返回另一个函数（可能不止一个）或两者兼而有之的函数被称为**高阶****函数**。
- en: In our first lambda example in Kotlin, the `invokeSomeStuff` function was a
    high-order function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin的第一个lambda示例中，`invokeSomeStuff`函数是一个高阶函数。
- en: 'The following is another example of high-order function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个高阶函数的另一个示例：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding program, we created a high order function—`performOperationOnEven`
    which would take an `Int` and a lambda operation to execute on that `Int`. The
    only catch is that the function would only perform that operation on the provided
    `Int`, if that `Int` is an even number.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个高阶函数——`performOperationOnEven`，它将接受一个`Int`和一个对那个`Int`执行的操作的lambda表达式。唯一的限制是，如果该`Int`是偶数，该函数才会执行该操作。
- en: 'Isn''t that easy enough? Let''s have a look at the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是足够简单吗？让我们看看以下输出：
- en: '![](img/18a5c28e-0a67-4090-a06f-645f1a80e160.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18a5c28e-0a67-4090-a06f-645f1a80e160.png)'
- en: In all our previous examples, we saw how to pass a function (lambda) to another
    function. However, that's not the only feature of high order functions. A high
    order function also allows you to return a function from it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的所有示例中，我们看到了如何将一个函数（lambda）传递给另一个函数。然而，这并不是高阶函数的唯一特性。高阶函数还允许你从它返回一个函数。
- en: 'So, let us explore it. Have a look at the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来探索一下。看看以下示例：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding program, we created a function, `getAnotherFunction`, that
    would take an `Int` parameter and would return a function that takes a `String` value
    and returns `Unit`. That `return` function prints both its parameter (a `String`)
    and its parents parameter (an `Int`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个函数`getAnotherFunction`，它将接受一个`Int`参数，并返回一个接受一个`String`值并返回`Unit`的函数。该`return`函数打印其参数（一个`String`）及其父参数（一个`Int`）。
- en: 'See the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下输出：
- en: '![](img/59428ba1-f83a-4a58-b5d3-6d2c79225672.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59428ba1-f83a-4a58-b5d3-6d2c79225672.png)'
- en: In Kotlin, technically you can have nested high order functions to any depth.
    However, that would do more harm than help, and would even destroy the readability.
    So, you should avoid them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，技术上你可以有嵌套的高阶函数到任何深度。然而，这样做可能会造成更多的伤害而不是帮助，甚至可能破坏可读性。所以，你应该避免它们。
- en: Pure functions and side effects
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和副作用
- en: So, we have learned about lambda and high order functions. They are two of the
    most interesting and important topics of functional programming. In this section,
    we will be discussing side effects and pure functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经学习了 lambda 函数和高阶函数。它们是函数式编程中最有趣和最重要的主题之一。在本节中，我们将讨论副作用和纯函数。
- en: So, let's start by defining side effects. We will then gradually move towards
    pure functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先定义副作用。然后我们将逐步转向纯函数。
- en: Side effects
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: In a computer program, when a function modifies any object/data outside its
    own scope, that is called a **side effect**. For instance, we often write functions
    that modify a global or static property, modify one of its arguments, raise an
    exception, write data to display or file, or even call another function which
    has a side effect.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序中，当一个函数修改其自身作用域之外的任何对象/数据时，这被称为**副作用**。例如，我们经常编写修改全局或静态属性的函数，修改其参数之一，抛出异常，将数据写入显示或文件，甚至调用具有副作用的另一个函数。
- en: 'For example, have a look at the following program:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下程序：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding program is a simple object-oriented program. However, it contains
    side effects. The `addNumbers()` function modifies the state of the `Calc` class,
    which is bad practice in functional programming.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序是一个简单的面向对象程序。然而，它包含副作用。`addNumbers()` 函数修改了 `Calc` 类的状态，这在函数式编程中是一种不良做法。
- en: While we cannot avoid side effects in a few functions, especially where we are
    accessing IO and/or a database and so on, side effects should be avoided wherever
    possible.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们无法避免一些函数的副作用，尤其是在我们访问 IO 和/或数据库等情况时，但应尽可能避免副作用。
- en: Pure functions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: The definition of a pure function says that, if the return value of a function
    is completely dependent on its arguments/parameters, then this function may be
    referred to as a **pure function**. So, if we declare a function as `fun func1(x:Int):Int`,
    then its return value will be strictly dependent on its argument, `x`; say, if
    you call `func1` with a value of *3 N* times, then, for every call, its return
    value will be the same.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的定义表明，如果一个函数的返回值完全依赖于其参数/参数，那么这个函数可以被称为**纯函数**。所以，如果我们声明一个函数为 `fun func1(x:Int):Int`，那么它的返回值将严格依赖于其参数
    `x`；比如说，如果你用 *3 N* 次调用 `func1`，那么每次调用的返回值都将相同。
- en: The definition also says that a pure function should not actively or passively
    cause side effects, that is, it should not directly cause side effects, nor should
    it call any other function that causes side effects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 定义还说明，纯函数不应主动或被动地引起副作用，也就是说，它不应直接引起副作用，也不应调用任何引起副作用的函数。
- en: A pure function can be either a lambda or a named function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数可以是 lambda 函数或命名函数。
- en: So, why are they called pure functions? The reason is quite simple. Programming
    functions originated from mathematical functions. Programming functions, over
    time, evolved to contain multiple tasks and perform anonymous actions that are
    not directly related to the processing of passed arguments. So, those functions
    that still resemble mathematical functions are called pure functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么它们被称为纯函数呢？原因很简单。编程函数起源于数学函数。随着时间的推移，编程函数演变成了包含多个任务并执行与传递参数处理无直接关系的匿名操作。因此，那些仍然类似于数学函数的函数被称为纯函数。
- en: 'So, let''s modify our previous program to make it into a pure function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们修改我们之前的程序，使其成为一个纯函数：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Quite easy, isn't it? We are skipping the output, as the program is really easy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，不是吗？我们跳过了输出，因为这个程序真的很简单。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have learned about functions, how to use them, and their
    classifications. We also got introduced to lambda and high order functions. We
    learned about pure functions and side effects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了函数，如何使用它们以及它们的分类。我们还介绍了 lambda 函数和高阶函数。我们学习了纯函数和副作用。
- en: The next chapter will take you deeper into functions. As I already stated, you
    need to master functions in order to learn functional programming properly. So,
    what are you waiting for? Turn the page right now.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带你深入了解函数。正如我已经提到的，你需要掌握函数才能正确学习函数式编程。那么，你在等什么呢？现在就翻到下一页。
