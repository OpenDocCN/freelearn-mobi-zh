- en: Functions, Function Types, and Side Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming revolves around the concepts of immutability and functions.
    We learned about immutability in the last chapter; we also got a glimpse of pure
    functions while discussing immutability. Pure functions are basically one of the
    many types (but probably the most important one) that functional programming has
    to offer.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will revolve around functions. To go into depth on functional programming,
    you need a strong base in functions. To get your concepts clear, we will start
    with ordinary Kotlin functions and then gradually move on to discuss abstract
    concepts on functions that functional programming defines. We will also see their
    implementation in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding side effects and pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started by defining functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are one of the most important parts of programming. We write tons
    of functions every week for our projects. Functions are also a part of the fundamentals
    of programming. To learn functional programming, we must have our concepts clear
    with regard to functions. In this section, we will cover the basics of functions,
    in order to get you brushed up and ready for the next sections in this chapter,
    where we will be discussing abstract functional concepts and their implementation
    in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start by defining functions.
  prefs: []
  type: TYPE_NORMAL
- en: A **function** is a block of organized, reusable code that is used to perform
    a single, related action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not very clear? We will explain, but first, let''s learn why we should write
    functions. In short, what is the functionality of a function? Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions allow us to break the program into a bunch of steps and substeps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions encourages code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions, if used properly, help us keep the code clean, organized, and easy
    to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions make testing (unit testing) easy, testing each small part of the program
    is easier than the complete program in a single go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Kotlin, a function generally looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In Kotlin, a function declaration starts with the `fun` keyword, followed by
    the function name, then braces. Inside the braces, we can specify function arguments
    (optional). After the braces, there would be a colon (`:`) and return type, which
    specifies the datatype of the value/object to be returned (you can skip return
    type if you don't plan to return anything from the function; in that case, the
    default return type `Unit` will be assigned to the function). After those, there
    would be the function body, covered in curly braces (curly braces are also optional
    for Single-Expression functions, covered next in[ Chapter 5](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml),
    *More on Functions*).
  prefs: []
  type: TYPE_NORMAL
- en: '`Unit` is a datatype in Kotlin. `Unit` is a singleton instance of itself and
    holds a value that is `Unit` itself. `Unit` corresponds to `void` in Java, but
    it''s quite different than `void`. While `void` means nothing in Java and `void`
    cannot contain anything, we have `Nothing` in Kotlin for that purpose, which indicates
    that a function would never complete successfully (due to an exception or an infinite
    loop).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, what are those return types, parameters (arguments), and function bodies?
    Let's explore them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a more realistic function example than the abstract one previously
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, have a look at the following explanations for each parts of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function arguments/parameters**: These are the data (unless lambda) for the
    function to work on. In our example, `a` and `b` are the function parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function body**: Everything we write inside the curly braces of a function
    is called the **function body**. It is the part of a function, where we write
    the logic or set of instructions to accomplish a particular task. In the preceding
    example, two lines inside the curly braces is the function body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return statement, datatype**: If we are willing to return some value from
    the function, we have to declare the datatype of the value we are willing to return;
    that datatype is called the `return` type—in this case, `Int` is the `return`
    type and `return result` is the return statement, it enables you to return a value
    to the calling function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can make the previous example shorter by removing `val result = a+b` and
    replacing the return statement with `return a+b`. In Kotlin, we can further shorten
    this example, as we will see in [Chapter 5](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml), *More
    on Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: While writing functions is easy, Kotlin makes it easier for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin has bundled various features with functions that make a developer''s
    life easier. The following is a brief list of the features bundled with Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-expression functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infix notation and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover them in detail in the *Lambda, Generics, Recursions, Corecursion*
    section of [Chapter 5](f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml), *More on Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: Returning two values from a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While, generally, a function can return only a single value, in Kotlin, by
    leveraging the benefits of the `Pair` type and destructuring declarations, we
    can return two variables from a function. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, on comment `(1)`, we created a function that would
    return a `Pair<Int,String>` value.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)`, we used that function in a way that seems like it returns
    two variables. Actually, destructuring declarations allows you to destructure
    a `data class`/`Pair` and get its underlying values in standalone variables. When
    this feature is used with functions, it seems like the function is returning multiple
    values, though it returns only one value that is a `Pair` value or another `data
    class`.
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin provides us with extension functions. What are they? They are like an
    ad hoc function on top of an existing datatype/class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to count the number of words in a string, the following
    would be a traditional function to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We would pass a `String` to a function, have our logic count the words, and
    then we would return the value.
  prefs: []
  type: TYPE_NORMAL
- en: But don't you feel like it would always be better if there was a way that this
    function could be called on the `String` instance itself? Kotlin allows us to
    perform such an action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a careful look at the function declaration. We declared the function as
    `String.countWords()`, not just `countWords` as it was previously; that means
    it should be called on a `String` instance now, just like the member functions
    of `String` class. Just like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check out the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9e6f9a3-0d06-4c1e-8b44-51ac459c9c36.png)'
  prefs: []
  type: TYPE_IMG
- en: Default arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may have a requirement where we want to have an optional parameter for a
    function. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to make `anotherNumber` parameter optional; we want it to be `0`, if
    it is not passed as an argument. The traditional way is to have another overloaded
    function without any parameters, which would call this function with `0`, like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, in Kotlin, things are quite easy and straightforward and they don't
    require us to define the function again just to make an argument optional. For
    making arguments optional, Kotlin provides us with default arguments, by which
    we can specify a default value of a function right away at the time of declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the modified function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We would use the `main` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For the first one, we skipped the argument and for the second one, we provided
    `6`. So, for the first one, the output should be true (as `5` is really greater
    than `0`), while for the second one, it should be false (as `5` isn't greater
    than `6`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot output confirms the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae55b51d-74ec-41b4-963e-629fa7f51823.png)'
  prefs: []
  type: TYPE_IMG
- en: Nested functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin allows you to nest functions, one within another. We can declare and
    use a function within another function.
  prefs: []
  type: TYPE_NORMAL
- en: When you declare a function within another function, the nested functions, visibility
    will stay exclusively within the parent function and cannot be accessed from outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s have an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we declared and used a function—`nested()`—inside
    the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output, if you''re curious:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e86a63ad-5bd7-4a67-88f2-9fc3e1427bdb.png)'
  prefs: []
  type: TYPE_IMG
- en: So, as we've got our basics brushed up in functions, let's move forward in functional
    programming. In the following section, we will learn about function types.
  prefs: []
  type: TYPE_NORMAL
- en: Function types in functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main objectives of functional programming is to implement modular
    programming. Side effects (a functional term, defined later in this chapter) are
    often sources of bugs; functional programming wants you to avoid side effects
    totally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, functional programming has defined the following types of
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions as property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will discuss each of these concepts in order to get a solid
    grip on functional programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started with lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda, which can also be called **anonymous functions**, has a first-class
    citizen support in Kotlin. While, in Java, lambda is only supported starting with
    Java 8, in Kotlin, you can use Kotlin with JVM 6 onwards, so there's really no
    barrier for lambda in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we were talking about lambda, anonymous classes (or objects) and anonymous
    functions, but what are they? Let us explore.
  prefs: []
  type: TYPE_NORMAL
- en: To be generic, lambda or lambda expressions generally means **anonymous functions**,
    that is, functions without names, which can be assigned to variables, passed as
    arguments, or returned from another function. It is a kind of nested function,
    but is more versatile and more flexible. You can also say all the lambda expressions
    are functions, but not every function is a lambda expression. Being anonymous
    and unnamed brings a lot of benefits to lambda expressions, which we will discuss
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, not all languages support lambda and Kotlin is one of
    rarest languages, and it provides extensive support for lambda.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is it called lambda? Let us dig up a bit of history now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda, Λ, **λ** (uppercase Λ, lowercase λ) is the 11^(th) letter of the Greek
    alphabet. Pronunciation: lám(b)da.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://en.wikipedia.org/wiki/Lambda](https://en.wikipedia.org/wiki/Lambda)'
  prefs: []
  type: TYPE_NORMAL
- en: During the 1930s, Alonzo Church, who was at that time studying mathematics at
    Princeton University, used the Greek alphabet, specifically lambda, to denote
    what he called **functions**. The thing to note is that, at that time, there were
    only anonymous functions in computing; the concept of modern-day named functions
    were yet to come.
  prefs: []
  type: TYPE_NORMAL
- en: So, with this practice of Alonzo Church, the word lambda got attached to anonymous
    functions (then the only type of function) which is, to date, referred to in the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: Alonzo Church (June 14, 1903-August 11, 1995), was an American mathematician
    and logician who made major contributions to mathematical logic and the foundations
    of theoretical computer science. He is best known for the lambda calculus, *Church-Turing*
    thesis, proving the undecidability of the *Entscheidungsproblem*, *Frege-Church*
    ontology, and the *Church-Rosser* theorem. He also worked on philosophy of language
    (for example, Church, 1970).
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://en.wikipedia.org/wiki/Alonzo_Church](https://en.wikipedia.org/wiki/Alonzo_Church)'
  prefs: []
  type: TYPE_NORMAL
- en: Don't you think we have had enough of theories? Shouldn't we now focus on learning
    what lambda actually is, or what, exactly, it looks like? We will have a look
    at how lambdas look in Kotlin, but we would prefer to introduce you to lambda
    in Java first, and later in Kotlin, to make you fully understand how much power
    lambdas possess in Kotlin and what exactly is meant by first-class citizen support.
    You'll also learn the difference between lambda in Java and Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Java example. It''s a simple example, where we are passing
    an instance of an interface to a method and, in that method, we are calling a
    method from the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, in this program, `SomeInterface` is an interface (the inner interface of
    `LambdaIntroClass`) with a single method—`doSomeStuff()`. The static method (it's
    static to make it easily accessible by the `main` method) `invokeSomeStuff` takes
    an instance of `SomeInterface` and calls its method `doSomeStuff()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was a simple example; now, let''s make it simpler: let''s add lambda to
    it. Have a look at the following updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, here, the definition of `SomeInterface` and `invokeSomeStuff()` stays the
    same. The only difference is on passing the instance of `SomeInterface`. Instead
    of creating an instance of `SomeInstance` with a new `SomeInstance`, what we wrote
    is an expression (in bold) that looks pretty much like mathematical function expressions
    (except obviously the `System.out.println()`). That expression is called a **lambda
    expression**.
  prefs: []
  type: TYPE_NORMAL
- en: Wasn't that fantastic? You didn't need to create an instance of the interface,
    then override the method and all that stuff. What you did is a simple expression.
    That expression would be used as the method body of the `doSomeStuff()` method
    inside the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for both the programs is identical; it is as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b2507fe-ff5a-4106-8227-846e71d7eb23.png)'
  prefs: []
  type: TYPE_IMG
- en: Java doesn't have any types for lambda; you can only use lambda to create instances
    of classes and interfaces on the go. The only benefit of lambda in Java is that
    it makes Java programs easier to read (by humans) and reduces line counts.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot actually blame Java for that. After all, Java is basically a purely
    object-oriented language. Kotlin, on the other hand, is a perfect blend of object-oriented
    and functional programming paradigms; it brings both the worlds closer together.
    In our words, Kotlin is the best language if you want to get started with functional
    programming with previous knowledge of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, no more lectures, let us move on to the code. Let us now have a look how
    the same program would look in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that's the complete program (well, except the `import` statements and package
    name). I know you're a bit confused; you're asking if it is really the same program?
    Where is the interface definition then? Well, in Kotlin that is not actually required.
  prefs: []
  type: TYPE_NORMAL
- en: The `invokeSomeStuff()` function is actually a high-order function (covered
    next); we pass our lambda there and it directly calls the function.
  prefs: []
  type: TYPE_NORMAL
- en: Brilliant, isn't it? Kotlin has a bunch of features with lambda. Let us have
    a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Function as property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin also allows us to have functions as properties. Functions as properties
    means that a function can be used as a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we created a property, `sum`, which will actually
    hold a function to add two numbers passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: While `sum` is a `val` property, what it holds is a function (or lambda) and
    we can call that function just like the usual function we call; there are no differences
    there at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re curious, the following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19f84162-6dd6-4c54-9bb2-87a1876a3a39.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let us discuss the syntax of lambda.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, a lambda always stays embraced by the curly braces. This makes a
    lambda easy to identify, unlike in Java, where parameters/arguments reside outside
    the curly braces. In Kotlin, parameters/arguments reside inside curly braces separated
    by (`->`) from the logic of the function. The last statement in a lambda (which
    may just be a variable/property name or another function call) is considered as
    the return statement. So, whatever is the evaluation of the last statement of
    a lambda is the return value of a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if your function is a single parameter function, you can also skip the
    property name. So, how can you use that parameter if you don't specify the name?
    Kotlin provides you with a default `it` property for single parameter lambdas
    where you don't specify the property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s modify the previous lambda to add it. Have a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We skipped the complete program and output, as they remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: You must have noticed that we assigned the function parameters value to another
    `var` property (both when the parameter was named and when we denoted with `it`).
    The reason is that, in Kotlin, function parameters are immutable, but with the
    reverse number program, we needed a way to change the value; so, we assigned the
    value to a `var` property, which is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have lambda as properties, but what about their datatypes? Every property/variable
    has a datatype (even if the type is inferred), so what about lambdas? Let''s have
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we declared a `reverse` property as a function. In
    Kotlin, when you're declaring a property as a function, you should mention the
    datatypes of parameters/arguments inside braces, followed by an arrow and then
    the return type of the function; if the function is not planned to return something,
    you should mention `Unit`. While declaring a function as a property, you need
    not specify the parameter/argument name and while defining/assigning the function
    to the property, you can skip providing datatypes of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/643690f0-41fa-4752-88a9-e5b67d54c8a6.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we have a good concept of lambda and functions as properties in Kotlin.
    Now, let us move ahead with high order functions.
  prefs: []
  type: TYPE_NORMAL
- en: High order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A high order function is a function which accepts another function as a parameter
    or returns another function. We just saw how we can use a function as a property,
    so it's quite easy to see that we can accept another function as a parameter or
    that we can return another function from a function. As stated previously, technically
    the function that receives or returns another function (it may be more than one)
    or does both is called a **high-order** **function**.
  prefs: []
  type: TYPE_NORMAL
- en: In our first lambda example in Kotlin, the `invokeSomeStuff` function was a
    high-order function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another example of high-order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we created a high order function—`performOperationOnEven`
    which would take an `Int` and a lambda operation to execute on that `Int`. The
    only catch is that the function would only perform that operation on the provided
    `Int`, if that `Int` is an even number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Isn''t that easy enough? Let''s have a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a5c28e-0a67-4090-a06f-645f1a80e160.png)'
  prefs: []
  type: TYPE_IMG
- en: In all our previous examples, we saw how to pass a function (lambda) to another
    function. However, that's not the only feature of high order functions. A high
    order function also allows you to return a function from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us explore it. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we created a function, `getAnotherFunction`, that
    would take an `Int` parameter and would return a function that takes a `String` value
    and returns `Unit`. That `return` function prints both its parameter (a `String`)
    and its parents parameter (an `Int`).
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59428ba1-f83a-4a58-b5d3-6d2c79225672.png)'
  prefs: []
  type: TYPE_IMG
- en: In Kotlin, technically you can have nested high order functions to any depth.
    However, that would do more harm than help, and would even destroy the readability.
    So, you should avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions and side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have learned about lambda and high order functions. They are two of the
    most interesting and important topics of functional programming. In this section,
    we will be discussing side effects and pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start by defining side effects. We will then gradually move towards
    pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a computer program, when a function modifies any object/data outside its
    own scope, that is called a **side effect**. For instance, we often write functions
    that modify a global or static property, modify one of its arguments, raise an
    exception, write data to display or file, or even call another function which
    has a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, have a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program is a simple object-oriented program. However, it contains
    side effects. The `addNumbers()` function modifies the state of the `Calc` class,
    which is bad practice in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: While we cannot avoid side effects in a few functions, especially where we are
    accessing IO and/or a database and so on, side effects should be avoided wherever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of a pure function says that, if the return value of a function
    is completely dependent on its arguments/parameters, then this function may be
    referred to as a **pure function**. So, if we declare a function as `fun func1(x:Int):Int`,
    then its return value will be strictly dependent on its argument, `x`; say, if
    you call `func1` with a value of *3 N* times, then, for every call, its return
    value will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: The definition also says that a pure function should not actively or passively
    cause side effects, that is, it should not directly cause side effects, nor should
    it call any other function that causes side effects.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function can be either a lambda or a named function.
  prefs: []
  type: TYPE_NORMAL
- en: So, why are they called pure functions? The reason is quite simple. Programming
    functions originated from mathematical functions. Programming functions, over
    time, evolved to contain multiple tasks and perform anonymous actions that are
    not directly related to the processing of passed arguments. So, those functions
    that still resemble mathematical functions are called pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s modify our previous program to make it into a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Quite easy, isn't it? We are skipping the output, as the program is really easy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about functions, how to use them, and their
    classifications. We also got introduced to lambda and high order functions. We
    learned about pure functions and side effects.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take you deeper into functions. As I already stated, you
    need to master functions in order to learn functional programming properly. So,
    what are you waiting for? Turn the page right now.
  prefs: []
  type: TYPE_NORMAL
