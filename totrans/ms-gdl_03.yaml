- en: Chapter 3. Managing Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the basic unit of Gradle build script, that
    is, Task. We will have a detailed look into the Task framework, how to create
    your own tasks, overwrite tasks provided by Gradle, tasks configurations, and
    creating custom tasks using different approaches provided by Gradle. We will also
    discuss the task dependencies. This chapter will also give insight view of controlling
    the execution of tasks, how to enable or disable task execution, and skip task
    execution based on some conditions. Gradle provides one additional feature known
    as incremental build support, which skips the execution of tasks if it is up to
    date, that is, if there are no changes in the input and output of the tasks. It
    helps in reducing the build time of the scripts if you are running the build repeatedly.
    We will try to understand this feature with some examples. Gradle supports this
    functionality by default. We will see how to extend this feature to user-defined
    tasks. Additionally, we will also explore the `Project` object provided by Gradle
    to control the build scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Build script basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A build script is nothing but a set of actions that execute in some predefined
    order and perform certain operations. In Gradle, we call these actions or group
    of actions a **Task**, which is part of the parent entity called **Project**.
    The atomic unit of execution in the Gradle build file is called a Task. The outcome
    of the build file might be some assets such as JAR, WAR, and so on, or it might
    perform certain operations such as deployment of assets and configuration of assets.
    Each build file that is `build.gradle` represents at least one project. It might
    contain more than one project also in case of multiproject or multimodule build.
    We will discuss multiproject build in [Chapter 6](ch06.html "Chapter 6. Working
    with Gradle"), *Working with Gradle*. The execution of the build represents the
    execution of the `Project` object, which internally calls different tasks to perform
    the operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute any build script, Gradle instantiates the `org.gradle.api.Project`
    object for the build file and gives an implicit project object. You can use this
    object to access the Project API in the build file either through `project.<methodname
    | property>` or simply `<methodname | property>`. For example; to print the name
    of the project in your build file, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding statements will return the same output, that is, the project
    name. The project name is the name of the parent directory of the `build.gradle`
    file. Consider that `build.gradle` is under the `Chapter3` directory; thus, the
    output of the preceding statements would be `Project name is Chapter3`. You can
    change the name of the project by providing `rootProject.name=<New Project Name>`
    in the `settings.gradle` file. We will discuss further usage of the `settings.gradle`
    file in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"), *Working with
    Gradle*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the output `Project name is Chapter3`, you need to write the statements
    outside of a task block. If you write it inside a task, and if we are using the
    name or `$name` variable, it will show the task name. This is because inside a
    task block, the scope of the `name` variable will be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the properties of the project object, which can be
    used to configure the build file using the getter and setter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name // readonly`, you can only change using `settings.gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent // readonly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the properties are read-only, which are directly set by Gradle runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle also provides some default tasks, which can be used without applying
    any plugin such as copy task and zip task. It is also possible to define your
    own custom properties and custom tasks for the **project** object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each task in the build file, Gradle instantiates one of the implementations
    of Task object. There are different implementations of the Task interface; you
    can find further details of it at [https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html](https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html).
    Similar to the `Project` object, you can also control tasks programmatically using
    the Task API. You will see more details on this when we will create custom tasks
    using Groovy in a later section. In summary:'
  prefs: []
  type: TYPE_NORMAL
- en: A task is a collection of actions and properties. It can depend on some other
    tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task can accept input and return output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task also provides certain predefined properties such as name and description
    enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with a simple build file example to explain the existing project
    properties, provide custom properties, create tasks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the file location `/Chapter3/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the preceding `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, in Section 1, we have overwritten some of the existing
    properties of the project object. In Section 2, we have added custom properties
    to the project object. Note that the syntax of adding custom properties is to
    add the `<name=value>` pair inside the `ext` closure, or we can define it as `ext.<propertyname>
    = value`. Then, we have added two tasks to this build script in Section 3 and
    4 and added custom properties to the `sampleTask1` task. To add/update properties
    of the project, you do not need to add the `def` keyword. `def` is used to define
    the user-defined variables. However, here we are defining project properties.
    If you use `def startDate=<Value>`, it would be treated as a variable not a project
    property.
  prefs: []
  type: TYPE_NORMAL
- en: We are able to print the `startDate` and `endDate` in `sampleTask1` as we added
    these two as project properties, which can be directly accessed throughout the
    build file. To call task methods or to use task properties outside the task, we
    can use `task.<property name>` or `task.<method name>`. As in the preceding example,
    inside the `sampleTask2` task, we are printing `sampleTask1.taskDetail`.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to specify the properties of any project. We will see
    this in detail when we discuss properties in [Chapter 6](ch06.html "Chapter 6. Working
    with Gradle"), *Working with Gradle*.
  prefs: []
  type: TYPE_NORMAL
- en: Task configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed in first chapter that a build file consists of three phases: initialization,
    configuration, and execution, which are explained briefly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization creates the project object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration phase configures the project object, creates **DAG** (**Directed
    Acyclic Graph**) based on task dependencies. It also executes the project and
    the task configuration statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution phase finally executes the actions mentioned in the task body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The task API mainly defines two types of closures: `doFirst`(Closure closure)
    and `doLast`(Closure closure), which internally calls `doFirst(Action action)`
    and `doLast(Action action)`. You can mention either one or both of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Statements mentioned outside of these actions are part of your configuration,
    which are executed during the configuration phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the configuration phase of a task, you can execute the build script
    using the `--dry-run` or `–m` option. The `--dry-run` ( or `–m`) option only goes
    through the initialization and configuration phase, not the execution phase. Try
    to execute the preceding build file with the `--dry-run` option and you will find
    all the configuration statements printed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Gradle 2.4 version, there are some performance improvements implemented in
    the configuration phase. For more details, refer to the release note at [https://docs.gradle.org/2.4/release-notes#significant-configuration-time-performance-improvements](https://docs.gradle.org/2.4/release-notes#significant-configuration-time-performance-improvements).
  prefs: []
  type: TYPE_NORMAL
- en: Task execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, a task is nothing but a single or group of actions that
    is executed to perform certain operations. You can add multiple actions to `doFirst`
    or `doLast` closures if needed. The `doFirst` closure will always execute before
    the `doLast` closure. You can add the actions to the task even after task definition.
  prefs: []
  type: TYPE_NORMAL
- en: For example, add the following statements after the `sampleTask2` task is mentioned
    in the preceding script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement will add two more additional actions to `sampleTask2`.
    Gradle provides one short notation for `doLast`, which is `<<`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Groovy, `<<` is the left shift operator to append elements to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to execute `sampleTask3` and review the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If multiple tasks are mentioned on the command line, they will be executed in
    the order defined (unless some dependency is applied on the tasks).
  prefs: []
  type: TYPE_NORMAL
- en: Task dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about build lifecycle or test lifecycle of any build tool, what
    does actually happen internally? It does not execute only one task; it basically
    executes a group of tasks, which are defined in a certain order and this order
    is nothing but the task dependencies. Consider the example of building any Java
    project. You can build a Java project by executing the `gradle build` task. This
    will do everything, such as compiling the source code, package classes into JAR
    file and copy the JAR file to a location. Does it mean that all these processes
    are only part of the **build** task? The message we want to convey here is that
    Gradle's `build` task does not execute only one task, but it executes the series
    of tasks from `compileJava`, `classes`, `compiileTestJava` and so on until the
    building of the JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Task dependency](img/B02000_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure is nothing but the representation of the DAG after applying
    the Java plugin. It represents different tasks and how they are dependent on each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: If a task, Task1, depends on another task, Task2, then Gradle makes sure that
    Task2 is always executed before Task1\. In the preceding example, the **compileJava**,
    **classes**, and **jar** tasks will always execute before the build task. A task
    can depend on one or more tasks. Two or more tasks can also depend on the same
    prerequisite task. For example, in the preceding DAG the **javadoc**, **compileTestjava**,
    and **jar** tasks depends on the **classes** task. It does not mean that the **classes**
    task will execute three times. It will execute only once in the **build** lifecycle.
    If a task has already been executed due to some other dependency, it will not
    execute again. It will just inform the other dependent task about its status so
    that dependent task will continue to execute without calling it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the build file, a task dependency can be defined in any of the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Many plugins provide tasks with default dependencies. As we have seen in the
    preceding diagram, the `classes` task has the `compileJava` dependency. If you
    add any other dependency (for example, `task1`) to the `classes` task, it will
    append the task (`task1`) with the `compileJava` task. This means, executing the
    `classes` task will execute both `compileJava` and `task1`. To exclusively override
    the existing dependencies with a new set of dependencies, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, executing the `classes` task will execute both `task1` and `task2` as
    dependent tasks and it will ignore the `compileJava` task.
  prefs: []
  type: TYPE_NORMAL
- en: Task ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If **Task1** depends on **Task2**, then Gradle makes sure that **Task2** will
    always execute before **Task1**. However, it does not make sure the ordering of
    tasks. That is, it will not ensure that **Task2** will execute immediately before
    **Task1**. Between the execution of **Task2** and **Task1**, other tasks might
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Task ordering](img/B02000_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, **Task1** depends on **Task2** and **Task3**.
    **Task4** is an independent task. If you execute `gradle Task1 Task4`, the execution
    flow will be **Task2**, **Task3**, **Task1**, and then **Task4**, as if a task
    depends on multiple tasks. Gradle executes the dependent tasks in alphabetical
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with `dependsOn`, Gradle provides some additional categories of ordering.
    For example, after the execution of the last task, you might want to clean the
    temporary resources, which were created during the build process. To enable this
    type of ordering, Gradle provides the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shouldRunAfter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mustRunAfter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finalyzedBy` (more strict in nature)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example. Create the `build_ordering.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the script, we have created six tasks named `sampleTask` with an integer
    suffix. Now, to understand task ordering, execute the preceding build script with
    different task names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute `sampleTask2` and `sampleTask1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute `sampleTask2, sampleTask1`, and `sampleTask3`. Task `sampleTask2`
    will execute only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will execute `sampleTask5` and `sampleTask6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `sampleTask5` task will not execute `sampleTask4`, since the
    `mustRunAfter` ordering will come into effect when both tasks (`sampleTask4` and
    `sampleTask5`) are part of the execution process. This is explained in the following
    command. Here, you have also seen the use of the `finalizedBy` operation. It provides
    the concluded by order, that is, `sampleTask5` should be immediately followed
    by `sampleTask6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will execute `sampleTask4`, `sampleTask5`, and `sampleTask6` in sequence.
    This is because `sampleTask5` must run after `sampleTask4`, and `sampleTask5`
    should be concluded by `sampleTask6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between `mustRunAfter` and `shouldRunAfter` is that `mustRunAfter`
    is strict ordering, whereas `shouldRunAfter` is lenient ordering. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, for the first two statements, the execution order is `sampleTask3`,
    `sampleTask2`, and then `sampleTask1`. The next statement `sampleTask3.mustRunAfter
    sampleTask1`, which says `sampleTask3` must execute after `sampleTask1` introduces
    cyclic dependency. Thus, the execution of `sampleTask1` will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you replace `mustRunAfter` with `shouldRunAfter`, then it will not throw
    any exception and will ignore strict ordering in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Task operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are tired of typing complete task names in the command-line; here is
    a good option for you. If you have defined task names in camel case (*camelCase*)
    format, you can just execute the task by mentioning the first letter of each word.
    For example, you can execute the `sampleTask1` task with shorthand `sT1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will execute `sampleTask1` and `sampleTask2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the shorthand of camel case matches more than one task, it will result in
    ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will explore some other task operations such as conditional execution,
    build optimization, and force execution.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different scenarios when you want to execute some tasks based on
    certain properties. For example, you have a property named `environment` in the
    `build` file. If the value of the property is set to `prod`, you want to execute
    production specific tasks and if it is `qa`, you want to execute test-specific
    tasks. Create a `build` file `build_condition.gradle` with the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the preceding `build` file with both the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, Gradle skipped `qaTask` and executed only `prodTask` based on the environment
    property set in the `build` file. You can also remove the environment value in
    the preceding `ext` closure and directly set the property from the command-line
    option and try to execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There might be another scenario when a task is outdated and you do not want
    to execute it, even if some other task depends on this task. This feature is supported
    by the `enabled` option in the task configuration phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can set `enabled` in the configuration phase itself. It should
    not be part of the `doFirst` or `doLast` closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if we try to set `enabled = false` in the `doLast`
    closure, the task will not execute. Build will fail with the `Cannot call Task.setEnabled(boolean)
    on task ':sampleTask12' after task has started execution` error.
  prefs: []
  type: TYPE_NORMAL
- en: Build optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a scenario where your `build` file consists of 10 tasks, which execute
    as per the task dependencies order. Out of 10 tasks, five tasks are modifying
    five different files on the filesystem. Let''s say these five files are some property
    files and these build tasks are setting some values to the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After first execution, the property files are modified with the respective values.
    When you run the `build` script again, although the files are already modified,
    the build script modifies those files again.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle provides a mechanism of skipping the execution of these kinds of tasks
    based on the input and output parameters of the task, which is also known as **incremental
    build**. It helps in reducing the build time. You might have observed when you
    apply Java plugin and build your project couple of times, some tasks are marked
    with UP-TO-DATE keyword (execute without `-q` option). This means there is no
    change in the input and output compared to the last execution of these tasks and
    those tasks are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Gradle provides this feature to its in-built tasks. You can also
    enhance your tasks with this capability, with the help of inputs and outputs of
    the task. Task inputs and outputs are of type `TaskInputs` and `TaskOuputs`. We
    will explain this behavior with help of one example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `PropDetails.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the `build_optimization.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this task for the first time, it will read the `PropDetail.xml`
    file and will create two files `envproperty.txt` and `sysproperty.txt` with `key=value`
    pair mentioned in the `property` file. Now, if you run this command again, you
    will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This implies that there is no change in the input and output of this task; thus,
    there is no need to execute the task again.
  prefs: []
  type: TYPE_NORMAL
- en: Try to change either the XML file or the generated property files or delete
    the output files. If you run the `Gradle` command again, this time, the task will
    execute and it will recreate the files. Gradle internally generates snapshots
    of input parameters and output parameters (Gradle generates a hash code to avoid
    duplicates) and stores it. Next time onwards, Gradle generates the snapshots of
    input and output parameters, and if both are the same, it avoids the execution
    of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Also, an important point to remember, if no output is defined for tasks, then
    it will not be considered for optimization (`UP-TO-DATE`). The task will always
    execute. There can be a scenario where the output of a task is not a file or a
    directory, it could be some other logical build steps or system-related check.
    In this situation, you can use the `TaskOutputs.upToDateWhen()` method or the
    `outputs.upToDateWhen` closure to check the specific scenario and mark tasks `UP-TO-DATE`.
  prefs: []
  type: TYPE_NORMAL
- en: To skip the optimization technique and force full execution of the task, the
    `--rerun-tasks` command line option can be used. It will execute the task forcefully,
    even if it is `UP-TO-DATE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `--rerun-tasks` option will always execute the task without checking the
    input and output parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Task rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed the `methodMissing` concept in Groovy. You can define some method
    patterns in Groovy, which can respond to method calls at runtime with the predefined
    patterns. Task rules provide the same flexibility with tasks. It allows executing
    a task, which does not exist. Gradle checks the task rule and creates the task
    if the rules have been defined. We will see the usage with the help of a simple
    example. For example, you have different assets, which are synced from different
    repository servers. Rather than creating different tasks for each sync, you can
    create the task rule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here you can call different tasks for each repository servers as `gradle sync<repoServer>`
    and it will sync the assets from that repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common example of task rules can be found in the Java plugin. Add `apply
    plugin: ''java''` as the first line in the `build` file and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As of now, do not worry much about the plugin. We will discuss plugins in detail
    in [Chapter 4](ch04.html "Chapter 4. Plugin Management"), *Plugin Management*.
  prefs: []
  type: TYPE_NORMAL
- en: In the above output, you can find the rules defined in the Java plugin. Gradle
    provides three in-built rules `clean<TaskName>`, `build<sConfigurationName>`,
    and `upload<ConfigurationName>` and the newly created `sync<repoServer>` rule.
    For all the tasks that are available in your `build` file (Java plugin tasks and
    user-defined tasks), you can execute one additional task using `clean<TaskName>`.
    For example, you have assemble, classes, and jar tasks available in the Java plugin.
    Apart from executing normal clean task, which deletes the build directory, you
    can also execute tasks such as `cleanClasses, cleanJar`, and so on, which cleans
    only the result of one particular task.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle's in-built tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For day-to-day build-related activities, Gradle provides a variety of tasks.
    We will take a look at some of Gradle's in-built tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The Copy Task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This task is used to copy file(s) or directories from one location to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In `copyTask`, we have configured the `from` location and `into` location, and
    have also added the condition to include only `employees.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: The Rename Task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This task is an extended version of the copy task, which is used to rename
    files or directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the `copyWithRename` task, an additional `rename` closure was added.
  prefs: []
  type: TYPE_NORMAL
- en: The Zip task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This task is used to zip a group of file(s) or directories and copy the zip
    to the destination directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the `ziptask` task, another `destinationDir` configuration was added. You
    can refer to the online documentation for more a detailed API for these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that here we have not mentioned any actions for these tasks. Tasks themselves
    know what to do. We only need to configure the tasks to define them.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you use tasks that are part of plugins. Mostly, a plugin is
    a group of tasks bound together for some specific functionality. For example;
    we use the `java` plugin to build the Java project, the `war` plugin to create
    web archives, and so on. When you apply the `java` plugin to a build script, Java
    tasks are automatically included. We will discuss about plugins in detail in [Chapter
    4](ch04.html "Chapter 4. Plugin Management"), *Plugin Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the Java tasks, we do not need to mention even the configurations.
    For these tasks, Gradle applies conventions, that is, the default configuration.
    If a project follows a certain convention, it can directly execute these tasks
    without any configurations. If not, it should define its own configurations. To
    add the `java` plugin to a `build` file, just add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `java` plugin assumes that the project's source files are located
    at `src/main/java`. If the source files are present in this directory, you can
    execute the `gradle compileJava` or `gradle build` task without any configuration.
    We will discuss more on Java plugins and tasks in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Until now in this chapter, we have got some idea about how to create tasks and
    how to use Gradle's in-built tasks. In the next section, we will explore how to
    create custom tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Custom tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gradle supports a variety of tasks for build automation, either from Gradle's
    in-house plugins or from third-party plugins. As we know the software adage, change
    is the only constant thing in software; the requirements and complexity change
    over the time. Many a times we come across different automation requirements for
    which no task or plugin is available in Gradle. In such cases, you can extend
    Gradle by adding custom tasks to the build.
  prefs: []
  type: TYPE_NORMAL
- en: A custom task is an enhanced task, which you add to Gradle to fulfill custom
    requirements. It can have input, output, configurations and more. Its scope is
    not only limited to the `build` file where it is defined; it can be reused in
    other projects by adding custom task JAR in the classpath. You can write custom
    tasks in Groovy, Java, and Scala. In this section, we will create custom task
    examples in Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle provides different ways to add custom tasks in the build script:'
  prefs: []
  type: TYPE_NORMAL
- en: The `build` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `buildSrc` directory inside the project directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a standalone Groovy project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom task is a Java or Groovy class that extends from `DefaultTask`. We
    can use the `@TaskAction` annotation to define the task actions. You can add multiple
    actions in a single task. They will execute in the order they are defined. Let's
    start with a simple custom task in the `build` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the file located at `Chapter3/Customtask/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the following file will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have defined a custom task type, `SampleTask`.
    We have added two action methods `action1()` and `action2()`. You can add more
    actions as per the requirement. We have added two task variables `systemName`
    and `systemGroup` with some default values. We can reinitialize these variables
    in the project scope again while configuring the task (hello). Gradle also provides
    the flexibility to add more actions to a task with the help of the `doFirst` and
    `doLast` closures like any other task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a task type is defined, you can create a task by using `task <taskname>(type:
    <TaskType>)`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can configure the task in configuration closure either while declaring the
    task or as a separate closure, as mentioned in the preceding file.
  prefs: []
  type: TYPE_NORMAL
- en: Using buildSrc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to keep the custom task code separate from the build file, but you
    do not want to create a separate project for it, you can achieve this by adding
    the custom task in the `buildSrc` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `buildSrc` directory in the project base directory and create the
    following mentioned folder hierarchy: `buildSrc/src/main/groovy/ch3/SampleTask.groovy`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the preceding `SampleTask` class in the file. You also need to import
    two packages: `org.gradle.api.DefaultTask` and `org.gradle.api.tasks.TaskAction`.
    Now, the `build` file is left with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: On executing the `hello` task, you will find the same output that was displayed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: After execution, you will find the following folder structure in the project.
    Note that you do not need to compile the `SampleTask` class. All the required
    steps would be performed by Gradle. It will compile the classes, create JAR, and
    will automatically add the required class to the build class path. You can just
    define the task and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using buildSrc](img/B02000_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3
  prefs: []
  type: TYPE_NORMAL
- en: The limitation is that the `SampleTask` task is only available in the current
    project and its subprojects only. You cannot use this task in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: The standalone task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To overcome the limitations of the `buildSrc` way of creating custom tasks,
    you need to create an independent Groovy project. Move the `SampleTask` class
    in a new project (`SampleTaskProj`), and then compile and package the project.
    You can even use Gradle to build this Groovy project. Just add `build.gradle`
    with the following statements to the `SampleTaskProj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are creating the project in Eclipse, you can run the following command
    to generate the Eclipse classpath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute the `gradle build` command to build the project. A JAR file will
    be created in the build directory. To use the tasks, in the build file (think
    of it as a new `build.gradle` file in another project), we need to reference the
    JAR file path in the **repositories** closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and update the `build.gradle` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `hello` task again and you will find the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed Gradle task in detail. We learned how to
    create simple tasks in Gradle and add actions to it. Along with it, we looked
    into task dependencies. We also looked into strict ordering of tasks if needed,
    using `mustRunAfter` and `FinalyzedBy`. We also discussed incremental build feature
    in Gradle, which improves build execution time. One of the important extensions
    is the custom task. We also saw how to create custom tasks and reuse the same
    task across different projects.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, a task could fulfill a simple build requirement. However, requirements
    keep growing and we need more number of tasks. It is also required to group certain
    related tasks to perform a specific behavior. This grouping of tasks is done in
    a plugin. A plugin is a group of different tasks bonded together. So, our next
    chapter is dedicated to plugin management. We will discuss how to bind tasks to
    a plugin and how to utilize plugins to enhance build capabilities.
  prefs: []
  type: TYPE_NORMAL
