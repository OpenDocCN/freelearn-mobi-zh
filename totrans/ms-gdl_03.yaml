- en: Chapter 3. Managing Task
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 管理任务
- en: In this chapter, we will discuss the basic unit of Gradle build script, that
    is, Task. We will have a detailed look into the Task framework, how to create
    your own tasks, overwrite tasks provided by Gradle, tasks configurations, and
    creating custom tasks using different approaches provided by Gradle. We will also
    discuss the task dependencies. This chapter will also give insight view of controlling
    the execution of tasks, how to enable or disable task execution, and skip task
    execution based on some conditions. Gradle provides one additional feature known
    as incremental build support, which skips the execution of tasks if it is up to
    date, that is, if there are no changes in the input and output of the tasks. It
    helps in reducing the build time of the scripts if you are running the build repeatedly.
    We will try to understand this feature with some examples. Gradle supports this
    functionality by default. We will see how to extend this feature to user-defined
    tasks. Additionally, we will also explore the `Project` object provided by Gradle
    to control the build scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论Gradle构建脚本的基元，即任务（Task）。我们将详细探讨任务框架，如何创建自己的任务，覆盖Gradle提供的任务，任务配置，以及使用Gradle提供的不同方法创建自定义任务。我们还将讨论任务依赖。本章还将提供关于控制任务执行的观点，如何根据某些条件启用或禁用任务执行，以及跳过任务执行。Gradle提供了一项称为增量构建支持的功能，如果任务是最新的，即任务的输入和输出没有变化，则会跳过任务的执行。如果你反复运行构建，这有助于减少脚本的构建时间。我们将通过一些示例来尝试理解这个功能。Gradle默认支持此功能。我们将了解如何将此功能扩展到用户定义的任务。此外，我们还将探索Gradle提供的`Project`对象，以控制构建脚本。
- en: Build script basics
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建脚本基础
- en: A build script is nothing but a set of actions that execute in some predefined
    order and perform certain operations. In Gradle, we call these actions or group
    of actions a **Task**, which is part of the parent entity called **Project**.
    The atomic unit of execution in the Gradle build file is called a Task. The outcome
    of the build file might be some assets such as JAR, WAR, and so on, or it might
    perform certain operations such as deployment of assets and configuration of assets.
    Each build file that is `build.gradle` represents at least one project. It might
    contain more than one project also in case of multiproject or multimodule build.
    We will discuss multiproject build in [Chapter 6](ch06.html "Chapter 6. Working
    with Gradle"), *Working with Gradle*. The execution of the build represents the
    execution of the `Project` object, which internally calls different tasks to perform
    the operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本实际上是一组按某些预定义顺序执行并执行某些操作的动作。在Gradle中，我们称这些动作或动作组为**任务**，它是称为**项目**的父实体的一个部分。Gradle构建文件中的执行原子单位称为任务。构建文件的结果可能是某些资产，如JAR、WAR等，或者它可能执行某些操作，如资产的部署和配置。每个`build.gradle`文件至少代表一个项目。在多项目或多模块构建的情况下，它也可能包含多个项目。我们将在[第6章](ch06.html
    "第6章. 与Gradle一起工作") *与Gradle一起工作*中讨论多项目构建。构建的执行代表`Project`对象的执行，该对象内部调用不同的任务以执行操作。
- en: 'When you execute any build script, Gradle instantiates the `org.gradle.api.Project`
    object for the build file and gives an implicit project object. You can use this
    object to access the Project API in the build file either through `project.<methodname
    | property>` or simply `<methodname | property>`. For example; to print the name
    of the project in your build file, you can use the following code:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行任何构建脚本时，Gradle会为构建文件实例化`org.gradle.api.Project`对象，并给出一个隐式的项目对象。你可以使用此对象通过`project.<methodname
    | property>`或简单地`<methodname | property>`在构建文件中访问项目API。例如；要在你的构建文件中打印项目的名称，你可以使用以下代码：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the preceding statements will return the same output, that is, the project
    name. The project name is the name of the parent directory of the `build.gradle`
    file. Consider that `build.gradle` is under the `Chapter3` directory; thus, the
    output of the preceding statements would be `Project name is Chapter3`. You can
    change the name of the project by providing `rootProject.name=<New Project Name>`
    in the `settings.gradle` file. We will discuss further usage of the `settings.gradle`
    file in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"), *Working with
    Gradle*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的上述语句都将返回相同的输出，即项目名称。项目名称是 `build.gradle` 文件父目录的名称。假设 `build.gradle` 位于 `Chapter3`
    目录下；因此，上述语句的输出将是 `项目名称是Chapter3`。你可以在 `settings.gradle` 文件中提供 `rootProject.name=<新项目名称>`
    来更改项目名称。我们将在 [第6章](ch06.html "第6章。使用Gradle") *使用Gradle* 中进一步讨论 `settings.gradle`
    文件的用法。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To get the output `Project name is Chapter3`, you need to write the statements
    outside of a task block. If you write it inside a task, and if we are using the
    name or `$name` variable, it will show the task name. This is because inside a
    task block, the scope of the `name` variable will be different.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到输出 `项目名称是Chapter3`，你需要在任务块之外编写语句。如果你在任务内编写它，并且我们使用名称或 `$name` 变量，它将显示任务名称。这是因为任务块内部，`name`
    变量的作用域将不同。
- en: 'The following are some of the properties of the project object, which can be
    used to configure the build file using the getter and setter methods:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些项目对象的属性，可以使用 getter 和 setter 方法来配置构建文件：
- en: '`name // readonly`, you can only change using `settings.gradle`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name // 只读`，你只能使用 `settings.gradle` 来更改'
- en: '`parent // readonly`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent // 只读`'
- en: '`version`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`版本`'
- en: '`description`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`'
- en: Some of the properties are read-only, which are directly set by Gradle runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性是只读的，它们由 Gradle 运行时直接设置。
- en: Gradle also provides some default tasks, which can be used without applying
    any plugin such as copy task and zip task. It is also possible to define your
    own custom properties and custom tasks for the **project** object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 还提供了一些默认任务，可以在不应用任何插件的情况下使用，例如复制任务和压缩任务。你也可以为 **项目** 对象定义自己的自定义属性和自定义任务。
- en: 'For each task in the build file, Gradle instantiates one of the implementations
    of Task object. There are different implementations of the Task interface; you
    can find further details of it at [https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html](https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html).
    Similar to the `Project` object, you can also control tasks programmatically using
    the Task API. You will see more details on this when we will create custom tasks
    using Groovy in a later section. In summary:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建文件中的每个任务，Gradle 将实例化 Task 对象的一个实现。Task 接口有不同的实现；你可以在 [https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html](https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html)
    找到更多关于它的详细信息。类似于 Project 对象，你也可以使用 Task API 编程方式控制任务。当我们在后面的部分使用 Groovy 创建自定义任务时，你将看到更多关于这个的细节。总之：
- en: A task is a collection of actions and properties. It can depend on some other
    tasks
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务是一组动作和属性的集合。它可以依赖于其他一些任务
- en: A task can accept input and return output
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以接受输入并返回输出
- en: A task also provides certain predefined properties such as name and description
    enabled
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务还提供了一些预定义属性，如名称和描述已启用
- en: We will start with a simple build file example to explain the existing project
    properties, provide custom properties, create tasks, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的构建文件示例开始，解释现有的项目属性，提供自定义属性，创建任务等。
- en: 'Consider the file location `/Chapter3/build.gradle`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑文件位置 `/Chapter3/build.gradle`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To execute the preceding `build.gradle` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行前面的 `build.gradle` 文件：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, in Section 1, we have overwritten some of the existing
    properties of the project object. In Section 2, we have added custom properties
    to the project object. Note that the syntax of adding custom properties is to
    add the `<name=value>` pair inside the `ext` closure, or we can define it as `ext.<propertyname>
    = value`. Then, we have added two tasks to this build script in Section 3 and
    4 and added custom properties to the `sampleTask1` task. To add/update properties
    of the project, you do not need to add the `def` keyword. `def` is used to define
    the user-defined variables. However, here we are defining project properties.
    If you use `def startDate=<Value>`, it would be treated as a variable not a project
    property.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在第一节中，我们覆盖了一些项目对象现有的属性。在第二节中，我们向项目对象添加了自定义属性。请注意，添加自定义属性的语法是在`ext`闭包内添加`<name=value>`对，或者我们可以将其定义为`ext.<propertyname>
    = value`。然后，我们在第三节和第四节中向此构建脚本添加了两个任务，并添加了自定义属性到`sampleTask1`任务。要添加/更新项目的属性，你不需要添加`def`关键字。`def`用于定义用户定义的变量。然而，在这里我们正在定义项目属性。如果你使用`def
    startDate=<Value>`，它将被视为变量而不是项目属性。
- en: We are able to print the `startDate` and `endDate` in `sampleTask1` as we added
    these two as project properties, which can be directly accessed throughout the
    build file. To call task methods or to use task properties outside the task, we
    can use `task.<property name>` or `task.<method name>`. As in the preceding example,
    inside the `sampleTask2` task, we are printing `sampleTask1.taskDetail`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在`sampleTask1`中打印`startDate`和`endDate`，因为我们将其添加为项目属性，可以在整个构建文件中直接访问。要调用任务方法或使用任务属性在任务外部，我们可以使用`task.<property
    name>`或`task.<method name>`。正如前面的示例，在`sampleTask2`任务内部，我们正在打印`sampleTask1.taskDetail`。
- en: There are multiple ways to specify the properties of any project. We will see
    this in detail when we discuss properties in [Chapter 6](ch06.html "Chapter 6. Working
    with Gradle"), *Working with Gradle*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以指定任何项目的属性。当我们在[第六章](ch06.html "第六章。使用Gradle")中讨论属性时，我们将详细讨论这一点，*使用Gradle*。
- en: Task configuration
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务配置
- en: 'We discussed in first chapter that a build file consists of three phases: initialization,
    configuration, and execution, which are explained briefly as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中讨论了构建文件由三个阶段组成：初始化、配置和执行，以下简要解释：
- en: Initialization creates the project object.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化创建项目对象。
- en: The configuration phase configures the project object, creates **DAG** (**Directed
    Acyclic Graph**) based on task dependencies. It also executes the project and
    the task configuration statements.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置阶段配置项目对象，根据任务依赖关系创建**DAG**（**有向无环图**）。它还执行项目和任务配置语句。
- en: The execution phase finally executes the actions mentioned in the task body.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行阶段最终执行任务体中提到的操作。
- en: 'The task API mainly defines two types of closures: `doFirst`(Closure closure)
    and `doLast`(Closure closure), which internally calls `doFirst(Action action)`
    and `doLast(Action action)`. You can mention either one or both of them.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 任务API主要定义了两种类型的闭包：`doFirst`(Closure closure)和`doLast`(Closure closure)，它们内部调用`doFirst(Action
    action)`和`doLast(Action action)`。你可以提及一个或两个。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Statements mentioned outside of these actions are part of your configuration,
    which are executed during the configuration phase.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些操作之外提到的语句是配置的一部分，在配置阶段执行。
- en: 'To verify the configuration phase of a task, you can execute the build script
    using the `--dry-run` or `–m` option. The `--dry-run` ( or `–m`) option only goes
    through the initialization and configuration phase, not the execution phase. Try
    to execute the preceding build file with the `--dry-run` option and you will find
    all the configuration statements printed on the console:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证任务的配置阶段，你可以使用`--dry-run`或`–m`选项执行构建脚本。`--dry-run`（或`–m`）选项只通过初始化和配置阶段，不通过执行阶段。尝试使用`--dry-run`选项执行前面的构建文件，你将在控制台上找到所有配置语句：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Gradle 2.4 version, there are some performance improvements implemented in
    the configuration phase. For more details, refer to the release note at [https://docs.gradle.org/2.4/release-notes#significant-configuration-time-performance-improvements](https://docs.gradle.org/2.4/release-notes#significant-configuration-time-performance-improvements).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle 2.4版本中，在配置阶段实现了一些性能改进。更多详情请参考发布说明中的[重要配置时间性能改进](https://docs.gradle.org/2.4/release-notes#significant-configuration-time-performance-improvements)。
- en: Task execution
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务执行
- en: As mentioned earlier, a task is nothing but a single or group of actions that
    is executed to perform certain operations. You can add multiple actions to `doFirst`
    or `doLast` closures if needed. The `doFirst` closure will always execute before
    the `doLast` closure. You can add the actions to the task even after task definition.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，任务不过是一系列执行以执行某些操作的单一或多个动作。如果需要，你可以向`doFirst`或`doLast`闭包添加多个动作。`doFirst`闭包将始终在`doLast`闭包之前执行。你甚至可以在任务定义之后向任务添加动作。
- en: For example, add the following statements after the `sampleTask2` task is mentioned
    in the preceding script.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面脚本中提到`sampleTask2`任务之后添加以下语句。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding statement will add two more additional actions to `sampleTask2`.
    Gradle provides one short notation for `doLast`, which is `<<`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将为`sampleTask2`添加两个额外的操作。Gradle为`doLast`提供了一个简短的表示法，即`<<`。
- en: 'In Groovy, `<<` is the left shift operator to append elements to a list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，`<<`是左移运算符，用于向列表中添加元素：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Try to execute `sampleTask3` and review the output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试执行`sampleTask3`并查看输出：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If multiple tasks are mentioned on the command line, they will be executed in
    the order defined (unless some dependency is applied on the tasks).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在命令行上提到了多个任务，它们将按照定义的顺序执行（除非对任务应用了某些依赖关系）。
- en: Task dependency
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务依赖
- en: When we talk about build lifecycle or test lifecycle of any build tool, what
    does actually happen internally? It does not execute only one task; it basically
    executes a group of tasks, which are defined in a certain order and this order
    is nothing but the task dependencies. Consider the example of building any Java
    project. You can build a Java project by executing the `gradle build` task. This
    will do everything, such as compiling the source code, package classes into JAR
    file and copy the JAR file to a location. Does it mean that all these processes
    are only part of the **build** task? The message we want to convey here is that
    Gradle's `build` task does not execute only one task, but it executes the series
    of tasks from `compileJava`, `classes`, `compiileTestJava` and so on until the
    building of the JAR file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论任何构建工具的构建生命周期或测试生命周期时，实际上内部发生了什么？它不仅仅执行一个任务；它基本上执行一系列任务，这些任务按照一定的顺序定义，而这个顺序就是任务的依赖关系。以构建任何Java项目为例。你可以通过执行`gradle
    build`任务来构建Java项目。这将完成所有工作，例如编译源代码、将类打包成JAR文件并将JAR文件复制到某个位置。这意味着所有这些过程都只是构建任务的一部分吗？我们在这里想要传达的信息是，Gradle的`build`任务不仅仅执行一个任务，而是执行从`compileJava`、`classes`、`compileTestJava`等一系列任务，直到构建JAR文件。
- en: '![Task dependency](img/B02000_03_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![任务依赖](img/B02000_03_01.jpg)'
- en: Figure 3.1
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1
- en: The preceding figure is nothing but the representation of the DAG after applying
    the Java plugin. It represents different tasks and how they are dependent on each
    other.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图只是应用Java插件后DAG的表示。它表示不同的任务以及它们是如何相互依赖的。
- en: If a task, Task1, depends on another task, Task2, then Gradle makes sure that
    Task2 is always executed before Task1\. In the preceding example, the **compileJava**,
    **classes**, and **jar** tasks will always execute before the build task. A task
    can depend on one or more tasks. Two or more tasks can also depend on the same
    prerequisite task. For example, in the preceding DAG the **javadoc**, **compileTestjava**,
    and **jar** tasks depends on the **classes** task. It does not mean that the **classes**
    task will execute three times. It will execute only once in the **build** lifecycle.
    If a task has already been executed due to some other dependency, it will not
    execute again. It will just inform the other dependent task about its status so
    that dependent task will continue to execute without calling it again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务Task1依赖于另一个任务Task2，那么Gradle会确保Task2始终在Task1之前执行。在前面的例子中，`compileJava`、`classes`和`jar`任务将始终在构建任务之前执行。一个任务可以依赖于一个或多个任务。两个或多个任务也可以依赖于同一个先决任务。例如，在前面的DAG中，`javadoc`、`compileTestjava`和`jar`任务依赖于`classes`任务。这并不意味着`classes`任务将执行三次。它将在构建生命周期中只执行一次。如果一个任务由于某些其他依赖关系已经执行，它将不会再次执行。它只会通知其他依赖任务其状态，以便依赖任务可以继续执行而无需再次调用它。
- en: 'In the build file, a task dependency can be defined in any of the following
    ways:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建文件中，任务依赖可以通过以下任何一种方式定义：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Many plugins provide tasks with default dependencies. As we have seen in the
    preceding diagram, the `classes` task has the `compileJava` dependency. If you
    add any other dependency (for example, `task1`) to the `classes` task, it will
    append the task (`task1`) with the `compileJava` task. This means, executing the
    `classes` task will execute both `compileJava` and `task1`. To exclusively override
    the existing dependencies with a new set of dependencies, use the following syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 许多插件提供了具有默认依赖的任务。正如我们在前面的图中看到的，`classes` 任务有 `compileJava` 依赖。如果你向 `classes`
    任务添加任何其他依赖（例如，`task1`），它将把任务（`task1`）附加到 `compileJava` 任务上。这意味着，执行 `classes` 任务将执行
    `compileJava` 和 `task1`。要使用一组新的依赖项专门覆盖现有的依赖项，请使用以下语法：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, executing the `classes` task will execute both `task1` and `task2` as
    dependent tasks and it will ignore the `compileJava` task.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，执行 `classes` 任务将执行作为依赖任务的 `task1` 和 `task2`，并且它将忽略 `compileJava` 任务。
- en: Task ordering
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务排序
- en: If **Task1** depends on **Task2**, then Gradle makes sure that **Task2** will
    always execute before **Task1**. However, it does not make sure the ordering of
    tasks. That is, it will not ensure that **Task2** will execute immediately before
    **Task1**. Between the execution of **Task2** and **Task1**, other tasks might
    be executed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **任务1** 依赖于 **任务2**，那么Gradle将确保**任务2**始终在**任务1**之前执行。然而，它并不确保任务的顺序。也就是说，它不会确保**任务2**将在**任务1**之前立即执行。在**任务2**和**任务1**的执行之间，可能会执行其他任务。
- en: '![Task ordering](img/B02000_03_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![任务排序](img/B02000_03_02.jpg)'
- en: Figure 3.2
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2
- en: As shown in the preceding diagram, **Task1** depends on **Task2** and **Task3**.
    **Task4** is an independent task. If you execute `gradle Task1 Task4`, the execution
    flow will be **Task2**, **Task3**, **Task1**, and then **Task4**, as if a task
    depends on multiple tasks. Gradle executes the dependent tasks in alphabetical
    order.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**任务1** 依赖于 **任务2** 和 **任务3**。**任务4** 是一个独立任务。如果你执行 `gradle Task1 Task4`，执行流程将是
    **任务2**、**任务3**、**任务1**，然后是 **任务4**，就像一个任务依赖于多个任务一样。Gradle 以字母顺序执行依赖任务。
- en: 'Along with `dependsOn`, Gradle provides some additional categories of ordering.
    For example, after the execution of the last task, you might want to clean the
    temporary resources, which were created during the build process. To enable this
    type of ordering, Gradle provides the following options:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `dependsOn` 之外，Gradle还提供了一些额外的排序类别。例如，在最后一个任务执行之后，你可能想要清理在构建过程中创建的临时资源。为了启用这种排序，Gradle提供了以下选项：
- en: '`shouldRunAfter`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldRunAfter`'
- en: '`mustRunAfter`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mustRunAfter`'
- en: '`finalyzedBy` (more strict in nature)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalyzedBy`（性质上更严格）'
- en: 'Let''s take a look at the following example. Create the `build_ordering.gradle`
    file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。创建 `build_ordering.gradle` 文件：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the script, we have created six tasks named `sampleTask` with an integer
    suffix. Now, to understand task ordering, execute the preceding build script with
    different task names:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们创建了六个带有整数后缀的 `sampleTask` 任务。现在，为了理解任务排序，使用不同的任务名称执行前面的构建脚本：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will execute `sampleTask2` and `sampleTask1`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行 `sampleTask2` 和 `sampleTask1`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will execute `sampleTask2, sampleTask1`, and `sampleTask3`. Task `sampleTask2`
    will execute only once:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行 `sampleTask2`、`sampleTask1` 和 `sampleTask3`。任务 `sampleTask2` 只会执行一次：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will execute `sampleTask5` and `sampleTask6`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行 `sampleTask5` 和 `sampleTask6`。
- en: 'Note that the `sampleTask5` task will not execute `sampleTask4`, since the
    `mustRunAfter` ordering will come into effect when both tasks (`sampleTask4` and
    `sampleTask5`) are part of the execution process. This is explained in the following
    command. Here, you have also seen the use of the `finalizedBy` operation. It provides
    the concluded by order, that is, `sampleTask5` should be immediately followed
    by `sampleTask6`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sampleTask5` 任务将不会执行 `sampleTask4`，因为当这两个任务（`sampleTask4` 和 `sampleTask5`）都是执行过程的一部分时，`mustRunAfter`
    排序将会生效。这将在下面的命令中解释。这里，你也看到了 `finalizedBy` 操作的使用。它提供了结论顺序，即 `sampleTask5` 应立即由
    `sampleTask6` 接替：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will execute `sampleTask4`, `sampleTask5`, and `sampleTask6` in sequence.
    This is because `sampleTask5` must run after `sampleTask4`, and `sampleTask5`
    should be concluded by `sampleTask6`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按顺序执行 `sampleTask4`、`sampleTask5` 和 `sampleTask6`。这是因为 `sampleTask5` 必须在 `sampleTask4`
    之后运行，并且 `sampleTask5` 应由 `sampleTask6` 结束。
- en: 'The difference between `mustRunAfter` and `shouldRunAfter` is that `mustRunAfter`
    is strict ordering, whereas `shouldRunAfter` is lenient ordering. Consider the
    following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`mustRunAfter` 和 `shouldRunAfter` 之间的区别在于 `mustRunAfter` 是严格的排序，而 `shouldRunAfter`
    是宽松的排序。考虑以下代码：'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, for the first two statements, the execution order is `sampleTask3`,
    `sampleTask2`, and then `sampleTask1`. The next statement `sampleTask3.mustRunAfter
    sampleTask1`, which says `sampleTask3` must execute after `sampleTask1` introduces
    cyclic dependency. Thus, the execution of `sampleTask1` will fail:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于前两个语句，执行顺序是`sampleTask3`、`sampleTask2`，然后是`sampleTask1`。下一个语句`sampleTask3.mustRunAfter
    sampleTask1`，表示`sampleTask3`必须在`sampleTask1`之后执行，这引入了循环依赖。因此，`sampleTask1`的执行将失败：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you replace `mustRunAfter` with `shouldRunAfter`, then it will not throw
    any exception and will ignore strict ordering in this scenario.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`mustRunAfter`替换为`shouldRunAfter`，则不会抛出任何异常，并且在这种情况下会忽略严格的顺序。
- en: Task operations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务操作
- en: 'If you are tired of typing complete task names in the command-line; here is
    a good option for you. If you have defined task names in camel case (*camelCase*)
    format, you can just execute the task by mentioning the first letter of each word.
    For example, you can execute the `sampleTask1` task with shorthand `sT1`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你厌倦了在命令行中输入完整的任务名称；这里有一个适合你的好选项。如果你已经以驼峰式（*camelCase*）格式定义了任务名称，你只需提及每个单词的首字母即可执行任务。例如，你可以使用缩写`sT1`来执行`sampleTask1`任务：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will execute `sampleTask1` and `sampleTask2`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行`sampleTask1`和`sampleTask2`。
- en: 'If the shorthand of camel case matches more than one task, it will result in
    ambiguity:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果驼峰式的缩写与多个任务匹配，将会导致歧义：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we will explore some other task operations such as conditional execution,
    build optimization, and force execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨一些其他任务操作，例如条件执行、构建优化和强制执行。
- en: Conditional execution
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件执行
- en: 'There are different scenarios when you want to execute some tasks based on
    certain properties. For example, you have a property named `environment` in the
    `build` file. If the value of the property is set to `prod`, you want to execute
    production specific tasks and if it is `qa`, you want to execute test-specific
    tasks. Create a `build` file `build_condition.gradle` with the following code
    snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要根据某些属性执行某些任务时，会有不同的场景。例如，你在`build`文件中有一个名为`environment`的属性。如果属性的值设置为`prod`，你想要执行特定于生产的任务；如果它是`qa`，你想要执行特定于测试的任务。创建一个`build`文件`build_condition.gradle`，包含以下代码片段：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Execute the preceding `build` file with both the tasks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个任务执行先前的`build`文件：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, Gradle skipped `qaTask` and executed only `prodTask` based on the environment
    property set in the `build` file. You can also remove the environment value in
    the preceding `ext` closure and directly set the property from the command-line
    option and try to execute the following commands:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Gradle跳过了`qaTask`并仅根据`build`文件中设置的环境属性执行了`prodTask`。你也可以在先前的`ext`闭包中移除环境值，并直接从命令行选项设置属性，然后尝试执行以下命令：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There might be another scenario when a task is outdated and you do not want
    to execute it, even if some other task depends on this task. This feature is supported
    by the `enabled` option in the task configuration phase:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在另一种情况，当一个任务过时且你不想执行它时，即使其他任务依赖于这个任务。这个特性在任务配置阶段通过`enabled`选项得到支持：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that you can set `enabled` in the configuration phase itself. It should
    not be part of the `doFirst` or `doLast` closure:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以在配置阶段本身设置`enabled`。它不应该成为`doFirst`或`doLast`闭包的一部分：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, if we try to set `enabled = false` in the `doLast`
    closure, the task will not execute. Build will fail with the `Cannot call Task.setEnabled(boolean)
    on task ':sampleTask12' after task has started execution` error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，如果我们尝试在`doLast`闭包中设置`enabled = false`，任务将不会执行。构建将失败，并出现`Cannot call
    Task.setEnabled(boolean) on task ':sampleTask12' after task has started execution`错误。
- en: Build optimization
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建优化
- en: 'Consider a scenario where your `build` file consists of 10 tasks, which execute
    as per the task dependencies order. Out of 10 tasks, five tasks are modifying
    five different files on the filesystem. Let''s say these five files are some property
    files and these build tasks are setting some values to the property:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，你的`build`文件由10个任务组成，这些任务按照任务依赖关系顺序执行。在10个任务中，有五个任务正在修改文件系统上的五个不同文件。假设这五个文件是某些属性文件，这些构建任务正在设置属性值：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After first execution, the property files are modified with the respective values.
    When you run the `build` script again, although the files are already modified,
    the build script modifies those files again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行后，属性文件被修改为相应的值。当你再次运行`build`脚本时，尽管文件已经被修改，构建脚本还是会再次修改这些文件。
- en: Gradle provides a mechanism of skipping the execution of these kinds of tasks
    based on the input and output parameters of the task, which is also known as **incremental
    build**. It helps in reducing the build time. You might have observed when you
    apply Java plugin and build your project couple of times, some tasks are marked
    with UP-TO-DATE keyword (execute without `-q` option). This means there is no
    change in the input and output compared to the last execution of these tasks and
    those tasks are ignored.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 提供了一种基于任务输入和输出参数跳过这些类型任务执行机制，这被称为**增量构建**。这有助于减少构建时间。你可能已经注意到，当你应用 Java
    插件并多次构建你的项目时，一些任务被标记为 UP-TO-DATE 关键字（执行时没有 `-q` 选项）。这意味着与上次执行这些任务相比，输入和输出没有变化，因此这些任务被忽略。
- en: 'By default, Gradle provides this feature to its in-built tasks. You can also
    enhance your tasks with this capability, with the help of inputs and outputs of
    the task. Task inputs and outputs are of type `TaskInputs` and `TaskOuputs`. We
    will explain this behavior with help of one example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gradle 为其内置任务提供此功能。你也可以通过任务输入和输出增强你的任务，输入和输出类型为 `TaskInputs` 和 `TaskOuputs`。我们将通过一个示例来解释这种行为：
- en: 'Consider the `PropDetails.xml` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `PropDetails.xml` 文件：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Consider the `build_optimization.gradle` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `build_optimization.gradle` 文件：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run this task for the first time, it will read the `PropDetail.xml`
    file and will create two files `envproperty.txt` and `sysproperty.txt` with `key=value`
    pair mentioned in the `property` file. Now, if you run this command again, you
    will see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次运行此任务，它将读取 `PropDetail.xml` 文件，并创建两个文件 `envproperty.txt` 和 `sysproperty.txt`，其中包含
    `property` 文件中提到的 `key=value` 对。现在，如果你再次运行此命令，你将看到以下输出：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This implies that there is no change in the input and output of this task; thus,
    there is no need to execute the task again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着此任务的输入和输出没有变化；因此，无需再次执行任务。
- en: Try to change either the XML file or the generated property files or delete
    the output files. If you run the `Gradle` command again, this time, the task will
    execute and it will recreate the files. Gradle internally generates snapshots
    of input parameters and output parameters (Gradle generates a hash code to avoid
    duplicates) and stores it. Next time onwards, Gradle generates the snapshots of
    input and output parameters, and if both are the same, it avoids the execution
    of tasks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改 XML 文件或生成的属性文件或删除输出文件。如果你再次运行 `Gradle` 命令，这次，任务将执行并重新创建文件。Gradle 内部生成输入参数和输出参数的快照（Gradle
    生成一个哈希码以避免重复）并存储它。从下一次开始，Gradle 生成输入和输出参数的快照，如果两者相同，则避免执行任务。
- en: Also, an important point to remember, if no output is defined for tasks, then
    it will not be considered for optimization (`UP-TO-DATE`). The task will always
    execute. There can be a scenario where the output of a task is not a file or a
    directory, it could be some other logical build steps or system-related check.
    In this situation, you can use the `TaskOutputs.upToDateWhen()` method or the
    `outputs.upToDateWhen` closure to check the specific scenario and mark tasks `UP-TO-DATE`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一个重要点需要记住，如果任务没有定义输出，则它将不会被考虑进行优化（`UP-TO-DATE`）。任务将始终执行。可能存在一种情况，即任务的输出不是文件或目录，它可能是其他逻辑构建步骤或系统相关的检查。在这种情况下，你可以使用
    `TaskOutputs.upToDateWhen()` 方法或 `outputs.upToDateWhen` 闭包来检查特定情况并标记任务为 `UP-TO-DATE`。
- en: To skip the optimization technique and force full execution of the task, the
    `--rerun-tasks` command line option can be used. It will execute the task forcefully,
    even if it is `UP-TO-DATE`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳过优化技术并强制完整执行任务，可以使用 `--rerun-tasks` 命令行选项。它将强制执行任务，即使它是 `UP-TO-DATE`。
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--rerun-tasks` option will always execute the task without checking the
    input and output parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`--rerun-tasks` 选项将始终执行任务，而不会检查输入和输出参数。'
- en: Task rules
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务规则
- en: 'We discussed the `methodMissing` concept in Groovy. You can define some method
    patterns in Groovy, which can respond to method calls at runtime with the predefined
    patterns. Task rules provide the same flexibility with tasks. It allows executing
    a task, which does not exist. Gradle checks the task rule and creates the task
    if the rules have been defined. We will see the usage with the help of a simple
    example. For example, you have different assets, which are synced from different
    repository servers. Rather than creating different tasks for each sync, you can
    create the task rule as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Groovy 中讨论了 `methodMissing` 概念。你可以在 Groovy 中定义一些方法模式，这些模式可以在运行时响应预定义的模式的方法调用。任务规则为任务提供了相同的灵活性。它允许执行一个不存在的任务。Gradle
    会检查任务规则，如果规则已被定义，则会创建任务。我们将通过一个简单的示例来查看其用法。例如，你有来自不同仓库服务器的不同资产，而不是为每个同步创建不同的任务，你可以创建如下任务规则：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here you can call different tasks for each repository servers as `gradle sync<repoServer>`
    and it will sync the assets from that repository.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以为每个仓库服务器调用不同的任务，例如 `gradle sync<repoServer>`，它将从该仓库同步资产。
- en: 'A very common example of task rules can be found in the Java plugin. Add `apply
    plugin: ''java''` as the first line in the `build` file and run the following
    command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '一个非常常见的任务规则示例可以在 Java 插件中找到。在 `build` 文件的第一行添加 `apply plugin: ''java''` 并运行以下命令：'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As of now, do not worry much about the plugin. We will discuss plugins in detail
    in [Chapter 4](ch04.html "Chapter 4. Plugin Management"), *Plugin Management*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，不必过多担心插件。我们将在[第 4 章](ch04.html "第 4 章。插件管理")*插件管理*中详细讨论插件。
- en: In the above output, you can find the rules defined in the Java plugin. Gradle
    provides three in-built rules `clean<TaskName>`, `build<sConfigurationName>`,
    and `upload<ConfigurationName>` and the newly created `sync<repoServer>` rule.
    For all the tasks that are available in your `build` file (Java plugin tasks and
    user-defined tasks), you can execute one additional task using `clean<TaskName>`.
    For example, you have assemble, classes, and jar tasks available in the Java plugin.
    Apart from executing normal clean task, which deletes the build directory, you
    can also execute tasks such as `cleanClasses, cleanJar`, and so on, which cleans
    only the result of one particular task.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，你可以找到在 Java 插件中定义的规则。Gradle 提供了三个内置规则 `clean<TaskName>`、`build<sConfigurationName>`
    和 `upload<ConfigurationName>` 以及新创建的 `sync<repoServer>` 规则。对于你在 `build` 文件中可用的所有任务（Java
    插件任务和用户定义的任务），你可以使用 `clean<TaskName>` 执行一个额外的任务。例如，Java 插件中提供了 assemble、classes
    和 jar 任务。除了执行正常的 clean 任务，删除构建目录外，你还可以执行 `cleanClasses`、`cleanJar` 等任务，这些任务仅清理特定任务的输出。
- en: Gradle's in-built tasks
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle 的内置任务
- en: For day-to-day build-related activities, Gradle provides a variety of tasks.
    We will take a look at some of Gradle's in-built tasks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日常的构建相关活动，Gradle 提供了各种任务。我们将查看一些 Gradle 的内置任务。
- en: The Copy Task
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制任务
- en: 'This task is used to copy file(s) or directories from one location to the other:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务用于将文件（或目录）从一个位置复制到另一个位置：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In `copyTask`, we have configured the `from` location and `into` location, and
    have also added the condition to include only `employees.xml`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `copyTask` 中，我们已配置了 `from` 位置和 `into` 位置，并添加了仅包含 `employees.xml` 的条件。
- en: The Rename Task
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名任务
- en: 'This task is an extended version of the copy task, which is used to rename
    files or directories:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务是一个扩展的复制任务，用于重命名文件或目录：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `copyWithRename` task, an additional `rename` closure was added.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `copyWithRename` 任务中，添加了一个额外的 `rename` 闭包。
- en: The Zip task
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zip 任务
- en: 'This task is used to zip a group of file(s) or directories and copy the zip
    to the destination directory:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务用于将一组文件（或目录）压缩并复制到目标目录：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `ziptask` task, another `destinationDir` configuration was added. You
    can refer to the online documentation for more a detailed API for these tasks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ziptask` 任务中，添加了另一个 `destinationDir` 配置。你可以参考在线文档以获取这些任务的更详细 API。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that here we have not mentioned any actions for these tasks. Tasks themselves
    know what to do. We only need to configure the tasks to define them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们没有提到这些任务的动作。任务本身知道该做什么。我们只需要配置任务来定义它们。
- en: Most of the time, you use tasks that are part of plugins. Mostly, a plugin is
    a group of tasks bound together for some specific functionality. For example;
    we use the `java` plugin to build the Java project, the `war` plugin to create
    web archives, and so on. When you apply the `java` plugin to a build script, Java
    tasks are automatically included. We will discuss about plugins in detail in [Chapter
    4](ch04.html "Chapter 4. Plugin Management"), *Plugin Management*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你使用的是插件的一部分任务。通常，插件是一组绑定在一起以实现某些特定功能的任务集合。例如；我们使用 `java` 插件来构建 Java 项目，使用
    `war` 插件来创建 Web 存档，等等。当你将 `java` 插件应用到构建脚本中时，Java 任务会自动包含在内。我们将在第 4 章[插件管理](ch04.html
    "Chapter 4. Plugin Management")中详细讨论插件。
- en: 'To execute the Java tasks, we do not need to mention even the configurations.
    For these tasks, Gradle applies conventions, that is, the default configuration.
    If a project follows a certain convention, it can directly execute these tasks
    without any configurations. If not, it should define its own configurations. To
    add the `java` plugin to a `build` file, just add the following line of code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 Java 任务，我们甚至不需要提及配置。对于这些任务，Gradle 应用约定，即默认配置。如果一个项目遵循某种约定，它可以直接执行这些任务而无需任何配置。如果不遵循，它应该定义自己的配置。要将
    `java` 插件添加到 `build` 文件中，只需添加以下代码行：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By default, the `java` plugin assumes that the project's source files are located
    at `src/main/java`. If the source files are present in this directory, you can
    execute the `gradle compileJava` or `gradle build` task without any configuration.
    We will discuss more on Java plugins and tasks in the next chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`java` 插件假定项目的源文件位于 `src/main/java`。如果源文件存在于该目录中，你可以执行 `gradle compileJava`
    或 `gradle build` 任务而无需任何配置。我们将在下一章中更多讨论 Java 插件和任务。
- en: Until now in this chapter, we have got some idea about how to create tasks and
    how to use Gradle's in-built tasks. In the next section, we will explore how to
    create custom tasks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经对如何创建任务以及如何使用 Gradle 的内置任务有了一些了解。在下一节中，我们将探讨如何创建自定义任务。
- en: Custom tasks
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义任务
- en: Gradle supports a variety of tasks for build automation, either from Gradle's
    in-house plugins or from third-party plugins. As we know the software adage, change
    is the only constant thing in software; the requirements and complexity change
    over the time. Many a times we come across different automation requirements for
    which no task or plugin is available in Gradle. In such cases, you can extend
    Gradle by adding custom tasks to the build.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'Gradle 支持各种用于构建自动化的任务，无论是来自 Gradle 内置插件还是第三方插件。正如我们所知的软件谚语，变化是软件中唯一不变的事物；需求和复杂性会随着时间的推移而变化。很多时候，我们会遇到不同的自动化需求，而在
    Gradle 中没有可用的任务或插件。在这种情况下，你可以通过添加自定义任务来扩展 Gradle。 '
- en: A custom task is an enhanced task, which you add to Gradle to fulfill custom
    requirements. It can have input, output, configurations and more. Its scope is
    not only limited to the `build` file where it is defined; it can be reused in
    other projects by adding custom task JAR in the classpath. You can write custom
    tasks in Groovy, Java, and Scala. In this section, we will create custom task
    examples in Groovy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义任务是一个增强的任务，你将其添加到 Gradle 中以满足自定义需求。它可以具有输入、输出、配置等。它的作用域不仅限于定义它的 `build` 文件；通过在类路径中添加自定义任务
    JAR，它可以在其他项目中重用。你可以用 Groovy、Java 和 Scala 编写自定义任务。在本节中，我们将创建 Groovy 的自定义任务示例。
- en: 'Gradle provides different ways to add custom tasks in the build script:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 提供了不同的方法在构建脚本中添加自定义任务：
- en: The `build` file
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build` 文件'
- en: The `buildSrc` directory inside the project directory
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目目录内的 `buildSrc` 目录
- en: Create a standalone Groovy project
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个独立的 Groovy 项目
- en: A custom task is a Java or Groovy class that extends from `DefaultTask`. We
    can use the `@TaskAction` annotation to define the task actions. You can add multiple
    actions in a single task. They will execute in the order they are defined. Let's
    start with a simple custom task in the `build` file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义任务是一个扩展自 `DefaultTask` 的 Java 或 Groovy 类。我们可以使用 `@TaskAction` 注解来定义任务操作。你可以在单个任务中添加多个操作。它们将按照定义的顺序执行。让我们从
    `build` 文件中的一个简单的自定义任务开始。
- en: 'Consider the file located at `Chapter3/Customtask/build.gradle`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑位于 `Chapter3/Customtask/build.gradle` 的文件：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the following file will be:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件的输出将是：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, we have defined a custom task type, `SampleTask`.
    We have added two action methods `action1()` and `action2()`. You can add more
    actions as per the requirement. We have added two task variables `systemName`
    and `systemGroup` with some default values. We can reinitialize these variables
    in the project scope again while configuring the task (hello). Gradle also provides
    the flexibility to add more actions to a task with the help of the `doFirst` and
    `doLast` closures like any other task.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个自定义任务类型`SampleTask`。我们添加了两个操作方法`action1()`和`action2()`。您可以按需添加更多操作。我们添加了两个任务变量`systemName`和`systemGroup`，并赋予了一些默认值。我们可以在配置任务（hello）时再次在项目范围内重新初始化这些变量。Gradle还提供了使用`doFirst`和`doLast`闭包向任务添加更多操作的灵活性，就像其他任务一样。
- en: 'Once a task type is defined, you can create a task by using `task <taskname>(type:
    <TaskType>)`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦定义了任务类型，您就可以使用`task <taskname>(type: <TaskType>)`创建一个任务。'
- en: You can configure the task in configuration closure either while declaring the
    task or as a separate closure, as mentioned in the preceding file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在配置闭包中配置任务，无论是声明任务时还是作为一个单独的闭包，如前述文件中所述。
- en: Using buildSrc
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用buildSrc
- en: If you want to keep the custom task code separate from the build file, but you
    do not want to create a separate project for it, you can achieve this by adding
    the custom task in the `buildSrc` directory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将自定义任务代码与构建文件分开，但又不想为它创建一个单独的项目，您可以通过在`buildSrc`目录中添加自定义任务来实现这一点。
- en: 'Create a `buildSrc` directory in the project base directory and create the
    following mentioned folder hierarchy: `buildSrc/src/main/groovy/ch3/SampleTask.groovy`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目基本目录中创建一个`buildSrc`目录，并创建以下提到的文件夹层次结构：`buildSrc/src/main/groovy/ch3/SampleTask.groovy`。
- en: 'Move the preceding `SampleTask` class in the file. You also need to import
    two packages: `org.gradle.api.DefaultTask` and `org.gradle.api.tasks.TaskAction`.
    Now, the `build` file is left with the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的`SampleTask`类移动到文件中。您还需要导入两个包：`org.gradle.api.DefaultTask`和`org.gradle.api.tasks.TaskAction`。现在，`build`文件剩下以下代码片段：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On executing the `hello` task, you will find the same output that was displayed
    earlier.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`hello`任务时，您将找到之前显示的相同输出。
- en: After execution, you will find the following folder structure in the project.
    Note that you do not need to compile the `SampleTask` class. All the required
    steps would be performed by Gradle. It will compile the classes, create JAR, and
    will automatically add the required class to the build class path. You can just
    define the task and execute it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您将在项目中找到以下文件夹结构。请注意，您不需要编译`SampleTask`类。所有必要的步骤将由Gradle执行。它将编译类，创建JAR文件，并将所需的类自动添加到构建类路径中。您只需定义任务并执行它。
- en: '![Using buildSrc](img/B02000_03_03.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用buildSrc](img/B02000_03_03.jpg)'
- en: Figure 3.3
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3
- en: The limitation is that the `SampleTask` task is only available in the current
    project and its subprojects only. You cannot use this task in other projects.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 限制是`SampleTask`任务仅在当前项目和其子项目中可用。您不能在其他项目中使用此任务。
- en: The standalone task
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立的任务
- en: 'To overcome the limitations of the `buildSrc` way of creating custom tasks,
    you need to create an independent Groovy project. Move the `SampleTask` class
    in a new project (`SampleTaskProj`), and then compile and package the project.
    You can even use Gradle to build this Groovy project. Just add `build.gradle`
    with the following statements to the `SampleTaskProj` project:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服创建自定义任务时`buildSrc`方式的限制，您需要创建一个独立的Groovy项目。将`SampleTask`类移动到新项目（`SampleTaskProj`）中，然后编译和打包项目。您甚至可以使用Gradle来构建此Groovy项目。只需将以下语句的`build.gradle`文件添加到`SampleTaskProj`项目中：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you are creating the project in Eclipse, you can run the following command
    to generate the Eclipse classpath:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Eclipse中创建项目，可以使用以下命令生成Eclipse类路径：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, execute the `gradle build` command to build the project. A JAR file will
    be created in the build directory. To use the tasks, in the build file (think
    of it as a new `build.gradle` file in another project), we need to reference the
    JAR file path in the **repositories** closure.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行`gradle build`命令来构建项目。在构建目录中将创建一个JAR文件。要使用任务，在构建文件（将其视为另一个项目中的新`build.gradle`文件）中，我们需要在**repositories**闭包中引用JAR文件路径。
- en: 'Create a new project and update the `build.gradle` file with the following
    content:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目，并更新`build.gradle`文件，内容如下：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Execute the `hello` task again and you will find the same output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行`hello`任务，您将找到相同的输出：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed Gradle task in detail. We learned how to
    create simple tasks in Gradle and add actions to it. Along with it, we looked
    into task dependencies. We also looked into strict ordering of tasks if needed,
    using `mustRunAfter` and `FinalyzedBy`. We also discussed incremental build feature
    in Gradle, which improves build execution time. One of the important extensions
    is the custom task. We also saw how to create custom tasks and reuse the same
    task across different projects.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了Gradle任务。我们学习了如何在Gradle中创建简单任务并向其添加操作。同时，我们还探讨了任务依赖关系。如果需要，我们还研究了任务的严格排序，使用`mustRunAfter`和`FinalyzedBy`。我们还讨论了Gradle中的增量构建功能，该功能可以提高构建执行时间。其中一个重要的扩展是自定义任务。我们还看到了如何创建自定义任务以及如何在不同的项目中重用相同的任务。
- en: As mentioned, a task could fulfill a simple build requirement. However, requirements
    keep growing and we need more number of tasks. It is also required to group certain
    related tasks to perform a specific behavior. This grouping of tasks is done in
    a plugin. A plugin is a group of different tasks bonded together. So, our next
    chapter is dedicated to plugin management. We will discuss how to bind tasks to
    a plugin and how to utilize plugins to enhance build capabilities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个任务可以满足简单的构建需求。然而，需求不断增长，我们需要更多的任务。还需要将某些相关任务分组以执行特定行为。这种任务的分组是在插件中完成的。插件是一组不同任务结合在一起。因此，我们下一章将专门讨论插件管理。我们将讨论如何将任务绑定到插件以及如何利用插件来增强构建能力。
