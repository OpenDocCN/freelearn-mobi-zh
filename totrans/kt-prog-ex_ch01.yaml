- en: The Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Learning a programming language is a daunting experience for many people, and
    not one that most individuals generally choose to undertake. As you have chosen
    to pick up this book, I assume that you have an interest in learning the Kotlin
    programming language and perhaps even becoming an expert at it someday. As a consequence,
    permit me to congratulate you on taking a bold step toward learning this language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，学习编程语言是一种令人畏惧的经历，大多数人通常不会选择去承担这样的任务。既然你已经选择了阅读这本书，我假设你对学习 Kotlin 编程语言感兴趣，也许有一天你甚至会成为这个领域的专家。因此，请允许我祝贺你勇敢地迈出了学习这门语言的第一步。
- en: Regardless of the problem domain that you may wish to build solutions for, be
    it application development, networking, or distributed systems, Kotlin is a good
    choice for the development of systems to achieve the required solutions. In other
    words, a developer can't go wrong with learning Kotlin. At this point, a proper
    introduction to the Kotlin language is required.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你希望为哪个问题域构建解决方案，无论是应用开发、网络还是分布式系统，Kotlin 都是开发实现所需解决方案的系统的一个好选择。换句话说，开发者学习
    Kotlin 是不会出错的。在这个时候，对 Kotlin 语言进行适当的介绍是必要的。
- en: Kotlin is a strongly-typed, object-oriented language that runs on the **Java
    Virtual Machine** (**JVM**) and can be used to develop applications in numerous
    problem domains. In addition to running on the JVM, Kotlin can be compiled to
    JavaScript, and as such, is an equally strong choice for developing client-side
    web applications. Kotlin can also be compiled directly into native binaries that
    run on systems without a virtual machine via Kotlin/Native. The Kotlin programming
    language was primarily developed by JetBrains – a company based in Saint Petersburg,
    Russia. The developers at JetBrains are the current maintainers of the language.
    Kotlin was named after Kotlin island – an island near Saint Petersburg.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种强类型、面向对象的编程语言，它在 **Java 虚拟机**（**JVM**）上运行，并且可以用于在众多问题域中开发应用程序。除了在
    JVM 上运行外，Kotlin 还可以编译成 JavaScript，因此它也是开发客户端网络应用程序的一个同样强大的选择。Kotlin 还可以通过 Kotlin/Native
    直接编译成在无虚拟机系统上运行的本地二进制文件。Kotlin 编程语言主要是由位于俄罗斯圣彼得堡的 JetBrains 公司开发的。JetBrains 的开发者是当前的语言维护者。Kotlin
    以 Kotlin 岛命名——一个位于圣彼得堡附近的小岛。
- en: Kotlin was designed to be used to develop industrial-strength software in many
    domains, but has seen the majority of its use come from the Android ecosystem.
    At the time of writing, Kotlin is one of the three languages that have been declared
    by Google as an official language for Android. Kotlin is syntactically similar
    to Java. As a matter of fact, it was designed to be a better alternative to Java.
    As a consequence, there are numerous significant advantages to using Kotlin instead
    of Java in software development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 被设计用来在许多领域开发工业级软件，但它的主要用途来自 Android 生态系统。在撰写本文时，Kotlin 是 Google 宣布的三种官方
    Android 语言之一。Kotlin 的语法与 Java 类似。事实上，它被设计成 Java 的更好替代品。因此，在软件开发中使用 Kotlin 而不是
    Java 有许多显著的优点。
- en: 'In this chapter, you will learn the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: The installation of Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 的安装
- en: The fundamentals of the Kotlin programming language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 编程语言的基础知识
- en: Installing and setting up Android Studio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和设置 Android Studio
- en: Gradle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle
- en: The fundamentals of the web
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络基础知识
- en: Getting started with Kotlin
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习 Kotlin
- en: In order to develop the Kotlin program, you will first need to install the **Java
    Runtime Environment** (**JRE**) on your computer. The JRE can be downloaded prepackaged
    along with a **Java Development Kit** (**JDK**). For the sake of this installation,
    we will be using the JDK.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发 Kotlin 程序，你首先需要在你的计算机上安装 **Java 运行时环境**（**JRE**）。JRE 可以与 **Java 开发工具包**（**JDK**）一起预包装下载。为了安装起见，我们将使用
    JDK。
- en: 'The easiest way to install a JDK on a computer is to utilize one of the JDK
    installers made available by Oracle (the owners of Java). There are different
    installers available for all major operating systems. Releases of the JDK can
    be downloaded from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上安装 JDK 最简单的方法是使用 Oracle（Java 的所有者）提供的 JDK 安装程序之一。所有主要操作系统都有不同的安装程序可用。可以从
    [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)
    下载 JDK 的版本：
- en: '![](img/d224f6f2-e4f0-4242-a2b8-9a4e2cd47652.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d224f6f2-e4f0-4242-a2b8-9a4e2cd47652.jpg)'
- en: Java SE web page
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 网页
- en: 'Clicking on the JDK download button takes you to a web page where you can download
    the appropriate JDK for your operating system and CPU architecture. Download a
    JDK suitable for your computer and continue to the next section:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 JDK 下载按钮将带您到一个网页，您可以下载适合您操作系统和 CPU 架构的 JDK。下载适合您计算机的 JDK 并继续到下一部分：
- en: '![](img/35879d00-e05f-4b19-a5ff-07ef3f82b0fd.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35879d00-e05f-4b19-a5ff-07ef3f82b0fd.jpg)'
- en: JDK download page
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 下载页面
- en: JDK installation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 安装
- en: In order to install the JDK on your computer, check out the necessary installation
    information from the following sections, based on your operating system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的计算机上安装 JDK，请根据您的操作系统从以下部分检查必要的安装信息。
- en: Installation on Windows
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 上的安装
- en: 'The JDK can be installed on Windows in four easy steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 JDK 可以通过四个简单的步骤完成：
- en: Double-click the downloaded installation file to launch the JDK installer.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击下载的安装文件以启动 JDK 安装程序。
- en: Click the Next button in the welcome window. This action will lead you to a
    window where you can select the components you want to install. Leave the selection
    at the default and click Next.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在欢迎窗口中点击“下一步”按钮。此操作将带您到一个可以选择要安装的组件的窗口。保持默认选择并点击“下一步”。
- en: The following window prompts the selection of the destination folder for the
    installation. For now, leave this folder as the default (also take note of the
    location of this folder, as you will need it in a later step). Click Next.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下窗口提示选择安装目标文件夹。目前，请保持此文件夹为默认设置（同时注意此文件夹的位置，您将在后续步骤中需要它）。点击“下一步”。
- en: Follow the instructions in the upcoming windows and click Next when necessary.
    You may be asked for your administrator's password, enter it when necessary. Java
    will be installed on your computer.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照即将出现的窗口中的说明操作，并在必要时点击“下一步”。您可能需要输入管理员密码，如有需要请输入。Java 将被安装到您的计算机上。
- en: 'After the JDK installation has concluded, you will need to set the `JAVA_HOME`
    environment variable on your computer. To do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 安装完成后，您需要在您的计算机上设置 `JAVA_HOME` 环境变量。为此：
- en: Open your Control Panel.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的控制面板。
- en: Select Edit environment variable.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“编辑环境变量”。
- en: In the window that has opened, click the New button. You will be prompted to
    add a new environment variable.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，点击“新建”按钮。您将被提示添加一个新的环境变量。
- en: Input `JAVA_HOME` as the variable name and enter the installation path of the
    JDK as the variable value.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量名输入为 `JAVA_HOME` 并输入 JDK 的安装路径作为变量值。
- en: Click `OK` once to add the environment variable.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”一次以添加环境变量。
- en: Installation on macOS
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS 上的安装
- en: 'In order to install the JDK on macOS, perform the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 macOS 上安装 JDK，请执行以下步骤：
- en: Download your desired JDK `.dmg` file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载您所需的 JDK `.dmg` 文件。
- en: Locate the downloaded `.dmg` file and double-click it.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位下载的 `.dmg` 文件并双击它。
- en: A finder window containing the JDK package icon is opened. Double-click this
    icon to launch the installer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个包含 JDK 包图标的查找器窗口。双击此图标以启动安装程序。
- en: Click Continue on the introduction window.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在介绍窗口中点击“继续”。
- en: Click Install on the installation window that appears.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的安装窗口中点击“安装”。
- en: Enter the administrator login and password when required and click Install Software.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当需要时输入管理员登录名和密码，然后点击“安装软件”。
- en: The JDK will be installed and a confirmation window displayed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 将被安装，并显示一个确认窗口。
- en: Installation on Linux
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 上的安装
- en: 'Installation of the JDK on Linux is easy and straightforward using `apt-get`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `apt-get` 在 Linux 上安装 JDK 很简单且直接：
- en: 'Update the package index of your computer. From your terminal, run:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的计算机的软件包索引。从您的终端运行：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check whether Java is already installed by running the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查 Java 是否已经安装：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You''ll know Java is installed if the version information for a Java install
    on your system is printed. If no version is currently installed, run:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果系统上 Java 安装的版本信息被打印出来，您就会知道 Java 已经安装。如果没有安装版本，请运行：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's it! The JDK will be installed on your computer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！JDK 将被安装到您的计算机上。
- en: Compiling Kotlin programs
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Kotlin 程序
- en: Now that we have the JDK set up and ready for action, we need to install a means
    to actually compile and run our Kotlin programs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 JDK 并准备使用，我们需要安装一种实际编译和运行我们的 Kotlin 程序的方法。
- en: Kotlin programs can be either compiled directly with the Kotlin command-line
    compiler or built and run with the **Integrated Development Environment** (**IDE**).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 程序可以直接使用 Kotlin 命令行编译器编译，或者使用**集成开发环境**（**IDE**）构建和运行。
- en: Working with the command-line compiler
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行编译器
- en: The command-line compiler can be installed via Homebrew, SDKMAN!, and MacPorts.
    Another option for setting up the command-line compiler is by manual installation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行编译器可以通过 Homebrew、SDKMAN! 和 MacPorts 进行安装。设置命令行编译器的另一种选项是手动安装。
- en: Installing the command-line compiler on macOS
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 macOS 上安装命令行编译器
- en: The Kotlin command-line compiler can be installed on macOS in various ways.
    The two most common methods for its installation on macOS are via Homebrew and
    MacPorts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 命令行编译器可以在 macOS 上以多种方式安装。在 macOS 上安装它的两种最常见方法是使用 Homebrew 和 MacPorts。
- en: Homebrew
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Homebrew
- en: 'Homebrew is a package manager for the macOS systems. It is used extensively
    for the installation of packages required for building software projects. To install
    Homebrew, locate your macOS terminal and run:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew 是 macOS 系统的软件包管理器。它被广泛用于安装构建软件项目所需的软件包。要安装 Homebrew，定位您的 macOS 终端并运行：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will have to wait a few seconds for the download and installation of Homebrew.
    After installation, check to see whether Homebrew is working properly by running
    the following command in your terminal:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要等待几秒钟以完成 Homebrew 的下载和安装。安装完成后，通过在终端中运行以下命令来检查 Homebrew 是否正常工作：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the current version of Homebrew installed on your computer is printed out
    in the terminal, Homebrew has been successfully installed on your computer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机上安装的 Homebrew 版本在终端中打印出来，则表示 Homebrew 已成功安装在您的计算机上。
- en: 'After properly installing Homebrew, locate your terminal and execute the following
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确安装 Homebrew 后，定位您的终端并执行以下命令：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Wait for the installation to finish, after which you are ready to compile Kotlin
    programs with the command-line compiler.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 等待安装完成，之后您就可以使用命令行编译器编译 Kotlin 程序了。
- en: MacPorts
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MacPorts
- en: 'Similar to HomeBrew, MacPorts is a package manager for macOS. Installing MacPorts
    is easy. It can be installed on a system by:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HomeBrew 类似，MacPorts 是 macOS 的软件包管理器。安装 MacPorts 很简单。可以通过以下方式在系统上安装：
- en: Installing Xcode and the Xcode command-line tools.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Xcode 和 Xcode 命令行工具。
- en: Agreeing to the Xcode license. This can be done in the terminal by running `xcodebuild
    -license`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同意 Xcode 许可协议。这可以通过在终端中运行 `xcodebuild -license` 来完成。
- en: Installing the required version of MacPorts.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所需版本的 MacPorts。
- en: MacPort versions can be downloaded from [https://www.macports.org/install.php](https://www.macports.org/install.php).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MacPort 版本可以从 [https://www.macports.org/install.php](https://www.macports.org/install.php)
    下载。
- en: 'Once downloaded, locate your terminal and run `port install kotlin` as the
    superuser:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，定位您的终端并以超级用户身份运行 `port install kotlin` 命令：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Installing the command-line compiler on Linux
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上安装命令行编译器
- en: Linux users can easily install the command-line compiler for Kotlin with SDKMAN!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 用户可以使用 SDKMAN! 轻松安装 Kotlin 的命令行编译器
- en: SDKMAN!
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDKMAN!
- en: 'This can be used to install packages on Unix-based systems such as Linux and
    its various distributions, for example, Fedora and Solaris. SDKMAN! can be installed
    in three easy steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于在基于 Unix 的系统（如 Linux 及其各种发行版，例如 Fedora 和 Solaris）上安装软件包。SDKMAN! 可以通过以下三个简单步骤进行安装：
- en: 'Download the software on to your system with `curl`. Locate your terminal and
    run:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `curl` 将软件下载到您的系统上。定位您的终端并运行：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After you run the preceding command, a set of instructions will come up in
    your terminal. Follow these instructions to complete the installation. Upon completing
    the instructions, run:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行上述命令后，您的终端将出现一系列说明。按照这些说明完成安装。完成说明后，运行：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the version number of SDKMAN! just installed is printed in your terminal
    window, the installation was successful.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刚刚安装的 SDKMAN! 的版本号在您的终端窗口中打印出来，则表示安装成功。
- en: 'Now that we have SDKMAN! successfully installed on our system, we can install
    the command-line compiler by running:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功在我们的系统上安装了 SDKMAN!，我们可以通过运行以下命令来安装命令行编译器：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Installing the command-line compiler on Windows
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装命令行编译器
- en: 'In order to use the Kotlin command-line compilers on Windows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Windows 上使用 Kotlin 命令行编译器：
- en: Download a GitHub release of the software from [https://github.com/JetBrains/kotlin/releases/tag/v1.2.30](https://github.com/JetBrains/kotlin/releases/tag/v1.2.30)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/JetBrains/kotlin/releases/tag/v1.2.30](https://github.com/JetBrains/kotlin/releases/tag/v1.2.30)
    下载软件的 GitHub 发布版
- en: Locate and unzip the downloaded file
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并解压下载的文件
- en: Open the extracted `kotlinc\bin` folder
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解压后的 `kotlinc\bin` 文件夹
- en: Start the command prompt with the folder path
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件夹路径启动命令提示符
- en: You can now make use of the Kotlin compiler from your command line.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从命令行使用 Kotlin 编译器。
- en: Running your first Kotlin program
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您的第一个 Kotlin 程序
- en: Now that we have our command-line compiler set up, let's try it out with a simple
    Kotlin program. Navigate to your home directory and create a new file named `Hello.kt`.
    All Kotlin files have a `.kt` extension appended to the end of the filename.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了命令行编译器，让我们用一个简单的 Kotlin 程序来试试。导航到您的家目录，并创建一个名为 `Hello.kt` 的新文件。所有 Kotlin
    文件都会在文件名末尾附加 `.kt` 扩展名。
- en: 'Open the file you just created in a text editor of your choosing and input
    the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您选择的文本编辑器打开您刚刚创建的文件，并输入以下内容：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save the changes made to the program file. After the changes have been saved,
    open your terminal window and input the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 保存对程序文件的更改。更改保存后，打开您的终端窗口并输入以下命令：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command compiles your program into an executable, `hello.jar`.
    The `-include-` runtime flag is used to specify that you want the compiled JAR
    to be self-contained. By adding this flag to the command, the Kotlin runtime library
    will be included in your JAR. The `-d` flag specifies that, in this case, we want
    the output of the compiler to be called.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将您的程序编译成可执行文件 `hello.jar`。`-include-` 运行时标志用于指定您希望编译的 JAR 文件是自包含的。通过向命令中添加此标志，Kotlin
    运行时库将被包含在您的 JAR 中。`-d` 标志指定在这种情况下，我们希望编译器的输出被调用。
- en: 'Now that we have compiled our first Kotlin program, we need to run it—after
    all, there''s no fun in writing programs if they can''t be run later on. Open
    your terminal, if it''s not already open, and navigate to the directory where
    the JAR was saved to (in this case, the home directory).  To run the compiled
    JAR, perform the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编译了我们的第一个 Kotlin 程序，我们需要运行它——毕竟，如果程序不能在以后运行，编写程序就没有乐趣了。打开您的终端，如果尚未打开，请导航到保存
    JAR 文件的目录（在本例中为家目录）。要运行编译后的 JAR 文件，请执行以下操作：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After running the preceding command, you should see `Hello world!` printed on
    your display. Congratulations, you have just written your first Kotlin program!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，您应该在显示屏上看到打印出 `Hello world!`。恭喜您，您刚刚编写了您的第一个 Kotlin 程序！
- en: Writing scripts with Kotlin
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin 编写脚本
- en: As previously stated, Kotlin can be used to write scripts. Scripts are programs
    that are written for specific runtime environments for the common purpose of automating
    the execution of tasks. In Kotlin, scripts have the `.kts` file extension appended
    to the file name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kotlin 可以用来编写脚本。脚本是为特定运行时环境编写的程序，其通用目的是自动化任务的执行。在 Kotlin 中，脚本文件名会附加 `.kts`
    扩展名。
- en: Writing a Kotlin script is similar to writing a Kotlin program. In fact, a script
    written in Kotlin is exactly like a regular Kotlin program! The only significant
    difference between a Kotlin script and regular Kotlin program is the absence of
    a main function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Kotlin 脚本与编写 Kotlin 程序类似。实际上，用 Kotlin 编写的脚本与常规 Kotlin 程序完全相同！Kotlin 脚本与常规
    Kotlin 程序之间唯一的显著区别是缺少主函数。
- en: 'Create a file in a directory of your choosing and name it `NumberSum.kts`.
    Open the file and input the following program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择的目录中创建一个名为 `NumberSum.kts` 的文件。打开文件并输入以下程序：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you''ve most likely guessed, the preceding script will print the sum of
    `1` and `2` to the standard system output. Save the changes to the file and run the
    script:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，前面的脚本将打印 `1` 和 `2` 的和到标准系统输出。保存文件更改并运行脚本：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A significant thing to take note of is that a Kotlin script does not need to
    be compiled.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，Kotlin 脚本不需要编译。
- en: Using the REPL
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REPL
- en: REPL is an acronym that stands for **Read–Eval–Print Loop**. An REPL is an interactive
    shell environment in which programs can be executed with immediate results given.
    The interactive shell environment can be invoked by running the `kotlinc` command
    without any arguments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 是一个代表 **读取-评估-打印循环** 的缩写。REPL 是一个交互式外壳环境，在其中可以执行程序并立即获得结果。可以通过运行不带任何参数的
    `kotlinc` 命令来调用交互式外壳环境。
- en: The Kotlin REPL can be started by running `kotlinc` in your terminal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在终端中运行 `kotlinc` 来启动 Kotlin REPL。
- en: 'If the REPL is successfully started, a welcome message will be printed in your
    terminal followed by `>>>` on the next line, alerting us that the REPL is awaiting
    input. Now you can type in code within the terminal, as you would in any text
    editor, and get immediate feedback from the REPL. This is demonstrated in the
    following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果REPL成功启动，您的终端将打印一条欢迎信息，然后是下一行的`>>>`，提示我们REPL正在等待输入。现在您可以在终端中输入代码，就像在任何文本编辑器中一样，并立即从REPL获得反馈。这在上面的屏幕截图中得到了演示：
- en: '![](img/625fb705-74eb-4221-b051-2b2faea54a20.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/625fb705-74eb-4221-b051-2b2faea54a20.jpg)'
- en: Kotlin REPL
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin REPL
- en: In the preceding screenshot, the `1` and `2` integers are assigned to `x` and
    `y`, respectively. The sum of `x` and `y` is stored in a new `z` variable and
    the value held by `z` is printed to the display with the `print()` function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，整数`1`和`2`分别赋值给`x`和`y`。`x`和`y`的和存储在新的`z`变量中，`z`的值通过`print()`函数打印到显示。
- en: Working with an IDE
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IDE进行工作
- en: Writing programs with the command line has its uses, but in most cases, it is
    better to use software built specifically for the purpose of empowering developers
    to write programs. This is especially true in cases where a large project is being
    worked on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行编写程序有其用途，但在大多数情况下，使用专门为使开发者能够编写程序而构建的软件会更好。这在处理大型项目时尤其如此。
- en: An IDE is a computer application that hosts a collection of tools and utilities
    for computer programmers for software development. There are a number of IDEs
    that can be used for Kotlin development. Out of these IDEs, the one with the most
    comprehensive set of features for the purpose of developing Kotlin applications
    is IntelliJ IDEA. As IntelliJ IDEA is built by the creators of Kotlin, there are
    numerous advantages in using it over other IDEs, such as an unparalleled feature
    set of tools for writing Kotlin programs, as well as timely updates that cater
    to the newest advancements and additions to the Kotlin programming language.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: IDE是一种计算机应用程序，它为程序员提供了一系列工具和实用程序，用于软件开发。有多个IDE可以用于Kotlin开发。在这些IDE中，IntelliJ
    IDEA是为开发Kotlin应用程序而设计的功能最全面的IDE。由于IntelliJ IDEA是由Kotlin的创造者开发的，因此与其他IDE相比，使用它有许多优势，例如编写Kotlin程序的无与伦比的工具集，以及针对Kotlin编程语言最新进步和新增功能的及时更新。
- en: Installing IntelliJ IDEA
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装IntelliJ IDEA
- en: 'IntelliJ IDEA can be downloaded for Windows, macOS, and Linux directly from
    JetBrains'' website: [https://www.jetbrains.com/idea/download](https://www.jetbrains.com/idea/download).
    On the web page, you are presented with two available editions for download: a
    paid Ultimate edition and a free Community edition. The Community edition is sufficient
    if you wish to run the programs in this chapter. Select the edition you wish to
    download:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA可以从JetBrains的网站直接下载：[https://www.jetbrains.com/idea/download](https://www.jetbrains.com/idea/download)。在网页上，您可以看到两个可供下载的版本：付费的终极版和免费的社区版。如果您想运行本章的程序，社区版就足够了。选择您要下载的版本：
- en: '![](img/85f67659-2d29-4b8a-b314-821877ce1cb3.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85f67659-2d29-4b8a-b314-821877ce1cb3.jpg)'
- en: IntelliJ IDEA download page
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA下载页面
- en: Once the download is complete, double-click on the downloaded file and install
    it on your operating system as you would any program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，双击下载的文件，并将其安装到您的操作系统上，就像安装任何程序一样。
- en: Setting up a Kotlin project with IntelliJ
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IntelliJ设置Kotlin项目
- en: 'The process of setting up a Kotlin project with IntelliJ is straightforward:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IntelliJ设置Kotlin项目的流程很简单：
- en: Start the IntelliJ IDE application.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动IntelliJ IDE应用程序。
- en: Click Create New Project.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建新项目。
- en: Select Java from the available project options on the left-hand side of the
    newly opened window.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新打开窗口的左侧选择可用的项目选项中的Java。
- en: Add Kotlin/JVM as an additional library to the project.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Kotlin/JVM作为附加库添加到项目中。
- en: Pick a project SDK from the drop-down list in the window.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的下拉列表中选择一个项目SDK。
- en: Click Next.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步。
- en: Select a template if you wish to use one, then continue to the next screen.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想使用模板，请选择一个，然后继续到下一屏幕。
- en: Provide a project name in the input field provided. Name the project `HelloWorld`
    for now.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的输入字段中提供项目名称。现在将项目命名为`HelloWorld`。
- en: Set a project location in the input field.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入字段中设置项目位置。
- en: Click Finish.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: 'Your project will be created and you will be presented with the IDE window:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目将被创建，您将看到IDE窗口：
- en: '![](img/c421ca1c-4301-49fc-9cd8-b7b503f01e9d.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c421ca1c-4301-49fc-9cd8-b7b503f01e9d.png)'
- en: To the left of the window, you will immediately see the project view. This view
    shows the logical structure of your project files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的左侧，你将立即看到项目视图。这个视图显示了你的项目文件的逻辑结构。
- en: 'Two folders are present. These are:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个文件夹存在。这些是：
- en: '`.idea`: This contains IntelliJ''s project-specific settings files.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.idea`：这包含 IntelliJ 的项目特定设置文件。'
- en: '`src`: This is the source folder of your project. You will place your program
    files in this folder.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：这是你的项目源文件夹。你将在这个文件夹中放置你的程序文件。'
- en: 'Now that the project is set up, we will write a simple program. Add a file
    named `hello.kt` to the source folder (right-click the `src` folder, select New
    | Kotlin File/Class, and name the file `hello`). Copy and paste the following
    code into the file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经设置好了，我们将编写一个简单的程序。在源文件夹中添加一个名为 `hello.kt` 的文件（右键点击 `src` 文件夹，选择 New |
    Kotlin File/Class，并将文件命名为 `hello`）。将以下代码复制并粘贴到文件中：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To run the program, click the Kotlin logo adjacent to the main function and
    select Run HelloKt:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '运行程序时，点击主函数旁边相邻的 Kotlin 图标，然后选择运行 HelloKt:'
- en: '![](img/ae14ae26-e575-477c-a0ac-f3b59cb44870.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae14ae26-e575-477c-a0ac-f3b59cb44870.jpg)'
- en: The project will be built and run, after which, `Hello world!` will be printed
    to the standard system output.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 项目构建并运行后，`Hello world!` 将被打印到标准系统输出。
- en: The fundamentals of the Kotlin programming language
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 编程语言的基础
- en: Now that we have set up our development environment and our IDE of choice, it
    is time to explore Kotlin. We will start by diving into the basics of the language
    and progress into more advanced topics, such as **object-oriented programming**
    (**OOP**).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的开发环境和所选择的 IDE，是时候探索 Kotlin 了。我们将从深入了解语言的基础开始，然后进入更高级的主题，例如 **面向对象编程**
    (**OOP**)。
- en: Kotlin basics
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 基础
- en: In this section, we will explore the basics of Kotlin—the building blocks, if
    you will. We will start by discussing variables.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Kotlin 的基础知识——如果你愿意，可以说是构建块。我们将从讨论变量开始。
- en: Variables
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'A variable is an identifier for a memory location that holds a value. A simpler
    way to describe a variable is an identifier that holds a value. Consider the following
    program:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个标识符，用于表示一个存储值的内存位置。更简单地说，变量就是一个持有值的标识符。考虑以下程序：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding `x` is a variable and the value it holds is `1`. More specifically,
    `x` is an integer variable. The `x` is referred to as an integer variable because
    `x` has been defined to have the `Int` data type. As such, the `x` variable can
    only hold an integer value. To be more accurate, we say that `x` is an instance
    of the `Int` class. At this point, you must be wondering what the words instance
    and class mean in this context. All will be revealed in due time. For now, let's
    focus on the topic of variables.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `x` 是一个变量，它持有的值是 `1`。更具体地说，`x` 是一个整型变量。`x` 被称为整型变量，因为 `x` 被定义为具有 `Int` 数据类型。因此，`x`
    变量只能持有整数值。更准确地说，我们可以说 `x` 是 `Int` 类的一个实例。此时，你一定想知道在这个上下文中“实例”和“类”这两个词的含义。所有答案都将适时揭晓。现在，让我们专注于变量的主题。
- en: 'When defining a variable in Kotlin, we make use of the `var` keyword. This
    keyword specifies that the variable is mutable in nature. Thus, it can be changed.
    The data type of the declared variable comes after a semicolon that follows the
    variable''s identifier. It is important to note that the data type of a variable
    need not be explicitly defined. This is because Kotlin supports type inference—the
    ability to infer types of objects upon definition. We might as well have written
    the definition of our `x` variable as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中定义变量时，我们使用 `var` 关键字。这个关键字指定变量是可变的。因此，它可以被更改。声明的变量的数据类型位于变量标识符后面的分号之后。需要注意的是，变量的数据类型不必显式定义。这是因为
    Kotlin 支持类型推断——在定义时推断对象类型的能力。我们甚至可以将我们的 `x` 变量的定义写成如下：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The outcome of the definition would be the same. A semicolon can be added to
    the end of the line of our variable definition but, similar to languages like
    JavaScript, it is not required:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的结果将是相同的。可以在变量定义的行尾添加分号，但与 JavaScript 等语言类似，这不是必需的：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we don''t want the values of our variables to change over the course of
    the execution of our program, we can do so by making them immutable. Immutable
    variables are defined with the `val` keyword, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在程序执行过程中改变变量的值，我们可以通过使它们不可变来实现。不可变变量使用 `val` 关键字定义，如下所示：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Variable scope
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'The scope of a variable is the region of a program where the variable is of
    consequence. In other words, the scope of a variable is the region of a program
    in which the variable can be used. Kotlin variables have block scope. Therefore,
    the variables can be utilized in all regions that the block they were defined
    in covers:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域是程序中变量具有意义的区域。换句话说，变量的作用域是程序中变量可以使用的区域。Kotlin变量具有块作用域。因此，变量可以在它们定义的代码块覆盖的所有区域中使用：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding program, we can directly observe the effects of block scope
    by taking a look at the two blocks. The definition of a function opened a new
    block. We have labeled to this block as `B` in our example. Within `A`, the `a`
    and `i` variables were declared. As such, the scope of the `a` and `i` variables
    exists within `A`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们可以通过查看两个代码块来直接观察到块作用域的影响。一个函数的定义开启了一个新的代码块。在我们的例子中，我们将这个代码块标记为`B`。在`A`内部，`a`和`i`变量被声明。因此，`a`和`i`变量的作用域存在于`A`内部。
- en: A `while` loop was created within `A`, and as such, a new `B` block was opened.
    Loop declarations mark the beginning of new blocks. Within `B`, a `b` value is
    declared. The `b` value exists in the `B` scope and can't be used outside its
    scope. As such, when we attempt to print the value held by `b` outside the `B` block,
    an error will occur.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`A`内部创建了一个`while`循环，因此打开了一个新的`B`代码块。循环声明标志着新代码块的开始。在`B`内部声明了一个`b`值。`b`值存在于`B`的作用域内，不能在其作用域之外使用。因此，当我们尝试在`B`代码块之外打印`b`值所持有的值时，将发生错误。
- en: One thing worth noting is that the `a` and `i` variables can still be utilized
    within the `B` block. This is because `B` exists within the scope of `A`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`a`和`i`变量仍然可以在`B`代码块中使用。这是因为`B`存在于`A`的作用域内。
- en: Local variables
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量
- en: These are variables that are local to a scope. The `a`, `i`, and `b` variables
    in our previous example are all local variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是局部于作用域的变量。在我们之前的例子中，`a`、`i`和`b`变量都是局部变量。
- en: Operands and operators
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数和运算符
- en: An operator is the part of an instruction that specifies the value to be operated
    on. An operator also carries out a specific operation on its operands. Examples
    of operators are `+`, `-`, `*`, `/`, and `%`. Operators can be categorized based
    on the type of operations carried out and the number of operands acted upon by
    the operator.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是指令的一部分，它指定要操作的价值。运算符还对其操作数执行特定的操作。运算符的示例包括`+`、`-`、`*`、`/`和`%`。运算符可以根据执行的操作类型和运算符作用的操作数数量进行分类。
- en: 'Based on the type of operations carried out by the operator, we can classify
    operators into:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 根据运算符执行的操作类型，我们可以将运算符分为以下几类：
- en: Relational operators
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Assignment operators
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Logical operators
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Arithmetic operators
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Bitwise operators
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符
- en: '| **Operator type** | **Examples** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **运算符类型** | **示例** |'
- en: '| Relational operators | `>`, `<`, `>=`, `<=`, `==` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 关系运算符 | `>`, `<`, `>=`, `<=`, `==` |'
- en: '| Assignment operators | `+=`, `-=`, `*=`, `/=`, `=` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 赋值运算符 | `+=`, `-=`, `*=`, `/=`, `=` |'
- en: '| Logical operators | `&&`, `&#124;&#124;`, `!` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑运算符 | `&&`, `||`, `!` |'
- en: '| Arithmetic operators | `+`, `-`, `*`, `/` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算符 | `+`, `-`, `*`, `/` |'
- en: '| Bitwise operators | `and(bits)`, `or(bits)`, `xor(bits)`, `inv()`, `shl(bits)`,
    `shr(bits)`, `ushr(bits)` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 位运算符 | `and(bits)`, `or(bits)`, `xor(bits)`, `inv()`, `shl(bits)`, `shr(bits)`,
    `ushr(bits)` |'
- en: 'Based on the number of operands acted upon, we have two main types of operators
    in Kotlin:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据运算符作用的操作数数量，Kotlin中有两种主要的运算符类型：
- en: Unary operators
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符
- en: Binary operators
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元运算符
- en: '| **Operator type** | **Description** | **Examples** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **运算符类型** | **描述** | **示例** |'
- en: '| Unary operator | Requires only one operand | `!`, `++`, `- -` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 一元运算符 | 只需要一个操作数 | `!`, `++`, `--` |'
- en: '| Binary operator | Requires two operands | `+`, `-`, `*`, `/`, `%`, `&&`,
    `&#124;&#124;` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 二元运算符 | 需要两个操作数 | `+`, `-`, `*`, `/`, `%`, `&&`, `||` |'
- en: Types
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: The type of a variable, with respect to its value space, is the set of possible
    values that the variable can possess. In many cases, it is useful to be able to
    explicitly specify the type of value you want to be held by a variable being declared.
    This can be done using a data type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的类型，就其值域而言，是变量可以拥有的可能值的集合。在许多情况下，能够显式指定你想要声明的变量持有的值的类型是有用的。这可以通过使用数据类型来实现。
- en: 'Some important types in Kotlin are:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中一些重要的类型包括：
- en: '`Int`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`整数`'
- en: '`Float`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`浮点数`'
- en: '`Double`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`双精度浮点数`'
- en: '`Boolean`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔`'
- en: '`String`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符串`'
- en: '`Char`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符`'
- en: '`Array`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`'
- en: Int
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`整数`'
- en: This type represents a 32-bit signed integer. When a variable is declared with
    this type, the value space of the variable is the set of integers, that is, the
    variable can only hold integer values. We have seen the use of this type several
    times in our examples so far. The `Int` type can hold integer values within the
    range of -2,147,483,648 to 2,147,483,647.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型表示一个32位有符号整数。当一个变量使用这种类型声明时，变量的值域是整数集，也就是说，变量只能持有整数值。到目前为止，我们在示例中已经多次看到了这种类型的使用。`Int`类型可以持有从-2,147,483,648到2,147,483,647范围内的整数值。
- en: Float
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Float
- en: 'This type represents a single precision 32-bit floating-point number. When
    used with a variable, this type specifies that the variable can only hold floating-point
    values. Its range is approximately ±3.40282347E+38F (6-7 significant decimal digits):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型表示单精度32位浮点数。当与变量一起使用时，此类型指定变量只能持有浮点值。其范围大约是±3.40282347E+38F（6-7位有效数字）：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Double
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Double
- en: 'This type represents a double precision 64-bit floating-point number. Similar
    to the `Float` type, this type specifies that the variable being declared holds
    floating-point values. An important difference between the `Double` and `Float`
    types is that `Double` can hold numbers across a much larger range without overflow.
    Its range is approximately ±1.79769313486231570E+308 (15 significant decimal digits):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型表示双精度64位浮点数。与`Float`类型类似，这种类型指定了正在声明的变量持有浮点值。`Double`和`Float`类型之间的重要区别是`Double`可以在不溢出的情况下持有更大范围的数字。其范围大约是±1.79769313486231570E+308（15位有效数字）：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Boolean
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boolean
- en: 'The `true` and `false` logical truth values are represented by the `Boolean`
    type:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`和`false`逻辑真值由`Boolean`类型表示：'
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Boolean values are operated upon by the `&&`, `||`, and `!` logical operators:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通过`&&`、`||`和`!`逻辑运算符进行操作：
- en: '| **Operator name** | **Operator** | **Description** | **Operator type** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **运算符名称** | **运算符** | **描述** | **运算符类型** |'
- en: '| Conjunction | `&&` | Evaluates to true when two of its operands are `true`,
    otherwise evaluates to `false`. | Binary |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑与 | `&&` | 当其两个操作数都为`true`时返回`true`，否则返回`false`。 | 二元 |'
- en: '| Disjunction | `&#124;&#124;` | Evaluates to true when at least one operand
    is `true`, otherwise evaluates to `false`. | Binary |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑或 | `&#124;&#124;` | 当至少有一个操作数为`true`时返回`true`，否则返回`false`。 | 二元 |'
- en: '| Negation | `!` | Inverts the value of its Boolean operand. | Unary |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 否定 | `!` | 取反其布尔操作数的值。 | 一元 |'
- en: String
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String
- en: 'A string is a sequence of characters. In Kotlin, strings are represented by
    the string class. Strings can be easily written by typing out a sequence of characters
    and surrounding it with double quotation marks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一系列字符的序列。在Kotlin中，字符串由字符串类表示。可以通过输入一系列字符并用双引号包围来轻松地写出字符串：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Char
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Char
- en: 'This type is used to represent characters. A character is a unit of information
    that roughly corresponds to a grapheme, or a grapheme-like unit or symbol. In
    Kotlin, characters are of the `Char` type. Characters in single quotes in Kotlin,
    such as `a`, `$`, `%`, and `&`, are all examples of characters:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型用于表示字符。字符是信息单位，大致对应于图形符号、类似图形符号的单位或符号。在Kotlin中，字符是`Char`类型。Kotlin中单引号内的字符，如`a`、`$`、`%`和`&`，都是字符的例子：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Recall we mentioned earlier that a string is a sequence of characters:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们之前提到的，字符串是一系列字符的序列：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Array
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Array
- en: An array is a data structure consisting of a set of elements or values with
    each element possessing at least one index or key. Arrays are very useful in storing
    collections of elements you wish to utilize later on in a program.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种数据结构，由一组具有至少一个索引或键的元素或值组成。数组在存储你希望在程序中稍后利用的元素集合时非常有用。
- en: 'In Kotlin, arrays are created using the `arrayOf()` library method. The values
    you wish to store in the array are passed in a comma-separated sequence:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，使用`arrayOf()`库方法创建数组。你希望存储在数组中的值以逗号分隔的序列传递：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each array value has a unique index that both specifies its position in the
    array and can be used to retrieve the value later on. The set of indices in an
    array starts with the index, 0, and progresses with an increment of 1.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组的值都有一个唯一的索引，它既指定了其在数组中的位置，也可以用于稍后检索该值。数组的索引集合从索引0开始，以1为增量递增。
- en: 'The value held in any given index position of an array can be retrieved by
    either calling the `Array#get()` method or by using the `[]` operation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`Array#get()`方法或使用`[]`操作来检索数组中任何给定索引位置的值：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At any point in time, the value at a position of an array can be changed:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，都可以更改数组中某个位置上的值：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can check the size of an array at any time with its `length` property:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时使用其`length`属性来检查数组的大小：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Functions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'A function is a block of code that can be defined once and reused any number
    of times. When writing programs, it is best practice to break up complex programmatic
    processes into smaller units that perform specific tasks. Doing this has many
    advantages, some of which are:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一段可以被定义一次并多次重用的代码块。在编写程序时，将复杂的程序流程分解成执行特定任务的较小单元是最佳实践。这样做有许多优点，其中一些包括：
- en: '**Improving code readability**: It is much easier to read programs that have
    been broken down into functional units. This is because the scope of the code
    to be understood at any given point in time is reduced when functions are utilized.
    The majority of the time, a programmer needs to only write or adjust a section
    of a large code base. When functions are utilized, the context of the program
    that needs to be read to ameliorate program logic is restricted to the body of
    the function in which the logic is written.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码可读性**：将程序分解成功能单元的程序更容易阅读。这是因为当使用函数时，任何给定时刻需要理解代码的范围都会减小。大多数时候，程序员只需要编写或调整大型代码库的一部分。当使用函数时，为了改善程序逻辑，需要阅读的程序上下文仅限于编写逻辑的函数体。'
- en: '**Improving the maintainability of a code base**: The use of functions in a
    code base makes it easy to maintain programs. If a change needs to be made to
    a particular program feature, many times it is as easy as adjusting a function
    in which the feature has been created.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码库的可维护性**：在代码库中使用函数使得维护程序变得容易。如果需要对特定程序功能进行更改，很多时候只需调整创建该功能的函数即可。'
- en: Declaring functions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明函数
- en: 'Functions are declared with the `fun` keyword. The following is a simple function
    definition:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用`fun`关键字声明。以下是一个简单的函数定义：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The function simply prints the sum of two values that have been passed as arguments
    to it. Function definitions can be broken down into the following components:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 函数简单地打印出传递给它作为参数的两个值的总和。函数定义可以分解为以下组件：
- en: '**A function identifier**: The identifier of a function is the name given to
    it. An identifier is required to refer to the function if we wish to invoke it
    later on in a program. In the preceding function declaration, `printSum` is the
    identifier of the function.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数标识符**：函数的标识符是赋予它的名称。如果我们希望在程序中稍后调用该函数，则需要一个标识符。在前面的函数声明中，`printSum`是函数的标识符。'
- en: '**A pair of parentheses containing a comma-separated list of the arguments
    being passed as values to the function**: Values passed to a function are called
    arguments of the function. All arguments passed to the function must have a type.
    The type definition of an argument follows a semicolon placed after the argument
    name.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含逗号分隔的参数列表的括号对**：传递给函数的值称为函数的参数。传递给函数的所有参数都必须有类型。参数的类型定义位于参数名称后的分号之后。'
- en: '**A return type specification**: Return types of functions are specified similarly
    to the way the types of variables and properties are. The return type specification
    follows the last parenthesis and is done by writing the type after a semicolon.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型指定**：函数的返回类型与变量和属性的类型的指定方式类似。返回类型指定位于最后一个括号之后，通过在分号之后写入类型来完成。'
- en: '**A block containing the body of the function**.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含函数主体的代码块**。'
- en: 'Observing the preceding function, it may appear that it has no return type.
    This is not `true`, the function has a return type of `Unit`. A unit return type
    need not be explicitly specified. The function might as well be declared as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的函数，它可能看起来没有返回类型。这并不`true`，该函数的返回类型是`Unit`。不需要显式指定单元返回类型。该函数也可以声明如下：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: An identifier is not required for a function. Functions that do not possess
    an identifier are called anonymous functions. Anonymous functions are present
    in Kotlin in the form of lambdas.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不需要标识符。没有标识符的函数称为匿名函数。在Kotlin中，匿名函数以lambda的形式存在。
- en: Invoking functions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'Functions are not executed once they are defined. In order for the code within
    a function to be executed, the function must be invoked. Functions can be invoked
    as functions, as methods, and indirectly by utilizing the `invoke()` and `call()`
    methods. The following shows the direct functional invocation using the function
    itself:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义后不会立即执行。为了执行函数内的代码，必须调用该函数。函数可以作为函数、方法调用，也可以通过使用 `invoke()` 和 `call()` 方法间接调用。以下展示了使用函数本身的直接函数调用：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Compile and run the preceding code. The word `Hello` is printed on the screen
    five times. `Hello` was passed as our first value in the function and `5` as our
    second.  As a result of this, the `word` and `times` arguments are set to hold
    the `Hello` and `5` values in our repeat function. Our `while` loop runs and prints
    our word as long as `i` is less than the number of times specified. `i++` is used
    to increase the value of `i` by 1\. `i` is increased by one upon each iteration
    of the loop. The loop stops once `i` is equal to `5`. Hence, our word `Hello`
    will be printed five times. Compiling and running the program will give us the
    following output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行前面的代码。屏幕上会打印出五次单词 `Hello`。`Hello` 是作为函数的第一个值传递的，而 `5` 是作为第二个值传递的。因此，`word`
    和 `times` 参数被设置为在重复函数中保留 `Hello` 和 `5` 的值。我们的 `while` 循环会一直运行并打印我们的单词，直到 `i` 小于指定的次数。`i++`
    用于将 `i` 的值增加 1。每次循环迭代时，`i` 的值都会增加 1。当 `i` 等于 `5` 时，循环停止。因此，我们的单词 `Hello` 将被打印五次。编译并运行程序将给出以下输出：
- en: '![](img/d35cd3cb-1ebc-4ba7-a6cf-ce1abaad92d0.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d35cd3cb-1ebc-4ba7-a6cf-ce1abaad92d0.jpg)'
- en: The other methods of function invocation will be demonstrated over the course
    of this book.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将演示函数调用的其他方法。
- en: Return values
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: 'A return value—as the name implies—is the value that a method returns. Functions
    in Kotlin can return values upon execution. The type of the value returned by
    a function is defined by the function''s return type. This is demonstrated in
    the following code snippet:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值——正如其名所示——是方法返回的值。Kotlin 中的函数在执行时可以返回值。函数返回值的类型由函数的返回类型定义。以下代码片段展示了这一点：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, the `returnFullName` function takes two distinct strings
    as its input parameters and returns a string value when called. The return type
    has been defined in the function header. The string returned is created via string
    templates:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`returnFullName` 函数接受两个不同的字符串作为其输入参数，并在调用时返回一个字符串值。返回类型已在函数头部定义。返回的字符串是通过字符串模板创建的：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The values for first name and last name are interpolated into the string of
    characters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首名和姓氏的值被插入到字符字符串中。
- en: The function naming convention
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数命名约定
- en: 'The conventions for naming functions in Kotlin are similar to that of Java.
    When naming methods, camel case is utilized. In camel case, names are written
    such that each word in the name begins with a capital letter, with no intervening
    spaces or punctuation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中命名函数的约定与 Java 类似。在命名方法时，使用驼峰式命名法。在驼峰式命名法中，名称的每个单词都以大写字母开头，没有空格或标点符号：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Comments
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'When writing code, you may need to jot down important information pertaining
    to the code being written. This is done through the use of comments. There are
    three types of comments in Kotlin:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，你可能需要记下与正在编写的代码相关的关键信息。这是通过使用注释来完成的。Kotlin 中有三种类型的注释：
- en: Single-line comments
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行注释
- en: Multiline comments
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行注释
- en: Doc comments
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档注释
- en: Single-line comments
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单行注释
- en: 'As the name implies, these comments span a single line. Single-line comments
    are started with two backslashes (`//`). Upon compilation of your program, all
    characters coming after these slashes are ignored. Consider the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这些注释跨越单行。单行注释以两个反斜杠（`//`）开始。在程序编译时，这些斜杠之后的所有字符都将被忽略。考虑以下代码：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The value held by `b` is never printed to the console because the function that
    performs the printing operation has been commented out.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `b` 的值永远不会打印到控制台，因为执行打印操作的函数已被注释掉。
- en: Multiline comments
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多行注释
- en: 'Multiline comments span multiple lines. They are started with a backslash followed
    by an asterisk (`/*`) and ended by an asterisk followed by a backslash (`*/`):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释跨越多行。它们以反斜杠后跟一个星号（`/*`）开始，以星号后跟一个反斜杠（`*/`）结束：
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Doc comments
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档注释
- en: 'This type of comment is similar to a multiline comment. The major difference
    is that it is used to document code within a program. A doc comment starts with
    a backslash followed by two asterisk characters (`/**`) and ends with an asterisk
    followed by a backslash (`*/`):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这种注释类似于多行注释。主要区别在于它用于在程序中注释代码。文档注释以反斜杠后跟两个星号字符（`/**`）开始，并以星号后跟反斜杠（`*/`）结束：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Controlling program flow
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制程序流程
- en: When writing programs, a scenario that often occurs is one in which we want
    to control how our program executes. This is necessary if we want to write programs
    that can make decisions based on conditions and program state. Kotlin possesses
    a number of structures for doing this, which will be familiar to people who have
    worked with programming languages in the past, such as `if`, `while`, and `for`
    constructs. There are also others that may not be familiar to individuals, such
    as the `when` construct. In this section, we will take a look at the structures
    at our disposal for controlling the flow of our program.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，经常遇到的一个场景是我们想要控制程序的执行方式。如果我们想编写可以根据条件和程序状态做出决策的程序，这是必要的。Kotlin 拥有用于此目的的多种结构，这些结构对以前使用过编程语言的人来说很熟悉，例如
    `if`、`while` 和 `for` 构造。还有一些可能对个人来说不太熟悉的结构，例如 `when` 构造。在本节中，我们将探讨我们可以用来控制程序流程的结构。
- en: Conditional expressions
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件表达式
- en: Conditional expressions are used for branching program flow. They execute or
    skip program statements based on the outcome of a conditional test. Conditional
    statements are the decision-making points of a program.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式用于分支程序流程。它们根据条件测试的结果执行或跳过程序语句。条件语句是程序中的决策点。
- en: Kotlin has two main structures for handling branching. These are `if` expressions
    and `when` expressions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 处理分支有两个主要结构。这些是 `if` 表达式和 `when` 表达式。
- en: The if expression
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`if` 表达式'
- en: 'The `if` expression is used to make a logical decision based on the fulfillment
    of a condition. We make use of the `if` keyword to write `if` expressions:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 表达式用于根据条件的满足情况做出逻辑决策。我们使用 `if` 关键字来编写 `if` 表达式：'
- en: '[PRE41]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding `if` expression tests whether the `a == 1` (read: `a` is equal
    to `1`) condition holds `true`. If the condition is `true`, the `a is one` string
    is printed on the screen, otherwise nothing is printed.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `if` 表达式测试 `a == 1`（读作：`a` 等于 `1`）条件是否成立。如果条件为 `true`，则屏幕上打印出 `a is one`
    字符串，否则不打印任何内容。
- en: 'An `if` expressions often has one or more accompanying `else` or `else if`
    keywords. These accompanying keywords can be used to further control the flow
    of a program. Take the following `if` expression for example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `if` 表达式通常有一个或多个伴随的 `else` 或 `else if` 关键字。这些伴随关键字可以用来进一步控制程序的流程。以下是一个 `if`
    表达式的例子：
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding expression first tests whether `a` is equal to `1`. This test
    evaluates to `false` so, the following condition has been tested. Surely `a` is
    not equal to `2`. Hence the second condition evaluates to `false`. As a result
    of all previous conditions evaluating to `false`, the final statement is executed.
    Hence `a is neither one nor two.` is printed on the screen.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式首先测试 `a` 是否等于 `1`。这个测试的结果是 `false`，因此接下来测试了另一个条件。显然 `a` 不等于 `2`。因此，第二个条件的结果也是
    `false`。由于所有前面的条件都评估为 `false`，所以执行了最后的语句。因此，屏幕上打印出 `a is neither one nor two.`。
- en: The when expression
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`when` 表达式'
- en: 'The `when` expression is another means of controlling program flow. Let''s
    observe how it works with a simple example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 表达式是另一种控制程序流程的方法。让我们通过一个简单的例子来看看它是如何工作的：'
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding `printEvenSum` function takes an integer array as its only argument.
    We will cover arrays later on in this chapter, but for now think of them as a
    sequential collection of values existing in a value space. In this case, the array
    passed contains values that exist in the value space of integers. Each element
    of the array is iterated upon using the `forEach` method and each number is tested
    in the `when` expression.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `printEvenSum` 函数只接受一个整数数组作为其唯一参数。我们将在本章后面讨论数组，但就现在而言，可以将它们视为存在于值空间中的值的有序集合。在这种情况下，传递的数组包含存在于整数值空间中的值。使用
    `forEach` 方法迭代数组的每个元素，并在 `when` 表达式中测试每个数字。
- en: Here, the `it` refers to the current value being iterated upon by the `forEach`
    method. The `%` operator is a binary operator that acts on two operands. It divides
    the first operand by the second and returns the remainder of the division. Thus,
    the `when` expression tests if/when the current value iterated upon (the value
    held within `it`) is divided by `2` and has a remainder of `0`. If it does, the
    value is even and hence the value is printed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`it` 指的是 `forEach` 方法正在迭代的当前值。`%` 操作符是一个二元操作符，作用于两个操作数。它将第一个操作数除以第二个操作数，并返回除法的余数。因此，`when`
    表达式测试当前迭代的值（`it` 中保存的值）除以 `2` 是否有余数为 `0`。如果有，则该值是偶数，因此打印该值。
- en: 'To observe how the program works, copy and paste the preceding code into a
    file, then compile and run the program:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要观察程序的工作方式，请将前面的代码复制并粘贴到一个文件中，然后编译并运行程序：
- en: '![](img/32c7d21e-9909-4f95-8dbe-d3719675ac1a.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32c7d21e-9909-4f95-8dbe-d3719675ac1a.jpg)'
- en: The Elvis operator
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elvis 操作符
- en: 'The Elvis operator is a terse structure that is present in Kotlin. It takes
    the following form:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Elvis 操作符是 Kotlin 中存在的一种简洁结构。它具有以下形式：
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Its usage in a Kotlin program is demonstrated in the following code block:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中展示了在 Kotlin 程序中的使用：
- en: '[PRE45]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the value held by `nullName` is not null, the Elvis operator returns it,
    otherwise the `"John"` string is returned. Thus, `firstName` is assigned the value
    returned by the Elvis operator.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `nullName` 保存的值不是 `null`，则 Elvis 操作符返回它，否则返回 `"John"` 字符串。因此，`firstName`
    被分配给 Elvis 操作符返回的值。
- en: Loops
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Looping statements are used to ensure that a collection of statements within
    a block of code repeats in execution. That is, a loop ensures that a number of
    statements within a program executes for a number of times. The looping constructs
    provided by Kotlin are the `for` loop, the `while` loop, and the `do…while` loop.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句用于确保代码块中的语句集合在执行中重复。也就是说，循环确保程序中的多个语句执行多次。Kotlin 提供的循环结构是 `for` 循环、`while`
    循环和 `do…while` 循环。
- en: The for loops
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: 'The `for` loop in Kotlin iterates over any object that provides an iterator.
    It is similar to the `for..in` loop in Ruby. The loop has this syntax:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的 `for` 循环遍历任何提供迭代器的对象。它与 Ruby 中的 `for..in` 循环类似。循环具有以下语法：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The block in the `for` loop is not necessary if only a single statement exists
    in the loop. A collection is a type of structure that provides an iterator. Consider
    the following program:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环中只有一个语句，则 `for` 循环中的块不是必需的。集合是一种提供迭代器的结构类型。考虑以下程序：
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Each value in the `numSet` array is iterated upon by the loop and assigned to
    the variable number. The number is then printed to the standard system output.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`numSet` 数组中的每个值都会被循环迭代，并分配给变量 `number`。然后，`number` 被打印到标准系统输出。'
- en: Every element of an array has an index. An index is the position an element
    holds within an array. The set of indices of an array in Kotlin starts from zero.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的每个元素都有一个索引。索引是元素在数组中持有的位置。Kotlin 中数组索引的集合从零开始。
- en: 'If instead of printing the numeric values of the number iterated upon, we wish
    to print the indices of each number, we can do that as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想打印迭代的数字的数值，而是想打印每个数字的索引，我们可以这样做：
- en: '[PRE48]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can specify a type for your iterator variable as well:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为迭代器变量指定一个类型：
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The while loops
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: 'A `while` loop executes instructions within a block as long as a specified
    condition is met. The `while` loops are created using the `while` keyword. It
    takes the following form:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足指定条件时，`while` 循环会执行一个块内的指令。`while` 循环是通过使用 `while` 关键字创建的。它具有以下形式：
- en: '[PRE50]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As in the case of the `for` loop, the block is optional in the case where only
    one sentence is within the scope of the loop. In a `while` loop, the statements
    in the block execute repeatedly while the condition specified still holds. Consider
    the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `for` 循环的情况一样，当循环范围内只有一个句子时，块是可选的。在 `while` 循环中，块内的语句在指定的条件仍然保持时重复执行。考虑以下代码：
- en: '[PRE51]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding program, the block of code within the `while` loop executes
    and prints `I am not Segun` until the name `Segun` is encountered. Once `Segun`
    is encountered, the loop terminates and nothing else is printed out, as shown
    in the following screenshot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`while` 循环内的代码块执行并打印 `I am not Segun`，直到遇到名称 `Segun`。一旦遇到 `Segun`，循环终止，不再打印其他内容，如下面的截图所示：
- en: '![](img/12ed2d24-0175-4dab-bd0f-745d268d1287.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12ed2d24-0175-4dab-bd0f-745d268d1287.jpg)'
- en: The break and continue keywords
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`break` 和 `continue` 关键字'
- en: 'Often when declaring loops, there is a need to either break out of the loop
    if a condition fulfills, or start the next iteration at any point in time within
    the loop. This can be done with the `break` and `continue` keywords. Let''s take
    an example to explain this further. Open a new Kotlin script file and copy the
    following code into it:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 常常在声明循环时，需要根据条件满足与否，从循环中跳出，或者在任何时间点开始下一次迭代。这可以通过使用`break`和`continue`关键字来实现。让我们通过一个例子来进一步解释这一点。打开一个新的
    Kotlin 脚本文件，并将以下代码复制到其中：
- en: '[PRE52]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding program is simplistic software for selecting admitted students
    out of a list of prospective students. We create a data class at the start of
    our program to model the data of each student, then two array lists are created.
    One array list holds the information of the prospective students, those that have
    applied for admission, and the other list holds the information of the students
    that have been admitted.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序是一个从潜在学生名单中选择录取学生的简单软件。我们在程序开始时创建一个数据类来模拟每个学生的数据，然后创建了两个数组列表。一个数组列表包含潜在学生的信息，那些申请入学的人，另一个列表包含已被录取的学生信息。
- en: The next five lines of code add prospective students to the prospective student
    list. We then declare a loop that iterates over all students present in the prospective
    student list. If the age of the current student in the loop is less than 16 years
    old, the loop skips to the next iteration. This models the scenario in where a
    student is too young to be admitted (thus not added to the admitted students list).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的五行代码将潜在的学生添加到潜在学生名单中。然后我们声明一个循环，遍历潜在学生名单中的所有学生。如果循环中当前学生的年龄小于16岁，循环将跳到下一次迭代。这模拟了学生年龄太小无法被录取（因此不会被添加到录取学生名单中）的情况。
- en: If the student is 16 or older, the student is added to the admitted list. An
    `if` expression is then used to check whether the number of admitted students
    is greater than or equal to three. If the condition is true, the program breaks
    out of the loop and no further iterations are done. The last line of the program
    prints out the students present in the list.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果学生年龄为16岁或以上，该学生将被添加到录取名单中。然后使用`if`表达式检查录取学生的数量是否大于或等于三个。如果条件为真，程序将跳出循环，不再进行进一步的迭代。程序的最后一行打印出名单中的学生。
- en: 'Run the program to see the output:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序以查看输出：
- en: '![](img/7a5c0bea-916f-4945-b1ec-d64d00455f5c.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a5c0bea-916f-4945-b1ec-d64d00455f5c.jpg)'
- en: The do…while loops
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do…while 循环
- en: 'The `do…while` loop is similar to the `while` loop, with the exception that
    in the conditional test for the reiteration of the loop, it is carried out after
    the first iteration. It takes the following form:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`do…while`循环与`while`循环类似，区别在于在循环重迭代的条件测试中，它是在第一次迭代之后进行的。它具有以下形式：'
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The statements within the block are executed while the condition tested holds
    `true`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试的条件保持`true`时，将执行块内的语句：
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Nullable values**: The `NullPointerException` is one thing that individuals
    who have first-hand experience writing Java code are certain to have encountered.
    The Kotlin type system is null-safe—it attempts to eliminate the occurrence of
    null references within code. As a result, Kotlin possesses nullable types and
    non-nullable types (types that can hold a null value and those that can''t).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**可空值**：`NullPointerException`是那些有编写 Java 代码第一手经验的个人肯定遇到过的事情。Kotlin 类型系统是空安全的——它试图消除代码中空引用的发生。因此，Kotlin
    具有可空类型和非可空类型（可以持有空值和不能持有空值的类型）。'
- en: 'To properly explain the `NullPointerException`, we will consider the following
    Java program:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确解释`NullPointerException`，我们将考虑以下 Java 程序：
- en: '[PRE55]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding program performs the simple task of printing the length of a
    string variable to the standard system output. There is only one problem with
    our program. When we compile and run it, it throws a null pointer exception and
    terminates midway through execution, as we can see the following screenshot:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序执行了一个简单的任务，即将字符串变量的长度打印到标准系统输出。我们的程序中只有一个问题。当我们编译并运行它时，它会抛出一个空指针异常，并在执行中途终止，如下面的截图所示：
- en: '![](img/b83699fa-31e2-46fd-bec9-384a7e2b2968.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b83699fa-31e2-46fd-bec9-384a7e2b2968.jpg)'
- en: Can you spot the cause of the `NullPointerException`? The exception arises as
    a result of the `String#length` method being used on a null reference. As such,
    the program stops executing and throws the exception. Clearly, this is not something
    we want to occur in our programs.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到 `NullPointerException` 的原因吗？异常是由于在 null 引用上使用了 `String#length` 方法而引发的。因此，程序停止执行并抛出异常。显然，我们不希望在我们的程序中发生这种情况。
- en: 'We can prevent this in Kotlin by preventing the assignment of a null value
    to the name object:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过防止将 null 值分配给名称对象来防止这种情况在 Kotlin 中发生：
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As can be seen in the following screenshot, Kotlin''s type system detects that
    a null value has been inappropriately assigned to the `name` variable and swiftly
    alerts the programmer of this blunder so it can be corrected:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，Kotlin 的类型系统检测到 `name` 变量被不适当地分配了 null 值，并迅速通知程序员这个错误，以便进行纠正：
- en: '![](img/d79645e5-90ab-4476-a979-40c1ac0fb675.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d79645e5-90ab-4476-a979-40c1ac0fb675.jpg)'
- en: 'At this point, you may be wondering what happens if a scenario arises in which
    the programmer intends to permit the passing of null values. In that scenario,
    the programmer simply declares the value as nullable by appending `?` to the type
    of the variable:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道如果出现程序员意图允许传递 null 值的场景会发生什么。在这种情况下，程序员只需通过在变量的类型后附加 `?` 来声明该值为可空：
- en: '[PRE57]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Regardless of the fact that we have declared the variable name to be nullable,
    we''ll still get an error upon running the program. This is because we must access
    the length property of the variable in a safe way. This can be done with `?.`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已声明变量名为可空，但在运行程序时我们仍然会得到错误。这是因为我们必须以安全的方式访问变量的长度属性。这可以通过 `?.` 来实现：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now that we have used the `?.` safe operator, the program will run as intended.
    Instead of a null pointer exception being thrown, the type system recognizes that
    a null pointer has been referenced and prevents the invocation of `length()` on
    the null object. The following screenshot shows the type-safe output:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用了 `?.` 安全操作符，程序将按预期运行。不会抛出空指针异常，类型系统会识别出已引用了 null 指针，并防止在 null 对象上调用
    `length()`。以下截图显示了类型安全的输出：
- en: '![](img/9bef2b92-61cb-4b9b-9fb3-edbe1f357c8e.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9bef2b92-61cb-4b9b-9fb3-edbe1f357c8e.jpg)'
- en: An alternative to using the `?.` safe operator would be to use the `!!` operator.
    The `!!` operator allows the program to continue execution and throws a `KotlinNullPointerException`
    once a function invocation is attempted on a null reference.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `?.` 安全操作符的替代方法是使用 `!!` 操作符。`!!` 操作符允许程序继续执行，并在尝试在 null 引用上调用函数时抛出 `KotlinNullPointerException`。
- en: 'We can see the effects by replacing `?.` with `!!.` in our written program.
    The following screenshot shows the output of the program when run. A `KotlinNullPointerException`
    is thrown as a result of the utilization of the `!!` operator:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将程序中写下的 `?.` 替换为 `!!.` 来看到效果。以下截图显示了程序运行时的输出。由于使用了 `!!` 操作符，抛出了 `KotlinNullPointerException`。
- en: '![](img/1a1a5aac-1923-42d8-9655-1e443af842d4.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1a1a5aac-1923-42d8-9655-1e443af842d4.jpg)'
- en: Packages
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: A package is a logical grouping of related classes, interfaces, enumerations,
    annotations, and functions. As source files grow larger, it is necessary to group
    these files into meaningful and distinct collections for various reasons, such
    as to enhance the maintainability of applications, name conflict prevention, and
    access control.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 包是相关类、接口、枚举、注解和函数的逻辑分组。随着源文件变得越来越大，出于各种原因，如提高应用程序的可维护性、防止名称冲突和访问控制，有必要将这些文件分组到有意义的、不同的集合中。
- en: 'A package is created with the `package` keyword followed by a package name:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 包是通过 `package` 关键字后跟包名来创建的：
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There can be only one package statement per program file. If a package for a
    program file is not specified, the contents of the file are placed into the default
    package.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序文件只能有一个包声明。如果一个程序文件的包没有被指定，则文件的内容将放置在默认包中。
- en: The import keyword
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入关键字
- en: 'Often, classes and types need to make use of other classes and types existing
    outside the package in which they are declared. This can be done by importing
    package resources. If two classes belong in the same package, no import is necessary:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，类和类型需要使用它们声明的包之外存在的其他类和类型。这可以通过导入包资源来实现。如果两个类属于同一个包，则不需要导入：
- en: '[PRE60]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the following code snippet, the `Buffalo` class does not need to be imported
    into the program because it exists in the same package (`animals`) as the `Lion`
    class:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`Buffalo` 类不需要导入到程序中，因为它与 `Lion` 类存在于同一个包（`animals`）中：
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In order to import classes, functions, interfaces, and types in separate packages,
    we use the `import` keyword followed by the package name. For example, the following `main`
    function exists in the default package. As such, if we want to make use of the
    `Lion` and `Buffalo` classes in the `main` function, we must import it with the
    `import` keyword. Consider the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同的包中导入类、函数、接口和类型，我们使用 `import` 关键字后跟包名。例如，下面的 `main` 函数存在于默认包中。因此，如果我们想在
    `main` 函数中使用 `Lion` 和 `Buffalo` 类，我们必须使用 `import` 关键字导入它们。考虑以下代码：
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Object-oriented programming concepts
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程概念
- en: Up till now, we have made used of classes in a number of examples but have not
    explored the concept in depth. This section will introduce you to the basics of
    classes as well as other object-oriented constructs available in Kotlin.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在许多示例中使用了类，但还没有深入探讨这个概念。本节将向您介绍 Kotlin 中类的基本知识以及其他面向对象的构造。
- en: Introduction
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the beginning of high-level programming languages, programs were written
    procedurally. The programming languages available were mainly procedural in nature.
    A procedural programming language is a language that utilizes a series of structured,
    well-defined steps to compose programs.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级编程语言的开端，程序是按照过程性编写的。当时可用的编程语言主要是过程性的。过程式编程语言是一种利用一系列结构化、定义良好的步骤来编写程序的编程语言。
- en: As the software industry grew larger and programs grew bulkier, it became necessary
    to devise a better approach to designing software. This led to the advent of object-oriented
    programming languages.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件行业的扩大和程序的膨胀，有必要设计一种更好的软件设计方法。这导致了面向对象编程语言的诞生。
- en: The object-oriented programming model is a model organized around objects and
    data rather than actions and sequential logic. In object-oriented programming,
    objects, classes, and interfaces are composed, extended, and inherited toward
    the goal of building industrial-strength software.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程模型是一种围绕对象和数据而不是动作和顺序逻辑组织的模型。在面向对象编程中，对象、类和接口被组合、扩展和继承，以实现构建工业级软件的目标。
- en: A **class** is a modifiable and extensible program template for the creation
    of objects and the maintenance of state through the use of variables, constants,
    and properties. A class possesses characteristics and behaviors. Characteristics
    are exposed as variables and behaviors are implemented in the form of methods.
    Methods are functions that are specific to a class or a collection of classes.
    Classes have the ability to inherit characteristics and behaviors from other classes.
    This ability is called **inheritance**.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是一个可修改和可扩展的程序模板，用于创建对象并通过使用变量、常量和属性来维护状态。类具有特性和行为。特性以变量的形式暴露，行为以方法的形式实现。方法是特定于类或类集合的函数。类能够从其他类继承特性和行为。这种能力被称为**继承**。'
- en: Kotlin is a fully object-oriented programming language and hence supports all
    features of object-oriented programming. In Kotlin, similar to Java and Ruby,
    only single inheritance is permitted. Some languages, such as C++, support multiple
    inheritance. A downside to multiple inheritance is that it brings up management
    issues, such as same name collisions. A class inheriting from another class is
    referred to as a subclass and the class it inherits from is its superclass.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种完全面向对象的编程语言，因此支持面向对象编程的所有特性。在 Kotlin 中，类似于 Java 和 Ruby，只允许单继承。一些语言，如
    C++，支持多重继承。多重继承的一个缺点是它会产生管理问题，例如同名冲突。从一个类继承的类被称为子类，而它继承的类是其超类。
- en: An **interface** is a structure that enforces certain characteristics and behaviors
    in classes. Behavioral enforcements via interfaces can be done by implementing
    an interface in a class. Similar to classes, an interface can extend another interface.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**是一种强制在类中实施某些特性和行为的结构。通过在类中实现接口，可以执行行为强制。类似于类，接口可以扩展另一个接口。'
- en: An **object** is an instance of a class that may possesses its own unique state.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**是类的实例，可能具有其自己的独特状态。'
- en: Working with classes
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与类一起工作
- en: 'A class is declared using the `class` keyword followed by the class name:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 类是通过 `class` 关键字后跟类名来声明的：
- en: '[PRE63]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As in the preceding example, a class in Kotlin need not have a body. Though
    this is charming, almost all the time you will want your class to have characteristics
    and behaviors placed within a body. This can be done with the use of opening and
    closing brackets:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个示例中所示，Kotlin 中的类不一定需要有主体。虽然这很吸引人，但几乎每次你都会希望你的类在主体中包含特性和行为。这可以通过使用开括号和闭括号来完成：
- en: '[PRE64]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding code snippet, we have a class named `HelloPrinter` with a single
    function declared in it. A function that is declared within a class is called
    a method. Methods can also be referred to as behaviors. Once a method is declared,
    it can be used by all instances of the class.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有一个名为 `HelloPrinter` 的类，其中声明了一个函数。在类中声明的函数被称为方法。方法也可以被称为行为。一旦声明了方法，它就可以被类的所有实例使用。
- en: Creating objects
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'Declaring an instance of a class—or an object—is similar to declaring a variable.
    We can create an instance of the `HelloPrinter` class, as shown in the following
    code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 声明类的实例或对象类似于声明变量。我们可以创建 `HelloPrinter` 类的实例，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding `printer` is an instance of the `HelloPrinter` class. The opening
    and closing brackets after the `HelloPrinter` class name are used to invoke the
    primary constructor of the `HelloPrinter` class. A constructor is similar to a
    function. A constructor is a special function that initializes an object of a
    type.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `printer` 是 `HelloPrinter` 类的一个实例。在 `HelloPrinter` 类名之后的开括号和闭括号用于调用 `HelloPrinter`
    类的主构造函数。构造函数类似于函数。构造函数是一个特殊的函数，用于初始化一个类型的对象。
- en: 'The function declared within the `HelloPrinter` class can be invoked directly
    by the `printer` object at any point in time:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HelloPrinter` 类中声明的函数可以在任何时间点直接通过 `printer` 对象调用：
- en: '[PRE66]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Occasionally, you may require a function to be directly invokable with the class
    without needing to create an object. This can be done with the use of a companion
    object.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要一个函数可以直接通过类调用，而不需要创建一个对象。这可以通过使用伴生对象来实现。
- en: Companion objects
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象
- en: 'Companion objects are declared within a class by utilizing the `companion`
    and `object` keywords. You can use functions that are static within a companion
    object:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 伴生对象是通过在类中使用 `companion` 和 `object` 关键字来声明的。你可以在伴生对象中使用静态函数：
- en: '[PRE67]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Sometimes, you may want to give an identifier to a companion object. This can
    be done by placing the name after the `object` keyword. Consider the following
    example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想给伴生对象一个标识符。这可以通过在 `object` 关键字后放置名称来完成。考虑以下示例：
- en: '[PRE68]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Properties
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Classes can have properties that may be declared using the `var` and `val`
    keywords. For example, in the following code snippet, the `Person` class has three
    properties, `age`, `firstName`, and `surname`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以有使用 `var` 和 `val` 关键字声明的属性。例如，在以下代码片段中，`Person` 类有三个属性，`age`、`firstName`
    和 `surname`：
- en: '[PRE69]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Properties can be accessed through an instance of the class holding the property.
    This is done by appending a single dot character (`.`) to an instance identifier
    followed by the property name. For example, in the following code snippet, an
    instance—named `person`—of the `Person` class is created and its `firstName`,
    `surname`, and `age` properties are assigned by accessing the properties:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以通过持有属性的类的实例来访问。这是通过在实例标识符后附加一个单独的点字符（`.`）并跟随着属性名称来完成的。例如，在以下代码片段中，创建了一个名为
    `person` 的 `Person` 类的实例，并通过访问属性来分配其 `firstName`、`surname` 和 `age` 属性：
- en: '[PRE70]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Advantages of Kotlin
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 的优势
- en: 'As previously discussed, Kotlin was designed to be a better Java, and as such,
    there are a number of advantages to using Kotlin over Java:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kotlin 被设计成比 Java 更好，因此使用 Kotlin 而不是 Java 有许多优势：
- en: '**Null safety**: One common occurrence in Java programs is the throwing of
    `NullPointerException`. Kotlin alleviates this issue by providing a null-safe
    type system.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空安全**：Java 程序中常见的一个问题是抛出 `NullPointerException`。Kotlin 通过提供空安全类型系统来减轻这个问题。'
- en: '**Presence of extension functions**: Functions can easily be added to classes
    defined in program files to extend their functionality in various ways. This can
    be done with extension functions in Kotlin.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展函数的存在**：可以在程序文件中定义的类中轻松添加函数，以各种方式扩展其功能。这可以通过 Kotlin 中的扩展函数来实现。'
- en: '**Singletons**: It is easy to implement the singleton pattern in Kotlin programs.
    The implementation of a singleton in Java takes considerably more effort than
    when it is done with Kotlin.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：在Kotlin程序中实现单例模式非常简单。在Java中实现单例模式比在Kotlin中实现要费劲得多。'
- en: '**Data classes**: When writing programs, it is a common scenario to have to
    create a class for the sole purpose of holding data in variables. This often leads
    to the writing of many lines of code for such a mundane task. Data classes in
    Kotlin make it extremely easy to create such classes that hold data with a single
    line of code.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类**：在编写程序时，通常需要创建一个类，仅用于在变量中存储数据。这通常会导致编写大量代码来完成这样的平凡任务。Kotlin中的数据类使得使用单行代码创建这样的数据类变得极其简单。'
- en: '**Function types**: Unlike Java, Kotlin has function types. This enables functions
    to accept other functions as parameters and the definition of functions that return
    functions.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数类型**：与Java不同，Kotlin拥有函数类型。这使得函数能够接受其他函数作为参数，以及定义返回函数的函数。'
- en: Developing Android applications with Kotlin
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin开发Android应用程序
- en: We have taken a concise look at some of the features Kotlin has put at our disposal
    for developing powerful applications. Over the course of this book, we will explore
    how these features can be utilized in Android application development - an area
    in which Kotlin shines.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地回顾了Kotlin为我们提供的一些开发强大应用程序的功能。在本书的整个过程中，我们将探讨如何利用这些功能进行Android应用程序开发——这是Kotlin大放异彩的领域。
- en: 'Before getting started on this journey, we must set up our systems for the
    task at hand. A major necessity for developing Android applications is a suitable
    IDE - it is not a requirement but it makes the development process easier. Many
    IDE choices exist for Android developers. The most popular are:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这段旅程之前，我们必须为手头的任务设置我们的系统。开发Android应用程序的一个主要需求是合适的IDE——它不是必需的，但它可以使开发过程更容易。Android开发者有许多IDE选择。最受欢迎的是：
- en: Android Studio
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio
- en: Eclipse
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse
- en: IntelliJ IDE
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDE
- en: Android Studio is by far the most powerful of the IDEs available with respect
    to Android development. As a consequence, we will be utilizing this IDE in all
    Android-related chapters in this book.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发方面，Android Studio无疑是所有IDE中最强大的。因此，我们将在这本书的所有与Android相关的章节中使用这个IDE。
- en: Setting up Android Studio
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Android Studio
- en: 'At the time of writing, the version of Android Studio that comes bundled with
    full Kotlin support is Android Studio 3.0\. The canary version of this software
    can be downloaded from [https://developer.android.com/studio/preview/index.html](https://developer.android.com/studio/preview/index.html).
    Once downloaded, open the downloaded package or executable and follow the installation
    instructions. A setup wizard exists to guide you through the IDE setup procedure:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，包含完整Kotlin支持的Android Studio版本是Android Studio 3.0。该软件的测试版可以从[https://developer.android.com/studio/preview/index.html](https://developer.android.com/studio/preview/index.html)下载。下载后，打开下载的包或可执行文件，按照安装说明进行操作。存在一个设置向导，可引导您完成IDE设置过程：
- en: '![](img/26ca7d94-1051-4f5d-94bf-4d5575c501ff.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26ca7d94-1051-4f5d-94bf-4d5575c501ff.png)'
- en: 'Continuing to the next setup screen will prompt you to choose which type of
    Android Studio setup you''d like:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到下一个设置屏幕将提示您选择您想要的Android Studio设置类型：
- en: '![](img/0daee16d-8ac5-4de1-adbd-6bf1e65649a2.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0daee16d-8ac5-4de1-adbd-6bf1e65649a2.png)'
- en: 'Select the Standard setup and continue to the next screen. Click Finish on
    the Verify Settings screen. Android Studio will now download the components required
    for your setup. You will need to wait a few minutes for the required components
    to download:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 选择标准设置并继续到下一个屏幕。在验证设置屏幕上点击完成。现在，Android Studio将下载设置所需的组件。您需要等待几分钟，直到所需的组件下载完成：
- en: '![](img/3a7eaf4d-9a0c-454a-b2b1-355563296623.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a7eaf4d-9a0c-454a-b2b1-355563296623.png)'
- en: 'Click Finish once the component download has completed. You will be taken to
    the Android Studio landing screen. You are now ready to use Android Studio:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 组件下载完成后，点击完成。您将被带到Android Studio的登录屏幕。现在，您已经准备好使用Android Studio了：
- en: '![](img/c39b7af7-10a9-4a9d-b6ee-4df181a6722e.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c39b7af7-10a9-4a9d-b6ee-4df181a6722e.jpg)'
- en: Building your first Android application
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的第一个Android应用程序
- en: Without further ado, let's explore how to create a simple Android application
    with Android Studio. We will be building the *HelloApp*. The *HelloApp* is an
    app that displays `Hello world!` on the screen upon the click of a button.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们探索如何使用Android Studio创建一个简单的Android应用程序。我们将构建*HelloApp*。*HelloApp*是一个在按钮点击后在屏幕上显示`Hello
    world!`的应用程序。
- en: On the Android Studio landing screen, click Start a new Android Studio project.
    You will be taken to a screen where you will specify some details that concern
    the app you are about to build, such as the name of the application, your company
    domain, and the location of the project.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio的登录屏幕上，点击“开始新的Android Studio项目”。您将被带到屏幕，您将指定一些与您即将构建的应用程序相关的详细信息，例如应用程序名称、公司域名和项目位置。
- en: Type in `HelloApp` as the application name and enter a company domain. If you
    do not have a company domain name, fill in any valid domain name in the company
    domain input box – as this is a trivial project, a legitimate domain name is not
    required. Specify the location in which you want to save this project and tick
    the checkbox for the inclusion of Kotlin support.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序名称输入为`HelloApp`，并输入公司域名。如果您没有公司域名，请在公司域名输入框中填写任何有效的域名 – 由于这是一个简单的项目，不需要合法的域名。指定您想要保存此项目的位置，并勾选包含Kotlin支持的复选框。
- en: 'After filling in the required parameters, continue to the next screen:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写了所需的参数后，继续到下一屏幕：
- en: '![](img/b17473b3-4f83-4cb4-a663-1ed9839f8840.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b17473b3-4f83-4cb4-a663-1ed9839f8840.jpg)'
- en: 'Here, we are required to specify our target devices. We are building this application
    to run on smartphones specifically, hence tick the Phone and Tablet checkbox if
    it''s not already ticked. You will notice an options menu next to each device
    option. This dropdown is used to specify the target API level for the project
    being created. An API level is an integer that uniquely identifies the framework
    API division offered by a version of the Android platform.  Select API level 15
    if not already selected and continue to the next screen:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要指定我们的目标设备。我们正在构建这个应用程序，使其在智能手机上运行，因此如果尚未勾选，请勾选“手机”和“平板电脑”复选框。您会在每个设备选项旁边注意到一个选项菜单。此下拉菜单用于指定正在创建的项目目标API级别。API级别是唯一标识Android平台版本提供的框架API分区的整数。如果尚未选择，请选择API级别15并继续到下一屏幕：
- en: '![](img/bb38d3ba-426b-4c4c-ab72-3a61befb14b3.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb38d3ba-426b-4c4c-ab72-3a61befb14b3.jpg)'
- en: On the next screen, we are required to select an activity to add to our application.
    An activity is a single screen with a unique user interface—similar to a window.
    We will discuss activities in more depth in [Chapter 2](kt-prog-ex_ch02.html),
    *Building an Android Application – Tetris*. For now, select the empty activity
    and continue to the next screen.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕上，我们需要选择要添加到应用程序中的活动。活动是一个具有独特用户界面的单个屏幕 – 类似于窗口。我们将在[第2章](kt-prog-ex_ch02.html)“构建Android应用程序
    – 沙漏游戏”中更深入地讨论活动。现在，选择空活动并继续到下一屏幕。
- en: 'Now, we need to configure the activity that we just specified should be created.
    Name the activity `HelloActivity` and ensure the Generate Layout File and Backwards
    Compatibility checkboxes are ticked:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要配置我们刚才指定的应该创建的活动。将活动命名为`HelloActivity`，并确保勾选了“生成布局文件”和“向后兼容性”复选框：
- en: '![](img/616a9a0b-f701-4c4a-be44-4af231f8d5f9.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/616a9a0b-f701-4c4a-be44-4af231f8d5f9.jpg)'
- en: Now, click the Finish button. Android Studio may take a few minutes to set up
    your project.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击“完成”按钮。Android Studio可能需要几分钟来设置您的项目。
- en: Once the setup is complete, you will be greeted by the IDE window containing
    your project files.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，您将看到一个包含项目文件的IDE窗口。
- en: Errors pertaining to the absence of required project components may be encountered
    at any point during project development. Missing components can be downloaded
    from the SDK manager.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目开发过程中，可能会在任何阶段遇到与缺少必需项目组件相关的错误。缺少的组件可以从SDK管理器中下载。
- en: 'Make sure that the project window of the IDE is open (on the navigation bar,
    select View | Tool Windows | Project) and the Android view is currently selected
    from the drop-down list at the top of the Project window. You will see the following
    files at the left-hand side of the window:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 确保IDE的项目窗口已打开（在导航栏中，选择视图 | 工具窗口 | 项目），并且Android视图当前已从项目窗口顶部的下拉列表中选择。您将在窗口的左侧看到以下文件：
- en: '`app` | `java` | `com.mydomain.helloapp` | `HelloActivity.java`: This is the
    main activity of your application. An instance of this activity is launched by
    the system when you build and run your application:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` | `java` | `com.mydomain.helloapp` | `HelloActivity.java`: 这是你的应用程序的主活动。当你构建和运行应用程序时，系统将启动这个活动的实例：'
- en: '`app` | `res` | `layout` | `activity_hello.xml`: The user interface for `HelloActivity` is
    defined within this XML file. It contains a `TextView` element placed within the
    `ViewGroup` of a `ConstraintLayout`. The text of the `TextView` has been set to
    Hello World!'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` | `res` | `layout` | `activity_hello.xml`: `HelloActivity` 的用户界面定义在这个
    XML 文件中。它包含一个放置在 `ConstraintLayout` 的 `ViewGroup` 中的 `TextView` 元素。`TextView`
    的文本已被设置为 Hello World!'
- en: '`app` | `manifests` | `AndroidManifest.xml`: The `AndroidManifest` file is
    used to describe the fundamental characteristics of your application. In addition,
    this is the file in which your application''s components are defined.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` | `manifests` | `AndroidManifest.xml`: `AndroidManifest` 文件用于描述应用程序的基本特征。此外，这也是定义应用程序组件的文件。'
- en: '`Gradle Scripts` | `build.gradle`: Two `build.gradle` files will be present
    in your project. The first `build.gradle` file is for the project and the second
    is for the app module. You will most frequently work with the module''s `build.gradle`
    file for the configuration of the compilation procedure of Gradle tools and the
    building of your app.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gradle 脚本` | `build.gradle`: 在你的项目中将存在两个 `build.gradle` 文件。第一个 `build.gradle`
    文件是针对项目的，第二个是针对应用模块的。你将最频繁地使用模块的 `build.gradle` 文件来配置 Gradle 工具的编译过程和构建你的应用。'
- en: Gradle is an open source build automation system used for the declaration of
    project configurations. In Android, Gradle is utilized as a build tool with the
    goal of building packages and managing application dependencies.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是一个开源的构建自动化系统，用于声明项目配置。在 Android 中，Gradle 被用作构建工具，目的是构建包和管理应用程序依赖项。
- en: Creating a user interface
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: A **user interface** (**UI**) is the primary means by which a user interacts
    with an application. The user interfaces of Android applications are made by the
    creation and manipulation of layout files. Layout files are XML files that exist
    in `app | res | layout`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面**（**UI**）是用户与应用程序交互的主要方式。Android 应用程序的用户界面是通过创建和操作布局文件来实现的。布局文件是存在于
    `app | res | layout` 中的 XML 文件。'
- en: 'To create the layout for the *HelloApp*, we are going to do three things:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `HelloApp` 创建布局，我们将做三件事：
- en: Add a `LinearLayout` to our layout file
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LinearLayout` 添加到我们的布局文件中
- en: Place the `TextView` within the `LinearLayout` and remove the `android:text`
    attribute it possesses
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TextView` 放置在 `LinearLayout` 中，并移除它所拥有的 `android:text` 属性
- en: Add a button to the `LinearLayout`
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `LinearLayout` 添加一个按钮
- en: 'Open the `activity_hello.xml` file if it''s not already opened. You will be
    presented with the layout editor. If the editor is in the `Design` view, change
    it to its `Text` view by toggling the option at the bottom of the layout editor.
    Now, your layout editor should look similar to that of the following screenshot:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `activity_hello.xml` 文件尚未打开，请打开它。你将看到布局编辑器。如果编辑器处于 `Design` 视图，请通过切换布局编辑器底部的选项将其更改为
    `Text` 视图。现在，你的布局编辑器应该看起来类似于以下截图：
- en: '![](img/8979d6ee-67a7-4437-8086-9170fee81d50.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8979d6ee-67a7-4437-8086-9170fee81d50.png)'
- en: 'A `LinearLayout` is a `ViewGroup` that arranges child views in either a horizontal
    or vertical manner within a single column. Copy the code snippet of our required
    `LinearLayout` from the following block and paste it within the `ConstraintLayout`
    preceding the `TextView`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout` 是一个 `ViewGroup`，它以水平或垂直方式在单列内排列子视图。从以下块中复制我们所需的 `LinearLayout`
    的代码片段，并将其粘贴到 `ConstraintLayout` 中 `TextView` 之前：'
- en: '[PRE71]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, copy and paste the `TextView` present in the `activity_hello.xml` file
    into the body of the `LinearLayout` element and remove the `android:text` attribute:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `activity_hello.xml` 文件中现有的 `TextView` 复制并粘贴到 `LinearLayout` 元素的主体中，并移除
    `android:text` 属性：
- en: '[PRE72]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Lastly, we need to add a button element to our layout file. This element will
    be a child of our `LinearLayout`. To create a button, we use the `Button` element:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将一个按钮元素添加到我们的布局文件中。这个元素将是我们的 `LinearLayout` 的子元素。要创建一个按钮，我们使用 `Button`
    元素：
- en: '[PRE73]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Toggle to the layout editor''s design view to see how the changes we have made
    thus far translate when rendered on the user interface:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到布局编辑器的设计视图，以查看我们迄今为止所做的更改在用户界面上的渲染效果：
- en: '![](img/67e7e213-d82f-4343-bc64-41c24b8b95e1.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67e7e213-d82f-4343-bc64-41c24b8b95e1.jpg)'
- en: 'Now we have our layout, but there''s a problem. Our CLICK ME! button does not
    actually do anything when clicked. We are going to fix that by adding a listener
    for click events to the button. Locate and open the `HelloActivity.java` file
    and edit the function to add the logic for the CLICK ME! button''s click event
    as well as the required package imports, as shown in the following code:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了布局，但有一个问题。我们的“点击我！”按钮在被点击时实际上并没有做任何事情。我们将通过向按钮添加点击事件监听器来解决这个问题。找到并打开`HelloActivity.java`文件，并编辑函数以添加“点击我！”按钮的点击事件逻辑以及所需的包导入，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding code snippet, we have added references to the `TextView` and
    `Button` elements present in our `activity_hello` layout file by utilizing the
    `findViewById` function. The `findViewById` function can be used to get references
    to layout elements that are within the currently-set content view. The second
    line of the `onCreate` function has set the content view of `HelloActivity` to
    the `activity_hello.xml` layout.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们通过使用`findViewById`函数添加了对`activity_hello`布局文件中存在的`TextView`和`Button`元素的引用。`findViewById`函数可以用来获取当前设置的内容视图中布局元素的引用。`onCreate`函数的第二行将`HelloActivity`的内容视图设置为`activity_hello.xml`布局。
- en: Next to the `findViewById` function identifier, we have the `TextView` type
    written between two angular brackets. This is called a function generic. It is
    being used to enforce that the resource ID being passed to the `findViewById`
    belongs to a `TextView` element.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在`findViewById`函数标识符旁边，我们有两个尖括号之间的`TextView`类型。这被称为函数泛型。它被用来强制传递给`findViewById`的资源ID属于`TextView`元素。
- en: After adding our reference objects, we set an `onClickListener` to `btnClickMe`.
    Listeners are used to listen for the occurrence of events within an application.
    In order to perform an action upon the click of an element, we pass a lambda containing
    the action to be performed to the element's `setOnClickListener` method.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加我们的引用对象后，我们为`btnClickMe`设置了一个`onClickListener`。监听器用于监听应用程序内事件的发生。为了在元素被点击时执行某个动作，我们将包含要执行的动作的lambda表达式传递给元素的`setOnClickListener`方法。
- en: When `btnClickMe` is clicked, `tvGreeting` is checked to see whether it has
    been set to contain any text. If no text has been set to the `TextView`, then
    its text is set to `Hello World!`, otherwise a toast is displayed with the `I
    have been clicked!` text.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 当`btnClickMe`被点击时，会检查`tvGreeting`是否被设置为包含任何文本。如果没有设置任何文本到`TextView`，则其文本设置为“Hello
    World!”，否则会显示包含`I have been clicked!`文本的吐司。
- en: Running the application
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'In order to run the application, click the Run ''app'' (^R) button at the top-right
    side of the IDE window and select a deployment target. The *HelloApp* will be
    built, installed, and launched on the deployment target:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行应用程序，点击IDE窗口右上角的“运行 'app' (^R)”按钮，并选择一个部署目标。`HelloApp`将在部署目标上构建、安装和启动：
- en: '![](img/2a4aec0b-7092-4aea-95ce-e661ba91f21e.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a4aec0b-7092-4aea-95ce-e661ba91f21e.jpg)'
- en: You may use one of the available prepackaged virtual devices or create a custom
    virtual device to use as the deployment target.  You may also decide to connect
    a physical Android device to your computer via USB and select it as your target.
    The choice is up to you. After selecting a deployment device, click OK to build
    and run the application.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用可用的预包装虚拟设备之一或创建一个自定义虚拟设备作为部署目标。您还可以决定通过USB将物理Android设备连接到您的计算机，并将其作为目标选择。选择权在您手中。选择部署设备后，点击“确定”以构建和运行应用程序。
- en: 'Upon launching the application, our created layout is rendered:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们创建的布局会被渲染：
- en: '![](img/134dccf4-82ae-4e5c-b69b-80e63d13f149.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/134dccf4-82ae-4e5c-b69b-80e63d13f149.jpg)'
- en: 'When CLICK ME! is clicked, Hello World! is shown to the user:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击“点击我！”时，用户会看到“Hello World！”：
- en: '![](img/89b90132-b0aa-400f-b7d6-f8a23aca8b18.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89b90132-b0aa-400f-b7d6-f8a23aca8b18.jpg)'
- en: 'Subsequent clicks of the CLICK ME! button display a toast message with the
    text I have been clicked!:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的点击“点击我！”按钮会显示包含文本“我已经被点击了！”的吐司消息：
- en: '![](img/f1a6b1ca-4330-4ef1-9ea7-d16afeb0ddb5.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1a6b1ca-4330-4ef1-9ea7-d16afeb0ddb5.jpg)'
- en: Fundamentals of the web
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络基础
- en: Most applications communicate with a server in one way or another. It is imperative
    that you understand a number of concepts related to the web before continuing
    in this book. This section explains those concepts concisely.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序以某种方式与服务器进行通信。在继续阅读本书之前，了解与网络相关的几个概念至关重要。本节简要解释了这些概念。
- en: What is the web?
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是网络？
- en: The web is a complex system of interconnected systems possessing the ability
    to communicate with other systems existing on a common network via one or more
    protocols. A protocol is an official, well-defined system of rules governing the
    exchange of information between devices.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个由相互连接的系统组成的复杂系统，它能够通过一个或多个协议与存在于公共网络上的其他系统进行通信。协议是一种官方的、定义良好的规则系统，用于规范设备之间信息交换。
- en: Hypertext Transfer Protocol
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超文本传输协议
- en: All communications over the web are made in accordance with a protocol. A particularly
    important protocol for fostering communication between systems is the **Hypertext
    Transfer Protocol** (**HTTP**).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通过网络的通信都是按照协议进行的。对于促进系统间通信来说，一个特别重要的协议是**超文本传输协议**（**HTTP**）。
- en: Billions of images, videos, text files, documents, and other files are transferred
    across the internet on a daily basis. These files are all transferred through
    HTTP. HTTP is an application protocol for distributed and hypermedia information
    systems. It can be said to be a foundational component for communication across
    the internet. A major benefit of using HTTP for data transfer across systems is
    that it is highly reliable. This is as a result of its utilization of reliable
    protocols, such as the **Transmission Control Protocol** (**TCP**) and **Internet
    Protocol** (**IP**).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 每天都有数十亿的张图片、视频、文本文件、文档和其他文件通过互联网传输。这些文件都是通过 HTTP 传输的。HTTP 是一种用于分布式和超媒体信息系统的应用协议。它可以被认为是互联网通信的基础组件。使用
    HTTP 在系统间传输数据的主要好处是它非常可靠。这是由于其利用了可靠的协议，如**传输控制协议**（**TCP**）和**互联网协议**（**IP**）。
- en: Clients and servers
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端和服务器
- en: A web client is any application that communicates with a web server utilizing
    HTTP. A web server is a computer that provides – or serves – web resources to
    web clients. A web resource is anything that provides web content. A web resource
    can be a media file, an HTML document, a gateway, and so on. Clients need web
    content for various purposes, such as information rendering and data manipulation.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 网络客户端是任何使用 HTTP 与网络服务器通信的应用程序。网络服务器是一台提供或服务网络资源的计算机。网络资源是提供网络内容的一切。网络资源可以是媒体文件、HTML
    文档、网关等。客户端需要网络内容用于各种目的，如信息呈现和数据操作。
- en: Clients and servers communicate with each other via HTTP. One major reason for
    the utilization of HTTP is the fact that it is extremely reliable in data transmission.
    The use of HTTP ensures data loss does not occur in a request-response cycle.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器通过 HTTP 进行通信。使用 HTTP 的一个主要原因是它在数据传输方面极其可靠。使用 HTTP 确保在请求-响应周期中不会发生数据丢失。
- en: HTTP requests and responses
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 请求和响应
- en: 'An HTTP request – as the name replies – is a solicitation for a web resource
    sent by a web client to a server over HTTP. An HTTP response is a reply – sent
    by a server – to a request in an HTTP transaction:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求——正如其名所示——是由网络客户端通过 HTTP 发送到服务器的对网络资源的请求。HTTP 响应是对 HTTP 事务中请求的回复——由服务器发送：
- en: '![](img/d15fab31-e348-4be5-b95d-7f0f39fb57cd.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d15fab31-e348-4be5-b95d-7f0f39fb57cd.jpg)'
- en: HTTP methods
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: 'HTTP supports a number of request methods. These methods can also be referred
    to as commands. HTTP methods specify the type of action to be performed by the
    server. Some common HTTP methods are tabularized as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 支持多种请求方法。这些方法也可以称为命令。HTTP 方法指定服务器要执行的操作类型。一些常见的 HTTP 方法如下表所示：
- en: '| **HTTP method** | **Description** |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 方法** | **描述** |'
- en: '| GET | Retrieves a named resource present on the client. |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| GET | 从客户端检索一个命名的资源。|'
- en: '| POST | Sends data from a client to a server. |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| POST | 从客户端向服务器发送数据。|'
- en: '| DELETE | Deletes a named resource residing on a server. |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | 删除服务器上驻留的命名资源。|'
- en: '| PUT | Store data collected by the client in a named resource residing on
    the server. |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 将客户端收集的数据存储在服务器上名为资源的存储中。|'
- en: '| OPTIONS | Returns HTTP methods that the server supports. |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| OPTIONS | 返回服务器支持的所有 HTTP 方法。|'
- en: '| HEAD | Retrieves HTTP headers with no content. |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| HEAD | 获取没有内容的 HTTP 头部信息。|'
- en: Summary
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to Kotlin and explored its fundamentals.
    In the process, we learned how to install Kotlin on a computer, what an IDE is,
    the IDEs at your disposal for writing programs in Kotlin, how to write and run
    Kotlin scripts, and how to use the REPL. In addition, we learned how to work with
    both IntelliJ IDEA and Android Studio, after which we implemented a simple Android
    application. Lastly, we had a look at the fundamental concepts related to the
    web.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Kotlin并探讨了其基础知识。在这个过程中，我们学习了如何在计算机上安装Kotlin，什么是IDE，可用于编写Kotlin程序的IDE，如何编写和运行Kotlin脚本，以及如何使用REPL。此外，我们还学习了如何使用IntelliJ
    IDEA和Android Studio，之后我们实现了一个简单的Android应用程序。最后，我们回顾了与网络相关的根本概念。
- en: In the next chapter, we will get more familiar with writing Kotlin programs
    by creating an Android application. We will take a look at the Android application
    architecture and the important components of an Android application, as well as
    many more topics.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过创建一个Android应用程序来更熟悉地编写Kotlin程序。我们将探讨Android应用程序架构以及Android应用程序的重要组件，以及更多主题。
