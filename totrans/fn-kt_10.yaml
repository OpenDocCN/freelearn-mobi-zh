- en: Functors, Applicatives, and Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functors, applicatives, and monads are among the most searched words related
    to functional programming, which makes sense if you consider that no-one knows
    what they mean (not really, there are bright people that know what they''re talking
    about). The confusion about monads, in particular, has become a joke/meme in the
    programming community:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A monad is a monoid in the category of endofunctors, what''s the problem?"'
  prefs: []
  type: TYPE_NORMAL
- en: This quote is fictionally attributed to Philip Wadler by James Iry on his classic
    blog post, *A Brief, Incomplete and Mostly Wrong History of Programming Languages,*
    ([http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html](http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options, lists, and functions as functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if I told you that you already use functors in Kotlin? Surprised? Let''s
    have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `List<T>` class has a function, `map(transform: (T) -> R): List<R>`.  Where
    does the name `map` come from? It came from category theory. What we do when we
    transform from `Int` to `String`, is we map from the `Int` category to the `String`
    category. In the same sense, in our example, we transform from `List<Int>` to
    `List<Int>` (not that exciting), and then from `List<Int>` to `List<String>`.
    We didn''t change the external type, just the internal value.'
  prefs: []
  type: TYPE_NORMAL
- en: And that is a functor. A **functor** is a type that defines a way to transform
    or to map its content. You can find different definitions of a functor, more or
    less academic; but in principle, all point to the same direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a generic interface for a functor type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And, it doesn't compile because Kotlin doesn't support higher-kinded types.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find more information on higher-kinded types for Kotlin, including alternatives
    and the future of Kotlin, in [Chapter 13](e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml),
    *Arrow Types***.**
  prefs: []
  type: TYPE_NORMAL
- en: 'In languages that support higher-kinded types, such as **Scala** and **Haskell**,
    it is possible to define a `Functor` type, for example, the Scala cats functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In Kotlin, we don't have those features, but we can simulate them by convention.
    If a type has a function or an extension function, then `map` is a functor (this
    is called **structural typing**, defining a type by its structure rather than
    its hierarchy).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have a simple `Option` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can define a `map` function for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, an `Option` value will behave differently for `Some` and `None:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Extension functions are so flexible that we can write a `map` function for
    a function type, `(A) -> B`, therefore, transforming functions into functors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are changing here is the return type from `B` to `C` by applying the
    parameter function, `transform: (B) -> C` to the result of the function `(A) ->
    B` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you have experience in other functional programming languages, recognize
    this behavior as forward function composition (more on function composition in
    [Chapter 12](54f4e874-0af4-411a-9820-369d4683e40a.xhtml), *Getting Started with
    Arrow).*
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **monad** is a functor type that defines a `flatMap` (or `bind`, in other
    languages) function, that receives a lambda that returns the same type. Let me
    explain it with an example. Luckily for us, `List<T>` defines a `flatMap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In a `map` function, we just transform the `List` value's content, but in `flatMap`,
    we can return a new `List` type with less or more items, making it a lot more
    potent than `map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a generic monad will look like this (just remember that we don''t have
    higher-kinded types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write a `flatMap` function for our `Option` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pay close attention, you can see that `flatMap` and map look very similar;
    so similar that we can rewrite `map` using `flatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can use a `flatMap` function''s power in cool ways that will be
    impossible with a plain map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our function, `calculateDiscount`, receives and returns `Option<Double>`. If
    the price is higher than `50.0`, we return a discount of `5.0` wrapped on `Some`,
    and `None` if it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'One cool trick with `flatMap` is that it can be nested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the inner `flatMap` function, we have access to both values and operate over
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this example in a slightly shorter way by combining `flatMap`
    and `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As such, we can rewrite our first `flatMap` example as a composition of two
    lists—one of numbers and another one of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This technique of nesting several `flatMap` or combinations of `flatMap` with
    `map` is very powerful and is the primary idea behind another concept named monadic
    comprehensions, which allow us to combine monadic operations (more about comprehensions
    in [Chapter 13](e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml), *Arrow Types*).
  prefs: []
  type: TYPE_NORMAL
- en: Applicatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our previous example, invoking a lambda inside a wrapper with a parameter inside
    the same kind of wrapper, is the perfect way to introduce applicatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'An **applicative** is a type that defines two functions, a `pure(t: T)` function
    that returns the `T` value wrapped in the applicative type, and an `ap` function (`apply`,
    in other languages) that receives a lambda wrapped in the applicative type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, when we explained monads, we made them extend directly
    from a functor but in reality, a monad extends from an applicative and an applicative
    extends from a functor. Therefore, our pseudo code for a generic applicative,
    and the entire hierarchy, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In short, an applicative is a more powerful functor, and a monad is a more powerful
    applicative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write an `ap` extension function for `List<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can revisit our last example from the *Monads* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite it with the `ap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Easier to read, but with a caveat—the result is in a different order. We need
    to be aware and choose which option is appropriate for our particular case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add `pure` and `ap` to our `Option` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Option.pure` is just a simple alias for the `Option.Some` constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Option.ap` function is fascinating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Both `Option.ap` and `List.ap` have the same body, using a combination of `flatMap`
    and `map`, which is precisely how we combine monadic operations.
  prefs: []
  type: TYPE_NORMAL
- en: With monads, we summed two `Option<Int>` using `flatMap` and `map:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using applicatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That is not very easy to read. First, we map `maybeFive` with a lambda `(Int)
    -> (Int) -> Int` (technically, a curried function, and there is more information
    about curried functions in [Chapter 12](54f4e874-0af4-411a-9820-369d4683e40a.xhtml),
    *Getting Started with Arrow*), that returns an `Option<(Int) -> Int>` that can
    be passed as a parameter for `maybeTwo.ap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make things easier to read with a little trick (that I''m borrowing
    from Haskell):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `infix` extension function `` Option<(T) -> R>.`(*)` `` will let us read
    the `sum` operation from left to right; how cool is that? Now, let's look at the
    following code, summing two `Option<Int>` using applicatives
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We wrap the `(Int) -> (Int) -> Int` lambda with the `pure` function and then
    we apply `Option<Int>`, one by one. We use the name `` `(*)` `` as a homage to
    Haskell's `<*>`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you can see that applicatives let you do some cool tricks, but monads
    are more powerful and flexible. When do use one or the other? It obviously depends
    on your particular problem, but our general advice is to use the abstraction with
    the least amount of power possible. You can start with a functor's `map`, then
    an applicative's `ap`, and lastly a monad's `flatMap`. Everything can be done
    with `flatMap` (as you can see  `Option`, `map`, and `ap` were implemented using
    `flatMap`), but most of the time `map` and `ap` can be more accessible to reason
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to functions, we can make a function behave as an applicative.
    First, we should add a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an object `Function1`, as the function type `(A) -> B` doesn't
    have a companion object to add new extension functions as we did with `Option:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Function1.pure(t: T)` will wrap a `T` value in a function and will return
    it, regardless of the parameter that we use. If you have experience with other
    functional languages, you''ll recognize function''s `pure` as an `identity` function
    (more about `identity` functions in [Chapter 12](54f4e874-0af4-411a-9820-369d4683e40a.xhtml),
    *Getting Started with Arrow*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `flatMap`, an `ap`, to a function `(A) -> B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We already cover `map(transform: (B) -> C): (A) -> C` and we know that it behaves
    as a forward function composition. If you pay close attention to `flatMap` and
    `ap`, you''ll see that the parameter is kind of backwards (and that `ap` is implemented
    as all the other `ap` functions for other types).'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, what can we do with the function''s `ap`? Let''s look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we can compose functions, which is not exciting at all because we already
    did that with `map`. But there is a little trick with function''s `ap`. We can
    access the original parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the original parameter in a function composition is useful in several
    scenarios, such as debugging and auditing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of cool concepts with scary names but with simple ideas
    behind them. The functor, applicative, and monad types open the door for several
    abstractions and more powerful functional concepts that we'll cover in the following
    chapters. We learned about some of the limitations of Kotlin and how we can overcome
    them as we create functions to mimic functor, applicative, and monad for different
    types. We also explored the hierarchical relationship between functors, applicatives,
    and monads.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover  how to work effectively with Streams of data.
  prefs: []
  type: TYPE_NORMAL
