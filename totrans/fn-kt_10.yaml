- en: Functors, Applicatives, and Monads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子、应用和函子
- en: 'Functors, applicatives, and monads are among the most searched words related
    to functional programming, which makes sense if you consider that no-one knows
    what they mean (not really, there are bright people that know what they''re talking
    about). The confusion about monads, in particular, has become a joke/meme in the
    programming community:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函子、应用和函子是关于函数式编程中最常搜索的词汇之一，如果你考虑到没有人知道它们的意思（实际上，有一些聪明的人知道他们在说什么），这就有意义了。特别是关于函子的混淆已经成为编程社区中的一个笑话/模因：
- en: '"A monad is a monoid in the category of endofunctors, what''s the problem?"'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “一个函子是端内函子的范畴中的幺半群，有什么问题？”
- en: This quote is fictionally attributed to Philip Wadler by James Iry on his classic
    blog post, *A Brief, Incomplete and Mostly Wrong History of Programming Languages,*
    ([http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html](http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话是虚构地归因于詹姆斯·艾里（James Iry）在他的经典博客文章《编程语言的简短、不完整且大部分错误的历史》中引用的菲利普·瓦德勒（Philip
    Wadler），([http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html](http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html))。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Functors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Options, lists, and functions as functors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项、列表和作为函子的函数
- en: Monads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩纳哥（Monads）
- en: Applicatives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用（Applicatives）
- en: Functors
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子（Functors）
- en: 'What if I told you that you already use functors in Kotlin? Surprised? Let''s
    have a look at the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，你已经在 Kotlin 中使用了函子，你会感到惊讶吗？让我们看看以下代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `List<T>` class has a function, `map(transform: (T) -> R): List<R>`.  Where
    does the name `map` come from? It came from category theory. What we do when we
    transform from `Int` to `String`, is we map from the `Int` category to the `String`
    category. In the same sense, in our example, we transform from `List<Int>` to
    `List<Int>` (not that exciting), and then from `List<Int>` to `List<String>`.
    We didn''t change the external type, just the internal value.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 类有一个函数，`map(transform: (T) -> R): List<R>`。`map` 这个名字是从哪里来的？它来自范畴论。当我们从
    `Int` 转换到 `String` 时，我们是从 `Int` 范畴映射到 `String` 范畴。在同样的意义上，在我们的例子中，我们是从 `List<Int>`
    转换到 `List<Int>`（不是很令人兴奋），然后从 `List<Int>` 转换到 `List<String>`。我们没有改变外部类型，只是内部值。'
- en: And that is a functor. A **functor** is a type that defines a way to transform
    or to map its content. You can find different definitions of a functor, more or
    less academic; but in principle, all point to the same direction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是一个函子。一个 **函子** 是一个定义了如何转换或映射其内容的类型。你可以找到关于函子的不同定义，或多或少是学术性的；但原则上，它们都指向同一个方向。
- en: 'Let''s define a generic interface for a functor type:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为函子类型定义一个泛型接口：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And, it doesn't compile because Kotlin doesn't support higher-kinded types.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它无法编译，因为 Kotlin 不支持高阶类型。
- en: You'll find more information on higher-kinded types for Kotlin, including alternatives
    and the future of Kotlin, in [Chapter 13](e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml),
    *Arrow Types***.**
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第 13 章 [Chapter 13](e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml) 中找到关于 Kotlin
    高阶类型（包括替代方案和 Kotlin 的未来）的更多信息，*箭头类型***。
- en: 'In languages that support higher-kinded types, such as **Scala** and **Haskell**,
    it is possible to define a `Functor` type, for example, the Scala cats functor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持高阶类型的语言中，例如 **Scala** 和 **Haskell**，可以定义一个 `Functor` 类型，例如 Scala cats 函子：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In Kotlin, we don't have those features, but we can simulate them by convention.
    If a type has a function or an extension function, then `map` is a functor (this
    is called **structural typing**, defining a type by its structure rather than
    its hierarchy).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，我们没有这些功能，但我们可以通过约定来模拟它们。如果一个类型有一个函数或扩展函数，那么 `map` 就是一个函子（这被称为**结构化类型**，通过其结构而不是其层次来定义类型）。
- en: 'We can have a simple `Option` type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个简单的 `Option` 类型：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, you can define a `map` function for it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以为它定义一个 `map` 函数：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And use it in the following way:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式使用它：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, an `Option` value will behave differently for `Some` and `None:`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个 `Option` 值对于 `Some` 和 `None` 将有不同的行为：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Extension functions are so flexible that we can write a `map` function for
    a function type, `(A) -> B`, therefore, transforming functions into functors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数非常灵活，以至于我们可以为函数类型编写一个 `map` 函数，即 `(A) -> B`，因此将函数转换为函子：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What we are changing here is the return type from `B` to `C` by applying the
    parameter function, `transform: (B) -> C` to the result of the function `(A) ->
    B` itself:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里改变的是通过应用参数函数 `transform: (B) -> C` 到函数 `(A) -> B` 的结果，将返回类型从 `B` 改为 `C`：'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you have experience in other functional programming languages, recognize
    this behavior as forward function composition (more on function composition in
    [Chapter 12](54f4e874-0af4-411a-9820-369d4683e40a.xhtml), *Getting Started with
    Arrow).*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在其他函数式编程语言中有所经验，你会认出这种行为是前向函数组合（更多关于函数组合的内容请参阅 [第 12 章](54f4e874-0af4-411a-9820-369d4683e40a.xhtml)，*使用箭头入门）。
- en: Monads
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monads
- en: 'A **monad** is a functor type that defines a `flatMap` (or `bind`, in other
    languages) function, that receives a lambda that returns the same type. Let me
    explain it with an example. Luckily for us, `List<T>` defines a `flatMap` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**monad** 是一个定义了 `flatMap`（或在其他语言中的 `bind`）函数的 funtor 类型，该函数接收一个返回相同类型的 lambda。让我用一个例子来解释它。幸运的是，`List<T>`
    定义了一个 `flatMap` 函数：'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In a `map` function, we just transform the `List` value's content, but in `flatMap`,
    we can return a new `List` type with less or more items, making it a lot more
    potent than `map`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `map` 函数中，我们只是转换 `List` 值的内容，但在 `flatMap` 中，我们可以返回一个具有更少或更多项的新 `List` 类型，这使得它比
    `map` 更强大得多。
- en: 'So, a generic monad will look like this (just remember that we don''t have
    higher-kinded types):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个通用的 monad 将看起来像这样（记住我们没有高阶类型）：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can write a `flatMap` function for our `Option` type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的 `Option` 类型编写一个 `flatMap` 函数：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you pay close attention, you can see that `flatMap` and map look very similar;
    so similar that we can rewrite `map` using `flatMap`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现 `flatMap` 和 `map` 非常相似；相似到我们可以用 `flatMap` 重写 `map`：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And now we can use a `flatMap` function''s power in cool ways that will be
    impossible with a plain map:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用 `flatMap` 函数的强大功能以一些酷炫的方式使用它，这些方式在普通的 `map` 中是不可能的：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our function, `calculateDiscount`, receives and returns `Option<Double>`. If
    the price is higher than `50.0`, we return a discount of `5.0` wrapped on `Some`,
    and `None` if it doesn't.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能函数 `calculateDiscount` 接收并返回 `Option<Double>`。如果价格高于 `50.0`，我们返回一个包裹在 `Some`
    中的 `5.0` 折扣，如果没有，则返回 `None`。
- en: 'One cool trick with `flatMap` is that it can be nested:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 的一个酷炫技巧是它可以嵌套：'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the inner `flatMap` function, we have access to both values and operate over
    them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部的 `flatMap` 函数中，我们可以访问这两个值并对它们进行操作。
- en: 'We can write this example in a slightly shorter way by combining `flatMap`
    and `map`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合 `flatMap` 和 `map` 来稍微缩短这个示例的写法：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As such, we can rewrite our first `flatMap` example as a composition of two
    lists—one of numbers and another one of functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的第一个 `flatMap` 示例重写为两个列表的组合——一个包含数字，另一个包含函数：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This technique of nesting several `flatMap` or combinations of `flatMap` with
    `map` is very powerful and is the primary idea behind another concept named monadic
    comprehensions, which allow us to combine monadic operations (more about comprehensions
    in [Chapter 13](e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml), *Arrow Types*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套多个 `flatMap` 或 `flatMap` 与 `map` 组合的技术非常强大，并且是另一个名为 monadic comprehensions（[第
    13 章](e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml)，*箭头类型*）的概念背后的主要思想，它允许我们组合 monadic
    操作（更多关于 comprehensions 的内容请参阅）。
- en: Applicatives
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Applicatives
- en: Our previous example, invoking a lambda inside a wrapper with a parameter inside
    the same kind of wrapper, is the perfect way to introduce applicatives.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子，在同一个类型的包装器内部调用 lambda，并在同一个包装器内部传递参数，是介绍 applicatives 的完美方式。
- en: 'An **applicative** is a type that defines two functions, a `pure(t: T)` function
    that returns the `T` value wrapped in the applicative type, and an `ap` function (`apply`,
    in other languages) that receives a lambda wrapped in the applicative type.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**applicative** 是一个定义了两个函数的类型，一个 `pure(t: T)` 函数，它返回包裹在 applicative 类型中的 `T`
    值，以及一个 `ap` 函数（在其他语言中称为 `apply`），它接收一个包裹在 applicative 类型中的 lambda。'
- en: 'In the previous section, when we explained monads, we made them extend directly
    from a functor but in reality, a monad extends from an applicative and an applicative
    extends from a functor. Therefore, our pseudo code for a generic applicative,
    and the entire hierarchy, will look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当我们解释 monads 时，我们让它们直接从 funtor 扩展，但事实上，monad 是从 applicative 扩展的，而 applicative
    是从 funtor 扩展的。因此，我们的通用 applicative 的伪代码以及整个层次结构将看起来像这样：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In short, an applicative is a more powerful functor, and a monad is a more powerful
    applicative.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一个 applicative 是一个更强大的 funtor，而一个 monad 是一个更强大的 applicative。
- en: 'Now, let''s write an `ap` extension function for `List<T>`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为 `List<T>` 写一个 `ap` 扩展函数：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And we can revisit our last example from the *Monads* section:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回顾一下上一节中 *Monads* 部分的最后一个示例：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s rewrite it with the `ap` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `ap` 函数来重写它：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Easier to read, but with a caveat—the result is in a different order. We need
    to be aware and choose which option is appropriate for our particular case.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更容易阅读，但有一个警告——结果顺序不同。我们需要意识到并选择适合我们特定情况的最佳选项。
- en: 'We can add `pure` and `ap` to our `Option` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的`Option`类添加`pure`和`ap`：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Option.pure` is just a simple alias for the `Option.Some` constructor.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option.pure`只是`Option.Some`构造函数的一个简单别名。'
- en: 'Our `Option.ap` function is fascinating:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Option.ap`函数非常迷人：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both `Option.ap` and `List.ap` have the same body, using a combination of `flatMap`
    and `map`, which is precisely how we combine monadic operations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option.ap`和`List.ap`有相同的主体，使用`flatMap`和`map`的组合，这正是我们组合单子操作的方式。'
- en: With monads, we summed two `Option<Int>` using `flatMap` and `map:`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单子，我们使用`flatMap`和`map`对两个`Option<Int>`进行求和：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, using applicatives:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用应用函数：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That is not very easy to read. First, we map `maybeFive` with a lambda `(Int)
    -> (Int) -> Int` (technically, a curried function, and there is more information
    about curried functions in [Chapter 12](54f4e874-0af4-411a-9820-369d4683e40a.xhtml),
    *Getting Started with Arrow*), that returns an `Option<(Int) -> Int>` that can
    be passed as a parameter for `maybeTwo.ap`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很容易阅读。首先，我们使用一个lambda `(Int) -> (Int) -> Int`（技术上是一个柯里化函数，关于柯里化函数的更多信息可以在[第12章](54f4e874-0af4-411a-9820-369d4683e40a.xhtml)，*开始使用Arrow*）来映射`maybeFive`，它返回一个`Option<(Int)
    -> Int>`，可以作为`maybeTwo.ap`的参数。
- en: 'We can make things easier to read with a little trick (that I''m borrowing
    from Haskell):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个小技巧（我从Haskell那里借来的）使事情更容易阅读：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `infix` extension function `` Option<(T) -> R>.`(*)` `` will let us read
    the `sum` operation from left to right; how cool is that? Now, let's look at the
    following code, summing two `Option<Int>` using applicatives
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`infix`扩展函数`Option<(T) -> R>.`(*)` ``将允许我们从左到右读取`sum`操作；这有多酷？现在，让我们看看以下代码，它是使用应用函数对两个`Option<Int>`进行求和'
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We wrap the `(Int) -> (Int) -> Int` lambda with the `pure` function and then
    we apply `Option<Int>`, one by one. We use the name `` `(*)` `` as a homage to
    Haskell's `<*>`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`pure`函数包装`(Int) -> (Int) -> Int` lambda，然后逐个应用`Option<Int>`。我们使用名称`(*)`作为对Haskell的`<*>`的致敬。
- en: So far, you can see that applicatives let you do some cool tricks, but monads
    are more powerful and flexible. When do use one or the other? It obviously depends
    on your particular problem, but our general advice is to use the abstraction with
    the least amount of power possible. You can start with a functor's `map`, then
    an applicative's `ap`, and lastly a monad's `flatMap`. Everything can be done
    with `flatMap` (as you can see  `Option`, `map`, and `ap` were implemented using
    `flatMap`), but most of the time `map` and `ap` can be more accessible to reason
    about it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以看到应用函数让你可以做一些很酷的技巧，但单子更强大、更灵活。何时使用一个或另一个？这显然取决于你的特定问题，但我们的总体建议是使用尽可能少权力的抽象。你可以从函子`map`开始，然后是应用函数`ap`，最后是单子`flatMap`。所有的事情都可以用`flatMap`来完成（正如你所见，`Option`、`map`和`ap`都是使用`flatMap`实现的），但大多数时候`map`和`ap`可以更容易地推理。
- en: 'Coming back to functions, we can make a function behave as an applicative.
    First, we should add a pure function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回到函数，我们可以使一个函数表现得像一个应用函数。首先，我们应该添加一个纯函数：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we create an object `Function1`, as the function type `(A) -> B` doesn't
    have a companion object to add new extension functions as we did with `Option:`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个对象`Function1`，因为函数类型`(A) -> B`没有伴随对象来添加新的扩展函数，就像我们为`Option`所做的那样：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Function1.pure(t: T)` will wrap a `T` value in a function and will return
    it, regardless of the parameter that we use. If you have experience with other
    functional languages, you''ll recognize function''s `pure` as an `identity` function
    (more about `identity` functions in [Chapter 12](54f4e874-0af4-411a-9820-369d4683e40a.xhtml),
    *Getting Started with Arrow*).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function1.pure(t: T)`将一个`T`值包装在一个函数中并返回它，无论我们使用什么参数。如果你有其他函数式语言的经验，你会认出函数的`pure`作为一个`identity`函数（关于`identity`函数的更多信息可以在[第12章](54f4e874-0af4-411a-9820-369d4683e40a.xhtml)，*开始使用Arrow*）。'
- en: 'Let''s add `flatMap`, an `ap`, to a function `(A) -> B`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个函数`(A) -> B`中添加`flatMap`和`ap`：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We already cover `map(transform: (B) -> C): (A) -> C` and we know that it behaves
    as a forward function composition. If you pay close attention to `flatMap` and
    `ap`, you''ll see that the parameter is kind of backwards (and that `ap` is implemented
    as all the other `ap` functions for other types).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经涵盖了`map(transform: (B) -> C): (A) -> C`，并且我们知道它表现得像一个正向函数组合。如果你仔细观察`flatMap`和`ap`，你会看到参数有点反方向（并且`ap`被实现为所有其他类型的`ap`函数）。'
- en: 'But, what can we do with the function''s `ap`? Let''s look at the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们能用函数的 `ap` 做些什么呢？让我们看看下面的代码：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Well, we can compose functions, which is not exciting at all because we already
    did that with `map`. But there is a little trick with function''s `ap`. We can
    access the original parameter:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们可以组合函数，这并不令人兴奋，因为我们已经用 `map` 做过这样的事情。但是函数的 `ap` 有一个小技巧。我们可以访问原始参数：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Accessing the original parameter in a function composition is useful in several
    scenarios, such as debugging and auditing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数组合中访问原始参数在多个场景下很有用，例如调试和审计。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered a lot of cool concepts with scary names but with simple ideas
    behind them. The functor, applicative, and monad types open the door for several
    abstractions and more powerful functional concepts that we'll cover in the following
    chapters. We learned about some of the limitations of Kotlin and how we can overcome
    them as we create functions to mimic functor, applicative, and monad for different
    types. We also explored the hierarchical relationship between functors, applicatives,
    and monads.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了很多名字吓人但背后理念简单的酷概念。函子、应用和单子类型为我们打开了几种抽象和更强大的函数概念的大门，这些内容我们将在接下来的章节中介绍。我们学习了
    Kotlin 的一些局限性以及我们如何在创建函数来模拟不同类型的函子、应用和单子时克服它们。我们还探讨了函子、应用和单子之间的层次关系。
- en: In the next chapter, we'll cover  how to work effectively with Streams of data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何有效地处理数据流。
