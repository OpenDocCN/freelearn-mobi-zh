<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer008">&#13;
			<h1 id="_idParaDest-62"><em class="italic"><a id="_idTextAnchor062"/>Chapter 2</em>: Working with Creational Patterns</h1>&#13;
			<p>In this chapter, we'll cover how classic <strong class="bold">creational patterns</strong> are implemented using <strong class="bold">Kotlin</strong>. These patterns deal with <em class="italic">how</em> and <em class="italic">when</em> you <em class="italic">create</em> your objects. For each design pattern, we will discuss what it aims to achieve and how Kotlin accommodates those needs.</p>&#13;
			<p>We will cover the following topics in this chapter:</p>&#13;
			<ul>&#13;
				<li>Singleton</li>&#13;
				<li>Factory Method</li>&#13;
				<li>Abstract Factory</li>&#13;
				<li>Builder</li>&#13;
				<li>Prototype</li>&#13;
			</ul>&#13;
			<p>Mastering these design patterns will allow you to manage your objects better, adapt well to changes, and write code that is easy to maintain.</p>&#13;
			<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>Technical requirements</h1>&#13;
			<p>For this chapter, you will need to install the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">IntelliJ IDEA</strong> <strong class="bold">Community Edition</strong> (<a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a>)</li>&#13;
				<li><strong class="bold">OpenJDK</strong> <strong class="bold">11</strong> (or higher) (<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a>)</li>&#13;
			</ul>&#13;
			<p>You can find the code files for this chapter on <strong class="bold">GitHub</strong> at <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02</a>.</p>&#13;
			<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Singleton</h1>&#13;
			<p><strong class="bold">Singleton</strong> – the most<a id="_idIndexMarker128"/> popular bachelor in town. Everybody knows him, everybody talks <a id="_idIndexMarker129"/>about him, and everybody knows where to look for him.</p>&#13;
			<p>Even people who don't like using design patterns will know Singleton by name. At one point, it was even proclaimed<a id="_idIndexMarker130"/> an <strong class="bold">anti-pattern</strong>, but only because of its wide popularity.</p>&#13;
			<p><em class="italic">So, for those who are encountering it for the first time, what is this design pattern all about?</em></p>&#13;
			<p>Usually, if you have a class, you can create as many instances of it as you want. For example, let's say that we both are asked to list all of our favorite movies:</p>&#13;
			<p class="source-code">val myFavoriteMovies = listOf("Black Hawk Down", "Blade   Runner")</p>&#13;
			<p class="source-code">val yourFavoriteMovies = listOf(...)</p>&#13;
			<p>Note that we can create as many instances of <strong class="source-inline">List</strong> as we want, and there's no problem with that. Most classes can have multiple instances. </p>&#13;
			<p><em class="italic">Next, what if we both want to list the best movies in the Quick and Angry series?</em></p>&#13;
			<p class="source-code">val myFavoriteQuickAndAngryMovies = listOf()</p>&#13;
			<p class="source-code">val yourFavoriteQuickAndAngryMovies = listOf()</p>&#13;
			<p>Note that these two lists are exactly the same because they are empty. And they will stay empty because they are immutable and because the <em class="italic">Quick and Angry</em> series is simply horrendous. I hope you would agree with that.</p>&#13;
			<p>Since these two instances of a class are exactly the same, according to the <strong class="bold">equals method</strong>, it doesn't make much sense to keep them in memory multiple times. It would be great if all references to an empty list pointed to the same instance of an object. And in fact, that's what happens with null, if you think about it. All nulls are the same.</p>&#13;
			<p>That's the main idea behind the Singleton design pattern.</p>&#13;
			<p>There are a couple of <a id="_idIndexMarker131"/>requirements for the Singleton design pattern:</p>&#13;
			<ul>&#13;
				<li>We should have exactly one instance in our system.</li>&#13;
				<li>This instance should<a id="_idIndexMarker132"/> be accessible from any <a id="_idIndexMarker133"/>part of our system.</li>&#13;
			</ul>&#13;
			<p>In <strong class="bold">Java</strong> and some<a id="_idIndexMarker134"/> other languages, this task is quite complex. First, you need to forbid new instances of an object being created by making a constructor for the <strong class="source-inline">private</strong> class. Then, you also need to make sure that instantiation is preferably lazy, thread-safe, and performant, with the following requirements:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Lazy</strong>: We might not want to instantiate a singleton object when our program starts, as this may be an expensive operation. We would like to instantiate it only when it's needed for the first time.</li>&#13;
				<li><strong class="bold">Thread-safe</strong>: If two threads are trying to instantiate a singleton object at the same time, they both should receive the same instance and not two different instances. If you're not familiar with this concept, we'll cover it in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>.</li>&#13;
				<li><strong class="bold">Performant</strong>: If many threads are trying to instantiate a singleton object at the same time, we shouldn't block them for a long period of time, as this will be halting their execution.</li>&#13;
			</ul>&#13;
			<p>Meeting all of these requirements in Java or <strong class="bold">C++</strong> is <a id="_idIndexMarker135"/>quite difficult, or at least very verbose.</p>&#13;
			<p>Kotlin makes creating <a id="_idIndexMarker136"/>singletons easy by introducing a keyword called <strong class="source-inline">object</strong>. You may recognize this keyword from <strong class="bold">Scala</strong>. By using this keyword, we'll get an implementation of a singleton object, which accommodates all of our requirements.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">The <strong class="source-inline">object</strong> keyword is used for more than just creating singletons. We'll discuss this in depth later in this chapter.</p>&#13;
			<p>We declare objects just like a regular class but with no constructor, as a singleton object cannot be instantiated by us:</p>&#13;
			<p class="source-code">object NoMoviesList</p>&#13;
			<p>From now on, we can access <strong class="source-inline">NoMoviesList</strong> from anywhere in our code, and there will be exactly one instance of it:</p>&#13;
			<p class="source-code">val myFavoriteQuickAndAngryMovies = NoMoviesList</p>&#13;
			<p class="source-code">val yourFavoriteQuickAndAngryMovies = NoMoviesList</p>&#13;
			<p class="source-code">println(myFavoriteQuickAndAngryMovies <strong class="bold">===</strong> </p>&#13;
			<p class="source-code">    yourFavoriteQuickAndAngryMovies) // true</p>&#13;
			<p>Take note of the<a id="_idIndexMarker137"/> referential equality sign that checks that two variables point to the same object in memory. <em class="italic">Is this really a list though?</em></p>&#13;
			<p>Let's create a function that prints the list of our movies:</p>&#13;
			<p class="source-code">fun printMovies(movies: List&lt;String&gt;) {</p>&#13;
			<p class="source-code">    for (m in movies) {</p>&#13;
			<p class="source-code">        println(m)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>When we pass an initial list of movies, the code compiles just fine:</p>&#13;
			<p class="source-code">// Prints each movie on a newline    </p>&#13;
			<p class="source-code">printMovies(myFavoriteMovies) </p>&#13;
			<p>But if we pass it our empty movie list, the code won't compile:</p>&#13;
			<p class="source-code">printMovies(myFavoriteQuickAndAngryMovies) </p>&#13;
			<p class="source-code">// Type mismatch: inferred type is NoMoviesList but // List&lt;String&gt; was expected</p>&#13;
			<p>The reason for this is that our function only accepts arguments of the <em class="italic">list of strings</em> type, while there's nothing to tell the function that <strong class="source-inline">NoMoviesList</strong> is of this type (even though its name suggests it).</p>&#13;
			<p>Luckily, in Kotlin, singleton objects can implement interfaces, and a generic <strong class="source-inline">List</strong> interface is available:</p>&#13;
			<p class="source-code">object NoMoviesList : List&lt;String&gt;</p>&#13;
			<p>Now, our compiler will prompt us to implement the required functions. We'll do that by adding a body to <strong class="source-inline">object</strong>:</p>&#13;
			<p class="source-code">object NoMoviesList : List&lt;String&gt; {</p>&#13;
			<p class="source-code">    override val size = 0</p>&#13;
			<p class="source-code">    override fun contains(element: String) = false </p>&#13;
			<p class="source-code">    ... /</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We'll leave it to you to<a id="_idIndexMarker138"/> implement the other functions if you wish. This should be a good exercise of everything you've learned about Kotlin until now. However, you don't have to do this. Kotlin already provides a function to create empty lists of any type:</p>&#13;
			<p class="source-code">printMovies(emptyList())</p>&#13;
			<p>If you're curious, this function returns a singleton object that implements a <strong class="source-inline">List</strong>. You can see the complete implementation in the Kotlin source code using your IntelliJ IDEA or on GitHub (<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt">https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt</a>). This is an excellent example of how design patterns are still actively applied in modern software.</p>&#13;
			<p>A Kotlin <strong class="source-inline">object</strong> has one major difference from a class – it can't have constructors. If you need to implement initialization for your Singleton, such as loading data from a configuration file for the first time, you can use the <strong class="source-inline">init</strong> block instead:</p>&#13;
			<p class="source-code">object Logger {</p>&#13;
			<p class="source-code">    init {</p>&#13;
			<p class="source-code">        println("I was accessed for the first time")</p>&#13;
			<p class="source-code">        // Initialization logic goes here</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    // More code goes here</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Note that if a Singleton is never invoked, it won't run its initialization logic at all, thereby saving resources. This is<a id="_idIndexMarker139"/> called <strong class="bold">lazy initialization</strong>.</p>&#13;
			<p>Now that we have learned how to limit object creation, let's discuss how to create objects without using a constructor directly.</p>&#13;
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Factory Method</h1>&#13;
			<p>The <strong class="bold">Factory Method</strong> design pattern<a id="_idIndexMarker140"/> is all about creating<a id="_idIndexMarker141"/> objects.</p>&#13;
			<p><em class="italic">But why do we need a method to create objects? Isn't that what constructors are for?</em></p>&#13;
			<p>Well, constructors have limitations.</p>&#13;
			<p>As an example, imagine we're building a game of chess. We would like to allow our players to save the state of the game into a text file and then restore the game from that position.</p>&#13;
			<p>Since the size of the board is predetermined, we only need to record the position and type of each piece. We'll use algebraic notation for this – for example, the Queen piece at C3 will be stored in our file as <strong class="source-inline">qc3</strong>, the pawn piece at A8 will be stored as <strong class="source-inline">pa8</strong>, and so on.</p>&#13;
			<p>Let's assume that we already read this file into a list of strings (which, by the way, would be an excellent application of the Singleton design pattern we discussed earlier).</p>&#13;
			<p>Given the list of notations, we would like to populate our board with them:</p>&#13;
			<p class="source-code">// More pieces here</p>&#13;
			<p class="source-code">val notations = listOf("pa8", "qc3", ...)</p>&#13;
			<p class="source-code">val pieces = mutableListOf&lt;ChessPiece&gt;()</p>&#13;
			<p class="source-code">for (n in notations) {</p>&#13;
			<p class="source-code">    pieces.add(createPiece(n))</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">println(pieces)</p>&#13;
			<p>Before we can implement our <strong class="source-inline">createPiece</strong> function, we need to decide what's common to all chess pieces. We'll create an interface for that:</p>&#13;
			<p class="source-code">interface ChessPiece {</p>&#13;
			<p class="source-code">    val file: Char</p>&#13;
			<p class="source-code">    val rank: Char</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Note that<a id="_idIndexMarker142"/> interfaces in Kotlin can declare properties, which <a id="_idIndexMarker143"/>is a very powerful feature.</p>&#13;
			<p>Each chess piece will be a <strong class="source-inline">data class</strong> that implements our interface:</p>&#13;
			<p class="source-code">data class Pawn(</p>&#13;
			<p class="source-code">    override val file: Char,</p>&#13;
			<p class="source-code">    override val rank: Char</p>&#13;
			<p class="source-code">) : ChessPiece</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">data class Queen(</p>&#13;
			<p class="source-code">    override val file: Char,</p>&#13;
			<p class="source-code">    override val rank: Char</p>&#13;
			<p class="source-code">) : ChessPiece</p>&#13;
			<p>The implementation of the other chess pieces is left as an exercise for you to do.</p>&#13;
			<p>Now, what's left is to implement our <strong class="source-inline">createPiece</strong> function:</p>&#13;
			<p class="source-code">fun createPiece(notation: String): ChessPiece {</p>&#13;
			<p class="source-code">    val <strong class="bold">(type, file, rank)</strong> = notation.<strong class="bold">toCharArray()</strong></p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    return when (type) {</p>&#13;
			<p class="source-code">        'q' -&gt; Queen(file, rank)</p>&#13;
			<p class="source-code">        'p' -&gt; Pawn(file, rank)</p>&#13;
			<p class="source-code">        // ...</p>&#13;
			<p class="source-code">        else -&gt; <strong class="bold">throw RuntimeException("Unknown piece: $type")</strong></p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Before we <a id="_idIndexMarker144"/>can discuss what this function achieves, let's<a id="_idIndexMarker145"/> cover three new syntax elements we haven't seen before.</p>&#13;
			<p>First, the <strong class="source-inline">toCharArray</strong> function splits a string into an array of characters. Since we assume that all of our notations are three characters long, the element at the <strong class="source-inline">0</strong> position will represent the <em class="italic">type</em> of the chess piece, the element at the <strong class="source-inline">1</strong> position will represent its vertical column – also known as <strong class="source-inline">file</strong> – and the last element will represent its horizontal column – also known as <strong class="source-inline">rank</strong>.</p>&#13;
			<p>Next, we can see three values: <strong class="source-inline">type</strong>, <strong class="source-inline">file</strong>, and <strong class="source-inline">rank</strong>, surrounded by parentheses. This is called<a id="_idIndexMarker146"/> a <strong class="bold">destructuring declaration</strong>, and you may be familiar with them from JavaScript, for example. Any <strong class="source-inline">data class</strong> can be destructured.</p>&#13;
			<p>The previous code example is similar to the following, much more verbose code:</p>&#13;
			<p class="source-code">val type = notation.toCharArray()[0]</p>&#13;
			<p class="source-code">val file = notation.toCharArray()[1]</p>&#13;
			<p class="source-code">val rank = notation.toCharArray()[2]</p>&#13;
			<p>Now, let's focus on the <strong class="source-inline">when</strong> expression. Based on the letter representing the type, it instantiates one of the implementations of the <strong class="source-inline">ChessPiece</strong> interface. Remember, this is what the Factory Method design pattern is all about.</p>&#13;
			<p>To make sure you grasp this design pattern well, feel free to implement the classes and logic for other chess pieces as an exercise.</p>&#13;
			<p>Finally, let's look at the bottom of our function, where we see the first use of a <strong class="source-inline">throw</strong> expression.</p>&#13;
			<p>This expression, as the name suggests, <em class="italic">throws</em> an exception, which will stop the normal execution of our simple program. We'll discuss how to handle exceptions in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>.</p>&#13;
			<p>In the real world, the Factory Method design pattern is often used by libraries that need to parse configuration files – be they of the XML, JSON, or YAML format – into runtime objects.</p>&#13;
			<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Static Factory Method</h2>&#13;
			<p>There is a <a id="_idIndexMarker147"/>similarly named design pattern (which has a slightly different implementation) that is often confused with the Factory <a id="_idIndexMarker148"/>Method design pattern, and it is described in the <em class="italic">Gang of Four</em> book – the <strong class="bold">Static Factory Method</strong> design pattern.</p>&#13;
			<p>The Static Factory Method design pattern was popularized by Joshua Bloch in his book, <em class="italic">Effective Java</em>. To understand this better, let's look at some examples from the Java standard library: the <strong class="source-inline">valueOf()</strong> methods. There are at least two ways to construct a <strong class="source-inline">Long</strong> (that is, a 64-bit integer) from a string:</p>&#13;
			<p class="source-code">Long l1 = new Long("1"); // constructor</p>&#13;
			<p class="source-code">Long l2 = Long.valueOf("1"); // static factory method</p>&#13;
			<p>Both the constructor and the <strong class="source-inline">valueOf()</strong> method receive string as input and produce <strong class="source-inline">Long</strong> as output.</p>&#13;
			<p><em class="italic">So, why should we prefer the Static Factory Method design pattern to a simple constructor?</em></p>&#13;
			<p>Here are some of the<a id="_idIndexMarker149"/> advantages of using the Static Factory Method compared to constructors:</p>&#13;
			<ul>&#13;
				<li>It provides an opportunity to explicitly name different object constructors. This is especially useful when your class has multiple constructors.</li>&#13;
				<li>We usually don't expect exceptions from a constructor. That doesn't mean that the instantiation of a class can't fail. Exceptions from a regular method, on the other hand, are much more accepted.</li>&#13;
				<li>Speaking of expectations, we expect the constructor to be fast. But construction of some objects<a id="_idIndexMarker150"/> is inherently slow. Consider using the Static Factory Method instead.</li>&#13;
			</ul>&#13;
			<p>These are mostly style advantages; however, there are also technological advantages to this approach.</p>&#13;
			<h3>Caching</h3>&#13;
			<p>The <a id="_idIndexMarker151"/>Static Factory Method design pattern may provide <strong class="bold">caching</strong>, as <strong class="source-inline">Long</strong> actually does. Instead of always returning a new instance for any <a id="_idIndexMarker152"/>value, <strong class="source-inline">valueOf()</strong> checks in the cache whether this value was already parsed. If it was, it returns a cached instance. Repeatedly calling the Static Factory Method with the same values may produce less garbage for collection than using constructors all the time.</p>&#13;
			<h3>Subclassing</h3>&#13;
			<p>When calling the constructor, we always instantiate the class we specify. On the other hand, calling a <a id="_idIndexMarker153"/>Static Factory Method is less<a id="_idIndexMarker154"/> restrictive and may produce either an instance of the class itself or one of its subclasses. We'll come to this after discussing the implementation of this design pattern in Kotlin.</p>&#13;
			<h3>Static Factory Method in Kotlin</h3>&#13;
			<p>We discussed the <strong class="source-inline">object</strong> keyword earlier in this chapter in the <em class="italic">Singleton</em> section. Now, we'll <a id="_idIndexMarker155"/>see<a id="_idIndexMarker156"/> another use of it as a <strong class="bold">companion object</strong>.</p>&#13;
			<p>In Java, Static Factory Methods are declared <strong class="source-inline">static</strong>. But in Kotlin, there's no such keyword. Instead, methods that don't belong to an instance of a class can be declared inside <strong class="source-inline">companion object</strong>:</p>&#13;
			<p class="source-code">class Server(port: Long) {</p>&#13;
			<p class="source-code">    init {</p>&#13;
			<p class="source-code">        println("Server started on port $port")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    companion object {</p>&#13;
			<p class="source-code">        fun withPort(port: Long) = Server(port)</p>&#13;
			<p class="source-code">  }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Companion objects may have a name – for example, <strong class="source-inline">companion object</strong> parser. But this is only to provide clarity about what the goal of the object is.</p>&#13;
			<p>As you can see, this time, we have declared an object that is prefixed by the <strong class="source-inline">companion</strong> keyword. Also, it's located inside a class, and not at the package level in the way we saw in the Singleton design pattern.</p>&#13;
			<p>This object has<a id="_idIndexMarker157"/> its own methods, and you may wonder what the benefit of this is. Just like a Java static method, calling a <strong class="source-inline">companion</strong> <strong class="source-inline">object</strong> will lazily instantiate it when the containing class is accessed for the first time:</p>&#13;
			<p class="source-code">Server.withPort(8080) // Server started on port 8080</p>&#13;
			<p>Moreover, calling it on an instance of a class simply won't work, unlike in Java:</p>&#13;
			<p class="source-code">Server(8080) // Won't compile, constructor is private</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">A class may have only one <strong class="source-inline">companion object</strong>.</p>&#13;
			<p>Sometimes, we also want the Static Factory Method to be the only way to instantiate our object. In order to do that, we can declare the default constructor of our object as <strong class="source-inline">private</strong>:</p>&#13;
			<p class="source-code">class Server <strong class="bold">private constructor</strong>(port: Long) {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This means that now there's only one way of constructing an instance of our class – through our Static Factory Method:</p>&#13;
			<p class="source-code">val server = Server(8080))  // Doesn't compile</p>&#13;
			<p class="source-code">val server = Server.withPort(8080) // Works!</p>&#13;
			<p>Let's now discuss another design pattern that is often confused with the Factory Method – Abstract Factory.</p>&#13;
			<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Abstract Factory</h1>&#13;
			<p><strong class="bold">Abstract Factory</strong> is a <a id="_idIndexMarker158"/>greatly misunderstood design pattern. It<a id="_idIndexMarker159"/> has a notorious reputation for being very complex and bizarre. Actually, it's quite simple. If you understood the Factory Method design pattern, you'll understand this one in no time. This is because the Abstract Factory design pattern is a factory of factories. That's all there is to it. The <em class="italic">factory</em> is a function or class that's able to create other classes. In other words, an abstract factory is a class that wraps multiple factory methods.</p>&#13;
			<p>You may understand this and still wonder what the use of such a design pattern may be. In the real world, the Abstract Factory design pattern is often used in frameworks and libraries that get their configuration from files. The <strong class="bold">Spring Framework</strong> is just one example of <a id="_idIndexMarker160"/>these.</p>&#13;
			<p>To better understand how the design pattern works, let's assume we have a configuration for our server written in a YAML file:</p>&#13;
			<p class="source-code">server: </p>&#13;
			<p class="source-code">    port: 8080</p>&#13;
			<p class="source-code">environment: production</p>&#13;
			<p>Our task is to construct objects from this configuration.</p>&#13;
			<p>In the previous section, we discussed how to use Factory Method to construct objects from the same family. But here, we have two families of objects that are related to each other but are not <em class="italic">siblings</em>.</p>&#13;
			<p>First, let's describe them as interfaces:</p>&#13;
			<p class="source-code">interface Property {</p>&#13;
			<p class="source-code">    val name: String</p>&#13;
			<p class="source-code">    val value: <strong class="bold">Any</strong></p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Instead of a <strong class="source-inline">data class</strong>, we'll return an interface. You'll see how this helps us later in this section:</p>&#13;
			<p class="source-code">interface ServerConfiguration {</p>&#13;
			<p class="source-code">    val properties: List&lt;Property&gt;</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Then, we can provide basic<a id="_idIndexMarker161"/> implementations to be used later:</p>&#13;
			<p class="source-code">data class PropertyImpl(</p>&#13;
			<p class="source-code">    override val name: String,</p>&#13;
			<p class="source-code">    override val value: Any</p>&#13;
			<p class="source-code">) : Property</p>&#13;
			<p class="source-code">data class ServerConfigurationImpl(</p>&#13;
			<p class="source-code">    override val properties: List&lt;Property&gt;</p>&#13;
			<p class="source-code">) : ServerConfiguration</p>&#13;
			<p>The server <a id="_idIndexMarker162"/>configuration simply contains the list of properties – and a <em class="italic">property</em> is a pair comprising a <strong class="source-inline">name</strong> object and a <strong class="source-inline">value</strong> object.</p>&#13;
			<p>This is the first time we have seen the <strong class="source-inline">Any</strong> type being used. The <strong class="source-inline">Any</strong> type is Kotlin's version of Java's <strong class="source-inline">object</strong>, but with one important distinction: it cannot be null.</p>&#13;
			<p>Now, let's write our first Factory Method, which will create <strong class="source-inline">Property</strong> given as a string:</p>&#13;
			<p class="source-code">fun property(prop: String): Property {</p>&#13;
			<p class="source-code">    val (name, value) = prop.split(":")</p>&#13;
			<p class="source-code">    return when (name) {</p>&#13;
			<p class="source-code">        "port" -&gt; PropertyImpl(name, value.trim().toInt())</p>&#13;
			<p class="source-code">        "environment" -&gt; PropertyImpl(name, value.trim())</p>&#13;
			<p class="source-code">        else -&gt; throw RuntimeException("Unknown property:           $name")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>As in many other languages, <strong class="source-inline">trim()</strong> is a function that is declared on strings that removes any spaces in the<a id="_idIndexMarker163"/> string. Now, let's create two properties to represent the port (<strong class="source-inline">port</strong>) and environment (<strong class="source-inline">environment</strong>) of our service:</p>&#13;
			<p class="source-code">val portProperty = property("port: 8080")</p>&#13;
			<p class="source-code">val environment = property("environment: production") </p>&#13;
			<p>There is a <a id="_idIndexMarker164"/>slight issue with this code. To understand what it is, let's try to store the value of the <strong class="source-inline">port</strong> property into another variable:</p>&#13;
			<p class="source-code">val port: Int = portProperty.value</p>&#13;
			<p class="source-code">// Type mismatch: inferred type is Any but Int was expected</p>&#13;
			<p>We already ensured that <strong class="source-inline">port</strong> is parsed to an <strong class="source-inline">Int</strong> in our Factory Method. But now, this information is lost because the type of the value is declared as <strong class="source-inline">Any</strong>. It can be <strong class="source-inline">String</strong>, <strong class="source-inline">Int</strong>, or any other type, for that matter. We need a new tool to solve this issue, so let's take a short detour and discuss casts in Kotlin.</p>&#13;
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Casts</h2>&#13;
			<p><strong class="bold">Casts</strong> in <a id="_idIndexMarker165"/>typed languages are a way to try and force the compiler to use the type we <a id="_idIndexMarker166"/>specify, instead of the type it has inferred. If we are sure what type the value is, we can use an <em class="italic">unsafe</em> cast on it:</p>&#13;
			<p class="source-code">val port: Int = portProperty.value<strong class="bold"> as Int</strong></p>&#13;
			<p>The reason it is called <em class="italic">unsafe</em> is that if the value is not of the type we expect, our program will crash without the compiler being able to warn us.</p>&#13;
			<p>Alternatively, we could use a <em class="italic">safe</em> cast:</p>&#13;
			<p class="source-code">val port: <strong class="bold">Int?</strong> = portProperty.value <strong class="bold">as?</strong> Int</p>&#13;
			<p><em class="italic">Safe</em> casts won't crash our<a id="_idIndexMarker167"/> program, but if the type of the object is not what we expect, it will return null. Notice that our <strong class="source-inline">port</strong> variable now is declared as the nullable <strong class="source-inline">Int</strong>, so we have to explicitly deal with the possibility of not getting what we want during compilation time. </p>&#13;
			<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>Subclassing</h2>&#13;
			<p>Instead of <a id="_idIndexMarker168"/>resorting to casts, let's try another approach. Instead of<a id="_idIndexMarker169"/> using a single implementation with a value of the <strong class="source-inline">Any</strong> type, we'll use two separate implementations:</p>&#13;
			<p class="source-code">data class IntProperty(</p>&#13;
			<p class="source-code">    override val name: String,</p>&#13;
			<p class="source-code">    override val value: Int</p>&#13;
			<p class="source-code">) : Property</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">data class StringProperty(</p>&#13;
			<p class="source-code">    override val name: String,</p>&#13;
			<p class="source-code">    override val value: String</p>&#13;
			<p class="source-code">) : Property</p>&#13;
			<p>Our Factory Method will have to change a little to be able to return one of the two classes:</p>&#13;
			<p class="source-code">fun property(prop: String): Property {</p>&#13;
			<p class="source-code">    val (name, value) = prop.split(":")</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    return when (name) {</p>&#13;
			<p class="source-code">        "port" -&gt; IntProperty(name, value.trim().toInt())</p>&#13;
			<p class="source-code">        "environment" -&gt; StringProperty(name, value.trim())</p>&#13;
			<p class="source-code">        else -&gt; throw RuntimeException("Unknown property:           $name")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This looks fine, but if we try to <a id="_idIndexMarker170"/>compile our code again, it <a id="_idIndexMarker171"/>still won't work:</p>&#13;
			<p class="source-code">val portProperty = Parser.property("port: 8080")</p>&#13;
			<p class="source-code">val port: Int = portProperty.value </p>&#13;
			<p>Although we now have two concrete classes, the compiler doesn't know if the parsed property is <strong class="source-inline">IntProperty</strong> or <strong class="source-inline">StringProperty</strong>. All it knows is that it's <strong class="source-inline">Property</strong>, and the type of the value is still <strong class="source-inline">Any</strong>:</p>&#13;
			<p class="source-code">&gt; Type mismatch: inferred type is Any but Int was expected</p>&#13;
			<p>We need another trick, and that trick is called <strong class="bold">smart casts</strong>.</p>&#13;
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Smart casts</h2>&#13;
			<p>We can<a id="_idIndexMarker172"/> check if an object is of a given type by <a id="_idIndexMarker173"/>using the <strong class="source-inline">is</strong> keyword:</p>&#13;
			<p class="source-code">println(portProperty is IntProperty) // true</p>&#13;
			<p>However, the Kotlin compiler is very smart. <em class="italic">If we performed a type check on an</em> <strong class="source-inline">if</strong> <em class="italic">expression, it would mean that</em> <strong class="source-inline">portProperty</strong> <em class="italic">was indeed</em> <strong class="source-inline">IntProperty</strong><em class="italic">, right?</em> So, it could be safely cast.</p>&#13;
			<p>The Kotlin compiler will do just that for us:</p>&#13;
			<p class="source-code">if (portProperty is IntProperty) {</p>&#13;
			<p class="source-code">    val port: Int = portProperty.value // works!</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>There is no compilation error anymore, and we also do not have to deal with nullable values.</p>&#13;
			<p>Smart casts<a id="_idIndexMarker174"/> also work on nulls. In Kotlin's type hierarchy, the non-nullable <strong class="source-inline">Int</strong> type is a subclass of a nullable type, <strong class="source-inline">Int?</strong>, and this is true for all types. Previously, we mentioned that a <em class="italic">safe</em> cast will return <strong class="source-inline">null</strong> if it fails:</p>&#13;
			<p class="source-code">val port: Int? = portProperty.value as? Int</p>&#13;
			<p>We could <a id="_idIndexMarker175"/>check if <strong class="source-inline">port</strong> is null, and if it isn't, it will be smartly cast to a non-nullable type:</p>&#13;
			<p class="source-code">if (port != null) {</p>&#13;
			<p class="source-code">    val port: Int = port</p>&#13;
			<p class="source-code">}</p>&#13;
			<p><em class="italic">Nice!</em> <em class="italic">But wait, what's going on in this code?</em></p>&#13;
			<p>In the previous chapter, we said that values cannot be reassigned. But here, we defined the <strong class="source-inline">port</strong> value twice. <em class="italic">How is this possible?</em> This is not a bug, but another Kotlin feature, and it is called <strong class="bold">variable shadowing</strong>.</p>&#13;
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Variable shadowing</h2>&#13;
			<p>First, let's<a id="_idIndexMarker176"/> consider how our code would look if there <a id="_idIndexMarker177"/>was no shadowing. We would have to declare two variables with different names:</p>&#13;
			<p class="source-code">val portOrNull: Int? = portProperty.value as? Int</p>&#13;
			<p class="source-code">if (portOrNull != null) {</p>&#13;
			<p class="source-code">    val port: Int = portOrNull // works</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>However, this is a waste, for two reasons. First, the variable names become quite verbose. Second, the <strong class="source-inline">portOrNull</strong> variable would most probably never be used past this point because null is not a very useful value to begin with. Instead, we can declare values with the same names in different scopes, denoted by curly brackets (<strong class="source-inline">{}</strong>).</p>&#13;
			<p>Please note that variable shadowing may confuse you, and it is error-prone by nature. However, it is important to be aware that it exists, but the recommendation is to name your variables explicitly whenever possible.</p>&#13;
			<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Collection of Factory Methods</h2>&#13;
			<p>Now that we've had<a id="_idIndexMarker178"/> our detour into casts and variable shadowing, let's go back to the previous code example and implement a second Factory Method, that will create a <strong class="source-inline">server</strong> configuration object:</p>&#13;
			<p class="source-code">fun server(propertyStrings: List&lt;String&gt;): </p>&#13;
			<p class="source-code">  ServerConfiguration {</p>&#13;
			<p class="source-code">    val parsedProperties = mutableListOf&lt;Property&gt;()</p>&#13;
			<p class="source-code">    for (p in propertyStrings) {</p>&#13;
			<p class="source-code">        parsedProperties += property(p)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    return ServerConfigurationImpl(parsedProperties)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This method takes the lines from our configuration file and converts them into <strong class="source-inline">Property</strong> objects using the <strong class="source-inline">property()</strong> Factory Method that we've already implemented.</p>&#13;
			<p>We can test that our second Factory Method works as well:</p>&#13;
			<p class="source-code">println(server(listOf("port: 8080", "environment: </p>&#13;
			<p class="source-code">  production")))</p>&#13;
			<p class="source-code"><strong class="bold">&gt; ServerConfigurationImpl(properties=[IntProperty(name=port, value=8080), StringProperty(name=environment, value=production)])</strong></p>&#13;
			<p>Since these two methods are related, it would be good to put them together under the same class. Let's call this class <strong class="source-inline">Parser</strong>. Although we didn't parse any actual file and agreed that we get its contents line by line already, by the end of this book, you would probably agree that implementing the actual reading logic is quite trivial.</p>&#13;
			<p>We can also use Static Factory Method and the <strong class="source-inline">companion object</strong> syntax we learned about in the previous section.</p>&#13;
			<p>The resulting implementation will look like this:</p>&#13;
			<p class="source-code">class Parser {</p>&#13;
			<p class="source-code">    companion object {</p>&#13;
			<p class="source-code">        fun property(prop: String): Property {</p>&#13;
			<p class="source-code">           ...</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">        fun server(propertyStrings: List&lt;String&gt;): ...{</p>&#13;
			<p class="source-code">           ...        </p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This pattern allows <a id="_idIndexMarker179"/>us to create <em class="italic">families</em> of objects – in this case, <strong class="source-inline">ServerConfig</strong> is the <em class="italic">parent</em> of a property.</p>&#13;
			<p>The previous code is just one way to implement an Abstract Factory. You may find some implementations that rely on implementing an interface instead:</p>&#13;
			<p class="source-code">interface Parser {</p>&#13;
			<p class="source-code">    fun property(prop: String): Property</p>&#13;
			<p class="source-code">    fun server(propertyStrings: List&lt;String&gt;):       ServerConfiguration</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">class YamlParser : Parser {</p>&#13;
			<p class="source-code">    // Implementation specific to YAML files</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">class JsonParser : Parser {</p>&#13;
			<p class="source-code">    // Implementation specific to JSON files</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This approach may be better if your Factory Methods grow to contain lots of code.</p>&#13;
			<p>One last question you may have is where we can see Abstract Factory used in real code. One example is the <strong class="source-inline">java.util.Collections</strong> class. It has methods such as <strong class="source-inline">emptyMap</strong>, <strong class="source-inline">emptyList</strong>, and <strong class="source-inline">emptySet</strong>, which each generate a different class. However, what is common to all of them is that they are all collections.</p>&#13;
			<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Builder</h1>&#13;
			<p>Sometimes, our <a id="_idIndexMarker180"/>objects are very simple and have only one constructor, be it an <a id="_idIndexMarker181"/>empty or non-empty one. But sometimes, their creation is very complex and based on a lot of parameters. We've seen one pattern already that provides <em class="italic">a better constructor</em> – the Static Factory Method design pattern. Now, we'll discuss the <strong class="bold">Builder</strong> design pattern, which will help us create complex objects.</p>&#13;
			<p>As an example of such an object, imagine we need to design a system that sends emails. We won't implement the actual mechanism of sending them, we will just design a class that represents it.</p>&#13;
			<p>An email may have the following properties:</p>&#13;
			<ul>&#13;
				<li>An address (at least one is mandatory)</li>&#13;
				<li>CC (optional)</li>&#13;
				<li>Title (optional)</li>&#13;
				<li>Body (optional)</li>&#13;
				<li>Important flag (optional)</li>&#13;
			</ul>&#13;
			<p>We can describe an email in our system as a <strong class="source-inline">data class</strong>:</p>&#13;
			<p class="source-code">data class Mail_V1(</p>&#13;
			<p class="source-code">    val to: List&lt;String&gt;,</p>&#13;
			<p class="source-code">    val cc: List&lt;String&gt;?,</p>&#13;
			<p class="source-code">    val title: String?,</p>&#13;
			<p class="source-code">    val message: String?,</p>&#13;
			<p class="source-code">    val important: Boolean,</p>&#13;
			<p class="source-code">)</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Look at the definition of the last argument in the preceding code. This comma is not a typo. It is called a <strong class="bold">trailing comma</strong>, and<a id="_idIndexMarker182"/> these were introduced in <strong class="bold">Kotlin 1.4</strong>. This is<a id="_idIndexMarker183"/> done so you can easily change the order of the arguments.</p>&#13;
			<p>Next, let's attempt to create an email addressed to our manager:</p>&#13;
			<p class="source-code">val mail = Mail_V1(</p>&#13;
			<p class="source-code">    listOf("manager@company.com"),    // To</p>&#13;
			<p class="source-code">    null,                             // CC</p>&#13;
			<p class="source-code">    "Ping ",                          // Title</p>&#13;
			<p class="source-code">    null,                             // Message,</p>&#13;
			<p class="source-code">    true))                            // Important</p>&#13;
			<p>Note that we<a id="_idIndexMarker184"/> have defined <em class="italic">carbon copy</em> (that's what <strong class="source-inline">CC</strong> stands for) as<a id="_idIndexMarker185"/> nullable so that it can receive either a list of emails or null. Another option would be to define it as <strong class="source-inline">List&lt;String&gt;</strong> and force our code to pass <strong class="source-inline">listOf()</strong>.</p>&#13;
			<p>Since our constructor receives a lot of arguments, we had to put in some comments in order not to get confused.</p>&#13;
			<p><em class="italic">But what happens if we need to change this class now?</em></p>&#13;
			<p>First, our code will stop compiling. Second, we need to keep track of the comments. In short, constructors with a long list of arguments quickly become a mess.</p>&#13;
			<p>This is the problem the Builder design pattern sets out to solve. It decouples the assigning of arguments from the creation of objects and allows the creation of complex objects one step at a time. In this section, we'll see a number of approaches to this problem.</p>&#13;
			<p>Let's start by creating a new class, <strong class="source-inline">MailBuilder</strong>, which will wrap our <strong class="source-inline">Mail</strong> class:</p>&#13;
			<p class="source-code">class MailBuilder {</p>&#13;
			<p class="source-code">    private var to: List&lt;String&gt; = listOf()</p>&#13;
			<p class="source-code">    private var cc: List&lt;String&gt; = listOf()</p>&#13;
			<p class="source-code">    private var title: String = ""</p>&#13;
			<p class="source-code">    private var message: String = ""</p>&#13;
			<p class="source-code">    private var important: Boolean = false</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    class Mail <strong class="bold">internal </strong>constructor(</p>&#13;
			<p class="source-code">        val to: List&lt;String&gt;,</p>&#13;
			<p class="source-code">        val cc: List&lt;String&gt;?,</p>&#13;
			<p class="source-code">        val title: String?,</p>&#13;
			<p class="source-code">        val message: String?,</p>&#13;
			<p class="source-code">        val important: Boolean</p>&#13;
			<p class="source-code">    )</p>&#13;
			<p class="source-code">    ... // More code will come here soon</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Our builder has <a id="_idIndexMarker186"/>exactly the same properties as our resulting class. But these<a id="_idIndexMarker187"/> properties are all mutable.</p>&#13;
			<p>Note that the constructor is marked using the <strong class="source-inline">internal</strong> visibility modifier. This means that our <strong class="source-inline">Mail</strong> class will be accessible to any code inside our module.</p>&#13;
			<p>To finalize the creation of our class, we'll introduce the <strong class="source-inline">build()</strong> function:</p>&#13;
			<p class="source-code">fun build(): Mail {</p>&#13;
			<p class="source-code">    if (to.isEmpty()) {</p>&#13;
			<p class="source-code">        throw RuntimeException("To property is empty")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    return Mail(to, cc, title, message, important)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>And for each property, we'll have another function to be able to set it:</p>&#13;
			<p class="source-code">fun message(message: String): MailBuilder {</p>&#13;
			<p class="source-code">    this.message = message</p>&#13;
			<p class="source-code">    return this</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">// More functions for each of the properties</p>&#13;
			<p>Now, we can use our builder to create an email in the following way:</p>&#13;
			<p class="source-code">val email = MailBuilder("hello@hello.com").title("What's   up?").build()</p>&#13;
			<p>After setting a <a id="_idIndexMarker188"/>new value, we return a reference to our object by using <strong class="source-inline">this</strong>, which <a id="_idIndexMarker189"/>provides us with access to the next setter to allow us to perform chaining (please refer to the <em class="italic">Fluent setters</em> section in this chapter for an explanation of this).</p>&#13;
			<p>This is a working approach. But it has a couple of downsides:</p>&#13;
			<ul>&#13;
				<li>The properties of our resulting class must be repeated insider the builder.</li>&#13;
				<li>For every property, we need to declare a function to set its value.</li>&#13;
			</ul>&#13;
			<p>Kotlin provides two other ways that you may find even more useful.</p>&#13;
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Fluent setters</h2>&#13;
			<p>The approach using <strong class="bold">fluent setters</strong> is a <a id="_idIndexMarker190"/>bit more concise. Here, we won't <a id="_idIndexMarker191"/>construct any additional classes. Instead, our <strong class="source-inline">data class</strong> constructor will contain only the mandatory fields. All other fields will become <strong class="source-inline">private</strong>, and we'll provide setters for these fields:</p>&#13;
			<p class="source-code">data class Mail_V2(</p>&#13;
			<p class="source-code">    val to: List&lt;String&gt;,</p>&#13;
			<p class="source-code">    private var _message: String? = null,</p>&#13;
			<p class="source-code">    private var _cc: List&lt;String&gt;? = null,</p>&#13;
			<p class="source-code">    private var _title: String? = null,</p>&#13;
			<p class="source-code">    private var _important: Boolean? = null</p>&#13;
			<p class="source-code">) {</p>&#13;
			<p class="source-code">    fun message(message: String) = apply {</p>&#13;
			<p class="source-code">        _message = message</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    // Pattern repeats for every other field</p>&#13;
			<p class="source-code">    //...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Using underscores for <strong class="source-inline">private</strong> variables is a common convention in Kotlin. It allows us to avoid repeating <strong class="source-inline">this.message = message</strong> and mistakes such as <strong class="source-inline">message = message</strong>.</p>&#13;
			<p>In this code example, we<a id="_idIndexMarker192"/> used the <strong class="source-inline">apply</strong> function. This is part of the <a id="_idIndexMarker193"/>family of scoping functions that can be invoked on every Kotlin object, and we'll cover them in detail in <a href="B17816_09_ePub.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a>, <em class="italic">Idioms and Anti-Patterns</em>. The <strong class="source-inline">apply</strong> function returns the reference to an object after executing the block. So, it's a shorter version of the setter function from the previous example:</p>&#13;
			<p class="source-code">fun message(message: String): MailBuilder {</p>&#13;
			<p class="source-code">    this.message = message</p>&#13;
			<p class="source-code">    return this</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This provides us with the same API as the previous example:</p>&#13;
			<p class="source-code">val mailV2 = Mail_V2(listOf("manager@company.com")).message("Ping")</p>&#13;
			<p>However, we may not need setters at all. Instead, we can use the <strong class="source-inline">apply()</strong> function we previously discussed on the object itself. This is one of the extension functions that every object in Kotlin has. This approach will work only if all of the optional fields are <em class="italic">variables</em> instead of <em class="italic">values</em>.</p>&#13;
			<p>Then, we can create our email like this:</p>&#13;
			<p class="source-code">val mail = Mail_V2("hello@mail.com").apply {</p>&#13;
			<p class="source-code">    message = "Something" </p>&#13;
			<p class="source-code">    title = "Apply"</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This is a nice approach, and <a id="_idIndexMarker194"/>it requires less code to implement. However, there are a few downsides to this approach too:</p>&#13;
			<ul>&#13;
				<li>We had to make all of the optional arguments mutable. Immutable fields should always be preferred to mutable ones, as they are thread-safe and easier to reason about.</li>&#13;
				<li>All of our optional arguments are also nullable. Kotlin is a null-safe language, so every time we access them, we first have to check that their value was set.</li>&#13;
				<li>This syntax is very verbose. For each field, we need to repeat the same pattern over and over again.</li>&#13;
			</ul>&#13;
			<p>Now, let's discuss the last approach to this problem.</p>&#13;
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Default arguments</h2>&#13;
			<p>In Kotlin, we can specify <a id="_idIndexMarker195"/>default values for constructor and function parameters: </p>&#13;
			<p class="source-code">data class Mail_V3(</p>&#13;
			<p class="source-code">    val to: List&lt;String&gt;,</p>&#13;
			<p class="source-code">    val cc: List&lt;String&gt; = listOf(),</p>&#13;
			<p class="source-code">    val title: String = "",</p>&#13;
			<p class="source-code">    val message: String = "",</p>&#13;
			<p class="source-code">    val important: Boolean = false</p>&#13;
			<p class="source-code">)</p>&#13;
			<p>Default arguments are set using the <strong class="source-inline">=</strong> operator after the type. This means that although our constructor still has all the arguments, we don't need to provide them any.</p>&#13;
			<p>So, if you would like to create an email without a body, you can do it like this:</p>&#13;
			<p class="source-code">val mail = Mail_V3(listOf("manager@company.com"), listOf(), "Ping")</p>&#13;
			<p>However, note that we <a id="_idIndexMarker196"/>had to specify that we don't want anyone in the CC field by providing an empty list, which is a bit inconvenient.</p>&#13;
			<p><em class="italic">What if we wanted to send an email that is only flagged as important?</em></p>&#13;
			<p>Not having to specify order with fluent setters was very handy. Kotlin has <em class="italic">named arguments</em> for that:</p>&#13;
			<p class="source-code">val mail = Mail_V3(title = "Hello", message = "There", to = listOf("my@dear.cat"))</p>&#13;
			<p>Combining default parameters with named arguments makes creating complex objects in Kotlin rather easy. For that reason, you will rarely need the Builder design pattern at all in Kotlin.</p>&#13;
			<p>In real applications, you'll often see the Builder design pattern used to construct instances of servers. A server would accept an optional host and an optional port and so on, and then when all of the arguments were set, you'd invoke a listen method to start it.</p>&#13;
			<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/>Prototype</h1>&#13;
			<p>The <strong class="bold">Prototype</strong> design pattern<a id="_idIndexMarker197"/> is all about customization and creating <a id="_idIndexMarker198"/>objects that are similar but slightly different. To understand it better, Let's look at an example.</p>&#13;
			<p>Imagine we have a system that manages users and their permissions. A <strong class="source-inline">data class</strong> representing a user might look like this:</p>&#13;
			<p class="source-code">data class User(</p>&#13;
			<p class="source-code">    val name: String,</p>&#13;
			<p class="source-code">    val role: Role,</p>&#13;
			<p class="source-code">    val permissions: Set&lt;String&gt;,</p>&#13;
			<p class="source-code">) {</p>&#13;
			<p class="source-code">    fun hasPermission(permission: String) = permission in       permissions</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Each user must have a role, and each role has a set of permissions.</p>&#13;
			<p>We'll describe a role as an <strong class="source-inline">enum</strong> class:</p>&#13;
			<p class="source-code">enum class Role {</p>&#13;
			<p class="source-code">    ADMIN,</p>&#13;
			<p class="source-code">    SUPER_ADMIN,</p>&#13;
			<p class="source-code">    REGULAR_USER</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The <strong class="source-inline">enum</strong> classes<a id="_idIndexMarker199"/> are a way to represent a collection of constants. This<a id="_idIndexMarker200"/> is more convenient than representing a role as a string, for example, as we check at compile time that such an object exists.</p>&#13;
			<p>When we create a new <em class="italic">user</em>, we assign them permissions that are similar to another user with the same <em class="italic">role</em>:</p>&#13;
			<p class="source-code">// In real application this would be a database of users</p>&#13;
			<p class="source-code">val allUsers = mutableListOf&lt;User&gt;()</p>&#13;
			<p class="source-code">fun createUser(name: String, role: Role) {</p>&#13;
			<p class="source-code">    for (u in allUsers) {</p>&#13;
			<p class="source-code">        if (u.role == role) {</p>&#13;
			<p class="source-code">            allUsers += User(name, role, u.permissions)</p>&#13;
			<p class="source-code">            return</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    // Handle case that no other user with such a role exists</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Let's imagine that <a id="_idIndexMarker201"/>we now need to add a new field to the <strong class="source-inline">User</strong> class, which <a id="_idIndexMarker202"/>we will name <strong class="source-inline">tasks</strong>:</p>&#13;
			<p class="source-code">data class User(</p>&#13;
			<p class="source-code">    val name: String,</p>&#13;
			<p class="source-code">    val role: Role,</p>&#13;
			<p class="source-code">    val permissions: Set&lt;String&gt;,</p>&#13;
			<p class="source-code">    <strong class="bold">val tasks: List&lt;String&gt;,</strong></p>&#13;
			<p class="source-code">) {</p>&#13;
			<p class="source-code">   ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Our <strong class="source-inline">createUser</strong> function will stop compiling. We'll have to change it by copying the value of this newly added field to the new instance of our class:</p>&#13;
			<p class="source-code">allUsers += User(name, role, u.permissions<strong class="bold">, u.tasks</strong>)</p>&#13;
			<p>This work will have to be repeated every time the <strong class="source-inline">User</strong> class is changed.</p>&#13;
			<p>However, there's a bigger problem still: <em class="italic">What if a new requirement is introduced, making the</em> <strong class="source-inline">permissions</strong> <em class="italic">property, for example, </em><strong class="source-inline">private</strong><em class="italic">?</em></p>&#13;
			<p class="source-code">data class User(</p>&#13;
			<p class="source-code">    val name: String,</p>&#13;
			<p class="source-code">    val role: Role,</p>&#13;
			<p class="source-code">    <strong class="bold">private val permissions</strong>: Set&lt;String&gt;,</p>&#13;
			<p class="source-code">    val tasks: List&lt;String&gt;,</p>&#13;
			<p class="source-code">) {</p>&#13;
			<p class="source-code">   ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Our code will stop compiling again, and we'll have to change it again. The constant requirement of changes to the code is a clear indication that we need another approach to solve this problem.</p>&#13;
			<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Starting from a prototype</h2>&#13;
			<p>The whole idea of a <em class="italic">prototype</em> is to be able to clone an object easily. There are at least two reasons you may <a id="_idIndexMarker203"/>want to do this:</p>&#13;
			<ul>&#13;
				<li>It helps in instances where creating your object is very expensive – for example, if you need to fetch it from the database.</li>&#13;
				<li>It helps if you need to create objects that are similar but vary slightly and you don't want to repeat similar parts over and over again.<p class="callout-heading">Important Note:</p><p class="callout">There are also more advanced reasons to use the Prototype design pattern. JavaScript, for example, uses prototypes to implement inheritance-like behavior without having classes.</p></li>&#13;
			</ul>&#13;
			<p>Luckily, Kotlin fixes the somewhat broken Java <strong class="source-inline">clone()</strong> method. Data classes have a <strong class="source-inline">copy()</strong> method, which takes an existing <strong class="source-inline">data class</strong>, and creates a new copy of it, optionally changing some of its attributes in the process:</p>&#13;
			<p class="source-code">// Name argument is underscored here simply not to confuse </p>&#13;
			<p class="source-code">// it with the property of the same name in the User object</p>&#13;
			<p class="source-code">fun createUser(_name: String, role: Role) {</p>&#13;
			<p class="source-code">    for (u in allUsers) {</p>&#13;
			<p class="source-code">        if (u.role == role) {</p>&#13;
			<p class="source-code">            <strong class="bold">allUsers += u.copy(name = _name)</strong></p>&#13;
			<p class="source-code">            return</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    // Handle case that no other user with such a role exists</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In a similar way to what we saw with the Builder design pattern, named arguments allow us to specify attributes that we can change in any order. And we need to specify only the attributes we want to change. All of the other data will be copied for us, even the <strong class="source-inline">private</strong> properties.</p>&#13;
			<p>The <strong class="source-inline">data class</strong> is yet another example of a design pattern that is so common that it became part of a language syntax. They are an extremely useful feature, and we will see them being used many more times in this book.</p>&#13;
			<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Summary</h1>&#13;
			<p>In this chapter, we have learned when and how to use creational design patterns. We started by discussing how to use the <strong class="source-inline">object</strong> keyword to construct a singleton class, and then we discussed the use of <strong class="source-inline">companion object</strong> if you need a Static Factory Method. We also covered how to assign multiple variables at once using destructuring declarations.</p>&#13;
			<p>Then, we discussed smart casts, and how they can be applied in the Abstract Factory design pattern to create families of objects. We then moved to the Builder design pattern and learned that functions can have default parameter values. We then learned that we can refer to their arguments using not only positions but also names.</p>&#13;
			<p>Finally, we covered the <strong class="source-inline">copy()</strong> function of the data classes, and how it helps us when implementing the Prototype design pattern to produce similar objects with slight changes. You should now understand how to use creational design patterns to better manage your objects.</p>&#13;
			<p>In the next chapter, we'll cover the second family of design patterns: <strong class="bold">structural patterns</strong>. These design patterns will help us create extensible and maintainable object hierarchies.</p>&#13;
			<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Questions</h1>&#13;
			<ol>&#13;
				<li>Name two uses for the <strong class="source-inline">object</strong> keyword we learned about in this chapter.</li>&#13;
				<li>What is the <strong class="source-inline">apply()</strong> function used for?</li>&#13;
				<li>Provide one example of a Static Factory Method.</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>