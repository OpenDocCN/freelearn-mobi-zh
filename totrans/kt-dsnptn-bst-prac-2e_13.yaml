- en: '*Chapter 10*: Concurrent Microservices with Ktor'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored how we should write idiomatic Kotlin code
    that will be readable and maintainable, as well as performant.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll put the skills we've learned so far to use by building
    a microservice using the **Ktor framework**. We also want this microservice to
    be reactive and to be as close to real life as possible. For that, we'll use the
    Ktor framework, the benefits of which we'll list in the first section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Ktor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the test consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing routes in Ktor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving concurrency in Ktor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a microservice written in Kotlin that
    is well tested and can read data from a PostgreSQL database and store data in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is what you''ll need to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JDK 11** or later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gradle 6.8** or later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL 14** or later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will assume that you have `PostgreSQL` already installed and that
    you have the basic knowledge for working with it. If you don''t, please refer
    to the official documentation: [https://www.postgresql.org/docs/14/tutorial-install.html](https://www.postgresql.org/docs/14/tutorial-install.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Ktor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You're probably tired of creating to-do or shopping lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead, in this chapter, the microservice will be for a `cat shelter`.
    The microservice should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Supply an endpoint we can ping to check whether the service is up and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the cats currently in the shelter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide us with a means to add new cats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework we'll be using for our microservice in this chapter is called
    **Ktor**. It's a concurrent framework that's developed and maintained by the creators
    of the Kotlin programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new Kotlin Gradle project:'
  prefs: []
  type: TYPE_NORMAL
- en: From your IntelliJ IDEA, select **File** | **New** | **Project** and choose
    **Kotlin** from **New Project** and **Gradle Kotlin** as your **Build System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your project a descriptive name – `CatsHostel`, in my case – and choose
    **Project JDK** (in this case, we are using **JDK 15**):![Figure 10.1 – Selecting
    the Project JDK type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B17816.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.1 – Selecting the Project JDK type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the next screen, select **JUnit 5** as your **Test framework** and set **Target
    JVM version** to **1.8**. Then, click **Finish**:![Figure 10.2 – Selecting Test
    framework and Target JVM version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B17816.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.2 – Selecting Test framework and Target JVM version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you should see the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B17816.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's open `build.gradle.kts`. This file controls how your project is
    built, its dependencies, and the libraries that the project is going to use. Depending
    on the version of your IntelliJ IDEA, the file's contents may differ a bit, but
    the general structure stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.kts` extension means that the configuration file for our Kotlin project
    is written in Kotlin, or to be precise, in `dependencies` block, which should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code mentions all the libraries that your project will be using.
    The `implementation()` configuration means that the library will be used at all
    times. The `testImplementation()` configuration means that the library will only
    be used during tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how a library is defined in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a regular string that has been separated into three parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `group` and `name` strings identify the library; the `version` configuration
    should be self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify the `dependencies` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since the files with `.kts` extensions are Kotlin files, we can use regular
    Kotlin syntax in them. In this case, we are using values and string interpolation
    to extract the version of our library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest version of Ktor to date is **1.6.4**, but when you read this book,
    it will be greater than this. You can find the latest version here: [https://ktor.io/](https://ktor.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, all Ktor libraries should be the same version and that's
    when the variable becomes useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have followed the steps from the beginning of this section, you should
    have a file called `server.kt` in the `src/main/kotlin` folder in your project.
    If you don't, create one now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the following content to the `server.kt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's all the code we need to write to start a web server that will respond
    with `OK` when you open `http://localhost:8080` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s understand what happens here:'
  prefs: []
  type: TYPE_NORMAL
- en: To interact with the request and return a response, we can use the `call` object,
    also known as the **context**. This object provides all the convenient methods
    for parsing requests and returning responses in different formats, and we'll see
    the different methods available for it throughout this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `embeddedServer()` function is an implementation of the Builder pattern,
    which we discussed in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062), *Working
    with Creational Patterns*. It allows us to configure our server. Most of the arguments
    have the same defaults. We override `port` to `8080` just for convenience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specify the `wait` argument to be `true` so that our server will wait for
    incoming requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only mandatory argument to the `embeddedServer` function is the server engine.
    In our example, we use `Netty`, which is a very well-known JVM library, but there
    are others as well. The most interesting of them is `CIO`, which was developed
    by JetBrains themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's understand what `CIO` and `Netty` are. They are both **Factory**
    patterns that create the actual instance of our server when invoked. This is a
    really interesting combination of different design patterns in one place to create
    a very flexible and extensible architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch to using `CIO`, all we need to do is add a new dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to pass another server engine, `CIO`, to our `embeddedServer`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't have to change anything else in our code when we switched
    the server engine. That is because `embeddedServer()` uses the Bridge design pattern
    to make components interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our server has been started, let's investigate how we define different
    responses for each request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `routing` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This block describes all the URLs that will be handled by our server. In this
    case, we only handle the root URL. When that URL is requested, a text response,
    `OK`, will be returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code returns a text response. Now, let''s see how we can return
    a JSON response instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `respondText()` method, we'll use `respond()`, which receives
    an object instead of a string. In our example, we're passing a map of strings
    to the `respond()` function. If we run this code, though, we'll get an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because, by default, objects are not serialized into JSON. Multiple
    libraries can do this for us. In this example, we''ll use the `kotlinx-serialization`
    library. Let''s start by adding it to our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the following lines before our `routing` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our code again, it will output this on our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We've just created our first route, which returns an object serialized as JSON.
    Now, we can check whether our application works by opening `http://localhost:8080/status`
    in our browser. But that is a bit cumbersome. In the next section, we'll learn
    how to write a test for the `/status` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write our first test, let's create a new file called `ServerTest.kt` under
    the `src/test/kotlin` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a new dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add the following contents to our `ServerTest.kt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Tests in Kotlin are grouped into classes, and each test is a method in the class,
    which is marked with the `@Test` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `test` method, we start a test server, issue a `GET` request to the
    `/status` endpoint, and check that the endpoint responds with a correct status
    code and JSON body.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this test now, though, it will fail, because we haven't started our
    server yet. To do so, we'll need to refactor it a bit, which we'll do in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our server has been started from the `main()` function. This was simple
    to set up, but this doesn't allow us to test our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ktor, the code is usually organized into modules. Let''s rewrite our `main`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of providing the logic of our server within a block, we specified
    a module that will contain all the configurations for our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module is defined as an extension function on the `Application` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the content of this function is the same as that of the block
    that we passed to our `embeddedService` function earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is go back to our test and specify which module we would
    like to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If you run this test now, it should pass, because our server has started properly
    in test mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve only dealt with the infrastructure of our service; we haven''t
    touched on its business logic: *managing cats*. To do so, we''ll need a database.
    In the next section, we''ll discuss how Ktor solves this problem using the Exposed
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store and retrieve cats, we'll need to connect to a database. We'll use PostgreSQL
    for that purpose, although using another SQL database won't be any different.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need a new library to connect to the database. We'll use the Exposed
    library, which is also developed by JetBrains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following dependency to our `build.gradle.kts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the libraries are in place, we need to connect to them. To do that, let''s
    create a new file called `DB.kt` under `/src/main/kotlin` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Since our application needs exactly one instance of a database, the `DB` object
    can use the Singleton pattern, which we discussed in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*. For that, we will use the `object` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Then, for each of the variables that we need to connect to the database, we
    will attempt to read them from our environment. If the `environment` variable
    is not set, we will use a default value using the **Elvis** operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database and a user is beyond the scope of this book, but you can
    refer to the official documentation for this, at [https://www.postgresql.org/docs/14/app-createuser.html](https://www.postgresql.org/docs/14/app-createuser.html)
    and [https://www.postgresql.org/docs/14/app-createdb.html](https://www.postgresql.org/docs/14/app-createdb.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can simply run the following two commands in your command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The first command creates a database user called `cats_admin` and asks you to
    specify a password for this user. Our application will use this `cats_admin` user
    to interact with the database. The second command creates a database called `cats_db`
    that belongs to the `cats_admin` user. Now that our database has been created,
    all we need to do is create a table that will store our cats in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, let''s define another Singleton object in our `DB.kt` file that will
    represent a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what the preceding definition means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntIdTable` means that we want to create a table with a primary key of the
    `Int` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the body of our object, we define the columns. In addition to the `ID` column,
    we'll have a `name` column that is of the `varchar` type, or in other words, a
    string, and is `20` characters at the most.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cat's `name` column is also unique, meaning that no two cats can have the
    same name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have a third column that is of the `integer` type, or `Int` in Kotlin
    terms, and is defaulted to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll also have a `data` class to represent a single cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that is left for us to do is add the following lines of code
    to our `mainModule()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Each time our application starts, the preceding code will connect to the database.
    Then, it will attempt to create a table that stores our entities. If a table already
    exists, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established a connection to our database, let's examine how
    we can use this connection to store a few cats in it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next task is adding the first cat to our virtual shelter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the REST principles, it should be a `POST` request, where the body
    of the request may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start by writing a new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Backticks are a useful Kotlin feature that allows us to have spaces in the names
    of our functions. This helps us create descriptive test names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the body of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We discussed the `withTestApplication` and `handleRequest` functions in the
    previous section. This time, we are using a `POST` request. These types of requests
    should have the correct header, so we must set those headers using the `addHeader()`
    function. We must also set the body to the contents discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we must check whether the response header is set to the `Created` HTTP
    code.
  prefs: []
  type: TYPE_NORMAL
- en: If we run this test now, it will fail with an HTTP code of `404` since we haven't
    implemented the `post` `/cats` endpoint yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `routing` block and add a new endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new cat, we''ll need to read the body of the `POST` request. We''ll
    use the `receiveParameters()` function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The `receiveParameters` function returns a case-insensitive map. First, we will
    attempt to fetch the cat's `name` from this map, and if there's no name in the
    request, we will fail the call. This will be handled by Ktor.
  prefs: []
  type: TYPE_NORMAL
- en: Then, if we didn't receive `age`, we will default it to `0` using the Elvis
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must insert those values into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Here, we open a `transaction` block to make changes to the database. Then, we
    use the `insert()` method, which is available on every table. Inside the `insert`
    lambda, the `cat` variable refers to the new row we are going to populate. We
    set the name of that row to the value of the `name` parameter and do the same
    for `age`.
  prefs: []
  type: TYPE_NORMAL
- en: If you run your test now, it should pass. But if you run it again, it will fail.
    That's because the name of a cat in the database is unique. Also, we don't clean
    the database between test runs. So, the first run creates a cat named `Meatloaf`,
    while the second run fails. This is because such a cat already exists.
  prefs: []
  type: TYPE_NORMAL
- en: To make our tests consistent, we need a way to clean our database between runs.
  prefs: []
  type: TYPE_NORMAL
- en: Making the tests consistent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to our test and add the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `@BeforeEach` annotation on a function. As its name suggests,
    this code will run before each test. The function will establish a connection
    to the database and drop the table completely. Then, our application will recreate
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our tests should pass consistently. In the next section, we'll learn how
    to fetch a cat from the database using the Exposed library.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the REST practices, the URL for fetching all cats should be `/cats`,
    while for fetching a single cat, it should be `/cats/123`, where `123` is the
    ID of the cat we are trying to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add two new routes for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The first route is very similar to the `/status` route we introduced earlier
    in this chapter. But the second round is slightly different: it uses a query parameter
    in the URL. You can recognize query parameters by the curly brackets around their
    name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To read a query parameter, we can access the `parameters` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is an ID on the URL, we need to try and fetch a cat from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Here, we open a transaction and use the `select` statement to get a cat with
    an ID equal to what we were provided previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an object was returned, we would convert it into JSON. Otherwise, we would
    return an HTTP code of `404`, `Not Found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a test for fetching a single cat as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we create a cat using Exposed. Here, we're using a new method
    called `insertAndGetId`. As its name suggests, it will return the ID of a newly
    created row. Then, we try to fetch that cat using our newly created endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to run this test, though, it will fail with the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Ktor doesn''t know how to turn our custom data class into JSON.
    To fix that, we''ll need to add a new plugin to our `build.gradle.kts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin will create serializers at compile time for any class marked with
    the `@Serializable` annotation. All we need to do now for the test to pass is
    add that annotation to our `Cat` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: That's it; now, our test for fetching a cat by its ID should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we would like to be able to fetch all the cats from the database.
    To do that, we must change our test setup a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Here, we changed the setup of our test to drop the table once all the tests
    have been executed. So, instead of the `@BeforeEach` annotation, which executes
    the function before each test, we use the `@AfterAll` annotation, which executes
    the function after all tests have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: For this annotation to work, we also need to add the `@TestInstance` annotation
    to our class. The default for that is `PER_METHOD`, but since we want to execute
    multiple tests at once, and then clean up after, we need to set the life cycle
    of our test class to `PER_CLASS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s wrap our test into a nested class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Nested test classes are a great way to encapsulate specific test situations.
    In our case, we would like to run two tests when there is a cat in our database
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the following setup code to our nested test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Before we execute each test in this nested class, we will create a cat in the
    database and after each test, we will delete all the cats from our database. Since
    we would like to keep track of the ID of the cat that we create, we will store
    it in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our test class for fetching a single entity looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we interpolate the cat's ID into our expected response since it
    will change with each test execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for fetching all the cats from the database will look almost the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: We just don't specify the ID, and the response is wrapped into a JSON array,
    as you can see by the square brackets around it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is implement this new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: If you followed the example for fetching a single entity from the database (from
    the beginning of this section), then this example won't be very different for
    you. We use the `selectAll()` function to fetch all the rows from the table. Then,
    we map each row to our `data` class. The only problem that is left for us to solve
    is that our code is quite messy and resides in a single file. It would be better
    if we split all the cat routes into a separate file. We'll do that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing routes in Ktor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll see what the idiomatic approach in Ktor is for structuring
    multiple routes that belong to the same domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current `routing` block looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be good if we could extract all the routes that are related to cats
    into a separate file. Let''s start by replacing all the cat routes with a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using IntelliJ IDEA, it will even suggest that you generate an extension
    function on the `Routing` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can move all our cat routes to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can see that the `/cats` URL is repeated many times. We can lift it
    using the `route()` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1 - Cleaner code after using the route() block'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 - Cleaner code after using the route() block
  prefs: []
  type: TYPE_NORMAL
- en: Notice how much cleaner our code has become now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there's one last important topic for us to cover. At the beginning of this
    chapter, we mentioned that Ktor is a highly concurrent framework. And in [*Chapter
    6*](B17816_06_ePub.xhtml#_idTextAnchor164), *Threads and Coroutines*, we said
    that concurrency in Kotlin is mainly achieved by using coroutines. But we have
    started a single coroutine in this chapter. We'll look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving concurrency in Ktor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking back at the code we've written in this chapter, you may be under the
    impression that the Ktor code is not concurrent at all. However, this couldn't
    be further from the truth.
  prefs: []
  type: TYPE_NORMAL
- en: All the Ktor functions we've used in this chapter are based on coroutines and
    the concept of **suspending functions**.
  prefs: []
  type: TYPE_NORMAL
- en: For every incoming request, Ktor will start a new coroutine that will handle
    it, thanks to the CIO server engine, which is based on coroutines at its core.
    Having a concurrency model that is performant but not obtrusive is a very important
    principle in Ktor.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `routing` blocks we used to specify all our endpoints have
    access to `CoroutineScope`, meaning that we can invoke suspending functions within
    those blocks.
  prefs: []
  type: TYPE_NORMAL
- en: One of the examples for such a suspending function is `call.respond()`, which
    we were using throughout this chapter. Suspending functions provide our application
    with opportunities to context switch, and to execute other code concurrently.
    This means that the same number of resources can serve far more requests than
    they would be able to otherwise. We'll stop here and summarize what we've learned
    about developing applications using Ktor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built a well-tested service using Kotlin that uses
    the Ktor framework to store entities in the database. We've also discussed how
    the multiple design patterns that we encountered at the beginning of this book,
    such as Factory, Singleton, and Bridge, are used in the Ktor framework to provide
    a flexible structure for our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to interact with the database using the Exposed framework.
    We've learned how we can declare, create, and drop tables, how to insert new entities,
    and how to fetch and delete them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at an alternative approach to developing web
    applications, but this time using a Reactive framework called **Vert.x**. This
    will allow us to compare the concurrent and Reactive approaches for developing
    web applications and discuss the tradeoffs of each of the approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are the Ktor applications structured and what are their benefits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are plugins in Ktor and what are they used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main problem that the Exposed library solves?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
