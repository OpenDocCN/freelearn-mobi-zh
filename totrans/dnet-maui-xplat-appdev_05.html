<html><head></head><body>
<div><div><h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-118">Exploring MVVM and Data Binding</h1>
<p class="normal">In the previous chapter, we explored how to construct <strong class="keyWord">user interfaces</strong> (<strong class="keyWord">UIs</strong>) using XAML. In this chapter, we will dive into <a id="_idIndexMarker279"/>the <strong class="keyWord">Model-View-View-Model</strong> (<strong class="keyWord">MVVM</strong>) pattern and data binding. The MVVM pattern, a widely adopted architectural pattern, is key in creating maintainable, scalable, and testable applications. In the context of .NET MAUI, MVVM separates the user interface logic, data, and the app’s structure into three distinct components: Model, View, and ViewModel. This separation leads to a clean and organized codebase, making it easier to develop and maintain the application. Data binding is a technique that connects the view (UI) with the ViewModel in a way that the UI reflects the ViewModel’s data and changes synchronously and automatically.</p>
<p class="normal">In this chapter, our initial focus will be on introducing <strong class="keyWord">MVVM</strong> and data binding. For a better design and cleaner code, we will employ the MVVM Toolkit, part of the .NET Community Toolkit. The use of the MVVM Toolkit results in more concise and clean ViewModel code.</p>
<p class="normal">In real-world applications, a majority of the logic is implemented in the model and service layers. Without a more complex model layer, we cannot delve into complicated topics about MVVM and data binding. Therefore, in the second half of this chapter, we present the actual model layer, which includes two .NET libraries, <strong class="keyWord">KPCLib</strong> and <strong class="keyWord">PassXYZLib</strong>.</p>
<p class="normal">With the real model layer in place, we introduce two advanced topics in data binding: binding to collections and using custom views.</p>
<p class="normal">The following topics will be covered in this chapter:</p>
<ul>
<li class="bulletList">Understanding <strong class="keyWord">MVVM</strong> and <strong class="keyWord">MVC</strong></li>
<li class="bulletList">Data binding</li>
<li class="bulletList">.NET Community Toolkit</li>
<li class="bulletList">Introducing the data model and service layer</li>
<li class="bulletList">Binding to collections</li>
<li class="bulletList">Using custom views</li>
</ul>
<h1 class="heading-1" id="_idParaDest-119">Technical requirements</h1>
<p class="normal">To test and debug the source code in this chapter, you need to have Visual Studio 2022 installed on your PC or Mac. Please refer to the <em class="italic">Development environment setup</em> section in <em class="chapterRef">Chapter 1</em>, <em class="italic">Getting Started with .NET MAUI</em>, for the details.</p>
<p class="normal">The source code for this chapter is available in the following GitHub repository: <a href="https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter04">https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter04</a>.</p>
<p class="normal">To check out the source code of this chapter, we can use the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ git clone -b 2nd/chapter04 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition.git PassXYZ.Vault2
</code></pre>
<p class="normal">To find out more about the source code in this book, please refer to the <em class="italic">Managing the source code in this book</em> section in <em class="chapterRef">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>.</p>
<h1 class="heading-1" id="_idParaDest-120">Understanding MVVM and MVC</h1>
<p class="normal">In software design, we usually follow and reuse good practices and design patterns. The <strong class="keyWord">Model-View-Controller</strong> (<strong class="keyWord">MVC</strong>) pattern is <a id="_idIndexMarker280"/>an approach to decoupling the responsibilities of a system. It can help to separate the implementation of the UI and the business logic into different parts.</p>
<figure class="mediaobject"><img alt="Figure 4.1: The MVC pattern" height="249" src="img/B21554_04_01.png" width="585"/></figure>
<p class="packt_figref">Figure 4.1: The MVC pattern</p>
<p class="normal">The <a id="_idIndexMarker281"/>MVC pattern, as shown in <em class="italic">Figure 4.1</em>, divides the responsibilities of the system into three distinct parts:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Model: </strong>The<a id="_idIndexMarker282"/> model represents the data and the business logic of the application. It is responsible for storing the app’s data, handling data validation, and performing any necessary data processing. Model classes typically interact with data sources, such as databases, web APIs, or file storage, to fetch and store data. Model classes <a id="_idIndexMarker283"/>usually can be implemented as <strong class="keyWord">Plain Old CLR Objects</strong> (<strong class="keyWord">POCOs</strong>) or <strong class="keyWord">Data Transfer Objects</strong> (<strong class="keyWord">DTOs</strong>). POCO is a class that doesn’t depend <a id="_idIndexMarker284"/>on any framework-specific classes, so POCO classes can be used with LINQ or Entity Framework well. DTO is a subset of a POCO class that only contains data without logic or behavior. DTO classes can be used to pass data between layers. The model has no dependency on the view or the controller so it can be implemented and tested separately.</li>
<li class="bulletList"><strong class="keyWord">View:</strong> The <a id="_idIndexMarker285"/>view is responsible for the app’s user interface and user interaction. The view should not contain any business logic or direct data processing. Instead, it displays data and interface elements to the user and captures their input.</li>
<li class="bulletList"><strong class="keyWord">Controller:</strong> The <a id="_idIndexMarker286"/>controller updates the model and view in response to the user’s action. Our understanding of the model and the view hasn’t changed too much over time, but there have been different understandings and implementations of the controller since the MVC pattern was introduced.</li>
</ul>
<p class="normal">The MVVM pattern <a id="_idIndexMarker287"/>was inspired by the MVC pattern, but it aimed to provide an improved approach specifically for UI development in XAML-based applications. With the rise of XAML-based UI frameworks, MVVM gained traction and became the de facto pattern for WPF, Silverlight, and later Xamarin.Forms applications. </p>
<p class="normal">With the evolution of Xamarin.Forms into .NET MAUI, MVVM continues to be a prominent pattern in multi-platform mobile and desktop application development.</p>
<figure class="mediaobject"><img alt="Figure 4.2: The MVVM pattern" height="237" src="img/B21554_04_02.png" width="465"/></figure>
<p class="packt_figref">Figure 4.2: The MVVM pattern</p>
<p class="normal">As we can see in <em class="italic">Figure 4.2</em>, in MVVM, the ViewModel is used to replace the controller. The differences between<a id="_idIndexMarker288"/> MVVM and MVC are as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Decoupling of view and model</strong>: The ViewModel is used to handle the communication between the view and the model. The view accesses the data and logic in the model via the ViewModel.</li>
<li class="bulletList"><strong class="keyWord">Data binding between the view and ViewModel</strong>: Using data binding, changes to the view or ViewModel can automatically be updated in the other one. This can help to reduce the complexity of implementation.</li>
</ul>
<p class="normal">In both MVC and MVVM, the model can be tested separately. In MVVM, it is possible to design unit tests for the ViewModel as well.</p>
<p class="normal">When the view changes, the changes will be reflected in the ViewModel via data binding. The ViewModel will process the data changes in the model. Similarly, when the data changes in the model, the ViewModel is notified to update the view. The common solution for notifications is to install event handlers that prompt the notifications. With data binding, the implementation is simplified significantly.</p>
<h2 class="heading-2" id="_idParaDest-121">MVVM in PassXYZ.Vault</h2>
<p class="normal">In our app, <code class="inlineCode">PassXYZ.Vault</code>, we use <a id="_idIndexMarker289"/>MVVM to handle the data exchange between the view and the ViewModel. As we can see in <em class="italic">Figure 4.3</em>, we have five XAML content pages and the same number of ViewModels defined. In our model, we have an <code class="inlineCode">Item</code> class, which is our model class, and it can be accessed through<a id="_idIndexMarker290"/> the <strong class="keyWord">IDataStore</strong> interface.</p>
<figure class="mediaobject"><img alt="Figure 4.3: MVVM in PassXYZ.Vault" height="411" src="img/B21554_04_03.png" width="825"/></figure>
<p class="packt_figref">Figure 4.3: MVVM in PassXYZ.Vault</p>
<p class="normal">Data binding is used as the communication channel between views and ViewModels. The ViewModel will update the <code class="inlineCode">Item</code> model via the <strong class="keyWord">IDataStore</strong> service interface. We will learn how to use data binding in the next section by analyzing the <code class="inlineCode">ItemDetailPage</code> and <code class="inlineCode">ViewModel</code>.</p>
<h1 class="heading-1" id="_idParaDest-122">Data binding</h1>
<p class="normal">Let’s explore how<a id="_idIndexMarker291"/> MVVM and data binding works. We can use an item detail page implementation in our app to analyze <strong class="keyWord">how data binding works</strong>. The following list includes the view, ViewModel, and model that we are going to explore:</p>
<ul>
<li class="bulletList"><strong class="keyWord">View</strong>: <code class="inlineCode">ItemDetailPage</code>, see <em class="italic">Listing 3.4</em> in the previous chapter</li>
<li class="bulletList"><strong class="keyWord">ViewModel</strong>: <code class="inlineCode">ItemDetailViewModel</code>, see <em class="italic">Listing 4.1</em></li>
<li class="bulletList"><strong class="keyWord">Model</strong>: <code class="inlineCode">Item</code> (access through the <strong class="keyWord">IDataStore</strong> interface), see <em class="italic">Listing 3.3</em> in the previous chapter</li>
</ul>
<p class="normal"><code class="inlineCode">ItemDetailPage</code> is a view used to display the content of an instance of <code class="inlineCode">Item</code>. The data is retrieved from the ViewModel. The UI elements presenting the content of <code class="inlineCode">Item</code> are connected to the ViewModel instance through data binding.</p>
<figure class="mediaobject"><img alt="A diagram of a binding object  Description automatically generated" height="318" src="img/B21554_04_04.png" width="825"/></figure>
<p class="packt_figref">Figure 4.4: Data binding</p>
<p class="normal">As we can see in <em class="italic">Figure 4.4</em>, data binding is used to synchronize the properties of target and source objects. There are three objects involved in data binding and they are the <code class="inlineCode">binding target</code>, <code class="inlineCode">binding source</code>, and <code class="inlineCode">binding object</code>.</p>
<h2 class="heading-2" id="_idParaDest-123">Binding object</h2>
<p class="normal">In <em class="italic">Figure 4.4</em>, the <a id="_idIndexMarker292"/>object of the <code class="inlineCode">Binding</code> class (<code class="inlineCode">Microsoft.Maui.Controls.Binding</code>) represents <a id="_idIndexMarker293"/>the connection between the target property (in the View) and the source property (in the ViewModel). It manages the synchronization of property values and handles the communication between the source and the target. The binding object is created when you define a binding <a id="_idIndexMarker294"/>expression in your XAML markup <a id="_idIndexMarker295"/>or create a binding in code.</p>
<p class="normal">Example of creating a binding object in XAML:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Label Text="{Binding FirstName}" /&gt;
</code></pre>
<p class="normal">Example of creating a binding object in C#:</p>
<pre class="programlisting code"><code class="hljs-code">label.SetBinding(Label.TextProperty, new Binding("FirstName"));
</code></pre>
<h2 class="heading-2" id="_idParaDest-124">Binding target</h2>
<p class="normal">In <em class="italic">Figure 4.4</em>, the <a id="_idIndexMarker296"/>target refers to the UI element (control) in the<a id="_idIndexMarker297"/> view that is bound to the ViewModel property. More specifically, the target is the property of the UI element involved in the binding. Examples of target properties include <code class="inlineCode">Text</code> on a <code class="inlineCode">Label</code> or <code class="inlineCode">Entry</code>, <code class="inlineCode">Source</code> on an <code class="inlineCode">Image</code>, and <code class="inlineCode">IsEnabled</code> on a <code class="inlineCode">Button</code>. The target property must be a bindable property to participate in data binding.</p>
<h2 class="heading-2" id="_idParaDest-125">Binding source</h2>
<p class="normal">The<a id="_idIndexMarker298"/> source is the object containing the property that is bound to the target property in the view. Typically, the source object is the ViewModel, which should be set as the <code class="inlineCode">BindingContext</code> of the view or one of its parents. The <a id="_idIndexMarker299"/>ViewModel exposes properties that define their data type, getter, and setter methods. The source property is identified through the Binding Path in the binding expression.</p>
<p class="normal">When you define a binding expression in XAML or create a binding object in code, a binding object is created and set for the specified target property. The XAML parser or the binding system creates the binding object and initializes it with the provided binding properties, such as <code class="inlineCode">Path</code>, <code class="inlineCode">Source</code>, <code class="inlineCode">Mode</code>, <code class="inlineCode">Converter</code>, and so on.</p>
<p class="normal">Here is a list of involved properties of target and source objects:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Target</strong> – This is the UI element involved and this UI element has to be a child of <code class="inlineCode">BindableObject</code>. The UI element used in <code class="inlineCode">ItemDetailPage</code> is <code class="inlineCode">Label</code>.</li>
<li class="bulletList"><strong class="keyWord">Target property</strong> – This is the property of the target object. It is a <code class="inlineCode">BindableProperty</code>. If the target is <code class="inlineCode">Label</code>, as we mentioned here, the target property can be the <code class="inlineCode">Text</code> property of <code class="inlineCode">Label</code>.</li>
<li class="bulletList"><strong class="keyWord">Source</strong> – This is the source object referenced by data binding. It is <code class="inlineCode">ItemDetailViewModel</code> here.</li>
<li class="bulletList"><strong class="keyWord">Source object value path</strong> – This is the path to the value in the source object. Here, the path is a <code class="inlineCode">ViewModel</code> property, such as <code class="inlineCode">Name</code> or <code class="inlineCode">Description</code>.</li>
</ul>
<p class="normal">Let’s <a id="_idIndexMarker300"/>look at <a id="_idIndexMarker301"/>the following code in <code class="inlineCode">ItemDetailPage</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;StackLayout Spacing="20" Padding="15"&gt;
  &lt;Label Text="Name:" FontSize="Medium" /&gt;
  &lt;Label Text="{Binding Name}" FontSize="Small"/&gt;                  //(1)
  &lt;Label Text="Description:" FontSize="Medium" /&gt;
  &lt;Label Text="{Binding Description}" FontSize="Small"/&gt;           //(2)
&lt;/StackLayout&gt;
</code></pre>
<p class="normal">In the XAML here, there are two data binding source paths, which are <code class="inlineCode">Name</code>, <strong class="keyWord">(1)</strong>, and <code class="inlineCode">Description</code>, <strong class="keyWord">(2)</strong>. The binding target is <code class="inlineCode">Label</code> and the target property is the <code class="inlineCode">Text</code> property of <code class="inlineCode">Label</code>. If we review the inheritance hierarchy of <code class="inlineCode">Label</code>, it looks like so:</p>
<pre class="programlisting con"><code class="hljs-con">Object -&gt; BindableObject -&gt; Element -&gt; NavigableElement -&gt; VisualElement -&gt; View -&gt; Label
</code></pre>
<p class="normal">We can see that <code class="inlineCode">Element</code>, <code class="inlineCode">VisualElement</code>, and <code class="inlineCode">View</code> are the derivatives of <code class="inlineCode">BindableObject</code>. The data binding target has to be a child of <code class="inlineCode">BindableObject</code>.</p>
<p class="normal">The binding source is the <code class="inlineCode">Name</code>, <strong class="keyWord">(1)</strong>, and <code class="inlineCode">Description</code>, <strong class="keyWord">(2)</strong>, properties of the ViewModel as shown in <em class="italic">Listing 4.1</em> here:</p>
<pre class="programlisting code"><code class="hljs-code">using PassXYZ.Vault.Models;
namespace PassXYZ.Vault.ViewModels {
[QueryProperty(nameof(ItemId), nameof(ItemId))]
public class ItemDetailViewModel : BaseViewModel {
        private string itemId;
        private string name;
        private string description;
        public string Id { get; set; }
        public string Name {                                      //(1)
            get =&gt; name;
            set =&gt; SetProperty(ref name, value);
        }
        public string Description...                              //(2)
        public string ItemId...
        public async void LoadItemId(string itemId) {             //(3)
            try {
                var item = await DataStore.GetItemAsync
                    (itemId);
                Id = item.Id;
                Name = item.Name;
                Description = item.Description;
            }
            catch (Exception) {
                Debug.WriteLine("Failed to Load Item");
            }
        }
}
</code></pre>
<p class="packt_figref">Listing 4.1: <code class="inlineCode">ItemDetailViewModel.cs</code> (<a href="https://epa.ms/ItemDetailViewModel4-1">https://epa.ms/ItemDetailViewModel4-1</a>)</p>
<p class="normal">The<a id="_idIndexMarker302"/> values of <code class="inlineCode">Name</code>, <strong class="keyWord">(1)</strong>, and <code class="inlineCode">Description</code>, <strong class="keyWord">(2)</strong>, are loaded from the model in the <code class="inlineCode">LoadItemId()</code> method, <strong class="keyWord">(3)</strong>. You may notice that the class is decorated by a <code class="inlineCode">QueryPropertyAttribute</code> attribute. This is used to pass parameters during page navigation, and it will be introduced in the next chapter.</p>
<p class="normal">Let’s use the<a id="_idIndexMarker303"/> following, <em class="italic">Table 4.1</em>, to summarize the data binding components in the code.</p>
<table class="table-container" id="table001-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Data binding elements</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Example</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Target</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">Label</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Target property</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">Text</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Source object</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ItemDetailViewModel</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Source object value path</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">Name</code> or <code class="inlineCode">Description</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 4.1: Data binding settings</p>
<h2 class="heading-2" id="_idParaDest-126">Properties of a Binding object</h2>
<p class="normal">Having analyzed<a id="_idIndexMarker304"/> the preceding code, let us have a look at the <a id="_idIndexMarker305"/>syntax of the binding expression:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;object property="{Binding bindProp1=value1[, bindPropN=valueN]*}" ... /&gt;
</code></pre>
<p class="normal">Binding properties can be set as a series of name-value pairs in the form of <code class="inlineCode">bindProp=value</code>. For example, see the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Label Text="{Binding Path=Description}" FontSize="Small"/&gt;
</code></pre>
<p class="normal">The <code class="inlineCode">Path</code> property is the default property, and it can be omitted if it is the first one in the property list as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Label Text="{Binding Description}" FontSize="Small"/&gt;
</code></pre>
<p class="normal">The binding properties that we mentioned here are the properties of the <code class="inlineCode">Binding</code> class, and you can find the details by referring to the Microsoft document about the <code class="inlineCode">Binding</code> class here: <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.maui.controls.binding">https://learn.microsoft.com/en-us/dotnet/api/microsoft.maui.controls.binding</a>.</p>
<p class="normal">As well as the <code class="inlineCode">Path</code> property, let’s review another two important binding properties, <code class="inlineCode">Source</code> and <code class="inlineCode">Mode</code>.</p>
<h3 class="heading-3" id="_idParaDest-127">Source</h3>
<p class="normal">The <code class="inlineCode">Source</code> property<a id="_idIndexMarker306"/> represents the object containing the source property (which will be bound to the target property). By default, the source object is the <code class="inlineCode">BindingContext</code> of the element, which is typically the ViewModel. However, you can use the <code class="inlineCode">Source</code> property to bind to other objects if needed.</p>
<p class="normal">Example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Label Text="{Binding Source={x:Reference someLabel}, Path=Text}" /&gt;
</code></pre>
<p class="normal">When we set data binding to the target, we can use the following two members of the target class:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">BindingContext</code> property gives us the source object</li>
<li class="bulletList">The <code class="inlineCode">SetBinding</code> method specifies the target property and source property</li>
</ul>
<p class="normal">In our<a id="_idIndexMarker307"/> case, we set the <code class="inlineCode">BindingContext</code> property to an instance of <code class="inlineCode">ItemDetailViewModel</code>, <strong class="keyWord">(1)</strong>, in the C# code-behind file of <code class="inlineCode">ItemDetailPage</code>, as shown in <em class="italic">Listing 4.2</em> here. It is set at the page level, and it applies to all binding targets on this page:</p>
<pre class="programlisting code"><code class="hljs-code">using PassXYZ.Vault.ViewModels;
using System.ComponentModel;
using Microsoft.Maui;
using Microsoft.Maui.Controls;
namespace PassXYZ.Vault.Views
{
  public partial class ItemDetailPage : ContentPage
  {
    public ItemDetailPage()
    {
      InitializeComponent();
      BindingContext = new ItemDetailViewModel();                 //(1)
    }
  }
}
</code></pre>
<p class="packt_figref">Listing 4.2: <code class="inlineCode">ItemDetailPage.xaml.cs</code> (<a href="https://epa.ms/ItemDetailPage4-2">https://epa.ms/ItemDetailPage4-2</a>)</p>
<p class="normal">Instead of using the <code class="inlineCode">Binding</code> markup extension, we can also create the binding using the <code class="inlineCode">SetBinding</code> method directly, as done here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;StackLayout Spacing="20" Padding="15"&gt;
  &lt;Label Text="Text:" FontSize="Medium" /&gt;
  &lt;Label x:Name="labelText" FontSize="Small"/&gt;                     //(2)
  &lt;Label Text="Description:" FontSize="Medium" /&gt;
  &lt;Label Text="{Binding Description}" FontSize="Small"/&gt;
&lt;/StackLayout&gt;
</code></pre>
<p class="normal"><strong class="keyWord">(2)</strong> In the XAML code, we removed the <code class="inlineCode">Binding</code> markup extension and specified the instance name as <code class="inlineCode">labelText</code>. In the C# code-behind file, we can call the <code class="inlineCode">SetBinding</code> method, <strong class="keyWord">(3)</strong>, in the <a id="_idIndexMarker308"/>constructor of <code class="inlineCode">ItemDetailPage</code> to create the data binding for the <code class="inlineCode">Text</code> property:</p>
<pre class="programlisting code"><code class="hljs-code">    public ItemDetailPage()
    {
        InitializeComponent();
        BindingContext = new ItemDetailViewModel();
        labelText.SetBinding(Label.TextProperty, "Text");          //(3)
    }
</code></pre>
<h3 class="heading-3" id="_idParaDest-128">Binding mode</h3>
<p class="normal">The <code class="inlineCode">Mode</code> property <a id="_idIndexMarker309"/>specifies the direction of data flow in the binding, such as if data flows only from the ViewModel to the UI or if it flows in both directions.</p>
<p class="normal">In <code class="inlineCode">ItemDetailPage</code>, all UI elements are <code class="inlineCode">Label</code> objects, which are not editable for the user. This is one-way binding from the source to the target. The changes in the source object will cause updates in the target object.</p>
<p class="normal">There are four binding modes supported in .NET MAUI. Let’s review them by referring to <em class="italic">Figure 4.5</em>.</p>
<figure class="mediaobject"><img alt="Figure 4.4: Binding mode" height="213" src="img/B21554_04_05.png" width="710"/></figure>
<p class="packt_figref">Figure 4.5: Binding mode</p>
<p class="normal">Let’s look at the binding modes supported in <code class="inlineCode">.NET MAUI</code>:</p>
<ul>
<li class="bulletList"><code class="inlineCode">OneWay</code> binding is <a id="_idIndexMarker310"/>usually used in the case of presenting data to the user. In our app, we will retrieve a list of password entries and display this list on <code class="inlineCode">ItemsPage</code>. When the user clicks an item in the list, the password details will show on <code class="inlineCode">ItemDetailPage</code>. <code class="inlineCode">OneWay</code> binding is used in both cases.</li>
<li class="bulletList"><code class="inlineCode">TwoWay</code> binding<a id="_idIndexMarker311"/> causes changes to either the source property or the target property to automatically update the other. In our app, when the user edits the fields of a password entry or when the user enters a username and password on <code class="inlineCode">LoginPage</code>, the target UI <code class="inlineCode">Entry</code> component and the source view model object are set with <code class="inlineCode">TwoWay</code>.</li>
<li class="bulletList"><code class="inlineCode">OneWayToSource</code> is the <a id="_idIndexMarker312"/>reverse of the <code class="inlineCode">OneWay</code> binding mode. When the target property is changed, the source property will be updated. When we add a new password entry on <code class="inlineCode">NewItemPage</code>, we can use <code class="inlineCode">OneWayToSource</code> instead of the <code class="inlineCode">TwoWay</code> binding mode to improve performance.</li>
<li class="bulletList"><code class="inlineCode">OneTime</code> binding is <a id="_idIndexMarker313"/>a binding mode that is not shown in <em class="italic">Figure 4.4</em>. The target properties are initialized from the source properties, but any further changes to the source properties won’t update the target properties. It is a simpler form of the <code class="inlineCode">OneWay</code> binding mode with better performance.</li>
</ul>
<p class="normal">If we don’t specify <a id="_idIndexMarker314"/>the binding mode in data binding, the default binding mode is used. We can overwrite the default binding mode if it is needed.</p>
<p class="normal">In our <code class="inlineCode">ItemsPage</code> code, we use the <code class="inlineCode">ListView</code> control to display the list of password groups and entries, so we should set the <code class="inlineCode">IsRefreshing</code> attribute to the <code class="inlineCode">OneWay</code> binding mode:</p>
<pre class="programlisting code"><code class="hljs-code">IsRefreshing="{Binding IsBusy, Mode=OneWay}"
</code></pre>
<p class="normal">When we add a new item in <code class="inlineCode">NewItemPage</code>, we use the <code class="inlineCode">Entry</code> and <code class="inlineCode">Editor</code> controls to edit the properties. We can use the <code class="inlineCode">OneWayToSource</code> or <code class="inlineCode">TwoWay</code> binding modes:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Label Text="Text" FontSize="Medium" /&gt;
&lt;Entry Text="{Binding Text, Mode=TwoWay}" FontSize="Medium"/&gt;
&lt;Label Text="Description" FontSize="Medium" /&gt;
&lt;Editor Text="{Binding Description, Mode=OneWayToSource}"
  AutoSize="TextChanges" FontSize="Medium" Margin="0" /&gt;
</code></pre>
<h2 class="heading-2" id="_idParaDest-129">Changing notifications in ViewModels</h2>
<p class="normal">In <em class="italic">Figure 4.5</em>, we can <a id="_idIndexMarker315"/>see the data binding target is a derived class of <code class="inlineCode">BindableObject</code>. Besides this requirement, in the data binding setup, the data source (ViewModel) needs to implement the <code class="inlineCode">INotifyPropertyChanged</code> interface so that when the property changes, a <code class="inlineCode">PropertyChanged</code> event is raised to notify the change.</p>
<p class="normal">In an MVVM pattern, the<a id="_idIndexMarker316"/> ViewModel is usually the data binding source so we need to implement the <code class="inlineCode">INotifyPropertyChanged</code> interface in our ViewModels. If we do this for each ViewModel class, there will be a lot of duplicated code. In a Visual Studio template, a <code class="inlineCode">BaseViewModel</code> class, as we can see in <em class="italic">Listing 4.3</em>, is included in the boilerplate code and we use it in our app. Other ViewModels inherit this class:</p>
<pre class="programlisting code"><code class="hljs-code">namespace PassXYZ.Vault.ViewModels;
public class BaseViewModel : INotifyPropertyChanged              //(1)
{
  public IDataStore&lt;Item&gt; DataStore =&gt;
    DependencyService.Get&lt;IDataStore&lt;Item&gt;&gt;();
  bool isBusy = false;
  public bool IsBusy {
    get { return isBusy; }
    set { SetProperty(ref isBusy, value); }                      //(2)
  }
  string title = string.Empty;
  public string Title {
    get { return title; }
    set { SetProperty(ref title, value); }
  }
  protected bool SetProperty&lt;T&gt;(ref T backingStore,
      T value,
      [CallerMemberName] string propertyName = "",
      Action onChanged = null) {
    if (EqualityComparer&lt;T&gt;.Default.Equals
        (backingStore, value))
        return false;
    backingStore = value;
    onChanged?.Invoke();
    OnPropertyChanged(propertyName);
    return true;
  }
#region INotifyPropertyChanged
 public event PropertyChangedEventHandler PropertyChanged;        //(4)
  protected void OnPropertyChanged([CallerMemberName]
    string propertyName = "") {                                   //(3)
    var changed = PropertyChanged;
    if (changed == null)
        return;
    changed.Invoke(this, new PropertyChangedEventArgs(propertyName));
  }
#endregion
}
</code></pre>
<p class="packt_figref">Listing 4.3 <code class="inlineCode">BaseViewModel.cs</code> (<a href="https://epa.ms/BaseViewModel4-3">https://epa.ms/BaseViewModel4-3</a>)</p>
<p class="normal">In the <code class="inlineCode">BaseViewModel</code> class (<em class="italic">Listing 4.3</em>), we can see the following:</p>
<p class="normal"><strong class="keyWord">(1)</strong> <code class="inlineCode">BaseViewModel</code> implements the <code class="inlineCode">INotifyPropertyChanged</code> interface and this interface defines a single event, <code class="inlineCode">PropertyChanged</code>, <strong class="keyWord">(4)</strong>.</p>
<p class="normal"><strong class="keyWord">(3)</strong> When a <a id="_idIndexMarker317"/>property is changed in the setter, the <code class="inlineCode">OnPropertyChanged</code> method is called. In <code class="inlineCode">OnPropertyChanged</code>, the <code class="inlineCode">PropertyChanged</code> event is fired. A copy of the <code class="inlineCode">PropertyChanged</code> event handler is stored in the <strong class="keyWord">changed</strong> local variable, so this implementation is safe in a multi-thread environment. When the <code class="inlineCode">PropertyChanged</code> event is fired, it needs to pass the property name as a parameter to indicate which property is changed. The <code class="inlineCode">CallerMemberName</code> attribute can be used to find the method name or property name of the caller, so we don’t need to hardcode the property name.</p>
<p class="normal"><strong class="keyWord">(2)</strong> When we define a property in the ViewModel, the <code class="inlineCode">OnPropertyChanged</code> method is called in the setter – but as you can see, in our code, we call <code class="inlineCode">SetProperty&lt;T&gt;</code> instead of <code class="inlineCode">OnPropertyChanged</code> directly. <code class="inlineCode">SetProperty&lt;T&gt;</code> will do additional work before it calls <code class="inlineCode">OnPropertyChanged</code>. It checks whether the value is changed. If there is no change, it will return and do nothing. If the value is changed, it will update the backing field and call <code class="inlineCode">OnPropertyChanged</code> to fire the change event.</p>
<p class="normal">If we recall <code class="inlineCode">ItemDetailViewModel</code> in <em class="italic">Listing 4.1</em>, it inherits from the <code class="inlineCode">BaseViewModel</code> class. In the setter of the <code class="inlineCode">Name</code> and <code class="inlineCode">Description</code> properties, we call <code class="inlineCode">SetProperty&lt;T&gt;</code> to set the values and fire the <code class="inlineCode">PropertyChanged</code> event:</p>
<pre class="programlisting code"><code class="hljs-code">        public string Name {
            get =&gt; name;
            set =&gt; SetProperty(ref name, value);
        }
        public string Description {
            get =&gt; description;
            set =&gt; SetProperty(ref description, value);
        }
</code></pre>
<p class="normal">In this section, we<a id="_idIndexMarker318"/> learned about data binding and the <code class="inlineCode">INotifyPropertyChanged</code> interface. We need to create boilerplate code to define a property with change notification support. To simplify the code and autogenerate boilerplate code behind the scenes, we can use the MVVM Toolkit.</p>
<h1 class="heading-1" id="_idParaDest-130">.NET Community Toolkit</h1>
<p class="normal">In this section, we <a id="_idIndexMarker319"/>will use the MVVM Toolkit to refactor our ViewModel code. The MVVM Toolkit is a module within the .NET Community Toolkit, specifically designed for building applications following the MVVM design pattern.</p>
<p class="normal">The .NET Community Toolkit (formerly Windows Community Toolkit) is a collection of helper functions, custom controls, and app services designed to simplify and accelerate .NET app development. The toolkit is open source and maintained by the community, offering a suite of tools for various .NET development platforms, such as .NET MAUI, Xamarin, UWP, WPF, and WinUI. The toolkit provides useful components that developers can use out of the box to easily build applications with a rich user interface, common app services, animations, and more.</p>
<p class="normal">The MVVM Toolkit <a id="_idIndexMarker320"/>supplies a set of base classes, utilities, and attributes that make implementing the MVVM pattern in your .NET applications more efficient and straightforward. The MVVM Toolkit provides the following key components:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ObservableObject</code>: A base <a id="_idIndexMarker321"/>class that simplifies the<a id="_idIndexMarker322"/> implementation of objects that raise PropertyChanged events, such as ViewModels. It implements the <code class="inlineCode">INotifyPropertyChanged</code> interface and provides the <code class="inlineCode">SetProperty</code> method to handle property change notifications.</li>
<li class="bulletList"><code class="inlineCode">RelayCommand</code> and <code class="inlineCode">AsyncRelayCommand</code>: Classes implementing the <code class="inlineCode">ICommand</code> interface, designed to<a id="_idIndexMarker323"/> handle executing<a id="_idIndexMarker324"/> methods and checking if a command can execute. They make it easy to create commands for your ViewModel that react to UI actions.</li>
<li class="bulletList"><strong class="keyWord">Dependency</strong> <strong class="keyWord">Injection</strong> <strong class="keyWord">support</strong>: The MVVM Toolkit offers built-in support for dependency<a id="_idIndexMarker325"/> injection, making it simple to integrate services into your ViewModels using popular dependency injection libraries like <code class="inlineCode">Microsoft.Extensions.DependencyInjection</code>.</li>
<li class="bulletList"><strong class="keyWord">Messenger</strong> (<strong class="keyWord">Event Aggregator</strong>): The MVVM Toolkit provides a lightweight messenger<a id="_idIndexMarker326"/> service that enables decoupled, message-based communication between components, like<a id="_idIndexMarker327"/> different ViewModels. This promotes a separation of concerns and makes each component more testable.</li>
</ul>
<p class="normal">Please find more information about the MVVM Toolkit in the <em class="italic">Further reading</em> section.</p>
<h2 class="heading-2" id="_idParaDest-131">How to use the MVVM Toolkit</h2>
<p class="normal">To use<a id="_idIndexMarker328"/> the MVVM Toolkit in .NET MAUI, follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Add the .NET <code class="inlineCode">CommunityToolkit.Mvvm</code> NuGet package to our project file as follows:
        <pre class="programlisting code"><code class="hljs-code">&lt;ItemGroup&gt;
  &lt;PackageReference Include="CommunityToolkit.Mvvm"
    Version="8.2.1" /&gt;
&lt;/ItemGroup&gt;
</code></pre>
</li>
<li class="numberedList">Refactor ViewModel using MVVM Toolkit Source Generators. Source Generators is a C# compiler feature that allows executing custom code at compile time to modify the compilation output. The MVVM Toolkit supports using Source Generators to automatically generate ViewModel and <code class="inlineCode">ICommand</code> boilerplate code based on attributes, which can simplify ViewModel creation.</li>
</ol>
<p class="normal">The MVVM Toolkit can help us to simplify ViewModel by using Source Generators. If we want to add a property in ViewModel as a data binding source, we need to implement the <code class="inlineCode">INotifyPropertyChanged</code> interface. For example, in <code class="inlineCode">ItemDetailViewModel</code>, we implement the <code class="inlineCode">Description</code> property as follows:</p>
<pre class="programlisting code"><code class="hljs-code">private string description;
public string Description {
  get =&gt; description;
  set =&gt; SetProperty(ref description, value);
}
</code></pre>
<p class="normal">In the Setter, the <code class="inlineCode">SetProperty</code> method is called, and it will update the backing field and call <code class="inlineCode">OnPropertyChanged</code> to fire the change event. Both <code class="inlineCode">SetProperty</code> and <code class="inlineCode">OnPropertyChanged</code> are defined in the <code class="inlineCode">BaseViewModel</code> class, as we can see in <em class="italic">Listing 4.3</em>.</p>
<p class="normal">Using the MVVM Toolkit, we can inherit from <code class="inlineCode">ObservableObject</code> instead of <code class="inlineCode">BaseViewModel</code>. <code class="inlineCode">ObservableObject</code> implements the <code class="inlineCode">INotifyPropertyChanged</code> interface similar to what we have done in <code class="inlineCode">BaseViewModel</code>. With <code class="inlineCode">ObservableObject</code>, we can simplify the above implementation as follows:</p>
<pre class="programlisting code"><code class="hljs-code">[ObservableProperty]
private string description;
</code></pre>
<p class="normal">As we can<a id="_idIndexMarker329"/> see, using the <code class="inlineCode">ObservableProperty</code><strong class="keyWord"> </strong>attribute, we can define the backing field only in the code. Source Generators will help us to generate boilerplate code. We can use the <code class="inlineCode">Description</code> property in XAML as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Label Text="{Binding Description}"
  FontSize="Small"
  TextType ="Html"
  Style="{DynamicResource ListItemDetailTextStyle}" /&gt;
</code></pre>
<p class="normal">In the MVVM pattern, we can define a ViewModel property as an observable property to support TwoWay binding. We can also define a ViewModel property as an <code class="inlineCode">ICommand</code> interface to handle UI events using data binding.</p>
<p class="normal">In our app, we display a list of items in <code class="inlineCode">ItemsPage</code>. In <code class="inlineCode">ItemsPage</code>, we need to load a list of items from the data source, and we also need to support adding a new item. We need to define two <code class="inlineCode">ICommand</code> interfaces as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public class ItemsViewModel : BaseViewModel
{
  ...
  public Command LoadItemsCommand { get; }                      //(1)
  public Command AddItemCommand { get; }                        //(2)
 
  public ItemsViewModel()
  {
    ...
    LoadItemsCommand = new Command(
        async () =&gt; await LoadItems());                         //(3)
    AddItemCommand = new Command(AddItem);                      //(4)
    ...
  }
  private async Task LoadItems()                                //(5)
  {
    ...
  }
  private async void AddItem(object obj)                        //(6)
  {
    await Shell.Current.GoToAsync(nameof(NewItemPage));
  }
  ...
}
</code></pre>
<p class="normal">In the above<a id="_idIndexMarker330"/> implementation, we define two properties, <code class="inlineCode">LoadItemsCommand</code><strong class="keyWord">(1)</strong> and <code class="inlineCode">AddItemCommand</code><strong class="keyWord">(2)</strong>, as the type <code class="inlineCode">Microsoft.Maui.Controls.Command</code>. In the constructor of ViewModel, we initialize them<strong class="keyWord">(3)(4)</strong> with the private methods <code class="inlineCode">LoadItems</code><strong class="keyWord">(5)</strong> and <code class="inlineCode">AddItem</code><strong class="keyWord">(6)</strong>.</p>
<p class="normal">Using the MVVM Toolkit, we can simplify the implementation as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public partial class ItemsViewModel : BaseViewModel
{
  ...
  [RelayCommand]
  private async void AddItem(object obj)                        //(1)
  {
    await Shell.Current.GoToAsync(nameof(NewItemPage));
  }
 
  ...
 
  [RelayCommand]
  private async Task LoadItems()                                //(2)
  {
    ...
  }
}
</code></pre>
<p class="normal">We can see that we just need to add <code class="inlineCode">RelayCommandAttribute</code> in front of <code class="inlineCode">AddItem</code> <code class="codeHighlighted" style="font-weight: bold;">(1)</code> and <code class="inlineCode">LoadItems</code> <code class="codeHighlighted" style="font-weight: bold;">(2)</code> to <a id="_idIndexMarker331"/>implement <code class="inlineCode">ICommand</code> properties. Source Generators will help us generate the rest of the code.</p>
<p class="normal">Having introduced the basic knowledge of XAML UI design, the MVVM pattern, and data binding, we can improve our app using the knowledge we just learned.</p>
<h1 class="heading-1" id="_idParaDest-132">Improving the data model and service</h1>
<p class="normal">After<a id="_idIndexMarker332"/> introducing the MVVM pattern, data binding, and the MVVM Toolkit, we have the fundamental knowledge of how to use data binding. In the rest of this chapter, we will explore advanced topics about data binding. We will discuss how to bind to collections first and then we will introduce custom views. Using custom views, we can make XAML code cleaner and more concise.</p>
<p class="normal">To examine these topics, a more intricate model layer is required. Instead of creating a hypothetical model layer, we’ll work with the actual model layer in our app, which includes two .NET libraries: <strong class="keyWord">KPCLib</strong> and <strong class="keyWord">PassXYZLib</strong>.</p>
<p class="normal">To introduce the model layer of our app, let us review the use cases again. We are developing a cross-platform password manager app that is compatible with the popular <strong class="keyWord">KeePass</strong> database format. We have the following use cases:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Use case 1</strong>: <code class="inlineCode">LoginPage</code> – As a password manager user, I want to log in to the password manager app so that I can access my password data.</li>
<li class="bulletList"><strong class="keyWord">Use case 2</strong>: <code class="inlineCode">AboutPage</code> – As a password manager user, I want to have an overview of my database and the app that I am using.</li>
<li class="bulletList"><strong class="keyWord">Use case 3</strong>: <code class="inlineCode">ItemsPage</code> – As a password manager user, I want to see a list of groups and entries so that I can explore and examine my password data.</li>
<li class="bulletList"><strong class="keyWord">Use case 4</strong>: <code class="inlineCode">ItemDetailPage</code> – As a password manager user, I want to see the details of a password entry after I select it in the list of password entries.</li>
<li class="bulletList"><strong class="keyWord">Use case 5</strong>: <code class="inlineCode">NewItemPage</code> – As a password manager user, I want to add a password entry or create a new group in my database.</li>
</ul>
<p class="normal">These five use cases are inherited from the Visual Studio template, and they are sufficient for the user stories of our password manager app for the moment. We will improve our app using these user stories in this chapter.</p>
<p class="normal">We implemented our app using the MVVM pattern, but the <code class="inlineCode">Item</code> model below is too simple and is not sufficient to be used in a password manager app:</p>
<pre class="programlisting code"><code class="hljs-code">public class Item
{
  public string Id { get; set; }
  public string Name { get; set; }
  public string Description { get; set; }
}
</code></pre>
<p class="normal">The major<a id="_idIndexMarker333"/> functionalities of our password manager app are encapsulated in the model layer. We will build our model using two .NET packages, KPCLib and PassXYZLib. These two packages include all the password management features we need.</p>
<h2 class="heading-2" id="_idParaDest-133">KPCLib</h2>
<p class="normal">The model <a id="_idIndexMarker334"/>that <a id="_idIndexMarker335"/>we will use is a library from <strong class="keyWord">KeePass</strong> called <code class="inlineCode">KeePassLib</code>. Both KeePass and <code class="inlineCode">KeePassLib</code> are built for .NET Framework, so they can only be used on Windows. I ported <code class="inlineCode">KeePassLib</code> and rebuilt it as a .NET Standard 2.0 library packaged as KPCLib. KPCLib can <a id="_idIndexMarker336"/>be found on NuGet and GitHub here:</p>
<ul>
<li class="bulletList">NuGet: <a href="https://www.nuget.org/packages/KPCLib/">https://www.nuget.org/packages/KPCLib/</a></li>
<li class="bulletList">GitHub: <a href="https://github.com/passxyz/KPCLib">https://github.com/passxyz/KPCLib</a></li>
</ul>
<p class="normal">KPCLib is used <a id="_idIndexMarker337"/>both as a package name and a namespace. The package of KPCLib includes two namespaces, <code class="inlineCode">KeePassLib</code> and <code class="inlineCode">KPCLib</code>. The <code class="inlineCode">KeePassLib</code> namespace is the original one from KeePass with the following changes:</p>
<ul>
<li class="bulletList">Updated and built for .NET Standard 2.0</li>
<li class="bulletList">Updated <code class="inlineCode">PwEntry</code> and <code class="inlineCode">PwGroup</code> to be classes derived from the <code class="inlineCode">Item</code> abstract class</li>
</ul>
<p class="normal">In the KPCLib namespace, an <code class="inlineCode">Item</code> abstract class is defined. The reason I created a new class and made it the parent class of <code class="inlineCode">PwEntry</code> and <code class="inlineCode">PwGroup</code> is due to the navigation design difference between <code class="inlineCode">KeePass</code> and <code class="inlineCode">PassXYZ.Vault</code>.</p>
<p class="normal">If we look at the UI of KeePass in <em class="italic">Figure 4.5</em>, we can see that it is a classic Windows desktop UI. The navigation is designed around a tree view like Windows Explorer.</p>
<figure class="mediaobject"><img alt="Figure 4.5: KeePass UI" height="419" src="img/B21554_04_06.png" width="459"/></figure>
<p class="packt_figref">Figure 4.6: KeePass UI</p>
<p class="normal">Two <a id="_idIndexMarker338"/>classes, <code class="inlineCode">PwGroup</code> and <code class="inlineCode">PwEntry</code>, behave like directories and files. A <code class="inlineCode">PwGroup</code> instance is just like a directory, and it includes a list of children – <code class="inlineCode">PwGroup</code> and <code class="inlineCode">PwEntry</code>. All <code class="inlineCode">PwGroup</code> instances are displayed in a tree view on the right-hand panel. When a <code class="inlineCode">PwGroup</code> instance is selected, the list of <code class="inlineCode">PwEntry</code> in this group is shown on the right-hand panel. <code class="inlineCode">PwEntry</code> includes the content of a password entry, such as a username and password. The content of <code class="inlineCode">PwEntry</code> is displayed on the bottom panel.</p>
<p class="normal">In the <code class="inlineCode">PassXYZ.Vault</code> UI design, we use a .NET MAUI Shell template. It is an implementation of the stacked Master-Detail pattern. In the stacked Master-Detail pattern, a single list is used to display items. In this case, the instances of both <code class="inlineCode">PwGroup</code> and <code class="inlineCode">PwEntry</code> can be displayed in the same list. After an item is selected, we will take an action according to the type of the item.</p>
<h3 class="heading-3" id="_idParaDest-134">Abstraction of PwGroup and PwEntry</h3>
<p class="normal">To <a id="_idIndexMarker339"/>work <a id="_idIndexMarker340"/>with the PassXYZ.Vault UI design better, we can abstract <code class="inlineCode">PwGroup</code> and <code class="inlineCode">PwEntry</code> as <a id="_idIndexMarker341"/>the <code class="inlineCode">Item</code> abstract class, as shown in <em class="italic">Figure 4.7</em>.</p>
<figure class="mediaobject"><img alt="Figure 4.6: Class diagram of Item" height="522" src="img/B21554_04_07.png" width="669"/></figure>
<p class="packt_figref">Figure 4.7: Class diagram of Item</p>
<p class="normal">Referring <a id="_idIndexMarker342"/>to the<a id="_idIndexMarker343"/> UML class diagram in <em class="italic">Figure 4.7</em> and the source code of <code class="inlineCode">Item.cs</code> in <em class="italic">Listing 4.4</em>, we can see the following properties are defined in the <code class="inlineCode">Item</code> abstract class. These <a id="_idIndexMarker344"/>properties are implemented in both <code class="inlineCode">PwEntry</code> and <code class="inlineCode">PwGroup</code>:</p>
<p class="normal"><strong class="keyWord">(1)</strong> <code class="inlineCode">Name</code>: the <code class="inlineCode">Item</code> name</p>
<p class="normal"><strong class="keyWord">(2)</strong> <code class="inlineCode">Description</code>: the <code class="inlineCode">Item</code> description</p>
<p class="normal"><strong class="keyWord">(3)</strong> <code class="inlineCode">Notes</code>: <code class="inlineCode">Item</code> comments defined by the user</p>
<p class="normal"><strong class="keyWord">(4)</strong> <code class="inlineCode">IsGroup</code>: <code class="inlineCode">true</code> if the instance is <code class="inlineCode">PwGroup</code> or <code class="inlineCode">false</code> if it is <code class="inlineCode">PwEntry</code></p>
<p class="normal"><strong class="keyWord">(5)</strong> <code class="inlineCode">Id</code>: ID of the instance (a unique value that is like the primary key in a database)</p>
<p class="normal"><strong class="keyWord">(6)</strong> <code class="inlineCode">ImgSource</code>: image source of the icon (both <code class="inlineCode">PwGroup</code> and <code class="inlineCode">PwEntry</code> can have an associated icon)</p>
<p class="normal"><strong class="keyWord">(7)</strong> <code class="inlineCode">LastModificationTime</code>: the last modification time of the item</p>
<p class="normal"><strong class="keyWord">(8)</strong> <code class="inlineCode">Item</code>: implements the <code class="inlineCode">INotifyPropertyChanged</code> interface, and it can work well in the MVVM model <a id="_idIndexMarker345"/>for data <a id="_idIndexMarker346"/>binding:</p>
<pre class="programlisting code"><code class="hljs-code">using System.Text;
namespace KPCLib
{
  public abstract class Item : INotifyPropertyChanged             //(8)
  {
    public abstract DateTime LastModificationTime {get;
        set;};}                                                   //(7)
    public abstract string Name { get; set; }                     //(1)
    public abstract string Description { get;}                    //(2)
    public abstract string Notes { get; set; }                    //(3)
    public abstract bool IsGroup { get; }                         //(4)
    public abstract string Id { get; }                            //(5)
    virtual public Object ImgSource { get; set; }                 //(6)
#region INotifyPropertyChanged ...
  }
}
</code></pre>
<p class="packt_figref">Listing 4.4: <code class="inlineCode">Item.cs</code> (<a href="https://epa.ms/Item4-4">https://epa.ms/Item4-4</a>)</p>
<h2 class="heading-2" id="_idParaDest-135">PassXYZLib</h2>
<p class="normal">To use <a id="_idIndexMarker347"/>KeePassLib in <code class="inlineCode">PassXYZ.Vault</code>, we <a id="_idIndexMarker348"/>need to use some .NET MAUI APIs to extend the functionalities required of our app. To separate the business logic <a id="_idIndexMarker349"/>from the UI and extend the functionalities of <code class="inlineCode">KeePassLib</code> for .NET MAUI, a .NET MAUI class library, PassXYZLib, is created to encapsulate the extended model in a separate library. PassXYZLib is both a package name and a namespace.</p>
<p class="normal">To <a id="_idIndexMarker350"/>add PassXYZLib to our project, we can add it to a <code class="inlineCode">PassXYZ.Vault.csproj</code> project file, as seen here:</p>
<pre class="programlisting code"><code class="hljs-code">  &lt;ItemGroup&gt;
    &lt;PackageReference Include="PassXYZLib" Version="2.1.2" /&gt;
  &lt;/ItemGroup&gt;
</code></pre>
<p class="normal">We can also add a PassXYZLib package from the command line here. From the command line, go to the project folder and execute this command to add the package:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet add package PassXYZLib
</code></pre>
<h2 class="heading-2" id="_idParaDest-136">Updating the model</h2>
<p class="normal">After<a id="_idIndexMarker351"/> we add a PassXYZLib package to the project, we can access the KPCLib, <code class="inlineCode">KeePassLib</code>, and <code class="inlineCode">PassXYZLib</code> namespaces. To replace the current model, we need to remove the <code class="inlineCode">Models/Item.cs</code> file from the project.</p>
<p class="normal">After that, we need to replace the <code class="inlineCode">PassXYZ.Vault.Models</code> namespace with KPCLib. In <em class="italic">Figure 4.8a</em>, we can see that the <code class="inlineCode">Item</code> in namespace <code class="inlineCode">PassXYZ.Vault.Models</code> is used.</p>
<figure class="mediaobject"><img alt="A screenshot of a computer program  Description automatically generated" height="497" src="img/B21554_04_08a.png" width="824"/></figure>
<p class="packt_figref">Figure 4.8a: PassXYZ.Vault.Models before update to KPCLib</p>
<p class="normal">After the <code class="inlineCode">PassXYZ.Vault.Models</code> namespace is replaced, in <em class="italic">Figure 4.8b</em>, the <code class="inlineCode">Item</code> from the <code class="inlineCode">KBCLib</code> namespace is utilized. Comparing the implementation before and after the transition, we can observe that the rest of the code remains largely unchanged. By adopting the MVVM pattern, most of the business logic is encapsulated within the model layer.</p>
<figure class="mediaobject"><img alt="A screenshot of a computer program  Description automatically generated" height="618" src="img/B21554_04_08b.png" width="825"/></figure>
<p class="packt_figref">Figure 4.8b: Updated to KPCLib</p>
<p class="normal">For the<a id="_idIndexMarker352"/> remaining changes in view models and views, all modifications pertain to namespace changes, so further explanations aren’t necessary.</p>
<h2 class="heading-2" id="_idParaDest-137">Updating the service</h2>
<p class="normal">The major<a id="_idIndexMarker353"/> changes can be found in <code class="inlineCode">MockDataStore.cs</code>. In the <code class="inlineCode">MockDataStore</code> class, we changed the namespace and the mock data initialization.</p>
<p class="normal">To decouple the model from the rest of the system, we use an <code class="inlineCode">IDataStore</code> interface to encapsulate the actual implementation. At this stage, we use mock data to implement the service for testing, so the <code class="inlineCode">MockDataStore</code> class is used. We will replace it with the actual implementation in <em class="chapterRef">Chapter 6</em>, <em class="italic">Software Design with Dependency Injection,</em> using dependency injection.</p>
<div><p class="normal"><strong class="keyWord">Dependency inversion and dependency injection</strong></p>
<p class="normal">We will learn<a id="_idIndexMarker354"/> about the <strong class="keyWord">Dependency Inversion Principle</strong> (<strong class="keyWord">DIP</strong>), which is one of the SOLID design principles, in <em class="chapterRef">Chapter 6</em>, <em class="italic">Software Design with Dependency Injection</em>. We will learn how to use dependency injection to manage the mapping of the <code class="inlineCode">IDataStore</code> interface to the actual implementation.</p>
</div>
<p class="normal">In the <a id="_idIndexMarker355"/>original code, we created new instances of <code class="inlineCode">PassXYZ.Vault.Models.Item</code> to initialize mock data. After we replace the model, we cannot create <code class="inlineCode">KPCLib.Item</code> directly, since it is an abstract class. Instead, we can create new instances of <code class="inlineCode">PxEntry</code> using JSON data and assign <code class="inlineCode">PxEntry</code> instances to the <code class="inlineCode">Item</code> list:</p>
<pre class="programlisting code"><code class="hljs-code">    Static string[] jsonData =…;
    readonly List&lt;Item&gt; items;
    public MockDataStore() {
        items = new List&lt;Item&gt;() {
            new PxEntry(jsonData[0]),
            new PxEntry(jsonData[1]),
            new PxEntry(jsonData[2]),
            new PxEntry(jsonData[3]),
            new PxEntry(jsonData[4])
        };
    }
</code></pre>
<p class="normal">To create the instances of an abstract class, the factory pattern can be used. To make the testing code simple, we did not use it here. The factory pattern is used in the actual implementation later in this book.</p>
<p class="normal">We have replaced the model in the sample code with our own model now. With this change, we can improve <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemDetailPage</code> to reflect the updated model.</p>
<p class="normal">We will update the view and ViewModel using data binding to collections in the next section.</p>
<h1 class="heading-1" id="_idParaDest-138">Binding to collections</h1>
<p class="normal">In the previous<a id="_idIndexMarker356"/> section, we replaced the model using PassXYZLib. When we introduced data binding, we used <code class="inlineCode">ItemDetailPage</code> and <code class="inlineCode">ItemDetailViewModel</code> to explain how to bind the source property to the target property. </p>
<p class="normal">For the item detail page, we created data binding from one source to one target. However, there are many cases in which we need to bind a data collection to the UI, such as <code class="inlineCode">ListView</code> or <code class="inlineCode">CollectionView</code>, to display a group of data.</p>
<figure class="mediaobject"><img alt="Figure 4.8: Binding to collections" height="240" src="img/B21554_04_09.png" width="825"/></figure>
<p class="packt_figref">Figure 4.9: Binding to collections</p>
<p class="normal">As we can see in <em class="italic">Figure 4.9</em>, when we create a data binding from a collection object to a collection view, the <code class="inlineCode">ItemsSource</code> property is the one to use. In .NET MAUI, collection views such as <code class="inlineCode">ListView</code> and <code class="inlineCode">CollectionView</code> can be used, and both have an <code class="inlineCode">ItemsSource</code> property.</p>
<p class="normal">For the collection object, we can use any collection that implements the <code class="inlineCode">IEnumerable</code> interface. However, the changes to the collection object may not be able to update the UI automatically. In order to update the UI automatically, the source object needs to implement the <code class="inlineCode">INotifyCollectionChanged</code> interface.</p>
<p class="normal">We can implement our collection object with the <code class="inlineCode">INotifyCollectionChanged</code> interface, but the simplest approach is to use the <code class="inlineCode">ObservableCollection&lt;T&gt;</code> class. If any item in the observable collection is changed, the bound UI view is notified automatically.</p>
<p class="normal">With this in mind, let’s review the class diagram of our <strong class="keyWord">models</strong>, <strong class="keyWord">ViewModels</strong>, and <strong class="keyWord">views</strong> as shown in <em class="italic">Figure 4.9</em>:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Model</strong>: <code class="inlineCode">Item</code>, <code class="inlineCode">PwEntry</code>, <code class="inlineCode">PwGroup</code>, <code class="inlineCode">Field</code></li>
<li class="bulletList"><strong class="keyWord">View Model</strong>: <code class="inlineCode">ItemsViewModel</code>, <code class="inlineCode">ItemDetailViewModel</code></li>
<li class="bulletList"><strong class="keyWord">View</strong>: <code class="inlineCode">ItemsPage</code>, <code class="inlineCode">ItemDetailPage</code></li>
</ul>
<p class="normal">When we display a list of items to the user, the user may act on the selected item. If the item is a group, we will show the groups and entries in an instance of <code class="inlineCode">ItemsPage</code>. If the item is an entry, we will show the content of the entry on a content page, which is an instance of <code class="inlineCode">ItemDetailPage</code>. On <code class="inlineCode">ItemDetailPage</code>, we display a list of fields to the user. Each field is a key value pair and is implemented as an instance of the <code class="inlineCode">Field</code> class.</p>
<p class="normal">In summary, we<a id="_idIndexMarker357"/> display two kinds of lists to the user – a list of items or a list of fields. The list of items is shown in <code class="inlineCode">ItemsPage</code> and the list of fields is shown in <code class="inlineCode">ItemDetailPage</code>.</p>
<figure class="mediaobject"><img alt="Figure 4.9: Class diagram of the model, view, and viewmodel" height="555" src="img/B21554_04_10.png" width="825"/></figure>
<p class="packt_figref">Figure 4.10: Class diagram of the model, view, and ViewModel</p>
<p class="normal">In this class diagram, we can see both <code class="inlineCode">PwEntry</code> and <code class="inlineCode">PwGroup</code> are derived from <code class="inlineCode">Item</code>. There is a list of items in <code class="inlineCode">ItemsViewModel</code> and there is a list of fields in <code class="inlineCode">ItemDetailViewModel</code>. In the views, <code class="inlineCode">ItemsPage</code> contains a reference to <code class="inlineCode">ItemsViewModel</code>, and <code class="inlineCode">ItemDetailPage</code> contains a reference to <code class="inlineCode">ItemDetailViewModel</code>.</p>
<p class="normal">After we refine our design, we can look at the implementation. We will review the implementation <a id="_idIndexMarker358"/>of <code class="inlineCode">ItemDetailViewModel</code> and <code class="inlineCode">ItemDetailPage</code> to verify the design change:</p>
<pre class="programlisting code"><code class="hljs-code">[QueryProperty(nameof(ItemId), nameof(ItemId))]
public partial class ItemDetailViewModel : BaseViewModel
{
  readonly IDataStore&lt;Item&gt; dataStore;
  ILogger&lt;ItemDetailViewModel&gt; logger;
  public ObservableCollection&lt;Field&gt; Fields { get; set; }         //(1)
  public ItemDetailViewModel(IDataStore&lt;Item&gt; dataStore,
    ILogger&lt;ItemDetailViewModel&gt; logger)
  {
    this.dataStore = dataStore;
    this.logger = logger;
    Fields = new ObservableCollection&lt;Field&gt;();                   //(2)
  }
  [ObservableProperty]
  private string? title;
  [ObservableProperty]
  private string? id;
  [ObservableProperty]
  private string? description;
  [ObservableProperty]
  private bool isBusy;
  private string? itemId;
  public string ItemId {
    get {
      if(itemId == null)
      { throw new NullReferenceException(nameof(itemId)); }
      return itemId;
    }
    set {
      itemId = value;
      LoadItemId(value);
    }
  }
  public override void OnItemSelecteion(object sender)
  {
    logger.LogDebug("OnItemSelecteion is invoked.");
  }
  public async void LoadItemId(string itemId)
  {
    if (itemId == null)
    { throw new ArgumentNullException(nameof(itemId)); }
    var item = await dataStore.GetItemAsync(itemId);
    if (item == null)
    { throw new NullReferenceException(itemId); }
    Id = item.Id;
    Title = item.Name;
    Description = item.Description;
    if (!item.IsGroup) {
      PwEntry dataEntry = (PwEntry)item;                          //(3)
      Fields.Clear();
      List&lt;Field&gt; fields =
        dataEntry.GetFields(GetImage: FieldIcons.GetImage);       //(4)
      foreach (Field field in fields) {
        Fields.Add(field);
      }
      logger.LogDebug($"ItemDetailViewModel:
        Name={dataEntry.Name}.");
    }
  }
}
</code></pre>
<p class="normal">As shown in<a id="_idIndexMarker359"/> the code here, we can see the difference in <code class="inlineCode">ItemDetailViewModel</code> compared to <em class="italic">Listing 4.1</em> at the beginning of this chapter:</p>
<p class="normal"><strong class="keyWord">(1)</strong> A <code class="inlineCode">Fields</code> property is defined as the <code class="inlineCode">ObservableCollection&lt;Field&gt;</code> type to hold the <code class="inlineCode">Field</code> list.</p>
<p class="normal"><strong class="keyWord">(2)</strong> The <code class="inlineCode">Fields</code> variable is initialized in the constructor of <code class="inlineCode">ItemDetailViewModel</code>.</p>
<p class="normal"><strong class="keyWord">(3)</strong> We can cast <code class="inlineCode">item</code> to a <code class="inlineCode">PwEntry</code> instance.</p>
<p class="normal"><strong class="keyWord">(4)</strong> We can get the list of fields by calling an extension method, <code class="inlineCode">GetFields</code>, which is defined in the PassXYZLib library.</p>
<p class="normal">Having <a id="_idIndexMarker360"/>reviewed the changes in <code class="inlineCode">ItemDetailViewModel</code>, let’s review the changes in <code class="inlineCode">ItemDetailPage</code> in <em class="italic">Listing 4.5</em>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  x:Class="PassXYZ.Vault.Views.ItemDetailPage"
  xmlns:local="clr-namespace:PassXYZ.Vault.ViewModels"
  xmlns:model="clr-namespace:KPCLib;assembly=KPCLib"              //(1)
  x:DataType="local:ItemDetailViewModel"
  Title="{Binding Title}"&gt;
  &lt;StackLayout&gt;
    &lt;ListView
      x:Name="FieldsListView"
      ItemsSource="{Binding Fields}"                              //(2)
      VerticalOptions="FillAndExpand"
      HasUnevenRows="False"
      RowHeight="84"
      IsPullToRefreshEnabled="true"
      IsRefreshing="{Binding IsBusy, Mode=OneWay}"
      CachingStrategy="RetainElement"
      ItemSelected="OnFieldSelected"&gt;
      &lt;ListView.ItemTemplate&gt;
        &lt;DataTemplate&gt;                                            //(3)
        ...               
        &lt;/DataTemplate&gt;
      &lt;/ListView.ItemTemplate&gt;
      &lt;ListView.Footer&gt;
        &lt;StackLayout Padding="5" Orientation="Horizontal"&gt;
          &lt;Label
            Text="{Binding Description}"
            FontSize="Small"
            Style="{DynamicResource ListItemDetailTextStyle}"
            TextType ="Html"/&gt;
        &lt;/StackLayout&gt;
      &lt;/ListView.Footer&gt;
    &lt;/ListView&gt;
  &lt;/StackLayout&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="packt_figref">Listing 4.5: <code class="inlineCode">ItemDetailPage.xaml</code> (<a href="https://epa.ms/ItemDetailPage4-5">https://epa.ms/ItemDetailPage4-5</a>)</p>
<p class="normal">In <code class="inlineCode">ItemDetailPage</code>, we can see there are many changes compared to <em class="italic">Listing 3.4</em> in <em class="chapterRef">Chapter 3</em><em class="italic">,</em> <em class="italic">User Interface Design with XAML</em>. <code class="inlineCode">ListView</code> is used to display the fields in an entry:</p>
<p class="normal"><strong class="keyWord">(1)</strong> To use <code class="inlineCode">Field</code> in <code class="inlineCode">DataTemplate</code>, an <code class="inlineCode">xmlns:model</code> namespace is added. Since the <code class="inlineCode">Field</code> class is in a<a id="_idIndexMarker361"/> different assembly, we need to specify the assembly’s name as follows:</p>
<pre class="programlisting code"><code class="hljs-code">xmlns:model="clr-namespace:KPCLib;assembly=KPCLib"
</code></pre>
<p class="normal"><strong class="keyWord">(2)</strong> We bind the <code class="inlineCode">Fields</code> property to the <code class="inlineCode">ItemsSource</code> property of <code class="inlineCode">ListView</code>.</p>
<p class="normal"><strong class="keyWord">(3)</strong> <code class="inlineCode">DataTemplate</code> is used to define the appearance of each item in <code class="inlineCode">ListView</code>. It is collapsed in <em class="italic">Listing 4.5</em>.</p>
<p class="normal">Let’s expand it and review the implementation of <code class="inlineCode">DataTemplate</code> in this code block:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;DataTemplate&gt;
  &lt;ViewCell&gt;
    &lt;Grid Padding="10" x:DataType="model:Field" &gt;                  //(1)
      &lt;Grid.RowDefinitions...&gt;
      &lt;Grid.ColumnDefinitions...&gt;
      &lt;Grid Grid.RowSpan="2" Padding="10"&gt;
        &lt;Grid.ColumnDefinitions...&gt;
        &lt;Image Grid.Column="0" Source="{Binding ImgSource}"        //(2)
        HorizontalOptions="Fill"
        VerticalOptions="Fill" /&gt;                        
      &lt;/Grid&gt;
      &lt;Label Text="{Binding Key}"  Grid.Column="1".../&gt;            //(3)
      &lt;Label Text="{Binding Value}" Grid.Row="1"                   //(4)
        Grid.Column="1".../&gt;                   
    &lt;/Grid&gt;
  &lt;/ViewCell&gt;
&lt;/DataTemplate&gt;
</code></pre>
<p class="normal">In <code class="inlineCode">DataTemplate</code>, the layout of each field is defined in a <code class="inlineCode">ViewCell</code> element. In the <code class="inlineCode">ViewCell</code> element, we defined a 2x2 <code class="inlineCode">Grid</code> layout. The first column is used to display the field icon. The key and value in the field are displayed in the second column with two rows:</p>
<p class="normal"><strong class="keyWord">(1)</strong> The <code class="inlineCode">x:DataType</code> attribute in the <code class="inlineCode">Grid</code> layout is set to <code class="inlineCode">Field</code> and the following data binding in <code class="inlineCode">Grid</code> will refer to the property of <code class="inlineCode">Field</code>. The <code class="inlineCode">Field</code> class is defined in our model, which is in the KPCLib package.</p>
<p class="normal"><strong class="keyWord">(2)</strong> To display the field icon, the <code class="inlineCode">Source</code> property of the <code class="inlineCode">Image</code> control is set to the <code class="inlineCode">ImgSource</code> property of <code class="inlineCode">Field</code>.</p>
<p class="normal">The <code class="inlineCode">Key</code> property and the <code class="inlineCode">Value</code> property of <code class="inlineCode">Field</code> are assigned to the <code class="inlineCode">Text</code> property of the <code class="inlineCode">Label</code> control.</p>
<p class="normal">With this <a id="_idIndexMarker362"/>analysis, we learned how to create data binding for a collection. The data binding used in <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemsViewModel</code> is similar to this implementation. The difference is we use a collection of <code class="inlineCode">Field</code> here and a collection of <code class="inlineCode">Item</code> classes is used in <code class="inlineCode">ItemsPage</code>. Having completed the changes, we can see the improvement of the UI in <em class="italic">Figure 4.11</em>.</p>
<figure class="mediaobject"><img alt="Screens screenshot of a phone  Description automatically generated" height="613" src="img/B21554_04_11.png" width="825"/></figure>
<p class="packt_figref">Figure 4.11: Improved ItemsPage and ItemDetailPage</p>
<p class="normal">In the improved UI, we <a id="_idIndexMarker363"/>display a list of items on <code class="inlineCode">ItemsPage</code> (on the left). The items in the list can be entries (such as on Facebook, Twitter, or Amazon), or groups, which we will see in the next chapter.</p>
<p class="normal">When the user clicks on an item, such as <strong class="screenText">GitHub</strong>, details about <strong class="screenText">GitHub</strong> are displayed on <code class="inlineCode">ItemDetailPage</code> (on the right). On the item detail page, the information about this account (<strong class="screenText">GitHub</strong>) is shown.</p>
<h1 class="heading-1" id="_idParaDest-139">Using custom views</h1>
<p class="normal">We implement an <a id="_idIndexMarker364"/>instance of <code class="inlineCode">ViewCell</code> in <code class="inlineCode">DataTemplate</code> in <em class="italic">Listing 4.5</em>. This <code class="inlineCode">ViewCell</code> is used to display a key-value pair with an icon. The same implementation is employed in both <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemDetailPage</code>, with the sole distinction being the data binding. We have duplicated code here. To refactor the implementation, we can create a custom view (or custom control).</p>
<p class="normal">A custom view<a id="_idIndexMarker365"/> in .NET MAUI is a user interface component created by developers to meet custom requirements, provide reusable UI logic, or extend the functionality of existing UI components. Custom views can be built by combining existing controls, deriving from base classes like <code class="inlineCode">View</code>, <code class="inlineCode">ViewCell</code>, or <code class="inlineCode">ContentView</code>, and overriding specific methods to customize rendering or behavior.</p>
<p class="normal">To create a custom view that can be reused in both <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemDetailPage</code>, we should first create a new folder called <code class="inlineCode">Templates</code> within the <code class="inlineCode">Views</code> directory. In Visual Studio, we can right-click on the <em class="italic">Templates</em> folder to add a <a id="_idIndexMarker366"/>new item based on the <strong class="keyWord">.NET MAUI ContentView</strong> (<strong class="keyWord">XAML</strong>) template, naming it <code class="inlineCode">KeyValueView</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ViewCell ...
  xmlns:vm="clr-namespace:PassXYZ.Vault.ViewModels"
  x:Class="PassXYZ.Vault.Views.Templates.<strong class="hljs-string-slc">KeyValueView</strong>"&gt;           //(1)
  &lt;Grid Padding="10" VerticalOptions="FillAndExpand"&gt;             //(2)
    &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition Height="Auto" /&gt;
      &lt;RowDefinition Height="Auto" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
      &lt;ColumnDefinition Width="Auto" /&gt;
      &lt;ColumnDefinition Width="Auto" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Grid Grid.RowSpan="2" Padding="10"&gt;
      &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="32" /&gt;
      &lt;/Grid.ColumnDefinitions&gt;
      &lt;Image x:Name=<strong class="hljs-string-slc">"imageField"</strong> Grid.Column="0"                 //(5)
        HorizontalOptions="Fill" VerticalOptions="Fill"&gt;
        &lt;Image.Source&gt;
        ...
        &lt;/Image.Source&gt;
      &lt;/Image&gt;
    &lt;/Grid&gt;
    &lt;Label x:Name=<strong class="hljs-string-slc">"keyField"</strong> ... /&gt;                              //(3)
    &lt;Label x:Name=<strong class="hljs-string-slc">"valueField"</strong> ... /&gt;                            //(4)
    &lt;Grid.GestureRecognizers&gt;
      &lt;TapGestureRecognizer
        NumberOfTapsRequired="1"
        Command="{Binding Source=
        {RelativeSource AncestorType=
        {x:Type vm:BaseViewModel}},
        Path=ItemSelectionChangedCommand}"
        CommandParameter="{Binding .}"&gt;
      &lt;/TapGestureRecognizer&gt;
    &lt;/Grid.GestureRecognizers&gt;
  &lt;/Grid&gt;
&lt;/ViewCell&gt;
</code></pre>
<p class="packt_figref">Listing 4.6: <code class="inlineCode">KeyValueView.xaml</code> (<a href="https://epa.ms/KeyValueView4-6">https://epa.ms/KeyValueView4-6</a>)</p>
<p class="normal">We can<a id="_idIndexMarker367"/> see in <em class="italic">Listing 4.6</em> that the class name is <code class="inlineCode">KeyValueView</code> <strong class="keyWord">(1)</strong> and we have created a 2x2 grid <strong class="keyWord">(2)</strong>. In this grid, there are two rows used to display key <strong class="keyWord">(3)</strong> and value <strong class="keyWord">(4)</strong> with an icon <strong class="keyWord">(5)</strong>.</p>
<p class="normal">When we use <code class="inlineCode">KeyValueView</code>, we can establish data binding for the key, value, and icon. To support data binding, we need to define the key, value, and icon as bindable properties. Let’s review the implementation shown in <em class="italic">Listing 4.7</em>.</p>
<pre class="programlisting code"><code class="hljs-code">public partial class KeyValueView : ViewCell {
  public KeyValueView() {
    InitializeComponent();
  }
  public static readonly BindableProperty KeyProperty =
    BindableProperty.Create(nameof(Key), typeof(string),
    typeof(KeyValueView), string.Empty,
    propertyChanging: (bindable, oldValue, newValue) =&gt;
    {
      var control = bindable as KeyValueView;
      var changingFrom = oldValue as string;
      var changingTo = newValue as string;
      if(control == null) {
        throw new NullReferenceException(nameof(control)); }
      if(changingTo == null) {
        throw new NullReferenceException(nameof(changingTo));
      }
      control.Key = changingTo;
    });
  public string Key {                                            //(1)
    get { return (string)GetValue(KeyProperty); }
    set {
        keyField.Text = value;
        SetValue(KeyProperty, value);
    }
  }
  public static readonly BindableProperty ValueProperty =
    BindableProperty.Create(nameof(Value), typeof(string),
    typeof(KeyValueView), string.Empty,
    propertyChanging: (bindable, oldValue, newValue) =&gt;
    {
      var control = bindable as KeyValueView;
      var changingFrom = oldValue as string;
      var changingTo = newValue as string;
      if (control == null)
        { throw new NullReferenceException(nameof(control)); }
      if (changingTo == null) {
        throw new NullReferenceException(nameof(changingTo));
      }
      control.Value = changingTo;
    });
  public string Value {                                           //(2)
      get { return (string)GetValue(ValueProperty); }
      set {
          valueField.Text = value;
          SetValue(ValueProperty, value);
      }
  }
  public static readonly BindableProperty SourceProperty =
    BindableProperty.Create(nameof(Source),
    typeof(ImageSource), typeof(KeyValueView), default!,
    propertyChanging: (bindable, oldValue, newValue) =&gt;
    {
      var control = bindable as KeyValueView;
      var changingFrom = oldValue as ImageSource;
      var changingTo = newValue as ImageSource;
      if (control == null)
        { throw new NullReferenceException(nameof(control)); }
      if (changingTo == null) {
        throw new NullReferenceException(nameof(changingTo));
      }
      control.Source = changingTo;
    });
  public ImageSource Source {                                     //(3)
    get { return (ImageSource)GetValue(SourceProperty); }
    set {
      imageField.Source = value;
      SetValue(SourceProperty, value);
    }
  }
}
</code></pre>
<p class="packt_figref">Listing 4.7: <code class="inlineCode">KeyValueView.xaml.cs</code> (<a href="https://epa.ms/KeyValueView4-7">https://epa.ms/KeyValueView4-7</a>)</p>
<p class="normal">To implement <a id="_idIndexMarker368"/>the bindable properties key <strong class="keyWord">(1)</strong>, Value <strong class="keyWord">(2)</strong>, and Source <strong class="keyWord">(3)</strong> within our custom control class, we must define the <code class="inlineCode">BindableProperty</code> using the static <code class="inlineCode">BindableProperty.Create</code> method. This method should include the property name, property type, declaring type, and a default value as parameters:</p>
<pre class="programlisting code"><code class="hljs-code">  public static readonly BindableProperty <strong class="hljs-slc">KeyProperty</strong> =
    BindableProperty.Create(nameof(Key), typeof(string),
    typeof(KeyValueView), string.Empty,
    propertyChanging: (bindable, oldValue, newValue) =&gt;
    {
      var control = bindable as KeyValueView;
      var changingFrom = oldValue as string;
      var changingTo = newValue as string;
      if(control == null) {
        throw new NullReferenceException(nameof(control)); }
      if(changingTo == null) {
        throw new NullReferenceException(nameof(changingTo));
      }
      control.Key = changingTo;
    });
</code></pre>
<p class="normal">After that, we need to implement the corresponding property with a getter and setter. They will interact with the <code class="inlineCode">BindableProperty</code> through the <code class="inlineCode">GetValue</code> and <code class="inlineCode">SetValue</code> methods:</p>
<pre class="programlisting code"><code class="hljs-code">  public string Key {
    get { return (string)GetValue(KeyProperty); }
    set {
      keyField.Text = value;
      SetValue(KeyProperty, value);
    }
  }
</code></pre>
<p class="normal">We have now <a id="_idIndexMarker369"/>created the custom view <code class="inlineCode">KeyValueView</code>, and are able to refactor the previous <code class="inlineCode">DataTemplate</code> implementation accordingly. The revised implementation is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;DataTemplate x:DataType="model:Field"&gt;
  &lt;template:KeyValueView
    Key="{Binding Key}"
    Value="{Binding Value}"
    Source="{Binding ImgSource}"/&gt;
&lt;/DataTemplate&gt;
</code></pre>
<p class="normal">After introducing the new data model, the design has not experienced significant changes. We have enhanced the UI to make it more meaningful, but the majority of the complexity remains concealed within our model libraries – KPCLib and PassXYZLib. This is the advantage we observe by employing the MVVM pattern, which allows us to separate the model (business logic) from the UI design.</p>
<h1 class="heading-1" id="_idParaDest-140">Summary</h1>
<p class="normal">In this chapter, we learned about the MVVM pattern and applied it to our app development. One key feature of the MVVM pattern is data binding between the view and ViewModel. We delved into data binding and utilized it in the implementation of our app.</p>
<p class="normal">To delve deeper into the complexities of data binding, we examined binding to collections and the utilization of data binding in custom views. By employing data binding and custom views, we’re able to refactor XAML code, resulting in a cleaner and more concise codebase.</p>
<p class="normal">To demonstrate advanced data binding usage, we need a more intricate model layer. We enhanced the model in this chapter by introducing two packages – KPCLib and PassXYZLib. We replaced the model in the sample code with the models found in these two packages. Subsequently, we updated the UIs of <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemDetailPage</code> to reflect the changes made to the model.</p>
<p class="normal">In the next chapter, we will refine our user stories and continue improving the UI, drawing upon our knowledge of Shell and navigation.</p>
<h1 class="heading-1" id="_idParaDest-141">Further reading</h1>
<ul>
<li class="bulletList"><em class="italic">Introduction to the MVVM Toolkit</em>: <a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/">https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/</a></li>
<li class="bulletList">KeePass is a free open source password manager: <a href="https://keepass.info/">https://keepass.info/</a></li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/cross-platform-app">https://packt.link/cross-platform-app</a></p>
<p class="normal"><img alt="" height="354" src="img/QR_Code166522361691420406.png" style="width:10em;" width="354"/></p>
</div>
</div></body></html>