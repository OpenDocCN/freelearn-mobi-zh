- en: Chapter 9. Adding Audio to Our Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：为我们的游戏添加音频
- en: '*In the previous chapter, we learned about artificial intelligence. We learned
    theory about finite state machines and fuzzy logic. We applied these elements
    to our game. We also implemented the remaining gameplay elements into our game.
    In this chapter, we are going to add music and sound to our game. Audio in itself
    is an important aspect to any game as it is part of the player''s experience.
    Try to play your favorite game without music and you''ll find yourself having
    a different experience when playing the game.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们学习了人工智能。我们学习了有限状态机和模糊逻辑的理论。我们将这些元素应用到我们的游戏中。我们还实现了剩余的游戏元素。在本章中，我们将向我们的游戏添加音乐和声音。音频本身是任何游戏的重要方面，因为它构成了玩家体验的一部分。尝试在没有音乐的情况下玩你最喜欢的游戏，你会发现游戏体验完全不同。*'
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Loading sound and music files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载声音和音乐文件
- en: Generating our own sound effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成我们自己的声音效果
- en: Playing audio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频
- en: Let's add music and sound to our game, shall we?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的游戏添加音乐和声音，怎么样？
- en: Finding music and sound
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找音乐和声音
- en: When developing a game, the developer is usually not a jack of all trades and
    may have a hard time when looking for sound and music. Apple's own GarageBand
    provides an easy way to create music using predefined loops or even one's own
    instruments. Another possibility is to find talented people who can help to create
    audio files. One of the places to look out for are the TIGSource forums—a place
    for independent game developers—which has a portfolio section at [http://forums.tigsource.com/index.php?board=43.0](http://forums.tigsource.com/index.php?board=43.0)
    and a section that offers paid work at [http://forums.tigsource.com/index.php?board=40.0](http://forums.tigsource.com/index.php?board=40.0).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发游戏时，开发者通常不是全能的，在寻找声音和音乐时可能会遇到困难。苹果自家的GarageBand提供了一个简单的方法来创建音乐，可以使用预定义的循环或甚至自己的乐器。另一种可能性是找到能够帮助创建音频文件的有才能的人。可以关注的地方之一是TIGSource论坛——一个独立游戏开发者的聚集地，它有一个[http://forums.tigsource.com/index.php?board=43.0](http://forums.tigsource.com/index.php?board=43.0)的收藏夹部分，以及一个提供付费工作的[http://forums.tigsource.com/index.php?board=40.0](http://forums.tigsource.com/index.php?board=40.0)部分。
- en: Generating sound effects
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成声音效果
- en: '**Bxfr** is a procedural sound generator which is often used in game jams.
    It is available online at [http://www.bfxr.net/](http://www.bfxr.net/); the standalone
    versions for Windows and Mac OS X can be downloaded from this link as well. Its
    purpose is to generate 8-bit sound effects in just a few clicks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bxfr**是一个常用于游戏快闪节的程序声音生成器。它可以在[http://www.bfxr.net/](http://www.bfxr.net/)在线找到；Windows和Mac
    OS X的独立版本也可以从这个链接下载。它的目的是通过几步点击生成8位声音效果：'
- en: '![Generating sound effects](img/1509OS_09_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![生成声音效果](img/1509OS_09_01.jpg)'
- en: First of all, we need to select a type, which we can then modify with several
    sliders such as the frequency or the length of the sound.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要选择一个类型，然后我们可以通过几个滑块来修改它，例如声音的频率或长度。
- en: Once we are done, we can export the sound effect using the **Export Wav** button.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以使用**导出Wav**按钮导出声音效果。
- en: Learning about audio formats
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解音频格式
- en: Sparrow allows all audio files supported by iOS to be loaded. Some audio codecs
    support hardware-assisted decoding, while others don't.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Sparrow允许加载iOS支持的任何音频文件。一些音频编解码器支持硬件辅助解码，而另一些则不支持。
- en: The iOS devices contain specialized hardware that can handle the encoding and
    decoding of certain audio formats (for example, AIFC), thereby freeing up the
    CPU that would otherwise be required to handle these expensive operations. The
    drawback of the hardware-assisted approach is that only one file can be handled
    at a time. For example, you can't play background music and sound effects with
    it simultaneously.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备包含专门用于处理某些音频格式（例如，AIFC）的硬件，从而释放出原本用于处理这些昂贵操作的CPU。硬件辅助方法的缺点是每次只能处理一个文件。例如，你不能同时用它播放背景音乐和声音效果。
- en: For more information about how iOS handles audio playback, take a look at Apple's
    documentation at [https://developer.apple.com/library/ios/documentation/audiovideo/conceptual/multimediapg/UsingAudio/UsingAudio.html](https://developer.apple.com/library/ios/documentation/audiovideo/conceptual/multimediapg/UsingAudio/UsingAudio.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于iOS处理音频播放的更多信息，请查看苹果的文档：[https://developer.apple.com/library/ios/documentation/audiovideo/conceptual/multimediapg/UsingAudio/UsingAudio.html](https://developer.apple.com/library/ios/documentation/audiovideo/conceptual/multimediapg/UsingAudio/UsingAudio.html)。
- en: The best formats for audio formats in Sparrow are AIFC and CAFF.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Sparrow 中音频格式的最佳格式是 AIFC 和 CAFF。
- en: 'Let''s see what they are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们是什么：
- en: 'AIFC is a compressed **Audio Interchange Format** (**AIFF**) file. This is
    usually the best option for background music. There is one other thing to consider:
    if the audio playback is hardware-assisted (as it is in the case of AIFC), only
    one file can be played at a time.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AIFC 是一种压缩的 **音频交换格式** (**AIFF**) 文件。这通常是背景音乐的最好选择。还有一件事要考虑：如果音频播放是硬件辅助的（如 AIFC
    的情况），一次只能播放一个文件。
- en: The **Core Audio File Format** (**CAFF**) is an uncompressed audio format. This
    format is best used for short sound effects.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心音频文件格式** (**CAFF**) 是一种未压缩的音频格式。这种格式最适合用于短音效。'
- en: 'Both these formats have the lowest footprint on the CPU. If application size
    is an issue, there is an unconventional way to solve this: some devices still
    only have mono speakers, so converting audio files to mono could be a valid option
    if there are a lot of sound files.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种格式对 CPU 的占用最小。如果应用程序大小是一个问题，有一种非常规的方法可以解决这个问题：一些设备仍然只有单声道扬声器，所以如果有很多声音文件，将音频文件转换为单声道可能是一个有效的选择。
- en: 'To convert audio files, the iOS SDK provides a command-line tool called **afconvert**.
    Assuming our audio file is called `myAudioFile.wav`, we can use the following
    examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换音频文件，iOS SDK 提供了一个名为 **afconvert** 的命令行工具。假设我们的音频文件名为 `myAudioFile.wav`，我们可以使用以下示例：
- en: '**Convert to CAFF**: The command to convert to CAFF is `afconvert –f caff –d
    LE16 myAudioFile.wav`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为 CAFF**：将文件转换为 CAFF 的命令是 `afconvert –f caff –d LE16 myAudioFile.wav`'
- en: '**Convert to AIFC**: The command to convert to AIFC is `afconvert –f AIFC –d
    ima4 myAudioFile.wav`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为 AIFC**：将文件转换为 AIFC 的命令是 `afconvert –f AIFC –d ima4 myAudioFile.wav`'
- en: Music and sound effects for our game
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏中的音乐和音效
- en: The necessary audio files are once again uploaded to our GitHub repository.
    In order to use them, download them from [https://github.com/freezedev/pirategame-assets/releases/download/0.9/Audio_09.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.9/Audio_09.zip),
    extract the file, and copy the contents in our template. When copying the files
    to the project, we need to make sure that we add them to the target.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的音频文件再次上传到我们的 GitHub 仓库。为了使用它们，从 [https://github.com/freezedev/pirategame-assets/releases/download/0.9/Audio_09.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.9/Audio_09.zip)
    下载它们，解压文件，并将内容复制到我们的模板中。在将文件复制到项目中时，我们需要确保将它们添加到目标中。
- en: Adding audio playback
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音频播放
- en: Now that we know about audio formats, we can generate sounds for ourselves if
    needed, and if we have the necessary files, we can play some audio.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了音频格式，如果需要，我们可以为自己生成声音，如果我们有必要的文件，我们也可以播放一些音频。
- en: Starting the audio engine
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动音频引擎
- en: Before we can play any sounds, we need to start the audio engine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以播放任何声音之前，我们需要启动音频引擎。
- en: Time for action – getting audio files to play
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 获取音频文件播放
- en: 'Perform the following steps to start the audio engine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以启动音频引擎：
- en: Open our Xcode project if it's not already open.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有打开，请打开我们的 Xcode 项目。
- en: Switch to the `Game.m` file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Game.m` 文件。
- en: 'Inside the initializer, start the audio engine as shown; it should be one of
    the first few statements:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中，按照以下方式启动音频引擎；它应该是前几条语句之一：
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a `dealloc` method that stops the audio engine:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `dealloc` 方法来停止音频引擎：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the example.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'When we run this example in the simulator, we might see the following lines
    in the console:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在模拟器中运行此示例时，我们可能会在控制台中看到以下行：
- en: '![Time for action – getting audio files to play](img/1509OS_09_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 获取音频文件播放](img/1509OS_09_02.jpg)'
- en: '*What just happened?*'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: To play any audio file, we need to start the audio engine at the start of our
    application, which in our case, is the initializer from the `Game` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放任何音频文件，我们需要在应用程序启动时启动音频引擎，在我们的例子中，是从 `Game` 类的初始化器开始。
- en: There are different operational modes for the audio engine, which influence
    how the iPod music app will behave when we run our game.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 音频引擎有不同的操作模式，这会影响我们在运行游戏时 iPod 音乐应用的行为。
- en: 'If the audio is muted, the game audio will be muted as well. This is the default
    operational mode; other modes include the game audio continue even when the device
    is muted or the iPod music mixes with the game audio. Take a look at what the
    latter will look like in code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果音频被静音，游戏音频也会被静音。这是默认的操作模式；其他模式包括即使设备被静音，游戏音频也会继续播放，或者 iPod 音乐与游戏音频混合。看看后者在代码中会是什么样子：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For more through information, take a look at the Sparrow SPAudioEngine documentation
    at [http://doc.sparrow-framework.org/v2/Classes/SPAudioEngine.html](http://doc.sparrow-framework.org/v2/Classes/SPAudioEngine.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多信息，请查看 Sparrow SPAudioEngine 文档，链接为 [http://doc.sparrow-framework.org/v2/Classes/SPAudioEngine.html](http://doc.sparrow-framework.org/v2/Classes/SPAudioEngine.html)。
- en: When we run this example, we get some information about the audio engine in
    the console.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此示例时，我们在控制台中获取有关音频引擎的一些信息。
- en: Have a go hero
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Currently, the audio engine starts and stops when the game starts or stops,
    respectively. It's also a good idea to start and stop the engine if the background
    and foreground events (such as `applicationWillResignActive` and `applicationDidBecomeActive`)
    are triggered.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，音频引擎在游戏开始或停止时启动或停止。如果触发背景和前景事件（如 `applicationWillResignActive` 和 `applicationDidBecomeActive`），启动和停止引擎也是一个好主意。
- en: Playing music in our scenes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的场景中播放音乐
- en: Now that the audio engine is up and running, let's play the background music.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在音频引擎已经启动并运行，让我们播放背景音乐。
- en: Time for action – playing music in our scenes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在我们的场景中播放音乐
- en: 'Perform the following steps to play background music in our scenes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在我们的场景中播放背景音乐：
- en: Open the `Scene.h` file.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Scene.h` 文件。
- en: 'Add an instance variable named `backgroundMusic`, which is a pointer to `SPSoundChannel`
    using the following line of code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `backgroundMusic` 的实例变量，它是一个指向 `SPSoundChannel` 的指针，使用以下代码行：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Declare a method called `stop` as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `stop` 的方法，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Inside the `Scene.m` file, define the `stop` method with an empty body.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scene.m` 文件中，定义一个空的 `stop` 方法。
- en: 'Update the `showScene` method in the `SceneDirector.m` file to fit the following
    block of code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `SceneDirector.m` 文件中的 `showScene` 方法以适应以下代码块：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Switch to `PirateCove.m`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `PirateCove.m`。
- en: 'Inside the initializer, add the following lines at the top:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中，在顶部添加以下行：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update the `reset` method to look like the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `reset` 方法，使其看起来如下：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the scene''s `stop` method as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现场景的 `stop` 方法：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the example and you will see the following output. We can now hear the music
    in the background.![Time for action – playing music in our scenes](img/1509OS_09_03.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，您将看到以下输出。我们现在可以听到背景音乐。![行动时间 – 在我们的场景中播放音乐](img/1509OS_09_03.jpg)
- en: '*What just happened?*'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: First of all, we added an instance variable (`backgroundMusic`) to hold the
    background music. The `SPSound` variable holds the data of a sound file while
    `SPSoundChannel` plays the sound itself, similar to the relationship between `SPTexture`
    and `SPImage`. It is recommended that you keep a reference to `SPSoundChannel`.
    This is required if we want to stop the playback sound for any reason whatsoever.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个实例变量（`backgroundMusic`）来存储背景音乐。`SPSound` 变量存储声音文件的数据，而 `SPSoundChannel`
    则播放声音本身，这与 `SPTexture` 和 `SPImage` 之间的关系类似。建议您保留对 `SPSoundChannel` 的引用。如果我们想因任何原因停止播放声音，这是必需的。
- en: To allow us to have background music in multiple scenes, we need to stop the
    background music from the current scene and start the music from the next scene
    because we don't want to run into any nasty side effects. These side effects are
    that the first music file will use the hardware codec and the second one will
    use software decoding, thereby heavily impacting the performance of our game.
    Both music files will play, though.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们在多个场景中拥有背景音乐，我们需要停止当前场景的背景音乐并从下一个场景开始播放音乐，因为我们不希望遇到任何讨厌的副作用。这些副作用是第一个音乐文件将使用硬件编解码器，而第二个将使用软件解码，从而严重影响我们游戏的表现。两个音乐文件都将播放。
- en: If we want to stop the background music when we are in the scene, we can utilize
    the scene's `reset` method. Now, we wanted to do the same only when the scene
    is deactivated. We first declared the `stop` method for exactly this purpose in
    step 3 and implemented it as an empty method in the step afterwards. In the `SceneManager`
    class, we need to call the `stop` method of each scene when we are hiding the
    scene.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在场景中停止背景音乐，我们可以利用场景的 `reset` 方法。现在，我们想在场景被停用时做同样的事情。我们在第 3 步中正好为此目的声明了
    `stop` 方法，并在之后的步骤中实现了它作为一个空方法。在 `SceneManager` 类中，我们需要在隐藏场景时调用每个场景的 `stop` 方法。
- en: Inside the initializer of the `PirateCove` scene, we created a local `SPSound`
    variable that loads the music file through our asset management system. We then
    used the `createChannel` method and saved the result in the instance variable.
    We want to loop the music endlessly, so we set the `loop` property to `YES`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PirateCove`场景的初始化器中，我们创建了一个局部的`SPSound`变量，通过我们的资产管理系统加载音乐文件。然后我们使用了`createChannel`方法并将结果保存在实例变量中。我们希望音乐无限循环，所以我们将`loop`属性设置为`YES`。
- en: In step 8, we updated the `reset` method to play the background music and in
    step 9, we overwrote the `stop` method and stopped the background music.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们更新了`reset`方法以播放背景音乐，在第9步中，我们覆盖了`stop`方法并停止了背景音乐。
- en: When we run this example now, we can hear the music playing in a loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行这个示例，我们可以听到音乐在循环播放。
- en: Have a go hero
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: Now that the pirate cove scene has some background music, go ahead and give
    the battlefield some music.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在海盗湾场景已经有了一些背景音乐，接下来给战场添加一些音乐。
- en: Adding a sound effect
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加声音效果
- en: Our audio engine is up and running; we already know that it works because we
    have played some music, and now it's time to add the sound effects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音频引擎已经启动并运行；因为我们已经播放了一些音乐，所以我们知道它是有效的，现在是我们添加声音效果的时候了。
- en: Time for action – sound effects in the pirate cove
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 海盗湾中的声音效果
- en: 'To add sound effects to the pirate cove scene, perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要将声音效果添加到海盗湾场景中，执行以下步骤：
- en: Open the `PirateCove.m` file.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PirateCove.m`文件。
- en: 'Update both the `onUpdateDamage` and `onUpdateHitpoints` methods to play a
    sound effect, as shown in the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`onUpdateDamage`和`onUpdateHitpoints`方法以播放声音效果，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the example and you will see the following output. We can now hear a sound
    if we successfully upgrade our pirate ship.![Time for action – sound effects in
    the pirate cove](img/1509OS_09_04.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将看到以下输出。现在，如果我们成功升级我们的海盗船，我们就能听到声音。![行动时间 – 海盗湾中的声音效果](img/1509OS_09_04.jpg)
- en: '*What just happened?*'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Inside the pirate cove scene, we added a sound effect to both the `onUpdateDamage`
    and the `onUpdateHitpoints` methods. We got the powerup file through the asset
    management system and then played the sound directly. This method is useful for
    short sounds and at places where we don't need to keep a reference to manipulate
    the playback of the audio channel afterwards.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在海盗湾场景中，我们在`onUpdateDamage`和`onUpdateHitpoints`方法中添加了声音效果。我们通过资产管理系统获取了增益文件，然后直接播放声音。这种方法对于短声音和不需要后续操作音频通道引用的地方很有用。
- en: Now, when we run this example, we can hear a sound effect once we successfully
    upgrade our ship.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个示例时，一旦我们成功升级我们的船，我们就能听到声音效果。
- en: Have a go hero
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: 'Go ahead and add the following sound effects in the battlefield:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请添加以下战场声音效果：
- en: When a ship is hit (the `hit` method in the `Ship` class)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一艘船被击中时（`Ship`类中的`hit`方法）
- en: When a ship shoots (the `shoot` method in the `Ship` class)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一艘船射击时（`Ship`类中的`shoot`方法）
- en: When a ship gets destroyed (hit points getter in the `Ship` class)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一艘船被摧毁（`Ship`类中的`hitPoints`获取器）
- en: Pop quiz
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. AAC audio files offer hardware-assisted encoding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. AAC音频文件提供硬件辅助编码。
- en: 'True'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: Q2\. If `SPSound` only contains the sound data, which class should be used to
    play an audio file?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 如果`SPSound`只包含声音数据，应该使用哪个类来播放音频文件？
- en: '`AVAudioSession`'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AVAudioSession`'
- en: '`SPSoundChannel`'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SPSoundChannel`'
- en: '`SPAudio`'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SPAudio`'
- en: Q3\. To play any sounds at all, we need to initialize the audio engine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 要播放任何声音，我们需要初始化音频引擎。
- en: 'True'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to load and play audio files. Specifically,
    we covered data formats and the basic usage of audio in Sparrow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何加载和播放音频文件。具体来说，我们涵盖了数据格式和在Sparrow中音频的基本用法。
- en: Now that our game has some audio, let's polish our game—which is the topic of
    the next chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们游戏中已经有了一些音频，让我们完善我们的游戏——这是下一章的主题。
