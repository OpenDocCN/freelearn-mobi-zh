<html><head></head><body><div class="appendix" title="Appendix&#xA0;A.&#xA0;Supplementary Information on OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="appA"/>Appendix A. Supplementary Information on OpenGL ES 3.0</h1></div></div></div><p>In this appendix, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The fixed function and programmable pipeline architecture</li><li class="listitem" style="list-style-type: disc">Software requirements for OpenGL ES 3.0 – Android ADT</li><li class="listitem" style="list-style-type: disc">Developing Hello World Triangle application on Android Studio with OpenGL ES 3.0</li><li class="listitem" style="list-style-type: disc">Software requirements for OpenGL ES 3.0 – iOS</li><li class="listitem" style="list-style-type: disc">Opening a sample project in Android and iOS</li><li class="listitem" style="list-style-type: disc">Application of the Lambert's cosine law</li><li class="listitem" style="list-style-type: disc">Calculating cosine between two vectors</li><li class="listitem" style="list-style-type: disc">Swizzling</li></ul></div><div class="section" title="The fixed function and programmable pipeline architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec104"/>The fixed function and programmable pipeline architecture</h1></div></div></div><p>Before we dive into<a id="id954" class="indexterm"/> OpenGL ES programming, it's very important to understand how the underlying architecture is stacked. There are two types of OpenGL ES architectures: fixed and<a id="id955" class="indexterm"/> programmable pipelines. This section will provide you a simple overview of these architectures; this overview will also help us to grasp the technical jargon of computer graphics terminology.</p><div class="section" title="Fixed pipeline architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec338"/>Fixed pipeline architecture</h2></div></div></div><p>The following image <a id="id956" class="indexterm"/>shows the OpenGL ES 1.1 fixed function pipeline architecture. It also provides the sequence of events from the moment input data is sent to the rendering engine to output an image generated on the screen.</p><div class="mediaobject"><img src="graphics/5527OT_A_01.jpg" alt="Fixed pipeline architecture"/></div><p>The <span class="strong"><strong>Input</strong></span> refers to the <a id="id957" class="indexterm"/>supply of raw data and drawing information required by the rendering engine to <a id="id958" class="indexterm"/>draw an object on the screen. For example, the preceding image shows three vertices, and three color data are provided to the graphics engine as raw data. In addition, we specified the engine that will draw this raw data in the form of a triangle.</p><p>In <span class="strong"><strong>Per Vertex Operation</strong></span>, transformations <a id="id959" class="indexterm"/>on input vertex coordinates are performed. Each geometrical input vertex is transformed on the basis of the camera view or object translation.</p><p>More specifically, at this stage, the modeling transformation is performed to convert object coordinates to world space coordinates. Further, these coordinates are converted to eye space coordinates by view transformation. Light information and texture coordinates are also calculated according to these transformations for all vertices. The second chapter, OpenGL ES 3.0 essentials, covers all the technical jargon that we have used for transformation in this section under <span class="emphasis"><em>Transformation with the model, view, and projection analogies</em></span> recipe.</p><p>The <span class="strong"><strong>Primitive</strong></span> assembly takes all the<a id="id960" class="indexterm"/> transformed coordinates from the previous stage and arranges them as per the specified draw or the primitive type (point, line, triangle) information provided at the input stage. For example, we supplied three vertices and instructed the engine to render them as a triangle. There are basically three types of primitives available in OpenGL ES: point, line, and triangle (also the variants of line and triangle). These basic three primitives can be used to render any complex geometry.</p><p>In the <span class="strong"><strong>Clip</strong></span>, <span class="strong"><strong>Viewport</strong></span>, and <span class="strong"><strong>Culling</strong></span> stages, the projection<a id="id961" class="indexterm"/> transformation is applied to generate clip space coordinates. In this, vertices that are outside the camera<a id="id962" class="indexterm"/> viewing volume are discarded. The<a id="id963" class="indexterm"/> resultant vertex coordinates are treated with the perspective division where<a id="id964" class="indexterm"/> normalize device coordinates are generated. Finally, viewport transformation is applied to normalize device coordinates to form screen space pixel coordinates. Faces are culled on the basis of the direction of the face, as specified to the graphics engine.</p><p>Rasterization is the process of converting transformed screen space primitives (point, line, and triangle) to discrete elements called fragments. The output of each fragment are screen coordinates and related attributes, such as color, texture coordinates, depth, and stencil.</p><p>The fragment processing stage processes each fragment generated in the rasterization stage. This stage processes the fragment appearance information using the color or texture information.</p><p>The <span class="strong"><strong>per-fragment operations</strong></span> stage performs<a id="id965" class="indexterm"/> some important tests before rendering images on screen. It consists of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The pixel ownership test</strong></span>: This is a test where pixel screen coordinates generated by the rasterization stage are tested to see whether they belong to the OpenGL ES context. For<a id="id966" class="indexterm"/> example, it may be possible that the rendering screen is overlaid with some text messages or obscured by other windows.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The scissor test</strong></span>: This stage ensures that fragments that are present outside the rectangle formed by four<a id="id967" class="indexterm"/> values of the scissor rectangle region should not be considered in rendering.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The stencil and depth test</strong></span>: This<a id="id968" class="indexterm"/> test checks the stencil and depth value to see whether the fragment needs to be discarded or not. For example, if two primitives are obscuring each other, the primitive fragment on top is kept by the OpenGL ES state. However, fragments belonging to the behind one will be discarded, irrespective of the rendering order.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Blending</strong></span>: This is a process of generating new color information, using the previous color specified <a id="id969" class="indexterm"/>earlier in the same color buffer location.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dithering</strong></span>: This technique uses existing colors to create effects of other colors. For<a id="id970" class="indexterm"/> example, various shades of gray color can be produced using various patterns generated by white and black colors.</li></ul></div></div><div class="section" title="The programmable pipeline architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec339"/>The programmable pipeline architecture</h2></div></div></div><p>Unlike the fixed<a id="id971" class="indexterm"/> function pipeline, the programmable pipeline architecture provides the flexibility to modify some stages of the graphics pipeline. OpenGL ES 2.0 and 3.0 follows the programmable pipeline architecture. These stages are modified using special programs called shaders. The following image shows the programmable pipeline architecture for OpenGL ES 3.0. The architecture for 2.0 is also similar to the following image, except that it does not support a special stage called the Transform feedback. Transform feedback is a new stage introduced in OpenGL ES 3.0. This stage is responsible for capturing the processed vertex data buffer after the geometric shading stage. These programmable stages can be seen in the following figure with green boxes. Developers need to program the shader to render object using OpenGL ES 3.0.</p><p>The programmable pipeline architecture requires at least two shaders, namely, the vertex shader and the fragment shader to render geometry on screen. Without these shaders, rendering is not possible.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The vertex shader is the first shader in the programmable pipeline architecture. Its responsibility is to perform processing on vertex coordinates to produce coordinate transformations. In most cases, it's used to calculate clipped coordinates from the model, view, and projection information. An example of the vertex shader is as follows:<div class="informalexample"><pre class="programlisting">#version 300 es
in vec4 VertexPosition;        
void main() {                  
  gl_Position = VertexPosition;
};</pre></div></li><li class="listitem" style="list-style-type: disc">The fragment shader is the last shader that works on the pixel level; it uses the output data from the rasterization stage, which generates primitive fragments. This shader is responsible for calculating colors for each and every fragment rendering object on screen. The fragment shader is also capable of applying textures on the fragment shader. Here is an example of the fragment shader:<div class="informalexample"><pre class="programlisting">#version 300 es         
precision mediump float;
out vec4 FragColor;     
void main() {           
  FragColor = vec4(0.0, 0.30, 0.60, 0.0);
};</pre></div><div class="mediaobject"><img src="graphics/5527OT_A_02.jpg" alt="The programmable pipeline architecture"/></div></li></ul></div><p>The programmable pipeline architecture needs a special type of language to program shaders. This<a id="id972" class="indexterm"/> language is called the OpenGL ES Shading Language. In this book, we will use specifications of OpenGL ES Shading Language 3.0.</p></div></div></div>
<div class="section" title="Software requirements for OpenGL ES 3.0 &#x2013; Android ADT"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec105"/>Software requirements for OpenGL ES 3.0 – Android ADT</h1></div></div></div><p>In the previous section, we have implemented the <a id="id973" class="indexterm"/>source code for our first simple program in OpenGL ES 3.0. We will use the same program to render the output on the Android and iOS platforms. This section will cover all the basic requirements that we need to develop OpenGL ES 3.0 applications on the Android platform.</p><p>Android is a Linux-based operating system; therefore, most of its development and configuration requires UNIX-based tools. This section discusses all the prerequisites for OpenGL ES 3.0's<a id="id974" class="indexterm"/> development on Android.</p><p>Android supports the OpenGL ES application development in two ways: the Java framework API and <a id="id975" class="indexterm"/>
<span class="strong"><strong>Native Development Kit</strong></span> (<span class="strong"><strong>NDK</strong></span>). The Java framework APIs for OpenGL ES 3.0 focuses on the Java code style of development. Therefore, if you are developing an application purely in Java code, you can build the OpenGL ES 3.0 code within the Java-based application framework. In contrast, the NDK uses the C/C++ language to build the OpenGL ES 3.0 application. This is more suitable for developers who are interested to develop OpenGL ES applications in the C/C++ language. The additional benefit is that the same code can be used across different platforms, which support the C/C++ language, such as iOS, Blackberry, Windows, and so on. JNI works as an interface between the core Java application framework and the NDK C/C++ code.</p><p>This book focuses on the native development of the OpenGL ES application through NDK. We will also see the advantages of using NDK over Java framework APIs.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec340"/>Getting ready</h2></div></div></div><p>For Android development, you must ensure the following prerequisites are fulfilled on your machine (Window/Linux/Mac) before starting the development sessions. Download the following packages <a id="id976" class="indexterm"/>and proceed to the next section:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ADT bundle</strong></span>: <a class="ulink" href="https://developer.android.com/sdk/index.html">https://developer.android.com/sdk/index.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Android </strong></span><a id="id977" class="indexterm"/><span class="strong"><strong>NDK</strong></span>: <a class="ulink" href="http://developer.android.com/tools/sdk/ndk/index.html">http://developer.android.com/tools/sdk/ndk/index.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cygwin</strong></span>: <a class="ulink" href="http://www.cygwin.com/install.html">http://www.cygwin.com/install.html</a> (only for <a id="id978" class="indexterm"/>Windows users)</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec341"/>How to do it...</h2></div></div></div><p><span class="strong"><strong>ADT bundle</strong></span>: Android<a id="id979" class="indexterm"/> Developer Tools (ADT) are a combo set of the Android software development kit. This provides <a id="id980" class="indexterm"/>us all necessary APIs, debugger, and test applications to build Android apps. It contains a variety of other tools that help us in profiling apps and provides an emulation support to run apps on an emulator.</p><p>Download the ADT bundle according to your operating system. The downloaded package will be in ZIP form; unzip it. This will extract a folder with the <code class="literal">adt-bundle-xxxxx</code> name. The name is dependent on the operating system and its version type: 32/64 bit.</p><p>This extracted ADT bundle contains the following important folders:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Eclipse folder</strong></span>: This folder contains the Eclipse IDE, which is an integrated environment to develop Android applications. This special Eclipse lets users to quickly set up new Android projects, add framework packages, create UI, export <code class="literal">.apk</code>, and provide <a id="id981" class="indexterm"/>many more features.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SDK folder</strong></span>: This folder contains tools to develop and debug your app; tools to support new features on the Android platform, sample apps, documentation, system images; and SDK<a id="id982" class="indexterm"/> dependent tools that are available <a id="id983" class="indexterm"/>when new platforms are released. For more information on the SDK, refer to <a class="ulink" href="https://developer.android.com/sdk/exploring.html">https://developer.android.com/sdk/exploring.html</a>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note70"/>Note</h3><p>For the sake of better project management, keep your installation in the central location. We have created a folder called Android and extracted the ADT bundle within this folder. The folder name and location can be as per your personal choice.</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JDK</strong></span>: Depending on the ADT's requirements, you may need to update the Java Development kit. JDK <a id="id984" class="indexterm"/>contains tools to develop, debug, and monitor Java applications.<p>Go to the previously mentioned URL and download the JDK. The minimum requirement is JDK 6.0. However, higher versions must be workable. Download the installer and install it on your machine. JDK automatically contains the<a id="id985" class="indexterm"/> <span class="strong"><strong>Java Runtime Environment</strong></span> (<span class="strong"><strong>JRE</strong></span>), which contains everything required to run Java applications on your system. Therefore, there is no need to install any other software package.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>NDK</strong></span>: The Native Development Kit is a toolset that helps to develop some parts of the <a id="id986" class="indexterm"/>Android application in the C/C++ language. It provides an interface between the Java and C++ code to communicate with each other. Download the latest NDK package and uncompress it into our Android folder.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Environment variables</strong></span>: Make sure that you define the system environment variable path to locate your NDK, SDK, and platform tools. This will be helpful in running executables from command-line terminals. Additionally, we need to define <code class="literal">ANDROID_HOME</code> to locate the SDK folder in the ADT bundle. The following <a id="id987" class="indexterm"/>sample shows the definition of these environment variables in the <code class="literal">.bash_profile</code> file under the Mac operating system. Similarly, these need to be defined in other operating systems, according to their way of defining environment variables:<div class="informalexample"><pre class="programlisting">bash_profile
PATH=/usr/local/bin:/usr/local/sbin:$PATH

ANDROID_NDK=/Users/parmindersingh/Dev/Android/android-ndk-r9c
ANDROID_HOME=/Users/parmindersingh/Dev/Android/adt-bundle-mac/sdk

PATH=$ANDROID_NDK:$PATH
PATH=$ANDROID_HOME/tool:$ANDROID_HOME/platform-tools:$PATH
export ANDROID_HOME</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Android SDK Manager</strong></span>: In the ADT bundle folder, open Eclipse IDE and navigate to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Android SDK Manager</strong></span>. Install Android 4.3 and its related subcomponents, as <a id="id988" class="indexterm"/>shown in the following screenshot:<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note71"/>Note</h3><p>For OpenGL ES 3.0, we need Android 4.3 (the Level 18 API) or higher versions.</p></div></div><div class="mediaobject"><img src="graphics/5527OT_A_03.jpg" alt="How to do it..."/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cygwin</strong></span>: Cygwin is a <a id="id989" class="indexterm"/>UNIX-based command-line terminal application that allows Windows users to<a id="id990" class="indexterm"/> compile and debug Unix-based applications.<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the <code class="literal">setup.exe</code> from the URL mentioned in the previous section and execute it. This will open the installation interface for the app. Click on default selection on each window and click on the <span class="strong"><strong>Next</strong></span> button until the list of packages needed to be installed does not appear.</li><li class="listitem">Search for make and select <span class="strong"><strong>Devel/make</strong></span>. Similarly, search shell, select Shells/bash, click on next and then click on <span class="strong"><strong>Finish</strong></span>. This will install a Cygwin Terminal in your Windows program list. Make a shortcut on your desktop for quick launch. Refer to the following screenshot for assistance:</li></ol></div><div class="mediaobject"><img src="graphics/5527OT_A_04.jpg" alt="How to do it..."/></div></li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec342"/>How it works...</h2></div></div></div><p>The Android SDK provides a<a id="id991" class="indexterm"/> beautiful modular package that contains all required tools that are necessary to build an Android application. SDK and platform tools in conjunction with the SDK platform act as a backbone of the Android application development. These provide services to debug, manage, and deploy Android applications. They manage various Android platforms and related SDK APIs. This package also contains a customized eclipse for Android development; it helps to build the applications UI quickly. IDE provides special tools (such as the Android SDK Manager) that allow you to install new Android platforms and many other helper tools.</p><p>Android supports the development of some portions of its application in the C/C++ language. This kind of development is supported through the NDK tool; this tool offers an interface called Java Native Interface (JNI) that helps to set up communication between the Java framework and native code to communicate with each other. NDK needs a Unix-based command-line terminal to build C/C++ libraries. This command-line terminal is built in under UNIX-based operating systems. On Windows, it's provided by the Cygwin application. Developers build the code and export the native code functionality through libraries (<code class="literal">.so</code>/<code class="literal">.dll</code>/<code class="literal">.a</code>). The Android application uses these libraries in static or<a id="id992" class="indexterm"/> uses the shared form to integrate it into the application.</p></div></div>
<div class="section" title="Developing the Hello World Triangle application on Android Studio with OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec106"/>Developing the Hello World Triangle application on Android Studio with OpenGL ES 3.0</h1></div></div></div><p>Android Studio is another new <span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>) for the Android application development; the community is rapidly migrating to it. Unlike the other recipes in this book that are based on Android ADT, you can also use the Android studio to develop OpenGL ES 3.0 applications. It uses the Gradle build system to create scalable applications. The template-based wizard helps in designing common components and layouts quickly. This IDE has many other cool features to make the development quicker, robust, and reliable.</p><p>The previous recipe, <span class="emphasis"><em>Software requirements for OpenGL ES 3.0 – Android ADT,</em></span> uses the <span class="strong"><strong>Android development tool</strong></span> (<span class="strong"><strong>ADT</strong></span>) and Eclipse ADT plugin to build Android-based OpenGL ES applications. All the recipes implemented in the book uses the ADT-based development system to program OpenGL ES 3.0 applications. However, we also want to provide an option to our readers to develop their recipes using Android Studio. Android Studio is very easy to use and set up. Unlike the ADT, it provides a rich interface and built-in support for NDK build. In this recipe, we will reuse the Android ADT-based first recipe: <code class="literal">HelloWorldTriangle</code> and create a new recipe using Android Studio.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec343"/>Getting ready</h2></div></div></div><p>Follow these steps to get and install Android Studio:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to <a class="ulink" href="https://developer.android.com/sdk/installing/index.html?pkg=studio">https://developer.android.com/sdk/installing/index.html?pkg=studio</a> to get the latest Android studio.</li><li class="listitem">Download the latest SDK tools and platforms using the SDK Manager at <a class="ulink" href="https://developer.android.com/tools/help/sdk-manager.html">https://developer.android.com/tools/help/sdk-manager.html</a>.</li><li class="listitem">You can learn to install the SDK package at <a class="ulink" href="https://developer.android.com/sdk/installing/adding-packages.html">https://developer.android.com/sdk/installing/adding-packages.html</a>. For Android OpenGL ES 3.0, any API level greater than 18 will work completely fine.</li><li class="listitem">Read the overview of the Android Studio at <a class="ulink" href="https://developer.android.com/tools/studio/index.html">https://developer.android.com/tools/studio/index.html</a> to know more about it.</li><li class="listitem">Do not forget to set the Android SDK path; the setup will automatically ask you to provide the directory path for the Android SDK.</li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec344"/>How to do it...</h2></div></div></div><p>Follow the given steps to create the first Android Hello World application on Android Studio. I hope that after learning this, you can port the rest of the chapters recipe as per your need.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new Android application project by navigating to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>New Project</strong></span>.</li><li class="listitem">Set <span class="strong"><strong>Application name</strong></span> as <code class="literal">HelloWorldTriangle</code> and <span class="strong"><strong>Company Domain</strong></span> as <code class="literal">cookbook.gles</code>, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5527OT_A_08.jpg" alt="How to do it..."/></div></li><li class="listitem">Select the target platform SDK's; we will use <span class="strong"><strong>API 18: Android 4.3 (Jelly Bean)</strong></span>. Refer to the following screenshot for more information:<div class="mediaobject"><img src="graphics/5527OT_A_09.jpg" alt="How to do it..."/></div></li><li class="listitem">Create the <span class="strong"><strong>Blank Activity</strong></span>, change <span class="strong"><strong>Activity Name</strong></span> to <code class="literal">GLESActivity</code>, and click on <span class="strong"><strong>Finish</strong></span>. This will create the project solution, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5527OT_A_11.jpg" alt="How to do it..."/></div></li><li class="listitem">Select the current <code class="literal">java</code> folder or package name and select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Java Class</strong></span>. Add two new classes called <code class="literal">GLESView</code> and <code class="literal">GLESNativeLib</code>.</li><li class="listitem">Use the <span class="emphasis"><em>Programming OpenGL ES 3.0 Hello World Triangle</em></span> recipe from <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <span class="emphasis"><em>OpenGL ES 3.0 on Android/iOS,</em></span> and copy its <code class="literal">JNI</code> folder to the <code class="literal">&lt;ProjectLocation&gt;\HelloWorldTriangle\app\src\main</code> location. This folder contains <code class="literal">Android.mk</code>, <code class="literal">Application.mk</code>, <code class="literal">NativeTemplate.h</code>, and <code class="literal">NativeTemplate.cpp</code>. The following screenshot shows the folder structure:<div class="mediaobject"><img src="graphics/5527OT_A_13.jpg" alt="How to do it..."/></div></li><li class="listitem">Similarly, use the <span class="emphasis"><em>Programming OpenGL ES 3.0 Hello World Triangle</em></span> recipe from <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <span class="emphasis"><em>OpenGL ES 3.0 on Android/iOS,</em></span> and reuse the contents of <code class="literal">GLESActivity.java</code>, <code class="literal">GLESView.java,</code> and <code class="literal">GLESNativeLib.java</code> to the respective files of this project. Make sure that the package name should not be replaced because this project has different package name compared to the <span class="emphasis"><em>Programming OpenGL ES 3.0 Hello World Triangle</em></span> recipe from <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <span class="emphasis"><em>OpenGL ES 3.0 in Android/iOS</em></span>. For more information, you can refer to the <code class="literal">HelloWorldTriangleAndroidStudio</code> example recipe provided with the sample code of this appendix.</li><li class="listitem">Go to <code class="literal">NativeTemplate.h</code>/<code class="literal">.cpp</code> and correct the JNI interface declaration and definition. Replace the old package name with the new one. The following example shows the change we made in the <code class="literal">init()</code> function with respect to the new package name in the current recipe:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The original declaration is as follows:<div class="informalexample"><pre class="programlisting">JNIEXPORT void JNICALL Java_cookbook_gles_GLESNativeLib_init(JNIEnv * env, jobject obj, jstring FilePath);</pre></div></li><li class="listitem" style="list-style-type: disc">The new declaration with the new package name is shown in the following code:<div class="informalexample"><pre class="programlisting">JNIEXPORT void JNICALL Java_gles_cookbook_helloworldtriangle_GLESNativeLib_init(JNIEnv * env, jobject obj, jstring FilePath);</pre></div></li></ul></div></li><li class="listitem">Navigate to <code class="literal">Application.mk</code> and declare the build variant and version of the SDK to be used for compilation. The <code class="literal">APP_ABI</code> tells the NDK compiler to build shared libraries for every possible target. The <code class="literal">APP_PLATFORM</code> informs the compiler to use a specified platform for compilation. For example, as we are using API level 18; therefore, for OpenGL ES, the EGL and GLESv3 libraries will be referenced from the platform API level 18:<div class="informalexample"><pre class="programlisting">//Application.mk
APP_ABI := all
APP_PLATFORM := android-18</pre></div></li><li class="listitem">Go to <code class="literal">build.gradle</code> present in the <code class="literal">&lt;ProjectLocation&gt;\HelloWorldTriangle \app\build.gradle4</code> and make the following two changes:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Module name</strong></span>: This informs the native code module name to Gradle system; this must be the same as the module name specified in the <code class="literal">Android.mk</code>:<div class="informalexample"><pre class="programlisting">// Add the same module name present 
// in the Android.mk file
ndk{
    moduleName "glNative"
}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The NDK external build</strong></span>: This compiles the makefile manually using the <code class="literal">ndk-build</code> command as we performed this for all other Android recipes. For this, we need to inform the Gradle build system not to prebuild the NDK. The <code class="literal">jni.srcDirs</code> tells the build system not to use the <code class="literal">ndk-build</code> command from the Android Studio. The <code class="literal">jniLibs.srcDir</code> gives the location of the build libraries for different targets using the external NDK compilation:<div class="informalexample"><pre class="programlisting">// Indicate the Android Studio not to use 
// NDK from the IDE We will compile the 
// project manually from Android.mk file.
sourceSets.main
        {
            jni.srcDirs = []
            jniLibs.srcDir 'src/main/libs'
        }</pre></div></li></ul></div><p>Refer to the following screenshot for the two changes we made in the <code class="literal">build.gradle</code>:</p><div class="mediaobject"><img src="graphics/5527OT_A_14.jpg" alt="How to do it..."/></div></li><li class="listitem">Open the command-line terminal. Navigate to the current <code class="literal">JNI</code> folder path and execute <code class="literal">ndk-build</code>. This command compiles source files and generates the shared library in the <code class="literal">&lt;Project&gt;\app\src\main\libs \&lt;targetplatform&gt;</code> folder path with the help of <code class="literal">Android.mk</code>.</li><li class="listitem">After building the library, use Android Studio and click on the <span class="strong"><strong>Project Execute</strong></span> button to view the output on the device or emulator. The following is the output of the Hello World Triangle:<div class="mediaobject"><img src="graphics/5527OT_A_15.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec345"/>How it works...</h2></div></div></div><p>The working of this recipe is the same as we implemented in <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <span class="emphasis"><em>OpenGL ES 3.0 on Android/iOS</em></span> except the fact that we will now use Android Studio to build the project. Refer to the <span class="emphasis"><em>Developing the Hello World Triangle application on Android Studio with OpenGL ES 3.0</em></span> recipe and look for the <span class="emphasis"><em>How it works…</em></span> section. This section will provide the necessary details of the working of OpenGL ES along with Android Java and native interfaces for the OpenGL ES 3.0 application development.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec346"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Using JNI on Android to communicate with C/C++</em></span> and <span class="emphasis"><em>Developing an Android OpenGL ES 3.0 application</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <span class="emphasis"><em>OpenGL ES 3.0 on Android/iOS.</em></span></li></ul></div></div></div>
<div class="section" title="Software requirements for OpenGL ES 3.0 &#x2013; iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec107"/>Software requirements for OpenGL ES 3.0 – iOS</h1></div></div></div><p>The specifications of OpenGL ES<a id="id993" class="indexterm"/> 3.0 are fully supported by iOS 7 and later versions. iPhone 5s, along with <a id="id994" class="indexterm"/>Apple's A7 GPU supports OpenGL ES 3.0 and the earlier version of OpenGL ES 2.0 and 1.1. Apple A7 GPU, provides the accessibility of all new features of OpenGL ES 3.0. It also has a larger pool of rendering resources. The shaders capability in 3.0 to access texture resource is twice as compared to OpenGL ES 2.0.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec347"/>Getting ready</h2></div></div></div><p>MAC provides the Xcode IDE for development of iOS applications, which targets iPhone, iPad, and iPod. The minimum requirements to support OpenGL ES 3.0 is version 5.0; all versions of Xcode beyond 5.0 supports iOS 7 build targets. This book will use the Xcode 5.2 version for its sample recipes.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec348"/>How to do it...</h2></div></div></div><p>OpenGL ES 3.0 is supported by the iOS 7 SDK on Xcode 5.0 and higher versions. The Xcode 5.0 version contains the iOS 7 SDK. If you are a new user, you can install it using your App store application. If you are using an older version of Xcode, you must update it to at least 5.0. The iOS 7 SDK and higher versions support OpenGL ES 3.0 through iOS 7 target devices.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec349"/>How it works...</h2></div></div></div><p>OpenGL ES 3.0 on the iOS7 with powerful GPU can perform sophisticated graphics rendering. The GPU is capable of high complex calculations in shaders for every pixel on the screen. OpenGL ES 3.0 is a C-based API seamlessly integrated into Object or C/C++. The OpenGL ES specification does not define the Windowing layer because the windowing mechanisms for all operating systems are very different from each other. Therefore, the underlying operating system is responsible for generating the rendering context to provide the windowing layer. In<a id="id995" class="indexterm"/> addition to this, the operating system must also provide a presentation layer where OpenGL ES can be rendered. iOS provides GLKit, which gives the presentation layer by providing the draw surface. GLKit was introduced in iOS 5 for the development of OpenGL ES. This is a 3D graphics development kit for OpenGL ES 2.0/3.0 using objective C/C++. This kit makes the programming job easier for the programmable pipeline architecture. For<a id="id996" class="indexterm"/> more information, refer to the Apple developer site at <a class="ulink" href="https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html">https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html</a>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec350"/>There's more...</h2></div></div></div><p>GLKit is<a id="id997" class="indexterm"/> developed using the C/C++ objective language. This language is only supported in Mac and iOS-based applications. Therefore, if we want our code to be portable across platforms, we need to program it in C/C++. The Objective C language supports the C/C++ language seamlessly within its framework.</p><p>The game engines, which work beautifully across platforms, actually use their own platform-independent frameworks for OpenGL ES programming. These frameworks are similar to GLKit, or even more powerful. In our approach, we will develop our own engine from scratch in C/C++ in order to build an acceptable cross-platform 3D graphics framework for Android and iOS.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec351"/>See also</h2></div></div></div><p>Apple provides special references to develop OpenGL ES applications on iOS. These references cover various aspects of <a id="id998" class="indexterm"/>OpenGL ES with respect to iOS. For more information, visit <a class="ulink" href="https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html">https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html</a>.</p></div></div>
<div class="section" title="Opening a sample project on Android ADT and iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec108"/>Opening a sample project on Android ADT and iOS</h1></div></div></div><p><span class="strong"><strong>Opening the sample </strong></span><a id="id999" class="indexterm"/><span class="strong"><strong>source for the Android platform</strong></span>:</p><p>In the Eclipse ID, navigate to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Project</strong></span> | <span class="strong"><strong>Android Project from Existing Code</strong></span>. Click on <span class="strong"><strong>Next</strong></span> and specify the<a id="id1000" class="indexterm"/> path of the folder that contains <code class="literal">Android.xml</code>. Open the command-line terminal, change the directory path to the <code class="literal">JNI</code> folder, and execute the <code class="literal">ndk-build</code> command in the terminal. Launch application from Eclipse using <span class="strong"><strong>Run</strong></span> or (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F11</em></span>) as the shortcut key.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>The path of the project should be the directory name that contains <code class="literal">Android.xml</code>.</p></div></div><p><span class="strong"><strong>Opening the sample source for the iOS platform</strong></span>:</p><p>Open the recipe folder<a id="id1001" class="indexterm"/> and locate <span class="strong"><strong>&lt;Project Name&gt;.xcodeproj</strong></span>, double-click on to open the project in the Xcode editor. Launch the application using <span class="strong"><strong>Product</strong></span> | <span class="strong"><strong>Run</strong></span> or (<span class="emphasis"><em>Command</em></span> + <span class="emphasis"><em>R</em></span>).</p></div>
<div class="section" title="Application of the Lambert's cosine law"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec109"/>Application of the Lambert's cosine law</h1></div></div></div><p>Let's understand how the cosine angle is calculated mathematically in order to implement Lambert's cosine law in our diffuse light shading recipe. The cosine angle between two vectors can be<a id="id1002" class="indexterm"/> calculated using the dot product between them:</p><p><span class="strong"><strong>Dot product</strong></span>:</p><p>Dot product between the<a id="id1003" class="indexterm"/> two vectors P (ai, bj, cz) and O (di, ej, fk) can be defined as the product of the magnitudes of the two vector and the cosine angle between them.</p><p><span class="emphasis"><em>P.Q = |P|*|Q|*cos(θ)…………Equation 1</em></span></p><p>Where |P| and |Q| are magnitude of P and Q, which can be calculated as:</p><p>|<span class="emphasis"><em>P| = √(a*a) +(b*b) +(c*c)     and       |Q| = √(d*d) +(e*e) +(f*f)</em></span></p><p>Alternatively, it is the product of respective components along x, y and z components:</p><p><span class="emphasis"><em>P.Q = (ai, bj, cz) * (di, ej, fk) =&gt; (ai*di)+ (bi*ei) +(ci*fi)</em></span></p><p><span class="emphasis"><em>P.Q = (a*d)*(i*i) + (b*e)*(j*j) +(c*f)*(k*k)  = ad + be + ef</em></span></p><p><span class="emphasis"><em>P.Q =  ad + be + ef…………Equation 2</em></span></p><p>Equate Equation 1 and Equation 2:</p><p><span class="emphasis"><em>ad + be + ef = |P|*|Q|*cos(θ)</em></span></p><p>If P and Q are units vectors, then Equation 1 can be deduced as:</p><p><span class="emphasis"><em>P.Q = cos(θ)…………Equation 3</em></span></p><p>We can also find the cosine angle by dividing |P|*|Q| both sides:</p><p><span class="emphasis"><em>cos(θ)  = ( P.Q )/( |P|*|Q| )…………Equation 4</em></span></p></div>
<div class="section" title="Calculating cosine between two vectors"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec110"/>Calculating cosine between two vectors</h1></div></div></div><p>This is an illustration of how to <a id="id1004" class="indexterm"/>calculate the cosine angle between two vectors formed by the <span class="strong"><strong>0</strong></span>, <span class="strong"><strong>20</strong></span>, and <span class="strong"><strong>0</strong></span> points on a flat <span class="emphasis"><em>x-z</em></span> plane surface and the light source situated at <span class="strong"><strong>20</strong></span>, <span class="strong"><strong>20</strong></span>, and <span class="strong"><strong>40</strong></span>, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/5527OT_A_05.jpg" alt="Calculating cosine between two vectors"/></div><p>Calculate ON and OL vectors, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">   OL = L – O = (20, 20, 40) – (0, 0, 0) =&gt; (20-0), (20-0), (40-0) =&gt; (20, 20, 40)
ON = N – O = (0, 20, 0) – (0, 0, 0) =&gt; (0, 20, 0) </pre></div><p>The dot product between OL and ON is as follows:</p><div class="informalexample"><pre class="programlisting">OL . ON = |OL| * |ON| * cos(θ)</pre></div><p>Using <span class="emphasis"><em>Equation 1</em></span>:</p><div class="informalexample"><pre class="programlisting">OL .ON = (20*0) + (20*20) + (40*0) = 400</pre></div><p>Using <span class="emphasis"><em>Equation 2</em></span>:</p><div class="informalexample"><pre class="programlisting">|OL|*|ON| = [√ (20*20) + (20*20) + (40*40)] * [ √ (0*0) +(20*20)+(0*0)] = 979.79</pre></div><p>Equating both equations, the result is shown in the following code:</p><div class="informalexample"><pre class="programlisting">400 = 979.79 * cos(θ);</pre></div><p>Here, <code class="literal">cos(</code>θ<code class="literal">) = 0.40</code> implies<a id="id1005" class="indexterm"/> that the <code class="literal">θ</code> is <code class="literal">65.90</code> degrees.</p></div>
<div class="section" title="Swizzling"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec111"/>Swizzling</h1></div></div></div><p>Swizzling is a <a id="id1006" class="indexterm"/>new GL shading language feature that allows you to rearrange components of a vector. For example:</p><div class="informalexample"><pre class="programlisting">vec4 A (1.0, 2.0, 3.0 , 4.0);</pre></div><p>Here, <code class="literal">vec4</code> is represented by the x, y, z, and w component. The result is as follows:</p><div class="informalexample"><pre class="programlisting">vec4 B = A.xxzz;</pre></div><p>Now, B is equivalent to {1.0, 1.0, 2.0, 2.0}</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec352"/>Getting ready</h2></div></div></div><p>The component access of the vec2/3/4s data type in the shading language can be considered either as vector, color, or texture coordinates or an array:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Form type</p>
</th><th style="text-align: left" valign="bottom">
<p>Components</p>
</th><th style="text-align: left" valign="bottom">
<p>Example: vec4(1.1, 2.2, 3.3, 4.4 );</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Vector</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">{x, y, z, w}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">float a = v.x;</code></p>
<p><code class="literal">float b= v.y;</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Color</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">{r, g, b, a}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">float a = v.r;</code></p>
<p><code class="literal">float b= v.g;</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Texture coordinates</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">{s, t, p, q}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">float a = v.s;</code></p>
<p><code class="literal">float b= v.t;</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Array</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[0, 1, 2, 3]</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">float a = v[0];</code></p>
<p><code class="literal">float b= v[1];</code></p>
</td></tr></tbody></table></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec353"/>How to do it...</h2></div></div></div><p>Swizzling is a mechanism of accessing a component directly using component names. For example:</p><div class="mediaobject"><img src="graphics/5527OT_A_06.jpg" alt="How to do it..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec354"/>There's more...</h2></div></div></div><p>In preceding <a id="id1007" class="indexterm"/>cases, swizzling occurs on the right-hand side of assignments. However, swizzling may occur on the left-hand side of assignments as well:</p><div class="mediaobject"><img src="graphics/5527OT_A_07.jpg" alt="There's more..."/></div></div></div></body></html>