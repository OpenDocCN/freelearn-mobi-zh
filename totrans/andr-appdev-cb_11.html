<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Multimedia</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Playing sound effects with SoundPool</li><li class="listitem" style="list-style-type: disc">Playing audio with MediaPlayer</li><li class="listitem" style="list-style-type: disc">Responding to hardware media controls in your app</li><li class="listitem" style="list-style-type: disc">Taking a photo with the default camera app</li><li class="listitem" style="list-style-type: disc">Taking a photo using the (old) Camera API</li><li class="listitem" style="list-style-type: disc">Taking a photo using the Camera2 (the new) API</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec84"/>Introduction</h1></div></div></div><p>Now that we've explored graphics and animations in the previous chapters, it's time to look at the sound options available in Android. The two most popular options to play sound include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>SoundPool</strong>: This is for <a id="id677" class="indexterm"/>short sound clips</li><li class="listitem" style="list-style-type: disc"><strong>MediaPlayer</strong>: This is<a id="id678" class="indexterm"/> designed for larger sound files (like music) and video files</li></ul></div><p>The first two recipes will look at using these libraries. We'll also look at how to use hardware related to sound, such as the volume controls and media playback controls (play, pause, and so on often found on headphones).</p><p>The rest of the chapter will focus on using the camera, both indirectly through Intents (to pass the camera request to the default camera application) and directly using the camera APIs. We'll examine the new Camera2 APIs released with Android 5.0 Lollipop (API 21), but we'll also look at the original Camera API since roughly 75 percent of the market doesn't have Lollipop yet. (To help you take advantage of the new features offered in the Camera2 API, we'll show a newer method for using the old Camera APIs to make it easier to use both Camera APIs in your own application.)</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec85"/>Playing sound effects with SoundPool</h1></div></div></div><p>When you need<a id="id679" class="indexterm"/> sound effects in your application, SoundPool <a id="id680" class="indexterm"/>is usually a good starting point.</p><p>SoundPool is interesting in that it allows us to create special effects with our sounds by changing the play rate and by allowing multiple sounds to play simultaneously.</p><p>Popular audio file types supported include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">3GPP (<code class="literal">.3gp</code>)</li><li class="listitem" style="list-style-type: disc">3GPP (<code class="literal">.3gp</code>)</li><li class="listitem" style="list-style-type: disc">FLAC (<code class="literal">.flac</code>)</li><li class="listitem" style="list-style-type: disc">MP3 (<code class="literal">.mp3</code>)</li><li class="listitem" style="list-style-type: disc">MIDI Type 0 and 1 (<code class="literal">.mid</code>, <code class="literal">.xmf</code>, and <code class="literal">.mxmf</code>)</li><li class="listitem" style="list-style-type: disc">Ogg (<code class="literal">.ogg</code>)</li><li class="listitem" style="list-style-type: disc">WAVE (<code class="literal">.wav</code>)</li></ul></div><p>See the <em>Supported Media Formats</em> link for a complete list, including network protocols.</p><p>As is common in Android, new releases to the OS bring changes to the APIs. The <code class="literal">SoundPool</code> is no exception and the original <code class="literal">SoundPool</code> constructor was deprecated in Lollipop (API 21). Rather than setting our minimum API to 21 or relying on deprecated code (that may stop working at some point), we'll implement both the old and the new approach and check the OS version at runtime to use the appropriate method.</p><p>This recipe will demonstrate how to play sound effects using the Android <code class="literal">SoundPool</code> library. To demonstrate playing sounds simultaneously, we'll create two buttons, and each will play a sound when pressed.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec304"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">SoundPool</code>. Use the default <strong>Phone &amp; Tablet</strong> options, and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p><p>To demonstrate playing sounds simultaneously, we need at least two audio files in the project. We went to <a id="id681" class="indexterm"/>SoundBible.com(<a class="ulink" href="http://soundbible.com/royalty-free-sounds-5.html">http://soundbible.com/royalty-free-sounds-5.html</a>
) and found two royalty-free public domain sounds to include in the download project files:</p><p>The first sound is a longer playing sound:</p><p>
<a class="ulink" href="http://soundbible.com/2032-Water.html">http://soundbible.com/2032-Water.html</a>
</p><p>The second sound is shorter:</p><p>
<a class="ulink" href="http://soundbible.com/1615-Metal-Drop.html">http://soundbible.com/1615-Metal-Drop.html</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec305"/>How to do it...</h2></div></div></div><p>As explained <a id="id682" class="indexterm"/>previously, we'll need two audio files to include <a id="id683" class="indexterm"/>in the project. Once you have your sound files ready, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new raw folder (<strong>File</strong> | <strong>New</strong> | <strong>Android resource directory</strong>) and chose <code class="literal">raw</code> in the <strong>Resource type</strong> dropdown.</li><li class="listitem">Copy your sound files to <code class="literal">res/raw</code> as <code class="literal">sound_1</code> and <code class="literal">sound_2</code>. (Keep their original extensions.)</li><li class="listitem">Open <code class="literal">activity_main.xml</code> and replace the existing <code class="literal">TextView</code> with the following Buttons:<div><pre class="programlisting">&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Play Sound 1"
    android:id="@+id/button1"
    android:layout_centerInParent="true"
    android:onClick="playSound1"/&gt;
&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Play Sound 2"
    android:id="@+id/button2"
    android:layout_below="@+id/button1"
    android:layout_centerHorizontal="true"
    android:onClick="playSound2"/&gt;</pre></div></li><li class="listitem">Now open <code class="literal">ActivityMain.java</code> and add the following global variables:<div><pre class="programlisting">HashMap&lt;Integer, Integer&gt; mHashMap= null;
SoundPool mSoundPool;</pre></div></li><li class="listitem">Modify the existing <code class="literal">onCreate()</code> method, as follows:<div><pre class="programlisting">final Button button1=(Button)findViewById(R.id.button1);
button1.setEnabled(false);
final Button button2=(Button)findViewById(R.id.button2);
button2.setEnabled(false);

if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
    createSoundPoolNew();
}else{
    createSoundPooolOld();
}
mSoundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {
    @Override
    public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
        button1.setEnabled(true);
        button2.setEnabled(true);
    }
});
mHashMap = new HashMap&lt;&gt;();
mHashMap.put(1, mSoundPool.load(this, R.raw.sound_1, 1));
mHashMap.put(2, mSoundPool.load(this, R.raw.sound_2, 1));</pre></div></li><li class="listitem">Add the<a id="id684" class="indexterm"/> <code class="literal">createSoundPoolNew()</code> method:<div><pre class="programlisting">@TargetApi(Build.VERSION_CODES.LOLLIPOP)
private void createSoundPoolNew() {
    AudioAttributes audioAttributes = new AudioAttributes.Builder()
    .setUsage(AudioAttributes.USAGE_MEDIA)
    .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
    .build();
    mSoundPool = new SoundPool.Builder()
            .setAudioAttributes(audioAttributes)
            .setMaxStreams(2)
            .build();
}</pre></div></li><li class="listitem">Add the<a id="id685" class="indexterm"/> <code class="literal">createSoundPooolOld()</code> method:<div><pre class="programlisting">@SuppressWarnings("deprecation")
private void createSoundPooolOld(){
    mSoundPool = new SoundPool(2, AudioManager.STREAM_MUSIC, 0);
}</pre></div></li><li class="listitem">Add the button <code class="literal">onClick()</code> methods:<div><pre class="programlisting">public void playSound1(View view){
    mSoundPool.play(mHashMap.get(1), 0.1f, 0.1f, 1, 0, 1.0f);
}

public void playSound2(View view){
    mSoundPool.play(mHashMap.get(2), 0.9f, 0.9f, 1, 1, 1.0f);
}</pre></div></li><li class="listitem">Override the <code class="literal">onStop()</code> callback as follows:<div><pre class="programlisting">protected void onStop() {
    super.onStop();
    mSoundPool.release();
}</pre></div></li><li class="listitem">Run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec306"/>How it works...</h2></div></div></div><p>The first detail to <a id="id686" class="indexterm"/>notice is how we construct the <a id="id687" class="indexterm"/>object itself. As we mentioned in the introduction, the SoundPool constructor was changed in Lollipop (API 21). The old constructor was deprecated in favor of using <code class="literal">SoundPool.Builder()</code>. With a constantly changing environment like Android, changes in the API are very common, so it's a good idea to learn how to work with the changes. As you can see, it's not difficult in this case. We just check the current OS version and call the appropriate method. It is worth noting the method annotations:</p><div><pre class="programlisting">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</pre></div><p>And:</p><div><pre class="programlisting">@SuppressWarnings("deprecation")</pre></div><p>After creating SoundPool, we set an <code class="literal">setOnLoadCompleteListener()</code> listener. Enabling the buttons is mostly for demonstration purposes to illustrate that SoundPool needs to load the sound resources before they are available.</p><p>The final point to make on using SoundPool is the call to <code class="literal">play()</code>. We need to pass in the <code class="literal">soundID</code>, which was returned when we loaded the sound using <code class="literal">load()</code>. The <code class="literal">Play()</code> gives us a few options, including sound volume (left and right), loop count, and playback rate. To demonstrate the flexibility, we play the first sound (which is longer) at a lower volume to create more of a background effect with the running water. The second sound plays at a higher volume and we play it twice.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec307"/>There's more...</h2></div></div></div><p>If you only need a basic sound effect, such as a click, you can use the AudioManager <code class="literal">playSoundEffect()</code> method. Here's an example:</p><div><pre class="programlisting">AudioManager audioManager =(AudioManager) 
this.getSystemService(Context.AUDIO_SERVICE);
audioManager.playSoundEffect(SoundEffectConstants.CLICK);</pre></div><p>You can only specify a sound from the <code class="literal">SoundEffectConstants</code>; you cannot use your own sound files.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec308"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Developer</strong><a id="id688" class="indexterm"/><strong> Docs: SoundPool</strong><p>
<a class="ulink" href="https://developer.android.com/reference/android/media/SoundPool.html">https://developer.android.com/reference/android/media/SoundPool.html</a>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Developer</strong><a id="id689" class="indexterm"/><strong> Docs: </strong><p>
<a class="ulink" href="https://developer.android.com/reference/android/media/AudioManager.html">https://developer.android.com/reference/android/media/AudioManager.html</a>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec86"/>Playing audio with MediaPlayer</h1></div></div></div><p>MediaPlayer <a id="id690" class="indexterm"/>is probably one of the most important classes for adding multimedia capability to your applications. It supports the following media sources:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Project resources</li><li class="listitem" style="list-style-type: disc">Local files</li><li class="listitem" style="list-style-type: disc">External resources (such as URLs, including streaming)</li></ul></div><p>MediaPlayer supports the following popular<a id="id691" class="indexterm"/> audio files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">3GPP (<code class="literal">.3gp</code>)</li><li class="listitem" style="list-style-type: disc">3GPP (<code class="literal">.3gp</code>)</li><li class="listitem" style="list-style-type: disc">FLAC (<code class="literal">.flac</code>)</li><li class="listitem" style="list-style-type: disc">MP3 (<code class="literal">.mp3</code>)</li><li class="listitem" style="list-style-type: disc">MIDI Type 0 and 1 (<code class="literal">.mid</code>, <code class="literal">.xmf</code>, and <code class="literal">.mxmf</code>)</li><li class="listitem" style="list-style-type: disc">Ogg (<code class="literal">.ogg</code>)</li><li class="listitem" style="list-style-type: disc">WAVE (<code class="literal">.wav</code>)</li></ul></div><p>And these popular<a id="id692" class="indexterm"/> file types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">3GPP (<code class="literal">.3gp</code>)</li><li class="listitem" style="list-style-type: disc">Matroska (<code class="literal">.mkv</code>)</li><li class="listitem" style="list-style-type: disc">WebM (<code class="literal">.webm</code>)</li><li class="listitem" style="list-style-type: disc">MPEG-4 (<code class="literal">.mp4</code>, <code class="literal">.m4a</code>)</li></ul></div><p>See the <em>Supported Media Formats</em> link for a complete list, including network protocols.</p><p>This recipe will <a id="id693" class="indexterm"/>demonstrate<a id="id694" class="indexterm"/> how to set up MediaPlayer in your app to play a sound included with your project. (For a complete review of the full capability offered by MediaPlayer, see the Developer Docs link at the end of this recipe.)</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec309"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">MediaPlayer</code>. Use the default <strong>Phone &amp; Tablet</strong> options and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p><p>We will also need a sound for this recipe and will use the same longer playing "water" sound used in the previous recipe.</p><p>The first <a id="id695" class="indexterm"/>sound is a longer playing sound:<a class="ulink" href="http://soundbible.com/2032-Water.html">http://soundbible.com/2032-Water.html</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec310"/>How to do it...</h2></div></div></div><p>As explained <a id="id696" class="indexterm"/>previously, we'll need a sound file to include in the <a id="id697" class="indexterm"/>project. Once you have your sound file ready, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new raw folder (<strong>File</strong> | <strong>New</strong> | <strong>Android resource directory</strong>) and chose <code class="literal">raw</code> in the <strong>resource type</strong> dropdown</li><li class="listitem">Copy your sound file to <code class="literal">res/raw</code> as <code class="literal">sound_1</code>. (Keep the original extension.)</li><li class="listitem">Open <code class="literal">activity_main.xml</code> and replace the existing <code class="literal">TextView</code> with the following buttons:<div><pre class="programlisting">&lt;Button
    android:layout_width="100dp"
    android:layout_height="wrap_content"
    android:text="Play"
    android:id="@+id/buttonPlay"
    android:layout_above="@+id/buttonPause"
    android:layout_centerHorizontal="true"
    android:onClick="buttonPlay" /&gt;
&lt;Button
    android:layout_width="100dp"
    android:layout_height="wrap_content"
    android:text="Pause"
    android:id="@+id/buttonPause"
    android:layout_centerInParent="true"
    android:onClick="buttonPause"/&gt;
&lt;Button
    android:layout_width="100dp"
    android:layout_height="wrap_content"
    android:text="Stop"
    android:id="@+id/buttonStop"
    android:layout_below="@+id/buttonPause"
    android:layout_centerHorizontal="true"
    android:onClick="buttonStop"/&gt;</pre></div></li><li class="listitem">Now open <code class="literal">ActivityMain.java</code> and add the following global variable:<div><pre class="programlisting">MediaPlayer mMediaPlayer;</pre></div></li><li class="listitem">Add the <code class="literal">buttonPlay()</code> method:<div><pre class="programlisting">public void buttonPlay(View view){
    if (mMediaPlayer==null) {
        mMediaPlayer = MediaPlayer.create(this, R.raw.sound_1);
        mMediaPlayer.setLooping(true);
        mMediaPlayer.start();
    } else  {
        mMediaPlayer.start();
    }
}</pre></div></li><li class="listitem">Add the <code class="literal">buttonPause()</code> method:<div><pre class="programlisting">public void buttonPause(View view){
    if (mMediaPlayer!=null &amp;&amp; mMediaPlayer.isPlaying()) {
        mMediaPlayer.pause();
    }
}</pre></div></li><li class="listitem">Add the <code class="literal">buttonStop()</code> method:<div><pre class="programlisting">public void buttonStop(View view){
    if (mMediaPlayer!=null) {
        mMediaPlayer.stop();
        mMediaPlayer.release();
        mMediaPlayer = null;
    }
}</pre></div></li><li class="listitem">Finally, override<a id="id698" class="indexterm"/> the <code class="literal">onStop()</code> callback with the<a id="id699" class="indexterm"/> following code:<div><pre class="programlisting">protected void onStop() {
    super.onStop();
    if (mMediaPlayer!=null) {
        mMediaPlayer.release();
        mMediaPlayer = null;
    }
}</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec311"/>How it works...</h2></div></div></div><p>The code here is pretty straightforward. We create MediaPlayer with our sound and start playing the sound. The buttons will replay, pause, and stop accordingly.</p><p>Even this basic example illustrates one very important concept regarding MediaPlayer, and that is the <em>state</em>. If you're making serious use of MediaPlayer, review the link provided below for detailed information.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec312"/>There's more...</h2></div></div></div><p>To make our <a id="id700" class="indexterm"/>demonstration easier to follow, we use the UI <a id="id701" class="indexterm"/>thread for all our operations. For this example, using a short audio file included with the project, we aren't likely going to experience any UI delays. In general, it's a good idea to use a background thread when preparing MediaPlayer. To make this common task easier, MediaPlayer already includes an asynchronous prepare method called <code class="literal">prepareAsync()</code>. The following code will create an <code class="literal">OnPreparedListener()</code> listener and use the <code class="literal">prepareAsync()</code> method:</p><div><pre class="programlisting">mMediaPlayer = new MediaPlayer();
mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
    @Override
    public void onPrepared(MediaPlayer mp) {
        mMediaPlayer.start();
    }
});
try {
    mMediaPlayer.setDataSource(*//*URI, URL or path here*//*));
} catch (IOException e) {
    e.printStackTrace();
}
mMediaPlayer.prepareAsync();</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec38"/>Playing music in the background</h3></div></div></div><p>Our example is <a id="id702" class="indexterm"/>meant to play audio when the application is in the<a id="id703" class="indexterm"/> foreground, and will release the MediaPlayer resources in the <code class="literal">onStop()</code> callback. What if you are creating a music player and want to play music in the background, even when the user is using another application? In that scenario, you'll want to use MediaPlayer in a service, instead of an Activity. You'll use the MediaPlayer library the same way; you'll just need to pass information (such as sound selection) from the UI to your service.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Note that since a service runs in the same UI thread as the activities, you still do not want to perform potentially blocking operations in a service. MediaPlayer does handle background threads to prevent blocking your UI Thread, otherwise, you would want to perform threading yourself. (See <a class="link" href="ch14.html" title="Chapter 14. Getting your app ready for the Play Store">Chapter 14</a>, <em>Getting Your App Ready for the Play Store</em> for more information on threading and options.)</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec39"/>Using hardware volume keys to control your app's audio volume</h3></div></div></div><p>If you want the <a id="id704" class="indexterm"/>volume controls to control the volume in your app, use the <code class="literal">setVolumeControlStream()</code> method to specify your application's audio stream, as follows:</p><div><pre class="programlisting">setVolumeControlStream(AudioManager.STREAM_MUSIC);</pre></div><p>See the following <code class="literal">AudioManager</code> link for the other stream options.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec313"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Supported Media Format <a class="ulink" href="https://developer.android.com/guide/appendix/media-formats.html">https://developer.android.com/guide/appendix/media-formats.html</a></li><li class="listitem" style="list-style-type: disc"><strong>Developer </strong><a id="id705" class="indexterm"/><strong>Docs: MediaPlayer </strong><a class="ulink" href="http://developer.android.com/reference/android/media/MediaPlayer.html">http://developer.android.com/reference/android/media/MediaPlayer.html</a></li><li class="listitem" style="list-style-type: disc"><strong>Developer</strong><a id="id706" class="indexterm"/><strong> Docs: AudioManager</strong>: <a class="ulink" href="https://developer.android.com/reference/android/media/AudioManager.html">https://developer.android.com/reference/android/media/AudioManager.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec87"/>Responding to hardware media controls in your app</h1></div></div></div><p>Having your app respond to<a id="id707" class="indexterm"/> media controls, such as Play, Pause, Skip, and so on, is a nice touch your users will appreciate.</p><p>Android makes this possible through the media library. As with the <em>Playing sound effects with SoundPool</em> recipe earlier, the Lollipop release changed how this is done. Unlike the <code class="literal">SoundPool</code> example, this recipe is able to take advantage of another approach—the compatibility library.</p><p>This recipe will show you how to set up <code class="literal">MediaSession</code> to respond to the hardware buttons, which will work on Lollipop and later, as well as previous <code class="literal">Lollilop</code> versions using the <code class="literal">MediaSessionCompat</code> library. (The Compatibility Library will take care of checking the OS version and using the correct API calls automatically.)</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec314"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">HardwareMediaControls</code>. Use the default <strong>Phone &amp; Tablet</strong> options and select <strong>Empty Activity</strong> when prompted for the <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec315"/>How to do it...</h2></div></div></div><p>We'll just be using Toasts messages to respond to the hardware events and therefore will not need to make any changes to the activity layout. To get started, open <code class="literal">ActivityMain.java</code> and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the following<a id="id708" class="indexterm"/> <code class="literal">mMediaSessionCallback</code> to respond to the media buttons:<div><pre class="programlisting">MediaSessionCompat.Callback mMediaSessionCallback = new MediaSessionCompat.Callback() {
    @Override
    public void onPlay() {
        super.onPlay();
        Toast.makeText(MainActivity.this, "onPlay()", Toast.LENGTH_SHORT).show();
    }
    @Override
    public void onPause() {
        super.onPause();
        Toast.makeText(MainActivity.this, "onPause()", Toast.LENGTH_SHORT).show();
    }
    @Override
    public void onSkipToNext() {
        super.onSkipToNext();
        Toast.makeText(MainActivity.this, "onSkipToNext()", Toast.LENGTH_SHORT).show();
    }
    @Override
    public void onSkipToPrevious() {
        super.onSkipToPrevious();
        Toast.makeText(MainActivity.this, "onSkipToPrevious()", Toast.LENGTH_SHORT).show();
    }
};</pre></div></li><li class="listitem">Add the following code to the existing <code class="literal">onCreate()</code> callback:<div><pre class="programlisting">MediaSessionCompat mediaSession = new MediaSessionCompat(this, getApplication().getPackageName());
mediaSession.setCallback(mMediaSessionCallback);
mediaSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS);
mediaSession.setActive(true);
PlaybackStateCompat state = new PlaybackStateCompat.Builder()
  .setActions(
    PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_PLAY_PAUSE | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS).build();
mediaSession.setPlaybackState(state);</pre></div></li><li class="listitem">Run the application on a device or emulator with media controls (such as headphones) to see the Toast messages.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec316"/>How it works...</h2></div></div></div><p>There are four steps to <a id="id709" class="indexterm"/>setting this up:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">MediaSession.Callback</code> and attach it to MediaSession</li><li class="listitem">Set the MediaSession flags to indicate we want the media buttons</li><li class="listitem">Set <code class="literal">SessionState</code> to <code class="literal">active</code></li><li class="listitem">Set <code class="literal">PlayBackState</code> with the actions we're going to handle</li></ol></div><p>Steps 4 and 1 work together as the Callback will only get the events set in the <code class="literal">PlayBackState</code>.</p><p>Since we're not actually controlling any playback in this recipe, we just demonstrate how to respond to the hardware events. You'll want to implement actual functionality in <code class="literal">PlayBackState</code> and include a call to <code class="literal">setState()</code> after the <code class="literal">setActions()</code> call.</p><p>This is a very nice example of how the changes to the API can make things easier. And since new <code class="literal">MediaSession</code> and <code class="literal">PlaybackState</code> were rolled in to the Compatibility Library, we can take advantage of these new APIs on older versions of the OS.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec317"/>There's more...</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec40"/>Checking the hardware being used</h3></div></div></div><p>If you want your app to respond differently based on the current output hardware, you can use <code class="literal">AudioManager</code> to check. Here's an example:</p><div><pre class="programlisting">AudioManager audioManager =(AudioManager) this.getSystemService(Context.AUDIO_SERVICE);
if (audioManager.isBluetoothA2dpOn()) {
    // Adjust output for Bluetooth.
} else if (audioManager.isSpeakerphoneOn()) {
    // Adjust output for Speakerphone.
} else if (audioManager.isWiredHeadsetOn()) {
    //Only checks if a wired headset is plugged in
    //May not be the audio output
} else {
    // Regular speakers?
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec318"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Developer</strong><a id="id710" class="indexterm"/><strong> Docs: MediaSession</strong><p>
<a class="ulink" href="https://developer.android.com/reference/android/media/session/MediaSession.html">https://developer.android.com/reference/android/media/session/MediaSession.html</a>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Developer</strong><a id="id711" class="indexterm"/><strong> Docs: MediaSessionCompat</strong><p>
<a class="ulink" href="https://developer.android.com/reference/android/support/v4/media/session/MediaSessionCompat.html">https://developer.android.com/reference/android/support/v4/media/session/MediaSessionCompat.html</a>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Developer </strong><a id="id712" class="indexterm"/><strong>Docs: PlaybackState</strong><p>
<a class="ulink" href="https://developer.android.com/reference/android/support/v4/media/session/PlaybackStateCompat.html">https://developer.android.com/reference/android/support/v4/media/session/PlaybackStateCompat.html</a>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Developer </strong><a id="id713" class="indexterm"/><strong>Docs: PlaybackStateCompat</strong><p>
<a class="ulink" href="https://developer.android.com/reference/android/support/v4/media/session/PlaybackStateCompat.html">https://developer.android.com/reference/android/support/v4/media/session/PlaybackStateCompat.html</a>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec88"/>Taking a photo with the default camera app</h1></div></div></div><p>If your application needs an <a id="id714" class="indexterm"/>image from the camera, but is not a camera<a id="id715" class="indexterm"/> replacement app, it may be better to allow the "default" camera app to take the picture. This also respects your user's choice of a preferred camera application.</p><p>When you take a photo, unless it is specific to just your application, it's considered good practice to make the photo publicly available. (This allows it to be included in the user's photo gallery.) This recipe will demonstrate using the default photo application to click a picture, save it to the public folder, and display the image.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec319"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">UsingTheDefaultCameraApp</code>. Use the default <strong>Phone &amp; Tablet</strong> options and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec320"/>How to do it...</h2></div></div></div><p>We're going to create a layout with an ImageView and button. The button will create an Intent to launch the default Camera app. When the camera app is done, our app will get a callback. Start by opening the Android Manifest and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following permission:<div><pre class="programlisting">&lt;uses-permission
android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;</pre></div></li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file and replace the existing <code class="literal">TextView</code> with the following views:<div><pre class="programlisting">&lt;ImageView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:id="@+id/imageView"
    android:src="img/ic_launcher"
    android:layout_centerInParent="true"/&gt;

&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Take Picture"
    android:id="@+id/button"
    android:layout_alignParentBottom="true"
    android:layout_centerHorizontal="true"
    android:onClick="takePicture"/&gt;</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following global variables to the <code class="literal">MainActivity</code> class:<div><pre class="programlisting">final int PHOTO_RESULT=1;
private Uri mLastPhotoURI=null;</pre></div></li><li class="listitem">Add the <a id="id716" class="indexterm"/>following method to create the URI for <a id="id717" class="indexterm"/>the photo:<div><pre class="programlisting">private Uri createFileURI() {
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(System.currentTimeMillis());
    String fileName = "PHOTO_" + timeStamp + ".jpg";
    return Uri.fromFile(new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),fileName));
}</pre></div></li><li class="listitem">Add the following method to handle the button click:<div><pre class="programlisting">public void takePicture(View view) {
    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_ CAPTURE);
    if (takePictureIntent.resolveActivity(getPackageManager()) != 
        null) {
        mLastPhotoURI = createFileURI();
        takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, mLastPhotoURI);
         startActivityForResult(takePictureIntent, PHOTO_RESULT);
    }
}</pre></div></li><li class="listitem">Add a new method to override <code class="literal">onActivityResult()</code>, as follows:<div><pre class="programlisting">@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == PHOTO_RESULT &amp;&amp; resultCode == RESULT_OK ) {
        mImageView.setImageBitmap(BitmapFactory.decodeFile(mLastPhotoURI.getPath()));
    }
}</pre></div></li><li class="listitem">You're <a id="id718" class="indexterm"/>ready to run the application<a id="id719" class="indexterm"/> on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec321"/>How it works...</h2></div></div></div><p>There are two parts to working with the default camera app. The first is to set up the intent to launch the app. We create the Intent using <code class="literal">MediaStore.ACTION_IMAGE_CAPTURE</code> to indicate we want a photo app. We verify a default app exists by checking the results from <code class="literal">resolveActivity()</code>. As long as it's not null, we know an application is available to handle the intent. (Otherwise, our app will crash.) We create a filename and add it to the intent with: <code class="literal">putExtra(MediaStore.EXTRA_OUTPUT, mLastPhotoURI)</code>.</p><p>When we get the callback in <code class="literal">onActivityResult()</code>, we first make sure it's the <code class="literal">PHOTO_RESULT</code> and <code class="literal">RESULT_OK</code> (the user could have cancelled), then we load the photo in <code class="literal">ImageView</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec322"/>There's more...</h2></div></div></div><p>If you don't care where the picture is stored, you can call the intent without using the <code class="literal">MediaStore.EXTRA_OUTPUT</code> extra. If you don't specify the output file, the <code class="literal">onActivityResult()</code> will include a thumbnail of the image in data Intent. Here is how you can display the thumbnail:</p><div><pre class="programlisting">if (data != null) {
    imageView
.setImageBitmap((Bitmap) data.getExtras().get("data"));
}</pre></div><p>Here's the code to load the full resolution image, using the URI returned in <code class="literal">data Intent</code>:</p><div><pre class="programlisting">if (data != null) {
    try {
        imageView.setImageBitmap(
            MediaStore.Images.Media. getBitmap(getContentResolver(),
            Uri.parse(data.toUri(Intent.URI_ALLOW_UNSAFE))));
    } catch (IOException e) {
        e.printStackTrace();
    }
}</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec41"/>Calling the default video app</h3></div></div></div><p>It's the same process if you want <a id="id720" class="indexterm"/>to call the default video capture application. Just change the intent in Step 5, as follows:</p><div><pre class="programlisting">Intent takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);</pre></div><p>You can get the URI to the video in the <code class="literal">onActivityResult()</code>, as follows:</p><div><pre class="programlisting">Uri videoUri = intent.getData();</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec323"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Scaling down large images to avoid Out of Memory exceptions</em> recipe in <a class="link" href="ch09.html" title="Chapter 9. Graphics and Animation">Chapter 9</a>, <em>Graphics and Animation</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec89"/>Taking a picture using the (old) Camera API</h1></div></div></div><p>The previous recipe <a id="id721" class="indexterm"/>demonstrated how to use an intent to call the <a id="id722" class="indexterm"/>default photo application. If you only need a quick photo, the intent is probably the ideal solution. If not, and you need more control of the camera, this recipe will show you how to use the camera directly with the Camera API.</p><p>There are actually two recipes for using the Camera API—one for the original Camera API released in Android 1.0 (API 1) and Camera2 API, released in Android 5.0 (API 21). We'll cover both the new and the old APIs. Ideally, you will want to write your application to the latest and greatest APIs available, but at the time of this writing, Android 5.0 (API 21) only has about a 23 percent market share. If you only use the Camera2 API, you exclude over 75 percent of the market.</p><p>Write your app to use Camera2 API to take advantage of the new features available, but still have a functional application using the original Camera API for the rest of your users. To help facilitate using both, this recipe is going to take advantage of newer features in Android, specifically the <code class="literal">TextureView</code>, introduced in Android 4.0 (API 14). We'll use the <code class="literal">TextureView</code>, in place of the more traditional <code class="literal">SurfaceView</code>, for displaying the camera preview. This will allow you to use the same layout with the newer Camera2 API as it uses the <code class="literal">TextureView</code> as well. (Setting the minimum API to Android 4.0 (API 14) and above, which has over 96 percent market share, isn't limiting your user base much.)</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec324"/>Getting ready</h2></div></div></div><p>Create a new project in<a id="id723" class="indexterm"/> Android Studio and call it <code class="literal">CameraAPI</code>. \On <a id="id724" class="indexterm"/>the <strong>Target Android Devices</strong> dialog, select the <strong>Phone &amp; Tablet</strong> option and chose API 14 (or above) for the <strong>Minimum SDK. </strong>Select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec325"/>How to do it...</h2></div></div></div><p>Start by opening the Android Manifest and following these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following two permissions:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.CAMERA"/&gt;
&lt;uses-permission
android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</pre></div></li><li class="listitem">Now open <code class="literal">activity_main.xml</code> and replace the existing TextView with the following views:<div><pre class="programlisting">&lt;TextureView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/textureView"
    android:layout_alignParentTop="true"
    android:layout_centerHorizontal="true" /&gt;

&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Take Picture"
    android:id="@+id/button"
    android:layout_alignParentBottom="true"
    android:layout_centerHorizontal="true"
    android:onClick="takePicture"/&gt;</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and modify the <code class="literal">MainActivity</code> class declaration to implement the <code class="literal">SurfaceTextureListener</code>, as follows:<div><pre class="programlisting">public class MainActivity extends AppCompatActivity
        implements TextureView.SurfaceTextureListener {</pre></div></li><li class="listitem">Add the <a id="id725" class="indexterm"/>following global declarations<a id="id726" class="indexterm"/> to <code class="literal">MainActivity</code>:<div><pre class="programlisting">@Deprecated
private Camera mCamera;
private TextureView mTextureView;</pre></div></li><li class="listitem">Create the following <code class="literal">PictureCallback</code> to handle saving the photo:<div><pre class="programlisting">Camera.PictureCallback pictureCallback = new Camera.PictureCallback() {
    @Override
    public void onPictureTaken(byte[] data, Camera camera) {
        try {
            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(System.currentTimeMillis());
            String fileName = "PHOTO_" + timeStamp + ".jpg";
            File pictureFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),fileName);

            FileOutputStream fileOutputStream =new FileOutputStream(pictureFile.getPath());
            fileOutputStream.write(data);
            fileOutputStream.close();
            Toast.makeText(MainActivity.this, "Picture Taken", Toast.LENGTH_SHORT).show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
};</pre></div></li><li class="listitem">Add the following code to the existing <code class="literal">onCreate()</code> callback:<div><pre class="programlisting">mTextureView = (TextureView)findViewById(R.id.textureView);
mTextureView.setSurfaceTextureListener(this);</pre></div></li><li class="listitem">Add the following methods to implement the <code class="literal">SurfaceTextureListener</code> interface:<div><pre class="programlisting">public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
    mCamera = Camera.open();
    if (mCamera!=null) {
        try {
            mCamera.setPreviewTexture(surface);
            mCamera.startPreview();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
    if (mCamera!=null) {
        mCamera.stopPreview();
        mCamera.release();
    }
    return true;
}
public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
    // Unused
}
public void onSurfaceTextureUpdated(SurfaceTexture surface) {
    // Unused
}</pre></div></li><li class="listitem">Add the<a id="id727" class="indexterm"/> following method to handle the<a id="id728" class="indexterm"/> button click:<div><pre class="programlisting">public void takePicture(View view) {
    if (mCamera!=null) {
        mCamera.takePicture(null, null, pictureCallback);
    }
}</pre></div></li><li class="listitem">Run the application on a device or emulator with a camera.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec326"/>How it works...</h2></div></div></div><p>The first thing to note is, when you're looking at this code in Android Studio, you're going to see a lot of strikethrough code with the following warning:</p><div><pre class="programlisting">'android.hardware.Camera' is deprecated</pre></div><p>As mentioned in the introduction, the <code class="literal">android.hardware.camera2</code> API was introduced in Android 5.0 (API 19) and replaces the <code class="literal">android.hardware.camera</code> APIs.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>You can add the following annotation to suppress the Deprecation warning:</p><div><pre class="programlisting">@SuppressWarnings("deprecation")</pre></div></div></div><p>There are two <a id="id729" class="indexterm"/>main steps when using the Camera API:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set up the <a id="id730" class="indexterm"/>preview</li><li class="listitem" style="list-style-type: disc">Capture the image</li></ul></div><p>We get the <code class="literal">TextureView</code> from our layout, then assign our activity (which implements <code class="literal">SurfaceTextureListener</code>) as the listener using this code:</p><div><pre class="programlisting">mTextureView.setSurfaceTextureListener(this);</pre></div><p>When the <code class="literal">TextureView</code> surface is ready, we get the <code class="literal">onSurfaceTextureAvailable</code> callback, where we set the preview surface with the following code:</p><div><pre class="programlisting">mCamera.setPreviewTexture(surface);
mCamera.startPreview();</pre></div><p>The next step is to take the picture when the button is pressed. We do that with this code:</p><div><pre class="programlisting">mCamera.takePicture(null, null, pictureCallback);</pre></div><p>When the picture is ready, we get the <code class="literal">onPictureTaken()</code> callback in the <code class="literal">Camera.PictureCallback</code> class we created.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec327"/>There's more...</h2></div></div></div><p>Keep in mind, this code is meant to show you how it works, not to create a full commercial application. As most developers know, the real challenge in coding is to handle all the problem cases. Some areas to improve include adding the ability to switch cameras, as the app currently uses the default camera. Also, take a look at the device orientation for both the preview and when saving a picture. A more sophisticated app would handle some of the work on a background thread to avoid delays on the UI thread. (Take a look at the next recipe to see how we do some of the camera processing on a background thread.)</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec42"/>Setting the camera parameters</h3></div></div></div><p>The Camera API <a id="id731" class="indexterm"/>includes parameters, which allow us to adjust the camera settings. With this example, we can change the size of the preview:</p><div><pre class="programlisting">Camera.Parameters parameters = mCamera.getParameters();
parameters.setPreviewSize(mPreviewSize.width, 
mPreviewSize.height);
mCamera.setParameters(parameters);</pre></div><p>Keep in mind, the hardware must also support the setting we want. In this example, we'd want to query the hardware first to get all available preview modes, then set the one that matches our <a id="id732" class="indexterm"/>requirements. (See an example of this in the next recipe when we set the picture resolution.) See <code class="literal">getParameters()</code> in the Camera documentation link.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec328"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next recipe: <em>Taking a picture using the Camera2 (the new) API</em></li><li class="listitem" style="list-style-type: disc">The <em>Reading device orientation</em> recipe in <a class="link" href="ch08.html" title="Chapter 8. Using the Touchscreen and Sensors">Chapter 8</a>, <em>Using the Touchscreen and Sensors</em> for examples on detecting the current device orientation</li><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: Building a Camera App</strong> at: <a class="ulink" href="https://developer.android.com/guide/topics/media/camera.html#custom-camera">https://developer.android.com/guide/topics/media/camera.html#custom-camera</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://developer.android.com/reference/android/hardware/Camera.html">https://developer.android.com/reference/android/hardware/Camera.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec90"/>Taking a picture using the Camera2 (the new) API</h1></div></div></div><p>Now that we've <a id="id733" class="indexterm"/>looked at the old Camera API, it's <a id="id734" class="indexterm"/>time to learn about the new Camera2 API. Unfortunately, it's a bit more complicated due to the asynchronous nature of the APIs. Fortunately, the overall concept is the same as the previous Camera API.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec329"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">Camera2API</code>. On the <strong>Target Android Devices</strong> dialog, select the <strong>Phone &amp; Tablet</strong> option and chose API 21 (or higher) for the <strong>Minimum SDK</strong>. Select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec330"/>How to do it...</h2></div></div></div><p>As you'll see, there's a lot of code for this recipe. Start by opening the Android Manifest and following these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following two permissions:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</pre></div></li><li class="listitem">Now open <code class="literal">activity_main.xml</code> and replace the existing TextView with the following views:<div><pre class="programlisting">&lt;TextureView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/textureView"
    android:layout_alignParentTop="true"
    android:layout_centerHorizontal="true" /&gt;

&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Take Picture"
    android:id="@+id/button"
    android:layout_alignParentBottom="true"
    android:layout_centerHorizontal="true"
    android:onClick="takePicture"/&gt;</pre></div></li><li class="listitem">Now open the <code class="literal">MainActivity.java</code> file and add the following global variables to the <code class="literal">MainActivity</code> class:<div><pre class="programlisting">private CameraDevice mCameraDevice = null;
private CaptureRequest.Builder mCaptureRequestBuilder = null;
private CameraCaptureSession mCameraCaptureSession  = null;
private TextureView mTextureView = null;
private Size mPreviewSize = null;</pre></div></li><li class="listitem">Add the <a id="id735" class="indexterm"/>following <code class="literal">Comparator</code> <a id="id736" class="indexterm"/>class:<div><pre class="programlisting">static class CompareSizesByArea implements Comparator&lt;Size&gt; {
    @Override
    public int compare(Size lhs, Size rhs) {
        return Long.signum((long) lhs.getWidth() * lhs.getHeight() - (long) rhs.getWidth() * rhs.getHeight());
    }
}</pre></div></li><li class="listitem">Add the following <code class="literal">CameraDevice.StateCallback</code>:<div><pre class="programlisting">private CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {
    @Override
    public void onOpened(CameraDevice camera) {
        mCameraDevice = camera;
        SurfaceTexture texture = mTextureView.getSurfaceTexture();
        if (texture == null) {
            return;
        }
        texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());
        Surface surface = new Surface(texture);
        try {
            mCaptureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        } catch (CameraAccessException e){
            e.printStackTrace();
        }
        mCaptureRequestBuilder.addTarget(surface);
        try {
            mCameraDevice.createCaptureSession(Arrays.asList(surface), mPreviewStateCallback, null);
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void onError(CameraDevice camera, int error) {}
    @Override
    public void onDisconnected(CameraDevice camera) {}
};</pre></div></li><li class="listitem">Add<a id="id737" class="indexterm"/> the <a id="id738" class="indexterm"/>following <code class="literal">SurfaceTextureListener</code>:<div><pre class="programlisting">private TextureView.SurfaceTextureListener mSurfaceTextureListener =     new TextureView.SurfaceTextureListener() {
    @Override
    public void onSurfaceTextureUpdated(SurfaceTexture surface) {}
    @Override
    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {}
    @Override
    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
            return false;
    }
    @Override
    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
            openCamera();
    }
};</pre></div></li><li class="listitem">Add the following <code class="literal">CameraCaptureSession.StateCallback</code>:<div><pre class="programlisting">private CameraCaptureSession.StateCallback mPreviewStateCallback = new CameraCaptureSession.StateCallback() {
    @Override
    public void onConfigured(CameraCaptureSession session) {
        startPreview(session);
    }

    @Override
    public void onConfigureFailed(CameraCaptureSession session) {}
};</pre></div></li><li class="listitem">Add the<a id="id739" class="indexterm"/> following code to the <a id="id740" class="indexterm"/>existing <code class="literal">onCreate()</code> callback:<div><pre class="programlisting">mTextureView = (TextureView) findViewById(R.id.textureView);
mTextureView.setSurfaceTextureListener(mSurfaceTextureListener);</pre></div></li><li class="listitem">Add the following methods to override <code class="literal">onPause()</code> and <code class="literal">onResume()</code>:<div><pre class="programlisting">@Override
protected void onPause() {
    super.onPause();
    if (mCameraDevice != null) {
        mCameraDevice.close();
        mCameraDevice = null;
    }
}
@Override
public void onResume() {
    super.onResume();
    if (mTextureView.isAvailable()) {
        openCamera();
    } else {
        mTextureView.setSurfaceTextureListener(mSurfaceTextureListener);
    }
}</pre></div></li><li class="listitem">Add the <code class="literal">openCamera()</code>method:<div><pre class="programlisting">private void openCamera() {
    CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
    try{
        String cameraId = manager.getCameraIdList()[0];
        CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
        StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP); 
        mPreviewSize = map.getOutputSizes(SurfaceTexture.class) [0];
        manager.openCamera(cameraId, mStateCallback, null);
    } catch(CameraAccessException e) {
        e.printStackTrace();
    } catch (SecurityException e) {
        e.printStackTrace();
    }
}</pre></div></li><li class="listitem">Add<a id="id741" class="indexterm"/> the <code class="literal">startPreview()</code> <a id="id742" class="indexterm"/>method:<div><pre class="programlisting">private void startPreview(CameraCaptureSession session) { 
    mCameraCaptureSession = session; 
    mCaptureRequestBuilder.set(CaptureRequest.CONTROL_MODE,CameraMetadata.CONTROL_MODE_AUTO); 
    HandlerThread backgroundThread = new HandlerThread("CameraPreview"); 
    backgroundThread.start();
    Handler backgroundHandler = new Handler(backgroundThread. getLooper());
    try {
        mCameraCaptureSession.setRepeatingRequest(mCaptureRequestBuilder.build(), null, backgroundHandler);
    } catch (CameraAccessException e) {
        e.printStackTrace();
    }
}</pre></div></li><li class="listitem">Add the <code class="literal">getPictureFile()</code> method:<div><pre class="programlisting">private File getPictureFile() {
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss"). format(System.currentTimeMillis());
    String fileName = "PHOTO_" + timeStamp + ".jpg";
    return new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),fileName);
}</pre></div></li><li class="listitem">Add the<a id="id743" class="indexterm"/> <code class="literal">takePicture()</code> method that <a id="id744" class="indexterm"/>saves the image file:<div><pre class="programlisting">protected void takePicture(View view) {
    if (null == mCameraDevice) {
        return;
    }
    CameraManager manager = (CameraManager)
    getSystemService(Context.CAMERA_SERVICE);
    try {
        CameraCharacteristics characteristics = manager.getCameraCharacteristics(mCameraDevice.getId());
        StreamConfigurationMap configurationMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        if (configurationMap == null) return;
        Size largest = Collections.max(
            Arrays.asList(configurationMap.getOutputSizes(ImageFormat.JPEG)),
            new CompareSizesByArea());
        ImageReader reader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(), ImageFormat.JPEG, 1);
        List &lt; Surface &gt; outputSurfaces = new ArrayList &lt; Surface &gt; (2);
        outputSurfaces.add(reader.getSurface());
        outputSurfaces.add(new Surface(mTextureView.getSurfaceTexture()));
        final CaptureRequest.Builder captureBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_ CAPTURE);
        captureBuilder.addTarget(reader.getSurface());
        captureBuilder.set(CaptureRequest.CONTROL_MODE,
            CameraMetadata.CONTROL_MODE_AUTO);
        ImageReader.OnImageAvailableListener readerListener = new ImageReader.OnImageAvailableListener() {
            @Override
            public void onImageAvailable(ImageReader reader) {
                Image image = null;
                try {
                    image = reader.acquireLatestImage();
                    ByteBuffer buffer = image.getPlanes()[0].getBuffer();
                    byte[] bytes = new byte[buffer.capacity()];
                    buffer.get(bytes);
                    OutputStream output = new FileOutputStream( get PictureFile());
                    output.write(bytes);
                    output.close();
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    if (image != null) {
                        image.close();
                    }
                }
            }
        };
        HandlerThread thread = new HandlerThread("CameraPicture");
        thread.start();
        final Handler backgroudHandler = new Handler(thread.getLooper());
        reader.setOnImageAvailableListener(readerListener, backgroudHandler);
        final CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() {
            @Override
            public void onCaptureCompleted(
            CameraCaptureSession session, CaptureRequest request, TotalCaptureResult result) {
                    super.onCaptureCompleted(session, request, result);
                    Toast.makeText(MainActivity.this, "Picture Saved", Toast.LENGTH_SHORT).show();
                    startPreview(session);
            }
        };
        mCameraDevice.createCaptureSession(outputSurfaces, new CameraCaptureSession.StateCallback() {
            @Override
            public vod onConfigured(CameraCaptureSession session) {
                try {
                    session.capture(captureBuilder.build(), captureCallback, backgroudHandler);
                } catch (CameraAccessException e) {
                    e.printStackTrace();
                }
            }
            @Override
            public void onConfigureFailed(CameraCaptureSession session) { }
        }, backgroudHandler);
    } catch (CameraAccessException e) {
        e.printStackTrace();
    }
}</pre></div></li><li class="listitem">Run the application on a device or emulator with a camera.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec331"/>How it works...</h2></div></div></div><p>Since we learned<a id="id745" class="indexterm"/> about the TextureView in the<a id="id746" class="indexterm"/> previous recipe, we can jump to the new Camera2 API information.</p><p>Though there are more classes involved, just like the older Camera API, there are two basic steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the preview</li><li class="listitem" style="list-style-type: disc">Capturing the image</li></ul></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec43"/>Setting up the preview</h3></div></div></div><p>Here's a rundown on how <a id="id747" class="indexterm"/>the code sets up the preview:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we set up the <code class="literal">TextureView.SurfaceTextureListener</code> with the <code class="literal">setSurfaceTextureListener()</code> method in <code class="literal">onCreate()</code>.</li><li class="listitem">When we get the <code class="literal">onSurfaceTextureAvailable()</code> callback, we open the camera.</li><li class="listitem">We pass our <code class="literal">CameraDevice.StateCallback</code> class to the <code class="literal">openCamera()</code> method, which eventually calls the <code class="literal">onOpened()</code> callback.</li><li class="listitem"><code class="literal">onOpened()</code> gets the surface for the preview by calling <code class="literal">getSurfaceTexture()</code> and passes it to the CameraDevice by calling <code class="literal">createCaptureSession()</code>.</li><li class="listitem">Finally, when <code class="literal">CameraCaptureSession.StateCallback onConfigured()</code> is called, we start the preview with the <code class="literal">setRepeatingRequest()</code> method.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec44"/>Capturing the image</h3></div></div></div><p>Even though the <code class="literal">takePicture()</code> method<a id="id748" class="indexterm"/> may appear to be procedural, capturing an image also involves several classes and relies on callbacks. Here's a breakdown on how the code takes a picture:</p><div><ol class="orderedlist arabic"><li class="listitem">The user clicks the <strong>Take Picture</strong> button.</li><li class="listitem">Then queries the camera to find the largest available image size.</li><li class="listitem">Then creates an <code class="literal">ImageReader</code>.</li><li class="listitem">Next, he/she sets up <code class="literal">OnImageAvailableListener</code>, and saves the image in the <code class="literal">onImageAvailable()</code> callback.</li><li class="listitem">Then, creates <code class="literal">CaptureRequest.Builder</code> and includes the <code class="literal">ImageReader</code> surface.</li><li class="listitem">Next, creates <code class="literal">CameraCaptureSession.CaptureCallback</code>, which defines the <code class="literal">onCaptureCompleted()</code> callback. When the capture is complete, it restarts the preview.</li><li class="listitem">Then, calls the <code class="literal">createCaptureSession()</code> method, creating a <code class="literal">CameraCaptureSession.StateCallback</code>. This is where the <code class="literal">capture()</code> method is called, passing in the <code class="literal">CameraCaptureSession.CaptureCallback</code> created earlier.</li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec332"/>There's more...</h2></div></div></div><p>As with the previous Camera example, we've just created the base code to demonstrate a working Camera application. Again, there are areas for improvement. First, you should handle the device orientation, for both the preview and when saving the images. (See the previous recipe for the link.) Also, with Android 6.0 (API 23) now available, it would be a good time to start using the new permission model. Instead of just checking for an exception as we do in the <code class="literal">openCamera()</code> method, it would be better to check for the required permission.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec333"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The previous recipe: <em>Taking a picture using the (old) Camera API</em></li><li class="listitem" style="list-style-type: disc"><em>The new Android 6.0 Run-Time permission model</em> in <a class="link" href="ch14.html" title="Chapter 14. Getting your app ready for the Play Store">Chapter 14</a><em>, Getting Your App Ready for the Play Store</em></li><li class="listitem" style="list-style-type: disc">Developer Docs: Camera2 API</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html">https://developer.android.com/reference/android/hardware/camera2/package-summary.html</a></li></ul></div></div></div></body></html>