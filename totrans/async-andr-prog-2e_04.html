<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Exploring the Loader"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Exploring the Loader</h1></div></div></div><p>In the previous chapter we familiarized ourselves with the simplest and high level, Android-specific, asynchronous construct; the <code class="literal">android.os.AsyncTask</code>. The <code class="literal">AsyncTask</code> is a lean construct used to create background work that offers a simple interface to publish results and send progress to the main thread. In this chapter we are going to move our focus to <code class="literal">android.content.Loader</code>, a high level Android-specific pattern used to load content asynchronously from content providers or data sources over a worker thread with content change capabilities and component lifecycle awareness.</p><p>In this chapter we will cover the the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing loaders</li><li class="listitem" style="list-style-type: disc">Loader API</li><li class="listitem" style="list-style-type: disc">Loader lifecycle</li><li class="listitem" style="list-style-type: disc">Loading data with Loader</li><li class="listitem" style="list-style-type: disc">Building responsive apps with AsyncTaskLoader</li><li class="listitem" style="list-style-type: disc">Building responsive apps with CursorLoader</li><li class="listitem" style="list-style-type: disc">Combining loaders</li><li class="listitem" style="list-style-type: disc">Applications of loaders</li></ul></div><div class="section" title="Introducing Loaders"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Introducing Loaders</h1></div></div></div><p>As the name suggests, the <a id="id187" class="indexterm"/>job of <code class="literal">Loader</code> is to load data on behalf of other parts of the application, and to make that data available across activities and fragments within the same process. The Loaders framework was created to solve a couple of issues related to asynchronous loading in Activities and Fragments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Background processing</strong></span>: The heavy lifting is automatically performed on a background thread, and the results are safely introduced to the main thread on completion.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Result caching</strong></span>: Loaded data can be cached and redelivered on repeat calls for speed and efficiency.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lifecycle awareness</strong></span>: The framework gives us control over when a Loader instance is destroyed, and allows Loaders to live outside the <code class="literal">Activity</code> lifecycle, making their data available across the application and across <code class="literal">Activity</code> restarts.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data change management</strong></span>: Loaders monitor their underlying data source, and reload their data in the <a id="id188" class="indexterm"/>background when necessary. The framework includes lifecycle callbacks that allow us to properly dispose of any expensive resources held by our Loaders.</li></ul></div><div class="section" title="Loader API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Loader API</h2></div></div></div><p>The <code class="literal">Loader</code> API was <a id="id189" class="indexterm"/>introduced to the Android platform at API level 11, but are available for backwards compatibility through the support libraries. The examples in this chapter use the support library to target API levels 7 through 23.</p><p>The framework defines interfaces, abstract classes, and loader implementations to create first class Android data loaders for your application.</p><p>The Loaders are able to monitor the content and deliver new changes, and will survive across an Activity transition or across a replaced Activity triggered by a configuration change. The API classes and interfaces delivered by this framework are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android.content.Loader&lt;DataType&gt;</code>: Nonfunctional (abstract) base class that defines the base methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.LoaderManager</code>: Manages loaders in Activities and Fragments</li><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.LoaderManager.LoaderCallbacks</code>: Callbacks used to listen for Loader events</li><li class="listitem" style="list-style-type: disc"><code class="literal">android.content.AsyncTaskLoader&lt;DataType&gt;</code>: <code class="literal">Loader</code> subclass that executes the loading over an <code class="literal">AsyncTask</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android.content.CursorLoader</code>: Loader implementation used to deal with Android internal databases and content providers' data sources</li></ul></div><p>The last two classes are non-abstract subclasses that we will go into detail with examples in the next sections of this chapter.</p><div class="section" title="Loader"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Loader</h3></div></div></div><p>
<code class="literal">Loader</code> is a generic <a id="id190" class="indexterm"/>type class that, by itself, does not implement any asynchronous behavior and exposes one generic type argument:</p><div class="informalexample"><pre class="programlisting">public class Loader&lt;DataType&gt;</pre></div><p>The <code class="literal">&lt;DataType&gt;</code> generic type defines the result type that your <code class="literal">Loader</code> is going to deliver and should be defined by any subclass that implements a domain specific <code class="literal">Loader</code>.</p><p>When you create your own loader there are five methods of <code class="literal">Loader</code> which we must implement to create a fully functional Loader:</p><div class="informalexample"><pre class="programlisting">protected void onStartLoading()
protected void onStopLoading()
protected void onForceLoad()
protected void onReset()
protected void onCancelLoad()</pre></div><p>The <code class="literal">onStartLoading()</code> method is the method that subclass must implement to start loading data, the <code class="literal">onStopLoading()</code> is a method used to implement behavior when a loader stop was requested because the activity or fragment associated is stopped. At this state, the <code class="literal">Loader</code> may carry on processing but shouldn't deliver updates to the <code class="literal">Activity</code> until <code class="literal">onStartLoading()</code> is invoked again.</p><p>The <code class="literal">onForceLoad()</code> is a method that you should implement to ignore a previously loaded data set and load a new one, like clearing a cache, and the <code class="literal">onReset()</code> method is a method called for you automatically by LoaderManager to free any loader's resources if your loader is not invoked again.</p><p>The <code class="literal">onCancelLoad()</code> is a method invoked on the main thread used to implement behavior when the load is canceled after invoking the <code class="literal">Loader.cancelLoad()</code>.</p><p>Although we can extend <code class="literal">Loader</code> directly, it is more common to use one of the two provided subclasses, <code class="literal">AsyncTaskLoader </code>or <code class="literal">CursorLoader</code>, depending on our requirements.</p><p>
<code class="literal">AsyncTaskLoader</code> is a general-purpose <code class="literal">Loader</code>, which we can subclass when we want to load just about any kind of data from just about any kind of source, and do so off the main thread.</p><p>
<code class="literal">CursorLoader</code> extends <code class="literal">AsyncTaskLoader</code>, specializing it to efficiently source data from a local database and manage the associated database <code class="literal">Cursor</code> correctly.</p></div><div class="section" title="Loader Manager"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Loader Manager</h3></div></div></div><p>When we use Loaders, we <a id="id191" class="indexterm"/>will not do so in isolation, because they form part of a small framework. Loaders are managed objects, and are looked after by a <code class="literal">LoaderManager</code>, which takes care of coordinating Loader lifecycle events with the <a id="id192" class="indexterm"/><code class="literal">Fragment</code> and <code class="literal">Activity</code> lifecycles, and makes the <code class="literal">Loader</code> instances available to the client code throughout an application.  The <code class="literal">LoaderManager</code> abstract class defined in <code class="literal">android.support.v4.content.LoaderManager</code> and   <code class="literal">android.app.LoaderManager</code> is accessible in all the Activities and Fragments through the member function <code class="literal">getLoaderManager</code>:</p><div class="informalexample"><pre class="programlisting">LoaderManager getLoaderManager()
// android.support.v4
LoaderManager getSupportLoaderManager();</pre></div><p>The LoaderManager provides an API that could be used by the client (Activity or Fragment) to set up, initialize, restart, and destroy loaders without being bound to the client lifecycle. The Loader Manager's most relevant methods that are accessible when you retrieve the client-managed LoaderManager instance are:</p><div class="informalexample"><pre class="programlisting">Loader&lt;D&gt; initLoader(int id, Bundle args,
                     LoaderManager.LoaderCallbacks&lt;D&gt; callback)

Loader&lt;D&gt; restartLoader(int id,Bundle args, 
                        LoaderManager.LoaderCallbacks&lt;D&gt; callback)
Loader&lt;D&gt; getLoader(int id);
void destroyLoader(int id);</pre></div><p>The <code class="literal">id</code> argument in all the methods defined by the <code class="literal">LoaderManager</code> identifies the Loader on the client context, and moreover, is used in all the <code class="literal">LoaderManager</code> APIs to trigger any action in a specific Loader.</p><p>The <code class="literal">initLoader</code> method is used to initialize a certain loader but it does not create a new Loader if a Loader with the same ID already exists on the <code class="literal">LoaderManager</code>.</p><p>The <code class="literal">restartLoader</code> method starts or restarts a loader, however if a Loader associated with the ID passed in already exists, the old loader will be destroyed when it completes its work.</p><p>The <code class="literal">destroyLoader</code> method stops and removes the <code class="literal">Loader</code> with the ID specified by the argument <code class="literal">id</code> explicitly from the <code class="literal">LoaderManager</code>.</p></div><div class="section" title="LoaderManager.LoaderCallbacks"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec07"/>LoaderManager.LoaderCallbacks</h3></div></div></div><p>To <a id="id193" class="indexterm"/>interact with the <code class="literal">LoaderManager</code>, the client needs to implement the <code class="literal">LoaderCallbacks&lt;D&gt;</code> interface and receive events to <a id="id194" class="indexterm"/>create a new <code class="literal">Loader</code> for a given ID, to receive the Loader results, or reset a Loader respectively:</p><div class="informalexample"><pre class="programlisting">Loader&lt;D&gt; onCreateLoader(int id, Bundle args)
void onLoadFinished(Loader&lt;D&gt; loader, D data)
void onLoaderReset(Loader&lt;D&gt; loader)</pre></div><p>Like we detailed before, the <code class="literal">D</code> generic type specifies the data type that the Loader returns and these callbacks are called by the LoaderManager when a particular state is reached on the Loader lifecycle:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onCreateLoader</code>: This is a creational method that bootstraps a Loader for a specified ID and with a given Bundle object. The Bundle object is used to pass arguments for the Loader creation. This method gets invoked when the client calls <code class="literal">initLoader</code> and no Loader with that ID exists on LoaderManager.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onLoadFinished</code>: This is the method called when the Loader gets its results; the callback is called with the results and with a reference for the loader that retrieved the result. When the Loader detects a content change on the data requested it will report back the new results, therefore this method could be called several times. This method is typically used to update the UI with the loaded data.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onLoaderReset</code>: This is the method invoked when the Loader for a given ID is going to be destroyed. This is the best place to release some resources and references attached to one specified ID.</li></ul></div></div></div><div class="section" title="Loader lifecycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Loader lifecycle</h2></div></div></div><p>Any Loader object <a id="id195" class="indexterm"/>managed by a <code class="literal">LoaderManager</code> can be in six different flags that defines the Loader state:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Reset</strong></span>: This is the flag that sets your loader when you create a Loaders instance. The flag would end up here if the <code class="literal">reset()</code> method is invoked. The <code class="literal">onReset()</code> is called when the reset is moving to this state, and the developer must use this method to release the resources allocated on the Loader and to reset any cache result.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Started</strong></span>: This is the flag set when your loader <code class="literal">startLoading()</code> is invoked. After your loader enters into this state, the <code class="literal">onStartLoading</code> method gets invoked to setup your loading resources.  If the Loader has already delivered results you can call the <code class="literal">forceLoad()</code> to restart a new loading. Your loader should only deliver results when this flag is on.</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stopped</strong></span>: This is the flag set when the loader is stopped and is not able to deliver new results or delivery of content changes. In this state, the loader could store results to deliver when the loader is restarted. To implement behavior when the loader has this on, the developer must implement the <code class="literal">onStopLoading</code> and release any resources allocated to load the results.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abandoned</strong></span>: This is an optional intermediate flag used to pinpoint whether the <code class="literal">Loader</code> was <a id="id196" class="indexterm"/>abandoned. Like the other methods, subclasses must implement the <code class="literal">onAbandon()</code> to implement behavior when the client is no longer interested in new data updates from the loader. At this state, prior to Reset, the Loader must not report any fresh updates but it can keep results to deliver when the loader is restarted.</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ContentChanged</strong></span>: This is a flag used to notify that the Loader content has changed. The <code class="literal">onContentChanged</code> is callback invoked when a content change is detected on the Load.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ProcessingChange</strong></span>: This is a flag used to notify that the Loader content is processing a change on its content. The following functions <code class="literal">takeContentChanged()</code>, <code class="literal">commitContentChanged()</code>, and <code class="literal">rollbackContentChanged()</code> are used to manage the data content changes and its processing state.<div class="mediaobject"><img src="graphics/Image_B05062_04_01.jpg" alt="Loader lifecycle"/><div class="caption"><p>Figure 4.1: Loader Lifecycle</p></div></div></li></ul></div></div></div></div>
<div class="section" title="Loading data with Loader"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Loading data with Loader</h1></div></div></div><p>So far, we have <a id="id197" class="indexterm"/>only described theoretical entities and the classes <a id="id198" class="indexterm"/>available on the API so now is the right time to show these concepts with a simple example.</p><p>In our example we will show you how to use <code class="literal">LoaderManager</code>, <code class="literal">LoaderCallback</code>, and a <code class="literal">Loader</code> to present an <code class="literal">Activity</code> that lists the name of users that are currently online for a chat application.</p><p>First, we are going to create an Activity that will act as a client to the <code class="literal">LoaderManager</code> and will have three buttons, <span class="strong"><strong>INIT</strong></span>, <span class="strong"><strong>RESTART</strong></span>, and <span class="strong"><strong>DESTROY</strong></span>; to initialize the loader, to restart, and to destroy the loader respectively. The Activity will receive the <code class="literal">LoaderCallbacks</code> callback directly since it implements that interface as member functions:</p><div class="informalexample"><pre class="programlisting">public class WhoIsOnlineActivity extends FragmentActivity
  implements LoaderCallbacks&lt;List&lt;String&gt;&gt; {
  public static final int WHO_IS_ONLINE_LOADER_ID = 1;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
   ...
    final LoaderManager lm =  getSupportLoaderManager();
    final Bundle bundle =new Bundle();
    bundle.putString("chatRoom", "Developers");
    initButton.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
<span class="strong"><strong>        lm.initLoader(WHO_IS_ONLINE_LOADER_ID, bundle,</strong></span>
<span class="strong"><strong>                      WhoIsOnlineActivity.this);</strong></span>
      }
    });
    restartButton.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
<span class="strong"><strong>        lm.restartLoader(WHO_IS_ONLINE_LOADER_ID, bundle,</strong></span>
<span class="strong"><strong>                         WhoIsOnlineActivity.this);</strong></span>
      }
    });
    destroyButton.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
<span class="strong"><strong>        lm.destroyLoader(WHO_IS_ONLINE_LOADER_ID);</strong></span>
      }
    });
 }
}</pre></div><p>Clicking on the <span class="strong"><strong>INIT</strong></span> button will initialize the <code class="literal">Loader</code> with the ID specified and with a bundle object that <a id="id199" class="indexterm"/>we use to pass arguments to the <code class="literal">Loader</code>, and as said <a id="id200" class="indexterm"/>before the <span class="strong"><strong>RESTART</strong></span> button will destroy a previous loader if it already exists and create a new one and the <span class="strong"><strong>DESTROY</strong></span> button will destroy the loader with the given ID if it already exists in the <code class="literal">LoaderManager</code>. These buttons are used here only to help us to explain the interaction and flow between the <code class="literal">LoaderManager</code> and the <code class="literal">Loader</code>s.</p><p>In this specific use case we are going to load the list of online users for the chat room developers.</p><p>Now let's take a look at the <code class="literal">LoaderCallback</code> functions and implement the interface on our <code class="literal">Activity</code>.</p><p>Starting with <code class="literal">onCreateLoader</code>, this <code class="literal">LoaderCallback</code> callback gets called only if the loader does not previously exist or when the loader is restarted by calling <code class="literal">LoaderManager.restartLoader()</code>.</p><p>When we initialize <code class="literal">WhosOnlineLoader</code> via the <code class="literal">LoaderManager</code> <code class="literal">initLoader</code> method, it will either return an <a id="id201" class="indexterm"/>existing Loader with the given ID (<code class="literal">LOADER_ID</code>) or, if it <a id="id202" class="indexterm"/>doesn't yet have a <code class="literal">Loader</code> with that ID, it will invoke the first of the <code class="literal">LoaderCallbacks</code> methods—<code class="literal">onCreateLoader</code>.</p><p>This means this method will not be called on for a configuration change because a previous loader with this ID is already available and initialized.</p><div class="informalexample"><pre class="programlisting">@Override
public Loader&lt;List&lt;String&gt;&gt; onCreateLoader(int id, Bundle args) {
  Loader res = null;
  switch (id) {
    case WHO_IS_ONLINE_LOADER_ID:
      res = new WhosOnlineLoader(this,
                                 args.getString("chatRoom"));
      break;
  }
  return res;
}</pre></div><p>This method creates the Loader instance calling the <code class="literal">WhosOnlineLoader</code> constructor and passing the chat group name that we are trying to load.</p><p>The next <code class="literal">LoaderCallback</code> function callback implemented is <code class="literal">onLoadFinished</code>; this callback gets called when the loader gets new results, when the data changes, or could be called when a configuration changes a <code class="literal">Loader</code> that already exists in the <code class="literal">LoaderManager</code>.</p><div class="informalexample"><pre class="programlisting">@Override
public void onLoadFinished(Loader&lt;List&lt;String&gt;&gt; loader,
                  List&lt;String&gt; users) {
     switch (loader.getId()) {
       case WHO_IS_ONLINE_LOADER_ID:
      ListView listView = (ListView) findViewById(R.id.list);
      ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,
        android.R.layout.simple_list_item_1,
        android.R.id.text1,
        users);
      listView.setAdapter(adapter);
      break;
    }
  }</pre></div><p>In our example, when the <code class="literal">onLoadFinished</code> gets called, we update the <code class="literal">ListView</code> adapter with the list of users received from the loader.</p><p>The <code class="literal">OnLoaderReset</code>, our last <code class="literal">LoaderCallback</code> function callback, gets called when the loader is destroyed, and in <a id="id203" class="indexterm"/>our example it simply cleans up the list view <a id="id204" class="indexterm"/>data in its adapter:</p><div class="informalexample"><pre class="programlisting">@Override
public void onLoaderReset(Loader&lt;List&lt;String&gt;&gt; loader) {
  ...
  ListView listView = (ListView)findViewById(R.id.list);
  listView.setAdapter(null);
}</pre></div><p>The loader reset is called when the <code class="literal">LoaderManager.destroyLoader(id)</code> is called or when the <code class="literal">Activity</code> gets destroyed. The Loader reset, as described earlier, will not destroy the loader but tell the Loader not to publish further updates. Hence, it can span multiple Activities.</p><p>The last piece of this cake is our custom Loader, the <code class="literal">WhosOnlineLoader</code>, used to retrieve the list of online users. Our <code class="literal">WhosOnlineLoader</code> is not going to load any asynchronous results, since a <code class="literal">Loader</code> subclass does not manage a background thread to load the results. Hence, this Loader should only be used for example purposes and to explain the <code class="literal">LoaderManager</code> and custom Loader interaction idiosyncrasies.</p><p>For debugging purposes, the methods <code class="literal">onStartLoading</code>, <code class="literal">onStopLoading</code>, <code class="literal">onReset</code>, and <code class="literal">onForceLoad</code> have a log message printed every time they enter on a function. The <code class="literal">deliverResult()</code>, the Loader function that delivers the result of the load to the registered listener, will also print a message to the Android Log with the users online.</p><div class="informalexample"><pre class="programlisting">public class WhosOnlineLoader extends Loader&lt;List&lt;String&gt;&gt; {

  private final String mChatRoom;
  private List&lt;String&gt; mResult = null;

  public WhosOnlineLoader(Context context, String chatRoom) {
    super(context);
    this.mChatRoom = chatRoom;
  }
  @Override
  protected void onStartLoading() {
    Log.i("WhoIsOnlineLoader", "onStarting WhoIsOnlineLoader["
          + Integer.toHexString(hashCode()) + "]");
    ...
    forceLoad();   
  }
  // Elided for brevity
  @Override
  public void deliverResult(List&lt;String&gt; data) {
    Log.i("WhoIsOnlineLoader", "DeliverResult WhoIsOnlineLoader["
          + Integer.toHexString(hashCode()) + "]");
    ...
    super.deliverResult(data);   
  }
  @Override
  protected void onReset() {
    Log.i("WhoIsOnlineLoader", "onReset WhoIsOnlineLoader["
          + Integer.toHexString(hashCode()) + "]");
    onStopLoading();
    ...
  }

}</pre></div><p>The <code class="literal">WhosOnlineLoader</code> code is partially omitted on purpose, although the <code class="literal">WhosOnlineLoader</code> <a id="id205" class="indexterm"/>source code is available to download from the <a id="id206" class="indexterm"/>Packt Publishing website.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>With everything in place, if we start the Activity, the user online list will be empty, although clicking on the <span class="strong"><strong>INIT</strong></span> button will result in a <code class="literal">LoaderManager.init</code> call.</p></div></div><p>Since we have some trace messages at the beginning of each <code class="literal">Loader</code> lifecycle, we can follow the loader callback calls:</p><div class="informalexample"><pre class="programlisting">I ... LoaderManager.init [1]
I ... LoaderCallbacks.onCreateLoader[1]
I ... Loader.new[ee07113]
I ... Loader.onStarting[ee07113]
I ... Loader.onForceload[ee07113]
I ... Loader.deliverResult[ee07113]
I ... LoaderCallbacks.onLoadFinished[1]</pre></div><p>As shown in the log output, a new <code class="literal">Loader</code> object instance with the <code class="literal">hashCode</code> <code class="literal">ee07113</code> is created when we invoke the <code class="literal">LoaderManager.init</code> function and the <code class="literal">onCreateLoader</code> gets called in the meantime. Afterwards, the loader is started and the results are loaded on the <code class="literal">onLoadFinished</code> callback, delivering the list of users.</p><p>Since the <code class="literal">Loader</code> with the <a id="id207" class="indexterm"/>ID now exists on the <code class="literal">LoaderManager</code>, lets <a id="id208" class="indexterm"/>check what happens when we click on the <span class="strong"><strong>restart</strong></span> button:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>I ... LoaderManager.restart [1]</strong></span>
<span class="strong"><strong>I ... LoaderCallbacks.onCreateLoader[1]</strong></span>
<span class="strong"><strong>I ... Loader.new[fb61f50]</strong></span>
<span class="strong"><strong>I ... Loader.onStarting[fb61f50]</strong></span>
<span class="strong"><strong>I ... Loader.onForceload[fb61f50]</strong></span>
<span class="strong"><strong>I ... Loader.deliverResult[fb61f50]</strong></span>
<span class="strong"><strong>I ... LoaderCallbacks.onLoadFinished[1]</strong></span>
<span class="strong"><strong>I ... Loader.onReset[ee07113]</strong></span>
<span class="strong"><strong>I ... Loader.onStopping[ee07113]</strong></span>
</pre></div><p>Since the <code class="literal">Loader ee07113</code> was created previously, it will be stopped and reset, and a new loader instance will be created and started like it did on the <code class="literal">init</code>.</p><p>Now we are going to click on the <span class="strong"><strong>DESTROY</strong></span> button and check the results:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>I ... LoaderManager.destroy [1]</strong></span>
<span class="strong"><strong>I ... LoaderCallbacks.onLoaderReset[1]</strong></span>
<span class="strong"><strong>I ... Loader.onAbandon[fb61f50]</strong></span>
<span class="strong"><strong>I ... Loader.onReset[fb61f50]</strong></span>
<span class="strong"><strong>I ... Loader.onStopping[fb61f50]</strong></span>
</pre></div><p>As expected, the <code class="literal">LoaderManager.destroy</code> gets called, and after that the <code class="literal">onAbandon</code>, <code class="literal">onReset</code>, and the <code class="literal">onStopping Loader</code> member methods were called to stop delivering results, release the loader resources, and to stop loading data. When the Loader is stopped we must cancel any loading but it can still monitor the data source for changes.</p><p>Another situation that is really important to explain is the configuration change. In this situation, the <code class="literal">LoaderManager</code> will continue to receive the results and keep them in a local cache. Once the new activity becomes visible, the cache results are delivered over the method <code class="literal">LoaderCallbacks.onLoadFinished</code>.</p><p>In a typical <code class="literal">Activity</code> transition where there is no configuration change involved, <code class="literal">LoaderManager</code> automatically resets the <code class="literal">Loader</code> resulting in calls to the loader stop and reset functions.</p><p>Given that now we <a id="id209" class="indexterm"/>understand how to use the <code class="literal">LoaderManager</code> to manage <a id="id210" class="indexterm"/>the loaders in activities, now we can focus our attention on how to use the subclasses <code class="literal">AsyncTaskLoader</code> and <code class="literal">LoaderCursor</code> to create asynchronous Loaders.</p></div>
<div class="section" title="Building responsive apps with AsyncTaskLoader"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Building responsive apps with AsyncTaskLoader</h1></div></div></div><p>
<code class="literal">AsyncTaskLoader</code> <a id="id211" class="indexterm"/>is a Loader implementation that uses <code class="literal">AsyncTasks</code> to perform its background work, though this is largely <a id="id212" class="indexterm"/>hidden from us when we implement our own subclasses.</p><p>We don't need to trouble ourselves with the <code class="literal">AsyncTasks</code>—they are completely hidden by <code class="literal">AsyncTaskLoader</code>—but with what we learned earlier about <code class="literal">AsyncTask</code>, it is interesting to note that tasks are, by default, executed using <code class="literal">AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</code> to ensure a high degree of concurrency when multiple Loaders are in use.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The <code class="literal">AsyncTaskLoader</code> in the compatibility package (<code class="literal">android.support.v4.content</code>) does not rely on the public <code class="literal">AsyncTask</code> in the platform. Instead, the compatibility package uses an internal <code class="literal">ModernAsyncTask</code> implementation to avoid Android fragmentation. The <code class="literal">ModernAsyncTask</code> creates threads with the name <code class="literal">ModernAsyncTask #&lt;N&gt;</code>.</p></div></div><p>In the next section we will use <code class="literal">AsyncTaskLoader</code> to load in the background, a currency to Bitcoin exchange rate, and display an updated exchange rate in our <code class="literal">BitcoinExchangeRateActivity</code> making use of the <code class="literal">LoaderManager</code>.</p><p>The exchange rate will be refreshed continuously using the <code class="literal">onContentChanged()</code> Loader method, used in this case to force a new exchange rate update in background.</p><p>Loader is generically typed so when we implement it, we need to specify the type of object that it will load—in our case <code class="literal">Double</code>:</p><div class="informalexample"><pre class="programlisting">public class BitcoinExchangeRateLoader extends
  AsyncTaskLoader&lt;Double&gt; {
  // ...
}</pre></div><p>The Loader abstract class requires a Context passed to its constructor, so we must pass a Context <a id="id213" class="indexterm"/>up the chain. We'll also need to <a id="id214" class="indexterm"/>know which currency exchange rate to retrieve, and the refresh time interval, so we'll also pass a string to identify the currency and an integer for the interval (milliseconds):</p><div class="informalexample"><pre class="programlisting">private Double       mExchangeRate = null;
private final long   mRefreshinterval;
private final String mCurrency;

BitcoinExchangeRateLoader(Context ctx,
                          String currency,
                          int refreshinterval) {
  super(ctx);
  this.mRefreshinterval = refreshinterval;
  this.mCurrency = currency;
}</pre></div><p>We don't need to keep our own reference to the <code class="literal">Context</code> object—<code class="literal">Loader</code> exposes a <code class="literal">getContext()</code> method which we can call from anywhere in our class where we might need a Context.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>We can safely pass a reference to an Activity instance as the Context parameter, but we should not expect <code class="literal">getContext()</code> to return the same object! Loaders potentially live much longer than a single Activity, so the Loader superclass only keeps a reference to the application Context, a context tied to an application, to prevent memory leaks.</p></div></div><p>There are several methods we will need to override which we'll work through one at a time. The most important is <code class="literal">loadInBackground</code>—the workhorse of our <code class="literal">AsyncTaskLoader</code>, and the only method which does not run on the main thread:</p><div class="informalexample"><pre class="programlisting">@Override
public Double loadInBackground() {
  //...
}</pre></div><p>The <code class="literal">AsyncTaskLoader</code> is a Loader subclass based on <code class="literal">AsyncTask</code>. Under the hood, it calls the <code class="literal">loadInBackground</code> function in an AsyncTask's background thread.</p><p>We're going to fetch the real-time bitcoin exchange rate from Internet, more precisely from the <a id="id215" class="indexterm"/>blockchain.info website, to delays to <a id="id216" class="indexterm"/>establish the connection, to transmit the data between the device and the remote endpoint and to some latency exposed by the access network. Since the delays can range from milliseconds to seconds, this task is a good candidate to perform off the main thread.</p><p>The following diagram displays the <code class="literal">Loader</code> lifecycle, showing callbacks invoked by <code class="literal">LoaderManager</code> and a typical <code class="literal">AsyncTaskLoader</code> implementation:</p><div class="mediaobject"><img src="graphics/Image_B05062_04_02.jpg" alt="Building responsive apps with AsyncTaskLoader"/></div><p>Given that loading the exchange rate from the network entails some delay due to blocking I/O reading from the network, and it is also possible that the remote website does not yet have enough resources to send the response back, we, as conscious developers who don't want to generate annoying Android ANRs, have to transfer these kinds of operations to the <code class="literal">AsyncTaskLoader.loadInBackground</code> method that is executed by the background thread in the system.</p><p>After we <a id="id217" class="indexterm"/>receive the response with the <a id="id218" class="indexterm"/>exchange rate, we need to decode the JSON response that comes in the HTTP response so this is also an operation we definitely want to perform off the main thread!</p><div class="informalexample"><pre class="programlisting">public Double loadInBackground() {
  Double result = null;
  StringBuilder builder = new StringBuilder();
  URL url = new URL("https://blockchain.info/ticker");
 
  // Create a Connection to the remote Website
  HttpURLConnection conn = (HttpURLConnection)
                           url.openConnection();
  ...
  conn.setRequestMethod("GET");
  conn.setDoInput(true); 
  conn.connect();
  // ! Read the response with the exchange rate to a String
  ...   // Decode the Response Received by Blockchain Website
  JSONObject obj = new JSONObject(builder.toString());
  result = obj.getJSONObject(mCurrency)
                      .getDouble("last");
  return result;
}</pre></div><p>In the preceding code, we execute the blocking operations suggested previously and as a result we return the exchange rate for the currency specified in the <code class="literal">Loader</code> construct.</p><p>We'll want to <a id="id219" class="indexterm"/>cache a reference to the Double object that we're delivering, so that any future calls can just return the same Double immediately. We'll do this by overriding <code class="literal">deliverResult</code> invoked on the main thread:</p><div class="informalexample"><pre class="programlisting">@Override
public void deliverResult(Double result) {
  this.mExchangeRate = result;
  super.deliverResult(result);
}</pre></div><p>To make our <code class="literal">Loader</code> actually work, we still need to override a handful of lifecycle methods that are defined by the <code class="literal">Loader</code> base class. First and foremost is <code class="literal">onStartLoading</code>:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onStartLoading() {

  if (mExchangeRate != null) {
    // If we currently have a result available, deliver it
    // immediately.
    deliverResult(mExchangeRate);
  }
  if (takeContentChanged() || mExchangeRate == null) {
    // If the exchange rate has changed since the last time
    // it was  loaded or is not currently available, start a load.
    forceLoad();
  }
}</pre></div><p>Here, we <a id="id220" class="indexterm"/>check our cache (<code class="literal">mExchangeRate</code>) to see if we have a previously loaded result that we can deliver immediately via <a id="id221" class="indexterm"/><code class="literal">deliverResult</code>. If the content data has changed recently, <code class="literal">contentChanged</code> flag is true, and we don't have a cached result, we force a background load to occur—we must do this otherwise our Loader won't ever load anything. As described before this callback runs on the main thread and the load will fire off a new load throughout <code class="literal">loadInBackground()</code> on the background thread.</p><p>We now have a minimal working <code class="literal">Loader</code> implementation, but there is some housekeeping required if we want our <code class="literal">Loader</code> to play well with the framework.</p><p>First of all, we need to make sure that we clean up the exchange rate when our <code class="literal">Loader</code> is discarded. Loader provides a callback intended for that exact purpose—<code class="literal">onReset</code>.</p><div class="informalexample"><pre class="programlisting">@Override
protected void onReset() {
  // Ensure the loader is stopped
  onStopLoading();
  mExchangeRate = null; 
}</pre></div><p>The framework will ensure that <code class="literal">onReset</code> is called when <code class="literal">Loader</code> is being discarded, which will happen when the app exits or when the <code class="literal">Loader</code> instance is explicitly discarded via <code class="literal">LoaderManager</code>.</p><p>There are two more lifecycle methods, which are important to implement correctly if we want our app to be as responsive as possible: <code class="literal">onStopLoading</code> and <code class="literal">onCanceled</code> (be careful of the spelling of <code class="literal">onCanceled</code> here versus <code class="literal">onCancelled</code> in most places).</p><p>The framework will tell us when it doesn't want us to waste cycles loading data by invoking the <a id="id222" class="indexterm"/><code class="literal">onStopLoading</code> callback. It may still need the data we have already loaded though, and it may tell us to start loading again, so we should not clean up resources yet. In <code class="literal">AsyncTaskLoader</code> we'll want to cancel the background work if possible, so we'll just call the superclass <code class="literal">cancelLoad</code> method:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onStopLoading() {
  // Attempt to cancel the current load task.
  cancelLoad();
}</pre></div><p>When the <code class="literal">Loader</code> is cancelled we don't stop the current rate loading; in spite of this, in other kinds of <a id="id223" class="indexterm"/>use cases, we might have a cancelling behavior on the <code class="literal">loadInBackground()</code> to stop the current loading by checking the <code class="literal">isAbandoned()</code> member function.</p><p>Finally, we need to implement <code class="literal">onCancelled</code> to clean up any data that might be loaded in the background after a cancellation has been issued:</p><div class="informalexample"><pre class="programlisting">@Override
public void onCanceled(Double data) {
   // For our data there is nothing to release, at this method
   // we should release the resources associated with 'data'.
}</pre></div><p>Depending on the kind of data Loader produces, we may not need to worry about cleaning up the result of canceled work—ordinary Java objects will be cleaned up by the garbage collector when they are no longer referenced.</p><p>So far, we have implemented the asynchronous exchange rate loading, now we have to implement the refresh feature to continuously fetch the value from the blockchain.info website. To load a new value for the current exchange rate we shall coerce the loader to run the <code class="literal">loadInBackground</code> again and retrieve the current value for the exchange rate.  The <code class="literal">Loader</code> abstract class offers us the method <code class="literal">onContentChanged()</code>, that will force a new load if the <code class="literal">Loader</code> is at the started state.</p><p>In our example, once the loader is started with <code class="literal">startLoading()</code>, we must continuously call <a id="id224" class="indexterm"/><code class="literal">onContentChanged</code> to mimic a value change and force a new load. We will achieve this by using a handler and by posting a <code class="literal">Runnable</code> that simply calls the <code class="literal">onContentChange</code> on our <code class="literal">Loader</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we are going to create the <code class="literal">Runnable</code> and create the handler in our loader:<div class="informalexample"><pre class="programlisting">public class BitcoinExchangeRateLoader extends
             AsyncTaskLoader&lt;Double&gt; { 
 
  private Handler mHandler;
 
 // Use to force a exchange rate value change
  private final Runnable refreshRunnable = new Runnable() {
    @Override
    public void run() { onContentChanged(); }
  };
 
  BitcoinExchangeRateLoader(Context ctx,
                            String currency,
                            int refreshinterval) {
    ...
    this.mHandler = new Handler();   
  }
}</pre></div></li><li class="listitem">Second, we need to submit a delayed task to force the next reload, each time the <code class="literal">forceLoad()</code> is called. When the <code class="literal">Loader</code> is reset we don't submit the next reload:<div class="informalexample"><pre class="programlisting">@Override
protected void onForceLoad() {
  mHandler.removeCallbacks(refreshRunnable);

  if (!isReset())
    mHandler.postDelayed(refreshRunnable, mRefreshinterval);
}</pre></div></li><li class="listitem">Third, to <a id="id225" class="indexterm"/>force a new reload when the <a id="id226" class="indexterm"/>loader is cancelled and the task is restarted afterwards, <code class="literal">onCanceled()</code> sets the <code class="literal">ContentChange</code> flag on by calling <code class="literal">onContentChanged()</code>:<div class="informalexample"><pre class="programlisting">  @Override
    public void onCanceled(Double data) {
       ...
       onContentChanged();
    }</pre></div></li><li class="listitem">To finish, we must cancel the next reload if the loader is stopped or cancelled:<div class="informalexample"><pre class="programlisting">@Override
protected void onReset() {
  ...
  mHandler.removeCallbacks(refreshRunnable);
}</pre></div></li></ol></div><p>So far so good—we have a <code class="literal">Loader</code>. Now we need to connect it to a client Activity or Fragment. Since in our previous example we attached our Loader to an Activity, this time we are going to use a different <code class="literal">LoaderManager</code> client and connect the loader to a Fragment object.</p><p>Our <code class="literal">Fragment</code>, loaded by <code class="literal">BitcoinExchangeRateActivity</code>, is going to initialize our Loader and display the loader result on the fragment UI. Let's get these easy bits out of the way first:</p><div class="informalexample"><pre class="programlisting">public class <a id="id227" class="indexterm"/>BitcoinExchangeRateFragment extends Fragment 
implements LoaderManager.LoaderCallbacks&lt;Double&gt; {


  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    LoaderManager lm = getActivity().getSupportLoaderManager();
    Bundle bundle = new Bundle();
    bundle.putString(CURRENNCY_KEY, "EUR");
    bundle.putInt(REFRESH_INTERNAL, 5000);
    lm.initLoader(BITCOIN_EXRATE_LOADER_ID, bundle,
                   BitcoinExchangeRateFragment.this);
  }
  ...
}</pre></div><p>In the preceding code, we mainly load the UI layout used to present the exchange rate on the screen and we implement our loader initialization on the <code class="literal">onActivityCreated</code> member function. The <code class="literal">onActivityCreated</code> member class callback is either called when the activity has been created or when the <code class="literal">Activity</code> is recreated, after a configuration change.</p><p>As we <a id="id228" class="indexterm"/>explained in previous sections, we call the <code class="literal">initLoader</code> passing an <code class="literal">int</code> identifier as the first argument, a Bundle of values—the second parameter—to configure the currency exchange rate that we want present on the screen, and a refresh rate interval between <code class="literal">onContextChange</code> calls. The third <a id="id229" class="indexterm"/>parameter is an object that implements <code class="literal">LoaderCallbacks</code>, which, in this case, is our <code class="literal">BitcoinExchangeRateFragment</code> instance, where we implement the loader callbacks directly on the fragment.</p><p>The <code class="literal">onCreateLoader</code> callback method that we implement on our Fragment is similar to the method that we create on the previous <code class="literal">WhoIsOnlineActivity</code> Loader, so it basically creates a new <code class="literal">BitcoinExchangeRateLoader</code> instance using the arguments passed on to the <code class="literal">Bundle</code> object.</p><div class="informalexample"><pre class="programlisting">public Loader&lt;Double&gt; onCreateLoader(int id, Bundle args) {
  Loader res = null;
  switch (id) {
  case BITCOIN_EXRATE_LOADER_ID:
    res = new BitcoinExchangeRateLoader(getActivity(),
          args.getString(CURRENNCY_KEY),
          args.getInt(REFRESH_INTERNAL));
    break;
  }
  return res;
}</pre></div><p>The implementation of <code class="literal">onLoadFdinished</code> must take the loaded exchange rate and display it in the <code class="literal">TextView</code>:</p><div class="informalexample"><pre class="programlisting">@Override
public void onLoadFinished(Loader&lt;Double&gt; loader, Double data) {
  switch (loader.getId()) {
  case BITCOIN_EXRATE_LOADER_ID:
    TextView tv  = (TextView) getView().
                   findViewById(R.id.temperature);
    tv.setText(data.toString());
    break;
  }
}</pre></div><p>For brevity, we <a id="id230" class="indexterm"/>omitted the <code class="literal">LoaderCallbacks.onLoaderReset</code> since the method body is empty. This method should be used to release any resources used that are directly bound to the Loader lifecycle.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>The full source code, with the Activity and <code class="literal">android.xml</code> layout is available on the Packt Publishing website.</p></div></div><p>When compared with <code class="literal">AsyncTask</code>, things here are more complicated—we've had to write more code and deal with more classes, but the payoff is that the data is cached for use across <code class="literal">Activity</code> restarts and can be used from other Fragments or Activities.</p><p>In our <code class="literal">BitcoinExchangeRateLoader</code>, the successive exchange rate updates are controlled by our refresh rate internal; however, in other kinds of <code class="literal">AsyncTaskLoaders</code> the rate where a content change happens could result in lots of <code class="literal">onLoadFinished</code> invocations, and hence potentially dominate the UI thread execution with UI updates and degrade the UI responsiveness.</p><p>To overcome this issue, the <code class="literal">AsyncTaskLoader</code> supplies a member function, called <code class="literal">setUpdateThrottle</code>, to control the minimum internal between successive data deliveries and as a result adjusts the interval between consecutive <code class="literal">onLoadFinished</code> invocations:</p><div class="informalexample"><pre class="programlisting">public void setUpdateThrottle(long delayMS)</pre></div><p>This method must <a id="id231" class="indexterm"/>be called when you feel that your loader content change-rate might overload the UI and affect your application smoothness. If a higher update frequency is not required in your data, the developer can make use of this function to reduce the Loader content change deliver frequency.</p><p>In the next section we will get a detailed overview on the last Loader subclass type that comes out of box with Android SDK, the <code class="literal">CursorLoader</code>.</p></div>
<div class="section" title="Building responsive apps with CursorLoader"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Building responsive apps with CursorLoader</h1></div></div></div><p>
<code class="literal">CursorLoader</code> is <a id="id232" class="indexterm"/>a specialized subclass of <a id="id233" class="indexterm"/><code class="literal">AsyncTaskLoader</code> that uses its lifecycle methods to correctly manage the resources associated with a database <code class="literal">Cursor</code>.</p><p>A database <code class="literal">Cursor</code> is a little like an Iterator, in that it allows you to scroll through a dataset without having to worry where exactly the dataset is coming from or what data structure it is a part of.</p><p>We're going to use <code class="literal">CursorLoader</code> to query the Android device for a list of music albums available. Because <code class="literal">CursorLoader</code> is already implemented to correctly handle all of the details of working with a <code class="literal">Cursor</code>, we don't need to subclass it. We can simply instantiate it, passing in the information it needs in order to open the <code class="literal">Cursor</code> it should manage for us. We can do this in the <code class="literal">onCreateLoader</code> callback:</p><div class="informalexample"><pre class="programlisting">@Override
public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {
  String[] columns = new String[] {
    MediaStore.Audio.Albums._ID,
    MediaStore.Audio.Albums.ARTIST,
    MediaStore.Audio.Albums.ALBUM
  };
  return new CursorLoader(this, 
    MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
    columns, // projection
    null, // selection
    null, // selectionArgs
    null // sortOrder
  );
}</pre></div><p>Just as with the previous example, we'll implement the callbacks in our <code class="literal">Activity</code> subclass. We're going to use <code class="literal">GridView</code> to display our album list, so we'll implement an <code class="literal">Adapter</code> interface to supply views for its cells, and we'll connect the <code class="literal">Adapter</code> to the <code class="literal">Cursor</code> created by our <code class="literal">Loader</code>:</p><div class="informalexample"><pre class="programlisting">public class AlbumListActivitySimple extends FragmentActivity
  implements LoaderCallbacks&lt;Cursor&gt; {

  public static final int ALBUM_LIST_LOADER = "album_list".
                                                 hashCode();
  private SimpleCursorAdapter mAdapter;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.phone_list_layout);
    GridView grid = (GridView) findViewById(R.id.album_grid);
    mAdapter = new AlbumCursorAdapter(getApplicationContext());
    grid.setAdapter(mAdapter);
   
    // Prepare the loader. 
    // Either re-connect with an existing one, or start a new one.
    getSupportLoaderManager().
      initLoader(ALBUM_LIST_LOADER,
                 null,
                 AlbumListActivitySimple.this);
  }

  @Override
  public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) {
    // Swap the new cursor in.  (The framework will take
    //  care of closing the old cursor once we return.)
    mAdapter.changeCursor(data);
  }

  @Override
  public void onLoaderReset(Loader&lt;Cursor&gt; loader) {
    // This is called when the last Cursor provided to
    // onLoadFinished() above is about to be closed. 
    //  We need to make sure we are no longer using it.
    mAdapter.changeCursor(null);
  }
}</pre></div><p>Have a look at the <a id="id234" class="indexterm"/>parts in bold in the preceding code. We create an <code class="literal">AlbumCursorAdapter</code>, and pass it to the <code class="literal">GridView</code>, we then initialize our <code class="literal">CursorLoader</code>. When loading is completed, we pass the loaded Cursor to the Adapter, and we're done.</p><p>The remaining piece <a id="id235" class="indexterm"/>to implement is <code class="literal">AlbumCursorAdapter</code>, which is going to start out as a very simple class. The job of our <code class="literal">CursorAdapter</code> is simply to map rows of data from the <code class="literal">Cursor</code> to each <code class="literal">View</code> in the individual row <code class="literal">View</code>.</p><p>The Android SDK provides the very handy <code class="literal">SimpleCursorAdapter</code> class, which does just what we need; mapping a database data row into an Album Item View. So for now we'll just subclass it and instruct it via constructor parameters which layout the inflation for each cell and the <code class="literal">Cursor</code> fields to map to each <code class="literal">View</code> within that layout:</p><div class="informalexample"><pre class="programlisting">public static class <a id="id236" class="indexterm"/>AlbumCursorAdapter extends <a id="id237" class="indexterm"/>SimpleCursorAdapter {
  private static String[] FIELDS = new String[] {
    MediaStore.Audio.Albums.ARTIST,
    MediaStore.Audio.Albums.ALBUM
  };
  private static int[] VIEWS = new int[] {
    R.id.album_artist, R.id.album_name
  };

  public AlbumCursorAdapter(Context context) {
    super(context, R.layout.album_item,
          null, FIELDS, VIEWS, 0);
  }
}</pre></div><p>The layout files and source code are available on the accompanying website. When you run this <code class="literal">Activity</code>, you'll see a grid list where each cell contains album artwork, the album artist, and the album name for each album.</p><p>Scroll to somewhere in the middle of the list and rotate your device, and you'll notice that the Activity restarts and redisplays the grid immediately, without losing its place—this is because the <code class="literal">CursorLoader</code> survived the restart, and still holds the <code class="literal">Cursor</code> object with the same rows loaded.</p><p>This is technically all very interesting, but it isn't much to look at. In the next section we'll combine our two <code class="literal">Loaders</code> to implement a scrollable grid displaying the album art for each album.</p></div>
<div class="section" title="Combining Loaders"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Combining Loaders</h1></div></div></div><p>In the preceding <a id="id238" class="indexterm"/>sections we developed a <code class="literal">CursorLoader</code> that loads a list of all available music albums on the system and an <code class="literal">AsynTaskLoader</code> that does a blocking IO operation in the background. Now we are going to use our previous <code class="literal">CursorLoader</code> together with <code class="literal">AsyncTaskLoader</code> which loads a thumbnail from the album ID to create an application that tiles the artwork of all the music albums on the device in a scrollable grid, performing all loading in the background.</p><p>Thanks to our <code class="literal">CursorLoader</code>, we already have access to the IDs of the albums we need to load—we're <a id="id239" class="indexterm"/>displaying only the album name and album artist—so we just need to pass those IDs to our <code class="literal">AlbumArtworkLoader</code> for it to asynchronously load the image for us.</p><p>Our <code class="literal">AlbumArtworkLoader </code>could receive the album ID either on the constructor or later, to load an image for a particular <code class="literal">albumId</code>:</p><div class="informalexample"><pre class="programlisting">public class AlbumArtworkLoader extends AsyncTaskLoader&lt;Bitmap&gt; {

  private int mAlbumId = -1; // The album Identifier
  Bitmap mData = null;

  public AlbumArtworkLoader(Context context, int albumId) {
    super(context);
    this.mAlbumId = albumId;
  }</pre></div><p>We'll enable <code class="literal">AlbumArtworkLoader</code> to load a new image instead of its current one, by setting a new <code class="literal">albumId</code>. Since the bitmap is cached (<code class="literal">mData</code>), just setting a new ID won't suffice—we also need to trigger a reload by using the <code class="literal">Loader.onContentChanged</code>:</p><div class="informalexample"><pre class="programlisting">  public void setAlbumId(int newAlbumId) {

    if (  isDifferentMedia(newAlbumId) || mData == null ) {

      // Album Id change will force the artwork reload
      this.mAlbumId = newAlbumId;
      onContentChanged();     

    } else if (!isDifferentMedia(newAlbumId) ) {
      // we already have the Bitmap for this album
      deliverResult(mData);
    }
  }</pre></div><p>The <code class="literal">onContentChanged, </code>as explained before, is a method of the abstract <code class="literal">Loader</code> superclass which will force a background load to occur if our <code class="literal">Loader</code> is currently in the started state. If we're currently stopped, a flag will be set and a background load will be triggered next time the <code class="literal">Loader</code> is started. Either way, when the background load completes, <code class="literal">onLoadFinished</code> will be triggered with the new data.</p><p>We need to implement the <code class="literal">onStartLoading</code> method to correctly handle the case where we were <code class="literal">stopped</code> <a id="id240" class="indexterm"/>when <code class="literal">onContentChanged</code> was invoked. Let's remind ourselves of what it used to look like:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onStartLoading() {
 
  if (mData != null) {
    deliverResult(mData);
  }
  if (takeContentChanged() || mData == null) {
    forceLoad();
  }
}</pre></div><p>The <code class="literal">onStartLoading</code> method again delivers its data immediately—if it has any.</p><p>It then calls <code class="literal">takeContentChanged</code> to see if we need to discard our cached <code class="literal">Bitmap</code> and load a new one. If <code class="literal">takeContentChanged</code> returns true, we invoke <code class="literal">forceLoad</code> to trigger a background load and redelivery.</p><p>Now we can cause our <code class="literal">AlbumArtworkLoader</code> to load and cache a different image, but a single <code class="literal">AlbumArtworkLoader</code> can only load and cache one image at a time, so we're going to need more than one active instance.</p><p>Let's walk through the process of modifying <code class="literal">AlbumCursorAdapter</code> to initialize a <code class="literal">AlbumCursorAdapter</code> for each cell in the <code class="literal">GridView</code>, and to use those <code class="literal">Loader</code>s to asynchronously load the album artwork and display them:</p><div class="informalexample"><pre class="programlisting">public class AlbumCursorAdapter extends CursorAdapter {

    Context ctx;
    private LayoutInflater inf;
    private LoaderManager mgr;
    private List&lt;Integer&gt; ids;
    private int count;

    public AlbumCursorAdapter(Context ctx, LoaderManager mgr) {
        super(ctx.getApplicationContext(), null, true);
        this.ctx = ctx;
        this.mgr = mgr;
        inf = (LayoutInflater) ctx.
                getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        ids = new ArrayList&lt;Integer&gt;();
    }

    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
      ..
    }

    @Override
    public void bindView(View view, Context context, Cursor cursor) {
      ...
    }</pre></div><p>We have two methods to implement—<code class="literal">newView</code> and <code class="literal">bindView. GridView</code> will invoke <code class="literal">newView</code> until it has <a id="id241" class="indexterm"/>enough View objects to fill all of its visible cells, and from then on it will recycle these same View objects by passing them to <code class="literal">bindView</code> to be repopulated with data for a different cell as the grid scrolls. As a view scrolls out of sight, it becomes available for rebinding.</p><p>What this means for us is that we have a convenient method in which to initialize our <code class="literal">AlbumArtworkLoaders</code>—<code class="literal">newView</code>, and another convenient method in which to retask Loader to load a new thumbnail—<code class="literal">bindView</code>.</p><p>
<code class="literal">newView</code> first inflates the album item layout for the row and gives to the parent view, a unique ID based on the ID generated by the adapter class <code class="literal">hashcode()</code> method and based on the current number of Loaders.</p><p>Later, the unique ID and the <code class="literal">imageView</code> is passed to a <code class="literal">ArtworkLoaderCallbacks</code> class, which we'll meet in a moment. <code class="literal">ArtworkLoaderCallbacks</code> is in turn used to initialize a new <code class="literal">Loader</code>, which shares the ID of the parent View. In this way we are initializing a new Loader for each visible row in the grid:</p><div class="informalexample"><pre class="programlisting">@Override
public View newView(Context context, Cursor cursor,
                    ViewGroup parent) {

  View view = (View) inf.inflate(R.layout.album_item,
                                 parent, false);
  ImageView imageView = (ImageView) view.
                                    findViewById(R.id.album_art);
        ...
  int viewId = AlbumCursorAdapter.class.hashCode() + count++;
  view.setId(viewId);
  mgr.initLoader(viewId, null,
                 new ArtworkLoaderCallbacks(ctx, imageView));
  ids.add(viewId);
  return view;
}</pre></div><p>In <code class="literal">bindView</code>, we are recycling each existing <code class="literal">View</code> to update the image, album name, and album artist that are being displayed by that <code class="literal">View</code>. So the first thing we do is clear out the old <code class="literal">Bitmap</code>.</p><p>Next we look up the <a id="id242" class="indexterm"/>correct <code class="literal">Loader</code> by ID, extract the ID of the next image to load from the <code class="literal">Cursor</code>, and load it by passing the ID to the method of <code class="literal">AlbumArtworkLoader</code>—<code class="literal">setAlbumId</code>:</p><div class="informalexample"><pre class="programlisting">@Override
public void bindView(View view, Context context, Cursor cursor) {
  ImageView imageView = (ImageView) view.
                           findViewById(R.id.album_art);
  imageView.setImageBitmap(null);
 
  Loader&lt;?&gt; loader = mgr.getLoader(view.getId());
  AlbumArtworkLoader artworkLoader = (AlbumArtworkLoader) loader;
  int albumId = cursor.getInt(
     cursor.getColumnIndex(MediaStore.Audio.Albums._ID));
  ...
  // Sets the album id bound to this imageView,
  // this could force the loader to retrieve a new image
  artworkLoader.setAlbumId(albumId);
 
}</pre></div><p>We need to add one more method to our <code class="literal">Adapter</code> so that we can clean up <code class="literal">AlbumArtworkLoaders</code> when we no longer need them. We'll call these ourselves when we no longer need these <code class="literal">Loaders</code>—for example, when our <code class="literal">Activity</code> is finishing:</p><div class="informalexample"><pre class="programlisting"> public void destroyLoaders() {
   for (Integer id : ids) {
     mgr.destroyLoader(id);
   }
 }</pre></div><p>That's our completed <a id="id243" class="indexterm"/><code class="literal">Adapter</code>. Next, let's look at <code class="literal">ArtworkLoaderCallbacks</code> which, as you probably guessed, is just an implementation of <code class="literal">LoaderCallbacks</code>:</p><div class="informalexample"><pre class="programlisting">public static class ArtworkLoaderCallbacks implements
  LoaderManager.LoaderCallbacks&lt;Bitmap&gt; {

  private Context context;
  private ImageView image;

  public ArtworkLoaderCallbacks(Context context,
                                ImageView image) {
    this.context = context.getApplicationContext();
    this.image = image;
  }

  @Override
  public Loader&lt;Bitmap&gt; onCreateLoader(int i, Bundle bundle) {
    return new AlbumArtworkLoader(context);
  }

  @Override
  public void onLoadFinished(Loader&lt;Bitmap&gt; loader, Bitmap b) {
    image.setImageBitmap(b);
  }

  @Override
  public void onLoaderReset(Loader&lt;Bitmap&gt; loader) {}
}</pre></div><p>The only interesting thing <code class="literal">ArtworkLoaderCallbacks</code> does is create an instance of <code class="literal">AlbumArtworkLoader</code>, and set a loaded Bitmap to its <code class="literal">ImageView</code>.</p><p>Our <code class="literal">Activity</code> is almost unchanged—we need to pass an extra parameter when instantiating <code class="literal">AlbumCursorAdapter</code> and, to avoid leaking the Loaders it creates, we need to invoke the <code class="literal">destroyLoaders</code> method of <code class="literal">AlbumCursorAdapter</code> in <code class="literal">onPause</code> or <code class="literal">onStop</code>, if the Activity is finishing:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onStop() {
  super.onStop();
  if (isFinishing()) {
    // Destroy the main album list Loader
    getSupportLoaderManager().destroyLoader(ALBUM_LIST_LOADER);
    // Destroy album artwork loaders
    mAdapter.destroyLoaders();
  }
}</pre></div><p>The full source code is available from the Packt Publishing website. Take a look at the complete source code to <a id="id244" class="indexterm"/>appreciate how little there actually is, and run it on a device to get a feel for just how much functionality <code class="literal">Loaders</code> give you for relatively little effort!</p></div>
<div class="section" title="Applications of Loader"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Applications of Loader</h1></div></div></div><p>The obvious applications include reading any kind of data from files or databases local to the device, or Android <a id="id245" class="indexterm"/>content providers, as we've done in the examples in this chapter.</p><p>One strong advantage of <code class="literal">Loaders</code> over direct use of <code class="literal">AsyncTask</code> is that their lifecycle is very flexible with respect to the <code class="literal">Activity</code> and <code class="literal">Fragment</code> lifecycles. Without any extra effort we can handle configuration changes such as an orientation change.</p><p>We can even start loading in one <code class="literal">Activity</code>, navigate through the app, and collect the result in a completely separate <code class="literal">Activity</code>, if that makes sense for our app.</p><p>In some ways, this decoupling from the Activity lifecycle makes <code class="literal">Loader</code> a better candidate than <code class="literal">AsyncTask</code> to perform network transfers such as HTTP downloads; however, they require more code and still aren't a perfect fit.</p><p>The framework is very powerful for managing asynchronous data loading; however, it does not provide a mechanism to show the loading progress, as we have on the <code class="literal">AsyncTask </code>framework and there is no error handling callback function to manage loading errors or exceptions.</p><p>To overcome these issues, the developer must extend the basic Loader framework classes and implement these <a id="id246" class="indexterm"/>patterns to match his needs.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>The <code class="literal">Loader</code> framework in Android does a wonderful job of making it easy to load data in the background and deliver it to the main thread when it is ready.</p><p>In this chapter we learned about the essential characteristics of all Loaders—background loading, caching of loaded data, and a managed lifecycle.</p><p>We took a detailed look at <code class="literal">AsyncTaskLoader</code> as a means to perform arbitrary background loading, and <code class="literal">CursorLoader</code> for asynchronous loading from local database Cursors.</p><p>We saw that <code class="literal">Loader</code> can free us from some of the constraints imposed by the <code class="literal">Activity</code> lifecycle, and took advantage of that to continue to work in the background even across <code class="literal">Activity</code> restarts.</p><p>In the next chapter we'll free ourselves completely from the constraints of the <code class="literal">Activity</code> lifecycle and perform background operations with <code class="literal">Service</code>, even when our app is no longer in the foreground.</p></div></body></html>