<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Structural Patterns – Composite and Flyweight</h1></div></div></div><p>We have already seen three structural patterns: the decorator, proxy, and bridge patterns that provide us with ways of adding state and behavior dynamically, controlling the creation and access of objects, and keeping specifications and implementations separate. This chapter will now focus on the composite and flyweight patterns that are designed to facilitate the manipulation of a group of objects or large number of small objects. The composite is often used and we can also make use of the flyweight pattern.</p><p>The flyweight pattern efficiently shares the common information present in small objects by helping you reduce the memory consumption or storage requirements when many values are duplicated.</p><p>In this chapter, we will discuss the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The composite pattern</li><li class="listitem" style="list-style-type: disc">The flyweight pattern</li></ul></div><p>The objectives of these two new structural patterns are described in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pattern</p>
</th><th style="text-align: left" valign="bottom">
<p>Objective</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>The composite pattern</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id137"/>pattern <a class="indexterm" id="id138"/>allows you to compose objects into tree structures and treat the group of objects as an instance of an object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The flyweight pattern</p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id139"/> pattern<a class="indexterm" id="id140"/> allows you to manage huge number of objects by instantiating them on the fly to improve the performance efficiently. </p>
</td></tr></tbody></table></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>The composite pattern</h1></div></div></div><p>This <a class="indexterm" id="id141"/>pattern is very often used to manipulate <a class="indexterm" id="id142"/>a group of objects. Swift, like many other languages already makes use of the composite pattern in its internal structure. For example, in the case of the <code class="literal">UIView</code> class available in the <code class="literal">cocoa</code> framework, which defines a common behavior of an app layout. Then, individuals view objects in the view hierarchy can be leaf nodes (such as labels) or composites that have collections of other views (such as table view controllers).</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>Roles</h2></div></div></div><p>This pattern <a class="indexterm" id="id143"/>permits you to treat single components and a group of components in the same way by providing a structured hierarchy of objects. It allows you to build structures of objects in the form of trees that contain both compositions of objects and individual objects as nodes.</p><p>Using this pattern, we can create complex trees and treat them as a whole or as parts. Operations can be applied to the whole or the parts too.</p><p>We generally find the <code class="literal">add</code>, <code class="literal">remove</code>, <code class="literal">display</code>, <code class="literal">find</code>, and <code class="literal">group</code> operations in the <code class="literal">Composite</code> class.</p><p>This pattern can be used when:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is necessary to have a composition hierarchy in a system</li><li class="listitem" style="list-style-type: disc">Clients need to be ignored if they are working with composites objects</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id144"/> generic UML class diagram is represented in the following figure:</p><div><img alt="Design" src="img/4852_03_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>Participants</h2></div></div></div><p>The participants<a class="indexterm" id="id145"/> of this pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Component</code>: This is an <a class="indexterm" id="id146"/>abstract class that introduces an object's interface of the composition, implements common methods, and defines the method signature that manages the addition or deletion of components.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Leaf</code>: This <a class="indexterm" id="id147"/>is a concrete class that defines the behavior of the elements in the composition. It implements the operations that the <code class="literal">Composite</code> class supports. A <code class="literal">Leaf</code> class does not have its own components.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Composite</code>: This<a class="indexterm" id="id148"/> is a concrete class that defines the behavior of the components that have children and store the child components. It implements the <code class="literal">Leaf</code> class-related operations. This class has an aggregation of the <code class="literal">Component</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Client</code>: This <a class="indexterm" id="id149"/>class uses the component's interface to manipulate the objects in the composition.</li></ul></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>
<code class="literal">Composite</code> contains components. Components can be <code class="literal">Leaf</code> or <code class="literal">Composite</code>. It is indeed recursive. A composite holds a set of children; these children may be other composites or leaf elements.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec68"/>Collaboration</h2></div></div></div><p>A <a class="indexterm" id="id150"/>client sends a request to the leaf throughout the <code class="literal">Component</code> interface.</p><p>When a component receives a request, it reacts depending on its class. If the component is a leaf, then it will treat the request itself.</p><p>If the component is a composite, it will first treat on itself, then it will send a message to each of its child, which in turn will execute a treatment too. Then, when every child completes their treatment, the composite will execute the last treatment.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec69"/>Illustration</h2></div></div></div><p>Our company <a class="indexterm" id="id151"/>has an online catalog of <a class="indexterm" id="id152"/>
<strong>Video on demand</strong> (<strong>VOD</strong>). All our movies are categorized by genre. As this is a pay-per-view system, each of our videos will have a price, name, and small description.</p><p>Now, we want to easily manipulate the display of our full catalog using this new pattern. The following schema represents the organization of our catalog:</p><div><img alt="Illustration" src="img/4852_03_02.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec70"/>Implementation</h2></div></div></div><p>So, it's<a class="indexterm" id="id153"/> time for us to apply the generic design of the composite pattern to our case. First, we will redesign our pattern according to our scenario in order to understand what we need to do, as shown in the following diagram:</p><p> </p><div><img alt="Implementation" src="img/4852_03_03.jpg"/></div><p>
</p><p>The <code class="literal">VODManager</code> class will use the <code class="literal">VODComponent</code> interface to access the VOD categories and VOD items. The <code class="literal">VODComponent</code> class is our abstract class that will provide the default implementation of the defined methods. The <code class="literal">VODItem</code> class will only override the methods that make sense. The <code class="literal">VODCategory</code> class will also override methods that make sense, including a way to add the new <code class="literal">VODItem</code> and <code class="literal">VODCategory</code> objects. After reorganizing<a class="indexterm" id="id154"/> our pattern, we are now ready to implement our solution.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec01"/>Implementation of the VODComponent</h3></div></div></div><p>First, we <a class="indexterm" id="id155"/>create our abstract class, which both <code class="literal">VODItem</code> and <code class="literal">VODCategory</code> will inherit form. This class will provide the interface for the leaf nodes and composite nodes. Swift doesn't support an abstract class; nevertheless, nothing should prevent us from implementing the default behavior onto our methods, such as informing that a method is not supported using an <strong>assert</strong>. An assert <a class="indexterm" id="id156"/>will just inform us that if it is used in an inappropriate class, then the method will not be supported. We could write our "fake" abstract class like this:</p><div><pre class="programlisting">// Abstract Class

class VODComponent {
  
  func add(vodComponent: VODComponent) {
    assert(false, "This method is not supported")
  }
  
  func remove(vodComponent: VODComponent) {
    assert(false, "This method is not supported")
  }
  
  func getName() -&gt; String {
    assert(false, "This method is not supported")
  }
  
  func getDescription() -&gt; String {
    assert(false, "This method is not supported")
  }
  
  func getPrice() -&gt; Double {
    assert(false, "This method is not supported")
  }
  
  func getChild(i:Int) -&gt; VODComponent {
    assert(false, "This method is not supported")
  }
  
  func display() {
    assert(false, "This method is not supported")
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Implementation of the VODItem leaf</h3></div></div></div><p>Our <a class="indexterm" id="id157"/>component class is ready; a default behavior is available for each method. We can now implement our <code class="literal">VODItem</code> class. It is a leaf class in the composite diagram and implements the behavior of the elements of the composite:</p><div><pre class="programlisting">class VODItem: VODComponent {
  private var name: String!
  Private var description: String!
  private var price: Double!
  
  init(name:String!, description:String!, price:Double!){
    self.name = name
    self.description = description
    self.price = price
  }
  
  override func getName() -&gt; String {
    return name!
  }
  
  override func getDescription() -&gt; String {
    return description!
  }
  
  override func getPrice() -&gt; Double {
    return price!
  }
  
  override func display() {
    print(" \(name!), \(price!),  ----  \(description!)")
  }
}</pre></div><p>See how I have defined the private variables with <code class="literal">!</code>. This means that the values of these variables cannot be nil after initialization. This is true because we added a constructor (the <code class="literal">init</code> method) where all our arguments must be passed to initialize our private fields.</p><p>Then, we override only methods that interest us. The <code class="literal">Add</code>/<code class="literal">Remove</code> and <code class="literal">GetChild</code> methods don't need to be overridden here; this will be done in the composite class.</p><p>To ensure that each name, description, and price has a value, we added an exclamation mark to unwrap it.</p><p>It is now time to implement our composite category class. We will call this composite class: <code class="literal">VODCategory</code>. It will hold <code class="literal">VODItems</code> or <code class="literal">VODCategory</code>. You'll see that again we will override only<a class="indexterm" id="id158"/> methods that interest us in this class. The <code class="literal">getPrice()</code> method will not interest us as it doesn't make sense.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Implementation of the VODCategory composite</h3></div></div></div><p>The first shot of the <code class="literal">VodCategory</code> class could be written as follow:</p><div><pre class="programlisting">class VODCategory: VODComponent{
  var vodComponents = [VODComponent]()
  private var name: String!
  private var description: String!
  
  init(name:String!, description:String!) {
    self.name = name
    self.description = description
  }
  
  override func add(vodComponent: VODComponent) {
    vodComponents.append(vodComponent)
  }
  
  override func remove(vodComponent: VODComponent) {
    vodComponents.remove(vodComponent)
  }
  
  override func getChild(i:Int) -&gt; VODComponent {
    return vodComponents[i]
  }

  override func getName() -&gt; String {
    return name!
  }
  
  override func getDescription() -&gt; String {
    return description!
  }

  override func display() {
    print(" \(name!),  \(description!) \r\n ----------------")
  }
}</pre></div><p>Well, as with <code class="literal">VODComponent</code>, we override the methods that interest us. As we can have any number of <code class="literal">VODComponent</code>, we add an array of type <code class="literal">VODComponent</code> to hold them.</p><p>We added <a class="indexterm" id="id159"/>the <code class="literal">Add</code>, <code class="literal">Remove</code>, and <code class="literal">GetChild</code> methods. The <code class="literal">Add</code> method will allow us to add an item, category, or subcategory. We can also remove it and return a <code class="literal">VODComponent</code> class based on its index.</p><p>Again, we can add a name and description to our composite that will be displayed when the <code class="literal">display()</code> method will be invoked.</p><p>Let's take a look at the following code:</p><div><pre class="programlisting">  override func remove(vodComponent: VODComponent) {
    vodComponents.remove(vodComponent)
  }</pre></div><p>If you write it like the preceding code, you'll get an error because Swift doesn't provide a <code class="literal">remove</code> method for the <code class="literal">Array</code> type.</p><p>It's time to make some modifications in our implementation and introduce you to the use of extensions.</p><p>Our problem is that we want to be able to remove an object of the type <code class="literal">VODComponent</code> to our <code class="literal">vodComponents</code> array using a method called <code class="literal">remove</code> (or anything else), where we pass an object that represents the object we want to remove from the list.</p><p>If we check the available method when the auto-completion is displayed, we do not see any method that can help us in this purpose, as shown in the following screenshot:</p><div><img alt="Implementation of the VODCategory composite" src="img/4852_03_04.jpg"/></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Structural Patterns – Decorator, Proxy, and Bridge">Chapter 2</a>, <em>Structural Patterns – Decorator, Proxy, and Bridge,</em> you could have used the decorator pattern to add such methods to the <code class="literal">Array</code> type; you can also propose to simply add a method to the class that will test all the elements in the array by comparing them one by one, and if they are identical, remove them from the list.</p><p>What we want <a class="indexterm" id="id160"/>is something that can be reused and generic. For this, Swift has <code class="literal">extension</code>. This permits you to add a behavior to a class very easily. Let's do it by adding a <code class="literal">remove</code> method to the type <code class="literal">Array</code>.</p><p>The extension must not be added to a class. Indeed, extensions are global. If you add extensions to an OS X or iOS project, you'll generally add them to a dedicated Swift file.</p><p>Here is our extension:</p><div><pre class="programlisting">extension Array {
  mutating func remove &lt;T: Equatable&gt; (object: T) {
    for i in (self.count-1).stride(through: 0, by: -1) {
      if let element = self[i] as? T {
        if element == object {
          self.removeAtIndex(i)
        }
      }
    }
  }
}</pre></div><p>As this function modifies the instance of the <code class="literal">Array</code> type and its properties, we mark this function as mutating. Then, we start from the end of the list and compare the elements that we want to find in the current elements of the list: </p><div><pre class="programlisting">      if let element = self[i] as? T {
        if element == object {
          self.removeAtIndex(i)
        }
      }</pre></div><p>Again, here there are some tricky things to do to make this code without any error. This function tells that we want that <code class="literal">Array</code> of type <code class="literal">T</code> must implement <code class="literal">Equatable</code> (is said with <code class="literal">remove &lt;T: Equatable&gt;</code> ) to be able to make the comparison:</p><div><pre class="programlisting">        if element == object {</pre></div><p>Therefore, we need to modify our abstract class, telling that our class implements the <code class="literal">Equatable</code> protocol:</p><div><pre class="programlisting">
<strong>class VODComponent : Equatable {</strong>
  
  func add(vodComponent:VODComponent){
    assert(false, "This method is not supported")
  }</pre></div><p>Of course, adding this protocol modifies our class diagram a little, but no matter. By implementing this protocol we are telling that elements of type <code class="literal">VODComponent</code> can be compared using <code class="literal">==</code> and <code class="literal">!=</code>.</p><p>If this is not <a class="indexterm" id="id161"/>completed, then we need to implement this protocol, so the best way to do this is by making a global function outside any class:</p><div><pre class="programlisting">// GLOBAL Func
func ==(left: VODComponent, right: VODComponent) -&gt; Bool {
  return left === right
}</pre></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>The <code class="literal">===</code> operator tells us whether the instances of the two components are identical or not.</p></div></div><p>So, now, all the code required for this class is written; the <code class="literal">remove</code> method is available and works perfectly.</p><p>Some improvements need to be added to our class to fully complete the implementation of the composite.</p><p>Have you seen how we implemented the <code class="literal">display</code> method in our composite (<code class="literal">VODCategory</code>) ? Indeed, the <code class="literal">display()</code> method of the composite only displays the information about itself, but it must invoke the <code class="literal">display()</code> method of each element that is contained in the composite. To do this, we will simply add a small part of the code that will iterate all elements that the composite contains in its array by adding a call to their respective <code class="literal">display()</code> methods.</p><p>Let's change the <code class="literal">display()</code> method of the <code class="literal">VODCategory</code> class to add an iteration to all our elements:</p><div><pre class="programlisting">//VODCategory
class VODCategory:VODComponent{
  
…
  override func display() {
    print(" \(name!),  \(description!) \r\n ----------------")
<strong>    for e in vodComponents{</strong>
<strong>        e.display()</strong>
<strong>    }</strong>
  }
}</pre></div><p>So, we iterate over each element of the array using <code class="literal">for … in</code> and call the <code class="literal">display()</code> method of each element.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec71"/>Usage</h2></div></div></div><p>All <a class="indexterm" id="id162"/>our classes are now ready and it's time to see how we can use this pattern in our client to test all of this.</p><p>We first prepare our <code class="literal">VODManager</code> class:</p><div><pre class="programlisting">class VODManager{
  var catalog:VODComponent
  
  init(vod: VODComponent) {
      catalog = vod
  }
  
  func displayCatalog() {
      catalog.display()
  }
}</pre></div><p>Then, we write our test code:</p><div><pre class="programlisting">//USAGE
let horrorCategory = VODCategory(name: "Horror", description: "Horror movies category")
let tvSeriesCategory = VODCategory(name: "TV Series", description: "TV Series category")
let comedyCategory = VODCategory(name: "Comedy", description: "Comedy category")
let voSTTvSeries = VODCategory(name: "VOSTSeries", description: "VOST TV Series sub category")

let allVODComponents = VODCategory(name: "All VOD", description: "All vod components")
let vodManager = VODManager(vod: allVODComponents)

allVODComponents.add(horrorCategory)
allVODComponents.add(tvSeriesCategory)
allVODComponents.add(comedyCategory)

tvSeriesCategory.add(voSTTvSeries)

horrorCategory.add(VODItem(name: "Scream", description: "Scream movie", price: 9.99))
horrorCategory.add(VODItem(name: "Paranormal Activity", description: "Paranormal Activity movie", price: 9.99))
horrorCategory.add(VODItem(name: "Blair Witch Project", description: "Blair Witch movie", price: 9.99))

tvSeriesCategory.add(VODItem(name: "Game of thrones S1E1", description: "Game of thrones Saison 1 episode 1", price: 1.99))
tvSeriesCategory.add(VODItem(name: "Deadwood", description: "Deadwood Saison 1 episode 1", price: 1.99))
tvSeriesCategory.add(VODItem(name: "Breaking Bad", description: "Breaking Bad Saison 1 Episode 1 " , price: 1.99))

voSTTvSeries.add(VODItem(name: "Doc Martin", description: "Doc Martin French serie Saison 1 Episode 1", price: 1.99))
voSTTvSeries.add(VODItem(name: "Camping Paradis", description: "Camping Paradis French serie Saison 1 Episode 1", price: 1.99))

comedyCategory.add(VODItem(name: "Very Bad Trip", description: "Very Bad Trip Movie", price: 9.99))
comedyCategory.add(VODItem(name: "Hot Chick", description: "Hot Chick Movie", price: 9.99))
comedyCategory.add(VODItem(name: "Step Brothers", description: "Step Brothers Movie", price: 9.99))
comedyCategory.add(VODItem(name: "Bad teacher", description: "Bad Teacher Movie", price: 9.99))

vodManager.displayCatalog()</pre></div><p>We <a class="indexterm" id="id163"/>need to prepare all our components. So, first, we prepare our tree category and then we add items to the good category.</p><p>At the end of the script, we call the <code class="literal">vodManager.displayCatalog()</code> method that will invoke the <code class="literal">display</code> method of all the components.</p><p>So, why don't we see something interesting in Playground? In fact, we have some clues that tell us that the code has been properly executed.</p><p>On the right-hand side of the screen, we can see the number of times a method has been called, as shown in the following screenshot:</p><div><img alt="Usage" src="img/4852_03_05.jpg"/></div><div><img alt="Usage" src="img/4852_03_06.jpg"/></div><p>However, we will modify this a little bit to get something more accurate for our test. We will modify each <code class="literal">display()</code> method by adding the string <code class="literal">return</code> type and replace the <code class="literal">print</code> statement with a <code class="literal">return</code> statement that contains the string to be returned:</p><div><pre class="programlisting">
<strong>  override func display() -&gt; String{</strong>
    return " \(name!), \(price!),  ----  \(description!)"
  }</pre></div><p>You <a class="indexterm" id="id164"/>need to change the <code class="literal">display()</code> method of the <code class="literal">VODComponent</code>, <code class="literal">VODItem</code>, and <code class="literal">VODCategory</code> classes.</p><p>For <code class="literal">VODCategory</code>, you need to modify it like the following code so that it is easily readable:</p><div><pre class="programlisting">override func display() -&gt; String{
    var text = " \(name!),  \(description!) \r\n ----------------"
    for e in vodComponents {
        text += "\r\n\(e.display()) \r\n"
    }
    return text
  }</pre></div><p>For <code class="literal">VODManager</code>, you need to simply add the return type and replace <code class="literal">print</code> with <code class="literal">return</code>:</p><div><pre class="programlisting">  func displayCatalog() -&gt; String{
      return catalog.display()
  }</pre></div><p>Finally, move the <code class="literal">tvSeriesCategory.add(voSTTvSeries)</code> line in the <em>Usage</em> section (marked with a comment : // USAGE) of the Playground file ( just before the <code class="literal">vodManager.display()</code>line; this will make our result easier to read.</p><p>Now, you will see something on the right-hand side just after the <code class="literal">vodManager.display()</code> line:</p><div><img alt="Usage" src="img/4852_03_07.jpg"/></div><p>Click on the Eye icon on the right-hand side of the screen. You'll see the result of our <code class="literal">vodManager.display()</code> invocation:</p><div><img alt="Usage" src="img/4852_03_08.jpg"/></div><p>Notice <a class="indexterm" id="id165"/>that the <code class="literal">display()</code> method of the composite or leaf is called recursively. The items are organized depending on the categories that we have added them to. In the preceding screenshot, we can see that after <code class="literal">Horror VODCategory</code> is called, all horror movies (<code class="literal">VODItem</code>) that we defined are displayed, then it continues with the TV series that also contain a <code class="literal">VOST TV Series</code> subcategory, and so on.</p><p>This concludes our discovery of the composite pattern.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>The flyweight pattern</h1></div></div></div><p>This <a class="indexterm" id="id166"/>pattern can be used when the system needs <a class="indexterm" id="id167"/>to deal with a large number of similar objects. Instead of creating each element one by one, this pattern permits you to reuse an object that shares the same data.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec72"/>Roles</h2></div></div></div><p>The flyweight pattern <a class="indexterm" id="id168"/>is used to reduce the memory and resource usage of complex models that contain many hundreds and thousands of similar objects by reducing the number of objects created. It tries to reuse similar existing objects or creates a new one when no match is found.</p><p>This pattern <a class="indexterm" id="id169"/>can be used when:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need to manipulate a lot of small similar objects</li><li class="listitem" style="list-style-type: disc">The cost (the memory/execution time) of this manipulation is high</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec73"/>Design</h2></div></div></div><p>The following <a class="indexterm" id="id170"/>class diagram represents the generic structure of the pattern:</p><div><img alt="Design" src="img/4852_03_09.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec74"/>Participants</h2></div></div></div><p>There are three participants to the flyweight pattern, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Flyweight</code>: This <a class="indexterm" id="id171"/>declares an interface that contains an intrinsic state and implements methods. These methods can receive and act on the extrinsic state of the flyweights.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FlyweightFactory</code>: This<a class="indexterm" id="id172"/> factory creates and manages a flyweight's objects. It assures that the flyweight is shared, thanks to the method that it returns a reference to the flyweight.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Client</code>: This <a class="indexterm" id="id173"/>contains references to the used flyweight. It also contains the extrinsic state of these flyweights.</li></ul></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>
<strong>The extrinsic state</strong>: This is the state that belongs to the context of the object (external) or unique to that instance.</p><p>
<strong>The intrinsic state</strong>: This is the state that belongs to the flyweight object and should be permanent or immutable (internal).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec75"/>Collaboration</h2></div></div></div><p>Clients <a class="indexterm" id="id174"/>do not create the flyweight by themselves, but they use the <code class="literal">FlyweightFactory</code> method that guarantees the sharing of flyweights.</p><p>When a client invokes a method of a flyweight, it needs to send its extrinsic state.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec76"/>Illustration</h2></div></div></div><p>Suppose<a class="indexterm" id="id175"/> that we want to display 200000 rectangles on a 1024 x 768 screen. These rectangles are generated randomly; they can have a random color from a list of 10 different colors.</p><p>We need to reduce the time taken to execute the function and use as less memory as possible.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec77"/>Implementation</h2></div></div></div><p>In this<a class="indexterm" id="id176"/> example, we will use an <code class="literal">XCTest</code> project with the <code class="literal">XCTest</code> framework and instrument tool to illustrate how this pattern will help us reduce the memory consumption.</p><p>First, open the project called <code class="literal">Flyweight Pattern_Demo1</code> that you will find in the source code folder of this chapter.</p><p>Go to the Xcode project named <code class="literal">FlyweightPattern_Demo1Tests</code> and click on the <code class="literal">FlyweightPattern_Demo1Tests.swift</code> file, as shown in the following screenshot:</p><div><img alt="Implementation" src="img/4852_03_10.jpg"/></div><p>In this file, you'll <a class="indexterm" id="id177"/>see the different test methods that are already implemented. Before starting with the implementation of our flyweight pattern, let's see what we currently have.</p><p>We already have an abstract class called <code class="literal">AbstractPerfTest</code> that contains some already defined properties, fields, and methods:</p><div><pre class="programlisting">class AbstractPerfTest {
  
  let colors:[SKColor] = [
    SKColor.yellowColor(),
    SKColor.blackColor(),
    SKColor.cyanColor(),
    SKColor.whiteColor(),
    SKColor.blueColor(),
    SKColor.brownColor(),
    SKColor.redColor(),
    SKColor.greenColor(),
    SKColor.grayColor(),
    SKColor.purpleColor()
  ]
  
  let sks = SKScene()
  let view = SKView(frame: NSRect(x: 0, y: 0, width: 1024, height: 768))
  
  let maxRectWidth = 100
  let maxRectHeight = 100
  
  //must be overriden
  func run(){
    preconditionFailure("Must be overriden")
  }
  
  
  // - MARK generate Rect Height and Width
  func generateRectWidth() -&gt; Int{
    return Int(arc4random_uniform(UInt32(maxRectWidth)))
  }
  
  func generateRectHeight() -&gt; Int{
    return Int(arc4random_uniform(UInt32(maxRectHeight)))
  }
  
  // - MARK generate Position X and Y
  func generateXPos() -&gt; Int{
    return Int(arc4random_uniform(UInt32(view.bounds.size.width)))
  }
  
  func generateYPos() -&gt; Int{
    return Int(arc4random_uniform(UInt32(view.bounds.size.height)))
  }
}</pre></div><p>There is <a class="indexterm" id="id178"/>another class called <code class="literal">NoPattern</code> that inherits from this abstract class and overrides the run method:</p><div><pre class="programlisting">import Foundation
// Inherits from our AbstractPerfTest class
// which contains default methods and init
class NoPattern:AbstractPerfTest {
  // Execute the test
  override func run(){
    var j:Int = 0
    for _ in 1...NUMBER_TO_GENERATE {
      let idx = Int(arc4random_uniform(UInt32(self.colors.count- 1)))
      
      let rect = SimpleRect(color: self.colors[idx])
      rect.display(generateXPos(), yPos: generateYPos(), width: generateRectWidth(), height: generateRectHeight())
      j++
    }
    print("\(j) rects generated")
  }
}</pre></div><p>The <code class="literal">SimpleRect</code> class <a class="indexterm" id="id179"/>is defined in the <code class="literal">SimpleRect.swift</code> file of the <code class="literal">NoPattern</code> group folder. It is an object defined by a color, <em>x</em> and <em>y</em> position, width, and height.</p><p>I will not comment too much on the <code class="literal">NoPattern</code> class, but what we see here is that the <code class="literal">run</code> method of the <code class="literal">NoPattern</code> class generates <code class="literal">NUMBER_TO_GENERATE</code> (set to <code class="literal">100000</code> by default in the <code class="literal">FlyweightPattern_Demo1Tests.swift</code> file) rectangles with a random color taken from the list of the colors array (defined in the abstract class). It then generates a position and dimension for each of these rectangles.</p><p>Now, let's check the performance of the <code class="literal">run</code> method.</p><p>Come back to the <code class="literal">FlyweightPattern_Demo1Tests.swift</code> file and check the method named <code class="literal">testSimpleScreenFilling_noFlyWeight()</code>. Here, the method will execute the code implemented in the <code class="literal">NoPattern</code> class that, like the name of the method tells us, does not implement the flyweight pattern. The execution time of this method will be used as a baseline to compare the same method but with the implementation of the flyweight pattern.</p><p>So, let's execute the test by clicking on the small icon on the left-hand side of the <code class="literal">func testSimpleScreenFilling_noFlyWeight()</code> function, as shown in the following screenshot:</p><div><img alt="Implementation" src="img/4852_03_12.jpg"/></div><p>We need to <a class="indexterm" id="id180"/>ensure that the console is visible in Xcode. While executing, you'll see that the console log with <strong>200000 rects generated</strong> has been repeated 10 times. This proves that our code has generated 2,00,000 rectangles 10 times. By default, the <code class="literal">self.measureBlock</code> closure is executed 10 times, and it calculates the standard deviation of these 10 executions to obtain an average execution time:</p><div><img alt="Implementation" src="img/4852_03_13.jpg"/></div><p>On my MacBook Pro 15 Retina Late 2013, the average time is <strong>0.804</strong> seconds:</p><div><img alt="Implementation" src="img/4852_03_14.jpg"/></div><p>Now, the best part is to refactor our code to reduce the time taken to generate these 2,00,000 rectangles. As you have already seen in the generic structure of the pattern, we will need a few classes to manage our flyweights.</p><p>Let's start with our <code class="literal">flyweightRect</code> class. Note that the <code class="literal">flyweightRect</code> and <code class="literal">SimpleRect</code> classes are used in the <code class="literal">NoPattern</code> class to generate rectangles that are identical.</p><p>Therefore, in <a class="indexterm" id="id181"/>the following code, you'll find our <code class="literal">FlyweightRect</code> class with the definition of our rectangle. So, we have a color, <em>x</em> and <em>y</em> position, height, and width of the rectangle.</p><p>Note that because I really want to see the gain in performance, I added two fields: <code class="literal">image</code> and <code class="literal">sprite</code>. Because the value of these fields have a cost in terms of performance on the instantiation of the class, I added them to show you clearly that the flyweight pattern permits you to reduce the calculation costs (and memory usage) when applied.</p><p>We will add a constructor to the intrinsic state as an argument: this will be the color. We will add another <code class="literal">display()</code>method that will receive extrinsic states as arguments:</p><div><pre class="programlisting">import SpriteKit
import Foundation

class FlyweightRect {
  
  var color: SKColor!
  var xPos: Int?
  var yPos: Int?
  var width: Int?
  var height: Int?
  var image: NSImage?
  var sprite: SKSpriteNode?
  
  //the constructor contains our intrinsic state
  init(color: SKColor) {
    self.color = color
    self.image = NSImage()
    self.sprite = SKSpriteNode()
  }
  
  func display(xPos: Int, yPos: Int, width: Int, height: Int){
    self.xPos = xPos
    self.yPos = yPos
    self.width = width
    self.height = height
  }
  
  func description() -&gt; String  {
    return "rect position: \(self.xPos), \(self.yPos) : dimension: \(self.width), \(self.height)  : color: \(self.color)"
  }
}</pre></div><p>Once our flyweight is defined, we can now prepare our <code class="literal">FlyweightFactory</code> object. Remember that this factory<a class="indexterm" id="id182"/> will first check if we already have a rectangle that is similar to the new one that we want to position on the screen; if it is not similar, then it will create a new one:</p><div><pre class="programlisting">import SpriteKit
import Foundation

class FlyweightRectFactory{
    internal static var rectsMap = Dictionary&lt;SKColor, FlyweightRect&gt;()

  static func getFlyweightRect(color:SKColor) -&gt; FlyweightRect{
    if let result = rectsMap[color]{
        return result
    } else { // if nil add it to our dictionnary
      let result = FlyweightRect(color: color)
      rectsMap[color] = result
      return result
    }
  }
}</pre></div><p>We declare a static <code class="literal">rectsMap</code> variable of the type <code class="literal">Dictionary</code> that will contain our shared objects and manage their existence. The dictionary <code class="literal">Key</code> will contain a <code class="literal">Color</code> object.</p><p>Then, we define a static method called <code class="literal">getFlyweightRect</code> that will return a <code class="literal">FlyweightRect</code> class.</p><p>As <code class="literal">rectMaps[color]</code> returns <code class="literal">nil</code>, we unwrap the optional with a <code class="literal">if let</code> statement. If it is not <code class="literal">nil</code>, we return the result; otherwise, we create a new flyweight with the appropriate color, add it to our dictionary, and return the result.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>In the <code class="literal">FlyweightPattern_Demo1.swift</code> file, you'll find several test methods that test the response time of the factory depending on the type of the object that manages our flyweights. In the project, I tested the performance of the object that manages our flyweights using the <code class="literal">Dictionary&lt;SKColor, FlyweightRect&gt;</code>, <code class="literal">NSMutableDictionary</code>, and <code class="literal">NSCache</code> types.</p></div></div><p>The complete code of the <code class="literal">FlyweightRectFactory.swift</code> file is as follows:</p><div><pre class="programlisting">import SpriteKit
import Foundation

class FlyweightRectFactory {
  
  internal static var rectsMap = Dictionary&lt;SKColor, FlyweightRect&gt;()
  internal static var rectsMapNS = NSMutableDictionary()
  internal static var rectsMapNSc = NSCache()
  
  
  static func getFlyweightRect(color:SKColor) -&gt; FlyweightRect{
    if let result = rectsMap[color]{
        return result
    }else {       let result = FlyweightRect(color: color)
      rectsMap[color] = result
      return result
    }
  }
  
  
  
  static func getFlyweightRectWithNS(color: SKColor) -&gt; FlyweightRect{
    
    let result = rectsMapNS[color.description]
    
    if result == nil {
      let flyweight= FlyweightRect(color: color)
      rectsMapNS.setObject(flyweight, forKey: color.description)
      return flyweightas FlyweightRect
    }else {
      return result as! FlyweightRect
    }
    
  }
  
  static func getFlyweightRectWithNSc(color: SKColor) -&gt; FlyweightRect{
    
    let result = rectsMapNSc.objectForKey(color.description)
    
    if result == nil {
      let flyweight= FlyweightRect(color: color)
      rectsMapNSc.setObject(flyweight, forKey:color.description)
      return flyweight as FlyweightRect
    }else {
      return result as! FlyweightRect
    }
  }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec78"/>Usage</h2></div></div></div><p>Using our pattern is extremely easy. You need to check the <code class="literal">run()</code> method of the <code class="literal">WithPattern.swift</code> file:</p><div><pre class="programlisting">class WithPattern:AbstractPerfTest{
  //Execute the test
  override func run(){
    var j:Int = 0
    for _ in 1...NUMBER_TO_GENERATE{
      let idx = Int(arc4random_uniform(UInt32(self.colors.count- 1)))
      let rect = FlyweightRectFactory.getFlyweightRect(self.colors[idx])
      rect.display(generateXPos(), yPos: generateYPos(), width: generateRectWidth(), height: generateRectHeight())
      j++
    }
    print("\(j) rects generated")
    //print("nb Map: \(FlyweightRectFactory.rectsMap.count)")
  }</pre></div><p>We will simply make a loop to create 200000 <code class="literal">FlyweightRect</code> objects (<code class="literal">NUMBER_TO_GENERATE</code> is a constant defined at the top of the <code class="literal">FlyweightPattern_Demo1Tests.swift</code> file).</p><p>The <code class="literal">WithPattern</code> class written in the preceding does the following:</p><div><ol class="orderedlist arabic"><li class="listitem">We first generate a random number that returns a value that will correspond to the index of a color available in the colors array (defined in the <code class="literal">AbstractPerfTest.swift</code> file).</li><li class="listitem">Then, we tell the factory to return a flyweight with the appropriate color.</li><li class="listitem">Then, we generate the extrinsic state (<em>x</em> position, <em>y</em> position, width, and height).</li><li class="listitem">Once the loop is complete, we display the number of generated rectangles.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec79"/>Performance results</h2></div></div></div><p>To check the<a class="indexterm" id="id183"/> performance, there is an <code class="literal">XCTest</code> class available in the project with the <code class="literal">self.measureblock</code> closure that allows us to measure the performance of our block.</p><p>To launch all the tests available in the project, click on the <strong>Show the Test navigator</strong> button on the left-hand side, as shown in the following screenshot:</p><div><img alt="Performance results" src="img/4852_03_15.jpg"/></div><p>Then, click <a class="indexterm" id="id184"/>on the play button that is visible on the right-hand side of the highlighted line:</p><div><img alt="Performance results" src="img/4852_03_16.jpg"/></div><p>After a few seconds, all the tests would have been run and you can now check your performance results.</p><p>Come back to the <code class="literal">FlyweightPattern_Demo1Tests.swift</code> file and check the end of each <code class="literal">measureblock()</code> method. This is the result with the flyweight pattern using a dictionary. You can see that it took an average of 0.247 seconds to generate 200000 rectangles, as shown in the following screenshot. You'll see a text with <code class="literal">Time xxxx</code> written; this is the average time taken to execute this block:</p><p> </p><div><img alt="Performance results" src="img/4852_03_17.jpg"/></div><p>
</p><p>As compared to an average of <strong>0.877</strong> seconds without using the pattern:</p><p> </p><div><img alt="Performance results" src="img/4852_03_18.jpg"/></div><p>
</p><p>After reviewing the results, you'll see that generating rectangles are better when (best performance first):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The flyweight pattern with a <code class="literal">Dictionary</code> object is used to manage our shared objects</li><li class="listitem" style="list-style-type: disc">The flyweight pattern with a <code class="literal">NSDictionary</code> object is used to manage our shared objects</li><li class="listitem" style="list-style-type: disc">The flyweight pattern with a <code class="literal">NSCache</code> object is used to manage our shared objects</li><li class="listitem" style="list-style-type: disc"> No pattern is applied</li></ul></div><p>In this example, we <a class="indexterm" id="id185"/>can say that generating 200000 <code class="literal">FlyweightRect</code> objects is 3,55 times faster than without using the pattern.</p><p>The test project proves that Swift is faster than Objective-C and <code class="literal">NSCache,</code> which are encapsulated.</p><p>The <code class="literal">NSDictionary</code> object will have its own logic while handling the cache. It can create more objects inside its own hidden code structure, so it's <a class="indexterm" id="id186"/>slower than the <code class="literal">NSDictionary</code> object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, you learned how to deal with structures of multiple objects. The composite pattern allows you to access and alter data structures in a uniform way, whereas the flyweight pattern is a more accurate way to save the memory space or time spent in calculation when they are multiple similar objects.</p><p>A flyweight pattern is useful with other patterns to keep data as small as possible. The composite pattern is useful in combination with other patterns to manage the data structure. The composite pattern can use a flyweight pattern, but the inverse will not.</p><p>In this chapter, I tried to present you with something different; using the <code class="literal">XCTest</code> framework, to test the performance of our pattern. If you want to dive deeper, you can try to see the difference in the memory allocation using the instrument tools provided in Xcode.</p><p>In the next chapter, we will continue with the discovery of our structural patterns by learning what the adapter and facade patterns are.</p></div></body></html>