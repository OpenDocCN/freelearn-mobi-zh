<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-50"><a id="_idTextAnchor082"/>2</h1>
<h1 id="_idParaDest-51"><a id="_idTextAnchor083"/>Creating Screens Using a Declarative UI and Exploring Compose Principles</h1>
<p>Mobile applications <a id="_idIndexMarker084"/>require a <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) for user interactions. For instance, the old way of creating the UI was imperative in Android. This meant having <a id="_idIndexMarker085"/>a separate prototype of the application’s UI using unique <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) layouts and not the same language used to build your logic.</p>
<p>However, with Modern Android Development, there is a push to stop using imperative programming and start using a declarative way of making the UI, which means developers design the UI based on the data received. This design paradigm uses one programming language to create an entire application. </p>
<p>It is fair to acknowledge it may seem difficult for new developers to decide what to learn when building a UI: the old way of creating views or opting for the new Jetpack Compose. However, suppose you’ve built an Android application before the Jetpack Compose era.</p>
<p>In such a case, you may already know using XML is a bit tedious, especially if your code base is complex. However, utilizing Jetpack Compose as your first choice makes work easier. In addition, it simplifies UI development by ensuring developers use less code, as they take advantage of the intuitive Kotlin APIs. Hence, there is a logical push by new developers when creating views to use Jetpack Compose instead of XML.</p>
<p>However, knowing both can be beneficial since many applications still use XML layouts, and you might have to maintain the view but build new ones using Jetpack Compose. In this chapter, we will look at Jetpack Compose basics by trying to implement small examples using columns, rows, boxes, lazy columns, and more.</p>
<p>In this chapter, we’ll be covering the following recipes:</p>
<ul>
<li>Implementing Android views in Jetpack Compos<a id="_idTextAnchor084"/>e</li>
<li>Implementing a scrollable list in Jetpack Compos<a id="_idTextAnchor085"/>e</li>
<li>Implementing your first tab layout with a view pager using Jetpack Compose</li>
<li>Implementing animations in Compose</li>
<li>Implementing accessibility in Jetpack Compose</li>
<li>Implementing declarative graphics using Jetpack Compos<a id="_idTextAnchor086"/>e</li>
</ul>
<h1 id="_idParaDest-52"><a id="_idTextAnchor087"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two</a>. To be able to view all the recipes, you will need to run all the preview functions separately. Hence, look for the <code>@Preview</code> composable function to view the UI created<a id="_idTextAnchor088"/>.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor089"/>Implementing Android views in Jetpack Compose</h1>
<p>In every Android application, having a UI element is very crucial. A view in Android is a simple <a id="_idIndexMarker086"/>building block for a UI. A view ensures <a id="_idIndexMarker087"/>users can interact with your application through a tap or other motion. This recipe will look at different Compose UI elements and see how we can build th<a id="_idTextAnchor090"/>em.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor091"/>Getting ready</h2>
<p>In this recipe, we will create one project that we will re-use for the entire chapter, so let’s go ahead and follow the steps in <a href="B18827_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Modern Android Development Skills</em>, on how to create your first Android project.</p>
<p>Create a project and call it <code>Compose Basics</code>. In addition, we will mostly use the <strong class="bold">Preview</strong> section to view the UI element we crea<a id="_idTextAnchor092"/>te.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor093"/>How to do it…</h2>
<p>Once you have created the project, follow these steps to build several Compose UI elements:</p>
<ol>
<li>Inside our project, let us go ahead and create a new package and call it components. This is where we will add all the components we create.</li>
<li>Create a Kotlin file and call it <code>UIComponents.kt</code>; inside <code>UIComponent</code>, go ahead and create a composable function, call it <code>EditTextExample()</code>, and call the <code>OutlinedTextField()</code> function; this will prompt you to import the required import, which is <code>androidx.Compose.material.OutlinedTextField</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun EditTextExample() {</pre><pre class="source-code">
    OutlinedTextField()</pre><pre class="source-code">
}</pre></li>
<li>When you <a id="_idIndexMarker088"/>look deep into <code>OutlineTextField</code> (see <em class="italic">Figure 2</em><em class="italic">.1</em>), you will notice the function accepts <a id="_idIndexMarker089"/>several inputs, and this is very useful when you need to customize your own composable functions.</li>
</ol>
<div><div><img alt="Figure 2.1 – The OutlinedTextField input" src="img/Figure_2.1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The OutlinedTextField input</p>
<ol>
<li value="4">For our <a id="_idIndexMarker090"/>example, we will not <a id="_idIndexMarker091"/>do much with the UI we create and will rather just look at how we create them.</li>
<li>Now, to fully create our <code>OutlinedTextField()</code> based on the types of input we see it accepts, we can give it a text and color and we can decorate it using a <code>Modifier()</code>; that is, by giving it specific instructions such as <code>fillMaxWidth()</code>, which sets the max width. When we say fill, we are simply specifying it should be fully filled. We set <code>.padding(top)</code> to <code>16.dp</code>, which applies additional space along each edge of the content in <code>dp</code>. It also has a value, which is the value to be entered in the <code>OutlinedTextField</code>, and an <code>onValueChange</code> lambda that listens to the input change.</li>
<li>We also give our <code>OutlinedText</code> some border colors when focused and when not focused to reflect the different states. Hence, if you start entering input, the box will change color to blue, as specified in the code:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun EditTextExample() {</pre><pre class="source-code">
    OutlinedTextField(</pre><pre class="source-code">
        value = "",</pre><pre class="source-code">
        onValueChange = {},</pre><pre class="source-code">
        label = { Text(stringResource(id =</pre><pre class="source-code">
        R.string.sample)) },</pre><pre class="source-code">
        modifier = Modifier</pre><pre class="source-code">
            .fillMaxWidth()</pre><pre class="source-code">
            .padding(top = 16.dp),</pre><pre class="source-code">
        colors =</pre><pre class="source-code">
            TextFieldDefaults.outlinedTextFieldColors(</pre><pre class="source-code">
                focusedBorderColor = Color.Blue,</pre><pre class="source-code">
                unfocusedBorderColor = Color.Black</pre><pre class="source-code">
            )</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>We also <a id="_idIndexMarker092"/>have another type <a id="_idIndexMarker093"/>of <code>TextField</code>, which is not outlined, and if you compare what <code>OutlinedTextField</code> takes in as input, you will notice they are fairly similar:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun NotOutlinedEditTextExample() {</pre><pre class="source-code">
    TextField(</pre><pre class="source-code">
        value = "",</pre><pre class="source-code">
        onValueChange = {},</pre><pre class="source-code">
        label = { Text(stringResource(id =</pre><pre class="source-code">
        R.string.sample)) },</pre><pre class="source-code">
        modifier = Modifier</pre><pre class="source-code">
            .fillMaxWidth()</pre><pre class="source-code">
            .padding(top = 8.dp, bottom = 16.dp),</pre><pre class="source-code">
        colors =</pre><pre class="source-code">
            TextFieldDefaults.outlinedTextFieldColors(</pre><pre class="source-code">
                focusedBorderColor = Color.Blue,</pre><pre class="source-code">
                unfocusedBorderColor = Color.Black</pre><pre class="source-code">
            )</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>You can <a id="_idIndexMarker094"/>run the application <a id="_idIndexMarker095"/>by adding the Compose functions inside the <code>@Preview</code> composable function. In our example, we can create <code>UIElementPreview()</code>, which is a preview function for displaying our UI. In <em class="italic">Figure 2</em><em class="italic">.2</em>, the top view is <code>OutlinedTextField</code>, whereas the second one is a normal <code>TextField</code>.</li>
</ol>
<div><div><img alt="Figure 2.2 – OutlinedTextField and TextField" src="img/Figure_2.2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – OutlinedTextField and TextField</p>
<ol>
<li value="9">Now, let’s <a id="_idIndexMarker096"/>go ahead and look <a id="_idIndexMarker097"/>at button examples. We will look at different ways to create buttons with different shapes. If you hover over the <code>Button()</code> composable function, you will see what it accepts as input, as shown in <em class="italic">Figure 2</em><em class="italic">.3</em>.</li>
</ol>
<div><div><img alt="Figure 2.3 – Button input" src="img/Figure_2.3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Button input</p>
<p>In our second example, we will try to create a button with an icon on it. In addition, we will add text, which is crucial when creating buttons since we need to specify to <a id="_idIndexMarker098"/>users what action <a id="_idIndexMarker099"/>or what the button will be doing once it is clicked on.</p>
<ol>
<li value="10">So, go ahead and create a Compose function in the same Kotlin file and call it <code>ButtonWithIcon()</code>, and then import the <code>Button()</code> composable function.</li>
<li>Inside it, you will need to import an <code>Icon()</code> with <code>painterResource</code> input, a content description, <code>Modifier</code>, and <code>tint</code>. We will also need <code>Text()</code>, which will give our button a name. For our example, we will not use <code>tint</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun ButtonWithIcon() {</pre><pre class="source-code">
    Button(onClick = {}) {</pre><pre class="source-code">
        Icon(</pre><pre class="source-code">
            painterResource(id =</pre><pre class="source-code">
                R.drawable.ic_baseline_shopping_bag_24                ),</pre><pre class="source-code">
            contentDescription = stringResource(</pre><pre class="source-code">
                id = R.string.shop),</pre><pre class="source-code">
            modifier = Modifier.size(20.dp)</pre><pre class="source-code">
        )</pre><pre class="source-code">
        Text(text = stringResource(id = R.string.buy),</pre><pre class="source-code">
            Modifier.padding(start = 10.dp))</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Let us <a id="_idIndexMarker100"/>also go ahead and create <a id="_idIndexMarker101"/>a new composable function and call it <code>CornerCutShapeButton()</code>; in this example, we will try to create a button with cut corners:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CornerCutShapeButton() {</pre><pre class="source-code">
    Button(onClick = {}, shape = CutCornerShape(10)) {</pre><pre class="source-code">
        Text(text = stringResource(</pre><pre class="source-code">
            id = R.string.cornerButton))  }}}}</pre></li>
<li>Let us also go ahead and create a new composable function and call it <code>RoundCornerShapeButton()</code>; in this example, we will try to create a button with round corners:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun RoundCornerShapeButton() {</pre><pre class="source-code">
    Button(onClick = {}, shape =</pre><pre class="source-code">
    RoundedCornerShape(10.dp)) {</pre><pre class="source-code">
        Text(text = stringResource(</pre><pre class="source-code">
            id = R.string.rounded))</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Let us also <a id="_idIndexMarker102"/>go ahead and <a id="_idIndexMarker103"/>create a new composable function and call it <code>ElevatedButtonExample()</code>; in this example, we will try to create a button with elevation:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun ElevatedButtonExample() {</pre><pre class="source-code">
    Button(</pre><pre class="source-code">
        onClick = {},</pre><pre class="source-code">
        elevation = ButtonDefaults.elevation(</pre><pre class="source-code">
            defaultElevation = 8.dp,</pre><pre class="source-code">
            pressedElevation = 10.dp,</pre><pre class="source-code">
            disabledElevation = 0.dp</pre><pre class="source-code">
        )</pre><pre class="source-code">
    ) {</pre><pre class="source-code">
        Text(text = stringResource(</pre><pre class="source-code">
            id = R.string.elevated))</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>When you <a id="_idIndexMarker104"/>run the application, you <a id="_idIndexMarker105"/>should have an image similar to <em class="italic">Figure 2</em><em class="italic">.4</em>; the first button after <code>TextField</code> is <code>ButtonWithIcon()</code>, the second one is <code>CornerCutShapeButton()</code>, the third is <code>RoundCornerShapeButton()</code>, and, lastly, we have <code>ElevatedButtonExample()</code>.</li>
</ol>
<div><div><img alt="Figure 2.4 – The different button types and other UI elements" src="img/Figure_2.4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – The different button types and other UI elements</p>
<ol>
<li value="16">Now, let us look at one last example since we will be using different views and styles throughout the book and will learn more in the process. Now, let us look at an image view; the <code>Image()</code> composable function takes in several inputs, as shown in <em class="italic">Figure 2</em><em class="italic">.5</em>.</li>
</ol>
<div><div><img alt="Figure 2.5 – Different ImageView input types" src="img/Figure_2.5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Different ImageView input types</p>
<ol>
<li value="17">In our example, <code>Image()</code> will only have a painter, which is not nullable, meaning <a id="_idIndexMarker106"/>you need to provide an <a id="_idIndexMarker107"/>image for this composable function, a content description for accessibility, and a modifier:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun ImageViewExample() {</pre><pre class="source-code">
    Image(</pre><pre class="source-code">
        painterResource(id = R.drawable.android),</pre><pre class="source-code">
        contentDescription = stringResource(</pre><pre class="source-code">
            id = R.string.image),</pre><pre class="source-code">
        modifier = Modifier.size(200.dp)</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>You can <a id="_idIndexMarker108"/>also try to play around <a id="_idIndexMarker109"/>with others things, such as adding <code>RadioButton()</code> and <code>CheckBox()</code> elements and customizing them. When you run your application, you should have something similar to <em class="italic">Figure 2</em><em class="italic">.6</em>.</li>
</ol>
<div><div><img alt="Figure 2.6 – Se﻿veral UI components" src="img/Figure_2.6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Se<a id="_idTextAnchor094"/>veral UI components</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor095"/>How it works…</h2>
<p>Every composable function is annotated with the <code>@Composable</code> annotation. This annotation tells the Compose compiler that the provided compiler is intended to convert the <a id="_idIndexMarker110"/>provided data into a UI. It is also <a id="_idIndexMarker111"/>important to note each composable function name needs to be a noun and not a verb or an adjective, and Google provides these guidelines. Any composable function you create can accept parameters that enable the app logic to describe or modify your UI.</p>
<p>We mention the Compose compiler, which means that a compiler is any special program that takes the code we wrote, examines it, and translates it into something the computer can understand – or machine language.</p>
<p>In <code>Icon()</code>, <code>painterResouce</code> specifies the icon we will be adding to the button, the content description helps with accessibility, and the modifier is used to decorate our icon.</p>
<p>We can preview the UI elements we build by adding the <code>@Preview</code> annotation and adding <code>showBackground = </code><code>true</code>:</p>
<pre class="source-code">
@Preview(showBackground = true)</pre>
<p><code>@Preview</code> is powerful, and we will look at how you can utilize it bette<a id="_idTextAnchor096"/>r in future chapters.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor097"/>Implementing a scrollable list in Jetpack Compose</h1>
<p>When building <a id="_idIndexMarker112"/>Android applications, one <a id="_idIndexMarker113"/>thing that we can all agree on is you must know how to build a <code>RecyclerView</code> to display your data. With our new, modern way of building Android applications, if we need to use <code>RecyclerView</code>, we can use <code>LazyColumn</code>, which is similar. In this recipe, we will look at rows, columns, and <code>LazyColumn</code>, and build a scrollable list using our dummy data.</p>
<p>In addition, we will be learning some <a id="_idTextAnchor098"/>Kotlin in the process.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor099"/>Getting ready</h2>
<p>We will continue using the <code>Compose Basics</code> project to build a scrollable list; hence, to get started, you need to have done the previous recipe.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor100"/>How to do it…</h2>
<p>Follow these <a id="_idIndexMarker114"/>steps to build your first scrollable list:</p>
<ol>
<li>Let us go <a id="_idIndexMarker115"/>ahead and build our first scrollable list, but first, we need to create our dummy data, and this is the item we want to be displayed on our list. Hence, create a package called <code>favoritecity</code> where our scrollable example will live.</li>
<li>Inside the <code>favoritecity</code> package, create a new data class and call it <code>City</code>; this will be our dummy data source – <code>data class </code><code>City ()</code>.</li>
<li>Let us model our <code>City</code> data class. Make sure you add the necessary imports once you have added the annotated values:<pre class="source-code">
data class City(</pre><pre class="source-code">
    val id: Int,</pre><pre class="source-code">
    @StringRes val nameResourceId: Int,</pre><pre class="source-code">
    @DrawableRes val imageResourceId: Int</pre><pre class="source-code">
)</pre></li>
<li>Now, in our dummy data, we need to create a Kotlin class and call this class <code>CityDataSource</code>. In this class, we will create a function called <code>loadCities()</code>, which will return our list of <code>List&lt;City&gt;</code>, which we will display in our scrollable list. Check the <em class="italic">Technical requirements</em> section for all the required imports to get all the code and images:<pre class="source-code">
class CityDataSource {</pre><pre class="source-code">
    fun loadCities(): List&lt;City&gt; {</pre><pre class="source-code">
        return listOf&lt;City&gt;(</pre><pre class="source-code">
            City(1, R.string.spain, R.drawable.spain),</pre><pre class="source-code">
            City(2, R.string.new_york,</pre><pre class="source-code">
                R.drawable.newyork),</pre><pre class="source-code">
            City(3, R.string.tokyo, R.drawable.tokyo),</pre><pre class="source-code">
            City(4, R.string.switzerland,</pre><pre class="source-code">
                R.drawable.switzerland),</pre><pre class="source-code">
            City(5, R.string.singapore,</pre><pre class="source-code">
                R.drawable.singapore),</pre><pre class="source-code">
            City(6, R.string.paris, R.drawable.paris),</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now, we have <a id="_idIndexMarker116"/>our dummy data, and it <a id="_idIndexMarker117"/>is time to display this on our scrollable list. Let’s create a new Kotlin file in our <code>components </code>package and call it <code>CityComponents</code>. In <code>CityComponents</code>, we will create our <code>@</code><code>Preview</code> function:<pre class="source-code">
@Preview(showBackground = true)</pre><pre class="source-code">
@Composable</pre><pre class="source-code">
private fun CityCardPreview() {</pre><pre class="source-code">
    CityApp()</pre><pre class="source-code">
}</pre></li>
<li>Inside our <code>@Preview</code> function, we have another composable function, <code>CityApp()</code>; inside this function, we will call our <code>CityList</code> composable function, which <a id="_idIndexMarker118"/>has the list as a <a id="_idIndexMarker119"/>parameter. In addition, in this composable function, we will call <code>LazyColumn</code>, and <code>items</code> will be <code>CityCard(cities)</code>. See the <em class="italic">How it works</em> section for further explanation about <code>LazyColumn</code> and <code>items</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CityList(cityList: List&lt;City&gt;) {</pre><pre class="source-code">
    LazyColumn {</pre><pre class="source-code">
        items(cityList) { cities -&gt;</pre><pre class="source-code">
            CityCard(cities)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, let us construct our <code>CityCard(city)</code> composable function:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CityCard(city: City) {</pre><pre class="source-code">
    Card(modifier = Modifier.padding(10.dp),</pre><pre class="source-code">
    elevation = 4.dp) {</pre><pre class="source-code">
        Column {</pre><pre class="source-code">
            Image(</pre><pre class="source-code">
                painter = painterResource(</pre><pre class="source-code">
                    city.imageResourceId),</pre><pre class="source-code">
                contentDescription = stringResource(</pre><pre class="source-code">
                    city.nameResourceId),</pre><pre class="source-code">
                modifier = Modifier</pre><pre class="source-code">
                    .fillMaxWidth()</pre><pre class="source-code">
                    .height(154.dp),</pre><pre class="source-code">
                contentScale = ContentScale.Crop</pre><pre class="source-code">
            )</pre><pre class="source-code">
            Text(</pre><pre class="source-code">
                text = LocalContext.current.getString(</pre><pre class="source-code">
                    city.nameResourceId),</pre><pre class="source-code">
                modifier = Modifier.padding(16.dp),</pre><pre class="source-code">
                style = MaterialTheme.typography.h5</pre><pre class="source-code">
            )</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>When you <a id="_idIndexMarker120"/>run the <code>CityCardPreview</code> composable <a id="_idIndexMarker121"/>function, you should have a scrollable list, as seen in <em class="italic">Figure 2</em><em class="italic">.6</em>.</li>
</ol>
<div><div><img alt="Figure 2.7﻿ – A scrollable list of cities" src="img/Figure_2.7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7<a id="_idTextAnchor101"/> – A scrollable list of cities</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor102"/>How it works…</h2>
<p>In Kotlin, a list <a id="_idIndexMarker122"/>has two types, <strong class="bold">immutable</strong> and <strong class="bold">mutable</strong>. Immutable lists <a id="_idIndexMarker123"/>are items that cannot be modified, whereas <a id="_idIndexMarker124"/>mutable lists are items in the list that can be modified. To <a id="_idIndexMarker125"/>define a list, we can say a list is a generic ordered collection of elements, and these elements can be in the form of integers, strings, images, and so on, which is mostly informed by the type of data we want our lists to contain. For instance, in our example, we have a string and image helping identify our favorite cities by name and image.</p>
<p>In our <code>City</code> data class, we use <code>@StringRes</code>, and <code>@DrawableRes</code> in order to just pull this directly from the <code>res</code> folders for <code>Drawable</code> and <code>String</code> easily, and they also represent the ID for the images and string.</p>
<p>We created <code>CityList</code> and annotated it with the composable function and declared the list of city objects as our parameter in the function. A scrollable list in Jetpack Compose is made using <code>LazyColumn</code>. The main difference between <code>LazyColumn</code> and <code>Column</code> is that when using <code>Column</code>, you can only display small items, as Compose loads all items at once.</p>
<p>In addition, a column can only hold fixed composable functions, whereas <code>LazyColumn</code>, as the name suggests, loads the content as required on demand, making it good for loading more items when needed. In addition, <code>LazyColumn</code> comes with a scrolling ability inbuilt, which makes work easier for developers.</p>
<p>We also <a id="_idIndexMarker126"/>created a composable function, <code>CityCard</code>, where we import the <code>Card()</code> element from Compose. A card contains <a id="_idIndexMarker127"/>content and actions about a single object; in our example, for instance, our card has an image and the name of the city. A <code>Card()</code> element in Compose has the following inputs in its parameter:</p>
<pre class="source-code">
@Composable
fun Card(
    modifier: Modifier = Modifier,
    shape: Shape = MaterialTheme.shapes.medium,
    backgroundColor: Color = MaterialTheme.colors.surface,
    contentColor: Color = contentColorFor(backgroundColor),
    border: BorderStroke? = null,
    elevation: Dp = 1.dp,
    content: @Composable () -&gt; Unit
),</pre>
<p>This means you can easily model your card to the best fitting; our card has padding and elevation, and <a id="_idIndexMarker128"/>the scope has a column. In <a id="_idIndexMarker129"/>this column, we have an image and text, which helps describe the image for more context.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor103"/>See also</h2>
<p>There is more to learn about lists and grids in Compose; you can use this link to learn more: <a href="https://developer.android.com/jetpack/compose/lists">https://developer.android.com/jetpack/compose/lists</a>.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor104"/>Implementing your first tab layout with a view pager using Jetpack Compose</h1>
<p>In <a id="_idIndexMarker130"/>Android development, having a slide between pages is very common, with a significant use case being <a id="_idIndexMarker131"/>onboarding or even when you are trying to display specific data in a tabbed, carousel way. In <a id="_idIndexMarker132"/>this recipe, we will build a simple horizontal pager in Compose and see how we can utilize the new knowledge to b<a id="_idTextAnchor105"/>uild better and more modern Android apps.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor106"/>Getting ready</h2>
<p>In this example, we will build a horizontal pager that changes colors when selected to show the state is selected. We will look into states in <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and Using Hilt</em>, for better understanding. Open the <code>Compose Basics</code> project to get started.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor107"/>How to do it…</h2>
<p>Follow these steps to build your tab carousel:</p>
<ol>
<li>Add the following pager dependencies to <code>build.gradle(Module:app)</code>:<pre class="source-code">
implementation "com.google.accompanist:accompanist-pager:0.x.x"</pre><pre class="source-code">
implementation "com.google.accompanist:accompanist-pager-indicators:0.x.x"</pre><pre class="source-code">
implementation 'androidx.Compose.material:material:1.x.x'</pre></li>
</ol>
<p>Jetpack Compose offers <strong class="bold">Accompanist</strong>, a group of libraries that aims to support it with commonly required features by developers – for instance, in our case, the pager.</p>
<ol>
<li value="2">In the <a id="_idIndexMarker133"/>same project from previous recipes, let’s create a package and call it <code>pagerexample</code>; inside it, create a Kotlin file and call it <code>CityTabExample</code>; inside <a id="_idIndexMarker134"/>this file, create a composable function and call it <code>CityTabCarousel</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CityTabCarousel(){}</pre></li>
<li>Now, let <a id="_idIndexMarker135"/>us go ahead and build our <code>CityTabCarousel</code>; for our example, we will create a dummy list of pages with our cities from the previous project:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CityTabCarousel(</pre><pre class="source-code">
    pages: MutableList&lt;String&gt; = arrayListOf(</pre><pre class="source-code">
        "Spain",</pre><pre class="source-code">
        "New York",</pre><pre class="source-code">
        "Tokyo",</pre><pre class="source-code">
        "Switzerland",</pre><pre class="source-code">
        "Singapore",</pre><pre class="source-code">
        "Paris" )) {. . .}</pre></li>
<li>We will need to change the color of the button based on the state, and to do this; we need to use <code>LocalContext</code>, which provides the context we can use. We will also need to create a <code>var pagerState = rememberPagerState()</code>, which will remember our pager state, and finally, when <a id="_idIndexMarker136"/>clicked, we will need to move to the next city in our pager, which will be very helpful. Hence, go <a id="_idIndexMarker137"/>ahead and add the following to the <code>CityTabCarousel</code> composable function:<pre class="source-code">
val context = LocalContext.current</pre><pre class="source-code">
var pagerState = rememberPagerState()</pre><pre class="source-code">
val coroutineScope = rememberCoroutineScope()</pre></li>
<li>Now, let’s <a id="_idIndexMarker138"/>create the <code>Column</code> element and add our <code>ScrollableTabRow()</code> composable function:<pre class="source-code">
Column {</pre><pre class="source-code">
    ScrollableTabRow(</pre><pre class="source-code">
        selectedTabIndex = pagerState.currentPage,</pre><pre class="source-code">
        indicator = { tabPositions -&gt;</pre><pre class="source-code">
            TabRowDefaults.Indicator(...)</pre><pre class="source-code">
        },</pre><pre class="source-code">
        edgePadding = 0.dp,</pre><pre class="source-code">
        backgroundColor = Color(</pre><pre class="source-code">
            context.resources.getColor(R.color.white,</pre><pre class="source-code">
                null)),</pre><pre class="source-code">
    ) {</pre><pre class="source-code">
        pages.forEachIndexed { index, title -&gt;</pre><pre class="source-code">
            val isSelected =</pre><pre class="source-code">
                pagerState.currentPage == index</pre><pre class="source-code">
            TabHeader(</pre><pre class="source-code">
                title,</pre><pre class="source-code">
                isSelected,</pre><pre class="source-code">
                onClick = { coroutineScope.launch {</pre><pre class="source-code">
                pagerState.animateScrollToPage(index)</pre><pre class="source-code">
                } },</pre><pre class="source-code">
            )</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre></li>
<li>Add <code>Text()</code> and <code>TabHeader()</code> for <code>HorizontalPager</code>:<pre class="source-code">
    HorizontalPager(</pre><pre class="source-code">
        count = pages.size,</pre><pre class="source-code">
        state = pagerState,</pre><pre class="source-code">
        modifier = Modifier</pre><pre class="source-code">
            .fillMaxWidth()</pre><pre class="source-code">
            .fillMaxHeight()</pre><pre class="source-code">
            .background(Color.White)</pre><pre class="source-code">
    ) { page -&gt;</pre><pre class="source-code">
        Text(</pre><pre class="source-code">
            text = "Display City Name:</pre><pre class="source-code">
                ${pages[page]}",</pre><pre class="source-code">
            modifier = Modifier.fillMaxWidth(),</pre><pre class="source-code">
            style = TextStyle(</pre><pre class="source-code">
                textAlign = TextAlign.Center</pre><pre class="source-code">
            )</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre></li>
<li>Please <a id="_idIndexMarker139"/>download <a id="_idIndexMarker140"/>the entire <a id="_idIndexMarker141"/>code for this recipe by following the link provided in the <em class="italic">Technical requirements</em> section to add all the required code. Finally, run the <code>@Preview</code> function, and your app should look<a id="_idTextAnchor108"/> like <em class="italic">Figure 2</em><em class="italic">.8</em>.</li>
</ol>
<div><div><img alt="Figure 2.8 – Tabs with cities" src="img/Figure_2.8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Tabs with cities</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor109"/>How it works…</h2>
<p>Accompanist comes with some significant libraries – for example, System UI Controller, AppCompact Compose Theme Adapter, Material Theme Adapter, Pager, Drawable Painter, and Flow Layouts, just to mention a few.</p>
<p>The <code>ScrollableTabRow()</code> that we use inside <code>Column</code> in the <code>CityTabCarousel</code> function <a id="_idIndexMarker142"/>contains a row of tabs and helps display an indicator underneath the currently focused or selected tab. In addition, as the name suggests, it enables scrolling and you do not have to <a id="_idIndexMarker143"/>implement further scrolling tooling. It also places its tab offsets at the starting edge, and you <a id="_idIndexMarker144"/>can quickly scroll tabs that are off-screen, as you will see when you run the <code>@Preview</code> function and play around with it.</p>
<p>When we invoke <code>remember()</code>, in Compose, this means we keep any value consistent across recomposition. Compose provides this function to help us store single objects in memory. When we trigger our application to run, <code>remember()</code> stores the initial value. As the word means, it simply retains the value and returns the stored value so that the composable function can use it.</p>
<p>Furthermore, whenever the stored value changes, you can update it, and the <code>remember()</code> function will keep it. The next time we trigger another run in our app and recomposition occurs, the <code>remember()</code> function will provide the latest stored value.</p>
<p>You will also notice our <code>MutableList&lt;String&gt;</code> is indexed at each position, and we do this to check which is selected. It is within this Lambda that we call <code>TabHeader</code> and showcase <a id="_idIndexMarker145"/>the selected tab pages. <code>forEachIndexed</code> performs the given action on each element, <a id="_idIndexMarker146"/>providing a sequential index of elements. We also ensure when a user clicks on a specific <a id="_idIndexMarker147"/>tab, we are on the right page:</p>
<pre class="source-code">
onClick = { coroutineScope.launch { pagerState.animateScrollToPage(index) } }</pre>
<p><code>HorizontalPager</code> is a horizontally scrolling layout that allows our users to flip between items from left to right. It takes in several inputs, but we supply it with the count, state, and modifier to decorate it in our use case. In the Lambda, we display text – in our example, showing which page we are on, which helps when navigating, as shown in <em class="italic">Figure 2</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 2.9 – HorizontalPager" src="img/Figure_2.9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – HorizontalPager</p>
<p>Our <code>TabHeader</code> composable function has a <code>Box()</code>; a box in Jetpack Compose will always <a id="_idIndexMarker148"/>size itself to fit the content, and this is subject to the specified constraints. In our example, we <a id="_idIndexMarker149"/>decorate our <code>Box</code> with the selectable modifier, which configures components to be selectable <a id="_idIndexMarker150"/>as part of a mutually exclusive group, allowing each item to be selected only once at any given time.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Ensure your target and compile SDK targets 33. In addition, you will notice that most Accompanist’s libraries are experimental, which means they can change. There is debate on whether to use this in your production, so you should always consult your team on these APIs. To see the entire list of libraries supported by Accompanist, you can<a id="_idTextAnchor110"/> follow this link: <a href="https://github.com/google/accompanist">https://github.com/google/accompanist</a>.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor111"/>Implementing animations in Compose</h1>
<p>Animation in Android is the process of adding motion effects to views. This can be achieved using images, text, or even starting a new screen where the transition is noticeable <a id="_idIndexMarker151"/>using motion effects. Animations are vital in Modern Android Development since modern UIs are more interactive <a id="_idIndexMarker152"/>and adaptive to smoother experiences, and users like them.</p>
<p>Furthermore, applications these days are rated based on how great their UI and user experiences are, hence the need to ensure your application is modern and robust. In this example, we will build a collapsing toolbar, an animation that is widely used in the Android world.</p>
<h2 id="_idParaDest-67">Getti<a id="_idTextAnchor112"/>ng ready</h2>
<p>We will continue using the <code>Compose </code><code>Basics</code> project.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor113"/>How to do it…</h2>
<p>We will be building a collapsing toolbar in this recipe; there are other great animations you can now build utilizing the power of Compose. The power is in your hands:</p>
<ol>
<li>We will not need to add any dependency to this recipe. We already have everything in place. So, let us go ahead and create a new package and add a Kotlin file, <code>collapsingtoolbar</code>.</li>
<li>Inside the Kotlin file, go ahead and create a new composable function, <code>CollapsingTool</code><code> </code><code>BarExample()</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CollapsingToolbarExample() {...}</pre></li>
<li>We will have all our needed composable functions in a box; you can refer to the previous recipe to refresh your memory on that. We will also need to define the height at which we will start to collapse our view, and this can be based on preference; for our example, we can set <code>height</code> to <code>260.dp</code>:<pre class="source-code">
private val height = 260.dp</pre><pre class="source-code">
private val titleToolbar = 50.dp</pre></li>
<li>Let us <a id="_idIndexMarker153"/>go ahead and add more <a id="_idIndexMarker154"/>composable functions with dummy text data to display once we scroll our content. We can assume this app is used for reading information about the cities we display:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CollapsingToolbarExample() {</pre><pre class="source-code">
    val scrollState: ScrollState =</pre><pre class="source-code">
        rememberScrollState(0)</pre><pre class="source-code">
    val headerHeight = with(LocalDensity.current) {</pre><pre class="source-code">
        height.toPx() }</pre><pre class="source-code">
    val toolbarHeight = with(LocalDensity.current) {</pre><pre class="source-code">
        titleToolbar.toPx() }</pre><pre class="source-code">
    Box(</pre><pre class="source-code">
        modifier = Modifier.fillMaxSize()</pre><pre class="source-code">
    ) {</pre><pre class="source-code">
        CollapsingHeader(scrollState, headerHeight)</pre><pre class="source-code">
        FactsAboutNewYork(scrollState)</pre><pre class="source-code">
        OurToolBar(scrollState, headerHeight,</pre><pre class="source-code">
            toolbarHeight)</pre><pre class="source-code">
        City()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>In our <code>CollapsingHeader</code> function, we pass in the scroll state and the <code>headerHeight</code> a float. We decorate Box with a <code>Modifier.graphicLayer</code>, where we set a parallax effect to make it look good and presentable.</li>
<li>We also <a id="_idIndexMarker155"/>ensure we add a <code>Brush()</code> and set <a id="_idIndexMarker156"/>the colors we need, and specify where it should start:<pre class="source-code">
Box(</pre><pre class="source-code">
    Modifier</pre><pre class="source-code">
        .fillMaxSize()</pre><pre class="source-code">
        .background(</pre><pre class="source-code">
            brush = Brush.verticalGradient(</pre><pre class="source-code">
                colors = listOf(Color.Transparent,</pre><pre class="source-code">
                Color(0xFF6D38CA)),</pre><pre class="source-code">
                startY = 1 * headerHeight / 5</pre><pre class="source-code">
            )</pre><pre class="source-code">
        )</pre><pre class="source-code">
)</pre><pre class="source-code">
...</pre></li>
<li><code>FactsAboutNewYork</code> is not a complex composable function, just dummy text; then, finally, in <code>ToolBar</code>, we utilize <code>AnimatedVisibility</code> and declare our <code>enter</code> and <code>exit</code> transition:<pre class="source-code">
AnimatedVisibility(</pre><pre class="source-code">
    visible = showToolbar,</pre><pre class="source-code">
    enter = fadeIn(animationSpec = tween(200)),</pre><pre class="source-code">
    exit = fadeOut(animationSpec = tween(200))</pre><pre class="source-code">
) {</pre><pre class="source-code">
...</pre></li>
<li>Finally, run the <code>@Preview</code> function, and you will have a collapsible toolbar, which <a id="_idIndexMarker157"/>brings a smooth experience <a id="_idIndexMarker158"/>to your UI. In addition, get the entire code in the <em class="italic">Techn<a id="_idTextAnchor114"/>ical </em><em class="italic">requirements</em> section.</li>
</ol>
<div><div><img alt="Figure 2.10 – A collapsible toolbar" src="img/Figure_2.10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – A collapsible toolbar</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor115"/>How it works…</h2>
<p>In Modern Android Development, the Jetpack Compose library has many animation APIs that are available as composable functions. For example, you might want your image or text to fade in and fade out.</p>
<p>Hence, if you <a id="_idIndexMarker159"/>are animating appearance <a id="_idIndexMarker160"/>and disappearance, which can be for an image, a text, a radio group, a button, and so on, you can use <code>AnimatedVisibility</code> to achieve this. Otherwise, if you are swapping content based on the state and want your content to crossfade, you can use <code>CrossFade</code>, or <code>AnimatedContent</code>.</p>
<p><code>val headerHeight = with(LocalDensity.current) { height.toPx() }</code> provides density, which will be used to transform the DP and SP units, and we can use this when we provide the DP, which we will do and later convert into the body of our layout.</p>
<p>You can call the modifier and use <code>graphicsLayer</code> to update any of the content above it independently to minimize invalidated content. In addition, <code>graphicsLayer</code> can be used to apply effects such as scaling, rotation, opacity, shadow, or even clipping.</p>
<p><code>translationY = -scroll.value.toFloat() / 2f</code> basically sets the vertical pixel offset of the layer relative to its top bound. The default value is always zero, but you can customize this to fit your needs. We also ensure the gradient is only applied to wrapping the title in <code>startY = 1 * headerHeight / </code><code>5</code>.</p>
<p><code>EnterTransition</code> defines how the target content should appear; a target here can be an image, a text, or even a radio group. On the other hand, <code>ExitTransition</code> defines how the initial target content should disappear when exiting the app or navigating away.</p>
<p><code>AnimatedContent</code> offers <code>slideIntoContainer</code> and <code>slideOutOfContainer</code>, and it animates its content as it changes based on the target state, which is remarkable. In addition, you can also encapsulate a transition and make it reusable by creating a class that holds all your animation values and an <code>Update()</code>function, which returns an instance of that class.</p>
<p>It is also fair to mention that, as with the old ways of doing animation in Android using <code>MotionLayout</code>, there are many ways to do transitions in Jetpack Compose. For instance, in <em class="italic">Table 2.1</em>, you will see the different types of transitions:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">EnterTransition</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">ExitTransition</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>SlideIn</code></p>
</td>
<td class="No-Table-Style">
<p><code>SlideOut</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>FadeIn</code></p>
</td>
<td class="No-Table-Style">
<p><code>FadeOut</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>SlideInHorizontally</code></p>
</td>
<td class="No-Table-Style">
<p><code>SlideOutHorizontally</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>SlideInVertically</code></p>
</td>
<td class="No-Table-Style">
<p><code>SlideOutVertically</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ScaleIn</code></p>
</td>
<td class="No-Table-Style">
<p><code>SlaceOut</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ExpandIn</code></p>
</td>
<td class="No-Table-Style">
<p><code>ShrinkOut</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ExpandHorizontally</code></p>
</td>
<td class="No-Table-Style">
<p><code>ShinkHorizontally</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ExpandVertically</code></p>
</td>
<td class="No-Table-Style">
<p><code>ShrinkVertically</code></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – A table showing different types of transitions</p>
<p>In addition, you <a id="_idIndexMarker161"/>can add your own custom <a id="_idIndexMarker162"/>animation effects in Jetpack Compose beyond the already built-in enter and exit animations by simply accessing the elemental transition instance via the <code>transition</code> property inside the content lambda for <code>AnimatedVisibility</code>. You will also notice any animation states that have been added<a id="_idTextAnchor116"/>.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor117"/>Implementing accessibility in Jetpack Compose</h1>
<p>As we build <a id="_idIndexMarker163"/>Android applications, we need to always have accessibility in the back of our minds because this makes technology inclusive and ensures all people with special needs are considered as we build applications.</p>
<p>Accessibility should be a team effort. If well handled, the advantages include having more people using your application. An accessible application is better for everyone. You also reduce the risk of being sued.</p>
<p>There are different types of disabilities, such as visual, aural, and motor impairments. If you open your <strong class="bold">Accessibility</strong> settings, you will see the different options that people with disabilities use on their devices<a id="_idTextAnchor118"/>.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor119"/>Getting ready</h2>
<p>Like previous recipes, we will continue using our sample project from previous recipes; you do not need to install anythin<a id="_idTextAnchor120"/>g.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor121"/>How to do it…</h2>
<p>For this <a id="_idIndexMarker164"/>recipe, we will describe the visual elements, which are very vital:</p>
<ol>
<li>By default, when we add an <code>Image</code> function, you might notice that it has two parameters, a painter for the image and a content description to visually describe the element:<pre class="source-code">
Image(painter = , contentDescription = )</pre></li>
<li>When you set the content description to <code>null</code>, you indicate to the Android framework that this element does not have an associated action or state. So, let’s go ahead and update all our content descriptions:<pre class="source-code">
Image(</pre><pre class="source-code">
    modifier = modifier</pre><pre class="source-code">
    painter = painterResource(city.imageResourceId),</pre><pre class="source-code">
    contentDescription =</pre><pre class="source-code">
        stringResource(R.string.city_images))</pre><pre class="source-code">
)</pre></li>
<li>Make sure you add the string to the <code>string </code><code>res</code> folder:<pre class="source-code">
&lt;string name="city_images"&gt;City Images&lt;/string&gt;</pre></li>
<li>So, go ahead and ensure you add a content description for every image that requires it.</li>
<li>In Compose, you can easily indicate whether a text is a heading by specifying this in the modifier and using semantics to show that that is a heading. Let’s add that in our decorated text:<pre class="source-code">
...</pre><pre class="source-code">
modifier = Modifier</pre><pre class="source-code">
    .padding(18.dp)</pre><pre class="source-code">
    .semantics { heading() }</pre><pre class="source-code">
...</pre></li>
<li>Finally, we can go ahead and compile, run, and test whether our application is accessible by following this link on how to manually test using talkback or using automated testing: <a href="https://developer.android.com/guide/topics/ui/accessibility/testing">https://developer.android.com/guide/topics/ui/accessibility/testing</a>.</li>
</ol>
<h2 id="_idParaDest-73"><a id="_idTextAnchor123"/>How it works…</h2>
<p>Jetpack Compose <a id="_idIndexMarker165"/>is built with accessibility in mind; that is to say, material components such as <code>RadioButton</code>, <code>Switch</code>, and so on have their size internally set, but only when these components can receive user interactions.</p>
<p>Furthermore, any screen element that users can click on or interact with should be large enough for reliable interaction. A standard format sets these elements to a size of at least <code>48dp</code> for <code>width</code> and <code>height</code>.</p>
<p>For example, <code>Switch</code> has its <code>onCheckChanged</code> parameter set to a non-null value, including width and height of at least <code>48dp</code>; we would have <code>CheckableSwitch()</code>, and <code>NonCheckableSwitch()</code>:</p>
<pre class="source-code">
@Composable
fun CheckableSwitch(){
    var checked by remember { mutableStateOf(false) }
    Switch(checked = checked, onCheckedChange = <strong class="bold">{} </strong>)
}
@Composable
fun NonCheckableSwitch(){
    var checked by remember { mutableStateOf(false) }
    Switch(checked = checked, onCheckedChange = null )
}</pre>
<p>Once you have <a id="_idIndexMarker166"/>implemented accessibility in your applications, you can easily test it by installing analysis tools from the Play Store – <code>uiautomatorviewer</code> and <code>lint</code>. You can also automate your tests using Espresso or Roboelectric to check for accessibility support.</p>
<p>Finally, you can manually test your application for accessibility support by going to <strong class="bold">Settings</strong>, then to <strong class="bold">Accessibility</strong>, and selecting <strong class="bold">talkback</strong>. This is found at the top of the screen; then press <strong class="bold">On</strong> or <strong class="bold">Off</strong> to turn the talkback functionality on or off. Then, navigate to the dialog confirmation, and click <strong class="bold">OK</strong> to confirm permis<a id="_idTextAnchor124"/>sion.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor125"/>There’s more…</h2>
<p>There is more regarding accessibility that developers should consider as they build their applications, including a state with which they should be able to notify their users on whether a <code>Switch</code> button has been selected. This ensures their applications support accessibility and are up to stan<a id="_idTextAnchor126"/>dard.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor127"/>Implementing declarative graphics using Jetpack Compose</h1>
<p>In <a id="_idIndexMarker167"/>Android development, your <a id="_idIndexMarker168"/>application might have a different need, and this need might be building your own custom graphics for an intended purpose. This is very common in many stable and large Android code bases. The essential part of any custom view is its appearance. Furthermore, custom drawing can be a very easy or complex task based on the needs of your application. In Modern Android Development, Jetpack Compose makes it easier to work with custom graphics simply because the demand is immense. For example, many applications may need to control what happens on their screen accurately; the use case might be as simple as putting a circle on the screen or building more complex graphics to handle known use<a id="_idTextAnchor128"/> cases.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor129"/>Getting ready</h2>
<p>Open the <code>Compose Basics</code> project to get started with this recipe. You can find the entire code in the <em class="italic">Technical </em><em class="italic">requirements</em> s<a id="_idTextAnchor130"/>ection.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor131"/>How to do it…</h2>
<p>In our <a id="_idIndexMarker169"/>project, let us create a <a id="_idIndexMarker170"/>new package and call it <code>circularexample</code>; inside this package, create a Kotlin file and call it <code>DrawCircleCompose</code>; inside the file, create a <code>CircleProgressIndicatorExample</code> composable function. You will not need to import anything for now:</p>
<ol>
<li>Let us now go ahead and define our composable function. Since, in our example, we want to display a tracker in a circle, we need to float to fill in our circle. We will also define the colors to help us identify the progress:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun CircleProgressIndicatorExample(tracker: Float, progress: Float) {</pre><pre class="source-code">
    val circleColors = listOf(</pre><pre class="source-code">
        colorResource(id = R.color.purple_700),</pre><pre class="source-code">
        colorResource(id = R.color.teal_200)</pre><pre class="source-code">
    )</pre></li>
<li>Now, let’s call <code>Canvas</code> to draw our arc. We give our circle the size of <code>200.dp</code> with <code>8.dp</code> padding. Where it gets interesting is in <code>onDraw</code>. <code>startAngle</code> is set at <code>-90</code>; the start angle is set in degrees to understand it better.</li>
</ol>
<p>The zero represents 3 o’clock, and you can also play around with your start angle to see how <code>-90</code> translates. The <code>useCenter</code> Boolean indicates whether arc is <a id="_idIndexMarker171"/>to close the center <a id="_idIndexMarker172"/>of the bounds. Hence, in our case, we set it to <code>false</code>. Then, finally, we set the <code>style</code>, which can be anything based on our preference:</p>
<pre class="source-code">
Canvas(
    modifier = Modifier
        .size(200.dp)
        .padding(8.dp),
    onDraw = {
        this.drawIntoCanvas {
            drawArc(
                color = colorSecondary,
                startAngle = -90f,
                sweepAngle = 360f,
                useCenter = false,
                style = Stroke(width = 55f, cap =
                    StrokeCap.Butt),
                size = Size(size.width, size.height)
            )
colorResource(id = R.color.teal_200)
 . . .</pre>
<ol>
<li value="3">We have just drawn the first part of the circle; now, we need to draw the progress with a <code>Brush</code>, which utilizes <code>linearGradient</code>:<pre class="source-code">
drawArc(</pre><pre class="source-code">
    brush = Brush.linearGradient(colors =</pre><pre class="source-code">
        circleColors),</pre><pre class="source-code">
    startAngle = -90f,</pre><pre class="source-code">
    sweepAngle = progress(tracker, progress),</pre><pre class="source-code">
    useCenter = false,</pre><pre class="source-code">
    style = Stroke(width = 55f, cap =</pre><pre class="source-code">
        StrokeCap.Round),</pre><pre class="source-code">
    size = Size(size.width, size.height)</pre><pre class="source-code">
) . . .</pre><pre class="source-code">
. . .</pre></li>
<li>Finally, our <code>progress</code> function <a id="_idIndexMarker173"/>tells <code>sweepAngle</code> where our <a id="_idIndexMarker174"/>progress should be based on our tracking abilities:<pre class="source-code">
private fun progress(tracker: Float, progress: Float): Float {</pre><pre class="source-code">
    val totalProgress = (progress * 100) / tracker</pre><pre class="source-code">
    return ((360 * totalProgress) / 100)</pre><pre class="source-code">
}</pre><pre class="source-code">
. . .</pre></li>
<li>Run the <code>preview</code> function, and you should see a circular progress indicator as in <em class="italic">Figure 2</em><em class="italic">.11</em>.</li>
</ol>
<div><div><img alt="Figure 2.11 – Showing a circular progress image" src="img/Figure_2.11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Showing a circular progress image</p>
<p class="callout-heading">Im<a id="_idTextAnchor132"/>portant note</p>
<p class="callout">The <code>Canvas</code> composable function uses <code>Canvas</code> to Compose an object, which, in turn, creates and helps manage a view-base Canvas. It is also important to mention that Compose makes it easier for developers by maintaining the state and creating and freeing any necessary hel<a id="_idTextAnchor133"/>per objects.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor134"/>How it works…</h2>
<p>Generally, <code>Canvas</code> allows you to specify an area on the screen where you want to draw. In the <a id="_idIndexMarker175"/>old way of building <a id="_idIndexMarker176"/>Android applications, we also utilized <code>Canvas</code>, and now in Compose, it is more powerful and valuable.</p>
<p><code>linearGradient</code> create a linear gradient with the specified colors along the provided start and end coordinates. For our example, we give it simple colors that come with the project.</p>
<p>The drawing functions have instrumental default parameters that you can use. For instance, by default, <code>drawArc</code>, as you can see, takes in several inputs:</p>
<div><div><img alt="Figure 2.12 – Showing what drawArc takes as input" src="img/Figure_2.12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Showing what drawArc takes as input</p>
<p><code>sweepAngle</code> in our example, which is the size of the arc in the degree that is drawn clockwise relative to <code>startAngle</code>, returns a function that calculates progress. This function <a id="_idIndexMarker177"/>can be customized to <a id="_idIndexMarker178"/>fit your needs. In our example, we pass in a tracker and progress and return a float.</p>
<p>Since we want to fill the circle, we create <code>cal totalProgress</code>, which checks <em class="italic">progress * 100</em> divided by the tracker, and we return <em class="italic">360 (circle) * our progress divided by 100</em>. You can customize this function to fit your needs. You can also write code to listen to where you are and make the progress move based on your input value from a listen<a id="_idTextAnchor135"/>er you create.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor136"/>There’s more…</h2>
<p>There is more you can do with <code>Canvas</code> and custom drawing. One amazing way to enhance your knowledge on the topic is to look into old solutions posted on Stack Overflow, such as drawing a heart or any other shape, and see whether you can do the same in Compose.</p>
</div>
</body></html>