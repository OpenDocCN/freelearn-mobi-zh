["```swift\nvector<string> words {\"Packt\", \"Packer\", \"Unpack\", \"packing\",\n\"Packt2\", \"Alpacca\"};\nstringprevKey;\nWriteOptionssyncW; syncW.sync = true;\nWriteBatchwb;\nfor (auto key : words) {\n  wb.Put(key, prevKey + \"\\tsome more content\");\n  prevKey = key;\n}\nassert(db->Write(syncW, &wb).ok() );\n```", "```swift\nIterator* idb = db->NewIterator(ropt);\nfor (idb->SeekToFirst(); idb->Valid(); idb->Next())\ncout<<idb->key() <<endl;\n```", "```swift\nfor (idb->SeekToLast(); idb->Valid(); idb->Prev())\ncout<<idb->key() <<endl;\n```", "```swift\ncout<<idb->key() << \" \" <<idb->value()  <<endl;\n```", "```swift\nVoid listKeysStarting(Iterator* idb, const Slice& prefix)\n{\ncout<< \"List all keys starting with \"\n<<prefix.ToString() <<endl;\nfor (idb->Seek(prefix);\nidb->Valid() &&idb->key().starts_with(prefix);\nidb->Next())\ncout<<idb->key() <<endl;\n}\n```", "```swift\nVoid listBackwardsKeysStarting(Iterator* idb, const Slice& prefix)\n{\ncout<< \"List all keys starting with \"\n<<prefix.ToString() << \" backwards \" <<endl;\nconst string keyAfter = prefix.ToString() + \"\\xFF\";\nidb->Seek(keyAfter);\nif (idb->Valid())\nidb->Prev(); // step to last key with actual prefix\nelse // no key just after our range, but\nidb->SeekToLast(); // maybe the last key matches?\nfor(;idb->Valid() &&idb->key().starts_with(prefix);\nidb->Prev())\ncout<<idb->key() <<endl;\n}\n```", "```swift\nVoid listKeys Between(Iterator* idb,\nconst Slice&startKey, const Slice&endKey)\n{\ncout<< \"List all keys >= \" <<startKey.ToString()\n<< \" and < \" <<endKey.ToString() <<endl;\nfor (idb->Seek(startKey);\nidb->Valid() &&idb->key().compare(endKey) < 0; \nidb->Next())\ncout<<idb->key() <<endl;\n}\n```", "```swift\nstring nextKey;\nif (db->Get(ropt, firstkey, &nextKey).IsNotFound())\nreturn firstkey + \" ** not found **\";  \nstring ret = firstkey;\nfor (;;) {\n  string key = value.substr(0, value.find(\"\\t\") );     \n  if (db->Get(ropt, key, &value).IsNotFound())\n  break;\n  ret += \" -> \" + key;\n}\nreturn ret;\n```"]