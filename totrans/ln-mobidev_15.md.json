["```kt\nprivate GoogleCloudMessaging gcm; \n... \nString regid = gcm.register(FlavorConstants.PushConfiguration.GoogleConfiguration.  \n GCM_PROJECT_NUMBER); \nLog.i(getClass().toString(), \"Obtained RegId from GCM : \" + regid); \n```", "```kt\n func registerForPushNotifications(){         \n        print (\"PN - register for PN\")         \n        let center = UNUserNotificationCenter.current() \n        center.delegate = self         \n        center.requestAuthorization(options:[.badge, .alert, .sound]) { (granted, error) in \n            if error == nil { \n                print (\"PN - No error\")                \n            } \n            else{ \n                print (\"PN - Error \")                 \n            } \n            if (!granted){ \n                print (\"PN - Not granted\") \n            } \n            else{ \n                print (\"PN - granted\") \n            } \n\n            guard granted else { return } \n            self.getNotificationSettings() \n        } \n    } \n\n    func getNotificationSettings() { \n        UNUserNotificationCenter.current().getNotificationSettings { (settings) in \n            print(\"Notification settings: \\(settings)\") \n            guard settings.authorizationStatus == .authorized else { return } \n            UIApplication.shared.registerForRemoteNotifications() \n        } \n    } \n\n func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) \n    { \n        let installation = PFInstallation.current() \n        installation?.setDeviceTokenFrom(deviceToken) \n        installation?.saveInBackground()         \n        PFPush.subscribeToChannel(inBackground: \"global\") { (result, error) in \n            print(\"PN - subscribed to global\") \n        } \n    } \n\n```", "```kt\npublic class PushHandler extends NotificationsHandler { \n\n    Context ctx; \n\n    @Override \n    public void onReceive(Context context, Bundle bundle) { \n        ctx = context; \n        String nhMessage = bundle.getString(\"message\"); \n        Parcelable parselableObject = bundle.getParcelable(\"parcel\");            \n       consumeNotification(nhMessage,parselableObject); \n    } \n\n    private void consumeNotification(String msg, Parcelable parselableObject) { \n\n        Log.i(this.getClass().toString(), \"Consume notification\");\n         Log.i(this.getClass().toString(), \"Notification msg = \"+msg); \n\n        if (parselableObject != null) {\n             Log.i(this.getClass().toString(), \"Consume has parcel\"); \n        } \n\n        displayNotificationMessage(ctx, \"Message\", msg,msg); \n    } \n\n    public static void displayNotificationMessage(Context context, String title, String contentText,  \n      String tickerText){ \n        displayNotificationMessage(context,title,contentText,tickerText,null); \n    } \n\n    public static void displayNotificationMessage(Context context, String title, String contentText, String tickerText, Parcelable parcelableObject){ \n\n... \n        NotificationCompat.Builder builder = new NotificationCompat.Builder(context); \n        Uri soundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION); \n\n        Bundle extras = new Bundle(); \n        extras.putParcelable(\"parcel\", parcelableObject); \n\n        Notification notification = builder.setContentTitle(title) \n                .setContentText(contentText) \n                .setTicker(tickerText) \n                .setSmallIcon(R.mipmap.appicon) \n                .setContentIntent(pendingIntent) \n                .setPriority(Notification.PRIORITY_HIGH) \n                .setSound(soundUri) \n                .setVibrate(new long[]{0, 500}) \n                .setExtras(extras) \n                .build(); \n\n        NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); \n        notificationManager.notify(0, notification); \n    } \n```", "```kt\n    func application(_ application: UIApplication,  didFailToRegisterForRemoteNotificationsWithError error: Error) { \n        print(\"Failed to register: \\(error)\") \n    } \n\n    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) { \n\n        print (\"PN - willPresent\")         \n        let userInfo = notification.request.content.userInfo as NSDictionary \n        let body = notification.request.content.body \n        for (key, value) in userInfo { \n            print(\"userInfo: \\(key) -> value = \\(value)\") \n        } \n        if ... { \n                print (\"PN - completion handler silent\") \n                completionHandler([]) \n            } \n            else{ \n                print (\"PN - completion handler alert badge sound\") \n                completionHandler([.alert,.badge, .sound]) \n            } \n        } \n       ... \n    } \n\n    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) { \n        print (\"PN - Did receive\") \n        ... \n        completionHandler() \n    }\n```", "```kt\n Parse.Push.send({ channels: \"channel or channels\", data: { title: \"title\", sound: 'default',  badge: 2, alert: \"message\", extraParam: \"something\" } },  \n    {   success: function () {   response.success(\"ok\");   }, \n        error: function (error) { response.success(\"nok: \" + error); }, \n        useMasterKey: true \n    }); // push send \n```", "```kt\ndata: { title: \"title\", sound: 'default',  badge: 2, alert: \"message\", extraParam: \"something\" }  \n```"]