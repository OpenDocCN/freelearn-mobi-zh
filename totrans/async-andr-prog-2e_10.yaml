- en: Chapter 10. Network Interactions with GCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, in order to update any kind of dynamic data that our examples
    required, we explicitly initiated a connection to a remote server, waking up the
    network radio and other resources required to perform the network operation. The
    application might fetch either fresh data or exactly the same data if nothing
    has changed since the last fetch.
  prefs: []
  type: TYPE_NORMAL
- en: Although this communication-fetching model might work for most use cases, it
    could consume battery resources and internet bandwidth in vain when the data does
    not change often.
  prefs: []
  type: TYPE_NORMAL
- en: This technique, commonly known as **data polling**, may also increase the server
    load when a great number of clients try to fetch or verify whether any data has
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the polling technique is **data pushing**. In this technique,
    the server tells the application when new data is available or when the data has
    changed. When the data consumer (application) gets notified, it will initiate
    a new interaction with the server to retrieve the fresh data.
  prefs: []
  type: TYPE_NORMAL
- en: Since fewer synchronizations are required, it will lead to fewer network interactions,
    which will lead to less battery resources consumed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce you to **Google Cloud Messaging** (**GCM**),
    a service delivered by Google Play Services that will help you to build applications
    that require data pushing or pulling messaging services. GCM delivers a framework
    to deliver push messages to multiple devices or group of devices in a battery-efficient
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Polling versus pushing messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to setup and configure **GCM** for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving downstream messages from the server with GCM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving downstream messages from GCM topic streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending upstream messages to your server with GCM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering one shot and periodic network tasks with `GcmNetworkManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to GCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since every network interaction with your server could wake the wireless radio
    interface up, on a device with limited energy resources it is crucial to minimize
    the number of times that your application tries to hit the network to sync data.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that require regular updates and up-to-date data, like a messaging
    application, polling in the background by setting an alarm for every x minutes,
    then waking up the radio and downloading your data could drain the battery in
    a matter of hours.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to GCM](img/Image_B05062_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1 - Polling data from remote server
  prefs: []
  type: TYPE_NORMAL
- en: The GCM offers us a platform to efficiently deliver notifications, with less
    than 4096 bytes, when there is new data to be consumed or to synchronize. This
    interaction model reduces the network interactions, and there is no need to constantly
    poll the server to discover data changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to GCM](img/Image_B05062_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Beyond the ability to dispatch downstream messages from your server (using HTTP
    or XMPP protocol messages) to your Android application, the GCM framework provides
    a battery-efficient communication channel to dispatch upstream messages from your
    application to a XMPP server managed by you.
  prefs: []
  type: TYPE_NORMAL
- en: The GCM client that runs on the Android device provides a reliable and battery-efficient
    connection between your GCM server and the device. The connection maintained is
    highly optimized to minimize bandwidth and battery consumption. Therefore, the
    use of GCM for applications that require high-frequency network data updates,
    such as real-time messaging, is extremely recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond that, when the device is offline and is not able to contact the GCM service,
    the platform is able to retain the messages in queues until a maximum number of
    20 queued messages, and ensure the delivery of the messages as soon as the device
    goes online again.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and configuring GCM for your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To setup Google Cloud Messaging on your application you will have to register
    with GCM and set up a Google API Project on your Google Developers Console ([https://developers.google.com/mobile/add](https://developers.google.com/mobile/add)):'
  prefs: []
  type: TYPE_NORMAL
- en: First pick **Android App Platform**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify your application name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example: `Asynchronous Android`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Supply your application package name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example: `com.packpublishing.asynchronousandroid`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Cloud Messaging Services** and **Enable Google Cloud Messaging**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the configuration files and download the JSON configuration file `google-services.json`
    to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your credentials (Server APIKey, SenderId) to authenticate with the GCM
    platform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have registered your application with GCM, get the `google-services.json`
    configuration file and copy the file into the `app/` or `mobile/` directory of
    your Android Studio Project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the Google Play Services SDK to your project level and app-level
    `<PROJECT_DIRECTORY>/build.gradle` file and rebuild your Android Studio Project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the application module build `< PROJECT_DIRECTORY >/app/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To use GCM on your Android application you need to have a device with Android
    API 8 or higher with the Google Play Store installed, or a device with API level
    9 if you want to use the new GCM features delivered by the Google Play Services.
  prefs: []
  type: TYPE_NORMAL
- en: With the Google Services library dependencies declared on our build files, we
    can start to bootstrap the GCM infrastructure on our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use GCM in your application, you have to register for the following permissions
    on your application `AndroidManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that you should replace `<Package>` with your unique application package,
    such as `com.packpublishing.asynchronousandroid`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the GCM Receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to receive Broadcast Intents from the GCM Platform, we will add the
    GCM `GcmReceiver`, a `WakefulBroadcastReceiver` subclass provided by the GCM library,
    to our `AndroidManifest.xml` application element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This `BroadcastReceiver` receives an Intent when a new downstream message arrives
    from the GCM Server, so it is required to subscribe to Intents with action `com.google.android.c2dm.intent.RECEIVE`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a registration service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to receive downstream messages from the GCM platform, the Android application
    requires a registration token. The registration token, a secret ID issued by the
    GCM server, must be obtained to identify the device on the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a registration token we will define an `IntentService` that will
    retrieve the registration token using Instance ID API. Let''s start by defining
    it on the `AndroidManisfest.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `IntentService` subclass will retrieve a new registration token in the background
    using the `SenderId` returned from the GCM registration. Once the new registration
    token is received, it will be dispatched to our servers to be stored safely. The
    token is our pass key to access the GCM service, so, in order to submit notifications,
    the server has to present this token. On the device, the registration will be
    implicitly stored securely by the GCM framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once a registration token is received with success, we update the default application
    shared preferences file, setting the `SENT_TOKEN_TO_SERVER` to `true`. This property
    indicates whether the generated token has been sent to your server. If the property
    is false, we send the token to your server. Otherwise, your server should have
    already received the token.
  prefs: []
  type: TYPE_NORMAL
- en: If an exception happens while fetching the new token or updating our registration
    token on our server during the `sendRegistrationToServer` call, we will set the
    `SENT_TOKEN_TO_SERVER` as `false`, ensuring that a new attempt is going be executed
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Though you would want to persist the registration to your backend server, for
    now, we will print the registration token to the log output. You can pick the
    value using `logcat` for future use in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: InstanceID listener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first time we get `InstanceID` through `InstanceID.getInstance`, a UUID
    Application identifier is generated to identify the application on the GCM platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instance ID may become invalid, if:'
  prefs: []
  type: TYPE_NORMAL
- en: The application explicitly deletes Instance ID (`Instance.deleteToken`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The device is factory reset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application is uninstalled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user clears application data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To receive a notification, each time the registration token requires a refresh,
    we will create a service that extends `InstanceIDListenerService`, registers to
    `com.google.android.gms.iid.InstanceID` intent, and includes it on the `AndroidManifest.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `onTokenRefresh` callback will be invoked when the registration token needs
    to be refreshed. This may occur if the security of the previous token has been
    compromised, such as with a suspicious use of the token. This procedure is usually
    initiated by the `instanceID` provider.
  prefs: []
  type: TYPE_NORMAL
- en: Instance ID API is used to manage security tokens that authorize your application
    or your server to interact with the GCM Service.
  prefs: []
  type: TYPE_NORMAL
- en: '![InstanceID listener](img/Image_B05062_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Beyond the creation of new tokens, the `InstanceID` singleton instance is able
    to delete tokens or even invalidate an `InstanceID`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Receiving downstream messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the basic blocks required to set up the GCM client already in place, in
    our first GCM example we will send a simple downstream message through the GCM
    Platform and print it as a notification on the Android Notification drawer.
  prefs: []
  type: TYPE_NORMAL
- en: To handle GCM messages, we will have to implement a service that extends from
    `GcmListenerService` and override the `onMessageReceived(String,Bundle)` method.
    Since `GcmReceiver` extends `WakefulBroadcastReceiver`, it is guaranteed that
    the CPU is going to be awake until the service completes the delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Our `GcmListenerService` subclass will receive a message from GCM and create
    an Android Notification as soon as it receives it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to register our `GcmListenerService` service class in the `AndroidManifest.xml`
    registering the service to receive the `com.google.android.c2dm.intent.RECEIVE`
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To instigate the initial registration with GCM, we will create an Activity that
    will start the `RegistrationService's` `IntentService` to retrieve the required
    token. However, before we try to retrieve the token, we will have to check if
    the Google Play Services is available on the device, and that the version installed
    on this device is no older than the one required by this client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by implementing the `Activty.onCreate` method, triggering
    interaction with the GCM platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we start the registration service, `checkPlayServices` will verify if
    the Google Play Services is installed on the device. If the service is not available,
    a dialog box is shown to the user that allows the users to download it from the
    Play Store or enable it on the device system settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When the `isGooglePlayServicesAvailable` returns success, we return true from
    the function and initiate the registration service.
  prefs: []
  type: TYPE_NORMAL
- en: When the function returns an error that can be resolved by the user, such as
    `SERVICE_VERSION_UPDATE_REQUIRED`, a localized dialog is shown to the user to
    correct the problem. The dialog could redirect the user to the Play Store if Google
    Play Services is out of date or missing, or to system settings if Google Play
    Services is disabled on the device.
  prefs: []
  type: TYPE_NORMAL
- en: If the returned cannot be solved by a user action, we simply finish the current
    `Activity` and print a log message because the device will not be able to register
    in GCM and receive the downstream message.
  prefs: []
  type: TYPE_NORMAL
- en: Yes! We finished the application GCM bootstrap, and as soon as we start the
    `Activity` and register with GCM, the device will be ready to receive downstream
    messages from GCM.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that our registration service will print a registration token to the
    log output, so don't forget to note it when you run the `MyChatActivity` for the
    first time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To interact with GCM you could set up an HTTP or XMPP backend server that uses
    the server credentials to connect to the GCM Service. For simplicity and testing
    we will build and submit HTTP messages directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a downstream message to our device we will have to send HTTP POST a
    message with a JSON object in the payload, setting the field to `to` with our
    noted registration token and a `data` object field with our custom notification
    properties: `title` and `body` and `type.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a JSON-formatted message that will generate an Android notification
    as soon as `NotificationGCMHandler` receives it from GCM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To submit HTTP messages to the GCM platform, you can use the curl command or
    use the chrome web application Postman ([http://www.getpostman.com/](http://www.getpostman.com/)).
    Here is the curl command that will submit the previous message to GCM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to replace the `<Server API Key>` with the API key generated on
    the Google Cloud Console registration and replace `<DeviceRegistrationToken>`
    with the token generated for your device. Notice that the downstream data messages
    have a maximum 4KB payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well with your GCM setup, your data object properties are
    passed to your `onMessageReceived()` method in the data bundle object and the
    GCM service will send you back a HTTP Response (200) with a message body similar
    to the one below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Receiving messages from topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The downstream messages allow us to send send short (4KB) messages to alert
    the user of new updates, new content or even reminders.
  prefs: []
  type: TYPE_NORMAL
- en: A downstream message is a one-way communication channel where the users can
    receive messages, but they cannot respond to them directly or take any immediate
    action.
  prefs: []
  type: TYPE_NORMAL
- en: To build interactive experiences, such as a chat system, we will have to support
    a bidirectional communication where the user can receive downstream messages and
    also send upstream messages to other devices or groups of devices.
  prefs: []
  type: TYPE_NORMAL
- en: In our next example, we will build a simple group messaging system based on
    the GCM upstream messaging and topic messaging features. The group messaging system
    will allow multiple devices to publish text messages to a shared message channel.
  prefs: []
  type: TYPE_NORMAL
- en: GCM topic messaging allows your backend server to send a message to devices
    that have a particular topic. Once the GCM receives a message to a particular
    topic, it will route and deliver the message to the subscribed devices transparently
    using the list of subscribed devices managed on the GCM platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'A topic is identified by the name that follows the next regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To start receiving messages related to a particular topic name, a GCM-registered
    client application will have to subscribe in GCM with its own registration token
    and the desired topic stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will update our `RegistrationIntentService` to subscribe our
    application to the `"/topics/forum"` message stream using the registration token
    received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To unsubscribe the device from the GCM "forum" topic, we can invoke `GcmPubSub`'s
    `unsubscribe()` with the registration token and topic name.
  prefs: []
  type: TYPE_NORMAL
- en: The topic messages are delivered to our `GcmListenerService` (`NotificationGCMHandler`)
    in the same way the push notification GCM messages were delivered in our previous
    example. The topic messages are delivered to our application, with the `from`
    field storing the topic name `/topics/forum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will give you an idea of what a typical topic message for our topic could
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The data object field is the field on the message that we might use to pass
    custom properties to the application. In our example, it carries information about
    the username and text written by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Next, and taking into account that `NotificationGCMHandler` will receive the
    topic messages sent from the GCM, we will update it to handle the topic messages
    received, and broadcast each topic message to any local `BroadcastReceiver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `NotificationGCMHandler` will simply wrap the topic messages on the Intents
    and dispatch them to the local Activity within your process. This asynchronous
    communication technique, already explained in previous chapters, is faster and
    more secure as your messages don''t leave your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With our `GcmListenerService` forwarding the messages received from our messaging
    topic, it is time to build the Activity that is going to display the messages
    received and publish messages to the group chat using the GCM upstream messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the work done in the previous chapter, we will create a `MessagingActivity`
    that will also verify that Google Play Services is available and start the `RegistrationIntentService`
    when no registration token is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To receive and display the topic messages in our Activity, we will create an
    anonymous `BroadcastReceiver` subclass that dynamically registers and unregisters
    the reception of local Intents whose action is `MSG_DELIVERY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we only want to receive the topic messages when the Activity is in the
    foreground, we will register and unregister to the local broadcasts on `onResume`
    and `onPause` callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: All that remains is to display our group chat messages on the UI and implement
    the `BroacastReceiver` that receives the broadcast Intents and updates the UI
    with the message username and text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To process the Broadcast Intent, we must override the `onReceive` method of
    `BroacastReceiver` in order to receive local `Intent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you submit a topic message to the GCM using the following `curl` command,
    you will see a new message popping up on the UI `TextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Sending upstream messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we are able to receive the chat group messages, we are not able to
    interact with the message stream from the application. Additionally, to send and
    process upstream messages with the GCM platform, an application server that implements
    the XMPP Connection Server protocol is required to connect to the GCM servers
    and receive upstream XMPP messages.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with our group messages we built a very basic XMPP server that processes
    the upstream messages from the device and forwards the message to the topic message.
  prefs: []
  type: TYPE_NORMAL
- en: The basic XMPP Server source code is available from the Packt Publishing website.
    Grab it from the Packt website, and, before you run it, update the static fields
    with your `SenderID` and your `ServerKey` in the `GCMServer.java` class file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The server will connect to the GCM platform, initiate a XMPP session, and process
    all the messages delivered to the `<SENDER_ID>@gcm.googleapis.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate an upstream message, we created a `EditText` on the UI and created
    a button that, once fired, will send an upstream message. To send an upstream
    message on the GCM platform, the application needs to provide the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The address of our server on the GCM platform: `<SENDER_ID>@gcm.googleapis.com`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique message identifier (`message_id`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message payload with a custom key/value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s update `MessagingActivity` to send the upstream message based on
    the `EditText` input field. Since the upstream dispatch requires network access,
    and as you know we cannot perform networking on the main `Thread`, we must perform
    the execution off the main thread using an `AsyncTask` subclass. On the Activity
    class, we implemented a basic asynchronous construct named `AsyncJob` to perform
    the network operation in the background, catching any exception that happen during
    the upstream request. This special purpose class could be used in background tasks
    that don''t produce any results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With `AsyncJob`, we declared three abstract methods that any `AsyncJob` subclass
    should provide implementations. `runOnBackground` should implement the background
    task, `OnFailure` should be used to handle execution exceptions, and the `onSuccess`
    callback is invoked to inform the developer that the job has been successfully
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to implement the `OnClicklistener` that will build up an upstream
    message and dispatch it to our XMPP server in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we created a `Bundle` object with all the payload data that
    we want to dispatch. Beyond that, we created a unique message ID using the `java.util.Random.nextInt`
    instance method.
  prefs: []
  type: TYPE_NORMAL
- en: This message receives as parameters the address following the format `<SENDER_ID>@gcm.googleapis.com`,
    the unique message ID string generated from the random integer, and the bundle
    with your payload.
  prefs: []
  type: TYPE_NORMAL
- en: Once we invoke the `GoogleCloudMessaging.send`, if an active connection is available,
    the new upstream message will be sent immediately, otherwise the message will
    be queued. Once the connectivity is re-established, the queued messages are dispatched
    to the GCM servers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the client attempts to send more messages after the 20-message limit is reached,
    it returns an error.
  prefs: []
  type: TYPE_NORMAL
- en: The `GoogleCloudMessaging` API will reuse and manage the connection to the GCM
    platform in an efficient way, maximizing the device battery life transparently
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the message is received by our XMPP server, the message is dispatched
    to `/topics/forum` and, consequently, it will update the UI message stream with
    the message we typed.
  prefs: []
  type: TYPE_NORMAL
- en: GcmListenerService delivery callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some situations, when there is no connectivity with the GCM servers due
    to lack of network connectivity, the message could remain on the local queues
    for a long period of time. So, in order to discard a message that remains on the
    queue without being sent to the GCM Service within the time specified, the `GoogleCloudMessaging`
    API provides an additional send method that could receive a TTL (Time to Live)
    time to set the message expire time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This works great when you have messages that are only relevant if they arrive
    within a certain time frame. With a time to live of 0, we'll attempt to send and
    return an error immediately if we're not connected. This situation does not apply
    for our example, so we will keep the original code with the send method that does
    not discard an old unsent message.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that the application GCM client is only able to
    queue a maximum of 20 messages when there is no connection to the GCM platform
    for a long period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the upstream expiration feature, the `GcmListenerService` also allows
    us to receive the upstream messages'' dispatch statuses by overriding the `onMessageSent`
    and `onSendError` callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `onMessageSent` callback is invoked when the message is delivered to the
    GCM and the is called when there is an error dispatching the message to the GCM
    connection server. Notice that both callbacks are invoked with the message identifier
    as argument, so you should use this identifier to pinpoint the message that was
    sent or failed with an error.
  prefs: []
  type: TYPE_NORMAL
- en: For efficiency reasons, the GCM message delivery reports are delivered in batches,
    so don't expect to receive the callback execution immediately after you upload
    a single message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive upstream messages'' dispatch statuses in our chat example, we will
    update our `NotificationGCMHandler` and override the `onMessageSent` and `onSendError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The callback methods defined in our `GcmListenerService` callbacks we print
    a message to the application log output with the message that was sent or failed.
    The dispatch of a message could fail if the message expiration time is reached
    or when a maximum size of upstream queued messages has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: Sweet! We've finished our group chat based on the GCM platform. During our journey
    we learned how to send a topic message upstream and downstream using a battery-efficient
    API that maintains a network connection with the Google servers. The API allows
    us to create bidirectional communication channels between the server and a device,
    or between a group of devices.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tasks with GCM Network Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the messaging framework, the GCM library comes with `GcmNetworkManager`,
    an API that allows us to efficiently schedule recurrent or periodic tasks on all
    the devices that run API level 9 (Android 2.1) and above. For devices running
    on API Level 21 (Lollipop) and above, GCM Network Manager uses the native `JobScheduler`
    API internally, covered in detail in [Chapter 7](ch07.html "Chapter 7. Exploring
    the JobScheduler API"), *Exploring the JobScheduler API*. In the same way as the
    `JobScheduler` API, it will try to batch the jobs and reduce the number of wakeups
    from idle state to improve the battery life of your user's device.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, with GCM Network Manager we are also able to set criteria that should
    meet to start the job execution, such as when the device is in a charging state
    or an unmetered WIFI connectivity is available. Although the GCM API offers us
    the same criteria offered by the `JobScheduler` API, it can be used on older and
    newer devices that have Google Play Services installed.
  prefs: []
  type: TYPE_NORMAL
- en: So, before you try to use it, you need to make sure that Google Play Services
    version is available on the device using the `GoogleApiAvailability` class, as
    we did for the GCM example.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the `checkPlayServices()` function from our previous example
    to a more complete solution. The previous function will display dialog when any
    user action is required to update or install Google Play Services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can schedule a task execution on GCM Network Manager to run under certain
    conditions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: When certain network connectivity is available (any network available, unmetered
    network connectivity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the device is plugged to the charger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task that runs within a predefined time window in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the task to run even after a reboot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the criteria supported are the same as the Scheduler API covered previously
    and available on devices that run on Android Lollipop, this API requires some
    extra mandatory criteria that you should specify to register a service task execution
    on the GCM Network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and construct a GCM task, two Builder classes are available: The `OneoffTask.Builder`
    used to create single shot tasks, and the `PeriodicTask.Builder` used register
    a task that runs recurrently at regular intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a one shot task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `OneoffTask` is a task that will execute once, within a specified time window
    in the future. The options available to configure a `OneoffTask` from the `OneoffTask.Builder`
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Execution Window Range (Mandatory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag Identifier (Mandatory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GcmTaskService` subclass that runs our task(Mandatory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra Arguments (Optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Job Persistence (Optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required Network (Optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charging Required (Optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update Current Task (Optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our next example, we will make use of GCM Network Manager to schedule the
    backup of account settings. The account settings, when updated, are stored in
    a local file and, once the backup runs, the account details will be pushed to
    our XMPP server over an upstream message. For saving our account settings, we
    will create an Activity that displays a form to fill our personal details.
  prefs: []
  type: TYPE_NORMAL
- en: The form will have a button that, once clicked, will save our account details
    on a local file and register a GCM Network task execution to push our details
    to our network XMPP Server.
  prefs: []
  type: TYPE_NORMAL
- en: To extend the battery life and reduce our metered mobile internet usage, we
    will register our backup task to run only when the WIFI network is available and
    the device is charging, at most 4 hours after scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we register our task on GCM Network Manager, we will add our `GcmTaskService`
    to the application manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the Android Manifest we added Intent filters required to receive GCM start
    broadcasts and, to protect our service from being started by programmes other
    than Google Play Services, we added the `com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE`
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are ready to register a one-off task to backup the account details
    stored locally on the application default shared preference file. Whenever the
    user updates the account details and taps the save button on the UI, the account
    details will be stored locally and a `OneoffTask` task is built and registered
    on GCM NM to publish the changes on our network servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the save button `OnClickListener` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To register tasks from your `Activity`, we obtained an instance of `GcmNetworkManage`r
    using the `Activity` context. Next, we created a `OneoffTask.Builder` object and
    set the task to start the `MyBackupService` service to complete the task and to
    run the task at least 4 hours after the scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the framework will start your job as soon as all the criteria are
    met and taking into account other jobs scheduled to run. As explained before,
    the GCM NM will delay the job execution and batch jobs to reduce the number of
    CPU wakeups from idle state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create the `MyBackupService` that extends from `GcmTaskService`
    and implements the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `OnRunTask` method will publish our account detail updates to our XMPP
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To execute the `onRunTask` method, the `GcmTaskService` started by GCM NM will
    spawn a background thread with `THREAD_PRIORITY_BACKGROUND` priority and will
    keep the device awake holding CPU `Wakelock` for at most 3 minutes. After 3 minutes
    of execution, if your task has not returned, GCM NM considers that your task has
    timed out, and will release the CPU `Wakelock`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your service receives more than one request at once, you should serialize
    the job execution with a synchronized section to avoid thread safety issues.
  prefs: []
  type: TYPE_NORMAL
- en: The result code returned by `onRunTask` will determine the task execution success
    (`RESULT_SUCCESS`), failure (`RESULT_FAILURE`) or failure with reschedule (`RESULT_RESCHEDULE`).
    In our particular example, if an exception is thrown during the upstream message
    submission the result code `RESULT_RESCHEDULE` returned will force the task to
    be re-executed again after a back-off period (exponential).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned how to send and receive data using a battery-efficient
    communication channel provide by GCM Platform.
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned the differences between polling and push/pull communication
    techniques to interact with network servers. The push and pull messaging used
    by GCM is able to reduce the battery efficiency of your application by avoiding
    redundant server queries to keep the user's data up to date.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, we learned how to setup and configure the GCM library on our
    application. To interact with Google Services, our device obtained a `instanceID`
    and registration token to authenticate and identify our device on the GCM service.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how handle notification messages and topic messages on our
    application and we interacted with a custom XMPP server using GCM upstream messages.
    At the same time, we built group chat system that is able to aggregate messages
    from different users in a unified stream of messages displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to use GCM Network Manager to schedule network tasks
    that run when certain criteria are meet on the device such as the device is connected
    to the WIFI network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the reader to the `RXJava`, a library
    used to compose asynchronous and event-based tasks on Java by using observable
    data streams.
  prefs: []
  type: TYPE_NORMAL
