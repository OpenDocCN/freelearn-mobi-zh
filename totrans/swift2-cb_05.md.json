["```swift\n    class WordCounter:NSObject {\n        private var file:String\n        lazy private var _words = [String:Int]()\n        var words:[String:Int] {\n            return _words\n        }\n    ```", "```swift\n        init(file:String){\n        super.init()\n            self.file = file\n        }\n    ```", "```swift\n        func execute(){\n            _words = [String:Int]()\n\n            // First step opening the file\n            var manager = NSFileManager.defaultManager()\n            var data = manager.contentsAtPath(NSBundle.mainBundle().pathForResource(file, ofType: \"txt\")!)!\n            var content = String(data: data, encoding:NSUTF8StringEnconding)!\n\n            // spliting the documento into words\n            var wordsArray = content.componentsSeparatedByString(\" \")\n            wordsArray = wordsArray.map({ (word) -> String in\n                return word.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n            }) .map({ (word) -> String in\n                return word.lowercaseString\n            }) .filter({(word) -> Bool in\n                 if let regex = try? NSRegularExpression(pattern: \"\\\\w+(-\\\\w+)*\", options: .CaseInsensitive) {\n                   let matches = regex.matchesInString(word, options: nil, range: NSMakeRange(0, word.characters.count))\n        return matches.count > 0\n    }\n\n            })\n\n            // computing the results\n            for word:String in wordsArray {\n                if let tot = _words[word] {\n                    _words[word] = tot + 1\n                }else{\n                    _words[word] = 1\n                }\n            }\n        }\n    }\n    ```", "```swift\n        @IBOutlet var textField: UITextField!\n        @IBOutlet var webView: UIWebView!\n        lazy private var start = CFAbsoluteTimeGetCurrent()\n        lazy private var finish = CFAbsoluteTimeGetCurrent()\n    ```", "```swift\n        @IBAction func loadWeb(sender: UIButton) {\n            let url = NSURL(string: textField.text!)\n            let request = NSURLRequest(URL: url!)\n            webView.loadRequest(request)\n        }\n    ```", "```swift\n        func countWords(file:String){\n            let wordCounter = WordCounter(file: file)\n            wordCounter.execute()\n            finish = CFAbsoluteTimeGetCurrent()\n            print(\"\\(finish-start)\")\n            var result = \"\"\n            for (total, word) in wordCounter.words.enumerate(){\n                result += \"\\(word) -> \\(total)\\n\"\n            }\n            UIAlertView(title: \"Result\", message: result, delegate: nil, cancelButtonTitle: \"Ok\").show()\n        }\n    ```", "```swift\n        @IBAction func countWordsWithoutThreads(sender: UIButton) {\n            start = CFAbsoluteTimeGetCurrent()\n            countWords(\"rfc2821\")\n        }\n\n        @IBAction func countWordsWithThreads(sender: UIButton){\n            start = CFAbsoluteTimeGetCurrent()\n            let thread1 = NSThread(target: self, selector: Selector(\"countWords:\"), object: \"rfc2821\")\n            thread1.start()\n        }\n    ```", "```swift\n    class WordCounter:NSObject {\n        lazy private var _words = [String:Int]()\n        var words:[String:Int] {\n            return _words\n        }\n        lazy private var content:String = \"\"\n\n        init(file:String){\n            super.init()\n            let manager = NSFileManager.defaultManager()\n            let data = manager.contentsAtPath(NSBundle.mainBundle().pathForResource(file, ofType: \"txt\")!)!\n            content = NSString(data: data, encoding: NSUTF8StringEncoding) as! String\n        }\n\n        init(content:String){\n            super.init()\n            self.content = content\n        }\n\n        func execute(){\n            _words = [String:Int]()\n\n            // spliting the document into words\n            var wordsArray = content.componentsSeparatedByString(\" \")\n            wordsArray = wordsArray.map({ (word) -> String in\n                return word.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n            }) .map({ (word) -> String in\n                return word.lowercaseString\n            }) .filter({(word) -> Bool in\n                if let regex = try? NSRegularExpression(pattern: \"\\\\w+(-\\\\w+)*\", options: .CaseInsensitive) {\n                  let matches = regex.matchesInString(word, options: nil, range: NSMakeRange(0, word.characters.count))\n        return matches.count > 0\n    }        \n    })\n\n            // computing the results\n            for word:String in wordsArray {\n                if let tot = _words[word] {\n                    _words[word] = tot + 1\n                }else{\n                    _words[word] = 1\n                }\n            }\n        }\n    }\n    ```", "```swift\n        struct UrlInfo {\n            var url:String\n            var finished:Bool = false\n            lazy var words = [String:Int]()\n            init(url:String){\n                self.url = url\n            }\n        }\n    ```", "```swift\n    @IBOutlet let urlTextField: UITextField!\n    @IBOutlet let urlsTables: UITableView!\n    var urls = [UrlInfo]()\n    let queue = NSOperationQueue()\n    ```", "```swift\n        @IBAction func analyze(sender: UIButton) {\n            var url = urlTextField.text.stringByReplacingOccurrencesOfString(\" \", withString: \"\", options: [], range: nil)\n            if url == \"\" {\n                return\n            }\n\n            let position = self.urls.count\n            self.urls.append(UrlInfo(url: url))\n            self.urlsTables.reloadData()\n\n            queue.addOperationWithBlock(){\n                var data = NSData(contentsOfURL: NSURL(string: url)!)\n                var textResponse = NSString(data: data!, encoding: NSASCIIStringEncoding) as! String\n                print(textResponse)\n                let wordCounter = WordCounter(content: textResponse)\n                wordCounter.execute()\n                self.urls[position].words = wordCounter.words\n                self.urls[position].finished = true\n\n                NSOperationQueue.mainQueue().addOperationWithBlock({\n                    self.urlsTables.reloadData()\n                })\n            }\n        }\n    ```", "```swift\n        func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{\n            return urls.count\n        }\n    ```", "```swift\n            func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell{\n            var cell = urlsTables.dequeueReusableCellWithIdentifier(\"url\") if cell == nil {\n              cell = UITableViewCell(style: .Default, reuseIdentifier: \"url\")\n                cell?.textLabel?.text = urls[indexPath.row].url\n            }\n\n            if self.urls[indexPath.row].finished {\n                cell?.imageView?.image = UIImage(named: \"ok.png\")\n            }else {\n                cell?.imageView?.image = nil\n            }\n            return cell!\n        }\n    ```", "```swift\n        func tableView(tableView: UITableView, didHighlightRowAtIndexPath indexPath: NSIndexPath) {\n            if urls[indexPath.row].finished {\n                var result = \"\"\n                for (total, word) in urls[indexPath.row].words.enumerate(){\n                    result += \"\\(word) -> \\(total)\\n\"\n                }\n                UIAlertView(title: \"Result\", message: result, delegate: nil, cancelButtonTitle: \"Ok\").show()   \n            }\n        }\n    ```", "```swift\n    class CycloneChecker:NSObject, NSXMLParserDelegate{\n    ```", "```swift\n        private let interval = 300\n        private let urls = [\"http://www.nhc.noaa.gov/nhc_at1.xml\",\n        \"http://www.nhc.noaa.gov/nhc_at2.xml\",\n        \"http://www.nhc.noaa.gov/nhc_at3.xml\",\n        \"http://www.nhc.noaa.gov/nhc_at4.xml\",\n        \"http://www.nhc.noaa.gov/nhc_at5.xml\"]\n        private var position = 0\n        private let queue = dispatch_queue_create(\"cyclone.queue\",DISPATCH_QUEUE_SERIAL)\n        private var started = false\n        var action: (String) -> (Void) = {(url) -> Void in\n        }\n    ```", "```swift\n        func start(){\n            started = true\n            initQueue()\n        }\n        func stop(){\n            started = false\n        }\n    ```", "```swift\n        private func initQueue(){\n            self.position = 0\n            for i in 1...urls.count {\n                dispatch_async(queue, { () -> Void in\n                  if self.started {\n                      print(\"checking \\(self.position)\")\n                      var xmlParser = NSXMLParser(contentsOfURL: NSURL(string: self.urls[self.position])!)\n                      xmlParser?.delegate = self\n                      xmlParser?.parse()\n                  }\n              })\n          }\n          dispatch_async(queue, { () -> Void in\n              if self.started {\n                  sleep(UInt32(self.interval))\n                  self.initQueue()\n              }\n          })\n      }\n    ```", "```swift\n        func parser(parser: NSXMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : AnyObject]){\n            if elementName == \"cyclone\"{\n                self.action(self.urls[self.position])\n            }\n        }\n    ```", "```swift\n        func parserDidEndDocument(parser: NSXMLParser) {\n            position += 1\n        }\n    ```", "```swift\n        var cycloneChecker = CycloneChecker()\n        @IBOutlet var buttonStart: UIButton!\n        @IBOutlet var buttonStop: UIButton!\n        @IBOutlet var textView: UITextView!\n        @IBOutlet var labelStatus: UILabel!\n    ```", "```swift\n        override func viewDidLoad() {\n            super.viewDidLoad()\n            cycloneChecker.action = {(url) -> Void in\n                if UIApplication.sharedApplication().applicationState == .Background   {\n                    var localNotification:UILocalNotification = UILocalNotification()\n                    localNotification.alertAction = \"Cyclone found\"\n                    localNotification.alertBody = \"A cyclone was found. visit \\(url) for more information\"\n                    localNotification.fireDate = NSDate(timeIntervalSinceNow: 10)\n                    UIApplication.sharedApplication().scheduleLocalNotification(localNotification)\n                }\n                dispatch_async(dispatch_get_main_queue(), { () -> Void in\n                    self.textView.text = \"\\(self.textView.text)\\nA cyclone was found. visit \\(url) for more information\"\n                })\n            }\n            self.textView.text = \"\"\n            self.textView.layer.borderWidth = 0.5\n        }\n    ```", "```swift\n        @IBAction func start(sender: AnyObject) {\n            cycloneChecker.start()\n            labelStatus.text = \"Status: started\"\n            buttonStart.enabled = false\n            buttonStop.enabled = true\n        }\n            @IBAction func stop(sender: AnyObject) {\n            cycloneChecker.stop()\n            labelStatus.text = \"Status: stopped\"\n            buttonStart.enabled = true\n            buttonStop.enabled = false\n        }\n    ```", "```swift\n        func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [String: AnyObject]?) -> Bool {\n            if UIApplication.instancesRespondToSelector(Selector(\"registerUserNotificationSettings:\"))\n                {\n\n                application.registerUserNotificationSettings(UIUserNotificationSettings(forTypes: UIUserNotificationType.Sound | UIUserNotificationType.Alert |\n                UIUserNotificationType.Badge, categories: nil))\n                }\n            return true\n        }\n    ```", "```swift\n    private class UrlManager {\n        enum UrlAddStatus {\n            case OK, FULL, REPEATED, WRONG_URL\n        }\n\n        private var _queue = dispatch_queue_create(\"concurrentqueue\", DISPATCH_QUEUE_CONCURRENT)\n        var queue:dispatch_queue_t{\n            return _queue\n        }\n        private var fileHandle:NSFileHandle?\n        private lazy var _urls = [String]()\n        let LIMIT = 10\n    ```", "```swift\n        func contains(url:String) -> Bool{\n            objc_sync_enter(self._urls)\n            for u in self._urls {\n                if u == url {\n                    objc_sync_exit(self._urls)\n                    return true\n                }\n            }\n            objc_sync_exit(self._urls)\n            return false\n        }\n\n        var full:Bool {\n            return self._urls.count >= self.LIMIT\n        }\n\n        private func validUrl(url:String) -> Bool{\n            var error:NSError?\n            var regex = NSRegularExpression(pattern:\"^(https?:\\\\/\\\\/)?([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})([\\\\/\\\\w \\\\.-]*)*\\\\/?$\", options: .CaseInsensitive, error: &error)\n            let matches = regex?.matchesInString(url, options: nil, range: NSMakeRange(0, count(url)))\n            return matches?.count > 0\n        }\n\n        private func writeMessage(message:String){\n            objc_sync_enter(self.fileHandle)\n            self.fileHandle?.writeData(message.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!)\n            objc_sync_exit(self.fileHandle)\n        }\n    ```", "```swift\n        init(){\n            var path:String = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as! String\n            let fullpath = (path as NSString).stringByAppendingPathComponent(\"application.log\")\n            NSFileManager.defaultManager().createFileAtPath(fullpath, contents: nil, attributes: nil)\n            self.fileHandle=NSFileHandle(forWritingAtPath:fullpath)!\n        }\n    ```", "```swift\n        func addUrl(url:String) -> UrlAddStatus {\n            if full {\n                // WRITE FULL\n                self.writeMessage(\"Couldn't store the url \\(url). Buffer is full\")\n                return .FULL\n            }\n            if self.contains(url){\n                self.writeMessage(\"Couldn't store the url \\(url). Already on buffer\")\n                return .REPEATED\n            }\n            if !self.validUrl(url) {\n                self.writeMessage(\"Couldn't store the url \\(url). Invalid url\")\n                return .WRONG_URL\n            }\n            objc_sync_enter(self._urls)\n            self._urls.append(url)\n            objc_sync_exit(self._urls)\n            self.writeMessage(\"Url \\(url) successfully stored\")\n            return .OK\n        }   \n    } // Class end\n    ```", "```swift\n    class LinkChecker:NSObject, NSXMLParserDelegate {\n        private var xmlParser:NSXMLParser\n        private var urlManager:UrlManager\n        var foundAction: (String) -> (Void) = {\n            (url) -> Void in\n        }\n    ```", "```swift\n        init(url:String) {\n            self.xmlParser = NSXMLParser(contentsOfURL: NSURL(string: url)!)!\n            self.urlManager = UrlManager()\n            super.init()\n            self.xmlParser.delegate = self\n            self.urlManager.addUrl(url)\n        }\n\n        private init(url:String, urlManager:UrlManager) {\n            self.xmlParser = NSXMLParser(contentsOfURL: NSURL(string: url)!)!\n            self.urlManager = urlManager\n            super.init()\n            self.xmlParser.delegate = self\n        }\n    ```", "```swift\n        func start(){\n            dispatch_async(urlManager.queue, { () -> Void in\n                self.xmlParser.parse()\n                return\n            })\n        }\n    ```", "```swift\n        func parser(parser: NSXMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [NSObject : AnyObject]){\n            if elementName.lowercaseString == \"a\" {\n                let href = \"href\"\n                var newUrl = attributeDict[\"href\"] as! String\n                if let  range = newUrl.rangeOfString(\"#\", options: .CaseInsensitiveSearch, range: nil, locale: nil){\n                    newUrl = newUrl.substringToIndex(range.startIndex)\n                }\n\n                print(\"found link \\(newUrl)\")\n                if self.urlManager.addUrl(attributeDict[href] as! String) == .OK {\n                    self.foundAction(attributeDict[href] as! String)\n                    dispatch_async(urlManager.queue, { () -> Void in\n                        self.xmlParser.parse()\n                        return\n                    })\n                }\n            }\n        }\n    } // class end\n    ```", "```swift\n    class ViewController: UIViewController, UITableViewDataSource {\n\n        @IBOutlet let urlTextField: UITextField!\n        @IBOutlet let tableView: UITableView!\n        private var _urls = [String]()\n        private var linkChecker:LinkChecker?\n    ```", "```swift\n        @IBAction func analyze(sender: UIButton) {\n            linkChecker = LinkChecker(url:self.urlTextField.text)\n            self.linkChecker?.foundAction = {\n                (url) -> Void in\n                self._urls.append(url)\n                dispatch_async(dispatch_get_main_queue(),\n                    {() -> Void in\n                        self.tableView.reloadData()\n                })\n            }\n            linkChecker?.start()\n            self.urlTextField.resignFirstResponder()\n        }\n    ```", "```swift\n        func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{\n            return self._urls.count\n        }\n\n        func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell{\n            var cell = self.tableView.dequeueReusableCellWithIdentifier(_urls[indexPath.row]) as? UITableViewCell\n\n            if cell == nil {\n                cell = UITableViewCell(style: .Default, reuseIdentifier: _urls[indexPath.row])\n                cell?.textLabel?.text = _urls[indexPath.row]\n            }\n            return cell!\n        }\n    ```"]