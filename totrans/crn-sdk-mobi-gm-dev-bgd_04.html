<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Game Controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Game Controls</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>So far we have completed the first half of our game in the previous chapter. We started on developing the initial structure for the project by introducing the game objects to the screen. Currently, the paddle and ball movement is inactive, but everything displayed in the simulator is scaled accordingly to the original game design. The last phase of completing this tutorial is to add in all the actions that will occur in the game, including object movement and updating the score.</p></blockquote></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Moving the paddle using touch events and accelerometer</li><li class="listitem" style="list-style-type: disc">Collision detection between all game objects in the scene</li><li class="listitem" style="list-style-type: disc">Removing objects upon collision detection</li><li class="listitem" style="list-style-type: disc">Ball movement within screen boundaries</li><li class="listitem" style="list-style-type: disc">Calculating the score</li><li class="listitem" style="list-style-type: disc">Win and lose conditions</li></ul></div><p>Home stretch! We can do it!</p><div class="section" title="Moving in the up direction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Moving in the up direction</h1></div></div></div><p>If making objects appear on screen is exciting to you, wait until you see them move! The main object of Breakout is to keep the ball above the paddle position to stay in play and have it collide with all the bricks to complete the level. What keeps the suspense flowing is the anticipation of the ball movement throughout the game screen. This wouldn't be possible without adding physical boundaries on the game objects to react to collision detection.<a id="id268" class="indexterm"/>
</p></div></div>
<div class="section" title="Let's get even more physical"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Let's get even more physical</h1></div></div></div><p>In the last chapter, we talked about how to integrate the physics engine into your code. We also started implementing physical bodies to the brick objects and now we'll need to do the same with other active game objects such as the paddle and the ball. Let's continue with this last half of the tutorial. We will continue using our <code class="literal">main.lua</code> file from the <code class="literal">Breakout</code> project folder.<a id="id269" class="indexterm"/>
</p><div class="section" title="physics.addBody()"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec01"/>physics.addBody()</h2></div></div></div><p>Corona display objects can be turned into simulated physical objects using one line of code.<a id="id270" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If no shape information is specified, the display object takes on the form of the actual rectangular boundary of the original image to create the physics body. For example, if a display object is 100 x 100 pixels, then that would be the actual size of the physics body.</li><li class="listitem" style="list-style-type: disc">If a shape is specified, then the body boundaries will follow the polygon provided by the shape. The shape coordinates must be defined in clockwise order, and the resulting shape must be convex-only.</li><li class="listitem" style="list-style-type: disc">If a radius is specified, then the body boundaries will be circular and centered in the middle of the display object used to create the physics body.</li></ul></div><p>A body shape is a table of local (x,y) coordinates, relative to the center of the display object.</p><p>Syntax:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Circular shapes:<a id="id271" class="indexterm"/><div class="informalexample"><pre class="programlisting">physics.addBody(object, [bodyType,] {density=d, friction=f, bounce=b [,radius=r]})
</pre></div></li><li class="listitem" style="list-style-type: disc">Polygon shapes:<div class="informalexample"><pre class="programlisting">physics.addBody(object, [bodyType,] {density=d, friction=f, bounce=b [,shape=s]})
</pre></div></li></ul></div><p>For example:</p><p>Circular bodies:</p><div class="informalexample"><pre class="programlisting">local ball = display.newImage("ball.png")
physics.addBody( ball, "dynamic" { density = 1.0, friction = 0.3, bounce = 0.2, radius = 25 } )
</pre></div><p>Polygon bodies:</p><div class="informalexample"><pre class="programlisting">local rectangle = display.newImage("rectangle.png")
rectangleShape = { -6,-48, 6,-48, 6,48, -6,48 }
physics.addBody( rectangle, { density=2.0, friction=0.5, bounce=0.2,
shape=rectangleShape } )
</pre></div><p>Parameters:<a id="id272" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Object</code> (Object): A display object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bodyType</code> (String): Specifying the body type is optional. It uses a string parameter before the first body element. The possible types are<code class="literal">"static", "dynamic"</code>, and<code class="literal">"kinematic"</code>. The default type is<code class="literal">"dynamic"</code> if no value is specified.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">static bodies don't move, and don't interact with each other; examples of static objects would include the ground or the walls of a pinball machine.</li><li class="listitem" style="list-style-type: disc">dynamic bodies are affected by gravity and collisions with the other body types.</li><li class="listitem" style="list-style-type: disc">kinematic objects are affected by forces but not by gravity, so you should generally set draggable objects to<code class="literal">"kinematic"</code>, at least for the duration of the drag event.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Density</code> (Number): Multiplied by the area of the body's shape to determine mass. Based on a standard value of 1.0 for water. Lighter materials (such as wood) have a density below 1.0, and heavier materials (such as stone) have a density greater than 1.0. Default value is <code class="literal">1.0</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Friction</code> (Number): May be any non-negative value; a value of 0 means no friction and 1.0 means fairly strong friction. The default value is <code class="literal">0.3</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Bounce</code> (Number): Determines the amount of an object's velocity returned after a collision. The default value is <code class="literal">0.2</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Radius</code> (Number): Radius of the bounding circle in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Shape</code> (Number): Shape value in the form of a table of the shape vertices, {x1,y1,x2,y2,...,xn,yn}. For example, <code class="literal">rectangleShape = { -6,-48, 6,-48, 6,48, -6,48 }</code>. The coordinates must be defined in clockwise order, and the resulting shape must be convex-only. (Physics assume the 0,0 point of an object, is the center of the object. A -x will be to the left of the object's center and -y will be at the top of object's center).</li></ul></div></div></div>
<div class="section" title="Time for action&#x2014;starting physics for the paddle and ball"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Time for action—starting physics for the paddle and ball</h1></div></div></div><p>Right now, our display objects are rather stagnant. In order for gameplay to initiate, we have to activate physics for the paddle and ball in order for any kind of movement in the game to occur.<a id="id273" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Above the <code class="literal">gameLevel1()</code> function, create a new function called <code class="literal">startGame()</code>.<div class="informalexample"><pre class="programlisting">function startGame()
</pre></div></li><li class="listitem">Add in the following lines to instantiate the physics of the paddle and ball:<a id="id274" class="indexterm"/><div class="informalexample"><pre class="programlisting">physics.addBody(paddle, "static", {density = 1, friction = 0, bounce = 0})
physics.addBody(ball, "dynamic", {density = 1, friction = 0, bounce = 0})
</pre></div></li><li class="listitem">Create an event listener that uses the background display object to remove the<code class="literal">"tap"</code> event for <code class="literal">startGame()</code>. Close the function with <code class="literal">end</code>.<div class="informalexample"><pre class="programlisting">background:removeEventListener("tap", startGame)
end
</pre></div></li><li class="listitem">In the <code class="literal">addGameScreen()</code> function that we created in the previous chapter, we have to add the following line after the call to the <code class="literal">gameLevel1()</code> function. This starts the actual game when the background is touched.<div class="informalexample"><pre class="programlisting">background:addEventListener("tap", startGame)
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec02"/>What just happened?</h2></div></div></div><p>The paddle object has a<code class="literal">"static"</code> body type so it is not affected by any collision that occurs against it.</p><p>The ball object has a<code class="literal">"dynamic"</code> body type because we want it to be affected by the collisions on the screen due to directional changes by the wall borders, bricks and paddle.</p><p>The event listener on the background is removed from the <code class="literal">startGame()</code> function, that way it doesn't affect any of the other touch events that are applied in game.</p></div></div>
<div class="section" title="Paddle movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Paddle movement</h1></div></div></div><p>Getting the paddle to move side to side is one of the key actions that needs to be accomplished. Part of the game design is to protect the ball from reaching the bottom of the screen. We will be separating paddle movement in the simulator and the accelerometer. The movement in the simulator enables us to test with touch events since accelerometer actions cannot be tested in the simulator.<a id="id275" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;dragging the paddle in the simulator"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Time for action—dragging the paddle in the simulator</h1></div></div></div><p>Right now, the paddle does not move at all. There are no coordinates set to translate on the screen, so let's create that.<a id="id276" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Underneath the <code class="literal">addGameScreen()</code> function, create a new function called <code class="literal">dragPaddle(event)</code>.<div class="informalexample"><pre class="programlisting">function dragPaddle(event)
</pre></div></li><li class="listitem">Next, we'll focus on moving the paddle side to side within the boundary of the game screen.<a id="id277" class="indexterm"/><div class="informalexample"><pre class="programlisting">if isSimulator then
if event.phase == "began" then
moveX = event.x - paddle.x
elseif event.phase == "moved" then
paddle.x = event.x - moveX
end
if((paddle.x - paddle.width * 0.5) &lt; 0) then
paddle.x = paddle.width * 0.5
elseif((paddle.x + paddle.width * 0.5) &gt; display.contentWidth) then
paddle.x = display.contentWidth - paddle.width * 0.5
end
end
end
</pre></div><p>Add in the preceding block of code to enable paddle movement in the simulator and then close the function. The reason for adding this block is because the simulator does not support accelerometer events.
</p><div class="mediaobject"><img src="graphics/1888_04_01.jpg" alt="Time for action—dragging the paddle in the simulator"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec03"/>What just happened?</h2></div></div></div><p>We have created a function where the drag event only works in the simulator. For <code class="literal">if event.phase == "began"</code>, a touch has been made to the paddle. On <code class="literal">elseif event.phase == "moved"</code>, a touch has been moved on the paddle.<a id="id278" class="indexterm"/>
</p><p>In order to keep the paddle from moving past the wall boundaries, <code class="literal">paddle.x</code> does not go past<code class="literal">&lt; 0</code> in the x-direction when it hits the coordinate. When the paddle slides to the right side of the screen, <code class="literal">paddle.x</code> does not go past<code class="literal">&gt; display.contentWidth</code> in the x-direction.</p><p>There is no designated coordinate for the right side of the screen since the code is supposed to be universal for all screen sizes on iOS and Android devices. Both platforms have varying screen resolutions, so <code class="literal">display.contentWidth</code> takes them into account.</p></div></div>
<div class="section" title="Time for action&#x2014;moving the paddle with accelerometer"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Time for action—moving the paddle with accelerometer</h1></div></div></div><p>As mentioned earlier, accelerometer events cannot be tested in the simulator. They only work when a game build is uploaded to a device to see the results. The paddle movement will stay within the wall borders of the level across the x-axis.<a id="id279" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Below the <code class="literal">dragPaddle()</code> function, create a new function called <code class="literal">movePaddle(event)</code>.<div class="informalexample"><pre class="programlisting">function movePaddle(event)
</pre></div></li><li class="listitem">Add in the accelerometer movement using <code class="literal">yGravity</code>. It provides the acceleration due to gravity in the y-direction.<a id="id280" class="indexterm"/><div class="informalexample"><pre class="programlisting">paddle.x = display.contentCenterX - (display.contentCenterX * (event.yGravity*3))
</pre></div></li><li class="listitem">Add in the wall borders for the level and close the function:<div class="informalexample"><pre class="programlisting">if((paddle.x - paddle.width * 0.5) &lt; 0) then
paddle.x = paddle.width * 0.5
elseif((paddle.x + paddle.width * 0.5) &gt; display.contentWidth) then
paddle.x = display.contentWidth - paddle.width * 0.5
end
end
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec04"/>What just happened?</h2></div></div></div><p>To make the accelerometer movement work with a device, we have to use <code class="literal">yGravity</code>.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"/>Note</h3><p>Accelerometer events are based on portrait scale when <code class="literal">xGravity</code> and <code class="literal">yGravity</code> are used accordingly. When display objects are designated for landscape mode, <code class="literal">xGravity</code> and <code class="literal">yGravity</code> values are switched to compensate for the events to work properly.</p></div><p>We have applied the same code for the paddle from <code class="literal">function dragPaddle():</code>
</p><div class="informalexample"><pre class="programlisting">if((paddle.x - paddle.width * 0.5) &lt; 0) then
paddle.x = paddle.width * 0.5
elseif((paddle.x + paddle.width * 0.5) &gt; display.contentWidth) then
paddle.x = display.contentWidth - paddle.width * 0.5
end
</pre></div><p>This still keeps the paddle from going past any wall border boundaries.</p></div></div>
<div class="section" title="Ball collision with paddle"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec07"/>Ball collision with paddle</h1></div></div></div><p>The motion of the ball has to flow in a fluid manner every time it collides with the paddle. This means proper directional changes on all sides of the game field.<a id="id281" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;making the ball bounce against the paddle"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Time for action—making the ball bounce against the paddle</h1></div></div></div><p>We will check which side of the paddle the ball has hit to choose the side where it will move next. It's important to have the motion to follow through any directional hits as it would in a realistic environment. Through every paddle collision, we want to make sure the ball goes in the<span class="emphasis"><em> up</em></span> direction.<a id="id282" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new function called <code class="literal">bounce()</code> for the ball after the <code class="literal">movePaddle()</code> function.<div class="informalexample"><pre class="programlisting">function bounce()
</pre></div></li><li class="listitem">Add in a value of -3 for velocity in the y-direction. This will make the ball move in an upward motion:<div class="informalexample"><pre class="programlisting">vy = -3
</pre></div></li><li class="listitem">Check when a collision is made with the <code class="literal">paddle</code> and <code class="literal">ball</code> and close the function:<div class="informalexample"><pre class="programlisting">if((ball.x + ball.width * 0.5) &lt; paddle.x) then
vx = -vx
elseif((ball.x + ball.width * 0.5) &gt;= paddle.x) then
vx = vx
end
end
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec05"/>What just happened?</h2></div></div></div><p>When the ball collides with the paddle, the motion follows through depending on what side of the paddle is touched by the ball. In the first part of the <code class="literal">if</code> statement, the ball travels toward 0 in the x-direction. The last part of the <code class="literal">if</code> statement shows the ball travelling toward the opposite side of the screen in the x-direction.</p></div></div>
<div class="section" title="Removing objects from the scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec09"/>Removing objects from the scene</h1></div></div></div><p>There are limited resources on a device. As much as we wish they were as powerful as a desktop to hold so much memory, it's not at that point yet. This is why it is important to remove display objects from the display hierarchy when you no longer use them in your application. This helps the overall system performance by reducing memory consumption and eliminates unnecessary drawing.<a id="id283" class="indexterm"/>
</p><p>When a display object is created, it is added by default to the root object of the display hierarchy. This object is a special kind of group object known as the<span class="strong"><strong> stage object</strong></span>.</p><p>In order to keep an object from rendering on screen, it needs to be removed from the scene. The object needs to be removed explicitly from its parent. This removes the object from the display hierarchy. This can be done in either of the two following ways:</p><p>
<code class="literal">myImage.parent:remove( myImage )</code> -- remove <code class="literal">myImage</code> from hierarchy</p><p>or</p><p>
<code class="literal">myImage:removeSelf( )</code> -- same as above</p><p>This does not free all the memory from the display object. To make sure that the display object is removed properly, we need to eliminate all variable references to it.<a id="id284" class="indexterm"/>
</p><div class="section" title="Variable references"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec06"/>Variable references</h2></div></div></div><p>Even though a display object has been removed from the hierarchy, there are situations in which the object continues to exist. To do this, we set the property to <code class="literal">nil</code>.<a id="id285" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">local ball = display.newImage("ball.png")
local myTimer = 3
function time()
myTimer = myTimer - 1
print(myTimer)
if myTimer == 0 then
ball:removeSelf()
ball = nil
end
end
timer.performWithDelay( 1000, time, myTimer )
</pre></div></div></div>
<div class="section" title="Brick by brick"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Brick by brick</h1></div></div></div><p>The bricks in the game are the main obstacles since they have to be cleared in order to move onto the next round. In this version of Breakout, the player must destroy all the bricks in one turn. Failure to do so results in starting over from the beginning of the current level.<a id="id286" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;removing the bricks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec11"/>Time for action—removing the bricks</h1></div></div></div><p>When the ball collides with a brick, we will use the same technique applied to the paddle to determine the side the ball will follow. When a brick is hit, we'll need to figure out which brick has been touched and then remove it from both the stage and the bricks group. Each brick removal will increment 100 points to the score. The score will be taken from the score constant and added to the current score as text.<a id="id287" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Below the <code class="literal">gameLevel2()</code> function, create a function called <code class="literal">removeBrick(event):</code><div class="informalexample"><pre class="programlisting">function removeBrick(event)
</pre></div></li><li class="listitem">Check which side of the brick the ball hits using the <code class="literal">if</code> statement. When checking for an event, we'll be referring the event to the object name,<code class="literal">"brick"</code>. This is the name we gave our <code class="literal">brick</code> display object:<div class="informalexample"><pre class="programlisting">if event.other.name == "brick" and ball.x + ball.width * 0.5 &lt; event.other.x + event.other.width * 0.5 then
vx = -vx
elseif event.other.name == "brick" and ball.x + ball.width * 0.5 &gt;= event.other.x + event.other.width * 0.5 then
vx = vx
end
</pre></div></li><li class="listitem">Add in the following <code class="literal">if</code> statement to remove the brick from the scene when the ball collides with one. After a collision has been made, increase the <code class="literal">score</code> by 1. Initiate the <code class="literal">scoreNum</code> to take the value of the <code class="literal">score</code> and multiply it by <code class="literal">scoreIncrease:</code><div class="informalexample"><pre class="programlisting">if event.other.name == "brick" then
vy = vy * -1
event.other:removeSelf()
event.other = nil
bricks.numChildren = bricks.numChildren - 1
score = score + 1
scoreNum.text = score * scoreIncrease
scoreNum:setReferencePoint(display.CenterLeftReferencePoint)
scoreNum.x = 54
end
</pre></div></li><li class="listitem">When all the bricks are destroyed from the level, create an <code class="literal">if</code> statement that pops up on the<span class="strong"><strong> Alert</strong></span> screen for a win condition and set the <code class="literal">gameEvent</code> string to<code class="literal">"win"</code>.<div class="informalexample"><pre class="programlisting">if bricks.numChildren &lt; 0 then
alertScreen("YOU WIN!", "Continue")
gameEvent = "win"
end
</pre></div></li><li class="listitem">Close the function with <code class="literal">end</code>.<div class="informalexample"><pre class="programlisting">end
</pre><div class="mediaobject"><img src="graphics/1888_04_02.jpg" alt="Time for action—removing the bricks"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec07"/>What just happened?</h2></div></div></div><p>If you remember from the previous chapter, we gave the <code class="literal">brick</code> objects a name called<code class="literal">"brick"</code>.<a id="id288" class="indexterm"/>
</p><p>When the ball hits the left side of any of the individual bricks, the ball travels towards the left. When the ball hits the right side of the bricks, it travels toward the right. The width of each object is taken as a whole to calculate the direction the ball travels.</p><p>When a brick is hit, the ball bounces upward (the y-direction). Upon every collision, the ball makes with a brick; the object is removed from the scene and destroyed from memory.</p><p>
<code class="literal">bricks.numChildren -1</code> subtracts the count from the total number of bricks it started out with originally. When a brick is removed, the score increments 100 points each time. The <code class="literal">scoreNum</code> text object updates the score every time a brick is hit.</p><p>When all bricks are gone, the<span class="strong"><strong> Alert</strong></span> screen pops up with a notification that the player has won the level. We also set <code class="literal">gameEvent = "win"</code>, which will be used in another function that will transition the event to a new scene.</p></div></div>
<div class="section" title="Directional changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec12"/>Directional changes</h1></div></div></div><p>Aside from the ball motion against the paddle, other factors are the collision states against the wall borders. When a collision occurs, the ball diverts its direction the opposite way. For every action, there is a reaction, just like real world physics.<a id="id289" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;updating the ball"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec13"/>Time for action—updating the ball</h1></div></div></div><p>The ball needs to move in a continuous motion without gravity affecting it. We'll have to take into account the side walls and top and bottom walls. The velocity in the x and y direction have to reflect the other way when a collision happens on any of the boundaries. We need to set coordinates that the ball is only allowed to move through and an alert when it passes through an area below the paddle region.<a id="id290" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new function called <code class="literal">function updateBall()</code> below the <code class="literal">removeBrick(event)</code> function.<div class="informalexample"><pre class="programlisting">function updateBall()
</pre></div></li><li class="listitem">Add in the ball movement:<div class="informalexample"><pre class="programlisting">ball.x = ball.x + vx
ball.y = ball.y + vy
</pre></div></li><li class="listitem">Add in the ball movement for the x-direction:<div class="informalexample"><pre class="programlisting">if ball.x &lt; 0 or ball.x + ball.width &gt; display.contentWidth then
vx = -vx
end
</pre><div class="mediaobject"><img src="graphics/1888_04_03.jpg" alt="Time for action—updating the ball"/></div></div></li><li class="listitem">Add in the ball movement for the y-direction:<a id="id291" class="indexterm"/><div class="informalexample"><pre class="programlisting">if ball.y &lt; 0 then
vy = -vy
end
</pre><div class="mediaobject"><img src="graphics/1888_04_04.jpg" alt="Time for action—updating the ball"/></div></div></li><li class="listitem">Add in the ball movement when it collides with the bottom of the<span class="strong"><strong> Gameplay</strong></span> screen. Create the lose<span class="strong"><strong> Alert</strong></span> screen and a game event for<code class="literal">"lose"</code>. Close the function with <code class="literal">end</code>.<a id="id292" class="indexterm"/><div class="informalexample"><pre class="programlisting">if ball.y + ball.height &gt; paddle.y + paddle.height then
alertScreen("YOU LOSE!", "Play Again") gameEvent = "lose"
end
end
</pre><div class="mediaobject"><img src="graphics/1888_04_05.jpg" alt="Time for action—updating the ball"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec08"/>What just happened?</h2></div></div></div><p>Everywhere the ball travels, proper direction change is needed when it hits the wall. Any time the ball hits the side walls, we use <code class="literal">vx = -vx</code>. When the ball hits the top boundary, <code class="literal">vy = -vy</code> is used. The only time the ball doesn't reflect the opposite direction is when it hits the bottom of the screen.<a id="id293" class="indexterm"/>
</p><p>The<span class="strong"><strong> Alert</strong></span> screen displays the lose condition, which emphasizes to the player to<span class="strong"><strong> Play Again</strong></span>. <code class="literal">gameEvent = "lose"</code> will be used in another <code class="literal">if</code> statement to reset the current level.</p></div></div>
<div class="section" title="Transitioning levels"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec14"/>Transitioning levels</h1></div></div></div><p>When a win or lose condition occurs, the game needs a way to transition to the next level or repeat the current one. The main game objects have to be reset to their starting position and the bricks redrawn. Pretty much the same idea when you start a game during first play.<a id="id294" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;resetting and changing levels"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec15"/>Time for action—resetting and changing levels</h1></div></div></div><p>We'll need to create functions that set up the first and second level in the game. If a level needs to be replayed, only the current level the user lost in can be accessed.<a id="id295" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new function called <code class="literal">changeLevel1()</code>. This will be placed below the <code class="literal">updateBall()</code> function:<div class="informalexample"><pre class="programlisting">function changeLevel1()
</pre></div></li><li class="listitem">Clear the <code class="literal">bricks</code> group when the player loses the round and reset them:<a id="id296" class="indexterm"/><div class="informalexample"><pre class="programlisting">bricks:removeSelf()
bricks.numChildren = 0
bricks = display.newGroup()
</pre></div></li><li class="listitem">Remove the <code class="literal">alertDisplayGroup:</code><div class="informalexample"><pre class="programlisting">alertBox:removeEventListener("tap", restart)
alertDisplayGroup:removeSelf()
alertDisplayGroup = nil
</pre></div></li><li class="listitem">Reset the <code class="literal">ball</code> and <code class="literal">paddle</code> position:<div class="informalexample"><pre class="programlisting">ball.x = (display.contentWidth * 0.5) - (ball.width * 0.5)
ball.y = (paddle.y - paddle.height) - (ball.height * 0.5) -2
paddle.x = display.contentWidth * 0.5
</pre></div></li><li class="listitem">Redraw the <code class="literal">bricks</code> for the current level:<div class="informalexample"><pre class="programlisting">gameLevel1()
</pre></div></li><li class="listitem">Add an event listener to the <code class="literal">background</code> object for <code class="literal">startGame()</code>. Close the function.<div class="informalexample"><pre class="programlisting">background:addEventListener("tap", startGame)
end
</pre></div></li><li class="listitem">Next create a new function called <code class="literal">changeLevel2()</code>. Apply all the same code used for <code class="literal">changeLevel1()</code>, but make sure the <code class="literal">bricks</code> are redrawn for <code class="literal">gameLevel2()</code>.<div class="informalexample"><pre class="programlisting">function changeLevel2()
bricks:removeSelf()
bricks.numChildren = 0
bricks = display.newGroup()
alertBox:removeEventListener("tap", restart)
alertDisplayGroup:removeSelf()
alertDisplayGroup = nil
ball.x = (display.contentWidth * 0.5) - (ball.width * 0.5)
ball.y = (paddle.y - paddle.height) - (ball.height * 0.5) -2
paddle.x = display.contentWidth * 0.5
gameLevel2() -- Redraw bricks for level 2
background:addEventListener("tap", startGame)
end
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec09"/>What just happened?</h2></div></div></div><p>When a level needs to be reset or changed, the display objects have to be wiped from the board. In this case, we removed the <code class="literal">bricks</code> group using <code class="literal">bricks:removeSelf()</code>.</p><p>When any<span class="strong"><strong> Alert</strong></span> screen pops up, whether win or lose, the entire <code class="literal">alertDisplayGroup</code> is removed during the reset as well. The <code class="literal">ball</code> and <code class="literal">paddle</code> are set back to their start game position.</p><p>
<code class="literal">gameLevel1()</code> is called to redraw the bricks for level 1. The function holds the initial setup for the <code class="literal">brick</code> display objects and <code class="literal">bricks</code> group.<a id="id297" class="indexterm"/>
</p><p>The <code class="literal">background</code> object is used again to call the <code class="literal">startGame()</code> function with an event listener. When level 2 needs to be set up, the same procedure is used like in function <code class="literal">changeLevel1()</code>, but called <code class="literal">changeLevel2()</code> and <code class="literal">gameLevel2()</code> is used to redraw the bricks.</p></div><div class="section" title="Have a go hero—add more levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec10"/>Have a go hero—add more levels</h2></div></div></div><p>Right now, the game only has two levels. What can be done to extend this game is add more levels. They can be created using the same logic made for <code class="literal">gameLevel1()</code> and <code class="literal">gameLevel2()</code> by adjusting the numbers used to create rows and columns for the bricks. You'll have to create a new function that resets the level. We can use the same method done on <code class="literal">changeLevel1()</code> and <code class="literal">changeLevel2()</code> to re-create a level and reset it.<a id="id298" class="indexterm"/>
</p></div></div>
<div class="section" title="You win some, you lose some"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec16"/>You win some, you lose some</h1></div></div></div><p>Nothing is more exhilarating than the anticipation of winning. That is until you make that one small mistake and it causes you to start over. Don't worry, it's not the end of the world, you can always try again and learn from your errors on beating the level.<a id="id299" class="indexterm"/>
</p><p>Game events that occur within the program such as a win or lose condition has been made will alert the player of their progress. The game has to have some way of guiding the player to what action they need to make to replay the level or move on to the next one.</p></div>
<div class="section" title="Time for action&#x2014;making win and lose conditions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec17"/>Time for action—making win and lose conditions</h1></div></div></div><p>For any game alerts to even appear during gameplay, we need to create some <code class="literal">if</code> statements for every possible scenario available in each level. When this occurs, the score needs to be reset back to zero.<a id="id300" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Below the <code class="literal">alertScreen()</code> function, create a new function called <code class="literal">restart():</code><div class="informalexample"><pre class="programlisting">function restart()
</pre></div></li><li class="listitem">Create an <code class="literal">if</code> statement for a<code class="literal">"win"</code> game event when the first level has been completed and transitions to<span class="strong"><strong> Level 2</strong></span>.<div class="informalexample"><pre class="programlisting">if gameEvent == "win" and currentLevel == 1 then
currentLevel = currentLevel + 1
changeLevel2()
levelNum.text = tostring(currentLevel)
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"/>Note</h3><p>
<code class="literal">tostring()</code> converts any argument to a string. In the preceding example, the <code class="literal">currentLevel</code> value changes from 1 to 2 when a<code class="literal">"win"</code> game event occurs. The value will convert to a string format that the <code class="literal">levelNum</code> text object can display on screen for<span class="strong"><strong> Level 2</strong></span>.</p></div></li><li class="listitem">Add an <code class="literal">elseif</code> statement for a<code class="literal">"win"</code> game event when the second level has been completed and notifies the player that the game has been completed.<div class="informalexample"><pre class="programlisting">elseif gameEvent == "win" and currentLevel == 2 then
alertScreen(" Game Over", " Congratulations!")
gameEvent = "completed"
</pre></div></li><li class="listitem">Add another <code class="literal">elseif</code> statement for<code class="literal">"lose"</code> game event on the first level. Reset the score to zero and replay level 1.<div class="informalexample"><pre class="programlisting">elseif gameEvent == "lose" and currentLevel == 1 then
score = 0
scoreNum.text = "0"
changeLevel1()
</pre></div></li><li class="listitem">Add another <code class="literal">elseif</code> statement for a<code class="literal">"lose"</code> game event on the second level. Reset the score to zero and replay level 2.<div class="informalexample"><pre class="programlisting">elseif gameEvent == "lose" and currentLevel == 2 then
score = 0
scoreNum.text = "0"
changeLevel2()
</pre></div></li><li class="listitem">Lastly add another <code class="literal">elseif</code> statement for a <code class="literal">gameEvent = "completed"</code>. Close the function with <code class="literal">end</code>.<div class="informalexample"><pre class="programlisting">elseif gameEvent == "completed" then
alertBox:removeEventListener("tap", restart)
end
end
</pre></div></li><li class="listitem">Now we need to backtrack and add an event listener to the <code class="literal">alertScreen()</code> function using the <code class="literal">alertBox</code> object. We're going to add it to the bottom of the function. This will activate <code class="literal">function restart()</code>.<div class="informalexample"><pre class="programlisting">alertBox:addEventListener("tap", restart)
<a id="id301" class="indexterm"/>
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>What just happened?</h2></div></div></div><p>The <code class="literal">restart()</code> function checks all <code class="literal">gameEvent</code> and <code class="literal">currentLevel</code> variables happening during gameplay. When a game event checks for the string<code class="literal">"win"</code>, it also goes down the list of statements to see what comes out true. For example, if the player wins and is currently on level 1, then the player moves on to level 2.</p><p>During a case that the player loses, <code class="literal">gameEvent == "lose"</code> becomes true and the code checks what level the player lost in. For any level the player loses in, the score reverts back to 0 and the current level the player was on is set up again.</p></div></div>
<div class="section" title="Activating event listeners"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec18"/>Activating event listeners</h1></div></div></div><p>The event listeners in this game basically turn the movements of the objects on and off. We have already coded the functions that carry out the actions of our game objects to run the level. Now it's time to activate them using certain type of events. As you've noticed from the previous chapter, we can add event listeners to display objects or have them run globally.<a id="id302" class="indexterm"/>
</p><div class="section" title="Collision events"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Collision events</h2></div></div></div><p>Collision events within the physics engine occur through Corona's event listener model. There are three new event types:<a id="id303" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">"collision":</code> This event includes phases for<code class="literal">"began"</code> and<code class="literal">"ended"</code>, which signify the moments of initial contact and broken contact. These phases exist for both normal two-body collisions and body-sensor collisions. If you do not implement a<code class="literal">"collision"</code> listener, this event will not fire.</li><li class="listitem" style="list-style-type: disc"><code class="literal">"preCollision":</code> An event type that fires right before the objects start to interact. Depending on your game logic, you may wish to detect this event and conditionally override the collision. It may also result in multiply reports per contact and affect the application performance.</li><li class="listitem" style="list-style-type: disc"><code class="literal">"postCollision":</code> An event type that fires right after the objects have interacted. This is the only event in which the collision force is reported. If you do not implement a<code class="literal">"postCollision"</code> listener, this event will not fire.<div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"/>Note</h3><p>Collisions are reported between pairs of objects and can be detected either globally, using a runtime listener, or locally within an object, using a table listener.</p></div></li></ul></div><div class="section" title="Global collision listeners"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Global collision listeners</h3></div></div></div><p>When detected as a runtime event, each collision event includes <code class="literal">event.object1</code>, which contains the table ID of the Corona display object involved.<a id="id304" class="indexterm"/>
</p><p>For example:</p><div class="informalexample"><pre class="programlisting">local physics = require "physics"
physics.start()
local box1 = display.newImage( "box.png" )
physics.addBody( box1, "dynamic", { density = 1.0, friction = 0.3, bounce = 0.2 } )
box1.myName = "Box 1"
local box2 = display.newImage( "box.png", 0, 350)
physics.addBody( box2, "static", { density = 1.0, friction = 0.3, bounce = 0.2 } )
box2.myName = "Box 2"
local function onCollision( event )
if event.phase == "began" and event.object1.myName == "Box 1" then
print( "Collision made." )
end
end
<span class="strong"><strong>Runtime:addEventListener( "collision", onCollision )</strong></span>
</pre></div></div><div class="section" title="Local collision listeners"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Local collision listeners</h3></div></div></div><p>When detected with a table listener within an object, each collision event includes <code class="literal">event.other</code>, which contains the table ID of the other display object involved in the collision.<a id="id305" class="indexterm"/>
</p><p>For example:</p><div class="informalexample"><pre class="programlisting">local physics = require "physics"
physics.start()
local box1 = display.newImage( "box.png" )
physics.addBody( box1, "dynamic", { density = 1.0, friction = 0.3, bounce = 0.2 } )
box1.myName = "Box 1"
local box2 = display.newImage( "box.png", 0, 350)
physics.addBody( box2, "static", { density = 1.0, friction = 0.3, bounce = 0.2 } )
box2.myName = "Box 2"
local function onCollision( self, event )
if event.phase == "began" and self.myName == "Box 1" then
print( "Collision made." )
end
end
box1.collision = onCollision
<span class="strong"><strong>box1:addEventListener( "collision", box1 )</strong></span>
box2.collision = onCollision
<span class="strong"><strong>box2:addEventListener( "collision", box2 )</strong></span>
</pre></div></div></div></div>
<div class="section" title="Time for action&#x2014;adding game listeners"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec19"/>Time for action—adding game listeners</h1></div></div></div><p>For many of the functions we have created for our game objects we need to activate the event listeners so that they will run the code and disable them when gameplay has stopped.<a id="id306" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">The last function we need to create in order to complete this game is called <code class="literal">gameListeners()</code>, which will also have a parameter called <code class="literal">event</code>. This should be added right after the <code class="literal">gameLevel2()</code> function.<div class="informalexample"><pre class="programlisting">function gameListeners(event)
</pre></div></li><li class="listitem">Add in the following event listeners that will start several events in the application using an <code class="literal">if</code> statement:<div class="informalexample"><pre class="programlisting">if event == "add" then
Runtime:addEventListener("accelerometer", movePaddle)
Runtime:addEventListener("enterFrame", updateBall)
paddle:addEventListener("collision", bounce)
ball:addEventListener("collision", removeBrick)
paddle:addEventListener("touch", dragPaddle)
</pre></div></li><li class="listitem">Next we'll add in an <code class="literal">elseif</code> statement for the event listeners that will remove the events and then close the function.<a id="id307" class="indexterm"/><div class="informalexample"><pre class="programlisting">elseif event == "remove" then
Runtime:removeEventListener("accelerometer", movePaddle)
Runtime:removeEventListener("enterFrame", updateBall)
paddle:removeEventListener("collision", bounce)
ball:removeEventListener("collision", removeBrick)
paddle:removeEventListener("touch", dragPaddle)
end
end
</pre></div></li><li class="listitem">In order for <code class="literal">function gameListeners()</code> to work properly, we need to instantiate it in the <code class="literal">startGame()</code> function using the<code class="literal">"add"</code> string in the parameter. Place it before the end of the function.<div class="informalexample"><pre class="programlisting">gameListeners("add")
</pre></div></li><li class="listitem">In the <code class="literal">alertScreen()</code> function, add the<code class="literal">"remove"</code> string in the parameter and place it at the start of the function.<div class="informalexample"><pre class="programlisting">gameListeners("remove")
</pre></div></li><li class="listitem">All the code has been written! Go ahead and run the game in the simulator. The application is also device ready. Make a simple icon image that fits the required dimensions for the device you're developing on. Compile a build and run it on your device.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec13"/>What just happened?</h2></div></div></div><p>There are two sets of <code class="literal">if</code> statements for the <code class="literal">event</code> parameter,<code class="literal">"add"</code> and<code class="literal">"remove"</code>.</p><p>All the event listeners in this function play an important role in making the game run.<code class="literal">"accelerometer"</code> and<code class="literal">"enterframe"</code> are used as runtime events since they have no specific target.</p><p>Both the <code class="literal">paddle</code> and <code class="literal">ball</code> have<code class="literal">"collision"</code> events that will carry out their purpose in any object contact made.</p><p>The<code class="literal">"touch"</code> event allows the user to touch and drag the paddle so it can move back and forth in the simulator.</p><p>Notice <code class="literal">event == "remove"</code> removes all event listeners that were active in the game. When the game starts, <code class="literal">gameListeners("add")</code> is activated. When a win or lose condition is achieved, <code class="literal">gameListeners("remove")</code> is activated.<a id="id308" class="indexterm"/>
</p></div><div class="section" title="Have a go hero—let's turn everything upside down"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Have a go hero—let's turn everything upside down</h2></div></div></div><p>What if we decided to flip the game upside down? In other words, place the paddle near the top of the screen, the ball below the paddle, and the group of bricks closer to the bottom of the screen.</p><p>Things you'll have to consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The top wall is now an area you have to keep the ball from entering</li><li class="listitem" style="list-style-type: disc">The y-direction the ball travels when it collides with the bricks</li><li class="listitem" style="list-style-type: disc">The ball has to reflect off the bottom wall when it collides with it</li></ul></div><p>As you can see, there are a couple things to consider before switching values from negative to positive and vice versa. Be sure to verify your logic and that it makes sense when creating this new variation.</p></div></div>
<div class="section" title="The results are in!"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec20"/>The results are in!</h1></div></div></div><p>Let's reiterate block by block to make sure that we have everything added into our game. You can also refer to the <code class="literal">Breakout Final</code> folder in the <a class="link" href="ch04.html" title="Chapter 4. Game Controls">Chapter 4</a> folder to see the final code. We made sure that we introduced our variables used in the game. We also initialized the <code class="literal">main()</code> function that starts the gameplay. A<span class="strong"><strong> Main Menu</strong></span> screen was implemented with the game title and a<span class="strong"><strong> Play</strong></span> button.<a id="id309" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">-- Hide Status Bar
display.setStatusBar(display.HiddenStatusBar)
-- Physics Engine
local physics = require "physics"
physics.start()
physics.setGravity(0, 0)
-- Accelerometer
system.setAccelerometerInterval( 100 )
-- Menu Screen
local menuScreenGroup -- display.newGroup()
local mmScreen
local playBtn
-- Game Screen
local background
local paddle
local brick
local ball
-- Score/Level Text
local scoreText
local scoreNum
local levelText
local levelNum
-- alertDisplayGroup
local alertDisplayGroup -- display.newGroup()
local alertBox
local conditionDisplay
local messageText
-- Variables
local _W = display.contentWidth / 2
local _H = display.contentHeight / 2
local bricks = display.newGroup()
local brickWidth = 35
local brickHeight = 15
local row
local column
local score = 0
local scoreIncrease = 100
local currentLevel
local vx = 3
local vy = -3
local gameEvent = ""
local isSimulator = "simulator" == system.getInfo("environment")
-- Main Function
function main()
mainMenu()
end
function mainMenu()
menuScreenGroup = display.newGroup()
mmScreen = display.newImage("mmScreen.png", 0, 0, true)
mmScreen.x = _W
mmScreen.y = _H
playBtn = display.newImage("playbtn.png")
playBtn:setReferencePoint(display.CenterReferencePoint)
playBtn.x = _W; playBtn.y = _H + 50
playBtn.name = "playbutton"
menuScreenGroup:insert(mmScreen)
menuScreenGroup:insert(playBtn)
-- Button Listeners
playBtn:addEventListener("tap", loadGame)
end
</pre></div><p>Next we transitioned the <code class="literal">menuScreenGroup</code> away from the stage to load the main playing field. The main display objects of the game, such as the paddle, ball, and bricks were added. The score and the level number were displayed as the UI elements and updated throughout gameplay. Paddle movement in both the simulator and accelerometer were added as well as the collision detection with the paddle and the ball.<a id="id311" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">function loadGame(event)
if event.target.name == "playbutton" then
-- Start Game
transition.to(menuScreenGroup,{time = 0, alpha=0, onComplete = addGameScreen})
playBtn:removeEventListener("tap", loadGame)
end
end
function addGameScreen()
background = display.newImage("bg.png", 0, 0, true )
background.x = _W
background.y = _H
paddle = display.newImage("paddle.png")
paddle.x = 240; paddle.y = 300
paddle.name = "paddle"
ball = display.newImage("ball.png")
ball.x = 240; ball.y = 290
ball.name = "ball"
-- Text
scoreText = display.newText("Score:", 5, 2, "Arial", 14)
scoreText:setTextColor(255, 255, 255, 255)
scoreNum = display.newText("0", 54, 2, "Arial", 14)
scoreNum:setTextColor(255, 255, 255, 255)
levelText = display.newText("Level:", 420, 2, "Arial", 14)
levelText:setTextColor(255, 255, 255, 255)
levelNum = display.newText("1", 460, 2, "Arial", 14)
levelNum:setTextColor(255, 255, 255, 255)
-- Build Level Bricks
gameLevel1()
-- Start Listener
background:addEventListener("tap", startGame)
end
-- Used to drag the paddle on the simulator
function dragPaddle(event)
if isSimulator then
if event.phase == "began" then
moveX = event.x - paddle.x
elseif event.phase == "moved" then
paddle.x = event.x - moveX
end
if((paddle.x - paddle.width * 0.5) &lt; 0) then
paddle.x = paddle.width * 0.5
elseif((paddle.x + paddle.width * 0.5) &gt; display.contentWidth) then
paddle.x = display.contentWidth - paddle.width * 0.5
end
end
end
function movePaddle(event)
-- Accelerometer Movement
--must be yGravity since it's landscape
paddle.x = display.contentCenterX - (display.contentCenterX * (event.yGravity*3))
-- Wall Borders
if((paddle.x - paddle.width * 0.5) &lt; 0) then
paddle.x = paddle.width * 0.5
elseif((paddle.x + paddle.width * 0.5) &gt; display.contentWidth) then
paddle.x = display.contentWidth - paddle.width * 0.5
end
end
function bounce()
vy = -3
-- Paddle Collision, check the which side of the paddle the ball hits, left, right
if((ball.x + ball.width * 0.5) &lt; paddle.x) then
vx = -vx
elseif((ball.x + ball.width * 0.5) &gt;= paddle.x) then
vx = vx
end
end
</pre></div><p>The physical properties of the paddle and ball were added to the start of the game. The brick layouts for each of the two levels were created. We have added event listeners to all our game objects from the point when they need to be activated during the game and removed when gameplay is over.</p><div class="informalexample"><pre class="programlisting">function startGame()
-- Physics
physics.addBody(paddle, "static", {density = 1, friction = 0, bounce = 0})
physics.addBody(ball, "dynamic", {density = 1, friction = 0, bounce = 0})
background:removeEventListener("tap", startGame)
gameListeners("add")
end
-- HOW TO BUILD BLOCKS
function gameLevel1()
currentLevel = 1
bricks:toFront()
local numOfRows = 4
local numOfColumns = 4
local brickPlacement = {x = (_W) - (brickWidth * numOfColumns ) / 2 + 20, y = 50}
for row = 0, numOfRows - 1 do
for column = 0, numOfColumns - 1 do
-- Create a brick
local brick = display.newImage("brick.png")
brick.name = "brick"
brick.x = brickPlacement.x + (column * brickWidth)
brick.y = brickPlacement.y + (row * brickHeight)
physics.addBody(brick, "static", {density = 1, friction = 0, bounce = 0})
bricks.insert(bricks, brick)
end
end
end
function gameLevel2()
currentLevel = 2
bricks:toFront()
local numOfRows = 5
local numOfColumns = 8
local brickPlacement = {x = (_W) - (brickWidth * numOfColumns ) / 2 + 20, y = 50}
for row = 0, numOfRows - 1 do
for column = 0, numOfColumns - 1 do
-- Create a brick
local brick = display.newImage("brick.png")
brick.name = "brick"
brick.x = brickPlacement.x + (column * brickWidth)
brick.y = brickPlacement.y + (row * brickHeight)
physics.addBody(brick, "static", {density = 1, friction = 0, bounce = 0})
bricks.insert(bricks, brick)
end
end
end
function gameListeners(event)
if event == "add" then
Runtime:addEventListener("accelerometer", movePaddle)
Runtime:addEventListener("enterFrame", updateBall)
paddle:addEventListener("collision", bounce)
ball:addEventListener("collision", removeBrick)
-- Used to drag the paddle on the simulator
paddle:addEventListener("touch", dragPaddle)
elseif event == "remove" then
Runtime:removeEventListener("accelerometer", movePaddle)
Runtime:removeEventListener("enterFrame", updateBall)
paddle:removeEventListener("collision", bounce)
ball:removeEventListener("collision", removeBrick)
-- Used to drag the paddle on the simulator
paddle:removeEventListener("touch", dragPaddle)
end
end
</pre></div><p>Every time the ball collides with a brick, the brick is removed from the scene. The directional changes are updated to the ball for every wall, paddle, or brick collision made. Every time a win or lose condition occurred, all game objects are reset to begin at the start of the current or new level.</p><div class="informalexample"><pre class="programlisting">--BRICK REMOVAL
function removeBrick(event)
-- Check the which side of the brick the ball hits, left, right
if event.other.name == "brick" and ball.x + ball.width * 0.5 &lt; event.other.x + event.other.width * 0.5 then
vx = -vx
elseif event.other.name == "brick" and ball.x + ball.width * 0.5 &gt;= event.other.x + event.other.width * 0.5 then
vx = vx
end
-- Bounce, Remove
if event.other.name == "brick" then
vy = vy * -1
event.other:removeSelf()
event.other = nil
bricks.numChildren = bricks.numChildren - 1
-- Score
score = score + 1
scoreNum.text = score * scoreIncrease
scoreNum:setReferencePoint(display.CenterLeftReferencePoint)
scoreNum.x = 54
end
-- Check if all bricks are destroyed
if bricks.numChildren &lt; 0 then
alertScreen("YOU WIN!", "Continue")
gameEvent = "win"
end
end
-- BALL FUNCTION
function updateBall()
-- Ball Movement
ball.x = ball.x + vx
ball.y = ball.y + vy
-- Wall Collision
if ball.x &lt; 0 or ball.x + ball.width &gt; display.contentWidth then
vx = -vx
end--Left
if ball.y &lt; 0 then
vy = -vy
end--Up
if ball.y + ball.height &gt; paddle.y + paddle.height then
alertScreen("YOU LOSE!", "Play Again") gameEvent = "lose"
end--down/lose
end
-- RESET LEVEL
function changeLevel1()
-- Clear Level Bricks
bricks:removeSelf()
bricks.numChildren = 0
bricks = display.newGroup()
-- Remove Alert
alertBox:removeEventListener("tap", restart)
alertDisplayGroup:removeSelf()
alertDisplayGroup = nil
-- Reset Ball and Paddle position
ball.x = (display.contentWidth * 0.5) - (ball.width * 0.5)
ball.y = (paddle.y - paddle.height) - (ball.height * 0.5) -2
paddle.x = display.contentWidth * 0.5
-- Redraw Bricks
gameLevel1()
-- Start
background:addEventListener("tap", startGame)
end
function changeLevel2()
-- Clear Level Bricks
bricks:removeSelf()
bricks.numChildren = 0
bricks = display.newGroup()
-- Remove Alert
alertBox:removeEventListener("tap", restart)
alertDisplayGroup:removeSelf()
alertDisplayGroup = nil
-- Reset Ball and Paddle position
ball.x = (display.contentWidth * 0.5) - (ball.width * 0.5)
ball.y = (paddle.y - paddle.height) - (ball.height * 0.5) -2
paddle.x = display.contentWidth * 0.5
-- Redraw Bricks
gameLevel2()
-- Start
background:addEventListener("tap", startGame)
end
</pre></div><p>When a condition occurs, an<span class="strong"><strong> Alert</strong></span> screen pops out, notifying the player what has happened. The display objects that initiate the alerts are created into a function. Lastly, the win and lose arguments are created to determine if the current level has to be replayed, goes to the next level, or if the game has been completed.</p><div class="informalexample"><pre class="programlisting">function alertScreen(title, message)
gameListeners("remove")
alertBox = display.newImage("alertBox.png")
alertBox.x = 240; alertBox.y = 160
transition.from(alertBox, {time = 300, xScale = 0.5, yScale = 0.5, transition = easing.outExpo})
conditionDisplay = display.newText(title, 0, 0, "Arial", 38)
conditionDisplay:setTextColor(255,255,255,255)
conditionDisplay.xScale = 0.5
conditionDisplay.yScale = 0.5
conditionDisplay:setReferencePoint(display.CenterReferencePoint)
conditionDisplay.x = display.contentCenterX
conditionDisplay.y = display.contentCenterY - 15
messageText = display.newText(message, 0, 0, "Arial", 24)
messageText:setTextColor(255,255,255,255)
messageText.xScale = 0.5
messageText.yScale = 0.5
messageText:setReferencePoint(display.CenterReferencePoint)
messageText.x = display.contentCenterX
messageText.y = display.contentCenterY + 15
alertDisplayGroup = display.newGroup()
alertDisplayGroup:insert(alertBox)
alertDisplayGroup:insert(conditionDisplay)
alertDisplayGroup:insert(messageText)
alertBox:addEventListener("tap", restart)
end
-- WIN/LOSE ARGUMENT
function restart()
if gameEvent == "win" and currentLevel == 1 then
currentLevel = currentLevel + 1
changeLevel2()--next level
levelNum.text = tostring(currentLevel)
elseif gameEvent == "win" and currentLevel == 2 then
alertScreen(" Game Over", " Congratulations!")
gameEvent = "completed"
elseif gameEvent == "lose" and currentLevel == 1 then
score = 0
scoreNum.text = "0"
changeLevel1()--same level
elseif gameEvent == "lose" and currentLevel == 2 then
score = 0
scoreNum.text = "0"
changeLevel2()--same level
elseif gameEvent == "completed" then
alertBox:removeEventListener("tap", restart)
end
end
main()
</pre></div><p>Beware of case-sensitive variables and functions in case you run into errors. Also be sure to check if you're missing any punctuation required in your code. These can be easily overlooked. Refer to your<span class="strong"><strong> Terminal</strong></span> window in the simulator for any error references.<a id="id320" class="indexterm"/>
</p><div class="section" title="Pop quiz—working with game controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Pop quiz—working with game controls</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">How do you properly remove a display object from the stage?<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. <code class="literal">remove()</code></li><li class="listitem" style="list-style-type: none">b. <code class="literal">object: remove()</code></li><li class="listitem" style="list-style-type: none">c. <code class="literal">object:removeSelf(); object = nil</code></li><li class="listitem" style="list-style-type: none">d. None of the above</li></ul></div></li><li class="listitem">What is the correct way to make the following display object into a physical object?<div class="informalexample"><pre class="programlisting">local ball = display.newImage("ball.png")
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. <code class="literal">physics.addBody( circle, { density=2.0, friction=0.5, bounce=0.2, radius = 25 } )</code></li><li class="listitem" style="list-style-type: none">b. <code class="literal">physics.addBody( circle, "dynamic", { density=2.0, friction=0.5, bounce=0.2, radius = 15 } )</code></li><li class="listitem" style="list-style-type: none">c. a and b</li><li class="listitem" style="list-style-type: none">d. None of the above</li></ul></div></li><li class="listitem">What best represents what<code class="literal">"began"</code> means in the following function?<div class="informalexample"><pre class="programlisting">local function onCollision( event )
if event.phase == "began" and event.object1.myName == "Box 1" then
print( "Collision made." )
end
end
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. A finger moved on the screen</li><li class="listitem" style="list-style-type: none">b. A finger was lifted from the screen</li><li class="listitem" style="list-style-type: none">c. The system cancelled tracking the start touch</li><li class="listitem" style="list-style-type: none">d. A finger touched the screen</li></ul></div></li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Summary</h1></div></div></div><p>Congratulations! You have completed making your very first game! You should be very proud of yourself. Now you have experienced how simple it is to make an application with Corona. It can take merely a few hundred lines of code to make an application.</p><p>In this chapter, we covered the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Added movement to the paddle with touch events</li><li class="listitem" style="list-style-type: disc">Introduced the accelerometer features</li><li class="listitem" style="list-style-type: disc">Implemented collision event listeners for all game objects affected</li><li class="listitem" style="list-style-type: disc">Removed objects from memory when they weren't needed on the game screen</li><li class="listitem" style="list-style-type: disc">Implemented movement of the ball as a physical object</li><li class="listitem" style="list-style-type: disc">Updated a scoreboard for every brick collision</li><li class="listitem" style="list-style-type: disc">Learned how to handle win and lose conditions</li></ul></div><p>The past two chapters weren't so bad now were they? We're getting familiar with the workflow as we continue programming in Lua. It will definitely get easier to understand as long as you keep working with different game frameworks.</p><p>What the next chapter holds will be another game that will surely catch your attention. We'll be creating animated sprite sheets for our display objects. How's that for eye candy?</p></div></body></html>