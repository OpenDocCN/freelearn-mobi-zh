- en: Making Asynchronous Programming Great Again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing tasks in the background using threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background threads synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using coroutines for asynchronous, concurrent execution of tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using coroutines for asynchronous, concurrent tasks execution with results handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying coroutines for asynchronous data processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy coroutine cancelation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a REST API client with Retrofit and a coroutines adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping third-party callback-style APIs with coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is going to address various aspects of asynchronous programming
    problems. The first two recipes, *Executing tasks in the background using threads*
    and *Background-threads synchronization*,are going to explain the standard library
    support for running background tasks using JVM threads.
  prefs: []
  type: TYPE_NORMAL
- en: In the further recipes, we are going to delve more deeply into the powerful
    Kotlin Coroutines framework. Those recipes are going to explain a general usage
    of coroutines for asynchronous and concurrent tasks executing. They will also
    present how to employ coroutines for solving more specific daily-life programming
    problems, such as concurrent data processing, asynchronous REST-call handling,
    and working with third-party callback-style APIs in a clean way. After reading
    this chapter, you will feel convenient applying the coroutines framework to write
    robust asynchronous code or to optimize your code by running expensive computations
    concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: The Kotlin Coroutines framework is not only a handy replacement for platform-specific
    concurrency and async frameworks. Its power is based on providing a unified, universal
    API that allows us to write asynchronous code, which can be run both on JVM, Android,
    JavaScript, and native platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tasks in the background using threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore how to work effectively with the JVM
    `Thread` class in a clean way using the Kotlin standard library functions dedicated
    to convenient thread-running. We are going to simulate two long-running tasks
    and execute them concurrently in background threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to make use of two functions simulating long-running
    operations. Here is the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'They are both just responsible for blocking a current thread for five and two seconds,
    respectively, in order to simulate long-running tasks. We will also make use of
    the predefined function returning the current thread name for debugging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by logging the current thread name to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new `Thread` and invoke the `` `5 sec long task`() `` function inside
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start another `Thread` and invoke `` `2 sec long task`() `` inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code is going to print the following text to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have successfully started two background threads, which are
    running concurrently. We are using the `thread()` utility function from the `kotlin.concurrent`
    package, which is responsible for instantiating and starting a new thread that
    runs a block of code passed to it in the form of a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the rest of the recipes to discover how to use the Kotlin Coroutines
    framework to replace the threading mechanism with a more robust and flexible framework.
    A good starting point could be the *Using coroutines for asynchronous concurrent-tasks
    execution *and *Using coroutines for asynchronous concurrent-tasks execution with
    results-handling *recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background threads synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore how to work effectively with the JVM
    `Thread` class in a clean way using the Kotlin standard library functions dedicated
    to running threads in a convenient way. We are going to simulate two long-running
    tasks and execute them in background threads synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to make use of the following two functions to
    simulate long-running operations. The `` `5 sec long task`() `` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'and the `` `2 sec long task`() `` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'They are both just responsible for blocking a current thread for five and two
    seconds, respectively, in order to simulate long-running tasks. We will also make
    use of the predefined function returning the current thread name for debugging
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by logging the current thread name to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new `Thread` and invoke the `` `5 sec long task`() `` function inside
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until the thread completes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start another `Thread` and invoke `` `2 sec long task`() `` inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until the thread completes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Test whether the main thread is free at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code is going to print the following text to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully started two background threads, which are synchronized.
    In order to run both background threads sequentially, we are using the `Thread.join()`
    function, which just blocks the main thread until the background thread completes.
    In order to instantiate and start a new background thread, we are using the `thread()` utility
    function from the `kotlin.concurrent` package. We are passing it a block of code
    to be run inside the thread inside a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the next recipes explaining how to use the Kotlin Coroutines
    framework to replace the threading mechanism with a more robust and flexible framework.
    A good starting point could be the *Using coroutines for asynchronous concurrent-tasks
    execution *and *Using coroutines for asynchronous concurrent-tasks execution with
    results-handling *recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using coroutines for asynchronous, concurrent execution of tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore how to use the coroutines framework
    in order to schedule asynchronous, concurrent execution of tasks. We are going
    to learn both how to synchronize a sequence of short background tasks and how
    to run expensive, long-running ones at the same time. We will simulate the sushi
    rolls preparation process to discover how to schedule blocking and non-blocking
    tasks together.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to start working with Kotlin Coroutines is to add the core framework
    dependency to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current recipe, we will assume our sushi-cooking simulation requires
    the four following steps to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Cook the rice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the fish
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut the vegetables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roll the sushi
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are going to be simulated by the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also use the following function to log a current thread name to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of the exercise, we will assume the sushi-roll preparation process
    must fulfill the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The longest *Rice-cooking* step must be executed in the background in a non-blocking
    way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Fish-preparation* and *Vegetable-cutting* steps have to be performed one
    by one while the rice is cooking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sushi-rolling* step can be done only when the first three steps are completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by logging the current thread name to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new coroutine running on a pool of background threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `` `cook rice`() `` function asynchronously in a nested coroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `` `prepare fish`() `` and  `` `cut vegetable`() `` functions sequentially
    while the `` `cook rice`() `` function is running in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until the rice-cooking coroutine completes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the final `` `roll the sushi`() `` function and wait until the main
    coroutine completes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Measure the total time for function execution and log it to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code is going to print the following text to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the beginning, we start a new coroutine running on a background thread with
    the `launch()` function call. We also create a handle to the `Job` instance returned
    by the `launch()` function under the `var sushiCookingJob: Job` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: The `launch()` function starts a new coroutine instance on a default `CoroutineContext`
    instance. However, we are able to pass our desired `CoroutineContext` as an additional
    parameter to the `launch()` function. When targeting the JVM platform, by default
    the `launch()` function starts a coroutine on a pool of background threads, which
    corresponds to the `CommonPool` context constant. We can also run the coroutine
    on a single thread by passing a context result of the `newSingleThreadContext()` function.
    If you are working with UI frameworks, such as Android, Swing, or JavaFx, you
    can run a coroutine on a `UI` context as well. The `UI` context is related to
    the main thread responsible for user-interface updates. There are different modules
    that provide the `UI` context implementation dedicated to a specific framework.
    You can learn more about framework-specific UI programming with coroutines in
    the following official guide: [https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the main coroutine, we are starting a new one and invoking the `` `cook
    rice`() `` function inside it. We are storing a handle to the `Job` instance corresponding
    to the coroutine handling the `` `cook rice`() `` function under the `val riceCookingJob:
    Job` variable. At this point, the rice-cooking task begins to run concurrently
    on a pool of threads.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are invoking two functions—`` `prepare fish`() `` and `` `cut vegetable`()
    ``. As you can see in the console output, those functions are executed sequentially.
    The vegetable-cutting task starts right after the fish-preparation completes.
    If we'd like to run them concurrently, we'd need to start each one inside a new
    coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wait for the completion of the rice-cooking task by calling a `join()` function
    on the `riceCookingJob` variable. Here, the `join()` function suspends the primary `sushiCookingJob`
    coroutine until `riceCookingJob` is complete. Right after the primary coroutine
    gets unblocked, the last  `` `roll the sushi`() `` function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: In order to await the primary coroutine completion, we need to invoke a `join()`
    function on the `sushiCookingJob` instance after starting it on the main thread.
    However, we are not able to call the `join()` function outside of a coroutine
    scope. We need to call it inside a new *blocking* coroutine started with a `runBlocking()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The coroutines framework is designed to allow us to execute tasks in a non-blocking
    way. Although we are able to write non-blocking code inside a coroutine's scope,
    we need to provide a bridge to the original thread inside the application that
    starts the primary coroutine.  We are able to connect the non-blocking coroutine
    scope with the blocking world outside using the `runBlocking()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `runBlocking()` function starts a new coroutine and blocks the current thread
    until its completion. It is designed to bridge regular blocking code to libraries
    that are written in suspending style. For example, it can be used in `main()`
    functions and in tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coroutines can be seen as lightweight thread replacements. Coroutines are lightweight
    in terms of resource consumption. For example, we can start a million coroutines
    concurrently with ease, where, after a second, each of them logs the current thread
    name to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will complete in about 10 seconds on a standard computer.
    In contrast, if we try to run this code using threads, we get the `OutOfMemoryError:
    unable to create new native thread` exception.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can follow up by reading the *Using coroutines for asynchronous, concurrent
    tasks execution with results handling*recipe. It shows you how to asynchronously
    schedule functions that return the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using coroutines for asynchronous, concurrent tasks execution with results handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore how to use the coroutines framework
    in order to run asynchronous operations concurrently, and learn how to handle
    the results they return properly. We are going to schedule two tasks and run them
    in the background using two coroutines. The first task is going to be responsible
    for displaying the progress-bar animation. The second one is going to simulate
    long-running computations. In the end, we are going to print the results returned
    by the second task to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to start working with Kotlin Coroutines is to add a core framework
    dependency to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current recipe, we are going to make use of the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first one is simulating an expensive computation that delays a thread for
    five seconds and returns the result in the end. The second one is responsible
    for displaying an infinite progress-bar animation. We are going to start both
    operations concurrently and wait for the result returned by the first one. After
    we get the result, we will print it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also use the following function to log a current thread name to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by logging a current thread name to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a coroutine responsible for displaying progress-bar animation from the
    background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a coroutine responsible for running the `` `calculate the answer to life
    the universe and everything`() `` function in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the result returned by the `future` coroutine and print it to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our code is going to display the progress-bar animation for five seconds and
    then print the result of the `` `calculate the answer to life the universe and
    everything`() `` function once it completes the simulated calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start the execution of `` `calculate the answer to life the universe and
    everything`() `` in the background task using the `async()` function. It just
    starts a new coroutine and returns an instance of a `Deferred<T>` class. The generic `T` type
    corresponds to the type of object that is returned by `async()`.  An instance
    of the `Deferred<T>` type is just a pointer to the future result delivered by
    the coroutine. It's a representation of asynchronous programming constructs, called *futures* or *promises*.
    We are able to evaluate the value of a `Deferred` object by calling the `await()`
    function on it. However, we are not able to call the `await()` function outside
    a coroutine scope. We need to call it inside a new *blocking* coroutine started
    with a `runBlocking()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The coroutines framework is designed to allow us to execute tasks in a non-blocking
    way. Although we are able to write non-blocking code inside a coroutine's scope,
    we need to provide a bridge to the original thread inside the application that
    starts the primary coroutine. We are able to connect the non-blocking coroutine
    scope with the blocking world outside using the `runBlocking()` function. The `runBlocking()` function
    starts a new coroutine and blocks the current thread until its completion. It
    is designed to bridge regular blocking code to libraries that are written in suspending
    style. For example, it can be used in `main()` functions and in tests.
  prefs: []
  type: TYPE_NORMAL
- en: As far as the progress-bar animation is concerned, we are scheduling it in the
    background using the `launch()` function. `launch()` is responsible for starting
    a new coroutine, however, it does not care about delivering the final results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed our predefined functions are marked with the `suspend` modifier
    declared before the `fun` keyword, for example, ``**suspend** fun `show progress
    animation`()``. The reason behind this is that we need to declare explicitly that
    the function is going to run inside the coroutine scope to be able to use coroutine-specific
    features inside the function's body. In our case, we are using the `delay()` function,
    which can be invoked only inside a coroutine scope. It is responsible for pausing
    the coroutine for a given amount of time without blocking the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can investigate another usage of the `delay()` function in the *Applying
    coroutines for asynchronous data processing* recipe. You can also explore different use
    cases of suspending functions in the *Easy coroutines cancelation* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you'd like to learn more about concurrent, asynchronous tasks-scheduling
    with coroutines, you can take a look at the *Using coroutines for asynchronous,
    concurrent tasks execution with results handling* recipe. It explains how to schedule
    both sequential and concurrent tasks running in a common coroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying coroutines for asynchronous data processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to implement a generic extension for the `Iterable`
    type, which will provide a replacement for the `Iterable<T>.map()` function. Our
    implementation of the `Iterable<T>.mapConcurrent()` function is going to allow
    data-mapping-operation optimization by running it concurrently with coroutines.
    Next, we are going to test our concurrent mapping function implementation by employing
    it to perform a simulation of a time-expensive operation applied to each of the
    elements of a sample `Iterable` object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement an extension function for the generic `Iterable<T>` class responsible
    for handling the mapping operation of its elements concurrently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Simulate time-consuming mapping operations applied to the sample `Iterable`
    range elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the mapped elements to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Measure the total time of the concurrent-mapping operation''s execution and
    log it to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by analyzing the effects of applying the `mapConcurrent()` function
    we implemented at the beginning to transform elements of the `(0..10)` range of
    integers. In the lambda block passed to the `mapConcurrent` function, we are simulating
    a long-running processing operation suspending the coroutine for one second, using
    the `delay(1000)` function and returning a square of the original integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code is going to print the following results to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation of the `Iterable.mapConcurrent()` extension function takes
    a functional parameter, `transform: suspend (T) -> R`, which represents an operation
    that is going to be applied to each element of the original of the `Iterable`
    object. Under the hood, in order to perform data transformation concurrently,
    there is a new coroutine started for each of the original elements using the `async()`
    function, and the `transform` function is applied to them. At this point, the
    original `Iterable<T>` instance has been transformed to the `Iterable<Deferred<T>>`
    type. Next, the instances of the consecutive `Deferred` type, returned by invocations
    of `async()`, are synchronized and transformed to the generic `R` type by calling
    the `await()` functions on them. In the end, we have an `Iterable` of the desired `R` type
    returned.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in the output of our example, the transformation of 10 integer
    numbers using the `Iterable.mapConcurrent()` function took roughly one second
    on a standard computer. You can try running the same transformations using the
    standard `Iterable.map()` and it will take around 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In order to simulate the delay inside the `transform` lambda block passed to
    the `mapConcurrent()` function, we use the `delay()` function with a specified
    time value passed. The `delay()` is suspending the coroutine for a given amount
    of time, but it's not blocking a thread. The `transform` block is being executed
    for each of the elements on the pool of background threads. Whenever one coroutine
    is suspended, another one is starting to run in place of the first one. If we
    replace the non-blocking `delay(1000)` call with the blocking `Thread.sleep(1000)` function,
    our example will finish in about four seconds. It is still a big win compared
    to the standard `Iterable.map()` function which doesn't run concurrently by default.
  prefs: []
  type: TYPE_NORMAL
- en: The coroutines framework is designed to allow us to execute tasks in a non-blocking
    way. Although we are able to write non-blocking code inside a coroutine's scope,
    we need to provide a bridge to the original thread inside the application that
    starts the primary coroutine.  We are able to connect the non-blocking coroutine
    scope with the blocking world outside using the `runBlocking()` function. The `runBlocking()` function
    starts a new coroutine and blocks the current thread until its completion. It
    is designed to bridge regular blocking code to libraries that are written in suspending
    style. For example, it can be used in `main()` functions and in tests.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to learn more about the basics of the extension function mechanism,
    you can take a look at the *Extending functionalities of classes* recipe in [Chapter
    2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml), *Expressive Functions and Adjustable
    Interfaces*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy coroutine cancelation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore how to implement a coroutine that allows
    us to cancel its execution. We are going to create an infinite progress-bar animation
    running in the console in the background using a coroutine. Next, after a given
    delay, we are going to cancel the coroutine and test how the animation behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to start working with Kotlin Coroutines is to add a core framework
    dependency to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement a suspend function responsible for displaying an infinite progress-bar
    animation in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the `` `show progress animation`() `` function inside a new coroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Delay the parent thread by five seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Cancel the progress-bar animation job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the job to complete and log the completion event to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the end, our code is going to display a progress-bar animation for five seconds
    and then stop it. We are scheduling the `` `show progress animation`() `` function
    to run in the background by invoking it inside a new coroutine instance created
    by the `launch()` function. We are storing a handle to a `Job` instance returned
    by the `launch()` function under the job variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are suspending the outer `runBlocking()` coroutine scope by five seconds
    with the `delay(5000)` call. Once the `delay()` function resumes coroutine execution,
    we call the `cancel()` function on the coroutine `Job` responsible for displaying
    the progress-bar animation.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, inside the `` `show progress animation`() `` function, we are
    running an infinite `while` loop, which updates the last console line with a new
    progress-bar animation state every 50 milliseconds. However, as you can verify
    by running the example, the animation stops immediately after the corresponding
    `Job` responsible for running it gets canceled, even though, after the cancellation,
    we invoke the `join()` function to wait for its completion.
  prefs: []
  type: TYPE_NORMAL
- en: You can also make use of a `Job` extension function, called `cancelAndJoin()`, that
    combines the `cancel()` and `join()` calls together. However, if you don't want
    to wait for the actual coroutine stop-event, a simple `cancel()` call is enough.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to explore the basics of the coroutines framework, take a look
    at the *Using coroutines for asynchronous concurrent-tasks execution *and *Using
    coroutines for asynchronous concurrent-tasks execution with results-handling *recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a REST API client with Retrofit and a coroutines adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore how to employ coroutines to interact
    with remote endpoints using REST APIs. We are going to implement a REST client
    using the Retrofit library, allowing us to communicate over HTTP with the GitHub
    API asynchronously. Finally, we will use it in practice to fetch GitHub repositories
    search results for a given search query.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to start working with Kotlin Coroutines is to add a core framework
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make use of the Retrofit library with the coroutines adapter plugin,
    we also need to add the following dependencies to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares the required dependencies in a Gradle build script,
    which is used in a sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
    The `retrofit` module provides the core Retrofit library implementation. `converter-gson` adds
    a Gson plugin that enables automatic conversion of the JSON response to Kotlin model-data
    classes. The `retrofit2-kotlin-coroutines-experimental-adapter` module provides
    an adapter for async REST calls, allowing us to wrap the response using the Kotlin
    Coroutines `Deferred` type.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the GitHub REST API, which is available
    publicly. We are going to communicate with an endpoint responsible for returning
    search results containing GitHub repositories for a given search query. You can
    find detailed endpoint docs here: [https://developer.github.com/v3/search/#search-repositories](https://developer.github.com/v3/search/#search-repositories).
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `/search/repositories` endpoint allows us to access the remote resources
    using the `GET` method and passing the desired search phrase under the key, called
    `q`. For example, the URL with the `GET` request for repositories matching the
    `"live.parrot"` search phrase would look like this: `https://api.github.com/search/repositories?q=parrot.live`.
    The results delivered by the endpoint are formatted using the JSON format. You
    can check out how the raw response looks like by opening the example URL in your
    browser or using the `curl` command-line tool: `curl https://api.github.com/search/repositories?q=parrot.live`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare data classes modeling the server response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an interface modeling the GitHub endpoint usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiate the `GithubApi` interface using the `Retrofit` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a call to the endpoint using the `GithubApi` instance and pass `"kotlin"`
    as a search phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the response and get a reference to the obtained list of `Repository`
    class objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort the repositories list by the number of their stars count in decreasing
    order, and print them to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a result, our code is going to send a request to the server, fetch and process
    the response, and print the following results to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We have started by implementing model classes that represent the data returned
    in the server's JSON response. You may have seen that some of the properties are
    marked with the `@SerializedName()` annotation. The aim of this annotation is
    to indicate to the Gson library that the specified property should be deserialized
    from a JSON field which name matches the value passed to `@SerializedName()`.
    Next, we are declaring an interface, `GithubApi`, that represents the methods
    we want to use to communicate with the endpoint. We've declared a single method,
    called `searchRepositories`, which takes a `String` parameter that corresponds
    to the search-query value required by the repositories search endpoint. We've
    also marked the `searchRepositories` method with the `@GET` annotation, which
    specifies the REST method type to use and a path to the endpoint. The `searchRepositories`
    method should return an instance of a `Deferred<Response>` type, representing
    a *future *result of an asynchronous call. Implementation of the `GithubApi` interface
    is generated by the Retrofit library internally. In order to obtain the `GithubApi`
    instance, we need to instantiate the `Retrofit` type and configure it with the
    endpoint's URL address and mechanisms responsible for JSON deserializing and performing
    asynchronous calls to the server. Finally, we call `Retrofit.create(GithubApi::class.java)`
    to obtain the `GithubApi` instance. That's it!
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to execute the actual call to the server, we need to call the `GithubApi.searchRepositories()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in order to obtain a list of `Repository` objects from the response,
    we need to wait for the completion of the async call to the server and response
    parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we post-process the list of repositories obtained from the response.
    We are sorting it by the stars count, in decreasing order, and printing it to
    the console with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to explore the basics of the coroutines framework, take a look
    at the *Using coroutines for asynchronous concurrent-tasks execution *and *Using
    coroutines for asynchronous, concurrent tasks execution with results handling *recipes. You
    can learn more about the Retrofit library by exploring its homepage, [http://square.github.io/retrofit/](http://square.github.io/retrofit/),
    which contains useful examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping third-party callback-style APIs with coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often third-party libraries offer callback-style asynchronous APIs. However,
    the callback functions are considered to be an anti-pattern, especially whenever
    we are dealing with a number of nested callbacks. In this recipe, we are going
    to learn how to deal with libraries that provide callback-style methods by transforming
    them easily into suspending functions that can be run using coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to start working with Kotlin Coroutines is to add the core framework
    dependency to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as the recipe task is concerned, let''s assume we have a class called
    `Result`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `getResultsAsync()` function, which simulates the third-party callback-style
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `getResultsAsync()` function just starts a background thread, delays it
    for a second, and invokes a callback function passed to it as an argument delivering
    the list of the `Result` class object to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wrap the `getResultsAsync()` function with the suspend function, returning
    the results directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a coroutine and invoke the `getResults()` suspending function inside
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the results and print them to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the end, our code is going to print the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve successfully managed to transform the callback-style `getResultsAsync(callback:
    (List<Result>) -> Unit)` function into the clean form of a suspending function
    returning the results directly–`suspend fun getResults(): List<Result>`. In order
    to get rid of the original `callback` argument, we have used the `suspendCoroutine()`
    function provided by the standard library. The `suspendCoroutine()` function takes
    the `block: (Continuation<T>) -> Unit` function type as an argument. The `Continuation`
    interface is designed to allow us to resume the coroutine paused by a suspending
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: When the `suspendCoroutine` function is called inside a coroutine, it captures
    its execution state in a `Continuation` instance and passes this continuation
    to the specified block as an argument. To resume execution of the coroutine, the
    block may invoke either `continuation.resume()` or `continuation.resumeWithException()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We invoke the original `getResultsAcync()` function inside the lambda passed
    to the `suspendCoroutine()` function, and we call the `continuation.resume(it)` 
    function in the `callback` lambda blocked passed to the `getResultsAsync()` function
    as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As the result, the coroutine inside which `getResults()` is called will become
    suspended until the `callback` lambda is executed internally in the `getResultsAsync()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to explore the basics of the coroutines framework, take a look
    at the *Using coroutines for asynchronous, concurrent tasks execution* and *Using
    coroutines for asynchronous, concurrent tasks execution with results handling*
    recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
