- en: Making Asynchronous Programming Great Again
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让异步编程再次伟大
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Executing tasks in the background using threads
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程在后台执行任务
- en: Background threads synchronization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台线程同步
- en: Using coroutines for asynchronous, concurrent execution of tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程进行异步、并发任务执行
- en: Using coroutines for asynchronous, concurrent tasks execution with results handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程执行异步、并发任务执行并处理结果
- en: Applying coroutines for asynchronous data processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用协程进行异步数据处理
- en: Easy coroutine cancelation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的协程取消
- en: Building a REST API client with Retrofit and a coroutines adapter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Retrofit 和协程适配器构建 REST API 客户端
- en: Wrapping third-party callback-style APIs with coroutines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程包装第三方回调式 API
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is going to address various aspects of asynchronous programming
    problems. The first two recipes, *Executing tasks in the background using threads*
    and *Background-threads synchronization*,are going to explain the standard library
    support for running background tasks using JVM threads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论异步编程问题的各个方面。前两个食谱，“使用线程在后台执行任务”和“后台线程同步”，将解释标准库对使用 JVM 线程运行后台任务的支持。
- en: In the further recipes, we are going to delve more deeply into the powerful
    Kotlin Coroutines framework. Those recipes are going to explain a general usage
    of coroutines for asynchronous and concurrent tasks executing. They will also
    present how to employ coroutines for solving more specific daily-life programming
    problems, such as concurrent data processing, asynchronous REST-call handling,
    and working with third-party callback-style APIs in a clean way. After reading
    this chapter, you will feel convenient applying the coroutines framework to write
    robust asynchronous code or to optimize your code by running expensive computations
    concurrently.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的食谱中，我们将更深入地探讨强大的 Kotlin 协程框架。这些食谱将解释协程在异步和并发任务执行中的通用用法。它们还将展示如何使用协程解决更具体的日常编程问题，例如并发数据处理、异步
    REST 调用处理，以及以整洁的方式与第三方回调式 API 一起工作。阅读完这一章后，您将感到方便地将协程框架应用于编写健壮的异步代码，或通过并发运行昂贵的计算来优化您的代码。
- en: The Kotlin Coroutines framework is not only a handy replacement for platform-specific
    concurrency and async frameworks. Its power is based on providing a unified, universal
    API that allows us to write asynchronous code, which can be run both on JVM, Android,
    JavaScript, and native platforms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 协程框架不仅是一个平台特定并发和异步框架的便捷替代品。其力量在于提供统一的、通用的 API，使我们能够编写可以在 JVM、Android、JavaScript
    和本地平台上运行的异步代码。
- en: Executing tasks in the background using threads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程在后台执行任务
- en: In this recipe, we are going to explore how to work effectively with the JVM
    `Thread` class in a clean way using the Kotlin standard library functions dedicated
    to convenient thread-running. We are going to simulate two long-running tasks
    and execute them concurrently in background threads.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨如何使用 Kotlin 标准库中专门为方便线程运行而设计的函数，以整洁的方式有效地与 JVM `Thread` 类一起工作。我们将模拟两个长时间运行的任务，并在后台线程中并发执行它们。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we are going to make use of two functions simulating long-running
    operations. Here is the first:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用两个模拟长时间运行操作的功能。这是第一个：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here is the second:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'They are both just responsible for blocking a current thread for five and two seconds,
    respectively, in order to simulate long-running tasks. We will also make use of
    the predefined function returning the current thread name for debugging purposes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它们两者都只是分别阻塞当前线程五秒和两秒，以模拟长时间运行的任务。我们还将使用预定义的函数返回当前线程名称，用于调试目的：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start by logging the current thread name to the console:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先记录当前线程名称到控制台：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Start a new `Thread` and invoke the `` `5 sec long task`() `` function inside
    it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的 `Thread` 中启动并调用 `5 sec long task()` 函数：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start another `Thread` and invoke `` `2 sec long task`() `` inside it:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个 `Thread` 中启动另一个 `Thread` 并调用 `2 sec long task()`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding code is going to print the following text to the console:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印以下文本到控制台：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have successfully started two background threads, which are
    running concurrently. We are using the `thread()` utility function from the `kotlin.concurrent`
    package, which is responsible for instantiating and starting a new thread that
    runs a block of code passed to it in the form of a lambda expression.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经成功启动了两个并发运行的后台线程。我们使用来自 `kotlin.concurrent` 包的 `thread()` 工具函数，该函数负责实例化和启动一个新的线程，该线程以
    lambda 表达式的形式运行传递给它的代码块。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Take a look at the rest of the recipes to discover how to use the Kotlin Coroutines
    framework to replace the threading mechanism with a more robust and flexible framework.
    A good starting point could be the *Using coroutines for asynchronous concurrent-tasks
    execution *and *Using coroutines for asynchronous concurrent-tasks execution with
    results-handling *recipes.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看其余的菜谱，了解如何使用 Kotlin 协程框架用更强大和灵活的框架替换线程机制。一个好的起点可以是 *使用协程执行异步并发任务* 和 *使用协程执行异步并发任务并处理结果*
    菜谱。
- en: Background threads synchronization
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景线程同步
- en: In this recipe, we are going to explore how to work effectively with the JVM
    `Thread` class in a clean way using the Kotlin standard library functions dedicated
    to running threads in a convenient way. We are going to simulate two long-running
    tasks and execute them in background threads synchronously.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何使用 Kotlin 标准库中专门用于以方便方式运行线程的函数，以干净的方式有效地与 JVM `Thread` 类一起工作。我们将模拟两个长时间运行的任务，并在后台线程中同步执行它们。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we are going to make use of the following two functions to
    simulate long-running operations. The `` `5 sec long task`() `` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用以下两个函数来模拟长时间运行的操作。`5 秒长任务()` 函数：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'and the `` `2 sec long task`() `` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 `2 秒长任务()` 函数：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'They are both just responsible for blocking a current thread for five and two
    seconds, respectively, in order to simulate long-running tasks. We will also make
    use of the predefined function returning the current thread name for debugging
    purposes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它们各自仅负责阻塞当前线程五秒和两秒，以模拟长时间运行的任务。我们还将使用预定义的函数返回当前线程名称，用于调试目的：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start by logging the current thread name to the console:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先记录当前线程名称到控制台：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Start a new `Thread` and invoke the `` `5 sec long task`() `` function inside
    it:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中启动一个新的 `Thread` 并调用 `5 秒长任务()` 函数：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wait until the thread completes:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待线程完成：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start another `Thread` and invoke `` `2 sec long task`() `` inside it:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中启动另一个 `Thread` 并调用 `2 秒长任务()` 函数：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wait until the thread completes:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待线程完成：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Test whether the main thread is free at the end:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结束时测试主线程是否空闲：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding code is going to print the following text to the console:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将打印以下文本到控制台：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have successfully started two background threads, which are synchronized.
    In order to run both background threads sequentially, we are using the `Thread.join()`
    function, which just blocks the main thread until the background thread completes.
    In order to instantiate and start a new background thread, we are using the `thread()` utility
    function from the `kotlin.concurrent` package. We are passing it a block of code
    to be run inside the thread inside a lambda expression.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功启动了两个同步的后台线程。为了顺序运行这两个后台线程，我们使用了 `Thread.join()` 函数，它只是阻塞主线程，直到后台线程完成。为了实例化和启动一个新的后台线程，我们使用了来自
    `kotlin.concurrent` 包的 `thread()` 工具函数。我们向它传递一个以 lambda 表达式形式传递给它的代码块，以在线程中运行。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Take a look at the next recipes explaining how to use the Kotlin Coroutines
    framework to replace the threading mechanism with a more robust and flexible framework.
    A good starting point could be the *Using coroutines for asynchronous concurrent-tasks
    execution *and *Using coroutines for asynchronous concurrent-tasks execution with
    results-handling *recipes.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看下一组菜谱，了解如何使用 Kotlin 协程框架用更强大和灵活的框架替换线程机制。一个好的起点可以是 *使用协程执行异步并发任务* 和 *使用协程执行异步并发任务并处理结果*
    菜谱。
- en: Using coroutines for asynchronous, concurrent execution of tasks
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程进行异步、并发任务执行
- en: In this recipe, we are going to explore how to use the coroutines framework
    in order to schedule asynchronous, concurrent execution of tasks. We are going
    to learn both how to synchronize a sequence of short background tasks and how
    to run expensive, long-running ones at the same time. We will simulate the sushi
    rolls preparation process to discover how to schedule blocking and non-blocking
    tasks together.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何使用协程框架来安排异步、并发的任务执行。我们将学习如何同步一系列短的后台任务，以及如何同时运行昂贵、长时间运行的任务。我们将通过模拟寿司卷准备过程来发现如何一起安排阻塞和非阻塞任务。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step to start working with Kotlin Coroutines is to add the core framework
    dependency to the project:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Kotlin协程的第一步是将核心框架依赖项添加到项目中：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在Gradle构建脚本中声明了`kotlinx-coroutines-core`依赖项，该依赖项用于示例项目（[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)）。
- en: 'In the current recipe, we will assume our sushi-cooking simulation requires
    the four following steps to be performed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前菜谱中，我们将假设我们的寿司烹饪模拟需要执行以下四个步骤：
- en: Cook the rice
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 煮米饭
- en: Prepare the fish
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备鱼
- en: Cut the vegetables
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切蔬菜
- en: Roll the sushi
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卷寿司
- en: 'These steps are going to be simulated by the following functions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将由以下函数来模拟：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will also use the following function to log a current thread name to the
    console:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以下函数来记录当前线程名称到控制台：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the sake of the exercise, we will assume the sushi-roll preparation process
    must fulfill the following requirements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习的目的，我们将假设寿司卷准备过程必须满足以下要求：
- en: The longest *Rice-cooking* step must be executed in the background in a non-blocking
    way
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最长的*煮饭*步骤必须在后台以非阻塞方式执行
- en: The *Fish-preparation* and *Vegetable-cutting* steps have to be performed one
    by one while the rice is cooking
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*鱼准备*和*切菜*步骤必须在煮饭时依次执行'
- en: The *Sushi-rolling* step can be done only when the first three steps are completed
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*卷寿司*步骤只能在完成前三个步骤后进行'
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start by logging the current thread name to the console:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先记录当前线程名称到控制台：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Start a new coroutine running on a pool of background threads:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台线程池上启动一个新的协程：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the `` `cook rice`() `` function asynchronously in a nested coroutine:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在嵌套协程中异步执行`cook rice()`函数：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the `` `prepare fish`() `` and  `` `cut vegetable`() `` functions sequentially
    while the `` `cook rice`() `` function is running in the background:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台运行`cook rice()`函数的同时，按顺序运行`prepare fish()`和`cut vegetable()`函数：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Wait until the rice-cooking coroutine completes:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待米饭烹饪的协程完成：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Invoke the final `` `roll the sushi`() `` function and wait until the main
    coroutine completes:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用最终的`roll the sushi()`函数并等待主协程完成：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Measure the total time for function execution and log it to the console:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量函数执行的总时间并将其记录到控制台：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding code is going to print the following text to the console:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在控制台打印以下文本：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the beginning, we start a new coroutine running on a background thread with
    the `launch()` function call. We also create a handle to the `Job` instance returned
    by the `launch()` function under the `var sushiCookingJob: Job` variable.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '在开始时，我们使用`launch()`函数调用在后台线程上启动一个新的协程。我们还在`var sushiCookingJob: Job`变量下创建了`launch()`函数返回的`Job`实例的句柄。'
- en: The `launch()` function starts a new coroutine instance on a default `CoroutineContext`
    instance. However, we are able to pass our desired `CoroutineContext` as an additional
    parameter to the `launch()` function. When targeting the JVM platform, by default
    the `launch()` function starts a coroutine on a pool of background threads, which
    corresponds to the `CommonPool` context constant. We can also run the coroutine
    on a single thread by passing a context result of the `newSingleThreadContext()` function.
    If you are working with UI frameworks, such as Android, Swing, or JavaFx, you
    can run a coroutine on a `UI` context as well. The `UI` context is related to
    the main thread responsible for user-interface updates. There are different modules
    that provide the `UI` context implementation dedicated to a specific framework.
    You can learn more about framework-specific UI programming with coroutines in
    the following official guide: [https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch()`函数在默认的`CoroutineContext`实例上启动一个新的协程实例。然而，我们可以将我们想要的`CoroutineContext`作为附加参数传递给`launch()`函数。在针对JVM平台时，默认情况下，`launch()`函数在一个后台线程池上启动协程，这对应于`CommonPool`上下文常量。我们也可以通过传递`newSingleThreadContext()`函数的上下文结果来在单个线程上运行协程。如果你正在使用UI框架，如Android、Swing或JavaFx，你还可以在`UI`上下文中运行协程。`UI`上下文与负责用户界面更新的主线程相关。有不同模块提供针对特定框架的`UI`上下文实现。你可以在以下官方指南中了解更多关于特定框架的协程UI编程：[https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md)。'
- en: 'Inside the main coroutine, we are starting a new one and invoking the `` `cook
    rice`() `` function inside it. We are storing a handle to the `Job` instance corresponding
    to the coroutine handling the `` `cook rice`() `` function under the `val riceCookingJob:
    Job` variable. At this point, the rice-cooking task begins to run concurrently
    on a pool of threads.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '在主协程内部，我们启动一个新的协程，并在其中调用`cook rice()`函数。我们将对应于处理`cook rice()`函数的协程的`Job`实例的句柄存储在`val
    riceCookingJob: Job`变量下。此时，米饭烹饪任务开始在多个线程的线程池上并发运行。'
- en: Next, we are invoking two functions—`` `prepare fish`() `` and `` `cut vegetable`()
    ``. As you can see in the console output, those functions are executed sequentially.
    The vegetable-cutting task starts right after the fish-preparation completes.
    If we'd like to run them concurrently, we'd need to start each one inside a new
    coroutine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用两个函数——`prepare fish()`和`cut vegetable()`。正如你在控制台输出中看到的，这些函数是顺序执行的。蔬菜切割任务在鱼准备完成后立即开始。如果我们想并发运行它们，我们需要在每个函数内部启动一个新的协程。
- en: Finally, we wait for the completion of the rice-cooking task by calling a `join()` function
    on the `riceCookingJob` variable. Here, the `join()` function suspends the primary `sushiCookingJob`
    coroutine until `riceCookingJob` is complete. Right after the primary coroutine
    gets unblocked, the last  `` `roll the sushi`() `` function is invoked.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在`riceCookingJob`变量上调用一个`join()`函数来等待米饭烹饪任务的完成。在这里，`join()`函数挂起主`sushiCookingJob`协程，直到`riceCookingJob`完成。在主协程解除阻塞后，紧接着调用的最后一个函数是`roll
    the sushi()`。
- en: In order to await the primary coroutine completion, we need to invoke a `join()`
    function on the `sushiCookingJob` instance after starting it on the main thread.
    However, we are not able to call the `join()` function outside of a coroutine
    scope. We need to call it inside a new *blocking* coroutine started with a `runBlocking()`
    function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了等待主协程完成，我们需要在主线程上启动它之后，在`sushiCookingJob`实例上调用一个`join()`函数。然而，我们无法在协程作用域之外调用`join()`函数。我们需要在用`runBlocking()`函数启动的新*阻塞*协程内部调用它。
- en: The coroutines framework is designed to allow us to execute tasks in a non-blocking
    way. Although we are able to write non-blocking code inside a coroutine's scope,
    we need to provide a bridge to the original thread inside the application that
    starts the primary coroutine.  We are able to connect the non-blocking coroutine
    scope with the blocking world outside using the `runBlocking()` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 协程框架旨在允许我们以非阻塞方式执行任务。尽管我们能够在协程的作用域内编写非阻塞代码，但我们仍需要提供一个桥梁，将启动主协程的应用程序中的原始线程连接起来。我们可以使用`runBlocking()`函数将非阻塞的协程作用域与外部的阻塞世界连接起来。
- en: The `runBlocking()` function starts a new coroutine and blocks the current thread
    until its completion. It is designed to bridge regular blocking code to libraries
    that are written in suspending style. For example, it can be used in `main()`
    functions and in tests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`runBlocking()` 函数启动一个新的协程并阻塞当前线程，直到其完成。它旨在将常规阻塞代码与以挂起风格编写的库桥接起来。例如，它可以在 `main()`
    函数和测试中使用。'
- en: 'Coroutines can be seen as lightweight thread replacements. Coroutines are lightweight
    in terms of resource consumption. For example, we can start a million coroutines
    concurrently with ease, where, after a second, each of them logs the current thread
    name to the console:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以被视为轻量级的线程替代品。在资源消耗方面，协程是轻量级的。例如，我们可以轻松地同时启动一百万个协程，其中每个协程在两秒钟后都将当前线程名称记录到控制台：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code will complete in about 10 seconds on a standard computer.
    In contrast, if we try to run this code using threads, we get the `OutOfMemoryError:
    unable to create new native thread` exception.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '之前的代码在标准计算机上大约需要 10 秒钟才能完成。相比之下，如果我们尝试使用线程运行此代码，我们会得到 `OutOfMemoryError: unable
    to create new native thread` 异常。'
- en: See also
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can follow up by reading the *Using coroutines for asynchronous, concurrent
    tasks execution with results handling*recipe. It shows you how to asynchronously
    schedule functions that return the results.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过阅读 *使用协程进行异步、并发任务执行以及结果处理* 菜谱来跟进。它展示了如何异步安排返回结果的函数。
- en: Using coroutines for asynchronous, concurrent tasks execution with results handling
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程进行异步、并发任务执行以及结果处理
- en: In this recipe, we are going to explore how to use the coroutines framework
    in order to run asynchronous operations concurrently, and learn how to handle
    the results they return properly. We are going to schedule two tasks and run them
    in the background using two coroutines. The first task is going to be responsible
    for displaying the progress-bar animation. The second one is going to simulate
    long-running computations. In the end, we are going to print the results returned
    by the second task to the console.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索如何使用协程框架来并发运行异步操作，并学习如何正确处理它们返回的结果。我们将安排两个任务，并使用两个协程在后台运行它们。第一个任务将负责显示进度条动画。第二个任务将模拟长时间运行的计算。最后，我们将打印第二个任务返回的结果到控制台。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step to start working with Kotlin Coroutines is to add a core framework
    dependency to the project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Kotlin 协程的第一步是将核心框架依赖项添加到项目中：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在 Gradle 构建脚本中声明了 `kotlinx-coroutines-core` 依赖项，该依赖项用于示例项目 ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook))。
- en: 'In the current recipe, we are going to make use of the following two functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前菜谱中，我们将使用以下两个函数：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first one is simulating an expensive computation that delays a thread for
    five seconds and returns the result in the end. The second one is responsible
    for displaying an infinite progress-bar animation. We are going to start both
    operations concurrently and wait for the result returned by the first one. After
    we get the result, we will print it to the console.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是模拟一个昂贵的计算，它将线程延迟五秒钟并在最后返回结果。第二个函数负责显示无限进度条动画。我们将同时启动这两个操作并等待第一个操作返回的结果。在得到结果后，我们将将其打印到控制台。
- en: 'We will also use the following function to log a current thread name to the
    console:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以下函数将当前线程名称记录到控制台：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Start by logging a current thread name to the console:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先记录当前线程名称到控制台：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start a coroutine responsible for displaying progress-bar animation from the
    background:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个协程，负责从后台显示进度条动画：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Start a coroutine responsible for running the `` `calculate the answer to life
    the universe and everything`() `` function in the background:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个协程，负责在后台运行 `calculate the answer to life the universe and everything()`
    函数：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Wait for the result returned by the `future` coroutine and print it to the
    console:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 `future` 协程返回的结果并将其打印到控制台：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our code is going to display the progress-bar animation for five seconds and
    then print the result of the `` `calculate the answer to life the universe and
    everything`() `` function once it completes the simulated calculations:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写代码以显示进度条动画五秒钟，然后一旦模拟计算完成，将打印`calculate the answer to life the universe
    and everything()`函数的结果：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start the execution of `` `calculate the answer to life the universe and
    everything`() `` in the background task using the `async()` function. It just
    starts a new coroutine and returns an instance of a `Deferred<T>` class. The generic `T` type
    corresponds to the type of object that is returned by `async()`.  An instance
    of the `Deferred<T>` type is just a pointer to the future result delivered by
    the coroutine. It's a representation of asynchronous programming constructs, called *futures* or *promises*.
    We are able to evaluate the value of a `Deferred` object by calling the `await()`
    function on it. However, we are not able to call the `await()` function outside
    a coroutine scope. We need to call it inside a new *blocking* coroutine started
    with a `runBlocking()` function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`async()`函数在后台任务中启动`calculate the answer to life the universe and everything()`函数的执行。它只是启动一个新的协程并返回一个`Deferred<T>`类的实例。泛型`T`类型对应于`async()`返回的对象类型。`Deferred<T>`类型的实例只是指向协程提供的未来结果的指针。它是异步编程结构的表示，称为*future*或*promise*。我们可以通过在`Deferred`对象上调用`await()`函数来评估`Deferred`对象的值。然而，我们无法在协程作用域之外调用`await()`函数。我们需要在用`runBlocking()`函数启动的新*阻塞*协程内部调用它。
- en: The coroutines framework is designed to allow us to execute tasks in a non-blocking
    way. Although we are able to write non-blocking code inside a coroutine's scope,
    we need to provide a bridge to the original thread inside the application that
    starts the primary coroutine. We are able to connect the non-blocking coroutine
    scope with the blocking world outside using the `runBlocking()` function. The `runBlocking()` function
    starts a new coroutine and blocks the current thread until its completion. It
    is designed to bridge regular blocking code to libraries that are written in suspending
    style. For example, it can be used in `main()` functions and in tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 协程框架旨在允许我们以非阻塞方式执行任务。尽管我们能够在协程的作用域内编写非阻塞代码，但我们仍需要提供一个连接到启动主协程的应用程序中原始线程的桥梁。我们可以使用`runBlocking()`函数将非阻塞的协程作用域与阻塞的外部世界连接起来。`runBlocking()`函数启动一个新的协程并阻塞当前线程直到其完成。它旨在将常规阻塞代码与以挂起风格编写的库桥接起来。例如，它可以在`main()`函数和测试中使用。
- en: As far as the progress-bar animation is concerned, we are scheduling it in the
    background using the `launch()` function. `launch()` is responsible for starting
    a new coroutine, however, it does not care about delivering the final results.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就进度条动画而言，我们正在使用`launch()`函数在后台安排它。`launch()`负责启动一个新的协程，然而，它并不关心交付最终结果。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: You may have noticed our predefined functions are marked with the `suspend` modifier
    declared before the `fun` keyword, for example, ``**suspend** fun `show progress
    animation`()``. The reason behind this is that we need to declare explicitly that
    the function is going to run inside the coroutine scope to be able to use coroutine-specific
    features inside the function's body. In our case, we are using the `delay()` function,
    which can be invoked only inside a coroutine scope. It is responsible for pausing
    the coroutine for a given amount of time without blocking the current thread.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的预定义函数在`fun`关键字之前标记了`suspend`修饰符，例如，``**suspend** fun `show progress
    animation`()``。背后的原因是，我们需要明确声明函数将在协程作用域内运行，以便能够在函数体内部使用协程特定的功能。在我们的例子中，我们使用了`delay()`函数，它只能在协程作用域内调用。它负责暂停协程一段时间而不阻塞当前线程。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can investigate another usage of the `delay()` function in the *Applying
    coroutines for asynchronous data processing* recipe. You can also explore different use
    cases of suspending functions in the *Easy coroutines cancelation* recipe.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在*Applying coroutines for asynchronous data processing*菜谱中调查`delay()`函数的另一种用法。你还可以在*Easy
    coroutines cancelation*菜谱中探索挂起函数的不同用例。
- en: If you'd like to learn more about concurrent, asynchronous tasks-scheduling
    with coroutines, you can take a look at the *Using coroutines for asynchronous,
    concurrent tasks execution with results handling* recipe. It explains how to schedule
    both sequential and concurrent tasks running in a common coroutine.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于使用协程进行并发、异步任务调度的信息，您可以查看 *使用协程进行异步、并发任务执行及结果处理* 菜谱。它解释了如何调度在公共协程中运行的顺序和并发任务。
- en: Applying coroutines for asynchronous data processing
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用协程进行异步数据处理
- en: In this recipe, we are going to implement a generic extension for the `Iterable`
    type, which will provide a replacement for the `Iterable<T>.map()` function. Our
    implementation of the `Iterable<T>.mapConcurrent()` function is going to allow
    data-mapping-operation optimization by running it concurrently with coroutines.
    Next, we are going to test our concurrent mapping function implementation by employing
    it to perform a simulation of a time-expensive operation applied to each of the
    elements of a sample `Iterable` object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为 `Iterable` 类型实现一个泛型扩展，它将提供 `Iterable<T>.map()` 函数的替代方案。我们的 `Iterable<T>.mapConcurrent()`
    函数实现将通过与协程并发运行来优化数据映射操作。接下来，我们将通过将其应用于模拟对样本 `Iterable` 对象每个元素应用耗时操作来测试我们的并发映射函数实现。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Implement an extension function for the generic `Iterable<T>` class responsible
    for handling the mapping operation of its elements concurrently:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为泛型 `Iterable<T>` 类实现一个扩展函数，用于处理其元素的并发映射操作：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Simulate time-consuming mapping operations applied to the sample `Iterable`
    range elements:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟对样本 `Iterable` 范围元素应用耗时映射操作：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Print the mapped elements to the console:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将映射后的元素打印到控制台：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Measure the total time of the concurrent-mapping operation''s execution and
    log it to the console:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量并发映射操作执行的总时间并将其记录到控制台：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start by analyzing the effects of applying the `mapConcurrent()` function
    we implemented at the beginning to transform elements of the `(0..10)` range of
    integers. In the lambda block passed to the `mapConcurrent` function, we are simulating
    a long-running processing operation suspending the coroutine for one second, using
    the `delay(1000)` function and returning a square of the original integer value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先分析一下，将我们在开头实现的 `mapConcurrent()` 函数应用于整数范围 `(0..10)` 的元素时产生的影响。在传递给 `mapConcurrent`
    函数的 lambda 块中，我们正在模拟一个长时间运行的处理操作，通过使用 `delay(1000)` 函数挂起协程一秒钟，并返回原始整数值的平方。
- en: 'Our code is going to print the following results to the console:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将打印以下结果到控制台：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our implementation of the `Iterable.mapConcurrent()` extension function takes
    a functional parameter, `transform: suspend (T) -> R`, which represents an operation
    that is going to be applied to each element of the original of the `Iterable`
    object. Under the hood, in order to perform data transformation concurrently,
    there is a new coroutine started for each of the original elements using the `async()`
    function, and the `transform` function is applied to them. At this point, the
    original `Iterable<T>` instance has been transformed to the `Iterable<Deferred<T>>`
    type. Next, the instances of the consecutive `Deferred` type, returned by invocations
    of `async()`, are synchronized and transformed to the generic `R` type by calling
    the `await()` functions on them. In the end, we have an `Iterable` of the desired `R` type
    returned.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '我们实现的 `Iterable.mapConcurrent()` 扩展函数接受一个函数参数 `transform: suspend (T) -> R`，它表示将要应用于
    `Iterable` 对象原始元素的运算。在底层，为了实现并发数据转换，我们为每个原始元素使用 `async()` 函数启动一个新的协程，并将 `transform`
    函数应用于它们。此时，原始的 `Iterable<T>` 实例已经被转换成了 `Iterable<Deferred<T>>` 类型。接下来，通过在它们上调用
    `await()` 函数，将 `async()` 调用返回的连续 `Deferred` 类型实例同步，并转换为通用的 `R` 类型。最后，我们得到了一个返回所需
    `R` 类型的 `Iterable`。'
- en: As you can see, in the output of our example, the transformation of 10 integer
    numbers using the `Iterable.mapConcurrent()` function took roughly one second
    on a standard computer. You can try running the same transformations using the
    standard `Iterable.map()` and it will take around 10 seconds.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在我们的示例输出中，使用 `Iterable.mapConcurrent()` 函数对 10 个整数进行转换在大约一秒钟内完成，在标准计算机上。您可以尝试使用标准的
    `Iterable.map()` 运行相同的转换，它将需要大约 10 秒钟。
- en: In order to simulate the delay inside the `transform` lambda block passed to
    the `mapConcurrent()` function, we use the `delay()` function with a specified
    time value passed. The `delay()` is suspending the coroutine for a given amount
    of time, but it's not blocking a thread. The `transform` block is being executed
    for each of the elements on the pool of background threads. Whenever one coroutine
    is suspended, another one is starting to run in place of the first one. If we
    replace the non-blocking `delay(1000)` call with the blocking `Thread.sleep(1000)` function,
    our example will finish in about four seconds. It is still a big win compared
    to the standard `Iterable.map()` function which doesn't run concurrently by default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在传递给 `mapConcurrent()` 函数的 `transform` lambda 块内部模拟延迟，我们使用带有指定时间值的 `delay()`
    函数。`delay()` 函数会暂停协程一段时间，但不会阻塞线程。`transform` 块将为后台线程池中的每个元素执行。每当一个协程被暂停时，另一个协程就会在原地开始运行以替代第一个协程。如果我们用阻塞的
    `Thread.sleep(1000)` 函数替换非阻塞的 `delay(1000)` 调用，我们的示例将大约在四秒内完成。与默认不并发运行的 `Iterable.map()`
    函数相比，这仍然是一个巨大的进步。
- en: The coroutines framework is designed to allow us to execute tasks in a non-blocking
    way. Although we are able to write non-blocking code inside a coroutine's scope,
    we need to provide a bridge to the original thread inside the application that
    starts the primary coroutine.  We are able to connect the non-blocking coroutine
    scope with the blocking world outside using the `runBlocking()` function. The `runBlocking()` function
    starts a new coroutine and blocks the current thread until its completion. It
    is designed to bridge regular blocking code to libraries that are written in suspending
    style. For example, it can be used in `main()` functions and in tests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 协程框架旨在允许我们以非阻塞的方式执行任务。尽管我们能够在协程的作用域内编写非阻塞代码，但我们仍需要为启动主协程的应用程序中的原始线程提供一个桥梁。我们能够使用
    `runBlocking()` 函数将非阻塞的协程作用域与外部的阻塞世界连接起来。`runBlocking()` 函数启动一个新的协程并阻塞当前线程，直到其完成。它旨在将常规阻塞代码与以挂起风格编写的库桥接起来。例如，它可以在
    `main()` 函数和测试中使用。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to learn more about the basics of the extension function mechanism,
    you can take a look at the *Extending functionalities of classes* recipe in [Chapter
    2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml), *Expressive Functions and Adjustable
    Interfaces*
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于扩展函数机制的基础知识，你可以查看[第2章](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml)中的*扩展类的功能*配方，*表达性函数和可调整接口*。
- en: Easy coroutine cancelation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的协程取消
- en: In this recipe, we are going to explore how to implement a coroutine that allows
    us to cancel its execution. We are going to create an infinite progress-bar animation
    running in the console in the background using a coroutine. Next, after a given
    delay, we are going to cancel the coroutine and test how the animation behaves.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨如何实现一个允许我们取消其执行的协程。我们将使用协程在后台控制台创建一个无限进度条动画。接下来，在给定延迟后，我们将取消协程并测试动画的行为。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step to start working with Kotlin Coroutines is to add a core framework
    dependency to the project:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Kotlin 协程的第一步是将核心框架依赖项添加到项目中：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在 Gradle 构建脚本中声明了 `kotlinx-coroutines-core` 依赖项，该依赖项用于示例项目 ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook))。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Implement a suspend function responsible for displaying an infinite progress-bar
    animation in the console:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个负责在控制台显示无限进度条动画的挂起函数：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Launch the `` `show progress animation`() `` function inside a new coroutine:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的协程中启动 `show progress animation()` 函数：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Delay the parent thread by five seconds:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停父线程五秒钟：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Cancel the progress-bar animation job:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消进度条动画任务：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Wait for the job to complete and log the completion event to the console:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待作业完成并将完成事件记录到控制台：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the end, our code is going to display a progress-bar animation for five seconds
    and then stop it. We are scheduling the `` `show progress animation`() `` function
    to run in the background by invoking it inside a new coroutine instance created
    by the `launch()` function. We are storing a handle to a `Job` instance returned
    by the `launch()` function under the job variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的代码将显示一个持续五秒的进度条动画，然后停止。我们通过在由`launch()`函数创建的新协程实例内部调用它，来安排`show progress
    animation()`函数在后台运行。我们将`launch()`函数返回的`Job`实例的句柄存储在`job`变量下。
- en: Next, we are suspending the outer `runBlocking()` coroutine scope by five seconds
    with the `delay(5000)` call. Once the `delay()` function resumes coroutine execution,
    we call the `cancel()` function on the coroutine `Job` responsible for displaying
    the progress-bar animation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`delay(5000)`调用将外部的`runBlocking()`协程作用域挂起五秒。一旦`delay()`函数恢复协程执行，我们就调用负责显示进度条动画的协程`Job`上的`cancel()`函数。
- en: Under the hood, inside the `` `show progress animation`() `` function, we are
    running an infinite `while` loop, which updates the last console line with a new
    progress-bar animation state every 50 milliseconds. However, as you can verify
    by running the example, the animation stops immediately after the corresponding
    `Job` responsible for running it gets canceled, even though, after the cancellation,
    we invoke the `join()` function to wait for its completion.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，在`show progress animation()`函数内部，我们运行一个无限`while`循环，每50毫秒更新一次最后一条控制台行，以显示新的进度条动画状态。然而，正如你可以通过运行示例来验证的那样，动画在负责运行它的`Job`被取消后立即停止，尽管在取消后，我们调用了`join()`函数来等待其完成。
- en: You can also make use of a `Job` extension function, called `cancelAndJoin()`, that
    combines the `cancel()` and `join()` calls together. However, if you don't want
    to wait for the actual coroutine stop-event, a simple `cancel()` call is enough.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一个名为`cancelAndJoin()`的`Job`扩展函数，它将`cancel()`和`join()`调用组合在一起。然而，如果你不想等待实际的协程停止事件，一个简单的`cancel()`调用就足够了。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to explore the basics of the coroutines framework, take a look
    at the *Using coroutines for asynchronous concurrent-tasks execution *and *Using
    coroutines for asynchronous concurrent-tasks execution with results-handling *recipes
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要探索协程框架的基础知识，请查看*使用协程执行异步并发任务*和*使用协程执行异步并发任务并处理结果*配方
- en: Building a REST API client with Retrofit and a coroutines adapter
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Retrofit和协程适配器构建REST API客户端
- en: In this recipe, we are going to explore how to employ coroutines to interact
    with remote endpoints using REST APIs. We are going to implement a REST client
    using the Retrofit library, allowing us to communicate over HTTP with the GitHub
    API asynchronously. Finally, we will use it in practice to fetch GitHub repositories
    search results for a given search query.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探索如何使用协程通过REST API与远程端点交互。我们将使用Retrofit库实现REST客户端，允许我们异步地通过HTTP与GitHub
    API通信。最后，我们将将其用于实际操作，以获取给定搜索查询的GitHub存储库搜索结果。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step to start working with Kotlin Coroutines is to add a core framework
    dependency:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Kotlin协程的第一步是添加一个核心框架依赖项：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In order to make use of the Retrofit library with the coroutines adapter plugin,
    we also need to add the following dependencies to our project:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Retrofit库与协程适配器插件，我们还需要将以下依赖项添加到我们的项目中：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding code declares the required dependencies in a Gradle build script,
    which is used in a sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
    The `retrofit` module provides the core Retrofit library implementation. `converter-gson` adds
    a Gson plugin that enables automatic conversion of the JSON response to Kotlin model-data
    classes. The `retrofit2-kotlin-coroutines-experimental-adapter` module provides
    an adapter for async REST calls, allowing us to wrap the response using the Kotlin
    Coroutines `Deferred` type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在Gradle构建脚本中声明了所需的依赖项，该脚本用于示例项目([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook))。`retrofit`模块提供了核心Retrofit库实现。`converter-gson`添加了一个Gson插件，它允许自动将JSON响应转换为Kotlin模型数据类。`retrofit2-kotlin-coroutines-experimental-adapter`模块提供了一个用于异步REST调用的适配器，允许我们使用Kotlin协程的`Deferred`类型包装响应。
- en: In this recipe, we are going to use the GitHub REST API, which is available
    publicly. We are going to communicate with an endpoint responsible for returning
    search results containing GitHub repositories for a given search query. You can
    find detailed endpoint docs here: [https://developer.github.com/v3/search/#search-repositories](https://developer.github.com/v3/search/#search-repositories).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用公开可用的GitHub REST API。我们将与一个端点进行通信，该端点负责返回包含给定搜索查询的GitHub仓库的搜索结果。您可以在以下位置找到详细的端点文档：[https://developer.github.com/v3/search/#search-repositories](https://developer.github.com/v3/search/#search-repositories)。
- en: 'The  `/search/repositories` endpoint allows us to access the remote resources
    using the `GET` method and passing the desired search phrase under the key, called
    `q`. For example, the URL with the `GET` request for repositories matching the
    `"live.parrot"` search phrase would look like this: `https://api.github.com/search/repositories?q=parrot.live`.
    The results delivered by the endpoint are formatted using the JSON format. You
    can check out how the raw response looks like by opening the example URL in your
    browser or using the `curl` command-line tool: `curl https://api.github.com/search/repositories?q=parrot.live`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`/search/repositories`端点允许我们使用`GET`方法访问远程资源，并通过键`q`传递所需的搜索短语。例如，匹配搜索短语`"live.parrot"`的仓库的`GET`请求URL将如下所示：`https://api.github.com/search/repositories?q=parrot.live`。端点返回的结果使用JSON格式进行格式化。您可以通过在浏览器中打开示例URL或使用`curl`命令行工具来查看原始响应的外观：`curl
    https://api.github.com/search/repositories?q=parrot.live`。'
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Declare data classes modeling the server response:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明数据类来模拟服务器响应：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare an interface modeling the GitHub endpoint usage:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个模拟GitHub端点使用的接口：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Instantiate the `GithubApi` interface using the `Retrofit` class:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Retrofit`类实例化`GithubApi`接口：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Make a call to the endpoint using the `GithubApi` instance and pass `"kotlin"`
    as a search phrase:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GithubApi`实例调用端点，并传递搜索短语`"kotlin"`：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Wait for the response and get a reference to the obtained list of `Repository`
    class objects:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待响应并获取到`Repository`类对象的列表引用：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Sort the repositories list by the number of their stars count in decreasing
    order, and print them to the console:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照仓库的星级数量降序排序仓库列表，并将它们打印到控制台：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As a result, our code is going to send a request to the server, fetch and process
    the response, and print the following results to the console:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的代码将向服务器发送请求，获取并处理响应，并将以下结果打印到控制台：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We have started by implementing model classes that represent the data returned
    in the server's JSON response. You may have seen that some of the properties are
    marked with the `@SerializedName()` annotation. The aim of this annotation is
    to indicate to the Gson library that the specified property should be deserialized
    from a JSON field which name matches the value passed to `@SerializedName()`.
    Next, we are declaring an interface, `GithubApi`, that represents the methods
    we want to use to communicate with the endpoint. We've declared a single method,
    called `searchRepositories`, which takes a `String` parameter that corresponds
    to the search-query value required by the repositories search endpoint. We've
    also marked the `searchRepositories` method with the `@GET` annotation, which
    specifies the REST method type to use and a path to the endpoint. The `searchRepositories`
    method should return an instance of a `Deferred<Response>` type, representing
    a *future *result of an asynchronous call. Implementation of the `GithubApi` interface
    is generated by the Retrofit library internally. In order to obtain the `GithubApi`
    instance, we need to instantiate the `Retrofit` type and configure it with the
    endpoint's URL address and mechanisms responsible for JSON deserializing and performing
    asynchronous calls to the server. Finally, we call `Retrofit.create(GithubApi::class.java)`
    to obtain the `GithubApi` instance. That's it!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现了表示服务器JSON响应中返回的数据的模型类。你可能已经注意到，一些属性被标记了`@SerializedName()`注解。这个注解的目的是告诉Gson库，指定的属性应该从与`@SerializedName()`传递的值匹配的JSON字段反序列化。接下来，我们声明了一个接口，`GithubApi`，它表示我们想要用来与端点通信的方法。我们声明了一个名为`searchRepositories`的单个方法，它接受一个`String`参数，该参数对应于存储库搜索端点所需的搜索查询值。我们还用`@GET`注解标记了`searchRepositories`方法，它指定了要使用的REST方法类型和端点的路径。`searchRepositories`方法应该返回一个`Deferred<Response>`类型的实例，表示异步调用的未来结果。`GithubApi`接口的实现是由Retrofit库内部生成的。为了获取`GithubApi`实例，我们需要实例化`Retrofit`类型，并使用端点的URL地址和负责JSON反序列化和对服务器执行异步调用的机制进行配置。最后，我们调用`Retrofit.create(GithubApi::class.java)`来获取`GithubApi`实例。就是这样！
- en: 'In order to execute the actual call to the server, we need to call the `GithubApi.searchRepositories()`
    function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行对服务器的实际调用，我们需要调用`GithubApi.searchRepositories()`函数：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, in order to obtain a list of `Repository` objects from the response,
    we need to wait for the completion of the async call to the server and response
    parsing:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了从响应中获取`Repository`对象列表，我们需要等待对服务器的异步调用完成以及响应解析：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we post-process the list of repositories obtained from the response.
    We are sorting it by the stars count, in decreasing order, and printing it to
    the console with the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对从响应中获取的存储库列表进行后处理。我们按星级数量降序排序，并使用以下代码将其打印到控制台：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: See also
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to explore the basics of the coroutines framework, take a look
    at the *Using coroutines for asynchronous concurrent-tasks execution *and *Using
    coroutines for asynchronous, concurrent tasks execution with results handling *recipes. You
    can learn more about the Retrofit library by exploring its homepage, [http://square.github.io/retrofit/](http://square.github.io/retrofit/),
    which contains useful examples.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要探索协程框架的基础知识，可以查看*使用协程执行异步并发任务执行*和*使用协程执行异步并发任务执行并处理结果*配方。你可以通过探索其主页[http://square.github.io/retrofit/](http://square.github.io/retrofit/)来了解更多关于Retrofit库的信息，其中包含有用的示例。
- en: Wrapping third-party callback-style APIs with coroutines
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程包装第三方回调式API
- en: Often third-party libraries offer callback-style asynchronous APIs. However,
    the callback functions are considered to be an anti-pattern, especially whenever
    we are dealing with a number of nested callbacks. In this recipe, we are going
    to learn how to deal with libraries that provide callback-style methods by transforming
    them easily into suspending functions that can be run using coroutines.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，第三方库提供回调式异步API。然而，回调函数被认为是一种反模式，尤其是在我们处理多个嵌套回调时。在这个配方中，我们将学习如何处理提供回调式方法的库，通过轻松地将它们转换为可以使用协程运行的挂起函数。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The first step to start working with Kotlin Coroutines is to add the core framework
    dependency to the project:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Kotlin协程的第一步是将核心框架依赖项添加到项目中：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code declares the `kotlinx-coroutines-core` dependency in a Gradle
    build script, which is used in the sample project ([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在Gradle构建脚本中声明了`kotlinx-coroutines-core`依赖，该依赖用于示例项目([https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook))。
- en: 'As far as the recipe task is concerned, let''s assume we have a class called
    `Result`, defined as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 就食谱任务而言，让我们假设我们有一个名为`Result`的类，其定义如下：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is the `getResultsAsync()` function, which simulates the third-party callback-style
    API:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`getResultsAsync()`函数，它模拟第三方回调风格的API：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `getResultsAsync()` function just starts a background thread, delays it
    for a second, and invokes a callback function passed to it as an argument delivering
    the list of the `Result` class object to it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`getResultsAsync()`函数只是启动一个后台线程，延迟一秒钟，然后调用传递给它作为参数的回调函数，将`Result`类对象的列表传递给它。'
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Wrap the `getResultsAsync()` function with the suspend function, returning
    the results directly:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用挂起函数包装`getResultsAsync()`函数，直接返回结果：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Start a coroutine and invoke the `getResults()` suspending function inside
    it:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在协程中启动一个协程并调用其中的`getResults()`挂起函数：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Wait for the results and print them to the console:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待结果并打印到控制台：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the end, our code is going to print the following output to the console:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的代码将打印以下输出到控制台：
- en: '[PRE67]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We''ve successfully managed to transform the callback-style `getResultsAsync(callback:
    (List<Result>) -> Unit)` function into the clean form of a suspending function
    returning the results directly–`suspend fun getResults(): List<Result>`. In order
    to get rid of the original `callback` argument, we have used the `suspendCoroutine()`
    function provided by the standard library. The `suspendCoroutine()` function takes
    the `block: (Continuation<T>) -> Unit` function type as an argument. The `Continuation`
    interface is designed to allow us to resume the coroutine paused by a suspending
    function.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '我们成功地将回调风格的`getResultsAsync(callback: (List<Result>) -> Unit)`函数转换成了直接返回结果的干净形式的挂起函数–`suspend
    fun getResults(): List<Result>`。为了去掉原始的`callback`参数，我们使用了标准库提供的`suspendCoroutine()`函数。`suspendCoroutine()`函数接受`block:
    (Continuation<T>) -> Unit`函数类型作为参数。`Continuation`接口被设计用来允许我们恢复由挂起函数暂停的协程。'
- en: When the `suspendCoroutine` function is called inside a coroutine, it captures
    its execution state in a `Continuation` instance and passes this continuation
    to the specified block as an argument. To resume execution of the coroutine, the
    block may invoke either `continuation.resume()` or `continuation.resumeWithException()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当在协程内部调用`suspendCoroutine`函数时，它会捕获其执行状态到一个`Continuation`实例中，并将这个延续传递给指定的块作为参数。为了恢复协程的执行，块可以调用`continuation.resume()`或`continuation.resumeWithException()`。
- en: 'We invoke the original `getResultsAcync()` function inside the lambda passed
    to the `suspendCoroutine()` function, and we call the `continuation.resume(it)` 
    function in the `callback` lambda blocked passed to the `getResultsAsync()` function
    as an argument:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在传递给`suspendCoroutine()`函数的lambda中调用原始的`getResultsAcync()`函数，并在传递给`getResultsAsync()`函数作为参数的`callback`
    lambda阻塞中调用`continuation.resume(it)`函数：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As the result, the coroutine inside which `getResults()` is called will become
    suspended until the `callback` lambda is executed internally in the `getResultsAsync()`
    function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，调用`getResults()`的协程将挂起，直到`getResultsAsync()`函数内部执行`callback` lambda。
- en: See also
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to explore the basics of the coroutines framework, take a look
    at the *Using coroutines for asynchronous, concurrent tasks execution* and *Using
    coroutines for asynchronous, concurrent tasks execution with results handling*
    recipes
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想探索协程框架的基础，请查看*使用协程执行异步、并发任务*和*使用协程执行异步、并发任务并处理结果*的食谱
