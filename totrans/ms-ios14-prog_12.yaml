- en: '*Chapter 12*: Improving Apps with Location Services'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：使用位置服务改进应用程序'
- en: All iOS devices come with a huge variety of chips and sensors that can be used
    to enhance the user experience. Augmented reality applications make heavy use
    of sensors such as the gyroscope, accelerometer, and camera. These sensors are
    great if you want to grab a picture or want to know how a device is moving. Other
    apps require different data, such as the user's GPS location at a given time.
    In this chapter, you will learn how to use the **Core Location** framework to
    do just that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有iOS设备都配备了各种芯片和传感器，可以用来增强用户体验。增强现实应用程序大量使用陀螺仪、加速度计和摄像头等传感器。如果您想拍照或想知道设备是如何移动的，这些传感器非常棒。其他应用程序需要不同的数据，例如用户在特定时间的GPS位置。在本章中，您将学习如何使用**Core
    Location**框架来实现这一点。
- en: '**Core Location** is a framework that allows developers to gain access to a
    user''s current location, but it also allows developers to track whether a user
    has entered or exited a specific area, or even to monitor a user''s location over
    time. A proper implementation of Core Location can be the core of many great features
    in your app, but a lousy implementation could drain a user''s battery in no time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Core Location**是一个框架，允许开发者访问用户的当前位置，但它还允许开发者跟踪用户是否进入或离开了特定区域，甚至可以监控用户随时间的变化位置。Core
    Location的正确实现可以是您应用程序中许多优秀功能的基石，但糟糕的实现可能会迅速耗尽用户的电池。'
- en: 'In this chapter, you will learn about the following location-related topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下与位置相关的主题：
- en: Requesting a user's location
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求用户的地理位置
- en: Subscribing to location changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅位置变化
- en: Setting up geofences
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置地理围栏
- en: By the end of the chapter, you should be able to make educated decisions about
    how and when you implement Core Location in your apps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够就如何在您的应用程序中实现Core Location做出明智的决定。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code bundle for this chapter includes a starter project called **LocationServices**.
    You can find it in the code bundle repository:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包包括一个名为**LocationServices**的入门项目。您可以在代码包仓库中找到它：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services)'
- en: Requesting a user's location
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求用户的地理位置
- en: As you can imagine, giving an application access to your exact location is quite
    a big deal. In the wrong hands, this data could allow people with malicious intentions
    to know exactly where you are at any given time and abuse this knowledge in many
    different ways. For this reason, it's essential that you only request a user's
    location if you absolutely have to. Simply using it for a small feature, or to
    make sure a user is in some arbitrary location before they sign up for a service,
    might not always be a good enough reason to ask for a user's location.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，允许应用程序访问您的确切位置是一件相当重要的事情。如果落入错误的手中，这些数据可能会让有恶意意图的人知道您在任何给定时间的确切位置，并以多种方式滥用这种知识。因此，如果您绝对需要，才请求用户的地理位置信息至关重要。仅仅为了实现一个小功能，或者确保用户在注册服务之前位于某个任意位置，可能并不总是请求用户地理位置信息的充分理由。
- en: Let's see now the different ways to ask the user for permission to access their
    location data in iOS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看在iOS中请求用户允许访问其位置数据的不同方法。
- en: Asking for permission to access location data
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求访问位置数据的许可
- en: 'When you do need access to a user''s location, you have to ask permission first.
    Similar to how you have to add a reason for needing the camera or a user''s contacts
    to the `Info.plist` file, you must also provide a reason for requesting location
    data. In the case of location data, there are two keys you can add to the `Info.plist`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当您确实需要访问用户的地理位置信息时，您必须首先请求许可。类似于您需要在`Info.plist`文件中添加需要相机或用户联系人的原因一样，您还必须提供请求位置数据的原因。在位置数据的情况下，您可以在`Info.plist`中添加两个键：
- en: Privacy-Location `NSLocationWhenInUseUsageDescription`)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私-位置 `NSLocationWhenInUseUsageDescription`)
- en: Privacy-Location `NSLocationAlwaysAndWhenInUseUsageDescription`)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私-位置 `NSLocationAlwaysAndWhenInUseUsageDescription`)
- en: When your app asks for permission to use a user's location data, they have the
    option to only allow your app access to their location when the app is in use,
    or they can choose to allow your app to access their location all the time, even
    when the app is in the background. You can also configure the type of access that
    you want to ask yourself. If you only need the user's location when they are using
    the app, make sure to configure your permission request properly so the user isn't
    asked to provide their location to your app when it's in the background.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用请求使用用户的位置数据时，他们可以选择仅在应用使用时允许你的应用访问他们的位置，或者他们可以选择始终允许你的应用访问他们的位置，即使应用处于后台。你还可以配置你想要请求的访问类型。如果你只需要在用户使用应用时获取用户的位置，请确保正确配置你的权限请求，这样用户就不会在应用处于后台时被要求向你的应用提供位置信息。
- en: After adding the required keys to the `Info.plist` file in the **LocationServices**
    app, you will need to write some code to ask the user for permission to use their
    location. Before doing this, let's quickly examine the sample project's structure
    and content so you are aware of what information can be found where.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所需的密钥添加到**LocationServices**应用的`Info.plist`文件后，你需要编写一些代码来请求用户允许使用他们的位置。在这样做之前，让我们快速检查一下示例项目的结构和内容，以便你知道信息可以在哪里找到。
- en: First, open the `Main.storyboard` file in the project. You will find a tab bar
    controller with two view controllers in it. Throughout this chapter, you will
    implement the features to populate these view controllers with appropriate data.
    Next, look at the `AppDelegate` implementation. The implementation here follows
    the `GeofenceViewController` is the one you will work on first, to make the user's
    current location appear on the screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在项目中打开`Main.storyboard`文件。你将找到一个带有两个视图控制器的标签栏控制器。在本章中，你将实现功能以填充这些视图控制器，并添加适当的数据。接下来，查看`AppDelegate`的实现。这里的实现遵循`GeofenceViewController`，这是你将首先工作的，以便在屏幕上显示用户的当前位置。
- en: You will notice that a lot of code has already been implemented in this view
    controller. Examine the existing code for a bit and you'll find that all the code
    makes calls to empty methods in `LocationHelper.swift`. Most of your focus in
    this chapter will be on implementing the Core Location code required to work with
    a user's location data, so the UI work has already been set up. As you add code
    to `LocationHelper`, you'll find that the user interface for `LocationServices`
    comes to life bit by bit.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在这个视图控制器中已经实现了大量的代码。稍微检查一下现有代码，你会发现所有代码都调用了`LocationHelper.swift`中的空方法。在本章中，你将主要关注实现与用户位置数据一起工作的Core
    Location代码，因此UI工作已经设置好了。当你向`LocationHelper`添加代码时，你会发现`LocationServices`的用户界面将逐步变得生动起来。
- en: 'Now that you have a better understanding of how the LocationServices app was
    set up, let''s see what steps are involved in asking the user for permission to
    use their location. Since this app will eventually track location changes in the
    background, you should ask the user for access to their location even when the
    app is in the background. To do this, add the following `viewDidAppear(_:)` code
    to `GeofenceViewController`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对如何设置LocationServices应用有了更好的理解，让我们看看请求用户允许使用其位置所需的步骤。由于此应用最终将在后台跟踪位置变化，因此即使在应用处于后台时，你也应该请求用户允许访问其位置。为此，将以下`viewDidAppear(_:)`代码添加到`GeofenceViewController`中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the first view controller the user will see, so asking the user for
    their location as soon as this view appears is a good idea. If it's not obvious
    that you will be prompting the user for their location, it's often a good idea
    to inform the user about why you are going to ask them for location permissions
    before actually showing the location access dialog. To actually make the permission
    dialog appear, you will need to add some code to `LocationHelper.swift`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户将看到的第一个视图控制器，因此当这个视图出现时立即请求用户的位置是个好主意。如果你不明确你将提示用户位置，通常在显示位置访问对话框之前通知用户你为什么要请求位置权限是个好主意。要实际使权限对话框出现，你需要在`LocationHelper.swift`中添加一些代码。
- en: 'All location service-related requests are performed through an instance of
    `CLLocationManager`. The location manager is responsible for obtaining the user''s
    GPS location, asking for permission to access the user''s location, and more.
    When the location manager receives updates about the user''s location, authorization
    status, or other events, it will notify its delegate. A location manager delegate
    should conform to the `CLLocationManagerDelegate` protocol. Note that the `LocationHelper`
    already conforms to `CLLocationManagerDelegate`, and that an instance of `CLLocationManager`
    is already created on this object. All that''s left to do is assign the helper
    as the delegate for the location manager. Add the following line at the end of
    the `init()` method in `LocationHelper` to set it as the location manager delegate:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有位置服务相关的请求都是通过`CLLocationManager`的一个实例来执行的。位置管理器负责获取用户的GPS位置，请求访问用户位置的权限，以及更多。当位置管理器收到有关用户位置、授权状态或其他事件的更新时，它将通知其代理。位置管理器代理应遵守`CLLocationManagerDelegate`协议。请注意，`LocationHelper`已经遵守了`CLLocationManagerDelegate`协议，并且在这个对象上已经创建了一个`CLLocationManager`的实例。剩下要做的就是将辅助器分配为位置管理器的代理。在`LocationHelper`的`init()`方法末尾添加以下行以将其设置为位置管理器代理：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, add the following implementation for the `askPermission(_:)` method:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为`askPermission(_:)`方法添加以下实现：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This implementation checks whether a current authorization status exists. If
    it does, the completion `callback` is called with the current status. If the current
    status has not been determined yet, the location manager is asked to request authorization
    to access the user location using the `requestAlwaysAuthorization()` method. This
    will prompt the user for their location permissions. The reason you need to have
    permanent access to a user''s location in this app is to ensure you can implement
    geofencing later in this chapter. Add the following method to the `CLLocationManagerDelegate`
    to retrieve the user''s response to the authorization prompt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现检查是否存在当前授权状态。如果存在，则使用当前状态调用完成`callback`。如果当前状态尚未确定，则请求位置管理器使用`requestAlwaysAuthorization()`方法请求访问用户位置的授权。这将提示用户进行位置权限的请求。在这个应用中你需要永久访问用户的位置的原因是为了确保你可以在本章后面实现地理围栏。将以下方法添加到`CLLocationManagerDelegate`以检索用户对授权提示的响应：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code immediately passes the user's response to the stored completion
    callback that was passed to `askPermission(_:)`. After calling the callback, it
    is set to nil to avoid accidentally calling it again. At this point, you have
    done all the work required to request access to a user's location. Let's see how
    you can retrieve a user's current location next, so you can make use of it in
    your apps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码立即将用户的响应传递给存储的完成回调，该回调是通过`askPermission(_:)`传递的。在调用回调后，它被设置为nil以避免意外再次调用它。此时，你已经完成了请求访问用户位置所需的所有工作。接下来，让我们看看如何检索用户当前位置，以便你可以在你的应用中使用它。
- en: Obtaining a user's location
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户的位置
- en: Once your app has access to location data, you can use the location manager
    to begin observing a user's location, the direction in which a user is heading,
    and more. For now, you will focus on obtaining the user's current location. `GeofenceViewController`
    already contains a method, called `showCurrentLocation()`, that is responsible
    for asking the location helper for a current location. If you examine this method
    closely, you'll find that it also asks the location helper for a location name
    by calling `getLocationName(for:_:)` and passing the obtained location to this
    method. The `showCurrentLocation()` method also uses the obtained location to
    focus a map view on the user's location by calling `setRegion(_:animated:)` on
    the map view.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用可以访问位置数据，你可以使用位置管理器来开始观察用户的位置、用户移动的方向等等。目前，你将专注于获取用户的当前位置。`GeofenceViewController`已经包含了一个名为`showCurrentLocation()`的方法，该方法负责请求位置辅助器提供当前位置。如果你仔细检查这个方法，你会发现它还通过调用`getLocationName(for:_:)`并传递获取到的位置到这个方法来请求位置名称。`showCurrentLocation()`方法还使用获取到的位置通过在地图视图上调用`setRegion(_:animated:)`来聚焦地图视图在用户的位置上。
- en: 'Since the view controller is already fully prepared to handle location updates,
    all you need to do is add the proper implementations for `getLatestLocation(_:)`
    and `getLocationName(for:_:)`. Begin by adding the following implementation for
    `getLatestLocation(_:)`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图控制器已经完全准备好处理位置更新，你所需要做的就是添加对`getLatestLocation(_:)`和`getLocationName(for:_:)`的正确实现。首先，为`getLatestLocation(_:)`添加以下实现：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding method first checks whether a location has already been obtained.
    If it has, then the latest obtained location is returned. If there is no existing
    location, the code checks whether location services are enabled. It's always good
    practice to check whether the location service you are about to use is actually
    available. If location services are available, the `completion` callback is stored
    in the helper, and the location manager is told to start monitoring the user's
    location by calling `startUpdatingLocation()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法首先检查是否已经获取了位置。如果已经获取，则返回最新获取的位置。如果没有现有位置，代码将检查位置服务是否已启用。检查你即将使用的位置服务是否实际可用始终是一个好习惯。如果位置服务可用，则将`completion`回调存储在辅助器中，并通过调用`startUpdatingLocation()`告诉位置管理器开始监控用户的位置。
- en: 'Calling `startUpdateLocation()` will make the location observer continuously
    monitor the user''s GPS location, and will send any relevant updates to its delegate
    by calling `locationManager(_:didUpdateLocations:)`. This method will always receive
    one or more new locations that the manager has obtained, where the latest location
    will be the last item in the list of obtained locations. Add the following implementation
    for this method to the `CLLocationManagerDelegate` extension of `LocationHelper`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`startUpdateLocation()`将使位置观察者持续监控用户的GPS位置，并通过调用`locationManager(_:didUpdateLocations:)`将其相关更新发送到其代理。此方法将始终接收到管理器获取的一个或多个新位置，其中最新位置将是获取位置列表中的最后一个项。将以下实现添加到`LocationHelper`的`CLLocationManagerDelegate`扩展中：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The implementation for `locationManager(_:didUpdateLocations:)` is fairly straightforward:
    the latest location is passed to the callback, and the callback is removed to
    prevent subsequent location updates from triggering the callback unexpectedly.
    Also, the location manager is told to stop monitoring the user''s location by
    calling `stopUpdatingLocation()`. Lastly, the obtained locations are stored for
    later use.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`locationManager(_:didUpdateLocations:)`的实现相当简单：将最新位置传递给回调，并移除回调以防止后续的位置更新意外触发回调。此外，通过调用`stopUpdatingLocation()`告诉位置管理器停止监控用户的位置。最后，将获取到的位置存储以供以后使用。'
- en: Important note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It's always good practice to make the location manager stop monitoring location
    updates if you won't be needing updates any time soon. Monitoring location updates
    has a pretty significant impact on battery life, so you shouldn't spend more time
    tracking a user's location than needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总是好的做法，如果你不会很快需要更新，就停止位置管理器监控位置更新。监控位置更新对电池寿命有相当大的影响，因此你不应该花费比所需更多的时间来跟踪用户的位置。
- en: 'Now that you can retrieve the user''s location, the last step is to also retrieve
    the location name by implementing `getLocationName(for:_:_)` in the location helper.
    Add the following implementation for this method to the location helper:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以检索用户的位置，下一步是通过在位置辅助器中实现`getLocationName(for:_:_)`来检索位置名称。将以下实现添加到位置辅助器中：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code uses `CLGeocoder` to find a placemark that corresponds with
    the user's current location. Note that this feature uses an internet connection,
    so the name lookup will only work if the user has an internet connection. Regular
    GPS-related features do not require internet access, so your app can monitor and
    track a user's location even if they don't have an active internet connection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`CLGeocoder`查找与用户当前位置相对应的地点标记。请注意，此功能需要互联网连接，因此名称查找只有在用户有互联网连接时才会工作。常规的GPS相关功能不需要互联网访问，因此即使用户没有活跃的互联网连接，你的应用也可以监控和跟踪用户的位置。
- en: Try running your app now—you should be able to see the user's current location
    on the map, and the location name, latitude, and longitude should be displayed
    on the screen as well. Now that you know how to obtain a user's location, let's
    see how you can efficiently subscribe your app to follow changes in a user's location
    in order to track their position.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行您的应用——您应该能够在地图上看到用户的当前位置，并且位置名称、纬度和经度也应显示在屏幕上。现在您已经知道如何获取用户的位置，让我们看看您如何有效地订阅应用以跟踪用户位置的变化，以便跟踪他们的位置。
- en: Subscribing to location changes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅位置变化
- en: One way of subscribing to changes in a user's location has already been covered
    in the previous section of this chapter. When you call `startUpdatingLocation()`
    on a location manager, it will automatically subscribe to the user's location.
    This method of tracking a user's location is excellent if you need very detailed
    reporting on a user's location, but usually, you don't need this level of detail.
    More importantly, using this kind of location tracking for an extended period
    will drain the user's battery.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅用户位置变化的一种方法已经在本章的前一节中介绍过了。当您在位置管理器上调用`startUpdatingLocation()`时，它将自动订阅用户的位置。如果您需要非常详细的位置报告，这种跟踪用户位置的方法是极好的，但通常您不需要这种详细程度。更重要的是，长时间使用这种位置跟踪会耗尽用户的电池。
- en: Luckily, there are better ways to monitor location changes. One way is to subscribe
    to locations that the user visits by calling `startMonitoringVisits()`. This method
    is used if you aren't interested in the user's detailed movement but only want
    to know whether the user spent an extended period in a particular area. This type
    of tracking of a user's location is perfect if you need a low-power way to track
    very rough location changes. This kind of tracking even works well if your app
    is running in the background, because your app will automatically be woken up
    or launched if a visit event occurs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有更好的方法来监控位置变化。一种方法是调用`startMonitoringVisits()`来订阅用户访问的位置。如果您不感兴趣于用户的详细移动，但只想知道用户是否在特定区域停留了较长时间，则使用此方法。这种跟踪用户位置的方式非常适合您需要低功耗方式来跟踪非常粗略的位置变化。即使您的应用在后台运行，这种跟踪方式也能很好地工作，因为如果发生访问事件，您的应用将自动被唤醒或启动。
- en: If your app is relaunched due to a location-related event, then `UIApplication.LaunchOptionsKey.location`
    will be present in the application's launch options dictionary. When it is, you
    are expected to create an instance of a location manager and assign it a delegate
    to receive the relevant location update.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用因与位置相关的事件而重新启动，那么`UIApplication.LaunchOptionsKey.location`将存在于应用的启动选项字典中。当它存在时，您应该创建一个位置管理器的实例并将其分配一个代理以接收相关的位置更新。
- en: If the visit monitoring is a bit too inaccurate for your purposes but you don't
    need continuous location tracking, you can use `LocationServices` sample app to
    see exactly how they work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问监控对您的用途来说不够精确，但您不需要持续的位置跟踪，您可以使用`LocationServices`示例应用来查看它们是如何工作的。
- en: 'If you look at `SignificantChangesViewController`, you''ll note that the view
    controller is fully set up to begin monitoring significant location changes. The
    `monitorSignificantChanges(_:)` method, defined in the location helper, takes
    a callback that''s called every time a significant location change occurs. Every
    time new location data is retrieved, the table view is reloaded to display the
    latest available data. Since significant location changes can wake the app up
    with a special key in the app''s launch options, let''s update `AppDelegate` so
    it can handle this scenario. Add the following code `application(_:didFinishLaunchingWithOptions:)`
    right before the `return` statement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`SignificantChangesViewController`，您会注意到视图控制器已经完全设置好以开始监控显著的位置变化。在位置辅助器中定义的`monitorSignificantChanges(_:)`方法，每次发生显著的位置变化时都会调用回调。每次检索到新的位置数据时，表格视图都会重新加载以显示最新的可用数据。由于显著的位置变化可以通过应用启动选项中的特殊键唤醒应用，因此让我们更新`AppDelegate`以处理这种情况。在`return`语句之前添加以下代码`application(_:didFinishLaunchingWithOptions:)`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since `AppDelegate` already has a reference to the location helper, all it needs
    to do is re-enable significant location changes monitoring. This small change
    to `AppDelegate` is quite powerful because it allows your app to respond to changes
    in the user's location even when the app is not running. Let's implement the appropriate
    code in the location helper next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `AppDelegate` 已经有对位置辅助的引用，它只需要重新启用显著位置变化的监控。这种对 `AppDelegate` 的小改动非常强大，因为它允许你的应用在应用未运行时也能对用户位置的变化做出响应。接下来，让我们在位置辅助中实现适当的代码。
- en: 'Add the following implementation for `monitorSignificantLocationChanges(_:)`
    to `LocationHelper`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `LocationHelper` 中的 `monitorSignificantLocationChanges(_:)` 方法添加以下实现：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method is very similar to the location helper methods you have seen before.
    When a significant location change is detected, the location manager calls `locationManager(_:didUpdateLocations:)`
    on its delegate. Since this method is already implemented, you should update the
    implementation as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与之前见过的位置辅助方法非常相似。当检测到显著的位置变化时，位置管理器会调用其代理的 `locationManager(_:didUpdateLocations:)`
    方法。由于此方法已经实现，你应该按照以下方式更新实现：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the location manager is only told to stop updating the user's location
    when significant location change tracking is not active. When you call `stopUpdatingLocation()`,
    the location manager will cease to deliver any location updates to this delegate
    method. Also, note that `significantChangeReceivedCallback` is not removed after
    being calling. The reason for this is that the caller of `monitorSignificantChanges(_:)`
    is interested in continuous location updates, so any time this method is called,
    the `SignificantChangesViewController` view controller that initiated significant
    location change tracking should always be called.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当显著位置变化跟踪不活跃时，位置管理器才被告知停止更新用户的位置。当你调用 `stopUpdatingLocation()` 时，位置管理器将停止向此代理方法提供任何位置更新。另外，请注意，在调用后
    `significantChangeReceivedCallback` 不会被移除。这是因为调用 `monitorSignificantChanges(_:)`
    的调用者对连续的位置更新感兴趣，所以每次调用此方法时，应该始终调用启动了显著位置变化跟踪的 `SignificantChangesViewController`
    视图控制器。
- en: 'One last thing you need to do so that your app receives significant location
    changes while it''s not in the foreground is to set the `allowsBackgroundLocationUpdates`
    property to `true`. Add the following line of code to the location helper''s `init()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了确保你的应用在后台时也能接收到显著的位置变化，你需要将 `allowsBackgroundLocationUpdates` 属性设置为 `true`。将以下代码行添加到位置辅助的
    `init()` 方法中：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In addition to subscribing to significant location changes or visits, you can
    also respond to the user entering or leaving a certain area with geofences.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了订阅显著的位置变化或访问之外，你还可以使用地理围栏对用户进入或离开某个特定区域做出响应。
- en: Setting up geofences
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置地理围栏
- en: 'Sometimes, your app doesn''t really need to know the details of the user''s
    whereabouts. Sometimes, you''re only interested in tracking whether the user has
    exited or left a certain area, in order to show certain content in your app or
    to unlock some kind of special feature. Core Location has great support for monitoring
    geofences. A `CLRegion` subclasses. Core Location provides two different region
    types that you can use:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的应用并不真的需要知道用户的位置详情。有时，你只对跟踪用户是否离开了或离开了某个特定区域感兴趣，以便在你的应用中显示某些内容或解锁某种特殊功能。Core
    Location 对监控地理围栏提供了很好的支持。`CLRegion` 是一个子类。Core Location 提供了两种不同的区域类型，你可以使用：
- en: '`CLCircularRegion`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLCircularRegion`'
- en: '`CLBeaconRegion`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLBeaconRegion`'
- en: A `CLCircularRegion` type is used to set up a geofence, as described before.
    A `CLBeaconRegion` type is used with physical BLE iBeacons, and essentially provides
    geofencing in a very small radius, for instance, just a couple of meters. In this
    section, you will learn how to set up a `CLCircularRegion` type that is set up
    around a user's first detected location. Setting up geofencing, or region monitoring,
    with both types of regions is very similar so all principles for monitoring a
    circular region also applies to beacon regions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 `CLCircularRegion` 类型来设置地理围栏。使用 `CLBeaconRegion` 类型与物理 BLE iBeacon 配合使用，基本上在非常小的半径内提供地理围栏，例如，仅几米。在本节中，你将学习如何设置一个围绕用户首次检测到的位置的
    `CLCircularRegion` 类型。使用这两种类型的区域设置地理围栏或区域监控非常相似，所以监控圆形区域的所有原则也适用于信标区域。
- en: 'If you look at the `GeofenceViewController`, you''ll notice that it has a button
    labeled `@IBAction` for this button does quite a lot of the work already, but
    one key element is missing—it doesn''t inform the location manager about the region
    that should be monitored. Add the following code to the end of `setGeofence()`
    in `GeofenceViewController`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `GeofenceViewController`，你会注意到它有一个标记为 `@IBAction` 的按钮，这个按钮已经做了很多工作，但缺少一个关键元素——它没有通知位置管理器应该监控的区域。请将以下代码添加到
    `GeofenceViewController` 中的 `setGeofence()` 方法末尾：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code uses the location that was obtained from the user before
    and uses it to create a circular region with a radius of 30 meters. The identifier
    that is passed to the region should be an identifier that uniquely defines the
    region. If you reuse an identifier, Core Location will stop monitoring the old
    region with that identifier and will monitor the new region instead. For the LocationServices
    app this is perfect, but if you want your app to observe multiple regions, you
    must make sure every region has its own unique identifier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用从用户那里获取的位置信息，并使用它创建一个半径为 30 米的圆形区域。传递给区域的标识符应该是一个唯一定义该区域的标识符。如果你重复使用一个标识符，Core
    Location 将停止监控具有该标识符的旧区域，并监控新的区域。对于 LocationServices 应用来说这很完美，但如果你想让你的应用监控多个区域，你必须确保每个区域都有自己的唯一标识符。
- en: 'Next, add the following implementation for `setGeofence(at:_:_:)` to the `LocationHelper`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下 `setGeofence(at:_:_:)` 的实现添加到 `LocationHelper` 中：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding method is again very similar to the other location helper methods.
    Let''s move right on to implementing the `CLocationManagerDelegate` methods that
    the location manager will call:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法与其他位置助手方法非常相似。让我们直接进入实现位置管理器将调用的 `CLocationManagerDelegate` 方法：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding two methods are part of the `CLocationManagerDelegate` protocol
    and are called when a user enters or exits a certain area. Since there's no extra
    work to be done by the helper, the corresponding callbacks are immediately called
    so the `GeofenceViewController` can update its interface accordingly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个方法是 `CLocationManagerDelegate` 协议的一部分，当用户进入或离开某个区域时被调用。由于助手没有额外的工作要做，相应的回调立即被调用，以便
    `GeofenceViewController` 可以相应地更新其界面。
- en: Try opening the app and tapping the **Set Geofence** button. An orange circle
    should now appear on the map to visualize the geofence you have set up. If you
    exit or enter the region, the status label should update accordingly to show whether
    you have just entered or left the geofence. Note that it might take up to five
    minutes for iOS to properly register, monitor, and report updates about your geofence.
    Note that your user should have an active internet connection for region monitoring
    to work optimally.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试打开应用并点击 **设置地理围栏** 按钮。现在应该会在地图上出现一个橙色圆圈，以可视化你设置的地理围栏。如果你退出或进入该区域，状态标签应该相应更新，以显示你是否刚刚进入或离开了地理围栏。请注意，iOS
    可能需要最多五分钟的时间来正确注册、监控和报告关于你的地理围栏的更新。请注意，为了使区域监控工作最佳，用户应该有一个活跃的互联网连接。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned several techniques to obtain and respond to
    a user's location. You have implemented a `LocationHelper` class that provided
    a simple interface for view controllers to use the location manager that is contained
    in the helper. You learned about the best practices in the area of asking the
    user for access to their location data, and you have learned that asking for a
    user's location is a pretty privacy-sensitive question that shouldn't be asked
    without a good reason.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了获取和响应用户位置的一些技术。你实现了一个 `LocationHelper` 类，它为视图控制器提供了一个简单的接口来使用包含在助手中的位置管理器。你了解了在请求用户访问其位置数据方面的最佳实践，并且你了解到请求用户的位置是一个相当敏感的隐私问题，在没有充分理由的情况下不应该提出。
- en: You learned that there are different ways, each with different levels of detail,
    that you can use to track a user's location. You saw that you can subscribe to
    continuous changes, which has a bad impact on battery life. You also learned about
    subscribing to visits and significant location changes. In addition to learning
    about tracking a user's location, you also learned about monitoring whether a
    user has entered or exited a certain area by implementing geofencing. When you
    implement Core Location in your own apps, always make sure to keep the user's
    privacy in mind. If you don't really need the location data, then don't request
    access to it. And if you do, make sure to handle your user's location data with
    great care.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到有不同方式，每种方式都有不同级别的细节，你可以用来追踪用户的位置。你看到了你可以订阅连续的变化，这对电池寿命有不良影响。你还学习了关于订阅访问和显著位置变化的内容。除了学习追踪用户的位置外，你还学习了通过实现地理围栏来监控用户是否进入或离开了某个区域。当你在自己的应用中实现Core
    Location时，始终确保将用户的隐私放在心上。如果你真的不需要位置数据，那么不要请求访问它。如果你需要，确保非常小心地处理用户的位置数据。
- en: In the next chapter, you will learn about the Combine framework and how you
    can use it to enhance your apps.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于Combine框架以及如何使用它来增强你的应用。
