- en: '*Chapter 12*: Improving Apps with Location Services'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All iOS devices come with a huge variety of chips and sensors that can be used
    to enhance the user experience. Augmented reality applications make heavy use
    of sensors such as the gyroscope, accelerometer, and camera. These sensors are
    great if you want to grab a picture or want to know how a device is moving. Other
    apps require different data, such as the user's GPS location at a given time.
    In this chapter, you will learn how to use the **Core Location** framework to
    do just that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Core Location** is a framework that allows developers to gain access to a
    user''s current location, but it also allows developers to track whether a user
    has entered or exited a specific area, or even to monitor a user''s location over
    time. A proper implementation of Core Location can be the core of many great features
    in your app, but a lousy implementation could drain a user''s battery in no time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following location-related topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting a user's location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to location changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up geofences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should be able to make educated decisions about
    how and when you implement Core Location in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code bundle for this chapter includes a starter project called **LocationServices**.
    You can find it in the code bundle repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services)'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting a user's location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can imagine, giving an application access to your exact location is quite
    a big deal. In the wrong hands, this data could allow people with malicious intentions
    to know exactly where you are at any given time and abuse this knowledge in many
    different ways. For this reason, it's essential that you only request a user's
    location if you absolutely have to. Simply using it for a small feature, or to
    make sure a user is in some arbitrary location before they sign up for a service,
    might not always be a good enough reason to ask for a user's location.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see now the different ways to ask the user for permission to access their
    location data in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Asking for permission to access location data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you do need access to a user''s location, you have to ask permission first.
    Similar to how you have to add a reason for needing the camera or a user''s contacts
    to the `Info.plist` file, you must also provide a reason for requesting location
    data. In the case of location data, there are two keys you can add to the `Info.plist`:'
  prefs: []
  type: TYPE_NORMAL
- en: Privacy-Location `NSLocationWhenInUseUsageDescription`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privacy-Location `NSLocationAlwaysAndWhenInUseUsageDescription`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your app asks for permission to use a user's location data, they have the
    option to only allow your app access to their location when the app is in use,
    or they can choose to allow your app to access their location all the time, even
    when the app is in the background. You can also configure the type of access that
    you want to ask yourself. If you only need the user's location when they are using
    the app, make sure to configure your permission request properly so the user isn't
    asked to provide their location to your app when it's in the background.
  prefs: []
  type: TYPE_NORMAL
- en: After adding the required keys to the `Info.plist` file in the **LocationServices**
    app, you will need to write some code to ask the user for permission to use their
    location. Before doing this, let's quickly examine the sample project's structure
    and content so you are aware of what information can be found where.
  prefs: []
  type: TYPE_NORMAL
- en: First, open the `Main.storyboard` file in the project. You will find a tab bar
    controller with two view controllers in it. Throughout this chapter, you will
    implement the features to populate these view controllers with appropriate data.
    Next, look at the `AppDelegate` implementation. The implementation here follows
    the `GeofenceViewController` is the one you will work on first, to make the user's
    current location appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that a lot of code has already been implemented in this view
    controller. Examine the existing code for a bit and you'll find that all the code
    makes calls to empty methods in `LocationHelper.swift`. Most of your focus in
    this chapter will be on implementing the Core Location code required to work with
    a user's location data, so the UI work has already been set up. As you add code
    to `LocationHelper`, you'll find that the user interface for `LocationServices`
    comes to life bit by bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a better understanding of how the LocationServices app was
    set up, let''s see what steps are involved in asking the user for permission to
    use their location. Since this app will eventually track location changes in the
    background, you should ask the user for access to their location even when the
    app is in the background. To do this, add the following `viewDidAppear(_:)` code
    to `GeofenceViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the first view controller the user will see, so asking the user for
    their location as soon as this view appears is a good idea. If it's not obvious
    that you will be prompting the user for their location, it's often a good idea
    to inform the user about why you are going to ask them for location permissions
    before actually showing the location access dialog. To actually make the permission
    dialog appear, you will need to add some code to `LocationHelper.swift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All location service-related requests are performed through an instance of
    `CLLocationManager`. The location manager is responsible for obtaining the user''s
    GPS location, asking for permission to access the user''s location, and more.
    When the location manager receives updates about the user''s location, authorization
    status, or other events, it will notify its delegate. A location manager delegate
    should conform to the `CLLocationManagerDelegate` protocol. Note that the `LocationHelper`
    already conforms to `CLLocationManagerDelegate`, and that an instance of `CLLocationManager`
    is already created on this object. All that''s left to do is assign the helper
    as the delegate for the location manager. Add the following line at the end of
    the `init()` method in `LocationHelper` to set it as the location manager delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following implementation for the `askPermission(_:)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation checks whether a current authorization status exists. If
    it does, the completion `callback` is called with the current status. If the current
    status has not been determined yet, the location manager is asked to request authorization
    to access the user location using the `requestAlwaysAuthorization()` method. This
    will prompt the user for their location permissions. The reason you need to have
    permanent access to a user''s location in this app is to ensure you can implement
    geofencing later in this chapter. Add the following method to the `CLLocationManagerDelegate`
    to retrieve the user''s response to the authorization prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code immediately passes the user's response to the stored completion
    callback that was passed to `askPermission(_:)`. After calling the callback, it
    is set to nil to avoid accidentally calling it again. At this point, you have
    done all the work required to request access to a user's location. Let's see how
    you can retrieve a user's current location next, so you can make use of it in
    your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a user's location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once your app has access to location data, you can use the location manager
    to begin observing a user's location, the direction in which a user is heading,
    and more. For now, you will focus on obtaining the user's current location. `GeofenceViewController`
    already contains a method, called `showCurrentLocation()`, that is responsible
    for asking the location helper for a current location. If you examine this method
    closely, you'll find that it also asks the location helper for a location name
    by calling `getLocationName(for:_:)` and passing the obtained location to this
    method. The `showCurrentLocation()` method also uses the obtained location to
    focus a map view on the user's location by calling `setRegion(_:animated:)` on
    the map view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the view controller is already fully prepared to handle location updates,
    all you need to do is add the proper implementations for `getLatestLocation(_:)`
    and `getLocationName(for:_:)`. Begin by adding the following implementation for
    `getLatestLocation(_:)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method first checks whether a location has already been obtained.
    If it has, then the latest obtained location is returned. If there is no existing
    location, the code checks whether location services are enabled. It's always good
    practice to check whether the location service you are about to use is actually
    available. If location services are available, the `completion` callback is stored
    in the helper, and the location manager is told to start monitoring the user's
    location by calling `startUpdatingLocation()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `startUpdateLocation()` will make the location observer continuously
    monitor the user''s GPS location, and will send any relevant updates to its delegate
    by calling `locationManager(_:didUpdateLocations:)`. This method will always receive
    one or more new locations that the manager has obtained, where the latest location
    will be the last item in the list of obtained locations. Add the following implementation
    for this method to the `CLLocationManagerDelegate` extension of `LocationHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation for `locationManager(_:didUpdateLocations:)` is fairly straightforward:
    the latest location is passed to the callback, and the callback is removed to
    prevent subsequent location updates from triggering the callback unexpectedly.
    Also, the location manager is told to stop monitoring the user''s location by
    calling `stopUpdatingLocation()`. Lastly, the obtained locations are stored for
    later use.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It's always good practice to make the location manager stop monitoring location
    updates if you won't be needing updates any time soon. Monitoring location updates
    has a pretty significant impact on battery life, so you shouldn't spend more time
    tracking a user's location than needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you can retrieve the user''s location, the last step is to also retrieve
    the location name by implementing `getLocationName(for:_:_)` in the location helper.
    Add the following implementation for this method to the location helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses `CLGeocoder` to find a placemark that corresponds with
    the user's current location. Note that this feature uses an internet connection,
    so the name lookup will only work if the user has an internet connection. Regular
    GPS-related features do not require internet access, so your app can monitor and
    track a user's location even if they don't have an active internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: Try running your app now—you should be able to see the user's current location
    on the map, and the location name, latitude, and longitude should be displayed
    on the screen as well. Now that you know how to obtain a user's location, let's
    see how you can efficiently subscribe your app to follow changes in a user's location
    in order to track their position.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to location changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way of subscribing to changes in a user's location has already been covered
    in the previous section of this chapter. When you call `startUpdatingLocation()`
    on a location manager, it will automatically subscribe to the user's location.
    This method of tracking a user's location is excellent if you need very detailed
    reporting on a user's location, but usually, you don't need this level of detail.
    More importantly, using this kind of location tracking for an extended period
    will drain the user's battery.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are better ways to monitor location changes. One way is to subscribe
    to locations that the user visits by calling `startMonitoringVisits()`. This method
    is used if you aren't interested in the user's detailed movement but only want
    to know whether the user spent an extended period in a particular area. This type
    of tracking of a user's location is perfect if you need a low-power way to track
    very rough location changes. This kind of tracking even works well if your app
    is running in the background, because your app will automatically be woken up
    or launched if a visit event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: If your app is relaunched due to a location-related event, then `UIApplication.LaunchOptionsKey.location`
    will be present in the application's launch options dictionary. When it is, you
    are expected to create an instance of a location manager and assign it a delegate
    to receive the relevant location update.
  prefs: []
  type: TYPE_NORMAL
- en: If the visit monitoring is a bit too inaccurate for your purposes but you don't
    need continuous location tracking, you can use `LocationServices` sample app to
    see exactly how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at `SignificantChangesViewController`, you''ll note that the view
    controller is fully set up to begin monitoring significant location changes. The
    `monitorSignificantChanges(_:)` method, defined in the location helper, takes
    a callback that''s called every time a significant location change occurs. Every
    time new location data is retrieved, the table view is reloaded to display the
    latest available data. Since significant location changes can wake the app up
    with a special key in the app''s launch options, let''s update `AppDelegate` so
    it can handle this scenario. Add the following code `application(_:didFinishLaunchingWithOptions:)`
    right before the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since `AppDelegate` already has a reference to the location helper, all it needs
    to do is re-enable significant location changes monitoring. This small change
    to `AppDelegate` is quite powerful because it allows your app to respond to changes
    in the user's location even when the app is not running. Let's implement the appropriate
    code in the location helper next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following implementation for `monitorSignificantLocationChanges(_:)`
    to `LocationHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is very similar to the location helper methods you have seen before.
    When a significant location change is detected, the location manager calls `locationManager(_:didUpdateLocations:)`
    on its delegate. Since this method is already implemented, you should update the
    implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the location manager is only told to stop updating the user's location
    when significant location change tracking is not active. When you call `stopUpdatingLocation()`,
    the location manager will cease to deliver any location updates to this delegate
    method. Also, note that `significantChangeReceivedCallback` is not removed after
    being calling. The reason for this is that the caller of `monitorSignificantChanges(_:)`
    is interested in continuous location updates, so any time this method is called,
    the `SignificantChangesViewController` view controller that initiated significant
    location change tracking should always be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing you need to do so that your app receives significant location
    changes while it''s not in the foreground is to set the `allowsBackgroundLocationUpdates`
    property to `true`. Add the following line of code to the location helper''s `init()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In addition to subscribing to significant location changes or visits, you can
    also respond to the user entering or leaving a certain area with geofences.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up geofences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, your app doesn''t really need to know the details of the user''s
    whereabouts. Sometimes, you''re only interested in tracking whether the user has
    exited or left a certain area, in order to show certain content in your app or
    to unlock some kind of special feature. Core Location has great support for monitoring
    geofences. A `CLRegion` subclasses. Core Location provides two different region
    types that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLCircularRegion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLBeaconRegion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `CLCircularRegion` type is used to set up a geofence, as described before.
    A `CLBeaconRegion` type is used with physical BLE iBeacons, and essentially provides
    geofencing in a very small radius, for instance, just a couple of meters. In this
    section, you will learn how to set up a `CLCircularRegion` type that is set up
    around a user's first detected location. Setting up geofencing, or region monitoring,
    with both types of regions is very similar so all principles for monitoring a
    circular region also applies to beacon regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the `GeofenceViewController`, you''ll notice that it has a button
    labeled `@IBAction` for this button does quite a lot of the work already, but
    one key element is missing—it doesn''t inform the location manager about the region
    that should be monitored. Add the following code to the end of `setGeofence()`
    in `GeofenceViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the location that was obtained from the user before
    and uses it to create a circular region with a radius of 30 meters. The identifier
    that is passed to the region should be an identifier that uniquely defines the
    region. If you reuse an identifier, Core Location will stop monitoring the old
    region with that identifier and will monitor the new region instead. For the LocationServices
    app this is perfect, but if you want your app to observe multiple regions, you
    must make sure every region has its own unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following implementation for `setGeofence(at:_:_:)` to the `LocationHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method is again very similar to the other location helper methods.
    Let''s move right on to implementing the `CLocationManagerDelegate` methods that
    the location manager will call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding two methods are part of the `CLocationManagerDelegate` protocol
    and are called when a user enters or exits a certain area. Since there's no extra
    work to be done by the helper, the corresponding callbacks are immediately called
    so the `GeofenceViewController` can update its interface accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Try opening the app and tapping the **Set Geofence** button. An orange circle
    should now appear on the map to visualize the geofence you have set up. If you
    exit or enter the region, the status label should update accordingly to show whether
    you have just entered or left the geofence. Note that it might take up to five
    minutes for iOS to properly register, monitor, and report updates about your geofence.
    Note that your user should have an active internet connection for region monitoring
    to work optimally.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned several techniques to obtain and respond to
    a user's location. You have implemented a `LocationHelper` class that provided
    a simple interface for view controllers to use the location manager that is contained
    in the helper. You learned about the best practices in the area of asking the
    user for access to their location data, and you have learned that asking for a
    user's location is a pretty privacy-sensitive question that shouldn't be asked
    without a good reason.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that there are different ways, each with different levels of detail,
    that you can use to track a user's location. You saw that you can subscribe to
    continuous changes, which has a bad impact on battery life. You also learned about
    subscribing to visits and significant location changes. In addition to learning
    about tracking a user's location, you also learned about monitoring whether a
    user has entered or exited a certain area by implementing geofencing. When you
    implement Core Location in your own apps, always make sure to keep the user's
    privacy in mind. If you don't really need the location data, then don't request
    access to it. And if you do, make sure to handle your user's location data with
    great care.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the Combine framework and how you
    can use it to enhance your apps.
  prefs: []
  type: TYPE_NORMAL
