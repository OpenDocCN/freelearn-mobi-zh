<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor121" class="calibre3 pcalibre pcalibre1"/>10</h1>
<h1 id="_idParaDest-108" class="calibre6"><a id="_idTextAnchor122" class="calibre3 pcalibre pcalibre1"/>Debugging Your App</h1>
<p class="calibre4">Debugging is a very important aspect of developing apps. It helps us identify and fix bugs in our code. It is a very important skill to have as a developer. It also helps us avoid bugs in the future. Many tools can help us debug our code. In this chapter, we will be looking at some of the tools that can help us debug our code.</p>
<p class="calibre4">In this chapter, we will learn debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect network requests/responses fired by our app using Chucker, and how to inspect our Room database, network requests, and background tasks using App Inspection.</p>
<p class="calibre4">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre16">
<li class="calibre15">General debugging tips and tricks</li>
<li class="calibre15">Detecting leaks with LeakCanary</li>
<li class="calibre15">Inspecting network requests with Chucker</li>
<li class="calibre15">Using App Inspection</li>
</ul>
<h1 id="_idParaDest-109" class="calibre6"><a id="_idTextAnchor123" class="calibre3 pcalibre pcalibre1"/>Technical requirements</h1>
<p class="calibre4">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio</a>) downloaded.</p>
<p class="calibre4">You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten" class="calibre3 pcalibre pcalibre1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten</a>.</p>
<h1 id="_idParaDest-110" class="calibre6"><a id="_idTextAnchor124" class="calibre3 pcalibre pcalibre1"/>General debugging tips and tricks</h1>
<p class="calibre4">Android Studio provides us with a variety of features that help us debug our code. Some of the features are listed in the following points:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Logcat</strong></li>
<li class="calibre15"><strong class="bold">Stack Traces</strong></li>
<li class="calibre15"><strong class="bold">Breakpoints</strong></li>
</ul>
<p class="calibre4">Let us look at each of these closely.</p>
<h2 id="_idParaDest-111" class="calibre7"><a id="_idTextAnchor125" class="calibre3 pcalibre pcalibre1"/>Logcat</h2>
<p class="calibre4">Logcat in Android Studio displays log <a id="_idIndexMarker476" class="calibre3 pcalibre pcalibre1"/>messages in real-time from our apps. Each log message has a<a id="_idIndexMarker477" class="calibre3 pcalibre pcalibre1"/> priority level attached to it. We add log messages in our app using the <code>Log</code> class. This class offers different priority levels that we can use to log messages. The different priority levels are as follows:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">V</strong>: Verbose (lowest priority)</li>
<li class="calibre15"><strong class="bold">D</strong>: Debug</li>
<li class="calibre15"><strong class="bold">I</strong>: Info</li>
<li class="calibre15"><strong class="bold">W</strong>: Warning</li>
<li class="calibre15"><strong class="bold">E</strong>: Error</li>
<li class="calibre15"><strong class="bold">F</strong>: Fatal</li>
<li class="calibre15"><strong class="bold">S</strong>: Silent (highest priority)</li>
</ul>
<p class="calibre4">We use the preceding letters to specify the log level. For example, if we want to log a message with the debug level, we will use the following code:</p>
<pre class="source-code">
Log.d("TAG", "Message")</pre> <p class="calibre4">The first parameter is the tag. The tag is used to identify the source of a log message. The second parameter is the<a id="_idIndexMarker478" class="calibre3 pcalibre pcalibre1"/> message that we want to log. Each time <a id="_idIndexMarker479" class="calibre3 pcalibre pcalibre1"/>we run our app, Logcat shows up at the bottom of the Android Studio window, as shown in the following figure:</p>
<div><div><img alt="Figure 10.1 – Logcat" src="img/B19779_10_01.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Logcat</p>
<p class="calibre4">From the preceding figure, we can see at the top that the Logcat window shows the device we are running our app on. In this case, we are running our app on a <strong class="bold">Pixel 6 Pro API 33</strong> emulator; yours can be different depending on the emulator you have installed. Next to the device, we can see the <strong class="bold">package</strong> of the app we are running. This has a search bar that allows us to search for specific logs with their tags. Below the search are the actual logs. We can see that each log has a tag, the priority level, the package name of the app, the time the log was created, and the message. We can also see that the logs are color-coded. To see all the color settings for our Logcat, we go to <strong class="bold">Settings</strong> | <strong class="bold">Editor </strong>| <strong class="bold">Color Scheme</strong> | <strong class="bold">Android Logcat</strong>, which shows the color settings as shown in the following figure:</p>
<div><div><img alt="Figure 10.2 – Logcat color settings" src="img/B19779_10_02.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Logcat color settings</p>
<p class="calibre4">This way, we can set a color <a id="_idIndexMarker480" class="calibre3 pcalibre pcalibre1"/>scheme for our Logcat. In the preceding figure, the color scheme has been set to <strong class="bold">Classic Light</strong>. There is a list that shows<a id="_idIndexMarker481" class="calibre3 pcalibre pcalibre1"/> the colors for each log level, and you can change the color for each log level. We can also change the font style and size for our Logcat.</p>
<p class="calibre4">With this, let us see how to create our first Logcat message. Let us head over to the <code>MainActivity.kt</code> file and add a log message in the <code>onCreate()</code> method as follows:</p>
<pre class="source-code">
Log.d("First Log", "This is our first log message")</pre> <p class="calibre4">Run the app and add <code>First Log</code> as a search query in the search bar:</p>
<div><div><img alt="Figure 10.3 – Logcat search" src="img/B19779_10_03.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Logcat search</p>
<p class="calibre4">This only shows the log<a id="_idIndexMarker482" class="calibre3 pcalibre pcalibre1"/> message that has the tag <strong class="bold">First Log</strong>. This is particularly<a id="_idIndexMarker483" class="calibre3 pcalibre pcalibre1"/> useful when we have a lot of logs, and we want to search for a specific log.</p>
<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor126" class="calibre3 pcalibre pcalibre1"/>Stack traces</h2>
<p class="calibre4">A <strong class="bold">stack trace</strong> is a list of method calls from the<a id="_idIndexMarker484" class="calibre3 pcalibre pcalibre1"/> point where the app was<a id="_idIndexMarker485" class="calibre3 pcalibre pcalibre1"/> started to the point where the exception was thrown. It is extremely useful in helping us identify the cause of an exception. Stack traces are normally displayed in Logcat.</p>
<p class="calibre4">To be able to see our first stack trace, let us head over to the <code>MainActivity.kt</code> file and add the following code in the <code>onCreate()</code> method:</p>
<pre class="source-code">
throw RuntimeException("This is a crash")</pre> <p class="calibre4">The preceding code will cause the app to crash when you run it. The app crashes immediately after executing the preceding code, and by checking our Logcat, we should be able to see the stack trace:</p>
<div><div><img alt="Figure 10.4 – Crash stack trace" src="img/B19779_10_04.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Crash stack trace</p>
<p class="calibre4">As shown in the preceding figure, the stack trace shows the exception or reason for the crash. Additionally, it shows the class and method where the exception was thrown. It also shows the line number where the exception was thrown. This is particularly useful in helping us identify the cause of the exception. We can click on the line number directly and it will take us<a id="_idIndexMarker486" class="calibre3 pcalibre pcalibre1"/> to the line of code where the exception was thrown.</p>
<p class="calibre4">The stack trace is a crucial tool in <a id="_idIndexMarker487" class="calibre3 pcalibre pcalibre1"/>helping us debug our code and quickly detect crashes and the cause of crashes. Before moving on, remember to remove the code that throws the exception so that we can continue with the rest of the chapter.</p>
<p class="calibre4">Android Studio allows us to copy and paste stack traces from a different source and see them in our Logcat. Copy the following stack trace:</p>
<pre class="console">
FATAL EXCEPTION: main
Process: com.packt.chapterten, PID: 7168
java.lang.RuntimeException: Unable to start activity ComponentInfo{com.packt.chapterten/com.packt.chapterten.MainActivity}: java.lang.RuntimeException: This is a crash
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3645)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3782)
at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:101)
at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2307)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:201)
at android.os.Looper.loop(Looper.java:288)
at android.app.ActivityThread.main(ActivityThread.java:7872)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:936)
Caused by: java.lang.RuntimeException: This is a crash
at com.packt.chapterten.MainActivity.onCreate(MainActivity.kt:48)
at android.app.Activity.performCreate(Activity.java:8305)
at android.app.Activity.performCreate(Activity.java:8284)
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1417)
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3626)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3782)
at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:101)
at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2307)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:201)
at android.os.Looper.loop(Looper.java:288)
at android.app.ActivityThread.main(ActivityThread.java:7872)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:936)</pre> <p class="calibre4">Once you are done<a id="_idIndexMarker488" class="calibre3 pcalibre pcalibre1"/> copying the stack trace, head over to the <strong class="bold">Code</strong> tab at the top of <a id="_idIndexMarker489" class="calibre3 pcalibre pcalibre1"/>Android Studio and select <strong class="bold">Analyze Stack Trace or Thread Dump</strong>, paste the stack trace, and you will see the following dialog with the stack trace:</p>
<div><div><img alt="Figure 10.5 – Analyze stack trace" src="img/B19779_10_05.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Analyze stack trace</p>
<p class="calibre4">This shows the preview of<a id="_idIndexMarker490" class="calibre3 pcalibre pcalibre1"/> the stack trace we just pasted. Clicking on <strong class="bold">OK</strong> takes us <a id="_idIndexMarker491" class="calibre3 pcalibre pcalibre1"/>to Logcat and shows us the stack trace as in <em class="italic">Figure 10</em><em class="italic">.4</em></p>
<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor127" class="calibre3 pcalibre pcalibre1"/>Breakpoints</h2>
<p class="calibre4">We use <strong class="bold">breakpoints</strong> to debug code<a id="_idIndexMarker492" class="calibre3 pcalibre pcalibre1"/> for our apps. A breakpoint is a point in our code where we want the debugger to pause the <a id="_idIndexMarker493" class="calibre3 pcalibre pcalibre1"/>execution of our code. This is useful when we are trying to find bugs that only appear under certain conditions. Android Studio allows us to add breakpoints to our code. We can add breakpoints to our code by clicking on the left side of the line number as shown in the following figure:</p>
<div><div><img alt="Figure 10.6 – Breakpoint" src="img/B19779_10_06.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Breakpoint</p>
<p class="calibre4">As shown in <em class="italic">Figure 10</em><em class="italic">.6</em>, a red circle is displayed when we add a breakpoint. To be able to see how the breakpoint works, we <a id="_idIndexMarker494" class="calibre3 pcalibre pcalibre1"/>need to run the <a id="_idIndexMarker495" class="calibre3 pcalibre pcalibre1"/>app in <strong class="bold">debug mode</strong>. We can <a id="_idIndexMarker496" class="calibre3 pcalibre pcalibre1"/>do this by clicking on the <strong class="bold">Debug</strong> button:</p>
<div><div><img alt="Figure 10.7 – Debug app" src="img/B19779_10_07.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Debug app</p>
<p class="calibre4">Since the breakpoint is on the <code>onCreate()</code> method, the debugger will pause the execution of our code at the breakpoint. Android Studio will highlight the line where the breakpoint is:</p>
<div><div><img alt="Figure 10.8 – Line breakpoint" src="img/B19779_10_08.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Line breakpoint</p>
<p class="calibre4">It also shows a <strong class="bold">Debug</strong> window at the bottom:</p>
<div><div><img alt="Figure 10.9 – Debug window" src="img/B19779_10_09.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Debug window</p>
<p class="calibre4">The <strong class="bold">Debug</strong> window shows us the variables that are in the scope of the breakpoint. We can also see the call stack, which<a id="_idIndexMarker497" class="calibre3 pcalibre pcalibre1"/> shows us the methods that have been <a id="_idIndexMarker498" class="calibre3 pcalibre pcalibre1"/>called before the breakpoint. We can also see the threads that are running in our app. We can also see the breakpoints that we have added to our code.</p>
<p class="calibre4">The <strong class="bold">Debug</strong> window has some buttons at the top that are immensely helpful in debugging our code:</p>
<div><div><img alt="Figure 10.10 – Debug window buttons" src="img/B19779_10_10.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Debug window buttons</p>
<p class="calibre4">The buttons are as highlighted in <em class="italic">Figure 10</em><em class="italic">.10</em>. Starting from the left to right, the buttons are:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Show execution point</strong>: This button shows the line of code where the debugger is paused</li>
<li class="calibre15"><strong class="bold">Step Over</strong>: This button allows us to execute the current line of code and move to the next line of code</li>
<li class="calibre15"><strong class="bold">Step Into</strong>: This button allows us to step into a method call</li>
<li class="calibre15"><strong class="bold">Step Out</strong>: This button allows us to step out of a method call</li>
<li class="calibre15"><strong class="bold">Run to Cursor</strong>: This button allows us to run the code until the cursor reaches the line of code where the cursor is</li>
</ul>
<p class="calibre4">On the left of the <strong class="bold">Debug</strong> window, we can also see the <strong class="bold">Play</strong> and <strong class="bold">Stop</strong> buttons. The <strong class="bold">Play</strong> button allows us to resume the <a id="_idIndexMarker499" class="calibre3 pcalibre pcalibre1"/>execution of our code and continue the debugging session until the next breakpoint or until the program completes<a id="_idIndexMarker500" class="calibre3 pcalibre pcalibre1"/> execution. To learn more about breakpoints, visit the official documentation at <a href="https://developer.android.com/studio/debug" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio/debug</a>.</p>
<p class="calibre4">In this section, we have learned about the different debugging options available in Android Studio. We learned about Logcat, stack traces, and breakpoints. We have also learned how to use these tools to debug our code. In the next section, we will learn about a different debugging tool, LeakCanary, and how to use it to detect memory leaks in our apps.</p>
<h1 id="_idParaDest-114" class="calibre6"><a id="_idTextAnchor128" class="calibre3 pcalibre pcalibre1"/>Detecting memory leaks with LeakCanary</h1>
<p class="calibre4"><strong class="bold">LeakCanary</strong> is an <a id="_idIndexMarker501" class="calibre3 pcalibre pcalibre1"/>open-source library developed by Square that helps us detect memory leaks in <a id="_idIndexMarker502" class="calibre3 pcalibre pcalibre1"/>our apps. The library has knowledge of <a id="_idIndexMarker503" class="calibre3 pcalibre pcalibre1"/>the internals of the Android Framework that allows it to narrow down the cause of the memory leak. It helps<a id="_idIndexMarker504" class="calibre3 pcalibre pcalibre1"/> reduce the <strong class="bold">Application Not Responding </strong>(<strong class="bold">ANR</strong>) errors and <strong class="bold">out-of-memory crashes</strong> in our apps. Here are some of the most common <a id="_idIndexMarker505" class="calibre3 pcalibre pcalibre1"/>causes of memory leaks:</p>
<ul class="calibre16">
<li class="calibre15">Storing instances of <strong class="source-inline1">Activity</strong> as <strong class="source-inline1">Context</strong> filed in an object that survives activity recreation due to configuration changes</li>
<li class="calibre15">Forgetting to unregister broadcast receivers, listeners, callbacks, or RxJava subscriptions when they are no longer needed</li>
<li class="calibre15">Storing references to <strong class="source-inline1">Context</strong> in a background thread</li>
</ul>
<p class="calibre4">LeakCanary is quite easy to <a id="_idIndexMarker506" class="calibre3 pcalibre pcalibre1"/>set up and no code implementation<a id="_idIndexMarker507" class="calibre3 pcalibre pcalibre1"/> is needed to use it. We just need to add the <code>leakcanary-android</code> dependency in our <code>libs.version.toml</code> file:</p>
<pre class="source-code">
<a id="_idTextAnchor129" class="calibre19 pcalibre pcalibre1"/>leakcanary-an<a id="_idTextAnchor130" class="calibre19 pcalibre pcalibre1"/>droid = "com.squareup.leakcanary:leakcanary-android:2.12"</pre> <p class="calibre4">Tap t<a id="_idTextAnchor131" class="calibre3 pcalibre pcalibre1"/>he <code>build.gradle.kts</code> file:</p>
<pre class="source-code">
debugImplementation(libs.leakcanary.android)</pre> <p class="calibre4">We have added the dependency using the <code>debugImplementation</code> configuration so that it is only added to debug builds. This is because LeakCanary is only used for debugging purposes. We can now run our app and see how LeakCanary works. A separate app will be installed on our device or emulator as shown in the following figure:</p>
<div><div><img alt="Figure 10.11 – Leaks app" src="img/B19779_10_11.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Leaks app</p>
<p class="calibre4">Opening the app brings up the following screen:</p>
<div><div><img alt="Figure 10.12 – LeakCanary screen" src="img/B19779_10_12.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.12 – LeakCanary screen</p>
<p class="calibre4">The screen shows the <strong class="bold">Leaks</strong>, <strong class="bold">Heap Dumps</strong>, and <strong class="bold">About</strong> tabs. The <strong class="bold">Leaks</strong> tab shows us the memory leaks that have been detected in our app. The <strong class="bold">Heap Dumps</strong> tab shows us the heap dumps that <a id="_idIndexMarker508" class="calibre3 pcalibre pcalibre1"/>have been taken. The <strong class="bold">About</strong> tab shows us the version of LeakCanary we are using <a id="_idIndexMarker509" class="calibre3 pcalibre pcalibre1"/>as well as general information. For now, there is no memory leak detected. When a memory leak is detected, LeakCanary will generate a notification or log output with detailed information about the memory leak. This information helps us identify the cause of the memory leak and fix it.</p>
<p class="calibre4">Let us now create a memory leak in our app and see how LeakCanary works:</p>
<ol class="calibre14">
<li class="calibre15">Create a new file inside the <strong class="source-inline1">com.packt.chapterten</strong> package and call it <strong class="source-inline1">LeakCanaryTest.kt</strong>. Add the following code to the file:<pre class="source-code">
class LeakCanaryTest
class LeakTestUtils {
    companion object {
        val leakCanaryTest = LeakCanaryTest()
    }
}</pre><p class="calibre4">In the preceding <a id="_idIndexMarker510" class="calibre3 pcalibre pcalibre1"/>code, we have created a class called <code>LeakCanaryTest</code> and another class called <code>LeakTestUtils</code>, with a<a id="_idIndexMarker511" class="calibre3 pcalibre pcalibre1"/> companion object that stores the <code>LeakCanaryTest</code> singleton in a static field.</p></li> <li class="calibre15">Let us now head over to the <strong class="source-inline1">MainActivity.kt</strong> file and add the following code in the <strong class="source-inline1">onCreate()</strong> code:<pre class="source-code">
AppWatcher.objectWatcher.expectWeaklyReachable(
    LeakTestUtils.leakCanaryTest,
    "Static reference to LeakCanaryTest"
)</pre><p class="calibre4">In the preceding code, we are telling LeakCanary that the singleton instance of <code>LeakCanaryTest</code> will be garbage collected.</p></li> <li class="calibre15">Let us run the app. We can see that LeakCanary has detected a memory leak and shows a notification as seen in the following figure:</li>
</ol>
<div><div><img alt="Figure 10.13 – Memory leak notification" src="img/B19779_10_13.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Memory leak notification</p>
<ol class="calibre14">
<li value="4" class="calibre15">Click on the <a id="_idIndexMarker512" class="calibre3 pcalibre pcalibre1"/>notification and it will take us to the <a id="_idIndexMarker513" class="calibre3 pcalibre pcalibre1"/>LeakCanary app where we can see the details of the memory leak:</li>
</ol>
<div><div><img alt="Figure 10.14 – Memory leak details" src="img/B19779_10_14.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Memory leak details</p>
<p class="calibre4">As shown in the preceding figure, LeakCanary shows the location of the memory leak and underlines the objects causing the leak. In this case, it is the <code>leakCanaryTest</code> object that<a id="_idIndexMarker514" class="calibre3 pcalibre pcalibre1"/> is causing the<a id="_idIndexMarker515" class="calibre3 pcalibre pcalibre1"/> memory leak. Every time we get a memory leak, we will receive such detailed information.</p>
<p class="calibre4">Remember to remove the code that causes the memory leak in the <code>MainActivity</code> <code>onCreate()</code> method so that we can continue with the rest of the chapter.</p>
<p class="calibre4">We have learned about LeakCanary and how to use it to detect memory leaks in our apps. You can learn more about LeakCanary at <a href="https://square.github.io/leakcanary/" class="calibre3 pcalibre pcalibre1">https://square.github.io/leakcanary/</a>.</p>
<p class="calibre4">In the next section, we will learn<a id="_idIndexMarker516" class="calibre3 pcalibre pcalibre1"/> about Chucker, another debugging<a id="_idIndexMarker517" class="calibre3 pcalibre pcalibre1"/> tool that helps us inspect network requests in our apps.</p>
<h1 id="_idParaDest-115" class="calibre6"><a id="_idTextAnchor132" class="calibre3 pcalibre pcalibre1"/>Inspecting network requests with Chucker</h1>
<p class="calibre4">This is from the Chucker GitHub (<a href="https://github.com/ChuckerTeam/chucker" class="calibre3 pcalibre pcalibre1">https://github.com/ChuckerTeam/chucker</a>) page:</p>
<p class="author-quote">Chucker simplifies the inspection of HTTP(S) requests/responses fired by our Android apps. Chucker works as an OkHttp Interceptor persisting all those events inside our application, and providing a UI for inspecting and sharing their content. Chucker displays a notification showing a summary of the ongoing network request.</p>
<p class="calibre4">Tapping the Chucker notification<a id="_idIndexMarker518" class="calibre3 pcalibre pcalibre1"/> mentioned previously launches the Chucker UI. Chucker UI shows a list<a id="_idIndexMarker519" class="calibre3 pcalibre pcalibre1"/> of all the network requests that have been made by our app. We can tap on a request to see the details of the request.</p>
<p class="calibre4">To use Chucker, follow<a id="_idIndexMarker520" class="calibre3 pcalibre pcalibre1"/> these steps:</p>
<ol class="calibre14">
<li class="calibre15">Add the <strong class="source-inline1">chucker</strong> dependency in the <strong class="source-inline1">libs.versions.toml</strong> file:<pre class="source-code">
chucker = "com.github.chuckerteam.chucker:library:4.0.0"
chucker-no-op = "com.github.chuckerteam.chucker:library-no-op:4.0.0"</pre><p class="calibre4">In the preceding code, we have added two dependencies: the first one is the Chucker library, and the second one is a no-op library variant to isolate Chucker from release builds since we only want to see the requests on debug builds.</p></li> <li class="calibre15">Tap the <strong class="bold">Sync Now</strong> button at the top to sync the project.</li>
<li class="calibre15">Next, we need to add the dependency in our app’s <strong class="source-inline1">build.gradle.kts</strong> file:<pre class="source-code">
debugImplementation(libs.chucker)
releaseImplementation(libs.chucker.no.op)</pre></li> <li class="calibre15">Tap <strong class="bold">Sync Now</strong> at the top. This will add the Chucker dependency in debug builds only.</li>
<li class="calibre15">Next, we need to create a<a id="_idIndexMarker521" class="calibre3 pcalibre pcalibre1"/> new <strong class="source-inline1">OkHttp</strong> client and add the Chucker interceptor to it. Let us head<a id="_idIndexMarker522" class="calibre3 pcalibre pcalibre1"/> over to the <strong class="source-inline1">Modules.kt</strong> file and add the following module to the <strong class="source-inline1">appModules</strong> module block:<pre class="source-code">
single {
    val chuckerCollector = ChuckerCollector(
        context = androidContext(),
        showNotification = true,
        retentionPeriod = RetentionManager.Period.ONE_HOUR
    )
    val chuckerInterceptor = ChuckerInterceptor.Builder(androidContext())
        .collector(chuckerCollector)
        .maxContentLength(250000L)
        .redactHeaders(emptySet())
        .alwaysReadResponseBody(false)
        .build()
   OkHttpClient.Builder()
        .addInterceptor(chuckerInterceptor)
        .build()
}</pre><p class="calibre4">The following explains the preceding code:</p><ul class="calibre17"><li class="calibre15">We have created a <code>OkHttpClient</code> instance to make network requests.</p></li> <li class="calibre15">Let us modify our <strong class="source-inline1">Retrofit</strong> instance to use the <strong class="source-inline1">OkHttpClient</strong> instance we just created. Still in the <strong class="source-inline1">Modules.kt</strong> file, modify the Retrofit instance as follows:<pre class="source-code">
single {
    Retrofit.Builder()
        .addConverterFactory(
            Json.asConverterFactory(contentType = "application/json".toMediaType())
        )
        .client(get())
        .baseUrl("https://cataas.com/api/")
        .build()
}</pre><p class="calibre4">We have added the <code>client</code> parameter <a id="_idIndexMarker525" class="calibre3 pcalibre pcalibre1"/>and passed it in the <code>OkHttpClient</code> instance we created <a id="_idIndexMarker526" class="calibre3 pcalibre pcalibre1"/>previously using Koin’s <code>get()</code> call.</p><p class="calibre4">With that, our Chucker setup is now complete.</p></li> <li class="calibre15">Build and run the app. We can see that Chucker has detected the network request and shows a notification, as seen in the following figure:</li>
</ol>
<div><div><img alt="Figure 10.15 – Chucker notification" src="img/B19779_10_15.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Chucker notification</p>
<p class="calibre4">From the preceding figure, we <a id="_idIndexMarker527" class="calibre3 pcalibre pcalibre1"/>can see that Chucker has detected the network request and shows the <a id="_idIndexMarker528" class="calibre3 pcalibre pcalibre1"/>status code, the method, and the URL of the request.</p>
<ol class="calibre14">
<li value="8" class="calibre15">We can tap on the notification and it will take us to the Chucker UI:</li>
</ol>
<div><div><img alt="Figure 10.16 – Chucker list of requests" src="img/B19779_10_16.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Chucker list of requests</p>
<p class="calibre4">This shows the list<a id="_idIndexMarker529" class="calibre3 pcalibre pcalibre1"/> of the network requests that have been<a id="_idIndexMarker530" class="calibre3 pcalibre pcalibre1"/> made by our app.</p>
<ol class="calibre14">
<li value="9" class="calibre15">Tap on a request to see the details of the request:</li>
</ol>
<div><div><img alt="Figure 10.17 – Chucker overview tab" src="img/B19779_10_17.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Chucker overview tab</p>
<p class="calibre4">The details screen has <a id="_idIndexMarker531" class="calibre3 pcalibre pcalibre1"/>three tabs as shown in the preceding <a id="_idIndexMarker532" class="calibre3 pcalibre pcalibre1"/>figure. The first tab is the <strong class="bold">Overview</strong> tab, which is shown in <em class="italic">Figure 10</em><em class="italic">.17</em>. The <strong class="bold">Overview</strong> tab shows the overview of the request. It shows the request details such as URL, method, response, duration, response size, and so on. The second<a id="_idIndexMarker533" class="calibre3 pcalibre pcalibre1"/> tab is the <strong class="bold">Request</strong> tab, which shows the request<a id="_idIndexMarker534" class="calibre3 pcalibre pcalibre1"/> headers and body:</p>
<div><div><img alt="Figure 10.18 – Chucker request tab" src="img/B19779_10_18.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Chucker request tab</p>
<p class="calibre4">For this request, the body is empty since it was a get request. The third tab is the <strong class="bold">Response</strong> tab, which <a id="_idIndexMarker535" class="calibre3 pcalibre pcalibre1"/>shows the response headers<a id="_idIndexMarker536" class="calibre3 pcalibre pcalibre1"/> and body:</p>
<div><div><img alt="Figure 10.19 – Chucker response tab" src="img/B19779_10_19.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Chucker response tab</p>
<p class="calibre4">From the preceding figure, we can see the response headers and body in JSON format.</p>
<p class="calibre4">The toolbar of the details screen has <strong class="bold">Search</strong>, <strong class="bold">Share</strong>, and <strong class="bold">Save</strong> buttons. The <strong class="bold">Search</strong> button allows us to search in either the request or the response. The <strong class="bold">Share</strong> button allows us to share the request or response details in JSON format. The <strong class="bold">Save</strong> button allows <a id="_idIndexMarker537" class="calibre3 pcalibre pcalibre1"/>us to save the request or response details to a file.</p>
<p class="calibre4">Chucker is very helpful in<a id="_idIndexMarker538" class="calibre3 pcalibre pcalibre1"/> debugging network requests in our apps. When non-technical teams test the debuggable version of our app, we can always tell them to share these requests, especially when they’re facing issues with their network requests.</p>
<p class="calibre4">That’s it for Chucker. Every time our app makes a network request, Chucker will show a notification and we can tap on the notification to see the details of the request.</p>
<p class="calibre4">We have learned about Chucker and how to use it to inspect network requests in our apps. In the next section, we will learn how to use App Inspection to inspect our app’s room database and explore the features App Inspection offers.</p>
<h1 id="_idParaDest-116" class="calibre6"><a id="_idTextAnchor133" class="calibre3 pcalibre pcalibre1"/>Using App Inspection</h1>
<p class="calibre4"><strong class="bold">App Inspection</strong> allows us to debug our <a id="_idIndexMarker539" class="calibre3 pcalibre pcalibre1"/>database, inspect network traffic, and debug our background tasks. It is a very important tool in helping us debug our apps. To use App Inspection, let us run our app and then navigate to <strong class="bold">View</strong> | <strong class="bold">Tool Windows</strong> | <strong class="bold">App Inspection</strong> in Android Studio:</p>
<div><div><img alt="Figure 10.20 – App Inspection" src="img/B19779_10_20.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.20 – App Inspection</p>
<p class="calibre4">App Inspection automatically connects to our app. The first tab is <strong class="bold">Database Inspector</strong>. On the left, we can see the different databases created by our app. We have the WorkManager, Chucker, LeakCanary, and Cat databases that we created earlier on. Let us click on the <strong class="bold">Cat</strong> database, and <a id="_idIndexMarker540" class="calibre3 pcalibre pcalibre1"/>we can see the columns of the table that we created in the database:</p>
<div><div><img alt="Figure 10.21 – Cat database" src="img/B19779_10_21.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Cat database</p>
<p class="calibre4">This shows the columns and the values that have been saved in the database. We can also run queries in the database. The query option is highlighted in the following figure:</p>
<div><div><img alt="Figure 10.22 – Execute query button" src="img/B19779_10_22.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Execute query button</p>
<p class="calibre4">We want to run a query that shows the cats with a specific <code>id</code>. We can do this by running the following <a id="_idIndexMarker541" class="calibre3 pcalibre pcalibre1"/>query:</p>
<pre class="source-code">
SELECT * FROM CAT WHERE id == "rrsvsbRgL7zaJuR3"</pre> <p class="calibre4">You can use a different <code>id</code> per the data you have. The query results will be as follows:</p>
<div><div><img alt="Figure 10.23 – Query results" src="img/B19779_10_23.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.23 – Query results</p>
<p class="calibre4">The data has all the cats that have the ID we specified. One thing to note is to ensure that you execute the queries on the correct database, as shown in <em class="italic">Figure 10</em><em class="italic">.23</em>. The database inspector helps us debug and write queries to our database and is very useful when working on apps that use a database.</p>
<p class="calibre4">Let us now head over to the <strong class="bold">Network Inspector</strong> tab. This tab shows us the network requests that have been <a id="_idIndexMarker542" class="calibre3 pcalibre pcalibre1"/>made by our app. We can see the request method, the URL, the status code, and the duration of the request:</p>
<div><div><img alt="Figure 10.24 – Network Inspector" src="img/B19779_10_24.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.24 – Network Inspector</p>
<p class="calibre4">From the preceding figure, we can see that the requests are for loading the cute cat images and all the details of the request. Similar to Chucker, it also has the request and response tabs that provide more information on the request. However, unlike Chucker, <strong class="bold">Network Inspector</strong> captures the network requests made by the app without any additional setup in the code. The <strong class="bold">Network Inspector</strong> tab is very useful in helping us debug network requests in our apps, especially when working on apps that make a lot of network requests.</p>
<p class="calibre4">Lastly, let us head over to the <strong class="bold">Background Task Inspector</strong> tab. This tab shows us the background task requests that have been made by our app. Our app should show the following:</p>
<div><div><img alt="Figure 10.25 – Background Task Inspector" src="img/B19779_10_25.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.25 – Background Task Inspector</p>
<p class="calibre4">The Background Task Inspector shows us the details of our background tasks. It has information for WorkManager <code>PetsSyncWorker</code> worker has succeeded. On the right are<a id="_idIndexMarker543" class="calibre3 pcalibre pcalibre1"/> more details of the worker, as shown in <em class="italic">Figure 10</em><em class="italic">.25</em>. The details show the UUID, constraints, state, and results of the worker, such as the output data, number of retries, and the time it started. This information is very helpful to check whether our background tasks are running as expected.</p>
<h1 id="_idParaDest-117" class="calibre6"><a id="_idTextAnchor134" class="calibre3 pcalibre pcalibre1"/>Summary</h1>
<p class="calibre4">In this chapter, we learned some debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect network requests/responses fired by our app using Chucker, and how to use App Inspection to debug our database, inspect our network requests, and inspect background tasks, too.</p>
<p class="calibre4">In the next chapter, we will learn Kotlin style and the best practices for writing Kotlin code. We will also learn how to use plugins such as Ktlint and Detekt to format, lint, and detect the code smells early.</p>
</div>
</body></html>