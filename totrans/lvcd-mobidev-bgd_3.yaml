- en: Chapter 3. Building User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。构建用户界面
- en: '*So many different screens!*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*有这么多不同的屏幕！*'
- en: '*When making utility or game applications for desktop computers, you can often
    get away with having a particular sized window for which you can make custom graphics
    that exactly fit. With mobile devices, you have to cope with a wide range of screen
    sizes and aspect ratios and also have to interface elements that look correct
    for the operating system on the user''s device.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在为台式计算机制作实用程序或游戏应用程序时，你通常可以避开特定大小的窗口，并为它制作完全适合的定制图形。在移动设备上，你必须应对广泛的屏幕尺寸和宽高比，并且还需要有适合用户设备操作系统的界面元素。*'
- en: 'LiveCode is capable of publishing on Mac, Windows, and Linux and goes some
    way toward solving the difficulty of making interface elements look right for
    each platform. The **View** menu has a **Look and Feel** menu item where you can
    choose between **Native Theme**, **Mac OS Classic**, **Windows 95**, and **Motif**.
    The same isn''t true for mobile operating systems as all controls look like Motif.
    You still have two choices though: you can create graphics that look like they
    belong in your target OS, or you can call native routines in order to let the
    system itself present the appropriate controls.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode 能够在 Mac、Windows 和 Linux 上发布，并在一定程度上解决了为每个平台制作界面元素看起来正确的问题。**视图** 菜单中有一个
    **外观和感觉** 菜单项，你可以从中选择 **原生主题**、**Mac OS Classic**、**Windows 95** 和 **Motif**。对于移动操作系统来说，情况并非如此，因为所有控件看起来都像
    Motif。尽管如此，你仍然有两个选择：你可以创建看起来属于目标操作系统的图形，或者你可以调用原生例程，以便让系统本身显示适当的控件。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Set up a *test bed* mobile application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个 *测试床* 移动应用程序
- en: Open an e-mail and browser windows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开电子邮件和浏览器窗口
- en: Show a date picker control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示日期选择器控件
- en: Load pictures from the library and camera
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图库和相机加载图片
- en: Make an iOS styled button
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 iOS 风格的按钮
- en: Manually lay out an interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动布局界面
- en: Use code to lay out an interface
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码来布局界面
- en: Look at a powerful mobile interface control's add-on
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看一个强大的移动界面控制的附加组件
- en: Setting up a test bed mobile app
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试床移动应用程序
- en: As a proving ground for the things we're going to try, we'll set up a single
    mobile app that has multiple screens, one for each of the things we want to test.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们要尝试的事情的试验场，我们将设置一个具有多个屏幕的单个移动应用程序，每个屏幕对应我们想要测试的每个事物。
- en: What should we call the test bed app? We could call it almost anything, but
    we'll let the iPhone make the decision for us. On the iPhone and iPod touch, there
    is only a small amount of space under the home screen icons for the name to appear.
    iOS will take your nice long app name and show a shortened version of the name,
    using ellipses to concatenate the ends of the name together. My super duper app
    will appear as My sup…app, not quite as informative! The number of letters that
    can appear without the text being truncated will vary depending on the width of
    the letters used, but typically, it has a limit of 11 letters. So, we will call
    the test bed app LC Test Bed, which is exactly 11 letters!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该怎么称呼测试床应用程序？我们可以叫它几乎任何名字，但我们将让 iPhone 为我们做出决定。在 iPhone 和 iPod touch 上，主屏幕图标下方只有一小块空间显示名称。iOS
    会显示你的长应用程序名称，并使用省略号将名称的末尾连接起来，显示名称的缩短版本。我的超级无敌应用程序将显示为 My sup…app，信息量不是很大！在不截断文本的情况下可以显示的字母数量会根据使用的字母宽度而变化，但通常，它有一个11个字母的限制。因此，我们将测试床应用程序命名为
    LC Test Bed，正好是11个字母！
- en: Time for action – making the test bed stack
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 制作测试床栈
- en: Before we create the iOS and Android apps, we should get what we want ready,
    as a LiveCode stack and fully test it on our desktop computers. The following
    steps are going to assume that you know how to do what is asked in LiveCode, without
    precise instructions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建 iOS 和 Android 应用之前，我们应该准备好我们想要的内容，作为一个 LiveCode 栈，并在我们的台式计算机上对其进行全面测试。以下步骤将假设你知道如何在
    LiveCode 中完成所要求的内容，而不需要精确的指令。
- en: Open LiveCode, create a new **Mainstack**, and save it as `LCTestBed`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 LiveCode，创建一个新的 **主栈**，并将其保存为 `LCTestBed`。
- en: Set the screen size to 320 x 480\. This is just to make sure that things appear
    on the smallest of screens. The things we will make, will appear at the upper-left
    corner area of the larger screens.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置屏幕大小为 320 x 480。这只是确保在最小的屏幕上显示内容。我们将制作的内容将出现在较大屏幕的左上角区域。
- en: We are going to make a button for each card in the stack; let's start by making
    a card named **Menu**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为栈中的每一张卡片制作一个按钮；让我们先制作一个名为 **菜单** 的卡片。
- en: Add buttons for **Email**, **Browser**, **DatePicker**, and **Picture**. Make
    sure that the buttons are big enough to touch on your devices. You should have
    something like what is shown here:![Time for action – making the test bed stack](img/image00255.jpeg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**电子邮件**、**浏览器**、**日期选择器**和**图片**按钮。确保按钮足够大，可以在你的设备上触摸。你应该有如下所示的内容：![行动时间
    – 制作测试床堆栈](img/image00255.jpeg)
- en: Create four new cards and name each one so that they match the button names.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四张新的卡片，并将每张卡片的名称与按钮名称匹配。
- en: 'Back at the first card, set the script of each button to go to the matching
    cards with this script:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到第一张卡片，将每个按钮的脚本设置为跳转到匹配的卡片，使用以下脚本：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On each card, create a button to return to the Menu card. Name the button `Menu`.
    Set its script to the same as the other buttons.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每张卡片上创建一个按钮，用于返回菜单卡片。将按钮命名为`Menu`。设置其脚本与其他按钮相同。
- en: Select the Run (browse) tool and try clicking on the buttons to jump to the
    four cards and back to the menu.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择运行（浏览）工具并尝试点击按钮跳转到四张卡片并返回到菜单。
- en: '*What just happened?*'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Well, nothing too exciting! However, you should now have five cards and the
    ability to go in and out of the Menu card. We're going to add scripts to each
    card to help illustrate its various features. The most efficient approach will
    be to add all the scripts and related buttons and fields and then to test the
    final test bed app in one go. However, where's the fun in that! Instead, we'll
    go one feature at a time…
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，没有什么特别激动人心的！然而，你现在应该有五张卡片，并且能够进入和退出菜单卡片。我们将为每张卡片添加脚本以帮助说明其各种功能。最有效的方法是添加所有脚本和相关按钮以及字段，然后一次性测试最终的测试床应用。然而，那样有什么乐趣呢！相反，我们将一次添加一个功能…
- en: Invoking the desktop e-mail application
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用桌面电子邮件应用
- en: There are many cases where you may want to hear from the users of your applications.
    Perhaps, you want them to e-mail suggested improvements or to ask you questions.
    You could easily launch their e-mail program and leave the user to figure out
    what to write. Alternately, you could set the **To** address, **Subject**, and
    even some of the **Body** of the message. At the very least, it would make your
    life easier because you could filter incoming e-mails based on something that
    you placed in the Subject field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况你可能想从你的应用程序用户那里得到反馈。也许，你希望他们通过电子邮件提出改进建议或向你提问。你可以轻松地启动他们的电子邮件程序，让用户自己决定写什么。或者，你可以设置**收件人**地址、**主题**，甚至消息的**正文**部分。至少，这会使你的生活更轻松，因为你可以根据你在主题字段中放置的内容过滤收到的电子邮件。
- en: Time for action – calling the native e-mail application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 调用原生电子邮件应用
- en: 'In the following steps we''ll make some fields and a button to try sending
    an e-mail feature:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将创建一些字段和一个按钮来尝试发送电子邮件功能：
- en: Go to the **Email** card and create four fields. Name them **To**, **CC**, **Subject**,
    and **Body**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**电子邮件**卡片并创建四个字段。将它们命名为**收件人**、**抄送**、**主题**和**正文**。
- en: Make a button named **Test**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**测试**的按钮。
- en: 'In the **Test** button, add this script:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**测试**按钮中添加以下脚本：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Select the **Run** tool and type in example information in each of the fields.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**运行**工具并在每个字段中输入示例信息。
- en: After setting up the **Standalone Application Settings…** and selecting the
    **Test Target**, click on the **Test** button.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置**独立应用程序设置…**并选择**测试目标**后，点击**测试**按钮。
- en: '*What just happened?*'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: One neat thing about the LiveCode syntax is that the code for mobile also works
    for desktop applications and vice versa. All being well, when you click on the
    Test button, you will find yourself in your default e-mail application ready to
    send the message that you had entered in the LiveCode stack fields.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode语法的巧妙之处在于，移动端的代码也适用于桌面应用程序，反之亦然。如果一切顺利，当你点击测试按钮时，你将发现自己已经进入了默认的电子邮件应用，准备发送你在LiveCode堆栈字段中输入的消息。
- en: Installing the e-mail test on devices
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在设备上安装电子邮件测试
- en: It's no great surprise that the desktop test worked. The ability to open other
    applications is the basic feature of LiveCode. Still, it's neat to send over some
    initial text for the new message to take on. Next, we should check whether this
    works on devices too.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面测试能够成功运行并不令人惊讶。打开其他应用程序的能力是LiveCode的基本功能。尽管如此，发送一些初始文本给新消息还是很有趣的。接下来，我们应该检查这也在设备上是否可行。
- en: Time for action – trying the test bed stack on devices
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在设备上尝试测试床堆栈
- en: 'Connect your Android and/or iOS device to your computer using USB. These instructions
    are almost the same as in the previous chapter, when we tested a "Hello World"
    stack. After this point, any directions will be briefer and based on the assumption
    that you know the steps needed to test an app on your device. [Chapter 7](part0093.xhtml#aid-2OM4A2
    "Chapter 7. Deploying to Your Device"), *Deploying to Your Device*, describes
    all the options in the **Standalone Applications Settings** dialog. For the moment,
    we''re only going to fill in a few details, so here, we will just view a portion
    of the dialog, starting with the Android settings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用USB将你的Android和/或iOS设备连接到电脑。这些说明几乎与上一章中测试 "Hello World" 堆栈时的说明相同。从这一点开始，任何指示都将更简短，并基于你已知在设备上测试应用程序的步骤。[第7章](part0093.xhtml#aid-2OM4A2
    "第7章。将应用程序部署到您的设备")，*将应用程序部署到您的设备*，描述了 **独立应用程序设置** 对话框中的所有选项。目前，我们只将填写一些细节，所以在这里，我们将只查看对话框的一部分，从Android设置开始：
- en: '![Time for action – trying the test bed stack on devices](img/image00256.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间 – 在设备上尝试测试床堆栈](img/image00256.jpeg)'
- en: Make sure that **Android** is checked in the **Standalone Application Settings**
    dialog.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 **独立应用程序设置** 对话框中勾选了 **Android**。
- en: In the **Identifier** field, type in an identifier that will be unique; `com.yourname.lctestbed`
    would do.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **标识符** 字段中，输入一个唯一的标识符；`com.yourname.lctestbed` 就可以。
- en: Get your device to its home screen past the initial lock screen if there is
    one.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有初始锁屏，将设备切换到主屏幕。
- en: In LiveCode, choose **Development/Test Target** and select your Android device.
    It will be named as **Android** followed by a long number.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在LiveCode中，选择 **开发/测试目标** 并选择你的Android设备。它将被命名为 **Android** 后跟一个长数字。
- en: Choose the **Development/Test** option.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **开发/测试** 选项。
- en: After compilation, the stack should run on your Android device and you should
    be able to touch the **Email** button and perform a test message that will use
    the Android e-mail application.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译后，堆栈应该在您的Android设备上运行，您应该能够触摸 **电子邮件** 按钮并执行一个测试消息，该消息将使用Android电子邮件应用程序。
- en: 'On iOS, if you haven''t already done so, read [Chapter 7](part0093.xhtml#aid-2OM4A2
    "Chapter 7. Deploying to Your Device"), *Deploying to Your Device*, on how to
    deploy to your device. At least read the parts that show you how to install your
    iOS developer certificates and provisioning files. As with Android, we''re only
    going to alter a couple of items in the Standalone Application Settings. The following
    is the screenshot of the dialog that we''ll be altering:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，如果你还没有这样做，请阅读[第7章](part0093.xhtml#aid-2OM4A2 "第7章。将应用程序部署到您的设备")，*将应用程序部署到您的设备*，了解如何将应用程序部署到您的设备。至少阅读那些展示如何安装您的iOS开发者证书和配置文件的章节。就像Android一样，我们只会在独立应用程序设置中更改几个项目。以下是我们将要更改的对话框截图：
- en: '![Time for action – trying the test bed stack on devices](img/image00257.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间 – 在设备上尝试测试床堆栈](img/image00257.jpeg)'
- en: 'Perform the following steps for an iOS device:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对iOS设备执行以下步骤：
- en: Change the **Standalone Application Settings** to **iOS**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **独立应用程序设置** 更改为 **iOS**。
- en: Under **Basic Application Settings** of the iOS settings is a **Profile** drop-down
    menu of the provisioning files that you have installed. Choose the one that is
    configured for the device you are going to test the app on.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS设置的 **基本应用程序设置** 下，有一个 **配置文件** 下拉菜单，用于选择你已安装的配置文件。选择一个为你将要测试的设备配置的配置文件。
- en: In the **Internal App ID** field, type in a unique ID. As with Android, `com.yourname.lctestbed`
    would do. `yourname` would of course be your name or your company name.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内部应用程序ID** 字段中，输入一个唯一的ID。就像Android一样，`com.yourname.lctestbed` 就可以。当然，`yourname`
    将是你的名字或公司名字。
- en: If you are testing on iPad, select the **iPod, iPhone and iPad** option from
    the **Supported Devices** drop-down menu.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在iPad上测试，从 **支持设备** 下拉菜单中选择 **iPod, iPhone 和 iPad** 选项。
- en: Close the dialog and choose **Save as Standalone Application…** from the **File**
    menu.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭对话框，并从 **文件** 菜单中选择 **另存为独立应用程序…**。
- en: When the saving is done, you may see a warning message telling you about missing
    splash screens and icons. It won't matter for now.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存完成后，你可能看到一个警告消息，告诉你缺少启动画面和图标。现在这并不重要。
- en: In **Finder**, locate the folder that was just created and open it to reveal
    the app file itself.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Finder** 中找到刚刚创建的文件夹，并打开它以显示应用程序文件本身。
- en: Open **Xcode** and choose **Devices** from the **Window** menu.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Xcode** 并从 **窗口** 菜单中选择 **设备**。
- en: You should see your device listed. Select it and if you see a button labeled
    **Use for Development**, click on that button.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能看到您的设备列出来。选择它，如果您看到一个标记为**用于开发**的按钮，请点击该按钮。
- en: Drag the app file straight from the **Finder** window to your device in the
    **Organizer** window.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接从**查找器**窗口将应用程序文件拖放到您的设备在**组织者**窗口中。
- en: The small colored circle next to the device will turn orange for a moment and
    then back to green.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备旁边的小彩色圆圈会暂时变成橙色，然后变回绿色。
- en: You can now open the app and try the **Email** button and test message, which
    will use the standard iOS Mail application.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以打开应用程序并尝试**邮件**按钮和测试消息，这将使用标准的iOS邮件应用程序。
- en: '*What just happened?*'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We went through the steps needed to install the test bed app on both Android
    and iOS devices. We also had to change a couple of things in the standalone application
    settings. As you saw, there are quite a lot of settings in there. You can look
    forward to learning about them all in [Chapter 7](part0093.xhtml#aid-2OM4A2 "Chapter 7. Deploying
    to Your Device"), *Deploying to Your Device*!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了在Android和iOS设备上安装测试床应用程序所需的步骤。我们还必须在独立应用程序设置中更改一些事情。如您所见，那里有很多设置。您可以在[第7章](part0093.xhtml#aid-2OM4A2
    "第7章。将应用程序部署到您的设备")中期待了解它们的所有内容，*将应用程序部署到您的设备*！
- en: Opening a web page
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开网页
- en: Another requirement in your applications is being able to present additional
    online information. You want the user to click on a link, or touch as the case
    may be, so that he/she is taken to a page that lists all the other applications
    that the user can buy from you!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序中还有一个要求，就是能够展示额外的在线信息。您希望用户点击链接，或者触摸，以便他们被带到列出用户可以从您那里购买的所有其他应用程序的页面！
- en: Time for action – calling the native browser application
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 调用原生浏览器应用程序
- en: 'This next test will go faster, or at least, the instructions will be briefer,
    as we will condense some of the steps in more concise directions, as given here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试将会更快，或者至少，说明将会更简短，因为我们将会将一些步骤浓缩成更简洁的指示，如下所示：
- en: Copy the **Test** button on the **Email** card and paste it on the **Browser**
    card, just to save you some time making the button look nice.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**测试**按钮，将其从**邮件**卡片粘贴到**浏览器**卡片上，这样您可以节省一些时间来使按钮看起来更美观。
- en: 'Edit the **Test** button script and change it to this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**测试**按钮脚本并将其更改为以下内容：
- en: '[PRE2]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Choose the **Run** tool and click on the **Test** button. You will see the RunRev
    home page in your default browser.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**运行**工具并点击**测试**按钮。您将在默认浏览器中看到RunRev的主页。
- en: 'The steps for trying the app on devices is exactly the same as with the steps
    to test the e-mail feature. For Android:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上尝试应用程序的步骤与测试电子邮件功能的步骤完全相同。对于Android：
- en: Select Android in the **Standalone Application Settings**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**独立应用程序设置**中选择Android。
- en: Select your Android device as the test target from the **Development** menu
    (most likely, it will still be selected from before).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**开发**菜单中选择您的Android设备作为测试目标（最有可能的是，它仍然是从之前选择的）。
- en: Select **Test** from the **Development** menu.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**开发**菜单中选择**测试**。
- en: The previous test of the app will be overwritten and the new version will be
    launched automatically.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的前一个测试将被覆盖，并将自动启动新版本。
- en: Try clicking on the **Browser** button and the **Test** button that you just
    created on the Browser card. The [http://runrev.com/](http://runrev.com/) page
    should be opened if you click on them.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击您在浏览器卡片上刚刚创建的**浏览器**按钮和**测试**按钮。如果您点击它们，应该会打开[http://runrev.com/](http://runrev.com/)页面。
- en: 'For iOS:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS：
- en: Select iOS in the standalone application settings.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在独立应用程序设置中选择iOS。
- en: Redo **Save as Standalone Application** and then drag the app file on your device
    in the **Organizer** window of Xcode, as you did the first time.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新执行**另存为独立应用程序**，然后将应用程序文件拖放到Xcode的**组织者**窗口中，就像您第一次做的那样。
- en: Try the **Browser** and **Test** buttons; you should see that the RunRev home
    page has opened inside Safari.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击**浏览器**和**测试**按钮；您应该看到RunRev的主页在Safari中打开。
- en: '*What just happened?*'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: As with the Email test, adding the standard code to open a web page works for
    Android and iOS just as it does for a desktop computer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与电子邮件测试一样，添加打开网页的标准代码在Android和iOS上与在桌面计算机上一样有效。
- en: If you are testing on both Android and iOS, you will notice that the behavior
    is different when you return after looking at a web page. With Android, you can
    press the back arrow button and still be on the Browser card of your stack. With
    iOS, the stack is restarted when you return. We will examine a solution later,
    where we write data to an external file, so that when the app is reopened, we
    can return the user before leaving the app.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时在Android和iOS上进行测试，你会在查看网页后返回时注意到行为的不同。在Android上，你可以按返回箭头按钮，仍然处于你的堆栈的浏览器卡片上。在iOS上，当你返回时，堆栈会重新启动。我们将在稍后探讨一个解决方案，我们将数据写入外部文件，这样当应用重新打开时，我们可以返回用户在离开应用之前的状态。
- en: The mobile-only date picker
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅移动设备使用的日期选择器
- en: The next couple of examples we will try are the ones that only work on mobile
    devices and not on desktop computers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个示例我们将尝试的，是只在移动设备上工作，而不是在桌面计算机上工作的。
- en: Time for action – displaying a date picker
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 显示日期选择器
- en: 'Many applications require the user to choose a date for an event, and with
    mobile devices, there is a particular look to the date picker that you are shown.
    Using LiveCode let''s us display such a control:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要用户为事件选择一个日期，并且在使用移动设备时，日期选择器会有一个特定的外观。使用LiveCode，我们可以显示这样的控件：
- en: Copy the **Test** button from the Browser card and paste it on the DatePicker
    card.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器卡片上的**Test**按钮复制并粘贴到DatePicker卡片上。
- en: 'Edit the script to make it like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑脚本使其看起来像这样：
- en: '[PRE3]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Select the **Run** tool and try the **Test** button. You'll see an error because
    this is a mobile-only feature.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Run**工具并尝试**Test**按钮。你会看到一个错误，因为这是一个仅适用于移动设备的功能。
- en: For a change, select **iPhone** or **iPad Simulator** from the **Development/Test
    Target** menu and then choose **Test** from the **Development** menu.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了改变一下，从**Development/Test Target**菜单中选择**iPhone**或**iPad Simulator**，然后从**Development**菜单中选择**Test**。
- en: You will see your stack open in the iOS simulator and you can try the **DatePicker**
    and **Test** buttons to then see the iOS date picker displayed.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在iOS模拟器中看到你的堆栈打开，你可以尝试**DatePicker**和**Test**按钮，然后看到iOS日期选择器显示出来。
- en: Perform the same old Save As and install using the Organizer window steps to
    try the date picker on your iOS device.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用组织者窗口中的相同旧版“另存为”和安装步骤来尝试在你的iOS设备上使用日期选择器。
- en: Touch the **DatePicker** button on the menu card and the **Test** button on
    the Datepicker card. An iOS native date picker should appear.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击菜单卡片上的**DatePicker**按钮和DatePicker卡片上的**Test**按钮。应该会出现一个iOS原生日期选择器。
- en: '*What just happened?*'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Hopefully, you're getting better and are able to build and install mobile apps
    faster by now! In addition to testing again on a device, we also tried out the
    simulator. Generally speaking, it is faster to use the iOS simulator whenever
    you can, and only test on a device when you're checking things such as multi-touch,
    accelerometer, and camera support.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经变得更好，能够更快地构建和安装移动应用！除了在设备上再次测试之外，我们还尝试了模拟器。一般来说，只要可能，使用iOS模拟器会更快，只有在检查多指触摸、加速度计和相机支持等问题时才需要在设备上进行测试。
- en: Time for action – loading pictures for a mobile device
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 为移动设备加载图片
- en: Maybe one day it will be possible for us to bring in images from the user's
    desktop computer photo application or from their web camera, but for now, these
    features only work on mobile devices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或许有一天，我们可以从用户的桌面计算机照片应用或他们的网络摄像头中导入图片，但到目前为止，这些功能只适用于移动设备。
- en: 'LiveCode can call upon the native photo library and camera apps. We will test
    both of these on Android and iOS, but of course, only if your device has some
    saved images and a camera. For Kindle Fire, which doesn''t have a camera, make
    sure that you save some pictures in the Gallery app, so that we can at least try
    loading those. Follow these steps to load pictures for a mobile device:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode可以调用原生的照片库和相机应用。我们将在Android和iOS上测试这两个应用，但当然，前提是你的设备上保存了一些图片和相机。对于没有相机的Kindle
    Fire，请确保你在图库应用中保存了一些图片，这样我们至少可以尝试加载这些图片。按照以下步骤为移动设备加载图片：
- en: Copy the **Test** button from the `DatePicker` card and paste it twice on the
    Pictures card. Change the name of the buttons to Test Camera and Test Library.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DatePicker`卡片上的**Test**按钮复制并粘贴到图片卡片上两次。将按钮的名称更改为Test Camera和Test Library。
- en: 'Edit the script of the test camera button to be:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑测试相机按钮的脚本为：
- en: '[PRE4]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit the script of the test library button to be:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑测试库按钮的脚本为：
- en: '[PRE5]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we test the loading of pictures, the image that is loaded will lie on top
    of the test buttons, stopping us from returning to the menu card. To solve this
    issue, add this to the card script:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们测试图片加载时，加载的图片将位于测试按钮之上，阻止我们返回到菜单卡片。为了解决这个问题，请将以下内容添加到卡片脚本中：
- en: '[PRE6]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Go in the **Standalone Application Settings** and select **Android**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**独立应用程序设置**并选择**Android**。
- en: We have to ask the Android OS permission to use the camera and store the image,
    so check the boxes for **Camera** and **Write External Storage**:![Time for action
    – loading pictures for a mobile device](img/image00258.jpeg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须请求Android操作系统权限来使用相机并存储图片，因此请勾选**相机**和**写入外部存储**的复选框：![行动时间 - 为移动设备加载图片](img/image00258.jpeg)
- en: Repeat the steps for testing on your Android device, or installing on your iOS
    device.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Android设备上进行测试步骤，或在iOS设备上安装。
- en: Once the app is running on your device, touch **Pictures** on the first screen
    and then **Test Library**. You should see typical OS-specific options to choose
    a picture from your library or gallery.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序在您的设备上运行，请触摸第一个屏幕上的**图片**，然后**测试库**。您应该看到典型的操作系统特定选项，用于从您的图库或相册中选择图片。
- en: The picture you have selected is loaded on the card window and will fill most
    of the screen, obscuring our test and menu buttons. The card script we entered
    gives you the ability to touch the image in order to delete it so that you can
    then try another test.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您选择的图片已加载到卡片窗口中，并将填充大部分屏幕，遮挡我们的测试和菜单按钮。我们输入的卡片脚本让您能够触摸图片以删除它，这样您就可以尝试另一个测试。
- en: Try the **Test Camera** button. You will see the OS-specific camera application
    and when you have taken a picture and touched the **Use** or **Ok** button in
    the camera application, the image will be placed on the Pictures card.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试**测试相机**按钮。您将看到操作系统特定的相机应用程序，当您拍照并在相机应用程序中触摸**使用**或**确定**按钮时，图片将被放置在图片卡片上。
- en: '*What just happened?*'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: These simple scripts illustrate how LiveCode is able to call the OS-specific
    applications to do what would otherwise take a lot of coding. What's more, as
    later iOS and Android OS versions are released, the same simple scripts activate
    the more advanced features that Apple and Google will have implemented.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的脚本说明了LiveCode如何能够调用操作系统特定的应用程序来完成其他情况下需要大量编码的工作。更重要的是，随着iOS和Android操作系统版本的更新，相同的简单脚本可以激活苹果和谷歌将实现的高级功能。
- en: Pop quiz – getting the big picture
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 - 获得整体概念
- en: Q1\. We take so much for granted when it comes to improvements in technology.
    You might feel hard done by if your phone's camera is a measly 2 megapixels, but
    think back to how things were long ago and how big a picture you were used to
    seeing. In terms of the number of pixels, how many original Macintosh screens
    can fit in the area shown by a single 8 megapixel photo?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 当提到技术改进时，我们往往认为这是理所当然的。如果您的手机相机只有2百万像素，您可能会感到不公平，但回想一下很久以前的事情，以及您习惯看到的大画面。从像素数量来看，一个单张800万像素的图片可以容纳多少个原始Macintosh屏幕的面积？
- en: '4'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4'
- en: '15'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '15'
- en: '24'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '24'
- en: '45'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '45'
- en: 'Answer: 45!'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：45！
- en: The original Mac had a screen that was 512 x 342 pixels. This will fit more
    than 45 times in the area of an 8 megapixel photo.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 原始Mac的屏幕分辨率为512 x 342像素。这将在800万像素照片的面积中容纳超过45次。
- en: Making OS-styled buttons
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作操作系统风格的按钮
- en: It's nice that LiveCode can call upon an OS's native controls, but this raises
    a problem because the standard Motif-styled buttons will look ugly when used with
    the OS buttons. We can fix this either using built-in features of LiveCode or
    with the use of an add-on product.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，LiveCode可以调用操作系统的原生控件，但这引发了一个问题，因为当与操作系统按钮一起使用时，标准Motif风格的按钮看起来会很丑。我们可以通过使用LiveCode的内置功能或使用附加产品来解决这个问题。
- en: Using bitmaps
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用位图
- en: As we saw in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. LiveCode Fundamentals"),
    *LiveCode Fundamentals*, you can use different bitmaps for the button's states.
    You could get such images by taking screenshots of the buttons on your mobile
    device, at least with the iOS and Android OS v4 and later versions, or you can
    save a lot of time by downloading files that others have made available. Some
    of these files are only licensed for use in prototypes; here, we'll take a look
    at one of the files that is also licensed to be used in commercial products.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](part0016.xhtml#aid-F8901 "第1章。LiveCode基础")中看到的，*LiveCode基础*，你可以为按钮的不同状态使用不同的位图。你可以通过在你的移动设备上截图按钮来获取这样的图片，至少在iOS和Android
    OS v4及更高版本中可以这样做，或者你也可以通过下载其他人提供的文件来节省大量时间。其中一些文件仅授权用于原型设计；在这里，我们将查看一个也授权用于商业产品的文件。
- en: Time for action – using Photoshop to prepare button states
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Photoshop准备按钮状态的行动时间
- en: The file we are going to use has Photoshop filter effects that other programs
    cannot handle, so unfortunately, you will need Photoshop to follow all of these
    steps or at least have a friend who has Photoshop! Pixelmator and GraphicConverter
    on Mac OS X can also extract graphics from the file, possibly, by just copying
    an area of the screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的文件包含Photoshop滤镜效果，其他程序无法处理，所以很遗憾，你需要Photoshop来执行所有这些步骤，或者至少有一个拥有Photoshop的朋友！Mac
    OS X上的Pixelmator和GraphicConverter也可以从文件中提取图形，可能只需复制屏幕的一个区域即可。
- en: 'Read the following article:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读以下文章：
- en: '[http://spin.atomicobject.com/2011/03/07/photoshop-template-for-ios-buttons/](http://spin.atomicobject.com/2011/03/07/photoshop-template-for-ios-buttons/)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://spin.atomicobject.com/2011/03/07/photoshop-template-for-ios-buttons/](http://spin.atomicobject.com/2011/03/07/photoshop-template-for-ios-buttons/)'
- en: 'The article points to some other sources of information; for now though, download
    the following file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文章指向了一些其他信息来源；不过，现在请下载以下文件：
- en: '[http://spin.atomicobject.com/assets/2011/3/7/iOS_Buttons.psd](http://spin.atomicobject.com/assets/2011/3/7/iOS_Buttons.psd)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://spin.atomicobject.com/assets/2011/3/7/iOS_Buttons.psd](http://spin.atomicobject.com/assets/2011/3/7/iOS_Buttons.psd)'
- en: Open the file in Photoshop (it may open automatically).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Photoshop中打开文件（它可能会自动打开）。
- en: In the Layers palette, hide the layers named Background and Tool Bar – Retina.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图层调板中隐藏名为Background和ToolBar – Retina的层。
- en: Expand the layer named **Bar Button – Retina**, and hide the **Button Label**
    layer.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开名为**Bar Button – Retina**的层，并隐藏**按钮标签**层。
- en: Use the Marquee tool to select an area around the upper-right-hand side button.
    It should all look like this:![Time for action – using Photoshop to prepare button
    states](img/image00259.jpeg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形选框工具选择右上角按钮周围的区域。它应该看起来像这样：![使用Photoshop准备按钮状态的行动时间](img/image00259.jpeg)
- en: Choose **Copy Merged** from the **Edit** menu.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**编辑**菜单中选择**合并拷贝**。
- en: Select **New** from the **File** menu and make sure that the **Background Contents**
    property is set to **Transparent** and accept the size you are given.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**文件**菜单中选择**新建**，并确保**背景内容**属性设置为**透明**，接受你给出的尺寸。
- en: Paste the content, it will be an exact fit, and you will see the idle state
    for that button.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粘贴内容，它将是一个完美的匹配，你将看到该按钮的空闲状态。
- en: Choose **Save for Web & Devices…** from the **File** menu.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**文件**菜单中选择**另存为网页和设备…**。
- en: In the save dialog, select **24 bit PNG** and make sure that the **Transparency**
    box is checked. Save the PNG with a suitable name, say `bluebuttonup.png`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存对话框中，选择**24位PNG**并确保**透明度**框被勾选。使用合适的名称保存PNG，例如`bluebuttonup.png`。
- en: Return to the main document and turn on the Visible = Active layer.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回主文档并打开Visible = Active层。
- en: Do another **Copy Merged** | **New** | **Paste** | **Save for Web & Devices…**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行**合并拷贝** | **新建** | **粘贴** | **另存为网页和设备…**。
- en: Save the PNG as `bluebuttondown.png`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PNG保存为`bluebuttondown.png`。
- en: Go back to LiveCode.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回LiveCode。
- en: Reopen the test bed stack.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开测试床堆栈。
- en: Use **File**, **Import As Control**, and **Image File…** to bring the two PNGs
    in the stack.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件**，**导入为控件**，和**图像文件…**将两个PNG文件导入堆栈。
- en: You can place the two images anywhere. Uncheck **Visible** in **Basic Properties**
    for each image.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将这两张图片放置在任何位置。在每个图片的**基本属性**中取消勾选**可见**。
- en: Add a new button to the first card and give it the name Location.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一张卡片上添加一个新的按钮，并将其命名为位置。
- en: 'Set the button script to:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置按钮脚本为：
- en: '[PRE7]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Select the Location button and in **Basic Properties** of the **Inspector**
    palette, turn off **Show name** and **Opaque**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择位置按钮，并在**检查器**调板的**基本属性**中关闭**显示名称**和**不透明**。
- en: In **Icons & Border**, turn off **Three D**, **Border** and **Hilite border**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图标与边框**中，关闭**三维效果**、**边框**和**高亮边框**。
- en: Click on the magic wand button next to the **Icon** entry in the **Inspector**
    palette.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**检查器**调色板中**图标**条目旁边的魔法棒按钮。
- en: From the **Image library** drop-down menu, select **This Stack**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**图像库**下拉菜单中选择**此堆栈**。
- en: Click on the lighter one of the two blue images.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击两个蓝色图像中较亮的一个。
- en: Click on the magic wand button next to the **Hilite icon** entry and then click
    on the darker of the two images.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**高亮图标**条目旁边的魔法棒按钮，然后点击两个图像中较暗的一个。
- en: Resize the button just big enough to show the blue image without it being cropped.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整按钮的大小，使其刚好足够显示蓝色图像而不会被裁剪。
- en: Place a Label field on top of the button.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮上方放置一个标签字段。
- en: In **Basic Properties**, check the **Disabled** box. This is to make sure that
    the field doesn't trap the click you are going to perform. We want the button
    to get that click.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**基本属性**中，勾选**禁用**框。这是为了确保字段不会捕获你将要执行的点击。我们希望按钮能够获得那个点击。
- en: In **Contents**, enter `Location`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容**中输入`Location`。
- en: Under **Text** **Formatting**, set the field to use **Helvetica Neue, 18 point,
    Bold, and center aligned**.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文本格式化**下，将字段设置为使用**Helvetica Neue，18点，粗体，居中对齐**。
- en: Under Colors & Palettes, set the text color white.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**颜色与调色板**下，设置文字颜色为白色。
- en: Align the field and the button so that the two are centered on each other.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字段和按钮对齐，使两者相互居中。
- en: If you now test using the iOS Simulator and click on the Location button, you
    will just see a zero, but trying on a device should display your latitude when
    you touch the button (you will have to give permission to the app to know your
    location the first time you press the button.)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在使用iOS模拟器进行测试并点击位置按钮，你将只看到一个零，但在设备上尝试应该会在你触摸按钮时显示你的纬度（你将不得不在第一次按下按钮时允许应用程序知道你的位置。）
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'Note that the example is in the iOS 6 format. iOS 8 can be found at:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，示例是iOS 6格式。iOS 8可以在以下位置找到：
- en: '[http://www.teehanlax.com/tools/iphone/](http://www.teehanlax.com/tools/iphone/)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.teehanlax.com/tools/iphone/](http://www.teehanlax.com/tools/iphone/)'
- en: '*What just happened?*'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Although the button we made, may not be of the perfect size or even have the
    correct look for a standalone iOS button, we did go through all of the steps that
    you would need to make button state images. Placing a LiveCode field over the
    image buttons doesn't necessarily give it the best appearance. In reality, you
    would take more time in Photoshop to make a button of the right width for the
    label you're using and might also have to add the text to the image itself. It
    would look better and would not need a field to show the button's name in LiveCode.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们制作的按钮可能不是完美的尺寸，甚至可能不符合独立iOS按钮的正确外观，但我们确实完成了制作按钮状态图像所需的所有步骤。在图像按钮上放置LiveCode字段并不一定能够给出最佳的外观。实际上，你会在Photoshop中花费更多的时间来制作适合你使用的标签的正确宽度的按钮，并且可能还需要将文本添加到图像本身。这将看起来更好，并且不需要字段在LiveCode中显示按钮的名称。
- en: LiveCode is able to use code to create the images we need, by setting the points
    of a graphic and its `fillGradient`. However, once you have the component parts
    needed to simulate a button or other kind of control, it would still take a lot
    more scripting to manage these elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode能够通过设置图形的点及其`fillGradient`来使用代码创建我们需要的图像。然而，一旦你有了模拟按钮或其他类型控件所需的组件，仍然需要更多的脚本才能管理这些元素。
- en: There is an easy way out, although, it will cost you $50!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的解决方案，尽管这会花费你50美元！
- en: Pop quiz – the cost of things these days
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——现在的物价
- en: Q1\. With the increase in your expectations about the size of a digital photo,
    you also expect to get a lot more for your money these days. While you weigh up
    the advantages of spending $50, how much better value do you think a computer's
    memory is now, compared to 25 years ago?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 随着你对数码照片大小的期望增加，你今天也期望得到更多的价值。当你权衡花费50美元的利弊时，你认为与25年前相比，电脑的内存现在价值提高了多少？
- en: 10 times better
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10倍的效果
- en: Half as good
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一半的效果
- en: 100 times better
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 100倍的效果
- en: 20,000 times better!
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 20,000倍！
- en: 'Answer: 4'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：4
- en: Yes indeed. 25 years ago, Apple was selling a 4 MB add-on kit for Macintosh
    II for about $1,500\. They now sell a 64 GB add-on for Mac Pro for $1,200.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 的确如此。25年前，苹果公司以大约1,500美元的价格出售Macintosh II的4MB附加套件。现在他们以1,200美元的价格出售Mac Pro的64GB附加套件。
- en: MobGUI to the rescue!
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobGUI来拯救！
- en: RunRev is based in Edinburgh, Scotland, and they're a talented bunch! However,
    they're not the only talented Scottish folk, there's John Craig as well. He has
    developed a powerful add-on to LiveCode that includes an increasingly long list
    of iOS- and Android-OS-like controls. If you were to buy his product, you would
    have to pay $50 for which you get the current version plus any updates that are
    released in the 12 months following your purchase date. While we take a look at
    it here, we can also use a trial version of the product.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: RunRev 总部位于苏格兰爱丁堡，他们是一群有才华的人！然而，他们并不是唯一有才华的苏格兰人，还有约翰·克雷格。他为 LiveCode 开发了一个强大的附加组件，其中包括一个越来越长的类似
    iOS 和 Android 操作系统的控件列表。如果你要购买他的产品，你需要支付 50 美元，你将获得当前版本以及在你购买日期后 12 个月内发布的任何更新。虽然我们在这里查看它，我们也可以使用产品的试用版。
- en: Time for action – getting started with MobGUI
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 开始使用 MobGUI
- en: 'As with the other add-ons to LiveCode, MobGUI needs to be installed in the
    LiveCode plugins folder. On Windows, this will be at `My Documents/My LiveCode/Plugins`.
    On Mac, it will be at `~/Documents/My LiveCode/Plugins`. This default location
    can be changed under the **LC Preferences** menu and **Files & Memory**. The following
    steps will guide you through getting started with MobGUI:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LiveCode 的其他附加组件一样，MobGUI 需要安装到 LiveCode 插件文件夹中。在 Windows 上，这将是在 `My Documents/My
    LiveCode/Plugins`。在 Mac 上，这将是在 `~/Documents/My LiveCode/Plugins`。此默认位置可以在 **LC
    Preferences** 菜单和 **Files & Memory** 下进行更改。以下步骤将指导你开始使用 MobGUI：
- en: Download the latest version of MobGUI from [http://mobgui.com/download.php](http://mobgui.com/download.php).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://mobgui.com/download.php](http://mobgui.com/download.php) 下载 MobGUI
    的最新版本。
- en: The `.zip` file will expand to become a LiveCode stack named **MobGUI_V1-28.livecode**
    for the current version. Hopefully, there will be a newer version when you download
    this.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.zip` 文件将展开成为一个名为 **MobGUI_V1-28.livecode** 的 LiveCode 堆栈，用于当前版本。希望当你下载时，会有更新的版本。'
- en: Drag the stack into the plugins folder and reopen LiveCode.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将堆栈拖入插件文件夹，并重新打开 LiveCode。
- en: Make a new Mainstack.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Mainstack。
- en: From the **Development** menu, choose **Plugins/revMobGUI**. This window will
    appear when you do so:![Time for action – getting started with MobGUI](img/image00260.jpeg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Development** 菜单中选择 **Plugins/revMobGUI**。当你这样做时，会出现以下窗口：![行动时间 – 开始使用 MobGUI](img/image00260.jpeg)
- en: The MobGUI window is much like a combination of the LiveCode Tool palette and
    Inspector palette.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobGUI 窗口类似于 LiveCode 工具调色板和检查器调色板的组合。
- en: Try dragging different items on the card and look at the options for each item.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将不同的项目拖放到卡片上，并查看每个项目的选项。
- en: The left-hand side list is scrollable and shows additional controls.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左侧的列表是可滚动的，并显示额外的控件。
- en: Once the controls are placed on the card, they can be manipulated like the normal
    LiveCode controls.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦控件放置在卡片上，它们就可以像正常的 LiveCode 控件一样进行操作。
- en: The selection field at the top right-hand side allows different themes to be
    selected. Select the **android** theme and click on **Apply**. Note that the controls
    you dragged out change. At the time of writing this book, the **android** theme
    represents the older pre-Lollipop themes.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上右角的选项字段允许选择不同的主题。选择 **android** 主题，然后点击 **Apply**。请注意，你拖出的控件会发生变化。在撰写本书时，**android**
    主题代表较老的预 Lollipop 主题。
- en: After you have manipulated a stack, you can export the current theme for later
    use. You need to save the newly created stack named the **MobGUI Theme** stack.
    When opened later, this stack will have an **Import** button.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你操作完堆栈后，你可以导出当前主题以供以后使用。你需要保存新创建的名为 **MobGUI Theme** 的堆栈。稍后打开时，此堆栈将有一个 **Import**
    按钮。
- en: '*What just happened?*'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: One remarkable thing about LiveCode is that the many windows and palettes that
    you use in the program are all just stacks, and we've started to make use of a
    rather specialized stack that is going to save us a lot of time and will give
    us a nice interface like the OS-specific interface.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode 的一个显著特点是，你在这个程序中使用的许多窗口和调色板实际上都是堆栈，我们已经开始使用一个相当专业的堆栈，这将为我们节省大量时间，并给我们一个像特定操作系统界面一样的好界面。
- en: A test bed app, the MobGUI way
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以 MobGUI 方式制作的测试床应用程序
- en: We're going to make much the same test bed app, but this time, we'll try to
    give a more iOS-like look to the app.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个类似的测试床应用程序，但这次，我们将尝试给应用程序一个更类似 iOS 的外观。
- en: Time for action – using MobGUI to make a test bed app
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用 MobGUI 制作测试床应用程序
- en: 'As you work in LiveCode starting new stacks, closing others, and opening previously
    saved stacks, these actions can still occupy memory. Sometimes, you can get in
    a confused state where you''re making a new Untitled stack only to find out there''s
    still an Untitled stack on the go, which you''re asked about if you want to purge.
    So, why not treat yourself to a quit and start a fresh launch of LiveCode! The
    following steps will help you achieve that:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 LiveCode 中工作时，开始新的堆栈，关闭其他堆栈，以及打开之前保存的堆栈，这些操作仍然会占用内存。有时，你可能会陷入困惑的状态，只创建了一个新的未命名堆栈，却发现还有一个正在进行的未命名堆栈，这时你会被询问是否要清除。所以，为什么不给自己一个退出并重新启动
    LiveCode 的机会呢！以下步骤将帮助您实现这一点：
- en: Create a new Mainstack. Set the name to `MGTestBed` and save it somewhere you
    can easily find it. Perhaps, in the folder with the `LCTestBed` stack, which was
    feeling lonely!
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的主堆栈。将名称设置为`MGTestBed`，并将其保存在您容易找到的地方。也许在包含`LCTestBed`堆栈的文件夹中，它感觉有点孤单！
- en: Open the MobGUI window by selecting **Development/Plugins/revMobGUI**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **Development/Plugins/revMobGUI** 打开 MobGUI 窗口。
- en: In the MobGUI window's page of controls, select the **Slider resizes** box and
    move the slider to select a size of **320x480**. This is the size of the original
    iPhone. Note the other sizes available. The card can also be resized with the
    LiveCode Inspector.![Time for action – using MobGUI to make a test bed app](img/image00261.jpeg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MobGUI 窗口的控件页面上，选择**滑块调整大小**复选框，并将滑块移动以选择**320x480**的大小。这是原始 iPhone 的大小。注意其他可用的大小。卡片也可以使用
    LiveCode 检查器进行调整。![使用 MobGUI 创建测试床应用程序的时间](img/image00261.jpeg)
- en: Select the **MobGUI context menu in IDE** option in the MobGUI window. This
    will enable you to edit the MobGUI control behaviors later.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MobGUI 窗口中，选择**IDE 中的 MobGUI 右键菜单**选项。这将使您能够在以后编辑 MobGUI 控件行为。
- en: Using the **Card Inspector**, set the name of this first card to Email.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**卡片检查器**，将此第一个卡片的名称设置为 Email。
- en: Drag a **TabBar** on the card window. Click on **Snap to bottom** of the card
    window. It will also resize the width of the card.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **TabBar** 拖动到卡片窗口中。单击卡片窗口的**底部对齐**。它也会调整卡片宽度。
- en: In the MobGUI window, drag a button in the card window on top of the TabBar.
    Duplicate the button 3 times by holding the *Alt*/*option* key and dragging it.
    Align the four buttons and distribute them across the card using LiveCode's **Align
    Tools** in the **Inspector** palette.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MobGUI 窗口中，将按钮拖动到卡片窗口顶部的 TabBar 上。通过按住 *Alt*/*option* 键并拖动来复制按钮 3 次。使用 LiveCode
    的**检查器**调色板中的**对齐工具**对四个按钮进行对齐，并将它们分布在整个卡片上。
- en: Select each button and set their names and labels to `Email`, `Browser`, `DatePicker`,
    and `Picture`. Then, resize the buttons so that they fit their name text appropriately.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个按钮，并将它们的名称和标签设置为`Email`、`Browser`、`DatePicker`和`Picture`。然后调整按钮的大小，使它们适合其名称文本。
- en: Select the **Email** button and choose **Object Script** from the **Object**
    menu or right-click on the button and choose the **Edit Script** option. The script
    will already look like the following screenshot:![Time for action – using MobGUI
    to make a test bed app](img/image00262.jpeg)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Email**按钮，并从**对象**菜单中选择**对象脚本**或右键单击按钮并选择**编辑脚本**选项。脚本将看起来像以下截图：![使用 MobGUI
    创建测试床应用程序的时间](img/image00262.jpeg)
- en: Add the following `mouseUp` handler to the script
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向每个卡片添加以下 `mouseUp` 处理程序
- en: '[PRE8]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can copy the mouseUp script of the first button and paste the script in
    the other three buttons. Note that there is a **preOpenControl** handler created
    by MobGUI following the mouseUp script in each of these buttons. Do not change
    that!
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将第一个按钮的 `mouseUp` 脚本复制并粘贴到其他三个按钮中。注意，MobGUI 在每个按钮的 `mouseUp` 脚本之后创建了一个 **preOpenControl**
    处理程序。不要更改它！
- en: We'll need these elements on all of the four cards we're going to make, so choose
    the **Select All** option and then choose **Group Selected** from the **Object**
    menu.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在将要制作的四个卡片上使用这些元素，所以选择**全选**选项，然后从**对象**菜单中选择**选择组**。
- en: Make sure that the group is selected and in the regular LiveCode Inspector palette,
    check the **Behave like a background** box.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保组已选择并位于常规 LiveCode 检查器调色板中，然后勾选**作为后台运行**复选框。
- en: Make three more cards and name them `Browser`, `DatePicker`, and `Picture`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另外三个卡片，并将它们的名称分别命名为`Browser`、`DatePicker`和`Picture`。
- en: From the LiveCode palette, drag a Label control on the card window for each
    of the four cards and set the name to match the card's name.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 LiveCode 调色板中，为每个卡片拖动一个标签控件到卡片窗口中，并将名称设置为与卡片名称匹配。
- en: In **Standalone Application Settings**, choose either iOS or Android, depending
    on the device you want to test on.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**独立应用程序设置**中，根据你想要测试的设备选择iOS或Android。
- en: Set the **Internal App ID** or **Identifier** to `com.yourname.MGTestBed`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**内部应用程序ID**或**标识符**设置为`com.yourname.MGTestBed`。
- en: If you're performing the same in iOS, make sure that you choose a profile from
    the Profile drop-down menu.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在iOS上执行相同的操作，请确保从“配置文件”下拉菜单中选择一个配置文件。
- en: You can now do a test from the **Development** menu, but first you have to choose
    either **iPhone Simulator** or your connected Android device.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以从**开发**菜单进行测试，但首先你必须选择**iPhone模拟器**或你的连接的Android设备。
- en: '*What just happened?*'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: It seemed like quite a few steps, but it doesn't take much time. We already
    have the navigation between the four cards and an authentic iOS-like interface.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有很多步骤，但实际上并不需要花费太多时间。我们已经有四个卡片之间的导航和一个真实的iOS界面。
- en: Let's get some of the test features going, but in a more native, integrated
    way than before.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以更原生、更集成的方式开始一些测试功能。
- en: MobGUI native controls
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MobGUI原生控件
- en: One powerful feature of MobGUI is that it can use ordinary LiveCode controls
    as placeholders for what will become native controls when you run the app on a
    device. This isn't something that you can't do for yourself with code, but being
    able to move placeholder controls around, until you like the layout, would save
    a lot of time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MobGUI的一个强大功能是它可以使用普通的LiveCode控件作为当你将应用运行在设备上时将成为本地控件的占位符。这不是你不能自己用代码做到的事情，但能够移动占位符控件，直到你满意布局，可以节省很多时间。
- en: Time for action – using native controls from MobGUI
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用MobGUI的本地控件
- en: MobGUI allows you to switch between the native control theme for iOS and Android
    or to redefine your own themes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: MobGUI允许你在iOS和Android的原生控件主题之间切换，或者重新定义你自己的主题。
- en: Right-click on the little image of the iPhone in the MobGUI window and make
    sure that you're on the Native iOS controls set.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MobGUI窗口中右键点击iPhone的小图标，确保你处于原生iOS控件集。
- en: Go to the Email card and drag 3 **Input** text controls from the MobGUI window
    and one **Multiline** text control.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往“电子邮件”卡片，从MobGUI窗口拖动3个**输入**文本控件和一个**多行**文本控件。
- en: Name the **Input** controls as `To`, `CC`, and `Subject` and the **Multiline**
    text control as `Body`. You can also add some regular LiveCode Label fields alongside
    the input fields as an indicator of what to enter. Size the Body field big enough
    to enter a few lines of text. Also, add some background color to the fields or
    the card so that the fields are seen properly.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**输入**控件命名为`To`、`CC`和`Subject`，将**多行**文本控件命名为`Body`。你还可以在输入字段旁边添加一些常规LiveCode标签字段，作为输入指示。将Body字段设置得足够大，以便输入几行文本。此外，给字段或卡片添加一些背景颜色，以便正确显示字段。
- en: As you make each field, note that you can set the keyboard type as well. Set
    it to Email for the To and CC fields.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建每个字段时，请注意，你可以设置键盘类型。将To和CC字段设置为电子邮件。
- en: From the iOS Controls 1 set, drag two buttons on the card window. Name one `Done`
    and the other `Send`. You should have a screenshot like this after this step:![Time
    for action – using native controls from MobGUI](img/image00263.jpeg)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从iOS控件1集中，将两个按钮拖到卡片窗口。将一个命名为`完成`，另一个命名为`发送`。完成此步骤后，你应该有一个这样的截图：![行动时间 – 使用MobGUI的本地控件](img/image00263.jpeg)
- en: 'When we test the app and touch one of the fields, the keyboard overlay appears.
    We''ll use the Done button as a way to hide the keyboard. Add a focus line to
    the `mouseUp` handler of the Done button script:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们测试应用并触摸其中一个字段时，键盘覆盖层会出现。我们将使用“完成”按钮来隐藏键盘。向“完成”按钮脚本的`mouseUp`处理程序添加一个焦点线：
- en: '[PRE9]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'MobGUI can retrieve properties from these native fields using the `mgText`
    property. Change the Send button''s `mouseUp` handler to use this property for
    each field and also, to call the `revMail` function:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobGUI可以使用`mgText`属性从这些原生字段检索属性。将发送按钮的`mouseUp`处理程序更改为使用此属性为每个字段，并调用`revMail`函数：
- en: '[PRE10]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Go to the Browser card.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往浏览器卡片。
- en: From the MobGUI window, drag a **Input** control to the card window and name
    it `URL`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从MobGUI窗口，将一个**输入**控件拖到卡片窗口，并将其命名为`URL`。
- en: Drag a **Browser** control to the card window and name it `Page`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**浏览器**控件拖到卡片窗口，并将其命名为`Page`。
- en: Adjust the sizes so that the text field fills the width of the card and the
    browser control fills the area between the text field and the tab bar at the bottom.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整大小，使文本字段填满卡片宽度，浏览器控件填满文本字段和底部标签栏之间的区域。
- en: Select the **Browser** control and in the MobGUI window, enter a value for **URL**
    or use the default one already there. This will make the browser control load
    this URL as its first page.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **浏览器** 控件，并在 MobGUI 窗口中输入 **URL** 的值或使用默认值。这将使浏览器控件将其作为第一个页面加载此 URL。
- en: 'Edit the script of the URL text field and add this handler, which looks for
    a Return key to go to the URL:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 URL 文本字段的脚本，并添加此处理程序，该处理程序查找回车键以转到 URL：
- en: '[PRE11]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try another test and go to the Email and Browser cards to see them in action.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试另一个测试，并转到“电子邮件”和“浏览器”卡片，看看它们在实际中的应用。
- en: '*What just happened?*'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We recreated the first two tests from our earlier test bed app, only now, it
    looks a lot nicer! Also, we made use of MobGUI's ability to get and set data in
    native iOS controls, in this case, using the `mgText` property and `mobileControlSet`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新创建了早期测试床应用程序中的前两个测试，但现在看起来好多了！此外，我们还利用了 MobGUI 在原生 iOS 控件中获取和设置数据的能力，在这种情况下，使用
    `mgText` 属性和 `mobileControlSet`。
- en: Note that all MobGUI controls show up as **groups** in the LiveCode Inspector
    and as **Custom controls** in the Project Browser. These groups are made of customized
    LiveCode controls such as buttons, fields, and so on. MobGUI also adds a MobGUI
    card to the end of your stack. This card includes invisible buttons that have
    behaviors defined. Behaviors are methods to create common functionality between
    objects without duplicating the scripts. You can view these behavior scripts by
    clicking on the script button on the right-hand side of the Project Browser, when
    you display the MobGUI card. Unless you have a specific need to change these,
    just leave them alone.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有 MobGUI 控件在 LiveCode 检查器中显示为 **组**，在项目浏览器中显示为 **自定义控件**。这些组由自定义 LiveCode
    控件（如按钮、字段等）组成。MobGUI 还会在您的堆栈末尾添加一个 MobGUI 卡片。此卡片包括具有定义行为的不可见按钮。行为是创建对象之间常见功能的方法，而不重复脚本。您可以通过在项目浏览器中显示
    MobGUI 卡片时点击右侧的脚本按钮来查看这些行为脚本。除非您有特定的需求要更改这些，否则请保持它们不变。
- en: Have a go hero – other tests and pretty icons
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试 - 其他测试和漂亮的图标
- en: Go ahead and add the other two tests to the stack in the same manner as we did
    in the *Time for action* sections earlier in this chapter. For the `DatePicker`
    example, you could examine the **Dictionary** definition for `iPhonePickDate`
    to see examples of how to use the picked date data in the same manner as the previous
    sections for example, adjustments for different screen sizes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章前面“行动时间”部分中所述的方式，将其他两个测试添加到堆栈中。对于 `DatePicker` 示例，您可以检查 **字典** 中的 `iPhonePickDate`
    定义，以查看如何使用选择日期数据的方式，例如，根据不同屏幕大小进行调整。
- en: So far, we have tested the size using the Portrait orientation with just an
    iPhone. You may want to use the same stack for iPhone and iPad or perhaps, iPad
    and an Android tablet, which have quite different aspect ratios.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用纵向方向和仅 iPhone 测试了大小。您可能希望使用相同的堆栈用于 iPhone 和 iPad，或者可能是 iPad 和 Android
    平板，它们的纵横比相当不同。
- en: Even if you just stick with the iPhone, you would still want to take care of
    Portrait and Landscape. We therefore, have to find ways to arrange the many controls
    on the card, so that they look their best on each screen size and orientation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您只是坚持使用 iPhone，您也仍然需要考虑纵向和横向。因此，我们必须找到方法来安排卡片上的许多控件，以便它们在每个屏幕尺寸和方向上看起来都最好。
- en: There are several ways to achieve this. First, we'll look at how to use a resize
    handler.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这一点。首先，我们将看看如何使用调整大小处理程序。
- en: Laying out using a resize handler
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调整大小处理程序进行布局
- en: When a stack's window size changes, LiveCode sends a `resizeStack` message that
    we can trap in order to rearrange controls for the new width and height.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当堆栈的窗口大小改变时，LiveCode 会发送一个 `resizeStack` 消息，我们可以捕获它以重新排列控件以适应新的宽度和高度。
- en: Time for action – a simple code layout example
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 简单的代码布局示例
- en: It could get quite complicated if you did lay out all of the card's controls
    with code, so we're only going to construct a simple case to show the technique.
    You can enhance this later for more complex cases.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用代码来布局卡片的全部控件，可能会变得相当复杂，所以我们只构建一个简单的案例来展示技术。您可以在以后为更复杂的情况进行增强。
- en: Create a new Mainstack.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的主堆栈。
- en: Add four buttons across the width of the card.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在卡片宽度上添加四个按钮。
- en: 'Put this handler in the card script:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此处理程序放入卡片脚本中：
- en: '[PRE12]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Resize the card window. The buttons should spread out evenly across the card.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整卡片窗口的大小。按钮应该在卡片上均匀分布。
- en: Go to **Standalone Application Settings** and select the iOS option.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **独立应用程序设置** 并选择 iOS 选项。
- en: Make sure that the supported devices include iPad.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保支持的设备包括iPad。
- en: Set the orientation options to include all the four orientations.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方向选项设置为包括所有四种方向。
- en: From the **Development** menu, set the **Test Target** as the **iPad Simulator**
    and perform a Test.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**开发**菜单中，将**测试目标**设置为**iPad 模拟器**并执行测试。
- en: In the simulator, choose either **Rotate Left** or **Rotate Right** from the
    **Hardware** menu.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器中，从**硬件**菜单中选择**向左旋转**或**向右旋转**。
- en: The buttons should spread themselves out across the screen in both the portrait
    and landscape orientation.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮应该在纵向和横向两种方向上均匀分布在屏幕上。
- en: '*What just happened?*'
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In addition to making a simple example of how the `resizeStack` handler can
    be handled, we also saw that the changes in orientation also send the `resizeStack`
    message.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了展示如何处理`resizeStack`处理器的简单示例外，我们还看到方向的变化也会发送`resizeStack`消息。
- en: Laying out using the LiveCode Geometry Manager
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LiveCode几何管理器进行布局
- en: 'While a control is selected on the card, the Inspector palette has an entry
    named Geometry. It''s a somewhat strange interface! Let''s take a look:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当在卡片上选择一个控件时，检查器面板中有一个名为几何的条目。这是一个有些奇怪的界面！让我们看看：
- en: '![Laying out using the LiveCode Geometry Manager](img/image00264.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![使用LiveCode几何管理器进行布局](img/image00264.jpeg)'
- en: These faint horizontal and vertical bars are used to select whether you want
    the control to be scaled or positioned by a fixed amount or relative amount. That
    is, if a button is 100 pixels from the right of the card window and if you select
    the position a fixed amount away, then as you resize the card window, the button
    will remain 100 pixels away from the right edge of the window. If, on the other
    hand, you use the relative setting and the button is 80 percent across the card
    window, it will still be 80 percent across the window after you have resized it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些微弱的水平和垂直条用于选择您是否希望控件通过固定量或相对量进行缩放或定位。也就是说，如果一个按钮距离卡片窗口的右侧100像素，并且您选择从固定量进行定位，那么当您调整卡片窗口大小时，按钮将保持在窗口右侧100像素的位置。另一方面，如果您使用相对设置，并且按钮占据卡片窗口的80%，那么在调整大小后，它仍然占据窗口的80%。
- en: The first click on one of these bars will make it turn solid red in color and
    this indicates that it's a fixed amount away from the edge of the card. If you
    click on it again, it takes the shape of a red waveform, indicating that it's
    going to be relative.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些条中点击第一个会使它变成实心红色，这表示它距离卡片边缘的固定量。如果您再次点击它，它将呈现红色波形形状，表示它将是相对的。
- en: In the screenshot, you can see that the selected button is set to a fixed amount
    from the bottom of the card and a relative amount from the right of the card.
    The image also shows the scaling settings for the control.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，您可以看到选定的按钮设置为从卡片底部固定量，从卡片右侧相对量。图像还显示了控件的缩放设置。
- en: Note that an object can also be positioned relative to other objects. Refer
    to the **Right object** and **Bottom object** pop-up selectors in the preceding
    screenshot.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个对象也可以相对于其他对象进行定位。参考前面截图中的**右侧对象**和**底部对象**弹出选择器。
- en: Time for action – using the Geometry Manager to position buttons
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用几何管理器定位按钮
- en: 'We''ll add some buttons to the stack that we are currently working on:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向当前正在工作的堆栈中添加一些按钮：
- en: Take the first four buttons and duplicate them to get another set of four buttons
    below the previous ones.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出前四个按钮并复制它们以获得另一组四个按钮，位于前面的按钮下方。
- en: Select the first of the new buttons and in the **Geometry** section of the Inspector
    palette, click once on the vertical bar and twice on the horizontal bar; you will
    end up with the state shown in the previous screenshot.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新按钮中的第一个，并在检查器面板的**几何**部分中，点击一次垂直条和两次水平条；您将得到前面截图中显示的状态。
- en: Do the same for the other three buttons.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其他三个按钮也进行相同的操作。
- en: Try resizing the card window.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试调整卡片窗口的大小。
- en: '*What just happened?*'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: That was quite a quick test, and if all went well, you will see that resizing
    the card window includes positioning the first four buttons using the `resizeStack`
    handler that we added, and it's positioning of the second set of four buttons
    using the Geometry Manager. With the settings we used, the results should be much
    the same, except that the second set of four buttons will remain a fixed distance
    away from the bottom of the card window.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次相当快的测试，如果一切顺利，你会发现调整卡片窗口大小包括使用我们添加的`resizeStack`处理程序定位前四个按钮，以及使用几何管理器定位第二组四个按钮。使用我们使用的设置，结果应该非常相似，只是第二组四个按钮将保持与卡片窗口底部的固定距离。
- en: There is a lot of power in the Geometry Manager and you should take a look at
    the other abilities it has at the reference link shown at the end of this chapter.
    However, it is not the best way to deal with mobile screen sizes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 几何管理器有很多功能，你应该查看本章末尾所示参考链接中的其他能力。然而，它并不是处理移动屏幕尺寸的最佳方式。
- en: Resolution independence
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分辨率独立性
- en: LiveCode 6.5, and beyond…
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode 6.5，以及更远…
- en: One of the features listed in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. LiveCode
    Fundamentals"), *LiveCode Fundamentals*, has already been developed and is present
    in LiveCode 6.5\. The new feature is Resolution Independence.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0016.xhtml#aid-F8901 "第1章。LiveCode基础知识")中列出的功能之一，*LiveCode基础知识*，已经被开发出来，并存在于LiveCode
    6.5中。新功能是分辨率独立性。
- en: Now, after seeing the two complex ways of adjusting the screen size, you may
    be able to forget all of it. In LiveCode 6.5, a new feature called Resolution
    Independence was introduced, and the correct use of this feature will make many
    of the layout difficulties go away.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在看到调整屏幕大小的两种复杂方法之后，你可能能够忘记所有这些。在LiveCode 6.5中，引入了一个名为“分辨率独立性”的新功能，正确使用此功能将使许多布局困难消失。
- en: 'There are two approaches in place to help you deal with different device sizes
    and aspect ratios: the Multiple Density Support and the Full Screen Scaling Mode.
    Some of the concepts are a little tricky, but a few screenshots will hopefully
    make them clear!'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，为了帮助您处理不同的设备尺寸和纵横比，有两种方法可供选择：多密度支持和全屏缩放模式。其中一些概念有点棘手，但一些截图可能会希望使它们变得清晰！
- en: Multiple density support
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多密度支持
- en: 'So far in this chapter, we overlooked the issue of the **DPI** (**dots per
    inch**) of devices. For Android devices, there are hundreds of different resolutions
    and DPI values. With iOS, there are only a few variations of DPI and resolution.
    The simplest these problem cases to examine, is where you want the same app to
    look like and work in the same manner as iPhone 3GS and iPhone 4 Retina or later
    versions of iPhones. Both have the same size screen, but iPhone 4''s retina display
    has twice the DPI. This URL shows you the difference between all the current iPhones:
    [http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions](http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们忽略了设备**DPI**（每英寸点数）的问题。对于Android设备，有数百种不同的分辨率和DPI值。对于iOS，只有几种DPI和分辨率的变体。最简单的问题案例是，你希望同一个应用在iPhone
    3GS和iPhone 4 Retina或更晚的iPhone版本上看起来和工作方式相同。它们都有相同大小的屏幕，但iPhone 4的视网膜显示屏的DPI是两倍。这个URL显示了所有当前iPhone之间的差异：[http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions](http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions)。
- en: With the MobGUI and Geometry Manager solution, you are effectively storing layout
    values or instructions behind the scenes that are ready to adapt to the user's
    device screen size. The Multiple Density Support in LiveCode 6.5 is an easier
    way to solve this issue.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MobGUI和几何管理器解决方案，你实际上是在幕后存储布局值或指令，这些值或指令准备适应用户的设备屏幕大小。LiveCode 6.5中的多密度支持是解决此问题的更简单方法。
- en: Pixels and points
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像素和点
- en: A pixel is an illuminated dot in an image or of a screen, whereas a point is
    a unit of measurement in print, generally, 1/72nd of an inch. If a screen has
    exactly 72 DPI, the two would be the same, and in the earlier days of Macintosh
    computers, this was pretty much the case. More modern Macs and PCs and most mobile
    devices are a lot more detailed than 72 DPI. With LiveCode 6.5, and its later
    versions, you can now make a stack that works in points, that will then fill the
    device screen by taking the image of each card and by applying a scaling factor
    to it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 像素是图像或屏幕上的发光点，而点是在印刷中的度量单位，通常为1/72英寸。如果一个屏幕的DPI正好是72，那么这两个就是相同的，在Macintosh计算机的早期日子里，这几乎是事实。更现代的Mac和PC以及大多数移动设备都比72
    DPI详细得多。在LiveCode 6.5及其后续版本中，您现在可以创建一个以点为单位工作的堆栈，然后通过将每个卡片上的图像和缩放因子应用到它来填充设备屏幕。
- en: While doing such scaling, something must be assumed to be of natural size. For
    iOS, LiveCode uses non-Retina screens as a scale factor of 1X and Retina screens
    are a scale factor of 2X. iPhone 5 and 6 introduced more sizes. A scale factor
    of 3X is required for iPhone 6 Plus. With Android, things are more complicated
    as it has at least seven levels of scaling factor.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此类缩放时，必须假设某些内容为自然尺寸。对于iOS，LiveCode使用非Retina屏幕作为1X缩放因子，而Retina屏幕的缩放因子为2X。iPhone
    5和6引入了更多尺寸。iPhone 6 Plus需要3X缩放因子。对于Android，事情更为复杂，因为它至少有七个缩放因子级别。
- en: In fact, really, there are an infinite number of scaling factors going on behind
    the scenes. However, you generally don't have to worry about them because LiveCode
    automatically gives you the ability to show different versions of an image depending
    on the DPI of the device in question.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，幕后正在进行无限多的缩放因子。然而，您通常不必担心它们，因为LiveCode自动为您提供根据所讨论设备的DPI显示不同图像版本的能力。
- en: Image naming convention
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像命名约定
- en: 'LiveCode will look at the file names of the included images (that have been
    added in the **Copy Files** part of the **Standalone Application Settings** dialog)
    and will load in the appropriately named version of the image. In the example
    shown here, two images have been added, `icon.png` and `icon@2x.png`. To make
    it easier to spot which one you are seeing, 512 and 1024 have been added to what
    would otherwise be two resolutions of the same icon:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode将检查包含的图像文件名（在**独立应用程序设置**对话框的**复制文件**部分中添加的），并将加载相应命名的图像版本。在此示例中，已添加了两个图像，`icon.png`和`icon@2x.png`。为了更容易地识别您看到的是哪一个，512和1024已添加到本应相同的图标两个分辨率：
- en: '![Image naming convention](img/image00265.jpeg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图像命名约定](img/image00265.jpeg)'
- en: This image is slightly magnified here to help you see that the 512 version of
    the image is lower resolution than the 1024 version.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像略有放大，以帮助您看到512版本的图像分辨率低于1024版本。
- en: 'The names used for iOS are:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: iOS使用的名称是：
- en: '`imagename.ext` (for example, `flowers.png`)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename.ext`（例如，`flowers.png`）'
- en: '`imagename@2x.ext` (for example, `flowers@2x.png`)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename@2x.ext`（例如，`flowers@2x.png`）'
- en: '`imagename@3x.ext` (for example, `flowers@3x.png`) for iPhone 6 Plus'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename@3x.ext`（例如，`flowers@3x.png`）用于iPhone 6 Plus'
- en: The first one is considered as the 1X scaled version and the `@2x` name is considered
    as the 2X scaled version and the same goes for the `@3x` version.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个被认为是1X缩放版本，而`@2x`名称被认为是2X缩放版本，`@3x`版本也是如此。
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you also need to specify the appropriate **Splash Screen** files in
    the LiveCode **Standalone Application Settings**. Otherwise, the iPhone will use
    lower resolution images. This can be verified by examining the `screenRect` of
    the device. Even though iPhone 6 Plus has a physical resolution of 1080 x 1920,
    use the 3x image sizes of 1242 x 2208\. The phone automatically downsizes the
    image. 2x images will be displayed fine on iPhone 6.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还需要在LiveCode**独立应用程序设置**中指定适当的**启动屏幕**文件。否则，iPhone将使用较低分辨率的图像。这可以通过检查设备的`screenRect`来验证。尽管iPhone
    6 Plus的物理分辨率为1080 x 1920，但应使用1242 x 2208的3x图像尺寸。手机会自动调整图像大小。2x图像在iPhone 6上显示良好。
- en: 'The names and scaling factors used for Android are more varied:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用的名称和缩放因子更为多样：
- en: '`imagename@ultra-low.ext - 0.25X`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename@ultra-low.ext - 0.25X`'
- en: '`imagename extra-low.ext - 0.5X`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename extra-low.ext - 0.5X`'
- en: '`imagename low.ext - 0.75`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename low.ext - 0.75`'
- en: '`imagename medium.ext - 1X`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename medium.ext - 1X`'
- en: '`imagename high.ext - 1.5X`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename high.ext - 1.5X`'
- en: '`imagename@extra-high.ext - 2x`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename@extra-high.ext - 2x`'
- en: '`imagename@ultra-high.ext - 4x`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagename@ultra-high.ext - 4x`'
- en: In actual practice, you may find that you only need two or three versions of
    an image to make an image look good enough on a wide range of DPI devices.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，您可能会发现您只需要两三个版本的图像就能在广泛范围的DPI设备上使图像看起来足够好。
- en: The full-screen scaling mode
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全屏缩放模式
- en: Prior to LiveCode 6.5 and its multiple density support, you had to do all the
    hard work by yourself! At least now you can design for just iPhone or iPad and
    have Retina versions of these devices looked after by LiveCode. With Android though,
    you still need to have a variety of layouts or alternately, have code that would
    position the interface elements based on the aspect ratio and pixel dimensions
    of the device.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在LiveCode 6.5及其多密度支持之前，您必须自己完成所有艰苦的工作！至少现在您可以为iPhone或iPad进行设计，并且LiveCode会负责这些设备的Retina版本。然而，对于Android，您仍然需要拥有多种布局，或者有代码可以根据设备的宽高比和像素尺寸定位界面元素。
- en: 'With the density support, you only have to take care of the aspect ratio, but
    there are still a lot of these to be taken care of. For utility-like applications,
    you will most likely have to go to this trouble, so that users get the expected
    experience. However, there are many types of applications that are more graphical
    and that can take advantage of the full screen scaling modes: `empty`, `exactFit`,
    `showAll`, `noBorder`, and `noScale`. Let''s take a look at what these are…'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密度支持，您只需要注意宽高比，但仍有许多此类问题需要处理。对于类似工具的应用程序，您很可能会遇到这种麻烦，以便用户获得预期的体验。然而，有许多类型的应用程序更加图形化，可以利用全屏缩放模式：`empty`、`exactFit`、`showAll`、`noBorder`和`noScale`。让我们看看这些是什么……
- en: Syntax
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法
- en: 'The general syntax, by the way, is to type this in your stack script:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，一般的语法是在您的堆栈脚本中输入以下内容：
- en: '[PRE13]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The quotes are required for the four active modes. The empty mode does not need
    quotes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四个活动模式，需要使用引号。空模式不需要引号。
- en: The empty mode
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空模式
- en: If **fullscreenmode** is **empty**, the card area is changed to match the device
    screen. That is, the top left card is in the top-left corner of the device screen
    and the card width and height match the actual pixel width and height of the device.
    Well, except if you have taken advantage of the multiple density support discussed
    earlier! Essentially, empty is the existing behavior in the earlier versions of
    LiveCode.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**fullscreenmode**是**empty**，则卡片区域将改变以匹配设备屏幕。也就是说，左上角的卡片位于设备屏幕的左上角，卡片的宽度和高度与设备的实际像素宽度和高度相匹配。嗯，除非您已经利用了前面讨论过的多密度支持！本质上，empty是LiveCode早期版本中的现有行为。
- en: The showAll mode
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: showAll模式
- en: 'This mode arrived slightly later than the other modes and is present in LiveCode
    6.6 and its later versions. With **showAll**, as the `fullscreenmode`, the card''s
    contents will be scaled, so that all of it is within the device''s screen. For
    devices that have a different aspect ratio than your card, elements that were
    outside of the card area are revealed. Suppose you create a graphical book app
    where you want the full height of the card to exactly fill the height of the device
    screen, but you don''t want black bars down the sides on a wider device, then
    you could extend the background pattern beyond the left- and right-hand side of
    the card area. On a narrower device, such as iPad, you would see the 4:3 area
    of the card. On a wider device, say iPhone 5, the extra background would be revealed.
    The following illustration shows which area of the background image will be seen
    on different devices:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式比其他模式稍晚出现，存在于LiveCode 6.6及其后续版本中。使用**showAll**，作为全屏模式，卡片的内容将被缩放，以便所有内容都显示在设备屏幕内。对于与您的卡片具有不同宽高比的设备，卡片区域外的元素将被显示出来。假设您创建了一个图形书应用，希望卡片的全部高度正好填满设备屏幕的高度，但您不希望在较宽的设备上出现黑色边框，那么您可以将背景图案扩展到卡片区域的左右两侧。在较窄的设备上，例如iPad，您将看到4:3的卡片区域。在较宽的设备上，例如iPhone
    5，将显示额外的背景。以下插图显示了在不同设备上可以看到的背景图像区域：
- en: '![The showAll mode](img/image00266.jpeg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![showAll模式](img/image00266.jpeg)'
- en: The letterbox mode
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信封模式
- en: The **letterbox** mode is identical to **showAll** except that the areas beyond
    the card area are hidden and leave you with the typical movie letterbox effect,
    hence the name!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**letterbox**模式与**showAll**相同，除了卡片区域之外的区域被隐藏，并留下典型的电影信封效果，因此得名！'
- en: The noBorder mode
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无边框模式
- en: 'The **noBorder** mode is very useful, but takes some time to get used to. Let''s
    say you are making a graphical adventure game, along the lines of Myst, and you
    want to use the same graphics for all devices. You could create a scene that has
    an aspect ratio of 14:9 and make sure that the important content is not too close
    to the edges. When the scene is viewed in the `noBorder` mode on an iPad, you
    would see the full height of the scene and most of the width. When viewed on iPhone
    5, you would see the full width of the scene and most of the height. As the name
    suggests, the card area would be scaled, so that there are no borders, as there
    would be in the letterbox mode. The following illustration shows which areas of
    an original 14:9 photograph would be visible for a 4:3 iPad and a 16:9 iPhone:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**noBorder**模式非常有用，但需要一些时间来适应。假设你正在制作一款图形冒险游戏，类似于Myst，并且你希望所有设备都使用相同的图形。你可以创建一个宽高比为14:9的场景，并确保重要内容不要离边缘太近。当场景在iPad上的**noBorder**模式下查看时，你会看到场景的完整高度和大部分宽度。当在iPhone
    5上查看时，你会看到场景的完整宽度和大部分高度。正如其名所示，卡片区域将被缩放，因此没有边框，就像信封模式中会有边框一样。以下插图显示了原始14:9照片的哪些区域对于4:3的iPad和16:9的iPhone是可见的：'
- en: '![The noBorder mode](img/image00267.jpeg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![The noBorder mode](img/image00267.jpeg)'
- en: The exactFit mode
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**exactFit**模式'
- en: As the name implies, **exactFit** would take the card's content and squish it
    to fill the device's screen. It's hard to think of a use case for this mode, but
    perhaps, if you perform some sort of artistic visualizer, the squishing wouldn't
    matter much!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**exactFit**会将卡片内容挤压以填充设备的屏幕。很难想到这个模式的使用场景，但也许如果你执行某种艺术视觉化，挤压就不会很重要了！
- en: Note
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As mentioned previously, the Geometry Manager has a lot of powerful features.
    If your interest is also in desktop applications, take a look at the lesson at:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，几何管理器有很多强大的功能。如果你的兴趣也在桌面应用程序上，请查看以下课程：
- en: '[http://lessons.runrev.com/s/lessons/m/4067/l/19026-Geometry-Manager](http://lessons.runrev.com/s/lessons/m/4067/l/19026-Geometry-Manager)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://lessons.runrev.com/s/lessons/m/4067/l/19026-Geometry-Manager](http://lessons.runrev.com/s/lessons/m/4067/l/19026-Geometry-Manager)'
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The trick with easy-to-use tools, such as LiveCode, is to create mobile apps
    that users think were created with the hard-to-use native tools, such as Xcode.
    You can achieve this because of LiveCode's ability to call upon native features
    and because you can make interfaces that look appropriate.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用易于使用的工具，例如LiveCode，的技巧是创建用户认为是用难以使用的原生工具，如Xcode，制作的移动应用。你可以实现这一点，因为LiveCode能够调用原生功能，并且你可以制作看起来合适的界面。
- en: In this chapter, we covered several ways to achieve this goal by calling native
    OS features using simple LiveCode commands. We prepared images to be used for
    button states and made buttons that look OS-specific by adding these images. We
    also created controls that look like iOS native controls with MobGUI and laid
    out the interface with code, with the Geometry Manager.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用简单的LiveCode命令调用原生OS功能，介绍了实现这一目标的几种方法。我们准备了用于按钮状态的图像，并添加了这些图像来制作看起来具有OS特定风格的按钮。我们还使用MobGUI创建了看起来像iOS原生控件的控制，并使用代码和几何管理器布局了界面。
- en: So far, these have all been small test stacks to get us warmed up! Next, we're
    going to look at the general application structure to make a fully fleshed out
    utility application.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些都是一些小测试堆栈，让我们热身！接下来，我们将查看通用应用程序结构，以制作一个完整的功能应用程序。
