- en: Chapter 3. Building User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So many different screens!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*When making utility or game applications for desktop computers, you can often
    get away with having a particular sized window for which you can make custom graphics
    that exactly fit. With mobile devices, you have to cope with a wide range of screen
    sizes and aspect ratios and also have to interface elements that look correct
    for the operating system on the user''s device.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'LiveCode is capable of publishing on Mac, Windows, and Linux and goes some
    way toward solving the difficulty of making interface elements look right for
    each platform. The **View** menu has a **Look and Feel** menu item where you can
    choose between **Native Theme**, **Mac OS Classic**, **Windows 95**, and **Motif**.
    The same isn''t true for mobile operating systems as all controls look like Motif.
    You still have two choices though: you can create graphics that look like they
    belong in your target OS, or you can call native routines in order to let the
    system itself present the appropriate controls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a *test bed* mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open an e-mail and browser windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show a date picker control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load pictures from the library and camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an iOS styled button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually lay out an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use code to lay out an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at a powerful mobile interface control's add-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a test bed mobile app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a proving ground for the things we're going to try, we'll set up a single
    mobile app that has multiple screens, one for each of the things we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: What should we call the test bed app? We could call it almost anything, but
    we'll let the iPhone make the decision for us. On the iPhone and iPod touch, there
    is only a small amount of space under the home screen icons for the name to appear.
    iOS will take your nice long app name and show a shortened version of the name,
    using ellipses to concatenate the ends of the name together. My super duper app
    will appear as My sup…app, not quite as informative! The number of letters that
    can appear without the text being truncated will vary depending on the width of
    the letters used, but typically, it has a limit of 11 letters. So, we will call
    the test bed app LC Test Bed, which is exactly 11 letters!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the test bed stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we create the iOS and Android apps, we should get what we want ready,
    as a LiveCode stack and fully test it on our desktop computers. The following
    steps are going to assume that you know how to do what is asked in LiveCode, without
    precise instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Open LiveCode, create a new **Mainstack**, and save it as `LCTestBed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the screen size to 320 x 480\. This is just to make sure that things appear
    on the smallest of screens. The things we will make, will appear at the upper-left
    corner area of the larger screens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to make a button for each card in the stack; let's start by making
    a card named **Menu**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add buttons for **Email**, **Browser**, **DatePicker**, and **Picture**. Make
    sure that the buttons are big enough to touch on your devices. You should have
    something like what is shown here:![Time for action – making the test bed stack](img/image00255.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create four new cards and name each one so that they match the button names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back at the first card, set the script of each button to go to the matching
    cards with this script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On each card, create a button to return to the Menu card. Name the button `Menu`.
    Set its script to the same as the other buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Run (browse) tool and try clicking on the buttons to jump to the
    four cards and back to the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, nothing too exciting! However, you should now have five cards and the
    ability to go in and out of the Menu card. We're going to add scripts to each
    card to help illustrate its various features. The most efficient approach will
    be to add all the scripts and related buttons and fields and then to test the
    final test bed app in one go. However, where's the fun in that! Instead, we'll
    go one feature at a time…
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the desktop e-mail application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many cases where you may want to hear from the users of your applications.
    Perhaps, you want them to e-mail suggested improvements or to ask you questions.
    You could easily launch their e-mail program and leave the user to figure out
    what to write. Alternately, you could set the **To** address, **Subject**, and
    even some of the **Body** of the message. At the very least, it would make your
    life easier because you could filter incoming e-mails based on something that
    you placed in the Subject field.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – calling the native e-mail application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps we''ll make some fields and a button to try sending
    an e-mail feature:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Email** card and create four fields. Name them **To**, **CC**, **Subject**,
    and **Body**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a button named **Test**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Test** button, add this script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the **Run** tool and type in example information in each of the fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting up the **Standalone Application Settings…** and selecting the
    **Test Target**, click on the **Test** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One neat thing about the LiveCode syntax is that the code for mobile also works
    for desktop applications and vice versa. All being well, when you click on the
    Test button, you will find yourself in your default e-mail application ready to
    send the message that you had entered in the LiveCode stack fields.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the e-mail test on devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's no great surprise that the desktop test worked. The ability to open other
    applications is the basic feature of LiveCode. Still, it's neat to send over some
    initial text for the new message to take on. Next, we should check whether this
    works on devices too.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – trying the test bed stack on devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connect your Android and/or iOS device to your computer using USB. These instructions
    are almost the same as in the previous chapter, when we tested a "Hello World"
    stack. After this point, any directions will be briefer and based on the assumption
    that you know the steps needed to test an app on your device. [Chapter 7](part0093.xhtml#aid-2OM4A2
    "Chapter 7. Deploying to Your Device"), *Deploying to Your Device*, describes
    all the options in the **Standalone Applications Settings** dialog. For the moment,
    we''re only going to fill in a few details, so here, we will just view a portion
    of the dialog, starting with the Android settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – trying the test bed stack on devices](img/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure that **Android** is checked in the **Standalone Application Settings**
    dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Identifier** field, type in an identifier that will be unique; `com.yourname.lctestbed`
    would do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get your device to its home screen past the initial lock screen if there is
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In LiveCode, choose **Development/Test Target** and select your Android device.
    It will be named as **Android** followed by a long number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Development/Test** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After compilation, the stack should run on your Android device and you should
    be able to touch the **Email** button and perform a test message that will use
    the Android e-mail application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On iOS, if you haven''t already done so, read [Chapter 7](part0093.xhtml#aid-2OM4A2
    "Chapter 7. Deploying to Your Device"), *Deploying to Your Device*, on how to
    deploy to your device. At least read the parts that show you how to install your
    iOS developer certificates and provisioning files. As with Android, we''re only
    going to alter a couple of items in the Standalone Application Settings. The following
    is the screenshot of the dialog that we''ll be altering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – trying the test bed stack on devices](img/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Perform the following steps for an iOS device:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the **Standalone Application Settings** to **iOS**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Basic Application Settings** of the iOS settings is a **Profile** drop-down
    menu of the provisioning files that you have installed. Choose the one that is
    configured for the device you are going to test the app on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Internal App ID** field, type in a unique ID. As with Android, `com.yourname.lctestbed`
    would do. `yourname` would of course be your name or your company name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are testing on iPad, select the **iPod, iPhone and iPad** option from
    the **Supported Devices** drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the dialog and choose **Save as Standalone Application…** from the **File**
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the saving is done, you may see a warning message telling you about missing
    splash screens and icons. It won't matter for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Finder**, locate the folder that was just created and open it to reveal
    the app file itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Xcode** and choose **Devices** from the **Window** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see your device listed. Select it and if you see a button labeled
    **Use for Development**, click on that button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the app file straight from the **Finder** window to your device in the
    **Organizer** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The small colored circle next to the device will turn orange for a moment and
    then back to green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now open the app and try the **Email** button and test message, which
    will use the standard iOS Mail application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We went through the steps needed to install the test bed app on both Android
    and iOS devices. We also had to change a couple of things in the standalone application
    settings. As you saw, there are quite a lot of settings in there. You can look
    forward to learning about them all in [Chapter 7](part0093.xhtml#aid-2OM4A2 "Chapter 7. Deploying
    to Your Device"), *Deploying to Your Device*!
  prefs: []
  type: TYPE_NORMAL
- en: Opening a web page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another requirement in your applications is being able to present additional
    online information. You want the user to click on a link, or touch as the case
    may be, so that he/she is taken to a page that lists all the other applications
    that the user can buy from you!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – calling the native browser application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This next test will go faster, or at least, the instructions will be briefer,
    as we will condense some of the steps in more concise directions, as given here:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the **Test** button on the **Email** card and paste it on the **Browser**
    card, just to save you some time making the button look nice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the **Test** button script and change it to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose the **Run** tool and click on the **Test** button. You will see the RunRev
    home page in your default browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The steps for trying the app on devices is exactly the same as with the steps
    to test the e-mail feature. For Android:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Android in the **Standalone Application Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your Android device as the test target from the **Development** menu
    (most likely, it will still be selected from before).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Test** from the **Development** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previous test of the app will be overwritten and the new version will be
    launched automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try clicking on the **Browser** button and the **Test** button that you just
    created on the Browser card. The [http://runrev.com/](http://runrev.com/) page
    should be opened if you click on them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: Select iOS in the standalone application settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redo **Save as Standalone Application** and then drag the app file on your device
    in the **Organizer** window of Xcode, as you did the first time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try the **Browser** and **Test** buttons; you should see that the RunRev home
    page has opened inside Safari.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the Email test, adding the standard code to open a web page works for
    Android and iOS just as it does for a desktop computer.
  prefs: []
  type: TYPE_NORMAL
- en: If you are testing on both Android and iOS, you will notice that the behavior
    is different when you return after looking at a web page. With Android, you can
    press the back arrow button and still be on the Browser card of your stack. With
    iOS, the stack is restarted when you return. We will examine a solution later,
    where we write data to an external file, so that when the app is reopened, we
    can return the user before leaving the app.
  prefs: []
  type: TYPE_NORMAL
- en: The mobile-only date picker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next couple of examples we will try are the ones that only work on mobile
    devices and not on desktop computers.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying a date picker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many applications require the user to choose a date for an event, and with
    mobile devices, there is a particular look to the date picker that you are shown.
    Using LiveCode let''s us display such a control:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the **Test** button from the Browser card and paste it on the DatePicker
    card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script to make it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the **Run** tool and try the **Test** button. You'll see an error because
    this is a mobile-only feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a change, select **iPhone** or **iPad Simulator** from the **Development/Test
    Target** menu and then choose **Test** from the **Development** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see your stack open in the iOS simulator and you can try the **DatePicker**
    and **Test** buttons to then see the iOS date picker displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the same old Save As and install using the Organizer window steps to
    try the date picker on your iOS device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Touch the **DatePicker** button on the menu card and the **Test** button on
    the Datepicker card. An iOS native date picker should appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully, you're getting better and are able to build and install mobile apps
    faster by now! In addition to testing again on a device, we also tried out the
    simulator. Generally speaking, it is faster to use the iOS simulator whenever
    you can, and only test on a device when you're checking things such as multi-touch,
    accelerometer, and camera support.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – loading pictures for a mobile device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe one day it will be possible for us to bring in images from the user's
    desktop computer photo application or from their web camera, but for now, these
    features only work on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'LiveCode can call upon the native photo library and camera apps. We will test
    both of these on Android and iOS, but of course, only if your device has some
    saved images and a camera. For Kindle Fire, which doesn''t have a camera, make
    sure that you save some pictures in the Gallery app, so that we can at least try
    loading those. Follow these steps to load pictures for a mobile device:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the **Test** button from the `DatePicker` card and paste it twice on the
    Pictures card. Change the name of the buttons to Test Camera and Test Library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script of the test camera button to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the script of the test library button to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we test the loading of pictures, the image that is loaded will lie on top
    of the test buttons, stopping us from returning to the menu card. To solve this
    issue, add this to the card script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go in the **Standalone Application Settings** and select **Android**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to ask the Android OS permission to use the camera and store the image,
    so check the boxes for **Camera** and **Write External Storage**:![Time for action
    – loading pictures for a mobile device](img/image00258.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the steps for testing on your Android device, or installing on your iOS
    device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the app is running on your device, touch **Pictures** on the first screen
    and then **Test Library**. You should see typical OS-specific options to choose
    a picture from your library or gallery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The picture you have selected is loaded on the card window and will fill most
    of the screen, obscuring our test and menu buttons. The card script we entered
    gives you the ability to touch the image in order to delete it so that you can
    then try another test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try the **Test Camera** button. You will see the OS-specific camera application
    and when you have taken a picture and touched the **Use** or **Ok** button in
    the camera application, the image will be placed on the Pictures card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These simple scripts illustrate how LiveCode is able to call the OS-specific
    applications to do what would otherwise take a lot of coding. What's more, as
    later iOS and Android OS versions are released, the same simple scripts activate
    the more advanced features that Apple and Google will have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – getting the big picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. We take so much for granted when it comes to improvements in technology.
    You might feel hard done by if your phone's camera is a measly 2 megapixels, but
    think back to how things were long ago and how big a picture you were used to
    seeing. In terms of the number of pixels, how many original Macintosh screens
    can fit in the area shown by a single 8 megapixel photo?
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '15'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '24'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '45'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: 45!'
  prefs: []
  type: TYPE_NORMAL
- en: The original Mac had a screen that was 512 x 342 pixels. This will fit more
    than 45 times in the area of an 8 megapixel photo.
  prefs: []
  type: TYPE_NORMAL
- en: Making OS-styled buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's nice that LiveCode can call upon an OS's native controls, but this raises
    a problem because the standard Motif-styled buttons will look ugly when used with
    the OS buttons. We can fix this either using built-in features of LiveCode or
    with the use of an add-on product.
  prefs: []
  type: TYPE_NORMAL
- en: Using bitmaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. LiveCode Fundamentals"),
    *LiveCode Fundamentals*, you can use different bitmaps for the button's states.
    You could get such images by taking screenshots of the buttons on your mobile
    device, at least with the iOS and Android OS v4 and later versions, or you can
    save a lot of time by downloading files that others have made available. Some
    of these files are only licensed for use in prototypes; here, we'll take a look
    at one of the files that is also licensed to be used in commercial products.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using Photoshop to prepare button states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The file we are going to use has Photoshop filter effects that other programs
    cannot handle, so unfortunately, you will need Photoshop to follow all of these
    steps or at least have a friend who has Photoshop! Pixelmator and GraphicConverter
    on Mac OS X can also extract graphics from the file, possibly, by just copying
    an area of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the following article:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://spin.atomicobject.com/2011/03/07/photoshop-template-for-ios-buttons/](http://spin.atomicobject.com/2011/03/07/photoshop-template-for-ios-buttons/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The article points to some other sources of information; for now though, download
    the following file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://spin.atomicobject.com/assets/2011/3/7/iOS_Buttons.psd](http://spin.atomicobject.com/assets/2011/3/7/iOS_Buttons.psd)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the file in Photoshop (it may open automatically).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Layers palette, hide the layers named Background and Tool Bar – Retina.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the layer named **Bar Button – Retina**, and hide the **Button Label**
    layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Marquee tool to select an area around the upper-right-hand side button.
    It should all look like this:![Time for action – using Photoshop to prepare button
    states](img/image00259.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Copy Merged** from the **Edit** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New** from the **File** menu and make sure that the **Background Contents**
    property is set to **Transparent** and accept the size you are given.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the content, it will be an exact fit, and you will see the idle state
    for that button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Save for Web & Devices…** from the **File** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the save dialog, select **24 bit PNG** and make sure that the **Transparency**
    box is checked. Save the PNG with a suitable name, say `bluebuttonup.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the main document and turn on the Visible = Active layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do another **Copy Merged** | **New** | **Paste** | **Save for Web & Devices…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the PNG as `bluebuttondown.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to LiveCode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reopen the test bed stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **File**, **Import As Control**, and **Image File…** to bring the two PNGs
    in the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can place the two images anywhere. Uncheck **Visible** in **Basic Properties**
    for each image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new button to the first card and give it the name Location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the button script to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the Location button and in **Basic Properties** of the **Inspector**
    palette, turn off **Show name** and **Opaque**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Icons & Border**, turn off **Three D**, **Border** and **Hilite border**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the magic wand button next to the **Icon** entry in the **Inspector**
    palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Image library** drop-down menu, select **This Stack**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the lighter one of the two blue images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the magic wand button next to the **Hilite icon** entry and then click
    on the darker of the two images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the button just big enough to show the blue image without it being cropped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a Label field on top of the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Basic Properties**, check the **Disabled** box. This is to make sure that
    the field doesn't trap the click you are going to perform. We want the button
    to get that click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Contents**, enter `Location`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Text** **Formatting**, set the field to use **Helvetica Neue, 18 point,
    Bold, and center aligned**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Colors & Palettes, set the text color white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Align the field and the button so that the two are centered on each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you now test using the iOS Simulator and click on the Location button, you
    will just see a zero, but trying on a device should display your latitude when
    you touch the button (you will have to give permission to the app to know your
    location the first time you press the button.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the example is in the iOS 6 format. iOS 8 can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.teehanlax.com/tools/iphone/](http://www.teehanlax.com/tools/iphone/)'
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the button we made, may not be of the perfect size or even have the
    correct look for a standalone iOS button, we did go through all of the steps that
    you would need to make button state images. Placing a LiveCode field over the
    image buttons doesn't necessarily give it the best appearance. In reality, you
    would take more time in Photoshop to make a button of the right width for the
    label you're using and might also have to add the text to the image itself. It
    would look better and would not need a field to show the button's name in LiveCode.
  prefs: []
  type: TYPE_NORMAL
- en: LiveCode is able to use code to create the images we need, by setting the points
    of a graphic and its `fillGradient`. However, once you have the component parts
    needed to simulate a button or other kind of control, it would still take a lot
    more scripting to manage these elements.
  prefs: []
  type: TYPE_NORMAL
- en: There is an easy way out, although, it will cost you $50!
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – the cost of things these days
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. With the increase in your expectations about the size of a digital photo,
    you also expect to get a lot more for your money these days. While you weigh up
    the advantages of spending $50, how much better value do you think a computer's
    memory is now, compared to 25 years ago?
  prefs: []
  type: TYPE_NORMAL
- en: 10 times better
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Half as good
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 100 times better
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 20,000 times better!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: 4'
  prefs: []
  type: TYPE_NORMAL
- en: Yes indeed. 25 years ago, Apple was selling a 4 MB add-on kit for Macintosh
    II for about $1,500\. They now sell a 64 GB add-on for Mac Pro for $1,200.
  prefs: []
  type: TYPE_NORMAL
- en: MobGUI to the rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RunRev is based in Edinburgh, Scotland, and they're a talented bunch! However,
    they're not the only talented Scottish folk, there's John Craig as well. He has
    developed a powerful add-on to LiveCode that includes an increasingly long list
    of iOS- and Android-OS-like controls. If you were to buy his product, you would
    have to pay $50 for which you get the current version plus any updates that are
    released in the 12 months following your purchase date. While we take a look at
    it here, we can also use a trial version of the product.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – getting started with MobGUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the other add-ons to LiveCode, MobGUI needs to be installed in the
    LiveCode plugins folder. On Windows, this will be at `My Documents/My LiveCode/Plugins`.
    On Mac, it will be at `~/Documents/My LiveCode/Plugins`. This default location
    can be changed under the **LC Preferences** menu and **Files & Memory**. The following
    steps will guide you through getting started with MobGUI:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version of MobGUI from [http://mobgui.com/download.php](http://mobgui.com/download.php).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.zip` file will expand to become a LiveCode stack named **MobGUI_V1-28.livecode**
    for the current version. Hopefully, there will be a newer version when you download
    this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the stack into the plugins folder and reopen LiveCode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new Mainstack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Development** menu, choose **Plugins/revMobGUI**. This window will
    appear when you do so:![Time for action – getting started with MobGUI](img/image00260.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MobGUI window is much like a combination of the LiveCode Tool palette and
    Inspector palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try dragging different items on the card and look at the options for each item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The left-hand side list is scrollable and shows additional controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the controls are placed on the card, they can be manipulated like the normal
    LiveCode controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The selection field at the top right-hand side allows different themes to be
    selected. Select the **android** theme and click on **Apply**. Note that the controls
    you dragged out change. At the time of writing this book, the **android** theme
    represents the older pre-Lollipop themes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have manipulated a stack, you can export the current theme for later
    use. You need to save the newly created stack named the **MobGUI Theme** stack.
    When opened later, this stack will have an **Import** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One remarkable thing about LiveCode is that the many windows and palettes that
    you use in the program are all just stacks, and we've started to make use of a
    rather specialized stack that is going to save us a lot of time and will give
    us a nice interface like the OS-specific interface.
  prefs: []
  type: TYPE_NORMAL
- en: A test bed app, the MobGUI way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to make much the same test bed app, but this time, we'll try to
    give a more iOS-like look to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using MobGUI to make a test bed app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you work in LiveCode starting new stacks, closing others, and opening previously
    saved stacks, these actions can still occupy memory. Sometimes, you can get in
    a confused state where you''re making a new Untitled stack only to find out there''s
    still an Untitled stack on the go, which you''re asked about if you want to purge.
    So, why not treat yourself to a quit and start a fresh launch of LiveCode! The
    following steps will help you achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Mainstack. Set the name to `MGTestBed` and save it somewhere you
    can easily find it. Perhaps, in the folder with the `LCTestBed` stack, which was
    feeling lonely!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the MobGUI window by selecting **Development/Plugins/revMobGUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the MobGUI window's page of controls, select the **Slider resizes** box and
    move the slider to select a size of **320x480**. This is the size of the original
    iPhone. Note the other sizes available. The card can also be resized with the
    LiveCode Inspector.![Time for action – using MobGUI to make a test bed app](img/image00261.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MobGUI context menu in IDE** option in the MobGUI window. This
    will enable you to edit the MobGUI control behaviors later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the **Card Inspector**, set the name of this first card to Email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **TabBar** on the card window. Click on **Snap to bottom** of the card
    window. It will also resize the width of the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the MobGUI window, drag a button in the card window on top of the TabBar.
    Duplicate the button 3 times by holding the *Alt*/*option* key and dragging it.
    Align the four buttons and distribute them across the card using LiveCode's **Align
    Tools** in the **Inspector** palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select each button and set their names and labels to `Email`, `Browser`, `DatePicker`,
    and `Picture`. Then, resize the buttons so that they fit their name text appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Email** button and choose **Object Script** from the **Object**
    menu or right-click on the button and choose the **Edit Script** option. The script
    will already look like the following screenshot:![Time for action – using MobGUI
    to make a test bed app](img/image00262.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following `mouseUp` handler to the script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can copy the mouseUp script of the first button and paste the script in
    the other three buttons. Note that there is a **preOpenControl** handler created
    by MobGUI following the mouseUp script in each of these buttons. Do not change
    that!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll need these elements on all of the four cards we're going to make, so choose
    the **Select All** option and then choose **Group Selected** from the **Object**
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the group is selected and in the regular LiveCode Inspector palette,
    check the **Behave like a background** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make three more cards and name them `Browser`, `DatePicker`, and `Picture`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the LiveCode palette, drag a Label control on the card window for each
    of the four cards and set the name to match the card's name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Standalone Application Settings**, choose either iOS or Android, depending
    on the device you want to test on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Internal App ID** or **Identifier** to `com.yourname.MGTestBed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're performing the same in iOS, make sure that you choose a profile from
    the Profile drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now do a test from the **Development** menu, but first you have to choose
    either **iPhone Simulator** or your connected Android device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seemed like quite a few steps, but it doesn't take much time. We already
    have the navigation between the four cards and an authentic iOS-like interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get some of the test features going, but in a more native, integrated
    way than before.
  prefs: []
  type: TYPE_NORMAL
- en: MobGUI native controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One powerful feature of MobGUI is that it can use ordinary LiveCode controls
    as placeholders for what will become native controls when you run the app on a
    device. This isn't something that you can't do for yourself with code, but being
    able to move placeholder controls around, until you like the layout, would save
    a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using native controls from MobGUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobGUI allows you to switch between the native control theme for iOS and Android
    or to redefine your own themes.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the little image of the iPhone in the MobGUI window and make
    sure that you're on the Native iOS controls set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Email card and drag 3 **Input** text controls from the MobGUI window
    and one **Multiline** text control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the **Input** controls as `To`, `CC`, and `Subject` and the **Multiline**
    text control as `Body`. You can also add some regular LiveCode Label fields alongside
    the input fields as an indicator of what to enter. Size the Body field big enough
    to enter a few lines of text. Also, add some background color to the fields or
    the card so that the fields are seen properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you make each field, note that you can set the keyboard type as well. Set
    it to Email for the To and CC fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the iOS Controls 1 set, drag two buttons on the card window. Name one `Done`
    and the other `Send`. You should have a screenshot like this after this step:![Time
    for action – using native controls from MobGUI](img/image00263.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we test the app and touch one of the fields, the keyboard overlay appears.
    We''ll use the Done button as a way to hide the keyboard. Add a focus line to
    the `mouseUp` handler of the Done button script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MobGUI can retrieve properties from these native fields using the `mgText`
    property. Change the Send button''s `mouseUp` handler to use this property for
    each field and also, to call the `revMail` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to the Browser card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the MobGUI window, drag a **Input** control to the card window and name
    it `URL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Browser** control to the card window and name it `Page`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the sizes so that the text field fills the width of the card and the
    browser control fills the area between the text field and the tab bar at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Browser** control and in the MobGUI window, enter a value for **URL**
    or use the default one already there. This will make the browser control load
    this URL as its first page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script of the URL text field and add this handler, which looks for
    a Return key to go to the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try another test and go to the Email and Browser cards to see them in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recreated the first two tests from our earlier test bed app, only now, it
    looks a lot nicer! Also, we made use of MobGUI's ability to get and set data in
    native iOS controls, in this case, using the `mgText` property and `mobileControlSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all MobGUI controls show up as **groups** in the LiveCode Inspector
    and as **Custom controls** in the Project Browser. These groups are made of customized
    LiveCode controls such as buttons, fields, and so on. MobGUI also adds a MobGUI
    card to the end of your stack. This card includes invisible buttons that have
    behaviors defined. Behaviors are methods to create common functionality between
    objects without duplicating the scripts. You can view these behavior scripts by
    clicking on the script button on the right-hand side of the Project Browser, when
    you display the MobGUI card. Unless you have a specific need to change these,
    just leave them alone.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – other tests and pretty icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and add the other two tests to the stack in the same manner as we did
    in the *Time for action* sections earlier in this chapter. For the `DatePicker`
    example, you could examine the **Dictionary** definition for `iPhonePickDate`
    to see examples of how to use the picked date data in the same manner as the previous
    sections for example, adjustments for different screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have tested the size using the Portrait orientation with just an
    iPhone. You may want to use the same stack for iPhone and iPad or perhaps, iPad
    and an Android tablet, which have quite different aspect ratios.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you just stick with the iPhone, you would still want to take care of
    Portrait and Landscape. We therefore, have to find ways to arrange the many controls
    on the card, so that they look their best on each screen size and orientation.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to achieve this. First, we'll look at how to use a resize
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out using a resize handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a stack's window size changes, LiveCode sends a `resizeStack` message that
    we can trap in order to rearrange controls for the new width and height.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – a simple code layout example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It could get quite complicated if you did lay out all of the card's controls
    with code, so we're only going to construct a simple case to show the technique.
    You can enhance this later for more complex cases.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Mainstack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add four buttons across the width of the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put this handler in the card script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Resize the card window. The buttons should spread out evenly across the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Standalone Application Settings** and select the iOS option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the supported devices include iPad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the orientation options to include all the four orientations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Development** menu, set the **Test Target** as the **iPad Simulator**
    and perform a Test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the simulator, choose either **Rotate Left** or **Rotate Right** from the
    **Hardware** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The buttons should spread themselves out across the screen in both the portrait
    and landscape orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to making a simple example of how the `resizeStack` handler can
    be handled, we also saw that the changes in orientation also send the `resizeStack`
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out using the LiveCode Geometry Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While a control is selected on the card, the Inspector palette has an entry
    named Geometry. It''s a somewhat strange interface! Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Laying out using the LiveCode Geometry Manager](img/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These faint horizontal and vertical bars are used to select whether you want
    the control to be scaled or positioned by a fixed amount or relative amount. That
    is, if a button is 100 pixels from the right of the card window and if you select
    the position a fixed amount away, then as you resize the card window, the button
    will remain 100 pixels away from the right edge of the window. If, on the other
    hand, you use the relative setting and the button is 80 percent across the card
    window, it will still be 80 percent across the window after you have resized it.
  prefs: []
  type: TYPE_NORMAL
- en: The first click on one of these bars will make it turn solid red in color and
    this indicates that it's a fixed amount away from the edge of the card. If you
    click on it again, it takes the shape of a red waveform, indicating that it's
    going to be relative.
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, you can see that the selected button is set to a fixed amount
    from the bottom of the card and a relative amount from the right of the card.
    The image also shows the scaling settings for the control.
  prefs: []
  type: TYPE_NORMAL
- en: Note that an object can also be positioned relative to other objects. Refer
    to the **Right object** and **Bottom object** pop-up selectors in the preceding
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using the Geometry Manager to position buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll add some buttons to the stack that we are currently working on:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the first four buttons and duplicate them to get another set of four buttons
    below the previous ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first of the new buttons and in the **Geometry** section of the Inspector
    palette, click once on the vertical bar and twice on the horizontal bar; you will
    end up with the state shown in the previous screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the other three buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try resizing the card window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That was quite a quick test, and if all went well, you will see that resizing
    the card window includes positioning the first four buttons using the `resizeStack`
    handler that we added, and it's positioning of the second set of four buttons
    using the Geometry Manager. With the settings we used, the results should be much
    the same, except that the second set of four buttons will remain a fixed distance
    away from the bottom of the card window.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of power in the Geometry Manager and you should take a look at
    the other abilities it has at the reference link shown at the end of this chapter.
    However, it is not the best way to deal with mobile screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Resolution independence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LiveCode 6.5, and beyond…
  prefs: []
  type: TYPE_NORMAL
- en: One of the features listed in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. LiveCode
    Fundamentals"), *LiveCode Fundamentals*, has already been developed and is present
    in LiveCode 6.5\. The new feature is Resolution Independence.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after seeing the two complex ways of adjusting the screen size, you may
    be able to forget all of it. In LiveCode 6.5, a new feature called Resolution
    Independence was introduced, and the correct use of this feature will make many
    of the layout difficulties go away.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two approaches in place to help you deal with different device sizes
    and aspect ratios: the Multiple Density Support and the Full Screen Scaling Mode.
    Some of the concepts are a little tricky, but a few screenshots will hopefully
    make them clear!'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple density support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far in this chapter, we overlooked the issue of the **DPI** (**dots per
    inch**) of devices. For Android devices, there are hundreds of different resolutions
    and DPI values. With iOS, there are only a few variations of DPI and resolution.
    The simplest these problem cases to examine, is where you want the same app to
    look like and work in the same manner as iPhone 3GS and iPhone 4 Retina or later
    versions of iPhones. Both have the same size screen, but iPhone 4''s retina display
    has twice the DPI. This URL shows you the difference between all the current iPhones:
    [http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions](http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions).'
  prefs: []
  type: TYPE_NORMAL
- en: With the MobGUI and Geometry Manager solution, you are effectively storing layout
    values or instructions behind the scenes that are ready to adapt to the user's
    device screen size. The Multiple Density Support in LiveCode 6.5 is an easier
    way to solve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Pixels and points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pixel is an illuminated dot in an image or of a screen, whereas a point is
    a unit of measurement in print, generally, 1/72nd of an inch. If a screen has
    exactly 72 DPI, the two would be the same, and in the earlier days of Macintosh
    computers, this was pretty much the case. More modern Macs and PCs and most mobile
    devices are a lot more detailed than 72 DPI. With LiveCode 6.5, and its later
    versions, you can now make a stack that works in points, that will then fill the
    device screen by taking the image of each card and by applying a scaling factor
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: While doing such scaling, something must be assumed to be of natural size. For
    iOS, LiveCode uses non-Retina screens as a scale factor of 1X and Retina screens
    are a scale factor of 2X. iPhone 5 and 6 introduced more sizes. A scale factor
    of 3X is required for iPhone 6 Plus. With Android, things are more complicated
    as it has at least seven levels of scaling factor.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, really, there are an infinite number of scaling factors going on behind
    the scenes. However, you generally don't have to worry about them because LiveCode
    automatically gives you the ability to show different versions of an image depending
    on the DPI of the device in question.
  prefs: []
  type: TYPE_NORMAL
- en: Image naming convention
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LiveCode will look at the file names of the included images (that have been
    added in the **Copy Files** part of the **Standalone Application Settings** dialog)
    and will load in the appropriately named version of the image. In the example
    shown here, two images have been added, `icon.png` and `icon@2x.png`. To make
    it easier to spot which one you are seeing, 512 and 1024 have been added to what
    would otherwise be two resolutions of the same icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image naming convention](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This image is slightly magnified here to help you see that the 512 version of
    the image is lower resolution than the 1024 version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names used for iOS are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`imagename.ext` (for example, `flowers.png`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename@2x.ext` (for example, `flowers@2x.png`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename@3x.ext` (for example, `flowers@3x.png`) for iPhone 6 Plus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one is considered as the 1X scaled version and the `@2x` name is considered
    as the 2X scaled version and the same goes for the `@3x` version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you also need to specify the appropriate **Splash Screen** files in
    the LiveCode **Standalone Application Settings**. Otherwise, the iPhone will use
    lower resolution images. This can be verified by examining the `screenRect` of
    the device. Even though iPhone 6 Plus has a physical resolution of 1080 x 1920,
    use the 3x image sizes of 1242 x 2208\. The phone automatically downsizes the
    image. 2x images will be displayed fine on iPhone 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names and scaling factors used for Android are more varied:'
  prefs: []
  type: TYPE_NORMAL
- en: '`imagename@ultra-low.ext - 0.25X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename extra-low.ext - 0.5X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename low.ext - 0.75`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename medium.ext - 1X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename high.ext - 1.5X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename@extra-high.ext - 2x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagename@ultra-high.ext - 4x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In actual practice, you may find that you only need two or three versions of
    an image to make an image look good enough on a wide range of DPI devices.
  prefs: []
  type: TYPE_NORMAL
- en: The full-screen scaling mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to LiveCode 6.5 and its multiple density support, you had to do all the
    hard work by yourself! At least now you can design for just iPhone or iPad and
    have Retina versions of these devices looked after by LiveCode. With Android though,
    you still need to have a variety of layouts or alternately, have code that would
    position the interface elements based on the aspect ratio and pixel dimensions
    of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the density support, you only have to take care of the aspect ratio, but
    there are still a lot of these to be taken care of. For utility-like applications,
    you will most likely have to go to this trouble, so that users get the expected
    experience. However, there are many types of applications that are more graphical
    and that can take advantage of the full screen scaling modes: `empty`, `exactFit`,
    `showAll`, `noBorder`, and `noScale`. Let''s take a look at what these are…'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general syntax, by the way, is to type this in your stack script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The quotes are required for the four active modes. The empty mode does not need
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: The empty mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If **fullscreenmode** is **empty**, the card area is changed to match the device
    screen. That is, the top left card is in the top-left corner of the device screen
    and the card width and height match the actual pixel width and height of the device.
    Well, except if you have taken advantage of the multiple density support discussed
    earlier! Essentially, empty is the existing behavior in the earlier versions of
    LiveCode.
  prefs: []
  type: TYPE_NORMAL
- en: The showAll mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This mode arrived slightly later than the other modes and is present in LiveCode
    6.6 and its later versions. With **showAll**, as the `fullscreenmode`, the card''s
    contents will be scaled, so that all of it is within the device''s screen. For
    devices that have a different aspect ratio than your card, elements that were
    outside of the card area are revealed. Suppose you create a graphical book app
    where you want the full height of the card to exactly fill the height of the device
    screen, but you don''t want black bars down the sides on a wider device, then
    you could extend the background pattern beyond the left- and right-hand side of
    the card area. On a narrower device, such as iPad, you would see the 4:3 area
    of the card. On a wider device, say iPhone 5, the extra background would be revealed.
    The following illustration shows which area of the background image will be seen
    on different devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The showAll mode](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The letterbox mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **letterbox** mode is identical to **showAll** except that the areas beyond
    the card area are hidden and leave you with the typical movie letterbox effect,
    hence the name!
  prefs: []
  type: TYPE_NORMAL
- en: The noBorder mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **noBorder** mode is very useful, but takes some time to get used to. Let''s
    say you are making a graphical adventure game, along the lines of Myst, and you
    want to use the same graphics for all devices. You could create a scene that has
    an aspect ratio of 14:9 and make sure that the important content is not too close
    to the edges. When the scene is viewed in the `noBorder` mode on an iPad, you
    would see the full height of the scene and most of the width. When viewed on iPhone
    5, you would see the full width of the scene and most of the height. As the name
    suggests, the card area would be scaled, so that there are no borders, as there
    would be in the letterbox mode. The following illustration shows which areas of
    an original 14:9 photograph would be visible for a 4:3 iPad and a 16:9 iPhone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The noBorder mode](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The exactFit mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name implies, **exactFit** would take the card's content and squish it
    to fill the device's screen. It's hard to think of a use case for this mode, but
    perhaps, if you perform some sort of artistic visualizer, the squishing wouldn't
    matter much!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned previously, the Geometry Manager has a lot of powerful features.
    If your interest is also in desktop applications, take a look at the lesson at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://lessons.runrev.com/s/lessons/m/4067/l/19026-Geometry-Manager](http://lessons.runrev.com/s/lessons/m/4067/l/19026-Geometry-Manager)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trick with easy-to-use tools, such as LiveCode, is to create mobile apps
    that users think were created with the hard-to-use native tools, such as Xcode.
    You can achieve this because of LiveCode's ability to call upon native features
    and because you can make interfaces that look appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered several ways to achieve this goal by calling native
    OS features using simple LiveCode commands. We prepared images to be used for
    button states and made buttons that look OS-specific by adding these images. We
    also created controls that look like iOS native controls with MobGUI and laid
    out the interface with code, with the Geometry Manager.
  prefs: []
  type: TYPE_NORMAL
- en: So far, these have all been small test stacks to get us warmed up! Next, we're
    going to look at the general application structure to make a fully fleshed out
    utility application.
  prefs: []
  type: TYPE_NORMAL
