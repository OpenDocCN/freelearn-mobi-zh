<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Extending RubyMotion"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Extending RubyMotion</h1></div></div></div><p>The DRY principle<a id="id569" class="indexterm"/> states the following:</p><p>
<span class="emphasis"><em>"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system."</em></span>
</p><p>We are now approaching the end of this book. So far we have learned how to quickly make iOS applications with RubyMotion. To make this process even more rapid, RubyMotion lets us use special RubyMotion-flavored gems and wrappers. <a id="id570" class="indexterm"/>
<span class="strong"><strong>Gems</strong></span> and <span class="strong"><strong>wrappers</strong></span>
<a id="id571" class="indexterm"/> are Ruby programs that are wrapped into a self-contained format. These are generally open source projects, which other developers can use in their applications or can even contribute back to these projects. Fortunately, RubyMotion has a very enthusiastic community; within months of launching RubyMotion's tool chain, plenty of gems were introduced that implement many laborious tasks fairly quickly. In this chapter, we will learn how to augment our application by using RubyMotion-flavored gems. The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">RubyMotion gems</li><li class="listitem" style="list-style-type: disc">CocoaPods</li></ul></div><div class="section" title="RubyMotion gems"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec59"/>RubyMotion gems</h1></div></div></div><p>Use of gems is based on the programming practice of <span class="strong"><strong>Don't Repeat Yourself</strong></span> (<span class="strong"><strong>DRY</strong></span>), which states that when some piece of code is ready to use and is available, why bother working on it again. The RubyMotion community may be very young right now, but it already has some amazing gems that make<a id="id572" class="indexterm"/> a lot of tiring tasks pretty easy. Some gems even target challenging functionalities in a very simple manner.</p><p>In this chapter we will cover the following RubyMotion-flavored gems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Teacup</li><li class="listitem" style="list-style-type: disc">BubbleWrap</li><li class="listitem" style="list-style-type: disc"><code class="literal">motion-addressbook</code></li></ul></div><div class="section" title="Teacup – say goodbye to Xcode and XIB files!"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec80"/>Teacup – say goodbye to Xcode and XIB files!</h2></div></div></div><p>Designing a UI for iOS apps is a tough job, especially for developers who have worked previously on easy-to-learn-and-implement web technologies. <span class="strong"><strong>Teacup</strong></span> is a gem that will make your life <a id="id573" class="indexterm"/>really easy. Teacup augments your ability to quickly design and style the views of your RubyMotion application; you can easily create layouts while keeping your code DRY.</p><p>Let's create an application and learn how easy it is to use<a id="id574" class="indexterm"/> Teacup:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$motion create TeaCupMotion</strong></span>
</pre></div><p>We will be using <a id="id575" class="indexterm"/>
<span class="strong"><strong>Bundler</strong></span> (which is also a Ruby gem) to install all our gems. Bundler also helps us manage application dependencies, so that the exact version of the gems used are available for the application to run.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>Bundler comes as a default dependency manager for popular frameworks such as Ruby on Rails.</p></div></div><p>Let's add Bundler to our application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update the <code class="literal">Rakefile</code> with the following lines of code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$:.unshift("/Library/RubyMotion/lib")</strong></span>
<span class="strong"><strong>require 'motion/project'</strong></span>
<span class="strong"><strong>require 'bundler'</strong></span>
<span class="strong"><strong>Bundler.require</strong></span>
</pre></div></li><li class="listitem">With Bundler, we require a Gemfile in which we can mention details about the gems we will use with our application. Next, let's create a Gemfile and add the following lines of code in it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>source "https://rubygems.org"</strong></span>
<span class="strong"><strong>gem "teacup"</strong></span>
</pre></div><p>So, in the future, if you want to add any new gem to your project, you can simply add it to this file.</p></li><li class="listitem">Next, let's run <code class="literal">bundle install</code> and we're good to go:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bundle install</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>The <code class="literal">bundle install</code> command<a id="id576" class="indexterm"/> adds a <code class="literal">Gemfile.lock</code> file to your repository. This ensures that other developers on your app, as well as your deployment environment, will all use the same third-party code that you are using now.</p></div></div></li><li class="listitem">Next, <a id="id577" class="indexterm"/>update the <code class="literal">app_delegate.rb</code> file with the following code:<div class="informalexample"><pre class="programlisting">class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)
    myNavController = RootController.alloc.init

    @window.rootViewController = UINavigationController.alloc.initWithRootViewController(myNavController)
    @window.rootViewController.wantsFullScreenLayout = true
    @window.makeKeyAndVisible
    true
  end
end</pre></div></li></ol></div><p>In this code, we are only initializing an instance of <code class="literal">RootController</code>, just like we do with every application. As you may remember, the controller is where all our application logic resides.</p><p>So far, in various chapters we have made RubyMotion iOS applications in a traditional way. Let's use Teacup in our application this time, and add styles by making use of its Cascading Style Sheets (CSS) type syntax<a id="id578" class="indexterm"/>.</p><p>Let's create a directory named <code class="literal">style</code> and add a new file with the name of <code class="literal">style.rb</code> in it. Add the following code to the <code class="literal">style.rb</code> file in the <code class="literal">style</code> folder:</p><div class="informalexample"><pre class="programlisting">Teacup::Stylesheet.new(:style) do

  style :your_layout,
    landscape: true

  style UILabel,
    textColor: UIColor.blueColor
  style :label,
    text: 'Awesome',
    backgroundColor: UIColor.whiteColor,
    top: 10,
    left: 100,
    width: 100,
    height: 20

end</pre></div><p>Let's <a id="id579" class="indexterm"/>understand the preceding code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we have created a stylesheet named <code class="literal">style</code>.<div class="informalexample"><pre class="programlisting">Teacup::Stylesheet.new(:style) do
…
end</pre></div><p>This convention is provided by Teacup to create a new stylesheet.</p></li><li class="listitem">Next, we have created a specific layout for your views, using CSS-based syntax.<div class="informalexample"><pre class="programlisting">  style :your_layout,
    landscape: true</pre></div><p>This will create a style named <code class="literal">your_layout</code> and will enable the landscape rotation (otherwise, only portrait orientation is enabled).</p></li><li class="listitem">Next, we have added style for all <code class="literal">UILabel</code> instances.<div class="informalexample"><pre class="programlisting">  style UILabel,
    textColor: UIColor.blueColor</pre></div><p>The preceding line of code gives text color to all <code class="literal">UILabel</code> instances that are defined inside the style. Since we apply a style to all the labels when using <code class="literal">UILabel</code>, if we want to style a specific element, we have to add the following commands:</p><div class="informalexample"><pre class="programlisting">style :label,
  text: 'Awesome',
  backgroundColor: UIColor.whiteColor,
  top: 10,
  left: 100,
  width: 100,
  height: 20</pre></div></li></ol></div><p>Here, <code class="literal">label</code> is like a class. This will do the styling for the label.</p><p>To understand<a id="id580" class="indexterm"/> this better, let's create a view. Perform the following steps to create a view:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file named <code class="literal">root_view_controller.rb</code> and add the following code to it:<div class="informalexample"><pre class="programlisting">class RootController &lt; UIViewController

  stylesheet :style

  layout :your_layout do
    @label1 = subview(UILabel, :label)
 
  end

  def shouldAutorotateToInterfaceOrientation(orientation)
    autorotateToOrientation(orientation)
  end
  
end</pre></div><p>As we have created a new controller file, we must make the corresponding changes to the <code class="literal">app_delegate.rb</code> file. Make these changes in your <code class="literal">app_delegate.rb</code> file as shown in the previous chapters.</p><p>In the preceding code snippet, first we have given the stylesheet a name, which is done using <code class="literal">stylesheet:style</code>, and then we have specified a layout named <code class="literal">your_layout</code> and passed <code class="literal">label : @label1 = subview(UILabel, :label)</code> to it.</p></li><li class="listitem">Let's fire up the terminal and test our application.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div><p>The following is the output:</p><div class="mediaobject"><img src="graphics/5220OT_11_01.jpg" alt="Teacup – say goodbye to Xcode and XIB files!"/></div><p>We can see the text <span class="strong"><strong>Awesome</strong></span> appear on the simulator screen and it is styled <a id="id581" class="indexterm"/>as we have defined in the stylesheet.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>Teacup implements the<a id="id582" class="indexterm"/> <code class="literal">viewDidLoad</code> method and instantiates any views. If you want to implement your own <code class="literal">viewDidLoad</code> method, make sure to call super.</p></div></div><p>We can also define different stylesheets for changing dimensions as we rotate the device, such as the landscape and portrait modes. Let's try this in our next example.</p></li><li class="listitem">Now update the stylesheet, that is, the <code class="literal">style.rb</code> file, with the following code:<div class="informalexample"><pre class="programlisting">    style :label,
    text: 'Awesome',
    backgroundColor: UIColor.whiteColor,
    top: 10,
    left: 100,
    width: 100,
    height: 20,
<span class="strong"><strong>    landscape: {</strong></span>
<span class="strong"><strong>        backgroundColor: UIColor.redColor,</strong></span>
<span class="strong"><strong>     }</strong></span>
</pre></div></li><li class="listitem">Run the <a id="id583" class="indexterm"/>application and rotate the screen from the simulator menu by navigating to <span class="strong"><strong>Hardware</strong></span> | <span class="strong"><strong>Rotate Left</strong></span>. You will see that as the screen rotates the background color of the label changes.<div class="mediaobject"><img src="graphics/5220OT_11_02.jpg" alt="Teacup – say goodbye to Xcode and XIB files!"/></div></li><li class="listitem">Now, let's do a few more things in the same example. Add the following code in the <code class="literal">style.rb</code> file:<div class="informalexample"><pre class="programlisting">  style UITextField,                # Defining styles based on view
class instead
  textColor: UIColor.redColor

  style :field,
  left:   10,
  top:    10,
  width:  200,
  height: 30,
  landscape: {
    width: 360  # make it wide in landscape view
  }

  style :search, extends: :field,
  backgroundColor: UIColor.whiteColor,
  left: 20,
  top: 70,
  placeholder: 'Search Box'     
  style :search_new, extends: :field,
  backgroundColor: UIColor.redColor,
  left: 20,
  top: 110,
  placeholder: 'Search Box'</pre></div><p>Here we have created two text field boxes.</p></li><li class="listitem">Now, update the <code class="literal">root_controller.rb</code> file.<div class="informalexample"><pre class="programlisting">  layout :your_layout do
    @label1 = subview(UILabel, :label)
    @search = subview(UITextField, :search)
    @one_more_search = subview(UITextField, :search_new)
 
  end</pre></div></li><li class="listitem">Let's test<a id="id584" class="indexterm"/> our application in the simulator.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div><p>The following is the output:</p><div class="mediaobject"><img src="graphics/5220OT_11_03.jpg" alt="Teacup – say goodbye to Xcode and XIB files!"/></div></li></ol></div><p>With the <a id="id585" class="indexterm"/>preceding example, we can see how easy it is to design views with the Teacup gem; it has delivered a way to create interfaces programmatically with ease. We have shared a few of the features of this amazing gem; you can explore more at <a class="ulink" href="https://github.com/rubymotion/teacup">https://github.com/rubymotion/teacup</a>.</p></div><div class="section" title="BubbleWrap – making Cocoa APIs more Ruby-like"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec81"/>BubbleWrap – making Cocoa APIs more Ruby-like</h2></div></div></div><p>BubbleWrap<a id="id586" class="indexterm"/> is a collection of very well-tested helpers<a id="id587" class="indexterm"/> and wrappers used to wrap Cocoa SDK code and provide more Ruby-like APIs for RubyMotion. It provides wrappers for a lot of iOS Cocoa SDK code, such as camera, notification center, HTTP, and many more.</p><p>We can do a lot of things very easily. For example, to perform a <code class="literal">GET HTTP</code> request with BubbleWrap, we require the following simple code snippet:</p><div class="informalexample"><pre class="programlisting">BW::HTTP.get("https://twitter.com/rubymotion") do |response|
  p response.body.to_str
end</pre></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Device Capability – Power Unleashed">Chapter 6</a>, <span class="emphasis"><em>Device Capability – Power Unleashed</em></span>, we have learned about device capabilities—implementing <a id="id588" class="indexterm"/>camera functionalities in your app. We have written quite a lot of code there, but with BubbleWrap things get really simplified. We only require the following code<a id="id589" class="indexterm"/> snippet for using a camera in our application:</p><div class="informalexample"><pre class="programlisting">BW::Device.camera.front.picture(media_types: [:movie, :image]) do |result|
  image_view = UIImageView.alloc.initWithImage(result[:original_image])
end</pre></div><p>BubbleWrap also provides a module named <code class="literal">App</code> that can be used while running the application. To understand this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a small sample application.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$motion create UseBubbleWrap</strong></span>
</pre></div></li><li class="listitem">Update the <code class="literal">Rakefile</code> to include a Bundler that will help us install the BubbleWrap gem easily.<div class="informalexample"><pre class="programlisting">require 'bundler'
Bundler.require</pre></div></li><li class="listitem">As shown in the last section, let's add a <code class="literal">Gemfile</code> to our project with the following code:<div class="informalexample"><pre class="programlisting">source :rubygems
gem 'bubble-wrap'</pre></div></li><li class="listitem">Run the following command to install the BubbleWrap gem:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$bundle install</strong></span>
</pre></div></li><li class="listitem">Next, let's fire up the terminal to test the <code class="literal">App</code> module<a id="id590" class="indexterm"/> on the console:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div></li><li class="listitem">To use the <code class="literal">App</code> module, run the following commands in REPL:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(main)&gt; App.name</strong></span>
<span class="strong"><strong>=&gt; "UseBubbleWrap"</strong></span>

<span class="strong"><strong>(main)&gt; App.identifier</strong></span>
<span class="strong"><strong>=&gt; "com.yourcompany.UseBubbleWrap"</strong></span>

<span class="strong"><strong>(main)&gt; App.documents_path</strong></span>
<span class="strong"><strong>=&gt; "/Users/abhishek/Library/Application Support/iPhone Simulator/6.1/Applications/3CF89A96-F390-4A7D-89B8-2F0E7B54A38A/Documents"</strong></span>

<span class="strong"><strong>(main)&gt; App.resources_path</strong></span>
<span class="strong"><strong>=&gt; "/Users/abhishek/Library/Application Support/iPhone Simulator/6.1/Applications/3CF89A96-F390-4A7D-89B8-2F0E7B54A38A/UseBubbleWrap.app"</strong></span>

<span class="strong"><strong>(main)&gt; App.frame</strong></span>
<span class="strong"><strong>=&gt; #&lt;CGRect origin=#&lt;CGPoint x=0.0 y=20.0&gt; size=#&lt;CGSize width=320.0 height=460.0&gt;&gt;</strong></span>
<span class="strong"><strong>(main)&gt; App.states</strong></span>
<span class="strong"><strong>=&gt; {}</strong></span>

<span class="strong"><strong>(main)&gt; App.shared</strong></span>
<span class="strong"><strong>=&gt; #&lt;UIApplication:0x9530920&gt;</strong></span>

<span class="strong"><strong>(main)&gt; App.current_locale</strong></span>
<span class="strong"><strong>=&gt; #&lt;__NSCFLocale:0x966a040&gt;</strong></span>
<span class="strong"><strong>(main)&gt; App.alert("This is nice!!")</strong></span>
<span class="strong"><strong>=&gt; #&lt;UIAlertView:0xa8433f0&gt;</strong></span>

<span class="strong"><strong>(main)&gt;  App.run_after(0.5) {  p "It's #{Time.now}"   }</strong></span>
<span class="strong"><strong>=&gt; #&lt;__NSCFTimer:0x93760c0&gt;</strong></span>
<span class="strong"><strong>(main)&gt; "It's 2013-05-10 18:47:34 +0530"</strong></span>
</pre></div></li><li class="listitem">There is <a id="id591" class="indexterm"/>another module named <code class="literal">Device</code> that provides many options related to the current device. Let's once again fire<a id="id592" class="indexterm"/> up REPL in our terminal and execute the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
<span class="strong"><strong>(main)&gt; Device.iphone?</strong></span>
<span class="strong"><strong>=&gt; true</strong></span>

<span class="strong"><strong>(main)&gt; Device.ipad?                 </strong></span>
<span class="strong"><strong>=&gt; false</strong></span>

<span class="strong"><strong>(main)&gt; Device.front_camera?</strong></span>
<span class="strong"><strong>"This method (front_camera?) is DEPRECATED. Transition to using Device.camera.front?"</strong></span>
<span class="strong"><strong>=&gt; false</strong></span>

<span class="strong"><strong>(main)&gt;  Device.screen.width</strong></span>
<span class="strong"><strong>=&gt; 320.0</strong></span>

<span class="strong"><strong>(main)&gt; Device.screen.height</strong></span>
<span class="strong"><strong>=&gt; 480.0</strong></span>

<span class="strong"><strong>(main)&gt; Device.orientation</strong></span>
<span class="strong"><strong>=&gt; :portrait</strong></span>
</pre></div></li></ol></div><p>There are <a id="id593" class="indexterm"/>tons of helpers that come with the BubbleWrap<a id="id594" class="indexterm"/> gem. It will be helpful for your project if you have a look at the BubbleWrap documentation at <a class="ulink" href="http://bubblewrap.io/">http://bubblewrap.io/</a>.</p></div><div class="section" title="motion-addressbook – access phonebook easily"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec82"/>motion-addressbook – access phonebook easily</h2></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Device Capability – Power Unleashed">Chapter 6</a>, <span class="emphasis"><em>Device Capability – Power Unleashed</em></span>, we had discussed in detail how to use the Address Book technology for iOS devices. In this section, we will use a special gem for <a id="id595" class="indexterm"/>RubyMotion named <code class="literal">motion-addressbook</code> that simplifies using the Address Book.</p><p>We will <a id="id596" class="indexterm"/>perform the following actions in this section:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a sample app with the <code class="literal">motion-addressbook</code> gem</li><li class="listitem" style="list-style-type: disc">Pull the data from the device's Address Book</li><li class="listitem" style="list-style-type: disc">Display it on the screen</li></ul></div><p>Let's start by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a sample application.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$motion create AddressBook_example</strong></span>
</pre></div></li><li class="listitem">Next, let's include the <code class="literal">motion-addressbook</code> gem in the <code class="literal">Gemfile</code>.<div class="informalexample"><pre class="programlisting">source :rubygems
gem 'bubble-wrap'
gem 'motion-addressbook'</pre></div></li><li class="listitem">Bundle<a id="id597" class="indexterm"/> install from the command line to include this gem in our project:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$bundle install</strong></span>
</pre></div></li><li class="listitem">Let's<a id="id598" class="indexterm"/> create a file named <code class="literal">addressbook_controller.rb</code> in which we will add a button and three labels. With the button, we will access our address book and choose the desired contact. In the labels, we will display the data of the user, which we have copied from the address book. Add the following code in your <code class="literal">addressbook_controller.rb</code> file:<div class="informalexample"><pre class="programlisting">def viewDidLoad
    view.backgroundColor = UIColor.underPageBackgroundColor
    load_button
    load_labels
  end

  def load_button

    @phonebook_button = UIButton.buttonWithType(UIButtonTypeRoundedRect)
    @phonebook_button.frame = [[50, 20], [200, 50]]
    @phonebook_button.setTitle("Click from Contacts", forState:UIControlStateNormal)
    @phonebook_button.addTarget(self, action: :addressbook_access, forControlEvents:UIControlEventTouchUpInside)
    view.addSubview(@phonebook_button)

  end


  def load_labels

    @first_name = UILabel.new
    @first_name.text = 'First Name'
    @first_name.frame = [[100,100],[150,50]]

    @last_name = UILabel.new
    @last_name.text = 'Last Name'
    @last_name.frame = [[100,160],[150,50]]

    @organization = UILabel.new
    @organization.text = 'Organization'
    @organization.frame = [[100,220],[150,50]]

    view.addSubview(@first_name)
    view.addSubview(@last_name)
    view.addSubview(@organization)
  end</pre></div></li><li class="listitem">Add the <a id="id599" class="indexterm"/>following code in the <a id="id600" class="indexterm"/><code class="literal">app_delegate.rb</code> file so that our delegate points to our address book controller:<div class="informalexample"><pre class="programlisting">class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)

  @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)
  @window.rootViewController = AddressbookController.alloc.init
  @window.makeKeyAndVisible

  
    true
  end
end</pre></div></li><li class="listitem">Let's fire up the terminal and run our app in a simulator to check if we are able to see our three labels and a button.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div><p>The following is the output:</p><div class="mediaobject"><img src="graphics/5220OT_11_04.jpg" alt="motion-addressbook – access phonebook easily"/></div></li><li class="listitem">In the<a id="id601" class="indexterm"/> preceding code snippet, we have mentioned a method named <code class="literal">addressbook_access</code>. To access the Address Book, we need to use the <code class="literal">AddressBook</code> picker that lets us open the device's Address Book in our application and pick data from it. With this method, we will be doing the same. Let's create this method in our <code class="literal">addressbook_controller.rb</code> file and add the following code to it:<div class="informalexample"><pre class="programlisting">  def addressbook_access

    AddressBook.pick { |person|
      if person
         first_name = person.attributes[:first_name]
         last_name = person.attributes[:last_name]
         org = person.attributes[:organization]
         @first_name.text = first_name
         @last_name.text = last_name
         @organization.text = org

      else
        # write some cancel code
      end
    }

  end</pre></div></li><li class="listitem">Let's fire up the terminal and run our app in a simulator to check if we are able to<a id="id602" class="indexterm"/> access the Address Book and import the desired contact details in our application.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div><p>The following is the output:</p><div class="mediaobject"><img src="graphics/5220OT_11_05.jpg" alt="motion-addressbook – access phonebook easily"/></div></li><li class="listitem">Once we select any contact, we will get its details on our application, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5220OT_11_06.jpg" alt="motion-addressbook – access phonebook easily"/></div></li></ol></div><p>That's it, we are done. It's the same application we had created in <a class="link" href="ch06.html" title="Chapter 6. Device Capability – Power Unleashed">Chapter 6</a>, <span class="emphasis"><em>Device Capability – Power Unleashed</em></span>, but with <code class="literal">motion-addressbook</code>, we have substantially less code.</p><p>Let's understand what <a id="id603" class="indexterm"/>we have done here. The <a id="id604" class="indexterm"/>
<code class="literal">motion-addressbook</code> gem gives us many options to easily use the device's Address Book. In the <code class="literal">addressbook_access</code> method, we have used the <code class="literal">AddressBook</code> picker by using <code class="literal">AddressBook.pick</code>, which opens up the device's Address Book for us. Once we select any contact, we get a <code class="literal">person</code> object that has a hash of all the attributes of the selected contact.</p><p>In our example, we have used the <code class="literal">first_name</code>, <code class="literal">last_name</code>, and <code class="literal">organization</code> values from the selected <code class="literal">person</code> object. However, the <code class="literal">motion-addressbook</code> gem has many more options that make working with the Address Book framework faster and easier. A few of them are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To create a new contact.<div class="informalexample"><pre class="programlisting">AddressBook::Person.new
#&lt;AddressBook::Person:0xc360bc0 @address_book=nil @ab_person=nil @attributes={}&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">To pull all the records from the address book.<div class="informalexample"><pre class="programlisting">AddressBook::Person.all
[#&lt;AddressBook::Person:0x9d78c80 @address_book=#&lt;__NSCFType:0xc0db6d0&gt; @ab_person=#&lt;__NSCFType:0x9d77ea0&gt; @attributes={:first_name=&gt;"Abhishek", :last_name=&gt;"Nalwaya", :organization=&gt;"Fun Inc."}&gt;, #&lt;AddressBook::Person:0x78f0a20 @address_book=#&lt;__NSCFType:0xc0db6d0&gt; @ab_person=#&lt;__NSCFType:0x9d78520&gt; @attributes={:first_name=&gt;"Akshat", :last_name=&gt;"Paul", :organization=&gt;"PacktPub"}&gt;, #&lt;AddressBook::Person:0x78a5eb0 @address_book=#&lt;__NSCFType:0xc0db6d0&gt; @ab_person=#&lt;__NSCFType:0x9d788b0&gt; @attributes={:first_name=&gt;"Laurent", :last_name=&gt;"Sansonetti", :organization=&gt;"HipByte"}&gt;, #&lt;AddressBook::Person:0x78c06e0 @address_book=#&lt;__NSCFType:0xc0db6d0&gt; @ab_person=#&lt;__NSCFType:0x9d78700&gt; @attributes={:first_name=&gt;"Manu", :last_name=&gt;"Singhal", :organization=&gt;"Ruby Inc"}&gt;]</pre></div></li><li class="listitem" style="list-style-type: disc">To get a list of records based on a specific attribute.<div class="informalexample"><pre class="programlisting">AddressBook::Person.find_all_by_organization('HipByte')</pre></div></li><li class="listitem" style="list-style-type: disc">To get a list<a id="id605" class="indexterm"/> of records based on many conditions.<div class="informalexample"><pre class="programlisting">AddressBook::Person.where(:email =&gt; 'akshatpaul@abc.com', :organization =&gt; 'Fun Inc')</pre></div></li><li class="listitem" style="list-style-type: disc">To create a new <a id="id606" class="indexterm"/>contact.<div class="informalexample"><pre class="programlisting">AddressBook::Person.create(:first_name =&gt; 'Shi', :last_name =&gt; 'Foo', :email =&gt; shi@foo.com')</pre></div></li></ul></div></div></div></div>
<div class="section" title="CocoaPods &#x2013; managing Objective-C libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec60"/>CocoaPods – managing Objective-C libraries</h1></div></div></div><p>CocoaPods<a id="id607" class="indexterm"/> is the best way to manage library dependencies in Objective-C projects. CocoaPods was originally designed to be integrated in Objective-C Xcode projects, but it can r<a id="id608" class="indexterm"/>eadily be used in RubyMotion projects using the <a id="id609" class="indexterm"/>
<code class="literal">motion-cocoapods</code> gem.</p><div class="section" title="Installing CocoaPods with RubyMotion"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec83"/>Installing CocoaPods with RubyMotion</h2></div></div></div><p>Perform the following steps to<a id="id610" class="indexterm"/> install CocoaPods with RubyMotion:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install CocoaPods.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>   $sudo gem install cocoapods</strong></span>
</pre></div></li><li class="listitem">Set up CocoaPods.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>   $pod setup</strong></span>
</pre></div></li><li class="listitem">Install <code class="literal">motion-cocoapods</code> to work with RubyMotion.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$sudo gem install motion-cocoapods</strong></span>
</pre></div></li></ol></div><p>Now we are all set to use CocoaPods in our RubyMotion project. Add the following code in the <code class="literal">Rakefile</code>:</p><div class="informalexample"><pre class="programlisting">Motion::Project::App.setup do |app|
  app.pods do
    dependency 'Reachability'
  end
end</pre></div><p>So, next time when you build your code, it will automatically download the library for you. Then you can use the Objective-C CocoaPods in your project.</p><p>For detailed documentation on CocoaPods, visit <a class="ulink" href="http://cocoapods.org/">http://cocoapods.org/</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter, we have learned the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">RubyMotion Gems<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Teacup: A community-driven DSL for creating user interfaces on iOS.</li><li class="listitem" style="list-style-type: disc">BubbleWrap: A collection of (tested) helpers and wrappers used to wrap CocoaTouch code and provide more Ruby-like APIs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">motion-addressbook</code>: A gem to perform different actions on the iOS Address Book.</li></ul></div></li><li class="listitem" style="list-style-type: disc">CocoaPods: It is the best way to manage library dependencies in Objective-C and RubyMotion projects</li></ul></div></div>
<div class="section" title="What next?"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>What next?</h1></div></div></div><p>Congratulations, we have covered a lot in the last 11 chapters and we are sure you now know a lot more about RubyMotion than you did at the outset.</p><p>We have learned a lot of things during this journey—beginning with installing RubyMotion, understanding the RubyMotion folder structure, debugging our application, introducing RubyMotion objects, creating an MVC application, playing with the user interface, using device capabilities such as the camera, gestures, persistence storage, writing test cases, creating games, using RubyMotion-flavored gems, and submitting the application to App Store. That's a lot of stuff!</p><p>So, what can be done next from here? The answer to this question is <span class="emphasis"><em>plenty of things!</em></span> There is still a lot to discover in RubyMotion and the iOS SDK; so from here, the first thing we can do is grab a book that explores the iOS SDK in detail. The best source for anything related to iOS SDK is Apple's Developer Reference at <a class="ulink" href="https://developer.apple.com/">https://developer.apple.com/</a>. All things at Apple's Developer Reference are in Objective-C, but now we have the skills to translate verbose Objective-C code to learn and clean RubyMotion code.</p><p>Next, keep yourself updated with the latest happenings in the RubyMotion ecosystem with the RubyMotion blog (<a class="ulink" href="http://blog.rubymotion.com">http://blog.rubymotion.com</a>) and Developer Center (<a class="ulink" href="http://www.rubymotion.com/developer-center/">http://www.rubymotion.com/developer-center/</a>). The RubyMotion blog keeps us updated with the RubyMotion world—what's new in this version or what's in store for the future of RubyMotion. Developer Center is a great source for API references, some quick tutorials, and the latest articles on technology. For RubyMotion wrappers and libraries, you can visit <a class="ulink" href="http://rubymotion-wrappers.com/">http://rubymotion-wrappers.com/</a>. This web page is a one-stop shop for details on available wrappers and is updated often.</p><p>To discuss any issue, you must join the RubyMotion community at its Google group (<a class="ulink" href="https://groups.google.com/forum/?fromgroups#!forum/rubymotion">https://groups.google.com/forum/?fromgroups#!forum/rubymotion</a>). This group is a great place to interact with the vibrant RubyMotion community.</p><p>Finally, create apps! There is no better way to master a technology than learning on your own in a real-world scenario. You can contribute to the community by creating wrappers and gems—that's a great way to acquire expertise on a specific area of a technology. We hope you have enjoyed reading and learning with this book, and have now evolved as an iOS RubyMotion developer; we are very excited about RubyMotion, just like you, and look forward to seeing your work making a mark in the iOS and RubyMotion world.</p></div></body></html>