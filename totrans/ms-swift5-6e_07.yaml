- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first learned to program with BASIC, my first few programs were written
    in one long block of code. I quickly realized that I was repeating the same code
    over and over. I thought that there must be a better way to do this, which was
    when I learned about subroutines and functions. Functions are one of the key concepts
    that you need to understand to write good code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to return values from a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use parameters in a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are variadic parameters?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are `inout` parameters?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Swift, a function is a self-contained block of code that performs a specific
    task. Functions are generally used to logically break our code into reusable named
    blocks. The function's name is used to call the function.
  prefs: []
  type: TYPE_NORMAL
- en: When we define a function, we can also optionally define one or more parameters.
    Parameters are named values that are passed into the function by the code that
    calls it. These parameters are generally used within the function to perform the
    task of the function. We can also define default values for the parameters to
    simplify how the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Every Swift function has a type associated with it. This type is referred to
    as the return type and it defines the types of data returned from the function
    to the code that called it. If a value is not returned from a function, the return
    type is `Void`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to define functions in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Using a single-parameter function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax that''s used to define a function in Swift is very flexible. This
    flexibility makes it easy for us to define simple C-style functions, or more complex
    functions with local and external parameter names, which we will see later in
    this chapter. Let''s look at some examples of how to define functions. The following
    example accepts one parameter and does not return any value to the code that called
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we defined a function named `sayHello()` that accepted
    one parameter, named `name`. Inside the function, we printed out a greeting to
    the person. Once the code within the function is executed, the function exits,
    and control is returned to the code that called it. Rather than printing out the
    greeting, we could return it to the code that called it by adding a return type,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `->` string defines the return type associated with the function as a string.
    This means that the function must return an instance of the `String` type to the
    code that calls it. Inside the function, we build a string constant, named `retString`,
    with the greeting message and then return it using the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a Swift function is a similar process to calling functions or methods
    in other languages, such as C or Java. The following example shows how to call
    the `sayHello(name:)` function, which prints the greeting message to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how to call the `sayHello2(name:)` function, which returns
    a value to the code that called it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we called the `sayHello2(name:)` function and inputted
    the value that was returned in the `message` variable. If a function defines a
    return type as the `sayHello2(name:)` function does, it must return a value of
    that type to the code that called it. Therefore, every possible conditional path
    within the function must end by returning a value of the specified type. This
    does not mean that the code that called the function is required to retrieve the
    returned value. As an example, both lines in the following snippet are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not specify a variable for the return value to go into, the value
    is dropped. When the code is compiled, you will receive a warning if a function
    returns a value and you do not put it into a variable or a constant. You can avoid
    this warning by using an underscore, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The underscore tells the compiler that you are aware of the return value, but
    you do not want to use it. Using the `@discardableResult` attribute when declaring
    a function will also silence the warning. This attribute is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With SE-0255 in Swift 5.1, we can omit the `return` statement in single expression
    functions. Let''s look at the following code as an example of what this would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is defined similarly to the previous hello functions with a `String`
    return type; however, you will notice that there is no return statement in the
    function. With SE-0255, if we have a function with a single expression, like the
    `sayHello4(name:)` function, the value of the expression can be returned without
    the need of the `return` statement. If we called the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `message` constant would contain the string `"Hello Kara"`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we would define multiple parameters for our functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using a multi-parameter function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not limited to just one parameter with our functions; we can also define
    multiple parameters. To create a multi-parameter function, we list the parameters
    in parentheses and separate the parameter definitions with commas. Let''s look
    at how to define multiple parameters in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the function accepts two arguments: `name` and `greeting`.
    We then print a greeting to the console using both parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a multi-parameter function is a little different from calling a single-parameter
    function. When calling a multi-parameter function, we separate the parameters
    with commas. We also need to include the parameter name for all the parameters.
    The following example shows how to call a multi-parameter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We do not need to supply an argument for each parameter of the function if we
    define default values. Let's look at how to configure default values for our parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a parameter's default values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define default values for any parameter by using the equal to operator
    (`=`) within the function definition when we declare the parameters. The following
    example shows how to declare a function with a parameter''s default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function declaration, we have defined one parameter without a default
    value `(name:String)` and one parameter with a default value `(greeting: String
    = "Bonjour")`. When a parameter has a default value declared, we can call the
    function with or without setting a value for that parameter. The following example
    shows how to call the `sayHello()` function without setting the `greeting` parameter,
    and also how to call it when you do set the `greeting` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `sayHello(name:"Jon")` line, the function will print out the message
    `Bonjour Jon` since it uses the default value for the `greeting` parameter. In
    the `sayHello(name:"Jon", greeting: "Hello")` line, the function will print out
    the message `Hello Jon` since we have overridden the default value for the `greeting`
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare multiple parameters with default values and override only the
    ones we want by using the parameter names. The following example shows how we
    would do this by overriding one of the default values when we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared a function with three parameters, each
    with a default value. We then called the function, leaving the `name2` parameter
    with its default value, while overriding the default values for the remaining
    two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example will print out the message `Hello Jon and Kailey`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how we can return multiple values from a function.
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple values from a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of ways to return multiple values from a Swift function.
    One of the most common ways is to put the values into a collection type (an array
    or dictionary) and then return the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to return a collection type from a Swift function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared the `getNames()` function with no parameters
    and a return type of `[String]`. The return type of `[String]` specifies the return
    type to be an array of string types.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, our array could only return string types. If we needed
    to return numbers with our strings, we could return an array of the `Any` type
    and then use typecasting to specify the `object` type. However, this would not
    be a good design for our application, as it would be prone to errors. A better
    way to return values of different types would be to use a `tuple` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we return a tuple from a function, it is recommended that we use a named
    tuple to allow us to use the dot syntax to access the returned values. The following
    example shows how to return a named tuple from a function and access the values
    from the named tuple that is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we defined the `getTeam()` function, which returned
    a named tuple that contains three values: `String`, `Int`, and `Double`. Within
    the function, we created the tuple that we were going to return. Notice that we
    did not need to define the tuple that we were going to return as a named tuple,
    as the value types within the tuple matched the value types in the function definition.
    We can now call the function as we would any other function, and use the dot syntax
    to access the values of the tuple that is returned. In the preceding example,
    the code would print out the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous sections, we returned non-nil values from our function; however,
    that is not always what we need our code to do. What happens if we need to return
    a nil value from a function? The following code would not be valid and would cause
    a `Nil is incompatible with return type String` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code throws an exception because we have defined the return type as a
    string value, but we are attempting to return a `nil` value. If there is a reason
    to return nil, we need to define the return type as an optional type to let the
    code calling it know that the value may be nil. To define the return type as an
    optional type, we use the question mark (`?`) in the same way as we did when we
    defined a variable as an optional type. The following example shows how to define
    an optional return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would not cause an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set a tuple as an optional type, or any value within a tuple as
    an optional type. The following example shows how we would return a tuple as an
    optional type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we could return a tuple as it was defined within
    our function definition or `nil`; either option is valid. If we needed an individual
    value within our tuple to be `nil`, we would need to add an optional type within
    our tuple. The following example shows how to return a value of nil within the
    tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we set the `percent` value to either `Double` or `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how we can add external parameter names for our functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding external parameter names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples in this section, we defined the parameters' names
    and value types in the same way we would define parameters in C code. In Swift,
    we are not limited to this syntax as we can also use external parameter names.
  prefs: []
  type: TYPE_NORMAL
- en: External parameter names are used to indicate the purpose of each parameter
    when we call a function. An external parameter name for each parameter needs to
    be defined in conjunction with its local parameter name. The external parameter
    name is added before the local parameter name in the function definition. The
    external and local parameter names are separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use external parameter names. But before we do, let''s
    review how we have previously defined functions. In the following two examples,
    we will define a function without external parameter names, and then redefine
    it with external parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `winPercentage()` function has three parameters.
    These parameters are `team`, `wins`, and `loses`. The `team` parameter should
    be a `String` type, while the `wins` and `loses` parameters should be `Int` types.
    The following line of code shows how to call the `winPercentage()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the same function with external parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we redefined the `winPercentage()` function with
    external parameter names. In this redefinition, we have the same three parameters:
    `team`, `wins`, and `losses`. The difference is how we have defined the parameters.
    When using external parameters, we define each parameter with both an external
    parameter name and a local parameter name, separated by a space.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the first parameter had an external parameter name
    of `baseballTeam` and an internal parameter name of `team`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call a function with external parameter names, we need to include the
    external parameter names in the function call. The following code shows how to
    call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While using external parameter names requires more typing, it does make your
    code easier to read. In the preceding example, it is easy to see that the function
    is looking for the name of a baseball team, the second parameter is the number
    of wins, and the last parameter is the number of losses.
  prefs: []
  type: TYPE_NORMAL
- en: Using variadic parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **variadic** parameter is one that accepts zero or more values of a specified
    type. Within the function''s definition, we define a variadic parameter by appending
    three periods (`...`) to the parameter''s type name. The values of a variadic
    parameter are made available to the function as an array of the specified type.
    The following example shows how we would use a variadic parameter with a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `sayHello()` function takes two parameters. The
    first parameter is of the `String` type, which is the greeting to use. The second
    parameter is a variadic parameter of the `String` type, which is the names to
    send the greeting to. Within the function, a variadic parameter is an array that
    contains the type specified; therefore, in our example, the `names` parameter
    is an array of `String` values. In this example, we used a `for-in` loop to access
    the values within the `names` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code shows how to call the `sayHello()` function with
    a variadic parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code prints a greeting to each of the names, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at what `inout` parameters are.
  prefs: []
  type: TYPE_NORMAL
- en: inout parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to change the value of a parameter and we want those changes to persist
    once the function ends, we need to define the parameter as an `inout` parameter.
    Any changes made to an `inout` parameter are passed back to the variable that
    was used in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Two things to keep in mind when we use `inout` parameters are that these parameters
    cannot have default values and that they cannot be variadic parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use `inout` parameters to swap the values of two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will accept two parameters and swap the values of the variables
    that are used in the function call. When we make the function call, we put an
    ampersand (`&`) in front of the variable name, indicating that the function can
    modify its value. The following example shows how to call the `reverse` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we set variable `one` to a value of `One` and variable
    `two` to a value of `Two`. We then called the `reverse()` function with the `one`
    and `two` variables. Once the `reverse()` function has returned, the variable
    named `one` will contain the value `Two`, while the variable named `two` will
    contain the value `One`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things to note about `inout` parameters: a variadic parameter cannot be
    an `inout` parameter and an `inout` parameter cannot have a default value.'
  prefs: []
  type: TYPE_NORMAL
- en: Omitting argument labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the functions in this chapter have used labels when passing arguments into
    the functions. If we do not want to use labels, we can omit them by using an underscore.
    The following example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the underscore prior to the `name` label in the parameter list. This
    indicates that the `name` label should not be used when calling this function.
    Now, we are able to call this function without using the `name` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This call would print out `Hi Jon`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's put what we have covered together and see a more complex example.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reinforce what we have learned in this chapter, let''s look at one more
    example. For this example, we will create a function that will test whether a
    string value contains a valid IPv4 address. An IPv4 address is the address assigned
    to a computer that uses the **Internet Protocol** (**IP**) to communicate. An
    IP address consists of four numeric values that range from `0-255`, separated
    by a dot (period). The following is a code example of a valid IP address; that
    is, `10.0.1.250`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since the sole parameter in the `isValidIp()` function is an optional type,
    the first thing we do is verify that the `ipAddR` parameter is not `nil`. To do
    this, we use a `guard` statement with optional binding. If the optional binding
    fails, we return a Boolean `false` value because `nil` is not a valid IP address.
  prefs: []
  type: TYPE_NORMAL
- en: If the `ipAddr` parameter contains a non-nil value, we split the string into
    an array of strings, using the dots as delimiters. Since an IP address is supposed
    to contain four numbers separated by a dot, we use the `guard` statement again
    to check whether the array contains four elements. If it does not, we return `false`
    because we know that the `ipAddr` parameter did not contain a valid IP address.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `split()` function of the `String` type to split the string
    into four substrings, where each substring contains one `octet` of the address.
    These substrings are stored in the `octets` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we loop through the values in the array that we created by splitting
    the original `ipAddr` parameter at the dots and passing the values to the `validOctet()`
    function. If all four values are verified by the `validOctet()` function, we have
    a valid IP address and we return a Boolean `true` value; however, if any of the
    values fail the `validOctet()` function, we return a Boolean `false` value. Now,
    let''s look at the code for the `validOctet()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `validOctet()` function has one `String` parameter, named `octet`. This
    function will verify that the `octet` parameter contains a numeric value between
    `0` and `255`; if it does, the function will return a Boolean `true` value. Otherwise,
    it will return a Boolean `false` value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered what functions are and how to use them. You will
    use functions in every serious application that you write. In the next chapter,
    we will look at classes and structures. Classes and structures can contain functions,
    but these functions are known as methods.
  prefs: []
  type: TYPE_NORMAL
