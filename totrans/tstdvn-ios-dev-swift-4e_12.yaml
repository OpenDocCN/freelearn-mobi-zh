- en: '*Chapter 9*: Test-Driven Input View in SwiftUI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2019, Apple introduced **SwiftUI** as a new way to build user interfaces
    for apps on Apple platforms. In contrast to user interfaces built with UIKit,
    SwiftUI views are a function of some kind of state. As a result, testing such
    views can be very easy. In a test, we would have to set the state and assert that
    the expected user interface elements are present.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the engineers in charge at Apple believe that there is no value
    in testing user interfaces. They believe that to prove the user interface looks
    and works as expected, it's enough to run the app and check with your eyes. This
    might be true for an app as simple as the one we are building in this book. But,
    if you have a look in the App Store, you will find most of the apps (if not all)
    are way more complicated. Usually, apps consist of many views and some of them
    are only visible in some rare cases. Ensuring that those views work for all input
    values and environment parameters is a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: Also, think about refactoring. Apps are never finished. We need to change and
    add features all the time. How do engineers make sure that all previous features
    still work?
  prefs: []
  type: TYPE_NORMAL
- en: Automatic tests performed by a computer are faster than manual tests by several
    orders of magnitude. In my opinion, engineers not using automatic tests, even
    for user interfaces, wastes time and money.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do we do when we want to build a user interface using SwiftUI and still
    rely on the advantages of test-driven development? Fortunately, there is a third-party
    library called **ViewInspector** on GitHub that fills this gap. In this chapter,
    we will add this library to our project and explore how we can write unit tests
    for SwiftUI code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is structured into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ViewInspector package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ViewInspector to test a simple view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing button actions with ViewInspector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by adding ViewInspector to our test target.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ViewInspector package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ViewInspector is an open source library that you can find on GitHub: [https://github.com/nalexn/ViewInspector](https://github.com/nalexn/ViewInspector).
    To add it to our project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **File** | **Add Packages** menu item in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type into the search field the URL of the package, `https://github.com/nalexn/ViewInspector`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Add the ViewInspector package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.01_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Add the ViewInspector package
  prefs: []
  type: TYPE_NORMAL
- en: Click **Add Package**.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode presents a new window in which we can set the target to which the package
    should be added. Select the **ToDoTests** target. Then click **Add Package** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package is now added to the **ToDoTests** target and we can use it in our
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using ViewInspector to test a simple view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The view we are going to build will be used to add new to-do items to the list
    of items. This means it needs input fields for all information a to-do item can
    hold. So, let's look into that aspect in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a title text field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, we start with the test. Follow these steps to add a text field for
    the title of a to-do item to the input view:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `ToDoItemInputViewTests`. Remove the two template test methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `ViewInspector` library and the main target (`ToDo`) so that it
    is testable (`@testable`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we can write tests for a SwiftUI view, we first need to extend it with
    the `Inspectable` protocol from the `ViewInspector` library. Add the following
    line right above the test case class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, Xcode complains that it **Cannot find type 'ToDoItemInputView'
    in scope**. That was expected as we haven't added this type yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **ToDo** group in the project navigator and add a SwiftUI file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Select the SwiftUI template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.02_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Select the SwiftUI template
  prefs: []
  type: TYPE_NORMAL
- en: 'Put `ToDoItemInputView.swift` in the **Save As** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The name of the new file is ToDoItemInputView.swift'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.03_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The name of the new file is ToDoItemInputView.swift
  prefs: []
  type: TYPE_NORMAL
- en: Now, the error in the test code is gone and we can continue with the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a property for the system under test and for the data object holding the
    information for the new to-do item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will fill `toDoitemData` with the data the user puts into the view, and when
    they are finished, we will create a `ToDoItem` instance from that data.
  prefs: []
  type: TYPE_NORMAL
- en: Again, Xcode tells us that something is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `ToDoItemData` as the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of this file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This new type needs to be the `ObservableObject` type because we want to use
    it as the state of our SwiftUI view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `ToDoItemInputViewTests` class and replace `setUpWithError()`
    and `tearDownWithError()` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code does not compile, as the initializer of `ToDoItemInputView`
    doesn''t take any arguments. To fix the compilation error, add the following property
    to `ToDoItemInputView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, Xcode shows an error in the `ToDoItemInputView_Previews` structure because
    the new property is missing in the initializer of `ToDoItemInputView`. Replace
    the contents of the `ToDoItemInputView_Previews` structure with the following
    code to fix this error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s get back to the test case class. Add the following fragment of
    a test method to `ToDoItemInputViewTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `toDoItemData` type has no `title` property. We will fix this in the next
    step. But first, let's try to understand what is happening here.
  prefs: []
  type: TYPE_NORMAL
- en: First, we call `inspect()` on the system under test (`sut`). This is possible
    because we extended the `ToDoItemInputView` call with conformance to the `Inspectable`
    protocol. On the returned type, we can call the `find` method that returns the
    first instance of the given type, in this case, the `TextField` type. On the value
    that is returned from the `find` call, we call `setInput(_:)` to simulate user
    input to that text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `title` property to `ToDoItemData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finish the test with the following `Assert` function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that this new test fails. The test fails in the line
    where we try to find the `TextField` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of the `body` property in `ToDoItemInputView` with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests again. Now all tests pass but we haven't seen the assertion fail.
    The test failed previously because it could not find a `TextField` element in
    the body of the view. Is this a problem? It could be. If we are not careful, we
    could write an assertion that always passes. So, it is a good idea to change the
    code in a way that the assertion fails but the rest of the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `ToDoItemInputView` structure with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we have added a dummy variable to act as the binding for the text of `TextField`.
    Run the tests to confirm that the last added test now fails at the assertion.
    As we have checked that the assertion can fail, we can change the code so that
    the test passes again.
  prefs: []
  type: TYPE_NORMAL
- en: That was easy. With the help of `ViewInspector`, we were able to write a test
    for the input text field of the title for the to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add a `DatePicker` structure to allow the user
    to add due dates to to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a DatePicker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The title is the only required data of a to-do item. The date is optional. In
    the user interface of the input view, we want to use a `DatePicker` structure
    for the input of the date value. We will use a toggle to show the `DatePicker`
    structure when the user wants to add a date for that to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we first need a test that asserts that the view initially doesn''t
    show a date picker. Add the following test method to `ToDoItemInputView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we assert that the code in the parameter of the `XCTAssertThrowsError`
    function throws an error. This means we test that there is no `DatePicker` in
    the view. The test fails if the `find` method finds a `DatePicker`.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to do anything to make this test pass. It already passes. We could
    add a `DatePicker` to see it failing. Actually, we will do that next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toggle element to show and hide the date picker will be bound to a `@State`
    property with the `withDate` property defined in `ToDoItemInputView`. As a result,
    the state of the toggle element will be reflected in the value of the `withDate`
    property. Interacting with a `@State` property from a unit test needs some change
    of the view code. We will start the implementation of the date input with the
    following change:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `ToDoItemInputView` structure with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added here a closure with a `didAppear` name that is called in the `onAppear`
    modifier of the `VStack` structure. We need a `VStack` structure or something
    similar here because, later in these steps, we will add more elements to the body
    of the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this preparation we can add the first fragment of the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start the test method with an expectation. It is needed here to make updating
    the `@State` property accessible in the test. The reason for that lies in the
    implementation details of view updates in SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: All the communication with the system under test has to be put into the closure
    of the expectation we define using `sut.on(\.didAppear) {}`.
  prefs: []
  type: TYPE_NORMAL
- en: In the closure, we first switch the toggle to make the date picker appear. Next,
    we search for the `DatePicker` and we try to set its date. Then we access the
    date of the `toDoItemDate` property. The test is not finished, but we have to
    pause here because the `Date` property is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Below the closure, we ask the `ViewInspector` library to host the system under
    test. This triggers the `onAppear` closure and makes working with `@State` properties
    possible. Finally, we have to wait for the expectation to be fulfilled. We don't
    have to call `fulfill()` on the expectation ourselves. This is managed by the
    `ViewInspector` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemData` and add the `Date` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can finish the test by adding the `Assert` function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests to confirm that this new test is failing. It fails because it
    can't find the toggle. Let's add the toggle in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property for the state of the toggle we are about to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, replace the contents of the computed `body` property with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the test fails because it can't find the date picker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the date picker as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, `test_whenWithDate_shouldAllowDateInput` passes but `test_whenWithoutDate_shouldNotShowDateInput`
    fails. This is a good thing because we haven't seen this test fail until now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make both tests pass, replace the code of the computed `body` property with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests to confirm that all tests pass again.
  prefs: []
  type: TYPE_NORMAL
- en: In making the last test pass, we learned what we have to do to test changes
    where a `@State` property is involved. This was shown here because you need to
    know this when you start writing tests for SwiftUI views.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to test changes to `@State` properties, let's refactor
    the test code and the implementation to make both easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the test code and the implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our app, it would be better if we move the `withDate` property to `ToDoItemData`
    because we need this information when we try to create the to-do item. Follow
    these steps to move that property to `ToDoItemData`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemInputTests` and replace `test_whenWithDate_shouldAllowDateInput()`
    with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests. This test now fails because we can't interact with a `@State`
    property this way.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `@State var withDate = false` line from `ToDoItemInputView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemData` and add the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now in `ToDoItemInputView`, replace all occurrences of `withDate` with `data.withDate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we have removed the `.onAppear` call below the closing brace of `VStack`.
    As it is not needed anymore, you can also remove the `didAppear` property from
    `ToDoItemInputView`.
  prefs: []
  type: TYPE_NORMAL
- en: Run all tests to confirm that all tests now pass again.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an input view for the title and the date of a to-do item. Next,
    we need a text field for the item description.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another text field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add another text field to the input view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemInputViewTests` and add the following incomplete test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This looks similar to the test we wrote for the `title` property, but this time
    we have to specify which `TextField` we are searching for. We added a `where`
    closure to find the text field with a `Description` label text. Within the `where`
    closure, we use the inspection capabilities of `ViewInspector` to find the string
    of the text of `labelView` of `TextField`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test does not compile, because the `itemDescription` property is missing
    in `ToDoItemData`. Add the property as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can finish the test. Add the following assertion to the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemInputView` and change the `body` property so that it looks as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we could again change the code to see the assertion of the test fail,
    as we did for the test of the `title` property. As the code and the test code
    look similar, I'm confident in the test without doing that. Think for yourself
    if you would like to see the assertion fail.
  prefs: []
  type: TYPE_NORMAL
- en: To make the test for the `title` property more robust against changes in the
    user interface, add a similar `where` closure to `test_shouldAllowTitleInput`.
  prefs: []
  type: TYPE_NORMAL
- en: A to-do item can also have a location associated with it. This means we need
    another text field for the location name. You have already seen how to add a text
    field to the input view, so this is left to you as an exercise. Use the `locationName`
    property name in `ToDoItemData` and the `"Location name"` title for the title
    of `TextField`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's make the user interface a bit nicer.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, the text fields and the date picker are structured using a `VStack`
    structure. This is the easiest, but not the prettiest way to do it. The user interface
    of the input view looks like this at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The user interface of the input view when using a VStack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.04_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – The user interface of the input view when using a VStack
  prefs: []
  type: TYPE_NORMAL
- en: 'We can improve the user interface by using `Form` and `Section` structures.
    Replace the `body` property code of `ToDoItemInput` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to specify in this code that we want `Section` defined in SwiftUI because
    we already defined a section type. With this code, the user interface looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – An improved user interface with Form and Section'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – An improved user interface with Form and Section
  prefs: []
  type: TYPE_NORMAL
- en: This looks way better. Run the tests to confirm that we didn't break something.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add another text field and a button.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an address text field and a button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need another text field for the address of the to-do item. Use your gained
    experience to add it yourself to the location section of the input form. To make
    your code consistent with the code of the book on GitHub, name the property `addressString`
    in `ToDoItemData` and use the label `Address` in the `TextField` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the data for the to-do item, the user can add it to the list.
    For that task, we need a button in the user interface. Follow these steps to add
    the button:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `ToDoItemInputViewTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to see this new test fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code within the Form of the body property of `ToDoItemInputView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this code compile, we need to add the action. Add the following method
    to `ToDoItemInputView` below the `body` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests to confirm that all tests now pass.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the user interface elements needed to move on to implementing
    adding the to-do item to the list of items in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing button actions with ViewInspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user puts in the address for the to-do item. In the details view of an item,
    the app shows a map of that location. This means we need to convert the address
    of the item to a coordinate before we can add the item to the list. Apple provides
    a `GeoCoder` class for that task. We will write tests for fetching an address
    from a `GeoCoder` class in [*Chapter 10*](B18127_10_ePub.xhtml#_idTextAnchor444),
    *Testing Networking Code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we assume that we already have a class called `APIClient`
    that uses `GeoCoder` (or some similar service) to translate an address into a
    coordinate. In the test, we are going to use a mock object for that `APIClient`
    class. Follow these steps to add a protocol for the `APIClient` class and a mock
    conforming to that protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `APIClient.swift`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following protocol definition to that new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This protocol defines a function that takes a `String` instance and calls a
    `completion` handler with a `Coordinate` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `APIClientMock.swift`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of that file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this mock in place, we can write a test that asserts that the `coordinate`
    instance is fetched when the user taps the **Save** button. Follow these steps
    to add that test and the implementation that makes the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new property (`apiClientMock`) to the `ToDoItemInputViewTests` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `setUpWithError`, initialize an API client mock and pass it into the initializer
    of `ToDoItemInputView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don''t forget to set this property to `nil` in `tearDownWithError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ToDoItemInputView` doesn''t have a property for the API client. We need to
    add it before we can continue with the test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `apiClient` property to `ToDoItemInputView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As `ToDoItemInputView` is a structure, this new property changes the automatically
    generated initializer. We use this initializer in `ToDoItemInputView_Previews`
    in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `ToDoItemInputView_Previews` structure with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code, we replaced the error with another. The implementation of `APIClient`
    is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following minimal implementation to `APIClient.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can add the test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we set up the title and the address of the input data and tap
    the `coordinate` instances for the address.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `addToDoItem()` method in `ToDoItemInputView` with the following
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this implementation, we call the `coordinate(for:completion:)` method defined
    in `APIClientProtocol`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that all tests now pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the user didn''t add an address to the input form? In this case,
    the `coordinate(for:completion:)` method should not be called because there is
    no coordinate to be fetched. We need a test for this case. Add the following test
    to `ToDoInputViewTests.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it pass, change the code in `addToDoItem()` so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests to confirm that all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: After the `coordinate` has been fetched, the `addToDoItem()` method should call
    a delegate method to inform it that the input data is complete and the item can
    be constructed. Again, we will add a `delegate` protocol to define the interface
    of the `delegate` object. This helps when we create a mock object for the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add the tests and the implementation of calling the `delegate`
    protocol with the to-do item data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following protocol definition to `ToDoItemInputView.swift` outside
    of the `ToDoItemInputView` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this protocol in place, we can add a mock object to the test target. Select
    the `ToDoTests` group in the project navigator and add a Swift file with the name
    `ToDoItemInputViewDelegateMock.swift`. Add the following code to this new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can start with the test. Add the following test fragment to `ToDoItemInputViewTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we set up the `apiClientMock` property to return a dummy coordinate when
    `coordinate(for:completion:)` is called, and we create an instance of `ToDoItemInputViewDelegateMock`
    and set it to the `delegate` property of the system under test. This property
    is still missing and therefore, we have to pause writing the test and first add
    it to `ToDoItemInputView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this `delegate` property to `ToDoItemInputView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This change makes the test compile and we can continue writing the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the test method so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Usually, I try to keep all the relevant code in the test. But in this case,
    the test method is a bit messy. As an example, let's move the inspector code into
    a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extension in `ToDoItemInputViewTests.swift` below the `ToDoItemInputViewTests`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this extension we can write the last test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, this is a bit better than the original version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, replace the implementation of `addToDoItem()` with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the completion closure, we now call the `addToDoItem(with:coordinate:)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this change makes all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the user didn''t add an address for the to-do item? Add the following
    test to make sure that, in this case, the `delegate` method also gets called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, replace `addToDoItem()` in `ToDoItemInputView` with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the `address` string is empty, we call the `delegate` method without a `coordinate`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Run all tests. All tests pass again.
  prefs: []
  type: TYPE_NORMAL
- en: The input view is now complete and we can move on to implementing some networking
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing SwiftUI code works a bit differently from testing UIKit code. One reason
    for this is that SwiftUI itself works completely differently. In addition, Apple
    doesn't provide a testing framework for SwiftUI code because they believe that
    user interface code should be tested with UITest.
  prefs: []
  type: TYPE_NORMAL
- en: I don't think that's true. UITest solve a different problem. I believe you should
    have access to both kinds of tests, and you should choose the right tool for the
    problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, with ViewInspector we have a powerful third-party solution that
    fills this gap. In this chapter, we added it as a SwiftUI package to the unit
    test target. We used the package to write unit tests for SwiftUI code and build
    an input view for to-do items following test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we learned how to add SwiftUI packages to test targets and how to
    use this specific SwiftUI package to write tests for things that aren't easily
    testable without it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to write unit tests for networking code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add more convenient methods in the extension of `ToDoItemInputView` in `ToDoItemInputViewTests.swift`
    to make the tests easier to read as we did for `test_save_shouldCallDelegate()`.
    What are the advantages of these helper methods? What are the disadvantages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user provides an address, but `GeoCoder` cannot find the coordinate
    to that address, the app should show an alert and ask the user if they still want
    to save the item. Go to the GitHub repository of `ViewInspector` ([https://github.com/nalexn/ViewInspector](https://github.com/nalexn/ViewInspector))
    and find out how you can test the presentation of an alert. Then write the test
    that asserts that the alert is presented and implement that feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
