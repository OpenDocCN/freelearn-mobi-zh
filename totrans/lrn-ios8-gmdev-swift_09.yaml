- en: Chapter 9. Metal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating a game, you should understand how to display things
    on the screen. This is always taken for granted, as all frameworks have a class
    called `sprite`, in which we just give a `.png` or `.jpg` file and say `addChild`
    and `tada`; we then have an image appearing on the screen. Moreover, with just
    a few simple functions such as move, scale, and rotate, we can even transform
    the sprite's position, size, and rotation. In reality, this `sprite` class does
    a whole lot of work just to display the image on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at Metal—a new graphics library from the people
    at Apple. This graphics library will help us to display objects on the screen.
    It is a communication tool that talks to the processor, the memory, the **graphics
    processing unit** (**GPU**), and the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If you are coming from a DirectX or OpenGL background, you will see that the
    process to display stuff on the screen, otherwise known as a graphics pipeline,
    is very similar to that in Metal. Metal's graphics pipeline is programmable with
    the use of a shader language, which uses C++11 as the base. We will go through
    it in detail in this chapter. Let's get rocking with Metal!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphics pipeline and shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic Metal project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The colored quad project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The textured quad project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metal is a graphics API that is used to display anything on the screen. Metal
    is very specific to iOS 8 and above; moreover, it will only work on a device with
    an A7 chip and above. It is said that it will run ten times faster than OpenGLES.
    OpenGLES is another graphics library. Unlike Metal, OpenGLES is open source and
    works cross-platform. The trade-off here is that you can make it ten times faster,
    meaning that you can add mode particles and objects in the screen, however, you
    can't run your games on other operating systems such as Android and Windows Phone.
    Games developed with OpenGLES can be run on other devices with minor changes to
    the code. In fact, SpriteKit and SceneKit are developed by using OpenGLES. So,
    do you want to make a game with more objects on the screen or would you rather
    make your game available on other platforms? The choice is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: In Metal, for rendering anything on the screen, you have to do it in two stages.
    The first stage is the preparation or initialization stage, and the next one is
    the drawing stage. In the preparation stage, we first get access to the GPU, ready
    the resources such as vertices and buffers, and prepare the render pipeline and
    the view in which you want to the object to be rendered into. After the preparation
    stage, we can get into actually drawing the image in the "draw" stage.
  prefs: []
  type: TYPE_NORMAL
- en: The graphics pipeline and shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at these stages in detail. We'll look at the preparation stage first.
  prefs: []
  type: TYPE_NORMAL
- en: The preparation/initialization stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps are included in this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: Get device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Command queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll look at each step, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Get device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we have to get the device that will be responsible for rendering our
    object. This will let us know the capabilities of the GPU in terms on how powerful
    it is and what its features are. In Metal, it will basically tell us what device
    we are running the game on, that is, whether it is running on an iPhone, iPad,
    or OS X. It will also tell us which version of the device it is and whether it
    is an iPhone 6, 5, 4, or any other device.
  prefs: []
  type: TYPE_NORMAL
- en: Command queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we know which device we are working on, we get the next command in the
    queue. Information is sent from the CPU to the GPU in an asynchronous manner.
    This means that both the CPU and the GPU don't work on the same items at a particular
    time. When the CPU is done with the calculations, the information is fed to the
    GPU. If the GPU is busy, the information has to wait while the CPU works on the
    next process. For this, we need a queue. So basically, the command to the GPU
    waits in a queue before it can be executed. Therefore, in this step, we get the
    next free slot in the queue so that information can be fed from the CPU to the
    GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this step, we ready the vertex, which is the information that we want to
    pass to the GPU. We will declare the properties that each vertex has (for example,
    the coordinates of each vertex at a basic level). We can also provide other information,
    such as color for each of the coordinates. We also need to store this data in
    the memory so that when the command executes, the GPU will retrieve the information.
    Information is stored in buffers. For each property of the vertex, a buffer is
    created. A buffer, as we saw in the first chapter, is nothing but a location in
    the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we see that there are four coordinates specified
    **a**, **b**, **c**, and **d**, each having their own vertex and color property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resources](img/B04014_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Render pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This step is broken down into two steps. In the first step, you'll have to create
    a descriptor. A descriptor is where you initialize the pipeline. We will tell
    the pixel which format to use while rasterizing the image. We will also be passing
    in our vertex shaders and pixel shader function here. Once the descriptor is ready,
    we can pass it to the *render pipeline* state. The state now contains all the
    information for the pipeline to be easily passed around. We will look at shaders
    in a later section, as it is better understood in action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recap the following from [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex/Geometry Shader**: The information is then passed into the vertex
    shader. Vertex shaders are programmable by using shader language. The language
    is similar to C. Using this language, we can change the position, causing the
    object to move, scale, or rotate like how you can do in your `update` function
    within the game loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel/Fragment Shader**: As in the vertex shader, in which you were able
    to do vertex modification, pixel shaders will enable you to make pixel-based operations.
    As this a shader, you know that this is also programmable. Using pixel shaders,
    you can create effects such as changing the color and transparency of the texture
    provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last step is to set up and ready the view. In the view stage, we will actually
    need access to the layer attached to the view on which the object will be drawn.
    The layer is like a blank canvas that is ready to be drawn on. We get the layer
    of the view so that we can keep drawing and erasing on it.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the initialization stage; next, we will see the steps to actually
    start drawing something on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The draw stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will finally draw the vertices that we sent in the first stage. This
    stage also has a few steps that need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Start render pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get command buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the command buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start render pass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We prepare the layer for drawing the object. We assign the layer to be drawn
    onto and clear the surface with the default color.
  prefs: []
  type: TYPE_NORMAL
- en: Get command buffer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Command buffer is the place where the command for rendering is stored. We
    need to get access to the command buffer in order to execute the commands.
  prefs: []
  type: TYPE_NORMAL
- en: Draw
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, the drawing takes place on the layer. This is done by a render command
    encoder, which takes the code from the command buffer and encodes it into machine
    language in order to render the image. We pass the pipeline state and the vertex
    buffer and then draw the image. This whole step is done off screen.
  prefs: []
  type: TYPE_NORMAL
- en: Commit the command buffer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the final stage, in which image rendering has been done, and the image
    is ready to be displayed onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this theoretical knowledge with us now, let's put it all to practice
    to see how we can display something to look at on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The basic Metal project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first project, we will create a basic triangle and display it on the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Xcode project. Select **Metal** as the technology and **Swift**
    as the language for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic Metal project](img/B04014_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select a location to save the project in. In the `GameViewController.swift`
    file, we delete all the contents of the `viewDidLoad` functions, so that we can
    start from the absolute basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in the overview, the first thing that we have to do is get the
    device that the application will work on. Add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create a new constant called `device` of the `MTLDevice` type and assign
    `MTLCreateSytemDefaultDevice` to it. So now, we have direct access to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to create `commandQueue` for the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We get the command from the device and assign it to a new variable called `commandQueue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we prepare resources such as the vertex information and vertex
    buffers. To create vertex definitions, create an array at the top of the file
    called `vertexArray`, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Imagine the shape of a screen to be a rectangle, with its width and height being
    2 pixels each and the center of the screen being the origin. So, in the preceding
    array, the 0th, 2nd, and 4th values are *x* coordinates, and the 1st, 3rd, and
    5th items are the corresponding *y* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are passing in three pairs of `x` and `y` values to draw a triangle.
    For the first value, `x` is at the origin and `y` is at `.75` in the *y* direction
    from the center of the screen. The next two coordinates are to the bottom left
    and bottom right of the origin.
  prefs: []
  type: TYPE_NORMAL
- en: So now, we have our vertices ready. Next, we have to create a vertex buffer
    so that we can store these vertices in it. Create a new variable called `vertexBuffer`
    of type `MTLBuffer`, as shown in the following diagram, and assign the `vertexArray`
    variable we created along with the size of the array and `nil` for `options`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic Metal project](img/B04014_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have to create our vertex and fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shaders are small pieces of code that are compiled at runtime. There are two
    types of shaders: **vertex** and **fragment**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex shaders**: This lets us perform vertex manipulation if we want an
    outside the game code. By vertex manipulation, we mean moving, rotating, and translating
    the each of the vertices, and therefore, the whole object. This is at the basic
    level; we can perform more complex operations by using vertex shaders. The vertex
    shader gets called as many times as the number of coordinates we pass in. So in
    this case, it will be called three times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment shaders**: These can be used to perform manipulations at the pixel
    level. They can be used to make various effects such as blur, pixelate, cel shading,
    and so on. Unlike Vertex shaders, pixel or fragment shaders can be called as many
    times as required to fill the space within the triangle with a color or texture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how to write our first shader files. First, we will write a vertex
    shader. In the project file, you will already have a new file called `Shaders.metal`.
    This is the shader file for Metal, in which you will write both your vertex shader
    and pixel shader.
  prefs: []
  type: TYPE_NORMAL
- en: People with an OpenGL or DirectX background may be wondering where the other
    file is. That is one of the differences between Metal and other shader languages.
    Metal uses just one file, and in this file, you can write both the shaders. Each
    shader is not a file but a function. So later, when we pass the shader in the
    pipeline descriptor, we won't be giving the file name of the shader but the name
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: You can create more than one shader file and write your vertex shader in one
    file and pixel shader in the other, or vice versa. Metal really doesn't care which
    file you put what in, as long as you make sure that you are calling the right
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create additional metal shader files, you can go to **File** | **New** |
    **File** | **Source** and select **Metal File**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic Metal project](img/B04014_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Shaders.metal` file, remove everything and add the following code,
    as we will start from the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the top, we include the metal standard library and use namespace metal. People
    with C++ will feel at home as the metal shader language is written in a modified
    version of C++11.
  prefs: []
  type: TYPE_NORMAL
- en: The first function right after that is the vertex shader function. Shader functions
    start with the keyword vertex or fragment to denote whether the function is a
    vertex shader or a fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the vertex shader, the function has the keyword `vertex` and it returns
    a `float4`. A float 4 is like a struct with four float values: `x`, `y`, `z`,
    and `w`; or `r`, `g`, `b`, and `a`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shaders also have their own data types, such as `float`, `float2`, `float3`,
    and `float4` or `int`, `int2`, `int3`, and `int4`. Since shaders usually deal
    with vertices or colors which are a `float3` with `x`, `y`, and `z` values and
    `float4` with `r`, `g`, `b`, and `a` values.
  prefs: []
  type: TYPE_NORMAL
- en: You can also perform mathematical operations on these values. For example, if
    you have two `float3` variables called `vert1` and `vert2` and you multiply `vert1`
    and `vert2`, then the resultant `vert3` will be created with the `x` values multiplied
    to create a new `x` value. And similarly, `y` and `z` values will be multiplied
    with `vert1` and `vert2` to create `vert3` with the new `x`, `y`, and `z` values.
  prefs: []
  type: TYPE_NORMAL
- en: After the return type, we specify the name of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The function takes in two attributes. The double rectangle bracket signifies
    that it is an attribute. Attributes are like properties. Here, we pass the `vertexArray`
    through the buffer we created. In the attribute, we pass the vertex array through
    the buffer at index `0`. Later, you will see that we assign our `vertexBuffer`
    an index value, which refers to the `0` position here, so that the shaders knows
    which buffer is the vertex buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The next attribute that the function takes in is the vertex ID. This is generated
    automatically, depending upon how many vertices we pass in. We pass in three pairs
    of *x* and *y* coordinates, so three vertex IDs will be generated for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the function it returns a `float4` vertex for each of the vertex IDs.
    As we have to return a float 4, we add the extra `0` and `1` at the end. You might
    be wondering how we are returning four values when there are only returning three
    values: `vertex_array[vid]`,`0`, and `1`. In shader languages, you can club `x`
    and `y` in a single variable. Here `vertex_array[vid]` is one variable, but it
    actually holds two objects in it, that is, the `x` and `y` values for that coordinate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create the function for the fragment shader. In a similar way to the
    vertex shader, we start with the shader type followed by return type and then
    provide the name of the function. We are not passing anything into the function
    yet. It does return a `float4` value. As it is a fragment shader and fragment
    shaders are used for making pixel manipulation, the four values here are the RGBA
    values of color. So here, the triangle that we will be drawing will be purple
    in color. If you want all four colors to be of the same value, we can perform
    the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will return all RGBA values as equal to `0.56`. So the triangle will be
    gray in color and will be transparent as the value of alpha `a` is also at `0.56`.
    This way of writing values looks very odd as we don't follow this practice in
    regular mathematics, but with constant use, you will get used to it and, in fact,
    appreciate it, as it is more convenient for programming shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fragment shaders can also be called pixel shaders as they are the same for the
    most part, but make sure that while creating a pixel shader function, you use
    the `fragment` keyword, otherwise Metal won't understand what you are talking
    about.
  prefs: []
  type: TYPE_NORMAL
- en: So, we are done with our shader file; let's now continue with our regular code
    in `GameViewController.swift` file.
  prefs: []
  type: TYPE_NORMAL
- en: We have added the shader function to our shader library. Once the shader is
    compiled, it is added to the `shader` library so that it can be retrieved later
    to save effort in compiling the shader again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the library from the device and add the shader functions to it. We also
    create new constants for getting the vertex and shader functions from the device,
    which will be required to pass in the render descriptor, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the render pipeline descriptor. First, we have to create a
    descriptor to assign to a state, later on. So, let''s create a new pipeline descriptor,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the descriptor, we provide the vertex and shader function and the pixel
    format to be used, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Pixel formats specify the order of the color components, bit depth per component,
    and data type. There are more than two dozen formats. To know more about the different
    types of pixel formats, you can visit Apple's documentation at [https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a `RenderPipeline` state from the descriptor, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A new variable, `pipelineState`, of the `MTLRenderPipeLineState` type is created,
    and the `pipeLibeStateDescriptor` constant is passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a layer of type `CAMetalLayer` and add it to the current view,
    so that we can draw the object on it. So, add the following code to prepare the
    view and add the layer to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To the `metalLayer` constant, we assign the device, pixel format of layer (the
    same as what we assigned in the pipeline descriptor), and the frame size, which
    is equal to the size of the frame of the view (frame size is the same as the screen
    size). Finally, add `metalLayer` as a sublayer to the current view layer.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that is required for setting up everything. We can move on to the
    next stage, that is, actually drawing the triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we create a render pass descriptor. Before we can create
    it, however, we need to get a reference to the next drawable texture from the
    layer as it will be required to pass it to the render descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the render descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we create a new constant called `renderPassDescriptor`, of type `MTLRenderPassDescriptor`.
    First, we assign the texture of the drawable layer so that whatever it renders
    gets drawn in the texture. So, the texture of the drawable layer is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the load action is called. Once loaded, the layer is first cleared with
    a color. Then, we pass a color with which the layer will be cleared. Here, we
    pass a purple color.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, our descriptor is ready. Next, we have to render the layer and the
    triangle. So first, we get the command buffer from the command queue. These are
    the commands that are stored in the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All these commands need to be encoded in the machine language through `MTLRenderCommandEncoder`.
    We pass the `renderPassDescriptor` variable here to encode the render code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set the pipeline and vertex buffer state in the encoder. While
    passing in `vertexBuffer`, we have to pass in the offset and index buffer values.
    As we created a new buffer, the offset value is `0` and for index, we pass `0`.
    This index value is what the vertex shader referred and passed in `[[buffer(0)]]`
    to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can draw the triangle by creating a primitive type. Eventually,
    all shapes are made of triangles, as we saw in the example of the ship in the
    first chapter. The number of vertices and their positions define the shape of
    the object. Here, we are creating a single triangle shape, so we are passing three
    vertices to create a triangle. This same triangle primitive is used to make squares,
    cubes, teapots, spheres, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have finally drawn, so we can end the encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we have drawn the triangle, we still need to present it on the screen.
    In the next step, we will provide the texture and commit it to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all. Finally, you will be able to see the purple triangle with the
    yellow background on the screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic Metal project](img/B04014_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congrats! You've successfully completed it.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is just for drawing the triangle, but I hope you are now able to
    appreciate the effort. The problem is that if you do any of the steps incorrectly,
    the chances are that the triangle won't get displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The code is also kept very basic. We can definitely optimize the code by adding
    a renderer class and creating the vertex array as a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will create a square. This time, we will pass colors
    for each of the coordinates instead of typing the color value in the fragment
    shader function.
  prefs: []
  type: TYPE_NORMAL
- en: The colored quad project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a colored square, we need to make some changes to `vertexArray`,
    as we will need to pass six vertices instead of three. We have to pass six vertices
    because, as you saw earlier, we can draw only in triangles. So, we need three
    points for the triangle to form the top part of the square and three more points
    to form its bottom part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the `a` and `c` points are repeated to form the second triangle,
    because the diagonal of the square are the same points for the first triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![The colored quad project](img/B04014_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that in the vertex array, we are now passing four values per vertex instead
    of two, as we did in the case of the triangle. This will simplify matters while
    modifying the shader function.
  prefs: []
  type: TYPE_NORMAL
- en: The values of the coordinates provided are the `x`, `y`, and `z` values, and
    an additional fourth parameter `w` is also passed in. Like the `z` value in two-dimensional
    space, it doesn't have much significance yet. Later, when you create a three-dimensional
    object, the `w` parameter plays a major role. But, as of now, let the value remain
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, as we saw while creating the triangle, the view is a 2 x 2 rectangle
    with the origin in the center. As we are passing in coordinates between `1` and
    `-1` in the *x*-*y* direction, the rectangle will actually cover the whole screen.
    If you still want to see the yellow background, change the value `1` to a smaller
    value, as we did in the case of the triangle. Do not change the values corresponding
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to passing vertices, we will also pass color values for each of these
    coordinates as a buffer in the code to create a new array called `colorArray`,
    as shown in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These are simple RGBA values for the respective coordinates. Here, a means that
    *red* = `1`, *green* = `0`, *blue* = `0`, and *alpha* = `1`. The values of each
    of these lie between `0` and `1`. So here, `a` will be all red in color. We can
    create custom colors by keeping red as `1` and adding more green or blue to the
    mix, as in the case of `c` and `d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in a similar way to how we created a `vertexBuffer`, we have to create
    a `colorBuffer` of type `MTLBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We pass in the `colorArray` that we created and the size of the whole array.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to make any changes to the device, layer, or the render pipeline
    in the code. But we do need to change the vertex and shader functions, as we are
    going to be passing information on the color.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any shader language, we can also create our own data types. A new data type
    called `VertexInOut` is created by using a struct in the shader file. So type
    the following code in the `Shader.metal` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We create a struct with two `float4` values, of which one is for position and
    the other is for the color. The position with double square brackets is used to
    indicate that we will be passing and retrieving the position attribute through
    the position property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vertex` function is changed, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A packed variable means that you cannot access each of the components individually,
    unlike a regular `float4`. For example, in a regular `float4` that has position
    data, we can access the `x`, `y`, `z`, and `w` values, but in a packed `float`,
    we cannot do that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first tell the `vertex` function type with the `vertex` keyword; we
    return a type called `VertexInOut` that we created earlier and provide the name
    of the function name. We provide the vertex ID, the position buffer with index
    `0`, and the color buffer with index `1` to the function.
  prefs: []
  type: TYPE_NORMAL
- en: In the function, we create a new variable called `outVertex` of type `VertexInOut`,
    assign the position and color values for each of the vertex IDs, and then return
    the `outVertex` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make changes to the fragment shader function, as the color
    that is passed in through the buffer needs to be applied to the cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the fragment shader, we use a `fragment` keyword to specify that it is a
    fragment shader, to return a `half4` (which is like a `float4` but consumes less
    memory), and to provide a name for the `shader` function. The function takes in
    the `VertexInOut` variable. The `[[stage_in]]` part is used to signify that the
    operation will have to be done on a per pixel basis. In the function, we ask it
    to return the typecast color value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about `stage_in` can be found at [https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we added a new color buffer and increased the number of vertices, we have
    to make changes to the `renderEncoder`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We set a new vertex buffer and pass the color buffer and the index value of
    `1`. In `drawPrimitives`, we are still creating a primitive of type triangle,
    but this time it's with six vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as we have changed the shader functions, we need to update the names
    in the pipeline, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that it is all built, we can see the colored square, or quad, as it is
    generally known:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The colored quad project](img/B04014_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might be wondering that when you passed in four colors for only the four
    vertices, how come the whole screen is colored and the colors are also merging.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader function gets called depending upon the number of vertices
    passed in. So the vertex shader function got called six times. On the other hand,
    the fragment shader function is actually called as many times as is required to
    fill the area generated by each triangle primitive. The colors are interpolated
    between the points, depending upon the distance from a coordinate. For this example,
    the bottom left coordinate was passed the color value of green. As it moves away
    from the bottom-left corner, the color slowly merges with other colors, thus reducing
    the value of green. So at the center, we have a mix of all the colors. This is
    a general feature of any fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: The texture quad project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next project, we will create a textured quad object. This is the basic
    building block of a sprite class. Here, we will be taking an image and pasting
    it on top of the quad or square that we created in the earlier project.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why I said that it is a basic building block for a sprite class is
    that we won't be able to move, rotate, or scale the sprite; we will just be displaying
    the sprite on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to referring to the process of adding a sprite to any quad in a similar
    way to adding wallpaper to wall, we can add the wallpaper right-side up or upside
    down on the wall. Similarly, while adding images to quads, we have to specify
    which way is up, otherwise the sprite will be pasted upside down or sideways on
    the quad.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we have to pass in one more array of coordinates, which are called
    texture coordinates. The texture coordinates are different than vertex coordinates
    such that the vertex coordinates are with reference to the screen coordinates
    system, with the center of the screen being the origin. Refer to the image provided.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are working in 2D, so we can call it the screen coordinates system, which
    is the same as the world coordinate system for convenience for now, but in 3D
    it is actually the world coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: The texture coordinate system is with respect to each quad or rectangle. Moreover,
    the top left of the quad is the origin for the texture coordinate system. So,
    for moving the quad around the screen, you will change the values in the vertex
    array. The texture coordinates will be changed to actually move the image around
    within the quad.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with all that theory out of the way, let''s create a new array called `textureCoordsArray`,
    as shown here. But before that, change `vertexArray` and reduce the size of the
    quad that we created earlier, so that we can have a better understanding of what
    is happening with the texture coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the texture coordinate array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'While creating a textured quad, there are two things that we need to pay close
    attention to:'
  prefs: []
  type: TYPE_NORMAL
- en: The `vertex` array provided for each triangle set needs to be in the anti-clockwise
    direction. So, for the first three position vertices in the vertex array, the
    order needs to be `abc` and `acd` respectively for both triangles, otherwise the
    texture will not be displayed properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the `vertex` array and texture coordinate needs to be the same;
    if the vertex array order is `abc` and `acd`, then the texture coordinate order
    needs to be specified in the same order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The texture quad project](img/B04014_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, the red letters **a**, **b**, **c**, and **d** denote
    the vertex coordinates, and the green coordinates denote the texture coordinates.
    The red origin is the origin of the vertex coordinate, and the green origin is
    the origin of the texture coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the texture coordinates ready, we have to create a texture buffer of the
    type `MTLBuffer` and pass in the texture coordinate array into it, along with
    the size of the array. This is similar to how we created buffers earlier for the
    respective arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have to load the texture that we want to paste onto the quad. For this,
    we import the `Bg2.png` files that we used in the SpriteKit project. Add the following
    lines of code at the end of the initialization stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the file from the local bundle location. We get the path to the
    file by passing the name of the file along with the extension. The data has to
    be then retrieved using the `NSData` method, in which we pass the path, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get the image from the data and store it in a constant of type `UIImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then, we get the width and height and specify the color space for the image.
    A color space decides how the colors are to be interpreted. There are other ways
    in which colors can be stored, apart from the RGBA values; for example, we can
    provide colors in the CMYK format. As the color values in the image are specified
    in RGB, we have to specify it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The width and height are obtained using the `CGImage` class, so we convert
    the image from the `UIImage` type to the `CGImage` type in this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To store each pixel of the image, we need to specify the size of the data of
    the whole image, so memory is created for the data to be written into. Each pixel
    takes up 4 bytes of memory space. So to get the memory occupied by the whole image,
    we have multiply the width with the height and then multiply these values by four,
    which will give the data value for the bitmap image. This value is stored in a
    `bitmapData` constant as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, we assign the number of bytes per pixel in a constant
    called `bytesPerPixel`. Also, we create a `bytesPerRow` constant to get the number
    of bytes per row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to specify how many bits does each component in a pixel take.
    A pixel is made up of `R`, `G`, `B`, and `A` values. For storing each value, we
    require 8 bits each. So for storing each RGBA value, we need 32 bits in total.
    As we''ll be requiring the value of bits per pixel component later on, we store
    the value in a constant called `bitsPerComponent` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a context that creates the environment by storing all the required
    data of the image. To the context we have to provide `bitmapData`, width and height
    of the image, bits per component, bytes per row, and `colorSpace` and `bitmapInfo`
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the bitmap information, we specify if there is an alpha channel in the image,
    the location of the alpha channel, and if the values are integers or float values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get the rectangular size of the image. We create a `rect` variable
    of type `CGRect` and pass in the origin and the width and height of the image,
    as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get the image and store the RGBA data into `bitmapData` through the
    context. We first clear the context and then pass in the context, the rectangle,
    and the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For loading the texture into Metal, we need a texture descriptor, which stores
    all the relevant information. We create a new constant called `textureDescriptor`
    and a texture descriptor with the pixel format of RGBA8 uniform normal and pass
    in the width, height, and the data if we want the image to be **mipmapped**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mipmap, as we saw in SceneKit, will create a lower resolution of the image
    and display it if the camera is far away from the texture to reduce the workload
    on the system, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a texture of type `MTLTexture` and pass in the texture descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the replace region function of type `MTLTexture` to replace
    the pixels with the image data that is stored in `bitmapData`. We pass in the
    region that is basically a rect and then we specify `mipmapLevel`, which is kept
    at `0` and sliced to determine which surface of the quad we will paste the image
    onto, as we just have one quad we specified as `0`. If we had more quads, such
    as a cube, we would have to specify values other than `0` for other faces. Next,
    we pass the `bitmapData`, which has the RGBA of the image stored in it; next,
    we pass in the `bytesPerRow` and `bytesPerImage` values in, as shown in the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we are passing in a texture coordinate buffer and we need a texture to be
    drawn, we have to make some changes to the shader file. So, go to the shader file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change the `VertexInOut` struct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the highlighted code, the user keyword is used in shaders while specifying
    attributes that are user-defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As the `textureCoordinate` buffer needs to be passed in, along with the position
    and color information, we pass it with the buffer index `2`. Also, while returning
    `outVertex`, we will assign the texture coordinate for that vertex ID in the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we also need to make changes to the `fragment` shader function, as we
    will be passing the texture into the fragment shader. So draw it on the quad,
    as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Along with the `stage_in` parameter, which we passed last time, we are also
    going to be passing the texture into the fragment shader with an index value of
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In the function to actually pick the color, a sampler is used. The sampler will
    decide how to pick the color from the texture that is passed in. The sampler is
    set as a `constexpr`, or a constant expression that is similar to a `const` type.
  prefs: []
  type: TYPE_NORMAL
- en: The sampler picks the colors, depending on the texture coordinates from the
    texture 2D that were provided using the `text2D.sample` function. The resultant
    color is stored and returned by the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `renderEncoder`, add the following highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that although `vertexBuffer` and texture have the same index, they are
    treated differently, as `vertexBuffer` is one type of buffer that is separate
    from a texture. As the `textureCoordinate` buffer is a type buffer, we have to
    pass in an index value of `2` as we are already passing `0` and `1` for the vertex
    and the color buffer respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make changes to the pipeline descriptor to use the newly created fragment
    shader, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: And finally, there is one more thing to do, which is to build it and run!
  prefs: []
  type: TYPE_NORMAL
- en: '![The texture quad project](img/B04014_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we have gone full circle in this book. The first thing that you learned
    in 2D SpriteKit game development was how to add an image to the scene. We typed
    in three lines of code and the image appeared on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, we have to do all this to get a simple image onto the screen. But,
    as I said earlier, this is just the beginning; we still haven't seen how to move,
    rotate, or scale the quad.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't yet looked at the depth buffer, which decides whether a portion of
    the image needs to be drawn on screen or not, depending on any other object that
    is in front of the current object.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have only looked at 2D. We haven't yet created a cube, for which additional
    vertices will be required. Deeper knowledge of algebra, trigonometry, and matrices
    will be required. Additional understanding of projections and model space, world
    space, view space, and screen space will be required, all of which are integral
    parts of graphics programming.
  prefs: []
  type: TYPE_NORMAL
- en: It's needless to say that these topics are way beyond the scope of this book.
    In fact, a whole book could be dedicated to graphics programming using Metal,
    while another book could be dedicated to using Metal Shader language to create
    cool effects.
  prefs: []
  type: TYPE_NORMAL
- en: For learning Metal, I recommend learning OpenGLES first as it has been there
    for so many years. Once you have a good understanding of that, you can put the
    knowledge into experimentation with Metal.
  prefs: []
  type: TYPE_NORMAL
- en: For learning OpenGLES, I recommend *Building Android Games with OpenGLES*. Although
    it teaches development for Android as OpenGLES is cross-platform, you can use
    the same concepts for iOS game development. The link to the video can be found
    at [https://www.packtpub.com/game-development/building-android-games-opengl-es-video](https://www.packtpub.com/game-development/building-android-games-opengl-es-video).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to create a simple triangle, quad, and a texture
    quad, and how to display these to the screen. You scratched the surface of graphics
    programming and learned the meaning of terms such as vertices, buffers, textures,
    and shaders.
  prefs: []
  type: TYPE_NORMAL
- en: This is merely the start of the learning process; there is still a lot to learn
    as graphics programming is a vast and deep subject, with courses specifically
    designed for it.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this chapter has generated some interest for the subject in you; if nothing
    more, I think you will at least have some appreciation for the people who sit
    for hours and develop frameworks and engines for you so that you can make the
    game of your dreams, without having any knowledge of the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about dreams, in the next chapter, you'll see how to finally publish
    a game on the iOS App Store.
  prefs: []
  type: TYPE_NORMAL
