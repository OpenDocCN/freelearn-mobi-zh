- en: Chapter 9. Metal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 金属
- en: Before we start creating a game, you should understand how to display things
    on the screen. This is always taken for granted, as all frameworks have a class
    called `sprite`, in which we just give a `.png` or `.jpg` file and say `addChild`
    and `tada`; we then have an image appearing on the screen. Moreover, with just
    a few simple functions such as move, scale, and rotate, we can even transform
    the sprite's position, size, and rotation. In reality, this `sprite` class does
    a whole lot of work just to display the image on the screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建游戏之前，您应该了解如何在屏幕上显示内容。这总是被理所当然地认为，因为所有框架都有一个名为`sprite`的类，我们只需提供一个`.png`或`.jpg`文件，并说`addChild`，然后“砰”的一声，图像就出现在屏幕上。此外，仅通过一些简单的函数，如移动、缩放和旋转，我们甚至可以变换精灵的位置、大小和旋转。实际上，这个`sprite`类只是为了在屏幕上显示图像而做了一大堆工作。
- en: In this chapter, we will look at Metal—a new graphics library from the people
    at Apple. This graphics library will help us to display objects on the screen.
    It is a communication tool that talks to the processor, the memory, the **graphics
    processing unit** (**GPU**), and the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Metal——苹果公司开发的一个新的图形库。这个图形库将帮助我们显示屏幕上的对象。它是一个通信工具，与处理器、内存、**图形处理单元**（**GPU**）和屏幕进行通信。
- en: If you are coming from a DirectX or OpenGL background, you will see that the
    process to display stuff on the screen, otherwise known as a graphics pipeline,
    is very similar to that in Metal. Metal's graphics pipeline is programmable with
    the use of a shader language, which uses C++11 as the base. We will go through
    it in detail in this chapter. Let's get rocking with Metal!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自DirectX或OpenGL的背景，您会发现显示内容到屏幕上的过程，也就是所谓的图形管线，在Metal中非常相似。Metal的图形管线可以使用着色语言进行编程，该语言以C++11为基础。我们将在本章中详细介绍它。让我们开始使用Metal吧！
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Overview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述
- en: Graphics pipeline and shaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形管线和着色器
- en: The basic Metal project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的Metal项目
- en: The colored quad project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色四边形项目
- en: The textured quad project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理四边形项目
- en: Overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Metal is a graphics API that is used to display anything on the screen. Metal
    is very specific to iOS 8 and above; moreover, it will only work on a device with
    an A7 chip and above. It is said that it will run ten times faster than OpenGLES.
    OpenGLES is another graphics library. Unlike Metal, OpenGLES is open source and
    works cross-platform. The trade-off here is that you can make it ten times faster,
    meaning that you can add mode particles and objects in the screen, however, you
    can't run your games on other operating systems such as Android and Windows Phone.
    Games developed with OpenGLES can be run on other devices with minor changes to
    the code. In fact, SpriteKit and SceneKit are developed by using OpenGLES. So,
    do you want to make a game with more objects on the screen or would you rather
    make your game available on other platforms? The choice is up to you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Metal是一个用于在屏幕上显示任何内容的图形API。Metal非常特定于iOS 8及以上版本；此外，它只能在配备A7芯片及以上的设备上运行。据说它的运行速度比OpenGLES快十倍。OpenGLES是另一个图形库。与Metal不同，OpenGLES是开源的，并且可以在跨平台上工作。这里的权衡是，您可以使其运行速度快十倍，这意味着您可以在屏幕上添加更多的粒子和其他对象，然而，您无法在其他操作系统（如Android和Windows
    Phone）上运行您的游戏。使用OpenGLES开发的游戏可以在其他设备上运行，只需对代码进行少量修改。实际上，SpriteKit和SceneKit就是使用OpenGLES开发的。那么，您是想制作一个屏幕上有更多对象的游戏，还是更希望您的游戏可以在其他平台上运行？选择权在您手中。
- en: In Metal, for rendering anything on the screen, you have to do it in two stages.
    The first stage is the preparation or initialization stage, and the next one is
    the drawing stage. In the preparation stage, we first get access to the GPU, ready
    the resources such as vertices and buffers, and prepare the render pipeline and
    the view in which you want to the object to be rendered into. After the preparation
    stage, we can get into actually drawing the image in the "draw" stage.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Metal中，要在屏幕上渲染任何内容，您必须分两个阶段进行。第一个阶段是准备或初始化阶段，下一个阶段是绘制阶段。在准备阶段，我们首先获取对GPU的访问权限，准备资源，如顶点和缓冲区，并准备渲染管线和您希望对象渲染到的视图。准备阶段完成后，我们就可以进入“绘制”阶段，实际绘制图像。
- en: The graphics pipeline and shaders
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形管线和着色器
- en: Let's look at these stages in detail. We'll look at the preparation stage first.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些阶段。我们首先看看准备阶段。
- en: The preparation/initialization stage
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备/初始化阶段
- en: 'The following steps are included in this stage:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此阶段包括以下步骤：
- en: Get device.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取设备。
- en: Command queue.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令队列。
- en: Resources.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源。
- en: Render pipeline.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染管线。
- en: View.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看视图。
- en: We'll look at each step, one by one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个查看每个步骤。
- en: Get device
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取设备
- en: First, we have to get the device that will be responsible for rendering our
    object. This will let us know the capabilities of the GPU in terms on how powerful
    it is and what its features are. In Metal, it will basically tell us what device
    we are running the game on, that is, whether it is running on an iPhone, iPad,
    or OS X. It will also tell us which version of the device it is and whether it
    is an iPhone 6, 5, 4, or any other device.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须获取将负责渲染我们的对象的设备。这将让我们了解GPU在性能和功能方面的能力。在Metal中，它将基本上告诉我们我们在哪个设备上运行游戏，即是否在iPhone、iPad或OS
    X上运行。它还会告诉我们设备的哪个版本，以及它是否是iPhone 6、5、4或其他任何设备。
- en: Command queue
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令队列
- en: Once we know which device we are working on, we get the next command in the
    queue. Information is sent from the CPU to the GPU in an asynchronous manner.
    This means that both the CPU and the GPU don't work on the same items at a particular
    time. When the CPU is done with the calculations, the information is fed to the
    GPU. If the GPU is busy, the information has to wait while the CPU works on the
    next process. For this, we need a queue. So basically, the command to the GPU
    waits in a queue before it can be executed. Therefore, in this step, we get the
    next free slot in the queue so that information can be fed from the CPU to the
    GPU.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了正在处理的设备，我们就可以获取队列中的下一个命令。信息以异步方式从CPU发送到GPU。这意味着CPU和GPU不会在特定时间处理相同的项。当CPU完成计算后，信息被传递给GPU。如果GPU正忙，信息必须等待，直到CPU处理下一个进程。为此，我们需要一个队列。所以基本上，GPU的命令在执行之前会等待在队列中。因此，在这个步骤中，我们获取队列中的下一个空闲槽位，以便信息可以从CPU传递到GPU。
- en: Resources
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: In this step, we ready the vertex, which is the information that we want to
    pass to the GPU. We will declare the properties that each vertex has (for example,
    the coordinates of each vertex at a basic level). We can also provide other information,
    such as color for each of the coordinates. We also need to store this data in
    the memory so that when the command executes, the GPU will retrieve the information.
    Information is stored in buffers. For each property of the vertex, a buffer is
    created. A buffer, as we saw in the first chapter, is nothing but a location in
    the memory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们准备顶点，这是我们想要传递给GPU的信息。我们将声明每个顶点具有的属性（例如，在基本层面上每个顶点的坐标）。我们还可以提供其他信息，例如每个坐标的颜色。我们还需要将这些数据存储在内存中，以便在命令执行时，GPU可以检索信息。信息存储在缓冲区中。对于顶点的每个属性，都会创建一个缓冲区。正如我们在第一章中看到的，缓冲区不过是内存中的一个位置。
- en: 'In the following screenshot, we see that there are four coordinates specified
    **a**, **b**, **c**, and **d**, each having their own vertex and color property:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到指定了四个坐标**a**、**b**、**c**和**d**，每个都有自己的顶点和颜色属性：
- en: '![Resources](img/B04014_09_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![资源](img/B04014_09_01.jpg)'
- en: Render pipeline
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染管道
- en: This step is broken down into two steps. In the first step, you'll have to create
    a descriptor. A descriptor is where you initialize the pipeline. We will tell
    the pixel which format to use while rasterizing the image. We will also be passing
    in our vertex shaders and pixel shader function here. Once the descriptor is ready,
    we can pass it to the *render pipeline* state. The state now contains all the
    information for the pipeline to be easily passed around. We will look at shaders
    in a later section, as it is better understood in action.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤被分解为两个步骤。在第一步中，你必须创建一个描述符。描述符是初始化管道的地方。我们将告诉像素在光栅化图像时使用哪种格式。我们还将在这里传递我们的顶点着色器和像素着色器函数。一旦描述符准备就绪，我们就可以将其传递给*渲染管道*状态。现在，状态包含管道所需的所有信息，以便可以轻松传递。我们将在稍后的部分查看着色器，因为它们在实际操作中更容易理解。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Recap the following from [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](ch01.html "第1章。入门")，*入门*中回顾以下内容：
- en: '**Vertex/Geometry Shader**: The information is then passed into the vertex
    shader. Vertex shaders are programmable by using shader language. The language
    is similar to C. Using this language, we can change the position, causing the
    object to move, scale, or rotate like how you can do in your `update` function
    within the game loop.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点/几何着色器**：信息随后被传递到顶点着色器。顶点着色器可以通过着色器语言进行编程。这种语言类似于C。使用这种语言，我们可以改变位置，使对象移动、缩放或旋转，就像你在游戏循环中的`update`函数中做的那样。'
- en: '**Pixel/Fragment Shader**: As in the vertex shader, in which you were able
    to do vertex modification, pixel shaders will enable you to make pixel-based operations.
    As this a shader, you know that this is also programmable. Using pixel shaders,
    you can create effects such as changing the color and transparency of the texture
    provided.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素/片段着色器**：与顶点着色器类似，在顶点着色器中你可以进行顶点修改，像素着色器将使你能够进行基于像素的操作。由于这是一个着色器，你知道这也是可编程的。使用像素着色器，你可以创建诸如更改纹理的颜色和透明度等效果。'
- en: View
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: The last step is to set up and ready the view. In the view stage, we will actually
    need access to the layer attached to the view on which the object will be drawn.
    The layer is like a blank canvas that is ready to be drawn on. We get the layer
    of the view so that we can keep drawing and erasing on it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是设置和准备视图。在视图阶段，我们实际上需要访问将要绘制对象的视图所附加的层。层就像一个准备绘制的空白画布。我们获取视图的层，以便我们可以在其上继续绘制和擦除。
- en: We are done with the initialization stage; next, we will see the steps to actually
    start drawing something on the screen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了初始化阶段；接下来，我们将看到实际开始在屏幕上绘制内容的步骤。
- en: The draw stage
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制阶段
- en: 'Here, we will finally draw the vertices that we sent in the first stage. This
    stage also has a few steps that need to be followed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将最终绘制我们在第一阶段发送的顶点。这一阶段也有一些需要遵循的步骤：
- en: Start render pass.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始渲染过程。
- en: Get command buffer.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取命令缓冲区。
- en: Draw.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制。
- en: Commit the command buffer.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交命令缓冲区。
- en: Start render pass
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始渲染过程
- en: We prepare the layer for drawing the object. We assign the layer to be drawn
    onto and clear the surface with the default color.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为绘制对象准备层。我们将层分配给要绘制的对象，并使用默认颜色清除表面。
- en: Get command buffer
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取命令缓冲区
- en: The Command buffer is the place where the command for rendering is stored. We
    need to get access to the command buffer in order to execute the commands.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区是存储渲染命令的地方。我们需要获取对命令缓冲区的访问权限以执行命令。
- en: Draw
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制
- en: Finally, the drawing takes place on the layer. This is done by a render command
    encoder, which takes the code from the command buffer and encodes it into machine
    language in order to render the image. We pass the pipeline state and the vertex
    buffer and then draw the image. This whole step is done off screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，绘制发生在层上。这是通过一个渲染命令编码器完成的，它将命令缓冲区中的代码编码成机器语言以渲染图像。我们传递管道状态和顶点缓冲区，然后绘制图像。这一整个过程是在屏幕外完成的。
- en: Commit the command buffer
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交命令缓冲区
- en: This is the final stage, in which image rendering has been done, and the image
    is ready to be displayed onto the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终阶段，图像渲染已经完成，图像准备在屏幕上显示。
- en: With all of this theoretical knowledge with us now, let's put it all to practice
    to see how we can display something to look at on the screen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有这些理论知识，让我们将其付诸实践，看看我们如何在屏幕上显示可以观看的内容。
- en: The basic Metal project
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本Metal项目
- en: In this first project, we will create a basic triangle and display it on the
    device.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个项目中，我们将创建一个基本的三角形并在设备上显示它。
- en: 'Create a new Xcode project. Select **Metal** as the technology and **Swift**
    as the language for the project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Xcode项目。选择项目技术为 **Metal**，语言为 **Swift**：
- en: '![The basic Metal project](img/B04014_09_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![基本Metal项目](img/B04014_09_02.jpg)'
- en: Select a location to save the project in. In the `GameViewController.swift`
    file, we delete all the contents of the `viewDidLoad` functions, so that we can
    start from the absolute basics.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选择保存项目的位置。在 `GameViewController.swift` 文件中，我们删除 `viewDidLoad` 函数的所有内容，以便我们可以从绝对基础开始。
- en: 'As discussed in the overview, the first thing that we have to do is get the
    device that the application will work on. Add the following line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如概述中所述，我们必须做的第一件事是获取应用程序将要工作的设备。添加以下行：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create a new constant called `device` of the `MTLDevice` type and assign
    `MTLCreateSytemDefaultDevice` to it. So now, we have direct access to the device.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `device` 的新常量，其类型为 `MTLDevice`，并将其分配给 `MTLCreateSytemDefaultDevice`。因此，我们现在可以直接访问设备。
- en: 'Next, we have to create `commandQueue` for the device:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须为设备创建 `commandQueue`：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We get the command from the device and assign it to a new variable called `commandQueue`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从设备获取命令并将其分配给一个名为 `commandQueue` 的新变量。
- en: 'In the next step, we prepare resources such as the vertex information and vertex
    buffers. To create vertex definitions, create an array at the top of the file
    called `vertexArray`, as shown in the following lines of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们准备资源，如顶点信息和顶点缓冲区。要创建顶点定义，在文件顶部创建一个名为`vertexArray`的数组，如图下代码所示：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Imagine the shape of a screen to be a rectangle, with its width and height being
    2 pixels each and the center of the screen being the origin. So, in the preceding
    array, the 0th, 2nd, and 4th values are *x* coordinates, and the 1st, 3rd, and
    5th items are the corresponding *y* coordinates.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设屏幕的形状是一个矩形，其宽度和高度各为2个像素，屏幕中心是原点。因此，在前面的数组中，第0个、第2个和第4个值是*x*坐标，而第1个、第3个和第5个项是对应的*y*坐标。
- en: Here, we are passing in three pairs of `x` and `y` values to draw a triangle.
    For the first value, `x` is at the origin and `y` is at `.75` in the *y* direction
    from the center of the screen. The next two coordinates are to the bottom left
    and bottom right of the origin.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了三对`x`和`y`值来绘制一个三角形。对于第一个值，`x`位于原点，`y`在屏幕中心的*y*方向上为`.75`。接下来的两个坐标位于原点的左下角和右下角。
- en: So now, we have our vertices ready. Next, we have to create a vertex buffer
    so that we can store these vertices in it. Create a new variable called `vertexBuffer`
    of type `MTLBuffer`, as shown in the following diagram, and assign the `vertexArray`
    variable we created along with the size of the array and `nil` for `options`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经有了顶点。接下来，我们必须创建一个顶点缓冲区，以便我们可以将其存储在其中。创建一个新的变量`vertexBuffer`，类型为`MTLBuffer`，如图所示，并将我们创建的`vertexArray`变量及其数组大小和`nil`作为`options`赋值。
- en: '![The basic Metal project](img/B04014_09_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![基本的Metal项目](img/B04014_09_03.jpg)'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we have to create our vertex and fragment shader.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建我们的顶点着色器和片段着色器。
- en: 'Shaders are small pieces of code that are compiled at runtime. There are two
    types of shaders: **vertex** and **fragment**:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是运行时编译的小段代码。有两种类型的着色器：**顶点**和**片段**：
- en: '**Vertex shaders**: This lets us perform vertex manipulation if we want an
    outside the game code. By vertex manipulation, we mean moving, rotating, and translating
    the each of the vertices, and therefore, the whole object. This is at the basic
    level; we can perform more complex operations by using vertex shaders. The vertex
    shader gets called as many times as the number of coordinates we pass in. So in
    this case, it will be called three times.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这允许我们在游戏代码外部执行顶点操作。通过顶点操作，我们指的是移动、旋转和转换每个顶点，从而整个对象。这是基本级别；我们可以通过使用顶点着色器执行更复杂的操作。顶点着色器的调用次数与我们传递的坐标数量相同。因此，在这种情况下，它将被调用三次。'
- en: '**Fragment shaders**: These can be used to perform manipulations at the pixel
    level. They can be used to make various effects such as blur, pixelate, cel shading,
    and so on. Unlike Vertex shaders, pixel or fragment shaders can be called as many
    times as required to fill the space within the triangle with a color or texture.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这些着色器可以用于在像素级别进行操作。它们可以用来实现各种效果，如模糊、像素化、赛博着色等。与顶点着色器不同，像素或片段着色器可以根据需要多次调用，以填充三角形内的颜色或纹理空间。'
- en: Let's see how to write our first shader files. First, we will write a vertex
    shader. In the project file, you will already have a new file called `Shaders.metal`.
    This is the shader file for Metal, in which you will write both your vertex shader
    and pixel shader.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写我们的第一个着色器文件。首先，我们将编写一个顶点着色器。在项目文件中，你将已经有一个名为`Shaders.metal`的新文件。这是Metal的着色器文件，其中你将编写你的顶点着色器和像素着色器。
- en: People with an OpenGL or DirectX background may be wondering where the other
    file is. That is one of the differences between Metal and other shader languages.
    Metal uses just one file, and in this file, you can write both the shaders. Each
    shader is not a file but a function. So later, when we pass the shader in the
    pipeline descriptor, we won't be giving the file name of the shader but the name
    of the function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有OpenGL或DirectX背景知识的人可能会想知道其他文件在哪里。这是Metal与其他着色语言之间的一大区别。Metal只使用一个文件，在这个文件中，你可以编写所有的着色器。每个着色器不是一个文件，而是一个函数。因此，当我们将在管道描述符中传递着色器时，我们不会给出着色器的文件名，而是给出函数名。
- en: You can create more than one shader file and write your vertex shader in one
    file and pixel shader in the other, or vice versa. Metal really doesn't care which
    file you put what in, as long as you make sure that you are calling the right
    functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建多个着色器文件，在一个文件中编写顶点着色器，在另一个文件中编写像素着色器，或者反之亦然。Metal 实际上并不关心你将什么放在哪个文件中，只要确保你调用的是正确的函数。
- en: 'To create additional metal shader files, you can go to **File** | **New** |
    **File** | **Source** and select **Metal File**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建额外的金属着色器文件，你可以转到 **文件** | **新建** | **文件** | **源文件** 并选择 **Metal 文件**：
- en: '![The basic Metal project](img/B04014_09_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![基本的 Metal 项目](img/B04014_09_04.jpg)'
- en: 'In the `Shaders.metal` file, remove everything and add the following code,
    as we will start from the basics:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Shaders.metal` 文件中，删除所有内容并添加以下代码，因为我们将从基础开始：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the top, we include the metal standard library and use namespace metal. People
    with C++ will feel at home as the metal shader language is written in a modified
    version of C++11.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们包含金属标准库并使用命名空间 metal。对于有 C++ 经验的人来说，金属着色器语言使用的是 C++11 的修改版，会感到很熟悉。
- en: The first function right after that is the vertex shader function. Shader functions
    start with the keyword vertex or fragment to denote whether the function is a
    vertex shader or a fragment shader.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的第一个函数是顶点着色器函数。着色器函数以 `vertex` 或 `fragment` 关键字开头，以表示该函数是顶点着色器还是片段着色器。
- en: 'So, in the vertex shader, the function has the keyword `vertex` and it returns
    a `float4`. A float 4 is like a struct with four float values: `x`, `y`, `z`,
    and `w`; or `r`, `g`, `b`, and `a`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在顶点着色器中，函数具有 `vertex` 关键字，并返回一个 `float4`。一个 float 4 就像是一个包含四个 float 值的结构：`x`、`y`、`z`
    和 `w`；或者 `r`、`g`、`b` 和 `a`。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Shaders also have their own data types, such as `float`, `float2`, `float3`,
    and `float4` or `int`, `int2`, `int3`, and `int4`. Since shaders usually deal
    with vertices or colors which are a `float3` with `x`, `y`, and `z` values and
    `float4` with `r`, `g`, `b`, and `a` values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器也有它们自己的数据类型，例如 `float`、`float2`、`float3` 和 `float4` 或 `int`、`int2`、`int3`
    和 `int4`。由于着色器通常处理顶点或颜色，这些是具有 `x`、`y` 和 `z` 值的 `float3` 以及具有 `r`、`g`、`b` 和 `a`
    值的 `float4`。
- en: You can also perform mathematical operations on these values. For example, if
    you have two `float3` variables called `vert1` and `vert2` and you multiply `vert1`
    and `vert2`, then the resultant `vert3` will be created with the `x` values multiplied
    to create a new `x` value. And similarly, `y` and `z` values will be multiplied
    with `vert1` and `vert2` to create `vert3` with the new `x`, `y`, and `z` values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对这些值执行数学运算。例如，如果你有两个名为 `vert1` 和 `vert2` 的 `float3` 变量，并且将 `vert1` 和 `vert2`
    相乘，那么生成的结果 `vert3` 将使用 `x` 值相乘来创建一个新的 `x` 值。同样，`y` 和 `z` 值将与 `vert1` 和 `vert2`
    相乘，以创建具有新 `x`、`y` 和 `z` 值的 `vert3`。
- en: After the return type, we specify the name of the function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回类型之后，我们指定函数的名称。
- en: The function takes in two attributes. The double rectangle bracket signifies
    that it is an attribute. Attributes are like properties. Here, we pass the `vertexArray`
    through the buffer we created. In the attribute, we pass the vertex array through
    the buffer at index `0`. Later, you will see that we assign our `vertexBuffer`
    an index value, which refers to the `0` position here, so that the shaders knows
    which buffer is the vertex buffer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受两个属性。双矩形括号表示它是一个属性。属性就像属性一样。在这里，我们通过我们创建的缓冲区传递 `vertexArray`。在属性中，我们通过索引
    `0` 的缓冲区传递顶点数组。稍后，你会看到我们为 `vertexBuffer` 分配一个索引值，它指的是这里的 `0` 位置，这样着色器就知道哪个缓冲区是顶点缓冲区。
- en: The next attribute that the function takes in is the vertex ID. This is generated
    automatically, depending upon how many vertices we pass in. We pass in three pairs
    of *x* and *y* coordinates, so three vertex IDs will be generated for this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受的下一个属性是顶点 ID。这会根据我们传递的顶点数量自动生成。我们传递三对 `x` 和 `y` 坐标，因此将为这个生成三个顶点 ID。
- en: 'Next, in the function it returns a `float4` vertex for each of the vertex IDs.
    As we have to return a float 4, we add the extra `0` and `1` at the end. You might
    be wondering how we are returning four values when there are only returning three
    values: `vertex_array[vid]`,`0`, and `1`. In shader languages, you can club `x`
    and `y` in a single variable. Here `vertex_array[vid]` is one variable, but it
    actually holds two objects in it, that is, the `x` and `y` values for that coordinate.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在函数中，它为每个顶点ID返回一个`float4`顶点。由于我们必须返回一个float 4，我们在末尾添加了额外的`0`和`1`。你可能想知道我们如何返回四个值，而实际上只返回了三个值：`vertex_array[vid]`、`0`和`1`。在着色器语言中，你可以在单个变量中将`x`和`y`组合在一起。在这里，`vertex_array[vid]`是一个变量，但实际上它包含两个对象，即该坐标的`x`和`y`值。
- en: 'We then create the function for the fragment shader. In a similar way to the
    vertex shader, we start with the shader type followed by return type and then
    provide the name of the function. We are not passing anything into the function
    yet. It does return a `float4` value. As it is a fragment shader and fragment
    shaders are used for making pixel manipulation, the four values here are the RGBA
    values of color. So here, the triangle that we will be drawing will be purple
    in color. If you want all four colors to be of the same value, we can perform
    the following operation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为片段着色器创建函数。与顶点着色器类似，我们首先指定着色器类型，然后是返回类型，接着提供函数的名称。目前我们还没有向函数传递任何内容。它确实返回一个`float4`值。由于它是一个片段着色器，而片段着色器用于像素操作，这里的四个值是颜色的RGBA值。因此，我们将绘制的三角形将是紫色的。如果你想让所有四个颜色值相同，我们可以执行以下操作：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will return all RGBA values as equal to `0.56`. So the triangle will be
    gray in color and will be transparent as the value of alpha `a` is also at `0.56`.
    This way of writing values looks very odd as we don't follow this practice in
    regular mathematics, but with constant use, you will get used to it and, in fact,
    appreciate it, as it is more convenient for programming shaders.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有RGBA值都等于`0.56`。因此，三角形将是灰色的，并且由于alpha `a`的值也是`0.56`，它将是透明的。这种写值的方式看起来非常奇怪，因为我们通常不遵循常规数学中的这种做法，但通过不断使用，你会习惯它，实际上你会欣赏它，因为它对编写着色器来说更加方便。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Fragment shaders can also be called pixel shaders as they are the same for the
    most part, but make sure that while creating a pixel shader function, you use
    the `fragment` keyword, otherwise Metal won't understand what you are talking
    about.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器也可以称为像素着色器，因为大部分情况下它们是相同的，但确保在创建像素着色器函数时使用`fragment`关键字，否则Metal无法理解你在说什么。
- en: So, we are done with our shader file; let's now continue with our regular code
    in `GameViewController.swift` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了着色器文件；现在让我们继续在`GameViewController.swift`文件中的常规代码。
- en: We have added the shader function to our shader library. Once the shader is
    compiled, it is added to the `shader` library so that it can be retrieved later
    to save effort in compiling the shader again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将着色器函数添加到我们的着色器库中。一旦着色器被编译，它就会被添加到`shader`库中，以便以后可以检索它，从而节省再次编译着色器的努力。
- en: 'Get the library from the device and add the shader functions to it. We also
    create new constants for getting the vertex and shader functions from the device,
    which will be required to pass in the render descriptor, as shown in the following
    code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备获取库并将着色器函数添加到其中。我们还创建了新的常量，用于从设备获取顶点和着色器函数，这些将在渲染描述符中需要，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we create the render pipeline descriptor. First, we have to create a
    descriptor to assign to a state, later on. So, let''s create a new pipeline descriptor,
    as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建渲染管线描述符。首先，我们必须创建一个描述符，稍后将其分配给状态。所以，让我们创建一个新的管线描述符，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the descriptor, we provide the vertex and shader function and the pixel
    format to be used, as shown in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述符中，我们提供了顶点和着色器函数以及要使用的像素格式，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pixel formats specify the order of the color components, bit depth per component,
    and data type. There are more than two dozen formats. To know more about the different
    types of pixel formats, you can visit Apple's documentation at [https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 像素格式指定了颜色组件的顺序、每个组件的位深度和数据类型。有二十多种格式。要了解更多关于不同类型的像素格式，您可以访问苹果的文档，网址为[https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat)。
- en: 'We then create a `RenderPipeline` state from the descriptor, as shown in the
    following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据描述符创建了一个`RenderPipeline`状态，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A new variable, `pipelineState`, of the `MTLRenderPipeLineState` type is created,
    and the `pipeLibeStateDescriptor` constant is passed to it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个新的变量`pipelineState`，其类型为`MTLRenderPipeLineState`，并将`pipeLibeStateDescriptor`常量传递给它。
- en: 'Next, we create a layer of type `CAMetalLayer` and add it to the current view,
    so that we can draw the object on it. So, add the following code to prepare the
    view and add the layer to it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个类型为`CAMetalLayer`的图层并将其添加到当前视图中，这样我们就可以在上面绘制对象。因此，添加以下代码来准备视图并将其图层添加到其中：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To the `metalLayer` constant, we assign the device, pixel format of layer (the
    same as what we assigned in the pipeline descriptor), and the frame size, which
    is equal to the size of the frame of the view (frame size is the same as the screen
    size). Finally, add `metalLayer` as a sublayer to the current view layer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`metalLayer`常量分配给设备、图层的像素格式（与我们在管道描述符中分配的相同），以及框架大小，它等于视图框架的大小（框架大小与屏幕大小相同）。最后，将`metalLayer`作为子图层添加到当前视图图层。
- en: This is all that is required for setting up everything. We can move on to the
    next stage, that is, actually drawing the triangle.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设置所有所需的内容。我们可以继续到下一个阶段，即实际绘制三角形。
- en: 'In the next step, we create a render pass descriptor. Before we can create
    it, however, we need to get a reference to the next drawable texture from the
    layer as it will be required to pass it to the render descriptor:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们创建渲染通道描述符。然而，在我们可以创建它之前，我们需要从图层获取下一个可绘制纹理的引用，因为它将被传递到渲染描述符中：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we create the render descriptor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建渲染描述符：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we create a new constant called `renderPassDescriptor`, of type `MTLRenderPassDescriptor`.
    First, we assign the texture of the drawable layer so that whatever it renders
    gets drawn in the texture. So, the texture of the drawable layer is passed in.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个新的常量`renderPassDescriptor`，其类型为`MTLRenderPassDescriptor`。首先，我们分配可绘制图层的纹理，以便渲染的内容被绘制在纹理上。因此，可绘制图层的纹理被传递进来。
- en: Next, the load action is called. Once loaded, the layer is first cleared with
    a color. Then, we pass a color with which the layer will be cleared. Here, we
    pass a purple color.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用加载操作。一旦加载，图层首先用颜色清除。然后，我们传递一个颜色，图层将用这个颜色清除。在这里，我们传递了一个紫色。
- en: 'With that, our descriptor is ready. Next, we have to render the layer and the
    triangle. So first, we get the command buffer from the command queue. These are
    the commands that are stored in the memory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们的描述符就准备好了。接下来，我们必须渲染图层和三角形。所以首先，我们从命令队列中获取命令缓冲区。这些是存储在内存中的命令：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All these commands need to be encoded in the machine language through `MTLRenderCommandEncoder`.
    We pass the `renderPassDescriptor` variable here to encode the render code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些命令都需要通过`MTLRenderCommandEncoder`编码成机器语言。我们在这里传递`renderPassDescriptor`变量来编码渲染代码：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we have to set the pipeline and vertex buffer state in the encoder. While
    passing in `vertexBuffer`, we have to pass in the offset and index buffer values.
    As we created a new buffer, the offset value is `0` and for index, we pass `0`.
    This index value is what the vertex shader referred and passed in `[[buffer(0)]]`
    to the value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在编码器中设置管道和顶点缓冲区状态。在传递`vertexBuffer`时，我们必须传递偏移量和索引缓冲区值。由于我们创建了一个新的缓冲区，偏移量值是`0`，对于索引，我们传递`0`。这个索引值是顶点着色器所引用并传递到`[[buffer(0)]]`的值：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can draw the triangle by creating a primitive type. Eventually,
    all shapes are made of triangles, as we saw in the example of the ship in the
    first chapter. The number of vertices and their positions define the shape of
    the object. Here, we are creating a single triangle shape, so we are passing three
    vertices to create a triangle. This same triangle primitive is used to make squares,
    cubes, teapots, spheres, and so on:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过创建原语类型来绘制三角形。最终，所有形状都是由三角形组成的，正如我们在第一章中关于船的例子中所看到的。顶点的数量和它们的位置定义了物体的形状。在这里，我们创建一个单独的三角形形状，因此我们传递三个顶点来创建一个三角形。这个相同的三角形原语用于制作正方形、立方体、茶壶、球体等等：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have finally drawn, so we can end the encoding:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经绘制完毕，因此我们可以结束编码：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Although we have drawn the triangle, we still need to present it on the screen.
    In the next step, we will provide the texture and commit it to the view:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经绘制了三角形，但我们仍然需要在屏幕上呈现它。在下一步中，我们将提供纹理并将其提交到视图中：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That is all. Finally, you will be able to see the purple triangle with the
    yellow background on the screen, as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了。最后，你将能够在屏幕上看到紫色三角形和黄色背景，如下面的截图所示：
- en: '![The basic Metal project](img/B04014_09_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![基本的 Metal 项目](img/B04014_09_05.jpg)'
- en: Congrats! You've successfully completed it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功完成了。
- en: All of this is just for drawing the triangle, but I hope you are now able to
    appreciate the effort. The problem is that if you do any of the steps incorrectly,
    the chances are that the triangle won't get displayed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些只是为了绘制三角形，但我希望你现在能够欣赏到所做的努力。问题是，如果你在任何一个步骤中出错，三角形可能不会显示出来。
- en: The code is also kept very basic. We can definitely optimize the code by adding
    a renderer class and creating the vertex array as a separate class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码也保持得很简单。我们绝对可以通过添加渲染器类和创建独立的类来创建顶点数组来优化代码。
- en: In the next example, we will create a square. This time, we will pass colors
    for each of the coordinates instead of typing the color value in the fragment
    shader function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将创建一个正方形。这次，我们将为每个坐标传递颜色，而不是在片段着色器函数中键入颜色值。
- en: The colored quad project
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 彩色四边形项目
- en: 'To create a colored square, we need to make some changes to `vertexArray`,
    as we will need to pass six vertices instead of three. We have to pass six vertices
    because, as you saw earlier, we can draw only in triangles. So, we need three
    points for the triangle to form the top part of the square and three more points
    to form its bottom part:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个彩色正方形，我们需要对 `vertexArray` 进行一些修改，因为我们需要传递六个顶点而不是三个。我们必须传递六个顶点，因为，正如你之前所看到的，我们只能绘制三角形。因此，我们需要三个点来形成正方形的顶部，还需要另外三个点来形成其底部：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will see that the `a` and `c` points are repeated to form the second triangle,
    because the diagonal of the square are the same points for the first triangle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 `a` 和 `c` 点被重复以形成第二个三角形，因为正方形的对角线与第一个三角形的点是相同的。
- en: '![The colored quad project](img/B04014_09_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![彩色四边形项目](img/B04014_09_06.jpg)'
- en: Notice that in the vertex array, we are now passing four values per vertex instead
    of two, as we did in the case of the triangle. This will simplify matters while
    modifying the shader function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在顶点数组中，我们现在为每个顶点传递四个值，而不是像三角形那样传递两个值。这将简化修改着色器函数的过程。
- en: The values of the coordinates provided are the `x`, `y`, and `z` values, and
    an additional fourth parameter `w` is also passed in. Like the `z` value in two-dimensional
    space, it doesn't have much significance yet. Later, when you create a three-dimensional
    object, the `w` parameter plays a major role. But, as of now, let the value remain
    `1`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的坐标值是 `x`、`y` 和 `z` 值，还有一个额外的第四个参数 `w` 也被传递进来。就像二维空间中的 `z` 值一样，它目前并没有太多意义。稍后，当你创建一个三维对象时，`w`
    参数将发挥重要作用。但，就目前而言，让这个值保持为 `1`。
- en: Additionally, as we saw while creating the triangle, the view is a 2 x 2 rectangle
    with the origin in the center. As we are passing in coordinates between `1` and
    `-1` in the *x*-*y* direction, the rectangle will actually cover the whole screen.
    If you still want to see the yellow background, change the value `1` to a smaller
    value, as we did in the case of the triangle. Do not change the values corresponding
    to `0`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在创建三角形时所见，视图是一个以中心为原点的 2 x 2 矩形。由于我们在 *x*-*y* 方向上传递的坐标在 `1` 和 `-1` 之间，实际上这个矩形将覆盖整个屏幕。如果你仍然想看到黄色背景，将值
    `1` 改为更小的值，就像我们在三角形的情况下所做的那样。不要更改与 `0` 对应的值。
- en: 'Similar to passing vertices, we will also pass color values for each of these
    coordinates as a buffer in the code to create a new array called `colorArray`,
    as shown in the following lines:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于传递顶点，我们也将通过代码将这些坐标的颜色值作为缓冲区传递，以创建一个新的数组`colorArray`，如下面的行所示：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These are simple RGBA values for the respective coordinates. Here, a means that
    *red* = `1`, *green* = `0`, *blue* = `0`, and *alpha* = `1`. The values of each
    of these lie between `0` and `1`. So here, `a` will be all red in color. We can
    create custom colors by keeping red as `1` and adding more green or blue to the
    mix, as in the case of `c` and `d`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相应坐标的简单RGBA值。在这里，`a`表示红色`red` = `1`，绿色`green` = `0`，蓝色`blue` = `0`，透明度`alpha`
    = `1`。这些值的每个都在`0`和`1`之间。因此，`a`将呈现全红色。我们可以通过保持红色为`1`并添加更多绿色或蓝色来创建自定义颜色，例如在`c`和`d`的情况下。
- en: 'Next, in a similar way to how we created a `vertexBuffer`, we have to create
    a `colorBuffer` of type `MTLBuffer`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，类似于我们创建`vertexBuffer`的方式，我们必须创建一个类型为`MTLBuffer`的`colorBuffer`：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We pass in the `colorArray` that we created and the size of the whole array.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了我们创建的`colorArray`以及整个数组的大小。
- en: We don't have to make any changes to the device, layer, or the render pipeline
    in the code. But we do need to change the vertex and shader functions, as we are
    going to be passing information on the color.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们不需要对设备、层或渲染管线进行任何更改。但我们需要更改顶点和着色器函数，因为我们将要传递关于颜色的信息。
- en: 'In any shader language, we can also create our own data types. A new data type
    called `VertexInOut` is created by using a struct in the shader file. So type
    the following code in the `Shader.metal` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何着色器语言中，我们也可以创建自己的数据类型。通过在着色器文件中使用结构体创建了一个名为`VertexInOut`的新数据类型。因此，在`Shader.metal`文件中输入以下代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create a struct with two `float4` values, of which one is for position and
    the other is for the color. The position with double square brackets is used to
    indicate that we will be passing and retrieving the position attribute through
    the position property.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含两个`float4`值的结构体，其中一个用于位置，另一个用于颜色。使用双方括号的位置表示我们将通过位置属性传递和检索位置属性。
- en: 'The `vertex` function is changed, as shown in the following lines of code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertex`函数已更改，如下面的代码行所示：'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A packed variable means that you cannot access each of the components individually,
    unlike a regular `float4`. For example, in a regular `float4` that has position
    data, we can access the `x`, `y`, `z`, and `w` values, but in a packed `float`,
    we cannot do that.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩变量意味着你不能单独访问每个组件，这与常规的`float4`不同。例如，在一个具有位置数据的常规`float4`中，我们可以访问`x`、`y`、`z`和`w`值，但在压缩的`float`中，我们无法这样做。
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we first tell the `vertex` function type with the `vertex` keyword; we
    return a type called `VertexInOut` that we created earlier and provide the name
    of the function name. We provide the vertex ID, the position buffer with index
    `0`, and the color buffer with index `1` to the function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用`vertex`关键字来声明`vertex`函数类型；我们返回一个之前创建的名为`VertexInOut`的类型，并提供函数名称。我们将顶点ID、索引为`0`的位置缓冲区和索引为`1`的颜色缓冲区传递给函数。
- en: In the function, we create a new variable called `outVertex` of type `VertexInOut`,
    assign the position and color values for each of the vertex IDs, and then return
    the `outVertex` variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，我们创建了一个名为`outVertex`的新变量，其类型为`VertexInOut`，为每个顶点ID分配位置和颜色值，然后返回`outVertex`变量。
- en: 'We also need to make changes to the fragment shader function, as the color
    that is passed in through the buffer needs to be applied to the cube:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改片段着色器函数，因为通过缓冲区传入的颜色需要应用到立方体上：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the fragment shader, we use a `fragment` keyword to specify that it is a
    fragment shader, to return a `half4` (which is like a `float4` but consumes less
    memory), and to provide a name for the `shader` function. The function takes in
    the `VertexInOut` variable. The `[[stage_in]]` part is used to signify that the
    operation will have to be done on a per pixel basis. In the function, we ask it
    to return the typecast color value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们使用`fragment`关键字来指定这是一个片段着色器，返回一个`half4`（类似于`float4`但占用更少的内存），并为`shader`函数提供一个名称。该函数接收`VertexInOut`变量。`[[stage_in]]`部分用于表示操作将需要在每个像素的基础上进行。在函数中，我们要求它返回类型转换后的颜色值。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about `stage_in` can be found at [https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`stage_in`的信息可以在[https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13)找到。
- en: 'As we added a new color buffer and increased the number of vertices, we have
    to make changes to the `renderEncoder`, as shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了一个新的颜色缓冲区并增加了顶点数量，我们必须对`renderEncoder`进行修改，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We set a new vertex buffer and pass the color buffer and the index value of
    `1`. In `drawPrimitives`, we are still creating a primitive of type triangle,
    but this time it's with six vertices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个新的顶点缓冲区，并传递了颜色缓冲区和索引值`1`。在`drawPrimitives`中，我们仍然在创建一个三角形类型的原始图形，但这次它有六个顶点。
- en: 'Finally, as we have changed the shader functions, we need to update the names
    in the pipeline, as highlighted in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们更改了着色器函数，我们需要更新管道中的名称，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that it is all built, we can see the colored square, or quad, as it is
    generally known:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经构建完成，我们可以看到彩色的正方形，或者通常所说的四边形：
- en: '![The colored quad project](img/B04014_09_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![彩色的四边形项目](img/B04014_09_07.jpg)'
- en: You might be wondering that when you passed in four colors for only the four
    vertices, how come the whole screen is colored and the colors are also merging.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，当你只为四个顶点传递了四个颜色时，为什么整个屏幕都被着色，颜色也在混合。
- en: The vertex shader function gets called depending upon the number of vertices
    passed in. So the vertex shader function got called six times. On the other hand,
    the fragment shader function is actually called as many times as is required to
    fill the area generated by each triangle primitive. The colors are interpolated
    between the points, depending upon the distance from a coordinate. For this example,
    the bottom left coordinate was passed the color value of green. As it moves away
    from the bottom-left corner, the color slowly merges with other colors, thus reducing
    the value of green. So at the center, we have a mix of all the colors. This is
    a general feature of any fragment shader.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器函数根据传入的顶点数量被调用。因此，顶点着色器函数被调用了六次。另一方面，片段着色器函数实际上被调用，直到填满每个三角形原始图形生成的区域。颜色根据坐标的距离进行插值。在这个例子中，左下角的坐标传递了绿色颜色值。随着它从左下角移动，颜色逐渐与其他颜色混合，从而降低了绿色的值。所以在中心，我们有了所有颜色的混合。这是任何片段着色器的一般特性。
- en: The texture quad project
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理四边形项目
- en: For the next project, we will create a textured quad object. This is the basic
    building block of a sprite class. Here, we will be taking an image and pasting
    it on top of the quad or square that we created in the earlier project.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，我们将创建一个纹理四边形对象。这是精灵类的基本构建块。在这里，我们将取一个图像并将其粘贴到我们在早期项目中创建的四边形或正方形上。
- en: The reason why I said that it is a basic building block for a sprite class is
    that we won't be able to move, rotate, or scale the sprite; we will just be displaying
    the sprite on the screen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以说它是精灵类的基本构建块，是因为我们无法移动、旋转或缩放精灵；我们只是在屏幕上显示精灵。
- en: Going back to referring to the process of adding a sprite to any quad in a similar
    way to adding wallpaper to wall, we can add the wallpaper right-side up or upside
    down on the wall. Similarly, while adding images to quads, we have to specify
    which way is up, otherwise the sprite will be pasted upside down or sideways on
    the quad.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 回到将精灵添加到任何四边形的过程，类似于将壁纸贴到墙上，我们可以在墙上正着或倒着贴壁纸。同样，在将图像添加到四边形时，我们必须指定哪个方向是向上的，否则精灵将被粘贴到四边形的倒置或侧置。
- en: For this, we have to pass in one more array of coordinates, which are called
    texture coordinates. The texture coordinates are different than vertex coordinates
    such that the vertex coordinates are with reference to the screen coordinates
    system, with the center of the screen being the origin. Refer to the image provided.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须传递一个额外的坐标数组，这些坐标被称为纹理坐标。纹理坐标与顶点坐标不同，因为顶点坐标是以屏幕坐标系统为参考的，屏幕中心是原点。请参考提供的图像。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are working in 2D, so we can call it the screen coordinates system, which
    is the same as the world coordinate system for convenience for now, but in 3D
    it is actually the world coordinate system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在2D空间中工作，因此我们可以称之为屏幕坐标系，目前为了方便，它与世界坐标系相同，但在3D中实际上是世界坐标系。
- en: The texture coordinate system is with respect to each quad or rectangle. Moreover,
    the top left of the quad is the origin for the texture coordinate system. So,
    for moving the quad around the screen, you will change the values in the vertex
    array. The texture coordinates will be changed to actually move the image around
    within the quad.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标系相对于每个四边形或矩形。此外，四边形的左上角是纹理坐标系统的原点。因此，为了在屏幕上移动四边形，您将更改顶点数组中的值。纹理坐标将改变，以便在四边形内实际移动图像。
- en: 'So, with all that theory out of the way, let''s create a new array called `textureCoordsArray`,
    as shown here. But before that, change `vertexArray` and reduce the size of the
    quad that we created earlier, so that we can have a better understanding of what
    is happening with the texture coordinate:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在所有理论都讲完之后，让我们创建一个新的数组，称为`textureCoordsArray`，如图所示。但在那之前，更改`vertexArray`并减小我们之前创建的四边形的尺寸，以便我们可以更好地理解纹理坐标所发生的情况：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, add the texture coordinate array:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加纹理坐标数组：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'While creating a textured quad, there are two things that we need to pay close
    attention to:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建纹理四边形时，有两件事我们需要特别注意：
- en: The `vertex` array provided for each triangle set needs to be in the anti-clockwise
    direction. So, for the first three position vertices in the vertex array, the
    order needs to be `abc` and `acd` respectively for both triangles, otherwise the
    texture will not be displayed properly.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个三角形集提供的`vertex`数组需要按逆时针方向排列。因此，对于顶点数组中的前三个位置顶点，两个三角形分别需要按`abc`和`acd`的顺序排列，否则纹理将无法正确显示。
- en: The order of the `vertex` array and texture coordinate needs to be the same;
    if the vertex array order is `abc` and `acd`, then the texture coordinate order
    needs to be specified in the same order.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertex`数组和纹理坐标的顺序必须相同；如果顶点数组顺序是`abc`和`acd`，那么纹理坐标顺序也必须按相同顺序指定。'
- en: '![The texture quad project](img/B04014_09_08.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![纹理四边形项目](img/B04014_09_08.jpg)'
- en: In the preceding image, the red letters **a**, **b**, **c**, and **d** denote
    the vertex coordinates, and the green coordinates denote the texture coordinates.
    The red origin is the origin of the vertex coordinate, and the green origin is
    the origin of the texture coordinate.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，红色字母**a**、**b**、**c**和**d**表示顶点坐标，绿色坐标表示纹理坐标。红色原点是顶点坐标的原点，绿色原点是纹理坐标的原点。
- en: 'With the texture coordinates ready, we have to create a texture buffer of the
    type `MTLBuffer` and pass in the texture coordinate array into it, along with
    the size of the array. This is similar to how we created buffers earlier for the
    respective arrays:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标准备好后，我们必须创建一个类型为`MTLBuffer`的纹理缓冲区，并将纹理坐标数组传递给它，同时传递数组的大小。这与我们之前为相应数组创建缓冲区的方式类似：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we have to load the texture that we want to paste onto the quad. For this,
    we import the `Bg2.png` files that we used in the SpriteKit project. Add the following
    lines of code at the end of the initialization stage.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须加载我们想要粘贴到四边形上的纹理。为此，我们导入在SpriteKit项目中使用的`Bg2.png`文件。在初始化阶段的末尾添加以下代码行。
- en: 'First, we get the file from the local bundle location. We get the path to the
    file by passing the name of the file along with the extension. The data has to
    be then retrieved using the `NSData` method, in which we pass the path, as shown
    here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从本地包位置获取文件。通过传递文件名及其扩展名来获取文件的路径。然后，必须使用`NSData`方法检索数据，方法中传递路径，如图所示：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we get the image from the data and store it in a constant of type `UIImage`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从数据中获取图像并将其存储在类型为`UIImage`的常量中：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, we get the width and height and specify the color space for the image.
    A color space decides how the colors are to be interpreted. There are other ways
    in which colors can be stored, apart from the RGBA values; for example, we can
    provide colors in the CMYK format. As the color values in the image are specified
    in RGB, we have to specify it here.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取图像的宽度和高度，并指定图像的颜色空间。颜色空间决定了颜色如何被解释。除了RGBA值之外，还有其他存储颜色的方式；例如，我们可以提供CMYK格式的颜色。由于图像中的颜色值是以RGB指定的，因此我们必须在这里指定它。
- en: 'The width and height are obtained using the `CGImage` class, so we convert
    the image from the `UIImage` type to the `CGImage` type in this step:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度和高度是通过 `CGImage` 类获得的，因此在这一步我们将图像从 `UIImage` 类型转换为 `CGImage` 类型：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To store each pixel of the image, we need to specify the size of the data of
    the whole image, so memory is created for the data to be written into. Each pixel
    takes up 4 bytes of memory space. So to get the memory occupied by the whole image,
    we have multiply the width with the height and then multiply these values by four,
    which will give the data value for the bitmap image. This value is stored in a
    `bitmapData` constant as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储图像的每个像素，我们需要指定整个图像数据的大小，因此为要写入的数据创建内存。每个像素占用4字节内存空间。因此，为了获取整个图像占用的内存，我们需要将宽度乘以高度，然后将这些值乘以四，这将给出位图图像的数据值。这个值存储在
    `bitmapData` 常量中，如下所示：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As mentioned earlier, we assign the number of bytes per pixel in a constant
    called `bytesPerPixel`. Also, we create a `bytesPerRow` constant to get the number
    of bytes per row:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将每像素字节数赋值给一个名为 `bytesPerPixel` 的常量。同时，我们创建一个 `bytesPerRow` 常量来获取每行的字节数：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also need to specify how many bits does each component in a pixel take.
    A pixel is made up of `R`, `G`, `B`, and `A` values. For storing each value, we
    require 8 bits each. So for storing each RGBA value, we need 32 bits in total.
    As we''ll be requiring the value of bits per pixel component later on, we store
    the value in a constant called `bitsPerComponent` here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要指定像素中每个组件占用多少位。一个像素由 `R`、`G`、`B` 和 `A` 值组成。为了存储每个值，我们需要每个值8位。因此，为了存储每个RGBA值，我们需要总共32位。由于我们稍后需要使用每像素组件的位数，我们在这里将值存储在一个名为
    `bitsPerComponent` 的常量中：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we create a context that creates the environment by storing all the required
    data of the image. To the context we have to provide `bitmapData`, width and height
    of the image, bits per component, bytes per row, and `colorSpace` and `bitmapInfo`
    at the end.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个上下文，通过存储图像所需的所有数据来创建环境。我们必须向上下文提供 `bitmapData`、图像的宽度和高度、每组件的位数、每行的字节数，以及最后的
    `colorSpace` 和 `bitmapInfo`。
- en: 'In the bitmap information, we specify if there is an alpha channel in the image,
    the location of the alpha channel, and if the values are integers or float values:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在位图信息中，我们指定图像中是否存在alpha通道，alpha通道的位置，以及值是整数还是浮点值：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we get the rectangular size of the image. We create a `rect` variable
    of type `CGRect` and pass in the origin and the width and height of the image,
    as shown in the following lines of code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取图像的矩形尺寸。我们创建一个类型为 `CGRect` 的 `rect` 变量，并传入图像的起点、宽度和高度，如下面的代码行所示：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we get the image and store the RGBA data into `bitmapData` through the
    context. We first clear the context and then pass in the context, the rectangle,
    and the image:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取图像并将RGBA数据通过上下文存储到 `bitmapData` 中。我们首先清除上下文，然后传入上下文、矩形和图像：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For loading the texture into Metal, we need a texture descriptor, which stores
    all the relevant information. We create a new constant called `textureDescriptor`
    and a texture descriptor with the pixel format of RGBA8 uniform normal and pass
    in the width, height, and the data if we want the image to be **mipmapped**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将纹理加载到Metal中，我们需要一个纹理描述符，它存储所有相关信息。我们创建一个新的常量 `textureDescriptor` 和一个具有RGBA8均匀正常像素格式的纹理描述符，并传入宽度、高度以及如果想要图像进行**mipmap**处理的数据。
- en: 'Mipmap, as we saw in SceneKit, will create a lower resolution of the image
    and display it if the camera is far away from the texture to reduce the workload
    on the system, as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Mipmap，正如我们在SceneKit中看到的，将创建图像的较低分辨率版本，并在相机远离纹理时显示它，以减少系统的负载，如下所示：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We create a texture of type `MTLTexture` and pass in the texture descriptor:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个类型为 `MTLTexture` 的纹理，并传入纹理描述符：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we use the replace region function of type `MTLTexture` to replace
    the pixels with the image data that is stored in `bitmapData`. We pass in the
    region that is basically a rect and then we specify `mipmapLevel`, which is kept
    at `0` and sliced to determine which surface of the quad we will paste the image
    onto, as we just have one quad we specified as `0`. If we had more quads, such
    as a cube, we would have to specify values other than `0` for other faces. Next,
    we pass the `bitmapData`, which has the RGBA of the image stored in it; next,
    we pass in the `bytesPerRow` and `bytesPerImage` values in, as shown in the following
    lines of code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`MTLTexture`类型的替换区域函数，用存储在`bitmapData`中的图像数据替换像素。我们传入的区域基本上是一个矩形，然后我们指定`mipmapLevel`，它保持在`0`并切割以确定我们将图像粘贴到四边形的哪个表面，因为我们只指定了一个四边形，其值为`0`。如果我们有更多的四边形，例如一个立方体，我们不得不为其他面指定除`0`之外的其他值。接下来，我们传入`bitmapData`，其中存储了图像的RGBA值；然后，我们传入`bytesPerRow`和`bytesPerImage`值，如下面的代码行所示：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we are passing in a texture coordinate buffer and we need a texture to be
    drawn, we have to make some changes to the shader file. So, go to the shader file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们传递了一个纹理坐标缓冲区并且需要绘制一个纹理，我们必须对着色器文件进行一些修改。所以，转到着色器文件。
- en: 'First, change the `VertexInOut` struct, as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`VertexInOut`结构体，如下所示：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the highlighted code, the user keyword is used in shaders while specifying
    attributes that are user-defined:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在高亮显示的代码中，当在着色器中指定用户定义的属性时使用了用户关键字：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As the `textureCoordinate` buffer needs to be passed in, along with the position
    and color information, we pass it with the buffer index `2`. Also, while returning
    `outVertex`, we will assign the texture coordinate for that vertex ID in the function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`textureCoordinate`缓冲区需要传递，以及位置和颜色信息，我们使用缓冲区索引`2`将其传递。同时，在返回`outVertex`时，我们将在函数中为该顶点ID分配纹理坐标。
- en: 'Next, we also need to make changes to the `fragment` shader function, as we
    will be passing the texture into the fragment shader. So draw it on the quad,
    as shown in the following lines of code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要对`fragment`着色器函数进行修改，因为我们将要传递纹理到片段着色器中。所以，在四边形上绘制，如下面的代码行所示：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Along with the `stage_in` parameter, which we passed last time, we are also
    going to be passing the texture into the fragment shader with an index value of
    `0`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们上次传递的`stage_in`参数外，我们还将以`0`的索引值将纹理传递到片段着色器中。
- en: In the function to actually pick the color, a sampler is used. The sampler will
    decide how to pick the color from the texture that is passed in. The sampler is
    set as a `constexpr`, or a constant expression that is similar to a `const` type.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际选择颜色的函数中，使用了一个采样器。采样器将决定如何从传入的纹理中选取颜色。采样器被设置为`constexpr`，即类似于`const`类型的常量表达式。
- en: The sampler picks the colors, depending on the texture coordinates from the
    texture 2D that were provided using the `text2D.sample` function. The resultant
    color is stored and returned by the fragment shader.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器根据使用`text2D.sample`函数提供的纹理坐标从2D纹理中选取颜色。结果颜色被存储并由片段着色器返回。
- en: 'Next, in `renderEncoder`, add the following highlighted lines:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`renderEncoder`中添加以下高亮显示的行：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that although `vertexBuffer` and texture have the same index, they are
    treated differently, as `vertexBuffer` is one type of buffer that is separate
    from a texture. As the `textureCoordinate` buffer is a type buffer, we have to
    pass in an index value of `2` as we are already passing `0` and `1` for the vertex
    and the color buffer respectively.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`vertexBuffer`和纹理具有相同的索引，但它们被处理方式不同，因为`vertexBuffer`是一种与纹理分开的独立缓冲区。由于`textureCoordinate`缓冲区是一种类型缓冲区，我们必须传入索引值`2`，因为我们已经为顶点和颜色缓冲区分别传入了`0`和`1`。
- en: 'Finally, make changes to the pipeline descriptor to use the newly created fragment
    shader, as shown here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改管道描述符以使用新创建的片段着色器，如下所示：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And finally, there is one more thing to do, which is to build it and run!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一件事要做，那就是构建并运行它！
- en: '![The texture quad project](img/B04014_09_09.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![纹理四边形项目](img/B04014_09_09.jpg)'
- en: With this, we have gone full circle in this book. The first thing that you learned
    in 2D SpriteKit game development was how to add an image to the scene. We typed
    in three lines of code and the image appeared on the screen.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们在本书中完成了整个循环。在2D SpriteKit游戏开发中，你首先学习的是如何将图像添加到场景中。我们输入了三行代码，图像就出现在屏幕上了。
- en: In reality, we have to do all this to get a simple image onto the screen. But,
    as I said earlier, this is just the beginning; we still haven't seen how to move,
    rotate, or scale the quad.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们必须做所有这些事情才能将一个简单的图像显示在屏幕上。但是，正如我之前所说的，这只是一个开始；我们还没有看到如何移动、旋转或缩放四边形。
- en: We haven't yet looked at the depth buffer, which decides whether a portion of
    the image needs to be drawn on screen or not, depending on any other object that
    is in front of the current object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有查看深度缓冲区，它决定了图像的某个部分是否需要根据当前对象前面的任何其他对象绘制到屏幕上。
- en: Also, we have only looked at 2D. We haven't yet created a cube, for which additional
    vertices will be required. Deeper knowledge of algebra, trigonometry, and matrices
    will be required. Additional understanding of projections and model space, world
    space, view space, and screen space will be required, all of which are integral
    parts of graphics programming.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们只看了二维的情况。我们还没有创建一个立方体，这需要额外的顶点。需要更深入地了解代数、三角学和矩阵。还需要对投影和模型空间、世界空间、视图空间和屏幕空间有更深入的理解，这些都是图形编程的不可或缺的部分。
- en: It's needless to say that these topics are way beyond the scope of this book.
    In fact, a whole book could be dedicated to graphics programming using Metal,
    while another book could be dedicated to using Metal Shader language to create
    cool effects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，这些主题远远超出了本书的范围。事实上，可以有一整本书专门讲述使用Metal的图形编程，而另一本书可以专门讲述使用Metal着色器语言创建酷炫效果。
- en: For learning Metal, I recommend learning OpenGLES first as it has been there
    for so many years. Once you have a good understanding of that, you can put the
    knowledge into experimentation with Metal.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习Metal，我建议先学习OpenGLES，因为它已经存在了这么多年。一旦你对它有了很好的理解，你就可以将知识应用到Metal的实验中。
- en: For learning OpenGLES, I recommend *Building Android Games with OpenGLES*. Although
    it teaches development for Android as OpenGLES is cross-platform, you can use
    the same concepts for iOS game development. The link to the video can be found
    at [https://www.packtpub.com/game-development/building-android-games-opengl-es-video](https://www.packtpub.com/game-development/building-android-games-opengl-es-video).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习OpenGLES，我推荐《使用OpenGLES构建Android游戏》。尽管它教授的是Android开发，因为OpenGLES是跨平台的，你可以用同样的概念进行iOS游戏开发。视频链接可以在[https://www.packtpub.com/game-development/building-android-games-opengl-es-video](https://www.packtpub.com/game-development/building-android-games-opengl-es-video)找到。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how to create a simple triangle, quad, and a texture
    quad, and how to display these to the screen. You scratched the surface of graphics
    programming and learned the meaning of terms such as vertices, buffers, textures,
    and shaders.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何创建一个简单的三角形、四边形和一个纹理四边形，以及如何将这些显示到屏幕上。你只是触及了图形编程的表面，并学习了诸如顶点、缓冲区、纹理和着色器等术语的含义。
- en: This is merely the start of the learning process; there is still a lot to learn
    as graphics programming is a vast and deep subject, with courses specifically
    designed for it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是学习过程的开始；图形编程是一个庞大而深奥的主题，为此专门设计了课程，还有很多东西要学习。
- en: I hope this chapter has generated some interest for the subject in you; if nothing
    more, I think you will at least have some appreciation for the people who sit
    for hours and develop frameworks and engines for you so that you can make the
    game of your dreams, without having any knowledge of the subject.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章激发了你对该主题的兴趣；至少，我认为你至少会对那些坐几个小时开发框架和引擎以供你制作梦想中的游戏的人有所赞赏，而你对此一无所知。
- en: Talking about dreams, in the next chapter, you'll see how to finally publish
    a game on the iOS App Store.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 说到梦想，在下一章中，你将看到如何最终将游戏发布到iOS App Store。
