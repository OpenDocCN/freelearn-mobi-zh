- en: Chapter 8. Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** is one agile technique for software engineering
    that aims to improve the software quality and to reduce the time taken to integrate
    changes by continuously applying integration and testing frequently, opposed to
    the more traditional approach of integrating and testing by the end of the development
    cycle. The original article was written by Martin Fowler back in 2000 ([http://www.martinfowler.com/articles/continuousIntegration.html](http://www.martinfowler.com/articles/continuousIntegration.html)),
    and describes the experience of putting together Continuous Integration on a large
    software project.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration has received a broad adoption in recent years, and a
    proliferation of commercial tools and Open Source projects is a clear demonstration
    of its success. That is not very difficult to understand, as anybody who during
    their professional career has participated in a software development project using
    a traditional approach, is very likely to have experienced the so called *integration
    hell*, where the time it takes to integrate the changes exceeds the time it took
    to make the changes. Does this remind you of anything?
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, Continous Integration is the practice to integrate changes
    frequently and in small steps. These steps are negligible and usually no errors
    as a product of the integration can arise without beign noticed immediately. The
    most common practice is to trigger the build process after every commit to the
    source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'This practice also implies other requirements, beside the source code being
    maintained by a Version Control System (VCS):'
  prefs: []
  type: TYPE_NORMAL
- en: Builds should be automated by running a single command. This feature has been
    supported for a very long time by tools like `make` and more recently by `ant`
    and `maven`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build should be self tested to confirm that the newly built software meets
    the expectations of the developers, and this has been the subject of this book
    so far.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The artifacts and results of the tests should be easy to find and view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In previous chapters, we have written some tests for our Android projects and
    now we would like to take Continuous Integration into account. To achieve this
    we want to create a model that coexists with the traditional Eclipse and Android
    ADT environments, so both alternatives are supported from the source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we are going to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Automating the build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Version Control Systems to the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration with Hudson
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter you will be able to apply Continuous Integration to your
    own project no matter its size, whether it is a medium or large software project
    employing dozens of developers or it is just you programming solo.
  prefs: []
  type: TYPE_NORMAL
- en: Building Android applications manually using Ant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we aim to incorporate **Continuous Integration** in our development process,
    the first step will be building Android applications manually, as we can combine
    it with this technique to automate the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: In doing this we intend to keep our project compatible with the Eclipse and
    ADT plugin building process, and this is what we are going to do. As I understand,
    this is a great advantage and speeds up the development process by automatically
    building and eventually showing the errors that may exist in your project immediately.
    This is an invaluable tool too when editing resources or other files that generate
    intermediate classes, otherwise some simple errors would be discovered too late
    in the building process.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Android supports this alternative with the existing tooling and
    not much effort is needed to merge both approaches in the same project. In such
    cases, building manually with **ant** is supported. However, other options exist
    too, though not supported *out-of-the-box*, like using **maven** or even **make**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ant is a software command-line tool and a Java library to automate software
    build process by describing it in XML files containing targets and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: More information can be found at its home page, [http://ant.apache.org/](http://ant.apache.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The Android Ant based build system requires at least Ant 1.8 or newer versions.
  prefs: []
  type: TYPE_NORMAL
- en: Here it is worth noting that the entire Android platform is built by an incredibly
    complex structure of makefiles and this method is used even for building the applications
    that are included by the platform like Calculator, Contacts, Browser, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already building a project with Eclipse, you can convert it using
    the `android` tool. `android` is available in the tools directory of the Android
    SDK. If you are using Microsoft Windows you should adapt the following examples
    to use valid Windows paths and replace the variables that are not available, like
    PWD in the following example, by their values.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we change our current directory to the project; though not strictly
    necessary, this simplifies things a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then using the `android` command we convert the project to be built with `ant`
    and the `build.xml` buildfile is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updated local.properties**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Added file <path/to>/TemperatureConverter/build.xml**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updated file <path/to>/TemperatureConverter/proguard.cfg**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after finishing this step we are ready to build the project manually
    from the command line. This buildfile features the following targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Target | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| help | Displays a short help. |'
  prefs: []
  type: TYPE_TB
- en: '| clean | Removes output files created by other targets. |'
  prefs: []
  type: TYPE_TB
- en: '| compile | Compiles project''s `.java` files into `.class` files. |'
  prefs: []
  type: TYPE_TB
- en: '| debug | Builds the application and signs it with a debug key. |'
  prefs: []
  type: TYPE_TB
- en: '| release | Builds the application. The generated `.apk` file must be signed
    before it is published. |'
  prefs: []
  type: TYPE_TB
- en: '| install | Installs/reinstalls the debug package onto a running emulator or
    device.If the application was previously installed, the signatures must match.
    |'
  prefs: []
  type: TYPE_TB
- en: '| uninstall | Uninstalls the application from a running emulator or device.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Some of these targets operate on a device or emulator. If there are several
    devices or emulators connected to the build machine we need to specify the specific
    target on the command line. For this reason the targets uses a variable named
    `adb.device.arg` for us to specify the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buildfile: build.xml**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[setup] Android SDK Tools Revision 9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[setup] Project Target: Android 2.3.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[setup] API level: 9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[setup] Importing rules file: platforms/android-8/ant/ant_rules_r2.xml**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-compile-tested-if-test:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-dirs:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Creating output directories if needed..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[mkdir] Created dir: TemperatureConverter/bin/classes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-resource-src:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Generating R.java / Manifest.java from the resources..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-aidl:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Compiling aidl files into Java classes..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**compile:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[javac] Compiling 6 source files to TemperatureConverter/bin/classes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-dex:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Converting compiled files and external libraries into TemperatureConverter/bin/classes.dex..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-package-resources:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Packaging resources**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[aaptexec] Creating full resource package..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-package-debug-sign:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[apkbuilder] Creating TemperatureConverter-debug-unaligned.apk and signing
    it with a debug key..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[apkbuilder] Using keystore: .android/debug.keystore**'
  prefs: []
  type: TYPE_NORMAL
- en: '**debug:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Running zip align on final apk..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Debug Package: TemperatureConverter/bin/TemperatureConverter-debug.apk**'
  prefs: []
  type: TYPE_NORMAL
- en: '**install:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[echo] Installing TemperatureConverter/bin/TemperatureConverter-debug.apk
    onto default emulator or device..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[exec] 371 KB/s (18635 bytes in 0.049s)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[exec] pkg: /data/local/tmp/TemperatureConverter-debug.apk**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[exec] Success**'
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILD SUCCESSFUL**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Total time: 6 seconds**'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, running the command line mentioned, the following steps are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup, including the specific rules for the version used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the output directories if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the sources, including resources, aidl, and Java files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the compiled files into `dex`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package creation and signing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation onto the given device or emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have the APK installed, and because we are now doing everything from
    the command line, we can even start the `TemperatureConverterActivity`. Using
    the `am start` command and an `Intent` using the action `MAIN` and the `Activity`
    we are interested to launch as the component, we can create a command line as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Activity is started as you can verify in the emulator. Then, we can proceed
    in a similar way for the test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command, we will obtain output similar to the following if everything
    goes well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updated default.properties**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updated local.properties**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Added file <path/to>/TemperatureConverterTest/build.xml**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updated file <path/to>/TemperatureConverterTest/proguard.cfg**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updated build.properties**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also as we did before with the main project, we can build and install the tests.
    To do it, once we have our test project converted we can build it using `ant`
    as we did for the main project. To build and install it on a running emulator,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that to be able to build the project successfully we need
    the libraries used to reside in the `libs` directory inside the project. You can
    create symbolic links to their original location to avoid copying them if you
    prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is a good practice to keep the Eclipse and Ant build processes synchronized,
    so if you add the required libraries to the `libs` directory you can also replace
    the locations of the libraries in the Eclipse project using **Properties | Java
    Build Path | Libraries**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the tests from the command line as we already discussed in previous
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command we will obtain the tests results:'
  prefs: []
  type: TYPE_NORMAL
- en: '**com.example.aatg.tc.test.EditNumberTests:.......**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**com.example.aatg.tc.test.TemperatureConverterActivityTests:.........**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**com.example.aatg.tc.test.TemperatureConverterApplicationTests:....**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**com.example.aatg.tc.test.TemperatureConverterTests:...**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test results for InstrumentationTestRunner=..........................**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time: 12.125**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OK (28 tests)**'
  prefs: []
  type: TYPE_NORMAL
- en: We have done everything from the command line by just invoking some simple commands,
    which is what we were looking for in order to feed this into a **Continuous Integration**
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Git—the fast version control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Git** is a free and Open Source, distributed version control system designed
    to handle everything from small to very large projects with speed and efficiency.
    It is very simple to setup so I strongly recommend its use even for personal projects.
    There is no project simpler enough that could not benefit from the application
    of this tool. You can find information and downloads at [http://git-scm.com/.](http://git-scm.com/.)'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a version control system or VCS (also known as **Source Code
    Management** or **SCM)** is an unavoidable element for development projects where
    more than one developer is involved. Furthermore, even if it is possible to apply
    continuous integration with no VCS in place, as it is not a requisite clearly,
    is not a reasonable practice.
  prefs: []
  type: TYPE_NORMAL
- en: Other, and probably more traditional, options exist in the VCS arena such as
    Subversion or CVS that you are free to use if you feel more comfortable. Anyway,
    Git is used extensively by the Android project so it is worth investing some time
    to at least understand the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that and remembering that this is a very broad subject to justify
    a book in itself (and certainly there are some good books about it) we are discussing
    here the most basic topics and supplying examples to get you started if you haven't
    embraced this practice yet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the simplest possible commands to create a local repository and populate
    it with the initial source code for our projects. In this case again we are using
    `TemperatureConverter` and `TemperatureConverterTest` projects created and used
    in previous chapters. We are selecting a directory named `git-repos` as the parent
    for both projects and copying the code we used in the previous section, where
    we built manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That is, we create the parent for the repositories, create the project directory,
    initialize the git repository, copy the initial content, clean our previous built,
    remove the `local.properties` file, add everything to the repository, and commit.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `local.properties` file must never be checked in a Version Control System
    as it contains information specific to your local configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the same should be done for the `TemperatureConverterTest` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point we have two project repositories containing the initial source
    code for the `TemperatureConverter` and `TemperatureConverterTest` projects. We
    haven't altered their structure so they are also compatible with **Eclipse** and
    the **Android ADT** plugin to build while we develop in an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to have both projects built and tested automatically every
    time we commit a change to the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration with Hudson
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hudson** is an Open Source, extensible **Continuous Integration** server
    which has the ability to build and test software projects or to monitor the execution
    of external jobs. Hudson has an easy installation and configuration and does a
    very decent job and this is the reason why we are basing our example on it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recently (January 2011) a proposal was made to change the name from Hudson to
    Jenkins to avoid future legal problems as Oracle has submitted a trademark registration.
    Consequently now two different forked projects exist. Though these examples are
    based on Hudson you should monitor the evolution of the individual projects to
    find the one that better suites your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Hudson
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned easy installation as one of Hudson's advantages and installation
    could not be any easier.
  prefs: []
  type: TYPE_NORMAL
- en: Download the native package for the operating system of your choice from [http://hudson-ci.org/](http://hudson-ci.org/).
    There are native packages for Debian/Ubuntu, RedHat/Fedora/Centos, openSUSE, OpenSolaris/Nevada,
    and FreeBSD or download the latest generic `hudson.war` (which will work on Mac
    and Windows as well). In the following examples we will be using version 2.0\.
    We will show the latter as it is the one that does not require administrative
    privileges to install, configure, and run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once finished, copy it into a selected directory, let''s say `~/hudson`, and
    then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This expands and starts Hudson.
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration uses port 8080 as the HTTP listener port, so pointing
    your browser of choice to `http://localhost:8080` should present you with the
    Hudson home page.
  prefs: []
  type: TYPE_NORMAL
- en: You can verify and change Hudson's operating parameter if required, by accessing
    the **Manage Hudson** screen. We should add to this configuration the plugins
    needed for Git integration and support for Android emulator during builds. These
    plugins are named **Hudson GIT plugin** and **Android Emulator Plugin** respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot displays the information you can obtain about the plugins following
    the hyperlinks available on the Hudson administration page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and configuring Hudson](img/3500_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After installing and restarting Hudson these plugins will be available for use.
    Our next step is to create the jobs necessary to build the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating the `TemperatureConverter` job using **New Job in the
    Hudson home page**. Different kind of jobs can be created; in this case we are
    selecting **Build a free-style software project**, allowing you to connect any
    SCM with any build system.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the OK button you will be presented with the specific job
    options, which that are described in the following table. This is the job properties
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the jobs](img/3500_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All of the options in the **New Job** screen have a help text associated, so
    here we are only explaining the ones we are entering:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Project name | The name given to the project. |'
  prefs: []
  type: TYPE_TB
- en: '| Description | Optional description. |'
  prefs: []
  type: TYPE_TB
- en: '| Discard Old Builds | This helps you save on disk consumption by managing
    how long to keep records of the builds (such as console output, build artifacts,
    and so on.) |'
  prefs: []
  type: TYPE_TB
- en: '| This build is parameterized | This allows you to configure parameters that
    are passed to the build process to create parameterized builds. |'
  prefs: []
  type: TYPE_TB
- en: '| Disable Build (No new builds will be executed until the project is re-enabled.)
    | Temporarily disable the project. |'
  prefs: []
  type: TYPE_TB
- en: '| Execute concurrent builds if necessary (beta) | This permits the execution
    of several builds concurrently. |'
  prefs: []
  type: TYPE_TB
- en: '| Source Code Management | Also know as VCS.Where is the source code for the
    project? In this case we are using git and a repository where the URL is the absolute
    path of the repository we created earlier. For example, `/home/diego/aatg/git-repos/TemperatureConverter`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Build Triggers | How this project is automatically built. In this case we
    want that every change in the source code triggers the automatic build so we are
    selecting **Poll SCM**. The other option is to use **Build periodically**. This
    feature is primarily for using Hudson as a `cron` replacement, and it is not ideal
    for continuously building software projects. When people first start continuous
    integration, they are often so used to the idea of regularly scheduled builds
    like nightly/weekly that they use this feature. However, the point of continuous
    integration is to start a build as soon as a change is made, to provide a quick
    feedback to the change. |'
  prefs: []
  type: TYPE_TB
- en: '| Schedule | This field follows the syntax of `cron` (with minor differences).
    Specifically, each line consists of five fields separated by TAB or whitespace:
    `MINUTE HOUR DOM MONTH DOW`.For example if we want to poll continuously at thirty
    minutes past the hour specify: `30 * * * *`Check the documentation for a complete
    explanation of all the options. |'
  prefs: []
  type: TYPE_TB
- en: '| Build environment | Lets you specify different options for the build environment
    and for the Android emulator that may run during the build. |'
  prefs: []
  type: TYPE_TB
- en: '| Build | This describes the build steps. We are selecting **Invoke Ant** as
    we are reproducing the steps we did before to manually build the project.The target
    we use here is `debug` as we only want to compile the project and generate the
    APK, and not install or run it. Additionally, using the **Advanced..**. options
    we need to specify the Android SDK directory and the Android target version **Properties**.`sdk.dir=/opt/android-sdk
    target=android-9` |'
  prefs: []
  type: TYPE_TB
- en: '| Post build actions | These are a series of actions we can do after the build
    is done. We are interested in saving the APKs so we are enabling **Archive the
    artifacts** and then defining the path for them as **Files to archive**; in this
    precise case it is `**/*-debug.apk`. |'
  prefs: []
  type: TYPE_TB
- en: 'Now there are two options: you can force a build using **Build now**, or introduce
    some changes to the source code through Git and wait for them to be detected by
    our polling strategy. Either way, we would get our project built and our artifacts
    ready to be used for other purposes, such as dependency projects or QA.'
  prefs: []
  type: TYPE_NORMAL
- en: So far we haven't run any tests and this is just what we are presenting now.
    Hudson has the ability to handle dependencies between projects, so we are now
    creating a Hudson job, `TemperatureConverterTest` depending on `TemperatureConverter`.
  prefs: []
  type: TYPE_NORMAL
- en: Proceed in the same way as before. We are only pinpointing the differences in
    setting up this project against the previous setup.
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Build Triggers | This is how we trigger the build of this project. **Built
    after other projects are built** is selected so that when some other projects
    finish building, a new build is scheduled for this project. We need this to be
    built after `TemperatureConverter`.This is convenient for running an extensive
    test after a build is complete as in this example. |'
  prefs: []
  type: TYPE_TB
- en: '| Build environment | Our intention is to install and run the tests on an emulator
    so for our build environment we use the facilities provided by the **Android Emulator
    Plugin**. This comes in handy if you wish to automatically start an Android emulator
    of your choice before the build steps execute, with the emulator being stopped
    after building is complete.You can choose to start a pre-defined, existing Android
    emulator instance (AVD).Alternatively, the plugin can automatically create a new
    emulator on the build slave with properties you specify here.In any case, the
    `logcat` output will automatically be captured and archived.Then select `2.3`
    for the **Android OS version**, `240` DPI for the **Screen density** and `WVGA`
    for **Screen resolution**.Feel free to experiment and select the options that
    better suit your needs. |'
  prefs: []
  type: TYPE_TB
- en: '| Common emulator options | We would like to **Reset emulator state at start-up**
    to wipe user data and disable **Show emulator window**, so the emulator window
    is not displayed. |'
  prefs: []
  type: TYPE_TB
- en: '| Build | Select **Invoke ant** as the build step and `install` as the **Target**.
    Here again, as we did in `TemperatureConverter`, we have to set some variables
    to build and install the current job. Using the **Advanced..**. options set:`sdk.dir=/opt/android-sdk``target=android-9``tested.project.dir=../../TemperatureConverter/workspace/``adb.device.arg=-s
    $ANDROID_AVD_DEVICE`As before, we specified the Android SDK directory and the
    target version. Additionally, here we should specify the target project directory,
    that is the SUT, and the device where we want to install the APK. We are using
    a special variable set by the **Android Emulator Plugin** to identify the ADV
    that was chosen as the target. |'
  prefs: []
  type: TYPE_TB
- en: After configuring and building this project, we have the APK installed on the
    target emulator. Some steps are still needed as we still miss running the tests
    and obtaining the results to be displayed in Hudson.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining Android test results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to display test results we should store raw XML results in the test
    runner. The default `android.test.InstrumentationTestRunner` does not support
    storing raw XML so the solution here is to extend it to provide the missing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: I found the `nbandroid-utils` ([http://code.google.com/p/nbandroid-utils/](http://code.google.com/p/nbandroid-utils/))
    project hosted in Google code that provides almost the same functionality that
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: The `com.neenbedankt.android.test.InstrumentationTestRunner` class extends the
    Android one so that an XML of the test results is written to the device when running
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: We also want the ability to specify the filename from the test arguments and
    be able to store files in external storage just in case test results become very
    large, so we are slightly modifying the class to support these features. Also,
    to make these changes evident we are naming the new class `XMLInstrumentationTestRunner:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we are providing the field to keep the name of the output file as well
    as its default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also defining the name of the argument our test runner will use to receive
    this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `onCreate()` method we verify if the argument has been provided and
    if so we store it in the previously defined field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onStart()` method we create the file and we use it as the JUnit output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the original code for this test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are still a few steps required to achieve our objective. The first is
    to add this test runner to our project using the combination `git add/git commit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to declare the instrumentation using the test runner in `AndroidManifest.xml`.
    That is use the recently created test runner `com.neenbedankt.android.test.XMLInstrumentationTestRunner`
    as the instrumentation for the `com.example.aatg.tc` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Also, add it to the repository as we did before with other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, as we have the ability to add a step in the build process by using
    **Add build step** that executes arbitrary commands in a shell script, we add
    this as an **Execute shell** step in the job configuration page. We are using
    some shell variables to be able to re-utilize this step for other projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us explain these steps in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We assign a specific project package name to PKG variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OUTDIR` is the name of the directory where the test runner will leave the
    file `OUTFILE`. Note that this is a directory on the emulator or device, not a
    local directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the package under test onto the emulator or device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the instrumentation from the command line, as we have seen previously, but
    in this case adding an extra argument `-e outfile` with the name of the file we
    are expecting to receive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the test results from that file, pulling from the device to the local workspace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost everything is in place. The only thing left is to tell Hudson where to
    expect these test results. In this scenario we use the **Post Build Actions also
    in the job configuration page**.
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Publish Junit test results report | When this option is configured, Hudson
    can provide useful information about test results, such as historical test result
    trends, a web UI for viewing test reports, tracking failures, and so on.To use
    this feature, first set up your build to run tests, then use `com.neenbedankt.android.test.XMLInstrumentationTestRunner`
    as the test runner, specify the output using `-e outfile` in the instrumentation,
    and use this same name to tell Hudson where to find the results. Ant glob syntax,
    such as `**/build/test-reports/*.xml`, can also be used.Be sure not to include
    any non-report files into this pattern.In simple terms, this is simply `test-results.xml`
    as we specified in the `OUTFILE` variable before.Once there are a few builds running
    with test results, you should start seeing some trend charts displaying the evolution
    of tests. |'
  prefs: []
  type: TYPE_TB
- en: 'Having done all of the steps described before, only forcing a build is left
    to see the results. Press **Build now** as usual and after a few moments you will
    see your test results and statistics displayed in a similar way as the following
    screenshot depicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining Android test results](img/3500_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From here we can easily understand our project status, knowing how many tests
    failed and why. Digging through the failed tests we can also find the extensive
    **Error message** and **Stack trace**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also really helpful to understand the evolution of a project through
    the evaluation of different trends and Hudson is able to provide such information.
    Every project presents the current trends using weather-like icons from sunny,
    when the health of the project increases 80%, and to thunderstorm when the health
    lies bellow 20%. In addition, for every project the evolution of the trend of
    the tests success versus failure ratio is displayed in a chart that is reproduced
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining Android test results](img/3500_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case we can see how since the last build, one test started to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how a project status changes by forcing a failure let''s add a failing
    test like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet another very interesting feature that is worth mentioning is the ability
    of Hudson to keep and display the Timeline and Build Time Trend, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining Android test results](img/3500_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This page presents the build history with hyperlinks to every particular build
    that you can follow to see the details.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have less concern to be worried about and every time somebody in the
    developer team commits changes to the repository we know that these changes will
    be immediately integrated and the whole project will be built and tested and if
    we further configure Hudson we can even receive the status by e-mail. To achieve
    this, in the job configuration page enable **E-mail Notification** and enter the
    desired **Recipients**.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced **Continuous Integration** in practice providing
    valuable information to start applying it soon to your projects no matter what
    their size is, whether you are developing solo or on a big company team.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques presented focus on the particularities of Android projects maintaining
    and supporting widely used development tools like Eclipse and Android ADT.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced real-world examples with real-world tools available from the vast
    Open Source arsenal. We employed Ant to automate the building process, git to
    create a simple version control system repository to store our source code and
    manage the changes, and finally installed and configured Hudson as the Continuous
    Integration of choice.
  prefs: []
  type: TYPE_NORMAL
- en: In this course we detailed the creation of jobs for automating the creation
    of `TemperatureConverter` and its tests and we emphasized on the relationship
    between the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we analyzed a way of getting XML results from Android tests and implemented
    this to obtain an attractive interface to monitor the running of tests, their
    results, and the existing trends.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter deals with a different aspect of testing concentrating on performance
    and profiling which is probably the natural step to follow after we have our application
    behaving correctly and according to our specifications.
  prefs: []
  type: TYPE_NORMAL
