<html><head></head><body>
        

                            
                    <h1 class="header-title">Making Asynchronous Programming Great Again</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Executing tasks in the background using threads</li>
<li>Background threads synchronization</li>
<li>Using coroutines for asynchronous, concurrent execution of tasks</li>
<li class="p1">Using coroutines for asynchronous, concurrent tasks execution with results handling</li>
<li>Applying coroutines for asynchronous data processing </li>
<li>Easy coroutine cancelation</li>
<li>Building a REST API client with Retrofit and a coroutines adapter</li>
<li>Wrapping third-party callback-style APIs with coroutines</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This chapter is going to address various aspects of asynchronous programming problems. The first two recipes, <em>Executing tasks in the background using threads</em> and <em>Background-threads synchronization</em>,<em> </em>are going to explain the standard library support for running background tasks using JVM threads.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the further recipes, we are going to delve more deeply into the powerful Kotlin Coroutines framework. Those recipes are going to explain a general usage of coroutines for asynchronous and concurrent tasks executing. They will also present how to employ coroutines for solving more specific daily-life programming problems, such as concurrent data processing, asynchronous REST-call handling, and working with third-party callback-style APIs in a clean way. After reading this chapter, you will feel convenient applying the coroutines framework to write robust asynchronous code or to optimize your code by running expensive computations concurrently.</p>
<p>The Kotlin Coroutines framework is not only a handy replacement for platform-specific concurrency and async frameworks. Its power is based on providing a unified, universal API that allows us to write asynchronous code, which can be run both on JVM, Android, JavaScript, and native platforms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing tasks in the background using threads</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to work effectively with the JVM <kbd>Thread</kbd> class in a clean way using the Kotlin standard library functions dedicated to convenient thread-running. We are going to simulate two long-running tasks and execute them concurrently in background threads.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we are going to make use of two functions simulating long-running operations. Here is the first:</p>
<pre>private fun `5 sec long task`() = Thread.sleep(5000)</pre>
<p>And here is the second:</p>
<pre>private fun `2 sec long task`() = Thread.sleep(2000)</pre>
<p>They are both just responsible for blocking a current thread for five and two seconds, respectively, in order to simulate long-running tasks. We will also make use of the predefined function returning the current thread name for debugging purposes:</p>
<pre>private fun getCurrentThreadName(): String = Thread.currentThread().name</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start by logging the current thread name to the console:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")</pre>
<ol start="2">
<li>Start a new <kbd>Thread</kbd> and invoke the <kbd>`5 sec long task`()</kbd> function inside it:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")<br/><br/><strong>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")</strong><br/><strong>    `5 sec long task`()</strong><br/><strong>    println("Ending async operation on ${getCurrentThreadName()}")</strong><br/><strong>}</strong></pre>
<ol start="3">
<li>Start another <kbd>Thread</kbd> and invoke <kbd>`2 sec long task`()</kbd> inside it:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")<br/><br/>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")<br/>    `5 sec long task`()<br/>    println("Ending async operation on ${getCurrentThreadName()}")<br/>}<br/><br/><strong>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")</strong><br/><strong>    `2 sec long task`()</strong><br/><strong>    println("Ending async operation on ${getCurrentThreadName()}")</strong><br/><strong>}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The preceding code is going to print the following text to the console:</p>
<pre><strong>Running on main</strong><br/><strong>Starting async operation on Thread-0</strong><br/><strong>Starting async operation on Thread-1</strong><br/><strong>Ending async operation on Thread-1</strong><br/><strong>Ending async operation on Thread-0</strong></pre>
<p class="mce-root"/>
<p>As you can see, we have successfully started two background threads, which are running concurrently. We are using the <kbd>thread()</kbd> utility function from the <kbd>kotlin.concurrent</kbd> package, which is responsible for instantiating and starting a new thread that runs a block of code passed to it in the form of a lambda expression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Take a look at the rest of the recipes to discover how to use the Kotlin Coroutines framework to replace the threading mechanism with a more robust and flexible framework. A good starting point could be the <em>Using coroutines for asynchronous concurrent-tasks execution </em>and <em>Using coroutines for asynchronous concurrent-tasks execution with results-handling </em>recipes.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Background threads synchronization</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to work effectively with the JVM <kbd>Thread</kbd> class in a clean way using the Kotlin standard library functions dedicated to running threads in a convenient way. We are going to simulate two long-running tasks and execute them in background threads synchronously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we are going to make use of the following two functions to simulate long-running operations. The <kbd>`5 sec long task`()</kbd> function:</p>
<pre>private fun `5 sec long task`() = Thread.sleep(5000)</pre>
<p>and the <kbd>`2 sec long task`()</kbd> function:</p>
<pre>private fun `2 sec long task`() = Thread.sleep(2000)</pre>
<p>They are both just responsible for blocking a current thread for five and two seconds, respectively, in order to simulate long-running tasks. We will also make use of the predefined function returning the current thread name for debugging purposes:</p>
<pre>private fun getCurrentThreadName(): String = Thread.currentThread().name</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start by logging the current thread name to the console:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")</pre>
<ol start="2">
<li>Start a new <kbd>Thread</kbd> and invoke the <kbd>`5 sec long task`()</kbd> function inside it:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")<br/><br/><strong>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")</strong><br/><strong>    `5 sec long task`()</strong><br/><strong>    println("Ending async operation on ${getCurrentThreadName()}")</strong><br/><strong>}</strong></pre>
<ol start="3">
<li>Wait until the thread completes:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")<br/><br/>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")<br/>    `5 sec long task`()<br/>    println("Ending async operation on ${getCurrentThreadName()}")<br/>}<strong>.join()</strong></pre>
<ol start="4">
<li>Start another <kbd>Thread</kbd> and invoke <kbd>`2 sec long task`()</kbd> inside it:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")<br/><br/>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")<br/>    `5 sec long task`()<br/>    println("Ending async operation on ${getCurrentThreadName()}")<br/>}.join()<br/><br/><strong>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")</strong><br/><strong>    `2 sec long task`()</strong><br/><strong>    println("Ending async operation on ${getCurrentThreadName()}")</strong><br/><strong>}</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Wait until the thread completes:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")<br/><br/>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")<br/>    `5 sec long task`()<br/>    println("Ending async operation on ${getCurrentThreadName()}")<br/>}.join()<br/><br/>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")<br/>    `2 sec long task`()<br/>    println("Ending async operation on ${getCurrentThreadName()}")<br/>}<strong>.join()</strong></pre>
<ol start="6">
<li>Test whether the main thread is free at the end:</li>
</ol>
<pre style="padding-left: 60px">println("Running on ${getCurrentThreadName()}")<br/><br/>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")<br/>    `5 sec long task`()<br/>    println("Ending async operation on ${getCurrentThreadName()}")<br/>}.join()<br/><br/>thread {<br/>    println("Starting async operation on ${getCurrentThreadName()}")<br/>    `2 sec long task`()<br/>    println("Ending async operation on ${getCurrentThreadName()}")<br/>}.join()<br/><br/><strong>println("${getCurrentThreadName()} thread is free now")</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The preceding code is going to print the following text to the console:</p>
<pre><strong>Running on main</strong><br/><strong>Starting async operation on Thread-0</strong><br/><strong>Ending async operation on Thread-0</strong><br/><strong>Starting async operation on Thread-1</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre><strong>Ending async operation on Thread-1</strong><br/><strong>main thread is free now</strong></pre>
<p>We have successfully started two background threads, which are synchronized. In order to run both background threads sequentially, we are using the <kbd>Thread.join()</kbd> function, which just blocks the main thread until the background thread completes. In order to instantiate and start a new background thread, we are using the <kbd>thread()</kbd> utility function from the <kbd>kotlin.concurrent</kbd> package. We are passing it a block of code to be run inside the thread inside a lambda expression. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Take a look at the next recipes explaining how to use the Kotlin Coroutines framework to replace the threading mechanism with a more robust and flexible framework. A good starting point could be the <em>Using coroutines for asynchronous concurrent-tasks execution </em>and <em>Using coroutines for asynchronous concurrent-tasks execution with results-handling </em>recipes.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Using coroutines for asynchronous, concurrent execution of tasks</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to use the coroutines framework in order to schedule asynchronous, concurrent execution of tasks. We are going to learn both how to synchronize a sequence of short background tasks and how to run expensive, long-running ones at the same time. We will simulate the sushi rolls preparation process to discover how to schedule blocking and non-blocking tasks together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The first step to start working with Kotlin Coroutines is to add the core framework dependency to the project:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.23.3' </pre>
<p>The preceding code declares the <kbd>kotlinx-coroutines-core</kbd> dependency in a Gradle build script, which is used in the sample project (<a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>).</p>
<p class="mce-root"/>
<p>In the current recipe, we will assume our sushi-cooking simulation requires the four following steps to be performed:</p>
<ol>
<li>Cook the rice </li>
<li>Prepare the fish</li>
<li>Cut the vegetables</li>
<li>Roll the sushi</li>
</ol>
<p>These steps are going to be simulated by the following functions:</p>
<pre>private fun <strong>`cook rice`</strong>() {<br/>    println("Starting to cook rice on ${getCurrentThreadName()}")<br/>    Thread.sleep(10000)<br/>    println("Rice cooked")<br/>}<br/><br/>private fun <strong>`prepare fish`</strong>() {<br/>    println("Starting to prepare fish on ${getCurrentThreadName()}")<br/>    Thread.sleep(2000)<br/>    println("Fish prepared")<br/>}<br/><br/>private fun <strong>`cut vegetable`</strong>() {<br/>    println("Starting to cut vegetables on ${getCurrentThreadName()}")<br/>    Thread.sleep(2000)<br/>    println("Vegetables ready")<br/>}<br/><br/>private fun <strong>`roll the sushi`</strong>() {<br/>    println("Starting to roll the sushi on ${getCurrentThreadName()}")<br/>    Thread.sleep(2000)<br/>    println("Sushi rolled")<br/>}</pre>
<p>We will also use the following function to log a current thread name to the console: </p>
<pre>private fun <strong>`print current thread name`</strong>() {<br/>    println("Running on ${getCurrentThreadName()}")<br/>    println()<br/>}<br/><br/>private fun getCurrentThreadName(): String = Thread.currentThread().name</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>For the sake of the exercise, we will assume the sushi-roll preparation process must fulfill the following requirements:</p>
<ul>
<li>The longest <em>Rice-cooking</em> step must be executed in the background in a non-blocking way</li>
<li>The <em>Fish-preparation</em> and <em>Vegetable-cutting</em> steps have to be performed one by one while the rice is cooking</li>
<li>The <em>Sushi-rolling</em> step can be done only when the first three steps are completed</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start by logging the current thread name to the console:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()</pre>
<ol start="2">
<li>Start a new coroutine running on a pool of background threads:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/><strong>var sushiCookingJob: Job</strong><br/><strong>sushiCookingJob = launch(newSingleThreadContext("SushiThread")) {<br/>    `print current thread name`()</strong><br/><strong>}</strong></pre>
<ol start="3">
<li>Execute the <kbd>`cook rice`()</kbd> function asynchronously in a nested coroutine:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/>var sushiCookingJob: Job<br/>sushiCookingJob = launch(newSingleThreadContext("SushiThread")) {<br/>    `print current thread name`()<br/>    <strong>val riceCookingJob = launch {<br/>        `cook rice`()</strong><br/><strong>    }</strong><br/>}</pre>
<ol start="4">
<li>Run the <kbd>`prepare fish`()</kbd> and  <kbd>`cut vegetable`()</kbd> functions sequentially while the <kbd>`cook rice`()</kbd> function is running in the background:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/>var sushiCookingJob: Job<br/>sushiCookingJob = launch(newSingleThreadContext("SushiThread")) {<br/>    `print current thread name`()<br/>    val riceCookingJob = launch {<br/>        `cook rice`()<br/>    }<br/>    println("Current thread is not blocked while rice is being<br/>     cooked")<br/>  <strong>  `prepare fish`()</strong><br/><strong>    `cut vegetable`()</strong><br/>}</pre>
<ol start="5">
<li>Wait until the rice-cooking coroutine completes:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/>var sushiCookingJob: Job<br/>sushiCookingJob = launch(newSingleThreadContext("SushiThread")) {<br/>    `print current thread name`()<br/>    val riceCookingJob = launch {<br/>        `cook rice`()<br/>    }<br/>    println("Current thread is not blocked while rice is being<br/>     cooked")<br/>    `prepare fish`()<br/>    `cut vegetable`()<br/><strong>    riceCookingJob.join()</strong><br/>}</pre>
<ol start="6">
<li>Invoke the final <kbd>`roll the sushi`()</kbd> function and wait until the main coroutine completes:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/>var sushiCookingJob: Job<br/>sushiCookingJob = launch(newSingleThreadContext("SushiThread")) {<br/>    `print current thread name`()<br/>    val riceCookingJob = launch {<br/>        `cook rice`()<br/>    }<br/>    println("Current thread is not blocked while rice is being<br/>     cooked")<br/>    `prepare fish`()<br/>    `cut vegetable`()<br/>    riceCookingJob.join()<br/><strong>    `roll the sushi`()</strong><br/>}<br/><strong>runBlocking {<br/>   sushiCookingJob.join()</strong><br/><strong>}</strong></pre>
<ol start="7">
<li>Measure the total time for function execution and log it to the console:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/>var sushiCookingJob: Job<br/><strong>val time = measureTimeMillis {<br/></strong>    sushiCookingJob = launch(newSingleThreadContext("SushiThread")) {<br/>        `print current thread name`()<br/>        val riceCookingJob = launch {<br/>            `cook rice`()<br/>        }<br/>        println("Current thread is not blocked while rice is being<br/>         cooked")<br/>        `prepare fish`()<br/>        `cut vegetable`()<br/>        riceCookingJob.join()<br/>        `roll the sushi`()<br/>    }<br/>    runBlocking {<br/>        sushiCookingJob.join()<br/>    }<br/><strong>}</strong><br/><strong>println("Total time: $time ms")</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The preceding code is going to print the following text to the console:</p>
<pre><strong>Running on main</strong><br/><strong>Running on SushiThread</strong><br/><strong>Current thread is not blocked while rice is being cooked</strong><br/><strong>Starting to cook rice on ForkJoinPool.commonPool-worker-1</strong><br/><strong>Starting to prepare fish on SushiThread</strong><br/><strong>Fish prepared</strong><br/><strong>Starting to cut vegetables on SushiThread</strong><br/><strong>Vegetables ready</strong><br/><strong>Rice cooked</strong><br/><strong>Starting to roll the sushi on SushiThread</strong><br/><strong>Sushi rolled</strong><br/><strong>Total time: 12089 ms</strong></pre>
<p>In the beginning, we start a new coroutine running on a background thread with the <kbd>launch()</kbd> function call. We also create a handle to the <kbd>Job</kbd> instance returned by the <kbd>launch()</kbd> function under the <kbd>var sushiCookingJob: Job</kbd> variable.</p>
<p class="mce-root"/>
<p>The <kbd>launch()</kbd> function starts a new coroutine instance on a default <kbd>CoroutineContext</kbd> instance. However, we are able to pass our desired <kbd>CoroutineContext</kbd> as an additional parameter to the <kbd>launch()</kbd> function. When targeting the JVM platform, by default the <kbd>launch()</kbd> function starts a coroutine on a pool of background threads, which corresponds to the <kbd>CommonPool</kbd> context constant. We can also run the coroutine on a single thread by passing a context result of the <kbd>newSingleThreadContext()</kbd> function. If you are working with UI frameworks, such as Android, Swing, or JavaFx, you can run a coroutine on a <kbd>UI</kbd> context as well. The <kbd>UI</kbd> context is related to the main thread responsible for user-interface updates. There are different modules that provide the <kbd>UI</kbd> context implementation dedicated to a specific framework. You can learn more about framework-specific UI programming with coroutines in the following official guide: <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md">https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md</a>.</p>
<p>Inside the main coroutine, we are starting a new one and invoking the <kbd>`cook rice`()</kbd> function inside it. We are storing a handle to the <kbd>Job</kbd> instance corresponding to the coroutine handling the <kbd>`cook rice`()</kbd> function under the <kbd>val riceCookingJob: Job</kbd> variable. At this point, the rice-cooking task begins to run concurrently on a pool of threads.</p>
<p>Next, we are invoking two functions—<kbd>`prepare fish`()</kbd> and <kbd>`cut vegetable`()</kbd>. As you can see in the console output, those functions are executed sequentially. The vegetable-cutting task starts right after the fish-preparation completes. If we'd like to run them concurrently, we'd need to start each one inside a new coroutine.</p>
<p>Finally, we wait for the completion of the rice-cooking task by calling a <kbd>join()</kbd> function on the <kbd>riceCookingJob</kbd> variable. Here, the <kbd>join()</kbd> function suspends the primary <kbd>sushiCookingJob</kbd> coroutine until <kbd>riceCookingJob</kbd> is complete. Right after the primary coroutine gets unblocked, the last  <kbd>`roll the sushi`()</kbd> function is invoked.</p>
<p>In order to await the primary coroutine completion, we need to invoke a <kbd>join()</kbd> function on the <kbd>sushiCookingJob</kbd> instance after starting it on the main thread. However, we are not able to call the <kbd>join()</kbd> function outside of a coroutine scope. We need to call it inside a new <em>blocking</em> coroutine started with a <kbd>runBlocking()</kbd> function.</p>
<p class="mce-root"/>
<p>The coroutines framework is designed to allow us to execute tasks in a non-blocking way. Although we are able to write non-blocking code inside a coroutine's scope, we need to provide a bridge to the original thread inside the application that starts the primary coroutine.  We are able to connect the non-blocking coroutine scope with the blocking world outside using the <kbd>runBlocking()</kbd> function.<br/>
The <kbd>runBlocking()</kbd> function starts a new coroutine and blocks the current thread until its completion. It is designed to bridge regular blocking code to libraries that are written in suspending style. For example, it can be used in <kbd>main()</kbd> functions and in tests.</p>
<p class="mce-root">Coroutines can be seen as lightweight thread replacements. Coroutines are lightweight in terms of resource consumption. For example, we can start a million coroutines concurrently with ease, where, after a second, each of them logs the current thread name to the console:</p>
<pre>runBlocking {<br/>    (0..1000000).map {<br/>        launch {<br/>            delay(1000)<br/>            println("Running on ${Thread.currentThread().name}")<br/>        }<br/>    }.map { it.join() }<br/>}</pre>
<p>The preceding code will complete in about 10 seconds on a standard computer. In contrast, if we try to run this code using threads, we get the <kbd>OutOfMemoryError: unable to create new native thread</kbd> exception.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can follow up by reading the <em>Using coroutines for asynchronous, concurrent tasks execution with results handling</em><em> </em>recipe. It shows you how to asynchronously schedule functions that return the results.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using coroutines for asynchronous, concurrent tasks execution with results handling</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to use the coroutines framework in order to run asynchronous operations concurrently, and learn how to handle the results they return properly. We are going to schedule two tasks and run them in the background using two coroutines. The first task is going to be responsible for displaying the progress-bar animation. The second one is going to simulate long-running computations. In the end, we are going to print the results returned by the second task to the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The first step to start working with Kotlin Coroutines is to add a core framework dependency to the project:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.23.3' </pre>
<p>The preceding code declares the <kbd>kotlinx-coroutines-core</kbd> dependency in a Gradle build script, which is used in the sample project (<a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>).</p>
<p>In the current recipe, we are going to make use of the following two functions: </p>
<pre>private suspend fun `calculate the answer to life the universe and everything`(): Int {<br/>    delay(5000)<br/>    return 42<br/>}<br/><br/>private suspend fun `show progress animation`() {<br/>    val progressBarLength = 30<br/>    var currentPosition = 0<br/>    while (true) {<br/>        print("\r")<br/>        val progressbar = (0 until progressBarLength)<br/>                .map { if (it == currentPosition) " " else "░" }<br/>                .joinToString("")<br/>        print(progressbar)<br/><br/>        delay(50)<br/><br/>        if (currentPosition == progressBarLength) {<br/>            currentPosition = 0<br/>        }<br/>        currentPosition++<br/>    }<br/>}</pre>
<p>The first one is simulating an expensive computation that delays a thread for five seconds and returns the result in the end. The second one is responsible for displaying an infinite progress-bar animation. We are going to start both operations concurrently and wait for the result returned by the first one. After we get the result, we will print it to the console.</p>
<p>We will also use the following function to log a current thread name to the console:</p>
<pre>private fun `print current thread name`() {<br/>    println("Running on ${getCurrentThreadName()}")<br/>    println()<br/>}<br/><br/>private fun getCurrentThreadName(): String = Thread.currentThread().name</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start by logging a current thread name to the console:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()</pre>
<ol start="2">
<li>Start a coroutine responsible for displaying progress-bar animation from the background:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/><br/><strong>launch {<br/>    println("Starting progressbar animation on ${getCurrentThreadName()}")</strong><br/><strong>    `show progress animation`()</strong><br/><strong>}</strong></pre>
<ol start="3">
<li>Start a coroutine responsible for running the <kbd>`calculate the answer to life the universe and everything`()</kbd> function in the background:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/><br/>launch {<br/>    println("Starting progressbar animation on ${getCurrentThreadName()}")<br/>    `show progress animation`()<br/>}<br/><br/><strong>val future = async {<br/>    println("Starting computations on ${getCurrentThreadName()}")</strong><br/><strong>    `calculate the answer to life the universe and everything`()</strong><br/><strong>}</strong><br/><br/>println("${getCurrentThreadName()} thread is not blocked while tasks are in progress")</pre>
<ol start="4">
<li>Wait for the result returned by the <kbd>future</kbd> coroutine and print it to the console:</li>
</ol>
<pre style="padding-left: 60px">`print current thread name`()<br/><br/>launch {<br/>    println("Starting progressbar animation on ${getCurrentThreadName()}")<br/>    `show progress animation`()<br/>}<br/><br/>val future = async {<br/>    println("Starting computations on ${getCurrentThreadName()}")<br/>    `calculate the answer to life the universe and everything`()<br/>}<br/><br/>println("${getCurrentThreadName()} thread is not blocked while tasks are in progress")<br/><br/><strong>runBlocking {<br/>    println("\nThe answer to life the universe and everything: ${future.await()}")</strong><br/><strong>    `print current thread name`()</strong><br/><strong>}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Our code is going to display the progress-bar animation for five seconds and then print the result of the <kbd>`calculate the answer to life the universe and everything`()</kbd> function once it completes the simulated calculations:</p>
<pre><strong>Running on main</strong><br/><strong>Starting progressbar animation on ForkJoinPool.commonPool-worker-1</strong><br/><strong>Starting calculation of the answer to life the universe and everything on ForkJoinPool.commonPool-worker-2</strong><br/><strong>main thread is not blocked while background tasks are still in progress</strong><br/><strong>░░░ ░░░░░░░░░░░░░░░░░░░░░░░░░░</strong><br/><strong>The answer to life the universe and everything: 42</strong><br/><strong>Running on main</strong></pre>
<p>We start the execution of <kbd>`calculate the answer to life the universe and everything`()</kbd> in the background task using the <kbd>async()</kbd> function. It just starts a new coroutine and returns an instance of a <kbd>Deferred&lt;T&gt;</kbd> class. The generic <kbd>T</kbd> type corresponds to the type of object that is returned by <kbd>async()</kbd>.  An instance of the <kbd>Deferred&lt;T&gt;</kbd> type is just a pointer to the future result delivered by the coroutine. It's a representation of asynchronous programming constructs, called <em>futures</em> or <em>promises</em>. We are able to evaluate the value of a <kbd>Deferred</kbd> object by calling the <kbd>await()</kbd> function on it. However, we are not able to call the <kbd>await()</kbd> function outside a coroutine scope. We need to call it inside a new <em>blocking</em> coroutine started with a <kbd>runBlocking()</kbd> function.</p>
<p>The coroutines framework is designed to allow us to execute tasks in a non-blocking way. Although we are able to write non-blocking code inside a coroutine's scope, we need to provide a bridge to the original thread inside the application that starts the primary coroutine. We are able to connect the non-blocking coroutine scope with the blocking world outside using the <kbd>runBlocking()</kbd> function. The <kbd>runBlocking()</kbd> function starts a new coroutine and blocks the current thread until its completion. It is designed to bridge regular blocking code to libraries that are written in suspending style. For example, it can be used in <kbd>main()</kbd> functions and in tests.</p>
<p>As far as the progress-bar animation is concerned, we are scheduling it in the background using the <kbd>launch()</kbd> function. <kbd>launch()</kbd> is responsible for starting a new coroutine, however, it does not care about delivering the final results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You may have noticed our predefined functions are marked with the <kbd>suspend</kbd> modifier declared before the <kbd>fun</kbd> keyword, for example, <kbd><strong>suspend</strong> fun `show progress animation`()</kbd>. The reason behind this is that we need to declare explicitly that the function is going to run inside the coroutine scope to be able to use coroutine-specific features inside the function's body. In our case, we are using the <kbd>delay()</kbd> function, which can be invoked only inside a coroutine scope. It is responsible for pausing the coroutine for a given amount of time without blocking the current thread.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li> You can investigate another usage of the <kbd>delay()</kbd> function in the <em>Applying coroutines for asynchronous data processing</em> recipe. You can also explore different use cases of suspending functions in the <em>Easy coroutines cancelation</em> recipe.</li>
<li>If you'd like to learn more about concurrent, asynchronous tasks-scheduling with coroutines, you can take a look at the <em>Using coroutines for asynchronous, concurrent tasks execution with results handling</em> recipe. It explains how to schedule both sequential and concurrent tasks running in a common coroutine.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying coroutines for asynchronous data processing</h1>
                
            
            
                
<p>In this recipe, we are going to implement a generic extension for the <kbd>Iterable</kbd> type, which will provide a replacement for the <kbd>Iterable&lt;T&gt;.map()</kbd> function. Our implementation of the <kbd>Iterable&lt;T&gt;.mapConcurrent()</kbd> function is going to allow data-mapping-operation optimization by running it concurrently with coroutines. Next, we are going to test our concurrent mapping function implementation by employing it to perform a simulation of a time-expensive operation applied to each of the elements of a sample <kbd>Iterable</kbd> object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Implement an extension function for the generic <kbd>Iterable&lt;T&gt;</kbd> class responsible for handling the mapping operation of its elements concurrently:</li>
</ol>
<pre style="padding-left: 60px">suspend fun &lt;T, R&gt; Iterable&lt;T&gt;.mapConcurrent(transform: suspend (T) -&gt; R) =<br/>    this.map {<br/>        async { transform(it) }<br/>    }.map {<br/>        it.await()<br/>    }</pre>
<ol start="2">
<li>Simulate time-consuming mapping operations applied to the sample <kbd>Iterable</kbd> range elements:</li>
</ol>
<pre style="padding-left: 60px">runBlocking {<br/><strong>    (0..10).mapConcurrent {<br/>        delay(1000)<br/>        it * it<br/>    }</strong><br/>}</pre>
<ol start="3">
<li>Print the mapped elements to the console:</li>
</ol>
<pre style="padding-left: 60px">runBlocking {<br/>        (0..10).mapConcurrent {<br/>            delay(1000)<br/>            it * it<br/>        }<strong>.map { println(it) </strong><strong>}</strong><br/>}</pre>
<ol start="4">
<li>Measure the total time of the concurrent-mapping operation's execution and log it to the console:</li>
</ol>
<pre style="padding-left: 60px">runBlocking {<br/><strong>    val totalTime = measureTimeMillis {<br/></strong>        (0..10).mapConcurrent {<br/>            delay(1000)<br/>            it * it<br/>        }.map { println(it) }<br/>    }<br/><strong>    println("Total time: $totalTime ms")</strong><br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's start by analyzing the effects of applying the <kbd>mapConcurrent()</kbd> function we implemented at the beginning to transform elements of the <kbd>(0..10)</kbd> range of integers. In the lambda block passed to the <kbd>mapConcurrent</kbd> function, we are simulating a long-running processing operation suspending the coroutine for one second, using the <kbd>delay(1000)</kbd> function and returning a square of the original integer value.</p>
<p>Our code is going to print the following results to the console:</p>
<pre><strong>0</strong><br/><strong>1</strong><br/><strong>4</strong><br/><strong>9</strong><br/><strong>16</strong><br/><strong>25</strong><br/><strong>36</strong><br/><strong>49</strong><br/><strong>64</strong><br/><strong>81</strong><br/><strong>100</strong><br/><strong>Total time: 1040 ms</strong></pre>
<p class="mce-root">Our implementation of the <kbd>Iterable.mapConcurrent()</kbd> extension function takes a functional parameter, <kbd>transform: suspend (T) -&gt; R</kbd>, which represents an operation that is going to be applied to each element of the original of the <kbd>Iterable</kbd> object. Under the hood, in order to perform data transformation concurrently, there is a new coroutine started for each of the original elements using the <kbd>async()</kbd> function, and the <kbd>transform</kbd> function is applied to them. At this point, the original <kbd>Iterable&lt;T&gt;</kbd> instance has been transformed to the <kbd>Iterable&lt;Deferred&lt;T&gt;&gt;</kbd> type. Next, the instances of the consecutive <kbd>Deferred</kbd> type, returned by invocations of <kbd>async()</kbd>, are synchronized and transformed to the generic <kbd>R</kbd> type by calling the <kbd>await()</kbd> functions on them. In the end, we have an <kbd>Iterable</kbd> of the desired <kbd>R</kbd> type returned.</p>
<p>As you can see, in the output of our example, the transformation of 10 integer numbers using the <kbd>Iterable.mapConcurrent()</kbd> function took roughly one second on a standard computer. You can try running the same transformations using the standard <kbd>Iterable.map()</kbd> and it will take around 10 seconds.</p>
<p>In order to simulate the delay inside the <kbd>transform</kbd> lambda block passed to the <kbd>mapConcurrent()</kbd> function, we use the <kbd>delay()</kbd> function with a specified time value passed. The <kbd>delay()</kbd> is suspending the coroutine for a given amount of time, but it's not blocking a thread. The <kbd>transform</kbd> block is being executed for each of the elements on the pool of background threads. Whenever one coroutine is suspended, another one is starting to run in place of the first one. If we replace the non-blocking <kbd>delay(1000)</kbd> call with the blocking <kbd>Thread.sleep(1000)</kbd> function, our example will finish in about four seconds. It is still a big win compared to the standard <kbd>Iterable.map()</kbd> function which doesn't run concurrently by default.</p>
<p>The coroutines framework is designed to allow us to execute tasks in a non-blocking way. Although we are able to write non-blocking code inside a coroutine's scope, we need to provide a bridge to the original thread inside the application that starts the primary coroutine.  We are able to connect the non-blocking coroutine scope with the blocking world outside using the <kbd>runBlocking()</kbd> function. The <kbd>runBlocking()</kbd> function starts a new coroutine and blocks the current thread until its completion. It is designed to bridge regular blocking code to libraries that are written in suspending style. For example, it can be used in <kbd>main()</kbd> functions and in tests.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to learn more about the basics of the extension function mechanism, you can take a look at the <em>Extending functionalities of classes</em> recipe in <a href="b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml" target="_blank">Chapter 2</a>, <em>Expressive Functions and Adjustable Interfaces</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Easy coroutine cancelation</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to implement a coroutine that allows us to cancel its execution. We are going to create an infinite progress-bar animation running in the console in the background using a coroutine. Next, after a given delay, we are going to cancel the coroutine and test how the animation behaves.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The first step to start working with Kotlin Coroutines is to add a core framework dependency to the project:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.23.3' </pre>
<p>The preceding code declares the <kbd>kotlinx-coroutines-core</kbd> dependency in a Gradle build script, which is used in the sample project (<a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Implement a suspend function responsible for displaying an infinite progress-bar animation in the console:</li>
</ol>
<pre style="padding-left: 60px">private suspend fun `show progress animation`() {<br/>    val progressBarLength = 30<br/>    var currentPosition = 0<br/>    while (true) {<br/>        print("\r")<br/>        val progressbar = (0 until progressBarLength)<br/>                .map { if (it == currentPosition) " " else "<strong>░</strong>" }<br/>                .joinToString("")<br/>        print(progressbar)<br/><br/>        delay(50)<br/><br/>        if (currentPosition == progressBarLength) {<br/>            currentPosition = 0<br/>        }<br/>        currentPosition++<br/>    }<br/>}</pre>
<ol start="2">
<li>Launch the <kbd>`show progress animation`()</kbd> function inside a new coroutine:</li>
</ol>
<pre style="padding-left: 60px">runBlocking {<br/>    val job = launch { `show progress animation`() }<br/>}</pre>
<ol start="3">
<li>Delay the parent thread by five seconds:</li>
</ol>
<pre style="padding-left: 60px">runBlocking {<br/>    val job = launch { `show progress animation`() }<br/>    <strong>delay(5000)</strong><br/>}</pre>
<ol start="4">
<li>Cancel the progress-bar animation job:</li>
</ol>
<pre style="padding-left: 60px">runBlocking {<br/>    val job = launch { `show progress animation`() }<br/>    delay(5000)<br/>    <strong>job.cancel()<br/>    println("Cancelled")</strong><br/>}</pre>
<ol start="5">
<li>Wait for the job to complete and log the completion event to the console:</li>
</ol>
<pre style="padding-left: 60px">runBlocking {<br/>    val job = launch {`show progress animation`()}<br/>    delay(5000)<br/>    job.cancel()<br/><strong>    job.join()</strong><br/><strong>    println("\nJob cancelled and completed")</strong><br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In the end, our code is going to display a progress-bar animation for five seconds and then stop it. We are scheduling the <kbd>`show progress animation`()</kbd> function to run in the background by invoking it inside a new coroutine instance created by the <kbd>launch()</kbd> function. We are storing a handle to a <kbd>Job</kbd> instance returned by the <kbd>launch()</kbd> function under the job variable.</p>
<p class="mce-root"/>
<p>Next, we are suspending the outer <kbd>runBlocking()</kbd> coroutine scope by five seconds with the <kbd>delay(5000)</kbd> call. Once the <kbd>delay()</kbd> function resumes coroutine execution, we call the <kbd>cancel()</kbd> function on the coroutine <kbd>Job</kbd> responsible for displaying the progress-bar animation. </p>
<p>Under the hood, inside the <kbd>`show progress animation`()</kbd> function, we are running an infinite <kbd>while</kbd> loop, which updates the last console line with a new progress-bar animation state every 50 milliseconds. However, as you can verify by running the example, the animation stops immediately after the corresponding <kbd>Job</kbd> responsible for running it gets canceled, even though, after the cancellation, we invoke the <kbd>join()</kbd> function to wait for its completion.</p>
<p>You can also make use of a <kbd>Job</kbd> extension function, called <kbd>cancelAndJoin()</kbd>, that combines the <kbd>cancel()</kbd> and <kbd>join()</kbd> calls together. However, if you don't want to wait for the actual coroutine stop-event, a simple <kbd>cancel()</kbd> call is enough.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to explore the basics of the coroutines framework, take a look at the <em>Using coroutines for asynchronous concurrent-tasks execution </em>and <em>Using coroutines for asynchronous concurrent-tasks execution with results-handling </em>recipes</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a REST API client with Retrofit and a coroutines adapter</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to employ coroutines to interact with remote endpoints using REST APIs. We are going to implement a REST client using the Retrofit library, allowing us to communicate over HTTP with the GitHub API asynchronously. Finally, we will use it in practice to fetch GitHub repositories search results for a given search query.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The first step to start working with Kotlin Coroutines is to add a core framework dependency:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.23.3' </pre>
<p>In order to make use of the Retrofit library with the coroutines adapter plugin, we also need to add the following dependencies to our project:</p>
<pre>implementation 'com.squareup.retrofit2:retrofit:2.4.0'<br/>implementation 'com.squareup.retrofit2:converter-gson:2.4.0'<br/>implementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-experimental-adapter:1.0.0'</pre>
<p>The preceding code declares the required dependencies in a Gradle build script, which is used in a sample project (<a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>). The <kbd>retrofit</kbd> module provides the core Retrofit library implementation. <kbd>converter-gson</kbd> adds a Gson plugin that enables automatic conversion of the JSON response to Kotlin model-data classes. The <kbd>retrofit2-kotlin-coroutines-experimental-adapter</kbd> module provides an adapter for async REST calls, allowing us to wrap the response using the Kotlin Coroutines <kbd>Deferred</kbd> type.</p>
<p>In this recipe, we are going to use the GitHub REST API, which is available publicly. We are going to communicate with an endpoint responsible for returning search results containing GitHub repositories for a given search query. You can find detailed endpoint docs here: <a href="https://developer.github.com/v3/search/#search-repositories">https://developer.github.com/v3/search/#search-repositories</a>.</p>
<p>The  <kbd>/search/repositories</kbd> endpoint allows us to access the remote resources using the <kbd>GET</kbd> method and passing the desired search phrase under the key, called <kbd>q</kbd>. For example, the URL with the <kbd>GET</kbd> request for repositories matching the <kbd>"live.parrot"</kbd> search phrase would look like this: <kbd>https://api.github.com/search/repositories?q=parrot.live</kbd>. The results delivered by the endpoint are formatted using the JSON format. You can check out how the raw response looks like by opening the example URL in your browser or using the <kbd>curl</kbd> command-line tool: <kbd>curl https://api.github.com/search/repositories?q=parrot.live</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare data classes modeling the server response:</li>
</ol>
<pre style="padding-left: 60px">data class Response(@SerializedName("items")<br/>                                      val list: Collection&lt;Repository&gt;)<br/>data class Repository(val id: Long?,<br/>                      val name: String?,<br/>                      val description: String?,<br/>                      @SerializedName("full_name") val fullName:<br/>                       String?,<br/>                      @SerializedName("html_url") val url: String?,<br/>                      @SerializedName("stargazers_count") val stars:<br/>                       Long?)</pre>
<ol start="2">
<li>Declare an interface modeling the GitHub endpoint usage:</li>
</ol>
<pre style="padding-left: 60px">interface GithubApi {<br/>    @GET("/search/repositories")<br/>    fun searchRepositories(@Query("q") searchQuery: String):<br/>    Deferred&lt;Response&gt;<br/><br/>}</pre>
<ol start="3">
<li>Instantiate the <kbd>GithubApi</kbd> interface using the <kbd>Retrofit</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">val api: GithubApi = Retrofit.Builder()<br/>        .baseUrl("https://api.github.com/")<br/>        .addConverterFactory(GsonConverterFactory.create())<br/>        .addCallAdapterFactory(CoroutineCallAdapterFactory())<br/>        .build()<br/>        .create(GithubApi::class.java)</pre>
<ol start="4">
<li>Make a call to the endpoint using the <kbd>GithubApi</kbd> instance and pass <kbd>"kotlin"</kbd> as a search phrase:</li>
</ol>
<pre style="padding-left: 60px">val api: GithubApi = Retrofit.Builder()<br/>        .baseUrl("https://api.github.com/")<br/>        .addConverterFactory(GsonConverterFactory.create())<br/>        .addCallAdapterFactory(CoroutineCallAdapterFactory())<br/>        .build()<br/>        .create(GithubApi::class.java)<br/><br/><strong>api.searchRepositories("Kotlin")</strong></pre>
<ol start="5">
<li>Wait for the response and get a reference to the obtained list of <kbd>Repository</kbd> class objects:</li>
</ol>
<pre style="padding-left: 60px">val api: GithubApi = Retrofit.Builder()<br/>        .baseUrl("https://api.github.com/")<br/>        .addConverterFactory(GsonConverterFactory.create())<br/>        .addCallAdapterFactory(CoroutineCallAdapterFactory())<br/>        .build()<br/>        .create(GithubApi::class.java)<br/><br/>val downloadedRepos = api.searchRepositories("Kotlin")<strong>.await().list</strong></pre>
<ol start="6">
<li>Sort the repositories list by the number of their stars count in decreasing order, and print them to the console:</li>
</ol>
<pre style="padding-left: 60px">val api: GithubApi = Retrofit.Builder()<br/>        .baseUrl("https://api.github.com/")<br/>        .addConverterFactory(GsonConverterFactory.create())<br/>        .addCallAdapterFactory(CoroutineCallAdapterFactory())<br/>        .build()<br/>        .create(GithubApi::class.java)<br/><br/>val downloadedRepos = api.searchRepositories("Kotlin").await().list<br/><strong>downloadedRepos</strong><br/><strong> .sortedByDescending { it.stars }<br/> .forEach {<br/> it.apply {<br/> println("$fullName <img src="img/a541e4e1-5cd5-430c-8778-8f64c957e4a2.png" style="width:1.25em;height:1.17em;"/>$stars\n$description\n$url\n")</strong><br/><strong> }<br/> }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As a result, our code is going to send a request to the server, fetch and process the response, and print the following results to the console:</p>
<pre><strong>JetBrains/kotlin <img src="img/f20aeb9f-ae96-4ab4-81ae-59a08f467e67.png" style="width:1.33em;height:1.17em;"/>23051</strong><br/><strong>The Kotlin Programming Language</strong><br/><strong>https://github.com/JetBrains/kotlin</strong><br/><br/><strong>perwendel/spark <img src="img/f20aeb9f-ae96-4ab4-81ae-59a08f467e67.png" style="width:1.33em;height:1.17em;"/>7531</strong><br/><strong>A simple expressive web framework for java. News: Spark now has a kotlin DSL https://github.com/perwendel/spark-kotlin</strong><br/><strong>https://github.com/perwendel/spark</strong><br/><br/><strong>KotlinBy/awesome-kotlin <img src="img/f20aeb9f-ae96-4ab4-81ae-59a08f467e67.png" style="width:1.25em;height:1.17em;"/>5098</strong><br/><strong>A curated list of awesome Kotlin related stuff Inspired by awesome-java. </strong><br/><strong>https://github.com/KotlinBy/awesome-kotlin</strong><br/><br/><strong>ReactiveX/RxKotlin <img src="img/f20aeb9f-ae96-4ab4-81ae-59a08f467e67.png" style="width:1.25em;height:1.17em;"/>4413</strong><br/><strong>RxJava bindings for Kotlin</strong><br/><strong>https://github.com/ReactiveX/RxKotlin</strong><br/><br/><strong>JetBrains/kotlin-native <img src="img/f20aeb9f-ae96-4ab4-81ae-59a08f467e67.png" style="width:1.33em;height:1.17em;"/>4334</strong><br/><strong>Kotlin/Native infrastructure</strong><br/><strong>https://github.com/JetBrains/kotlin-native</strong><br/><strong><br/>...</strong></pre>
<p>We have started by implementing model classes that represent the data returned in the server's JSON response. You may have seen that some of the properties are marked with the <kbd>@SerializedName()</kbd> annotation. The aim of this annotation is to indicate to the Gson library that the specified property should be deserialized from a JSON field which name matches the value passed to <kbd>@SerializedName()</kbd>. Next, we are declaring an interface, <kbd>GithubApi</kbd>, that represents the methods we want to use to communicate with the endpoint. We've declared a single method, called <kbd>searchRepositories</kbd>, which takes a <kbd>String</kbd> parameter that corresponds to the search-query value required by the repositories search endpoint. We've also marked the <kbd>searchRepositories</kbd> method with the <kbd>@GET</kbd> annotation, which specifies the REST method type to use and a path to the endpoint. The <kbd>searchRepositories</kbd> method should return an instance of a <kbd>Deferred&lt;Response&gt;</kbd> type, representing a <em>future </em>result of an asynchronous call. Implementation of the <kbd>GithubApi</kbd> interface is generated by the Retrofit library internally. In order to obtain the <kbd>GithubApi</kbd> instance, we need to instantiate the <kbd>Retrofit</kbd> type and configure it with the endpoint's URL address and mechanisms responsible for JSON deserializing and performing asynchronous calls to the server. Finally, we call <kbd>Retrofit.create(GithubApi::class.java)</kbd> to obtain the <kbd>GithubApi</kbd> instance. That's it!</p>
<p>In order to execute the actual call to the server, we need to call the <kbd>GithubApi.searchRepositories()</kbd> function:</p>
<pre>api.searchRepositories("Kotlin")</pre>
<p>Next, in order to obtain a list of <kbd>Repository</kbd> objects from the response, we need to wait for the completion of the async call to the server and response parsing:</p>
<pre>val downloadedRepos = api.searchRepositories("Kotlin")<strong>.await().</strong><strong>list</strong><br/></pre>
<p>Finally, we post-process the list of repositories obtained from the response. We are sorting it by the stars count, in decreasing order, and printing it to the console with the following code:</p>
<pre>val downloadedRepos = api.searchRepositories("Kotlin").await().list<br/><strong>downloadedRepos</strong><br/><strong>        .sortedByDescending { it.stars }<br/>        .forEach {<br/>            it.apply {<br/>                println("$fullName <img src="img/f20aeb9f-ae96-4ab4-81ae-59a08f467e67.png" style="width:1.33em;height:1.17em;"/>$stars\n$description\n$url\n")</strong><br/><strong>            }<br/>        }</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to explore the basics of the coroutines framework, take a look at the <em>Using coroutines for asynchronous concurrent-tasks execution </em>and <em>Using coroutines for asynchronous, concurrent tasks execution with results handling </em>recipes. You can learn more about the Retrofit library by exploring its homepage, <a href="http://square.github.io/retrofit/">http://square.github.io/retrofit/</a>, which contains useful examples.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Wrapping third-party callback-style APIs with coroutines</h1>
                
            
            
                
<p>Often third-party libraries offer callback-style asynchronous APIs. However, the callback functions are considered to be an anti-pattern, especially whenever we are dealing with a number of nested callbacks. In this recipe, we are going to learn how to deal with libraries that provide callback-style methods by transforming them easily into suspending functions that can be run using coroutines.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The first step to start working with Kotlin Coroutines is to add the core framework dependency to the project:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.23.3' </pre>
<p>The preceding code declares the <kbd>kotlinx-coroutines-core</kbd> dependency in a Gradle build script, which is used in the sample project (<a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook</a>). </p>
<p>As far as the recipe task is concerned, let's assume we have a class called <kbd>Result</kbd>, defined as follows:</p>
<pre>data class Result(val displayName: String)</pre>
<p>Here is the <kbd>getResultsAsync()</kbd> function, which simulates the third-party callback-style API:</p>
<pre>fun getResultsAsync(callback: (List&lt;Result&gt;) -&gt; Unit) =<br/>    thread {<br/>        val results = mutableListOf&lt;Result&gt;()<br/><br/>        // Simulate some extensive bacground task<br/>        Thread.sleep(1000)<br/><br/>        results.add(Result("a"))<br/>        results.add(Result("b"))<br/>        results.add(Result("c"))<br/><br/>        callback(results)<br/>    }</pre>
<p>The <kbd>getResultsAsync()</kbd> function just starts a background thread, delays it for a second, and invokes a callback function passed to it as an argument delivering the list of the <kbd>Result</kbd> class object to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Wrap the <kbd>getResultsAsync()</kbd> function with the suspend function, returning the results directly:</li>
</ol>
<pre style="padding-left: 60px">suspend fun getResults(): List&lt;Result&gt; =<br/>    suspendCoroutine { continuation: Continuation&lt;List&lt;Result&gt;&gt; -&gt;<br/>        getResultsAsync { continuation.resume(it) }<br/>    }<br/></pre>
<ol start="2">
<li>Start a coroutine and invoke the <kbd>getResults()</kbd> suspending function inside it:</li>
</ol>
<pre style="padding-left: 60px">val asyncResults = async {<br/>    getResults()<br/>}</pre>
<ol start="3">
<li>Wait for the results and print them to the console:</li>
</ol>
<pre style="padding-left: 60px">val asyncResults = async {<br/>    getResults()<br/>}<br/><br/><strong>println("getResults() is running in bacground. Main thread is not blocked.")</strong><br/><strong>asyncResults.await().map { println(it.displayName) }<br/>println("getResults() completed")</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In the end, our code is going to print the following output to the console:</p>
<pre><strong>getResults() is running in bacground. Main thread is not blocked.</strong><br/><strong>a</strong><br/><strong>b</strong><br/><strong>c</strong><br/><strong>getResults() completed</strong><br/><strong>Total time elapsed: 1029 ms</strong></pre>
<p class="mce-root">We've successfully managed to transform the callback-style <kbd>getResultsAsync(callback: (List&lt;Result&gt;) -&gt; Unit)</kbd> function into the clean form of a suspending function returning the results directly–<kbd>suspend fun getResults(): List&lt;Result&gt;</kbd>. In order to get rid of the original <kbd>callback</kbd> argument, we have used the <kbd>suspendCoroutine()</kbd> function provided by the standard library. The <kbd>suspendCoroutine()</kbd> function takes the <kbd>block: (Continuation&lt;T&gt;) -&gt; Unit</kbd> function type as an argument. The <kbd>Continuation</kbd> interface is designed to allow us to resume the coroutine paused by a suspending function.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When the <kbd>suspendCoroutine</kbd> function is called inside a coroutine, it captures its execution state in a <kbd>Continuation</kbd> instance and passes this continuation to the specified block as an argument. To resume execution of the coroutine, the block may invoke either <kbd>continuation.resume()</kbd> or <kbd>continuation.resumeWithException()</kbd>.</p>
<p class="mce-root">We invoke the original <kbd>getResultsAcync()</kbd> function inside the lambda passed to the <kbd>suspendCoroutine()</kbd> function, and we call the <kbd>continuation.resume(it)</kbd>  function in the <kbd>callback</kbd> lambda blocked passed to the <kbd>getResultsAsync()</kbd> function as an argument:</p>
<pre>suspend fun getResults(): List&lt;Result&gt; =<br/>    suspendCoroutine <strong>{ continuation: Continuation&lt;List&lt;Result&gt;&gt; -&gt;<br/>        getResultsAsync { continuation.resume(it) }<br/>    }</strong></pre>
<p>As the result, the coroutine inside which <kbd>getResults()</kbd> is called will become suspended until the <kbd>callback</kbd> lambda is executed internally in the <kbd>getResultsAsync()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to explore the basics of the coroutines framework, take a look at the <em>Using coroutines for asynchronous, concurrent tasks execution</em> and <em>Using coroutines for asynchronous, concurrent tasks execution with results handling</em> recipes</li>
</ul>


            

            
        
    </body></html>