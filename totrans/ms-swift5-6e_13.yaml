- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Subscripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom subscripts were added to Objective-C in 2012\. At that time, Chris Lattner
    was already two years into developing Swift and, like other good features, subscripts
    were added to the Swift language. I have not used custom subscripts in many other
    languages; however, I do find myself using subscripts extensively when I am developing
    in Swift. The syntax for using subscripts seems like a natural part of the language,
    possibly because they were part of the language when it was released and not added
    in later. Once you start using them, you may find them indispensable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are custom subscripts?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom subscripts to classes, structures, or enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating read/write and read-only subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external names without custom subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multidimensional subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subscripts, in the Swift language, are used as shortcuts for accessing elements
    of a collection, list, or sequence. We can use them in our custom types to set
    or retrieve the values by index rather than by using getter and setter methods.
    Subscripts, if used correctly, can significantly enhance the usability and readability
    of our custom types.
  prefs: []
  type: TYPE_NORMAL
- en: We can define multiple subscripts for a single type. When types have multiple
    subscripts, the appropriate subscript will be chosen based on the type of index
    passed in with the subscript. We can also set external parameter names for our
    subscripts that can help distinguish between subscripts that have the same types.
  prefs: []
  type: TYPE_NORMAL
- en: We use custom subscripts just like we use subscripts for arrays and dictionaries.
    For example, to access an element in an array, we use the `Array[index]` syntax.
    When we define a custom subscript for our custom types, we also access them with
    the same `ourType[key]` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: When creating custom subscripts, we should try to make them feel like a natural
    part of the class, structure, or enumeration. As mentioned previously, subscripts
    can significantly enhance the usability and readability of our code, but if we
    try to overuse them, they will not feel natural and will be hard to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at several examples of how we can create and use
    custom subscripts. However, before we see how to use custom subscripts, let's
    review how subscripts are used with Swift arrays to understand how subscripts
    are used within the Swift language itself. We should use subscripts in a similar
    manner to how Apple uses them within the language to make our custom subscripts
    easy to understand and use.
  prefs: []
  type: TYPE_NORMAL
- en: Subscripts with Swift arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example shows how to use subscripts to access and change the
    values of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create an array of integers and then use the subscript
    syntax to display and change the element at index three. Subscripts are mainly
    used to set or retrieve information from a collection. We generally do not use
    subscripts when specific logic needs to be applied to determine which item to
    select. As an example, we would not want to use subscripts to append an item to
    the end of the array or to retrieve the number of items in the array. To append
    an item to the end of an array, or to get the number of items in an array, we
    use functions or properties, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Subscripts in our custom types should follow the same standard set by the Swift
    language itself, so other developers that use our types are not confused by the
    implementation. The key to knowing when to use subscripts, and when not to, is
    to understand how they will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using custom subscripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how to define a subscript that is used to read and write to
    a backend array. Reading and writing to a backend storage class is one of the
    most common uses of custom subscripts. However, as we will see in this chapter,
    we do not need to have a backend storage class. The following code shows how to
    use a subscript to read and write to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the syntax for subscripts is similar to how we define properties
    within a class using the `get` and `set` keywords. The difference is that we declare
    the `subscript` using the `subscript` keyword. We then specify one or more inputs
    and the return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the custom subscript just like we used subscripts with arrays
    and dictionaries. The following code shows how to use the subscript in the preceding
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an instance of the `MyNames` class and display
    the original name at index `0`. We then change the name at index `0` and redisplay
    it. In this example, we use the subscript that is defined in the `MyNames` class
    to retrieve and set elements of the `names` array within the class.
  prefs: []
  type: TYPE_NORMAL
- en: While we could make the `names` array available for external code to access
    directly, this would lock our code into using an array to store the data. In the
    future, if we wanted to change the backend storage mechanism to a dictionary object,
    or even an SQLite database, we would have a difficult time doing so because all
    of the external code would also have to be changed. Subscripts are very good at
    hiding how we store information within our custom types; therefore, external code
    that uses these custom types does not rely on specific storage implementations.
  prefs: []
  type: TYPE_NORMAL
- en: If we gave direct access to the `names` array, we would also be unable to verify
    that the external code was inserting valid information into the array. With subscripts,
    we can add validation to our setters to verify that the data being passed in is
    correct before adding it to the array. As an example, in the previous example,
    we could have added in a validation to verify that the names only contain alpha
    characters and certain special characters that are valid in names. This can be
    very useful when we are creating a framework or a library.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only custom subscripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also make the subscript read-only by either not declaring a setter method
    within the subscript or by not implicitly declaring the getter and setter methods.
    The following code shows how to declare a read-only property by not declaring
    a getter or setter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to declare a read-only property by only declaring
    a getter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we do not define either a getter or setter method; therefore,
    Swift sets the subscript as read-only, and the code acts as if it were in a getter
    definition. In the second example, we specifically set the code in a getter definition.
    Both examples are valid read-only subscripts. One thing to note is that write-only
    subscripts are not valid in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Calculated subscripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the preceding example is very similar to using stored properties in a
    class or structure, we can also use subscripts in a similar manner to computed
    properties. Let''s look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used an array as the backend storage mechanism
    for the subscript. In this example, we use the value of the subscript to calculate
    the return value. We would use this subscript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example displays the calculated value of `5` (the number defined in the
    initialization) multiplied by `4` (the subscript value), which is equal to 20.
  prefs: []
  type: TYPE_NORMAL
- en: Subscript values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding subscript examples, all of the subscripts accepted integers
    as the value for the subscript; however, we are not limited to integers. In the
    following example, we will use a `String` type as the value for the subscript.
    The `subscript` keyword will also return a `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the subscript takes a string as the value within the subscript
    and returns a message saying `Hello`. Let''s look at how to use this subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the `greeting` constant would contain the string `Hello
    Jon`.
  prefs: []
  type: TYPE_NORMAL
- en: Static subscripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static subscripts were introduced in Swift 5.1 with SE-0254\. This functionality
    enables us to use the subscript without having to create an instance of the type.
    Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we create a structure named `Hello` and within this structure
    we define a `subscript`. The thing to note is the `static` keyword prior to the
    subscript declaration. We are now able to use this subscript as shown in the next
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the `greeting` constant would contain the string `Hello
    Jon`. Note that we did not have to create an instance of the `Hello` structure
    to use the subscript.
  prefs: []
  type: TYPE_NORMAL
- en: External names for subscripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, we can have multiple subscript signatures
    for our custom types. The appropriate subscript will be chosen based on the type
    of index passed into the subscript. However, there are times when we may wish
    to define multiple subscripts that have the same type. For this, we could use
    external names in a similar way to how we define external names for the parameters
    of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the original `MathTable` structure to include two subscripts
    that each accept an integer as the subscript type. However, one will perform a
    multiplication operation, and the other will perform an addition operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in this example we define two subscripts, and each subscript
    accepts an integer type. The difference between the two subscripts is the external
    name within the definition. In the first subscript, we define an external name,
    `multiply`, because we multiply the value of the subscript by the `num` property
    within this subscript. In the second `subscript`, we define an external name,
    `add`, because we add the value of the subscript to the `num` property within
    the subscript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use these two subscripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we run this example, we will see that the correct subscript is used, based
    on the external name within the subscript.
  prefs: []
  type: TYPE_NORMAL
- en: Using external names within our subscript is very useful if we need multiple
    subscripts of the same type. I would not recommend using external names unless
    they are needed to distinguish between multiple subscripts.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional subscripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the most common subscripts are those that take a single parameter, subscripts
    are not limited to single parameters. They can take any number of input parameters,
    and these parameters can be of any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we could use a multidimensional subscript to implement a
    Tic-Tac-Toe board. A Tic-Tac-Toe board looks similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing clock  Description automatically generated](img/B16683_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Empty Tic-Tac-Toe board'
  prefs: []
  type: TYPE_NORMAL
- en: The board can be represented by a two-dimensional array, where each dimension
    has three elements. The upper-left box of the board would be represented by the
    coordinates 0,0, while the lower-right box of the board would be represented by
    the coordinates 2,2\. The middle box would have the coordinates 1,1\. Each player
    will take turns placing their pieces (typically `x` or `o`) onto the board until
    one player has three pieces in a line or the board is full.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we could implement a Tic-Tac-Toe board using a multidimensional
    array and multidimensional subscripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the `TicTacToe` structure by defining a `3×3` array, also known as
    a matrix, which will represent the game board. We then define a subscript that
    can be used to set and retrieve player pieces on the board. The subscript will
    accept two integer values. We define multiple parameters for our subscripts by
    putting the parameters between parentheses. In this example, we are defining the
    subscript with the parameters `(x: Int, y: Int)`. We can then use the `x` and
    `y` variable names within our subscripts to access the values that are passed
    in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use this subscript to set the user''s pieces on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, we will see that we added the `x` piece to the center
    square and the `o` piece to the upper-left square, so our game board will look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing clock  Description automatically generated](img/B16683_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Tic-Tac-Toe board with two player pieces'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to using only one type for our multidimensional subscripts.
    For example, we could have a subscript of `(x: Int, y: Double, z: String)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add external names for our multidimensional subscript types to
    help identify what values are used for and to distinguish between subscripts that
    have the same types. Let''s take a look at how to use multiple types and external
    names with subscripts by creating a subscript that will return an array of string
    instances based on the values of the subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `SayHello` structure, we define our subscript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a subscript with three elements. Each element has an external
    name (`messageText`, `messageName`, and `number`) and an internal name (`message`,
    `name`, and `number`). The first two elements are of the `String` type and the
    last one is an `Integer` type. We use the first two elements to create a message
    for the user that will repeat the number of times defined by the last (`number`)
    element. We will use this subscript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we run this code, we will see that the `ret` variable contains an array of
    five strings, where each string equals `Bonjour Jon`. Now let's look at one of
    the most controversial new additions to the Swift language – dynamic member lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic member lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic member lookup enables a call to a property that will be dynamically
    resolved at runtime. This may not make a lot of sense without seeing an example,
    so let''s look at one. Let''s say that we had a structure that represented a baseball
    team. This structure has a property that represents the city the team was from
    and another property that represents the nickname of the team. The following code
    shows this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this structure, if we wanted to retrieve the full name of the baseball team,
    including the `city` and `nickname`, we could easily create a method as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you would do it in most object-oriented programming languages.
    However, in our code, which uses the `BaseballTeam` structure, we would retrieve
    the city and nickname as properties with the dot notation and the full name as
    a method. The following code shows how we would use both the `city` property and
    the `fullname` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a much cleaner interface using dynamic member lookups. To use
    dynamic member lookups, the first thing we need to do is to add the `@dynamicMemberLookup`
    attribute when we define the `BaseballTeam` structure, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will need to add the lookup to the `BaseballTeam` structure. This is
    done by implementing the `subscript(dynamicMember: )` subscript. The following
    code shows how we would create a lookup to retrieve both the full name and the
    winning percentage for the `BaseballTeam` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will retrieve the key passed in and uses a `switch` statement, using
    that key, to determine what information to return from the subscript. With this
    code added to the `BaseballTeam` structure, we can use the lookup as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we are able to access both `fullname` and `percent` from the instance
    of the `BaseballTeam` structure as if they were normal properties. This makes
    our code much cleaner and easier to read. However, there is one thing to keep
    in mind when using lookups like this: there is no way to control what keys are
    passed into the lookup.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we called `fullname` and `percent`; however, we could
    just as easily have called flower or dog with no warning from the compiler. This
    is why there is a lot of controversy attached to dynamic member lookup, because
    there is no compile-time warning if you do something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: If you use dynamic member lookup, make sure you verify the key and handle any
    instances when something unexpected is sent, as we did with the previous example
    using the default case of the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to use subscripts, let's take a quick look at when
    not to use custom subscripts.
  prefs: []
  type: TYPE_NORMAL
- en: When not to use a custom subscript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in this chapter, creating custom subscripts can really enhance
    our code. However, we should avoid overusing them or using them in a way that
    is not consistent with standard subscript usage. The way to avoid overusing subscripts
    is to examine how subscripts are used in Swift's standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, within the `MyNames` class, we define an array of
    names that are used within our application. As an example, let''s say that within
    our application we display this list of names and allow users to add names to
    it. Within the `MyNames` class, we then define the following subscript, which
    allows us to append a new name to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be a poor use of subscripts because its usage is not consistent
    with how subscripts are used within the Swift language itself—we are using it
    to accept a parameter and add that value. This might cause confusion when the
    class is used. It would be more appropriate to rewrite this subscript as a function,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember, when you are using custom subscripts, make sure that you are using
    them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in this chapter, adding support for subscripts to our custom types
    can greatly enhance their readability and usability. We saw that subscripts can
    be used to add an abstraction layer between our backend storage class and external
    code. Subscripts can also be used in a similar manner to computed properties,
    where the subscript is used to calculate a value. As we noted, the key with subscripts
    is to use them appropriately and in a manner that is consistent with subscripts
    in the Swift language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at what closures are and how to use them.
  prefs: []
  type: TYPE_NORMAL
