- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Custom Subscripting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义下标
- en: Custom subscripts were added to Objective-C in 2012\. At that time, Chris Lattner
    was already two years into developing Swift and, like other good features, subscripts
    were added to the Swift language. I have not used custom subscripts in many other
    languages; however, I do find myself using subscripts extensively when I am developing
    in Swift. The syntax for using subscripts seems like a natural part of the language,
    possibly because they were part of the language when it was released and not added
    in later. Once you start using them, you may find them indispensable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在2012年，Objective-C中增加了自定义下标。当时，Chris Lattner已经开发了Swift两年了，并且像其他优秀特性一样，下标也被添加到了Swift语言中。我在许多其他语言中并没有使用过自定义下标；然而，当我用Swift进行开发时，我发现自己在广泛地使用下标。使用下标的语法看起来像是语言的自然组成部分，可能是因为它们在语言发布时就是语言的一部分，而不是后来添加的。一旦开始使用它们，可能会发现它们变得不可或缺。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are custom subscripts?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是自定义下标？
- en: Adding custom subscripts to classes, structures, or enumerations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义下标添加到类、结构体或枚举中
- en: Creating read/write and read-only subscripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建读写和只读下标
- en: Using external names without custom subscripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义下标访问外部名称
- en: Using multidimensional subscripts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多维下标
- en: Introducing subscripts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍下标
- en: Subscripts, in the Swift language, are used as shortcuts for accessing elements
    of a collection, list, or sequence. We can use them in our custom types to set
    or retrieve the values by index rather than by using getter and setter methods.
    Subscripts, if used correctly, can significantly enhance the usability and readability
    of our custom types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift语言中，下标被用作访问集合、列表或序列元素的快捷方式。我们可以在自定义类型中使用它们，通过索引来设置或检索值，而不是使用getter和setter方法。如果正确使用，下标可以显著提高我们自定义类型的可用性和可读性。
- en: We can define multiple subscripts for a single type. When types have multiple
    subscripts, the appropriate subscript will be chosen based on the type of index
    passed in with the subscript. We can also set external parameter names for our
    subscripts that can help distinguish between subscripts that have the same types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为单个类型定义多个下标。当类型有多个下标时，将根据下标传递的索引类型选择合适的下标。我们还可以为我们的下标设置外部参数名称，这有助于区分具有相同类型的下标。
- en: We use custom subscripts just like we use subscripts for arrays and dictionaries.
    For example, to access an element in an array, we use the `Array[index]` syntax.
    When we define a custom subscript for our custom types, we also access them with
    the same `ourType[key]` syntax.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用自定义下标的方式就像我们使用数组和大字典的下标一样。例如，要访问数组中的一个元素，我们使用`Array[index]`语法。当我们为自定义类型定义自定义下标时，我们也使用相同的`ourType[key]`语法。
- en: When creating custom subscripts, we should try to make them feel like a natural
    part of the class, structure, or enumeration. As mentioned previously, subscripts
    can significantly enhance the usability and readability of our code, but if we
    try to overuse them, they will not feel natural and will be hard to use and understand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义下标时，我们应该努力使它们感觉像是类、结构体或枚举的自然部分。如前所述，下标可以显著提高我们代码的可用性和可读性，但如果我们过度使用它们，它们将不会感觉自然，并且难以使用和理解。
- en: In this chapter, we will look at several examples of how we can create and use
    custom subscripts. However, before we see how to use custom subscripts, let's
    review how subscripts are used with Swift arrays to understand how subscripts
    are used within the Swift language itself. We should use subscripts in a similar
    manner to how Apple uses them within the language to make our custom subscripts
    easy to understand and use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个示例，说明我们如何创建和使用自定义下标。然而，在我们了解如何使用自定义下标之前，让我们回顾一下如何在Swift数组中使用下标，以了解下标在Swift语言本身中的使用方式。我们应该以类似Apple在语言中使用下标的方式使用下标，使我们的自定义下标易于理解和使用。
- en: Subscripts with Swift arrays
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift数组中的下标
- en: 'The following example shows how to use subscripts to access and change the
    values of an array:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用下标来访问和更改数组的值：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we create an array of integers and then use the subscript
    syntax to display and change the element at index three. Subscripts are mainly
    used to set or retrieve information from a collection. We generally do not use
    subscripts when specific logic needs to be applied to determine which item to
    select. As an example, we would not want to use subscripts to append an item to
    the end of the array or to retrieve the number of items in the array. To append
    an item to the end of an array, or to get the number of items in an array, we
    use functions or properties, such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，我们创建了一个整数数组，然后使用下标语法来显示和更改索引为三的元素。下标主要用于设置或从集合中检索信息。我们通常不使用下标来应用特定逻辑以确定要选择哪个项目。例如，我们不想使用下标向数组的末尾添加项目或检索数组中的项目数量。要向数组的末尾添加项目或获取数组中的项目数量，我们使用函数或属性，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Subscripts in our custom types should follow the same standard set by the Swift
    language itself, so other developers that use our types are not confused by the
    implementation. The key to knowing when to use subscripts, and when not to, is
    to understand how they will be used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义类型中的下标应遵循Swift语言本身设定的相同标准，这样其他使用我们类型的开发者就不会被实现方式所困惑。了解何时使用下标，何时不使用的关键在于理解它们将被如何使用。
- en: Creating and using custom subscripts
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用自定义下标
- en: 'Let''s look at how to define a subscript that is used to read and write to
    a backend array. Reading and writing to a backend storage class is one of the
    most common uses of custom subscripts. However, as we will see in this chapter,
    we do not need to have a backend storage class. The following code shows how to
    use a subscript to read and write to an array:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义一个用于读取和写入后端数组的下标。读取和写入后端存储类是自定义下标最常见的使用之一。然而，正如我们将在本章中看到的，我们不需要有一个后端存储类。以下代码展示了如何使用下标来读取和写入数组：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, the syntax for subscripts is similar to how we define properties
    within a class using the `get` and `set` keywords. The difference is that we declare
    the `subscript` using the `subscript` keyword. We then specify one or more inputs
    and the return type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，下标的语法与我们使用`get`和`set`关键字在类中定义属性的方式相似。区别在于我们使用`subscript`关键字声明`subscript`。然后我们指定一个或多个输入和返回类型。
- en: 'We can now use the custom subscript just like we used subscripts with arrays
    and dictionaries. The following code shows how to use the subscript in the preceding
    example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用自定义下标，就像我们使用数组或字典中的下标一样。以下代码展示了如何在先前的示例中使用下标：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we create an instance of the `MyNames` class and display
    the original name at index `0`. We then change the name at index `0` and redisplay
    it. In this example, we use the subscript that is defined in the `MyNames` class
    to retrieve and set elements of the `names` array within the class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们创建了一个`MyNames`类的实例，并显示了索引`0`处的原始名称。然后我们更改索引`0`处的名称并重新显示它。在这个例子中，我们使用`MyNames`类中定义的下标来检索和设置类内`names`数组中的元素。
- en: While we could make the `names` array available for external code to access
    directly, this would lock our code into using an array to store the data. In the
    future, if we wanted to change the backend storage mechanism to a dictionary object,
    or even an SQLite database, we would have a difficult time doing so because all
    of the external code would also have to be changed. Subscripts are very good at
    hiding how we store information within our custom types; therefore, external code
    that uses these custom types does not rely on specific storage implementations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使`names`数组对外部代码直接访问，但这会将我们的代码锁定在只能使用数组来存储数据。在未来，如果我们想将后端存储机制更改为字典对象，甚至是一个SQLite数据库，我们将很难做到，因为所有外部代码也必须进行更改。下标非常擅长隐藏我们在自定义类型中存储信息的方式；因此，使用这些自定义类型的外部代码不依赖于特定的存储实现。
- en: If we gave direct access to the `names` array, we would also be unable to verify
    that the external code was inserting valid information into the array. With subscripts,
    we can add validation to our setters to verify that the data being passed in is
    correct before adding it to the array. As an example, in the previous example,
    we could have added in a validation to verify that the names only contain alpha
    characters and certain special characters that are valid in names. This can be
    very useful when we are creating a framework or a library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接访问 `names` 数组，我们也将无法验证外部代码是否正在将有效信息插入数组中。使用下标，我们可以在将数据添加到数组之前对其进行验证，以确保传递的数据是正确的。例如，在之前的例子中，我们可以在验证中添加一个验证，以确保名称只包含字母字符和某些在名称中有效的特殊字符。这在我们创建框架或库时非常有用。
- en: Read-only custom subscripts
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读自定义下标
- en: 'We can also make the subscript read-only by either not declaring a setter method
    within the subscript or by not implicitly declaring the getter and setter methods.
    The following code shows how to declare a read-only property by not declaring
    a getter or setter method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过不在下标中声明设置器方法或显式声明获取器和设置器方法来使下标只读。以下代码展示了如何通过不声明获取器或设置器方法来声明只读属性：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example shows how to declare a read-only property by only declaring
    a getter method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何仅通过声明获取器方法来声明只读属性：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first example, we do not define either a getter or setter method; therefore,
    Swift sets the subscript as read-only, and the code acts as if it were in a getter
    definition. In the second example, we specifically set the code in a getter definition.
    Both examples are valid read-only subscripts. One thing to note is that write-only
    subscripts are not valid in Swift.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们没有定义获取器或设置器方法；因此，Swift 将下标设置为只读，代码的行为就像是在获取器定义中一样。在第二个例子中，我们特别将代码设置在获取器定义中。这两个例子都是有效的只读下标。需要注意的是，Swift
    中不允许存在只写下标。
- en: Calculated subscripts
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算下标
- en: 'While the preceding example is very similar to using stored properties in a
    class or structure, we can also use subscripts in a similar manner to computed
    properties. Let''s look at how to do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子与在类或结构体中使用存储属性非常相似，但我们也可以以类似的方式使用下标来使用计算属性。让我们看看如何做到这一点：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we used an array as the backend storage mechanism
    for the subscript. In this example, we use the value of the subscript to calculate
    the return value. We would use this subscript as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用数组作为下标的后端存储机制。在这个例子中，我们使用下标的值来计算返回值。我们会这样使用这个下标：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example displays the calculated value of `5` (the number defined in the
    initialization) multiplied by `4` (the subscript value), which is equal to 20.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了计算值 `5`（在初始化中定义的数字）乘以 `4`（下标值），等于 20。
- en: Subscript values
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下标值
- en: 'In the preceding subscript examples, all of the subscripts accepted integers
    as the value for the subscript; however, we are not limited to integers. In the
    following example, we will use a `String` type as the value for the subscript.
    The `subscript` keyword will also return a `String` type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的下标示例中，所有下标都接受整数作为下标的值；然而，我们并不局限于整数。在以下示例中，我们将使用 `String` 类型作为下标的值。`subscript`
    关键字也将返回 `String` 类型：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, the subscript takes a string as the value within the subscript
    and returns a message saying `Hello`. Let''s look at how to use this subscript:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，下标将字符串作为下标内的值，并返回一条消息说“Hello”。让我们看看如何使用这个下标：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code, the `greeting` constant would contain the string `Hello
    Jon`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`greeting` 常量将包含字符串 `Hello Jon`。
- en: Static subscripts
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态下标
- en: 'Static subscripts were introduced in Swift 5.1 with SE-0254\. This functionality
    enables us to use the subscript without having to create an instance of the type.
    Let''s see how this works:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 静态下标是在 Swift 5.1 中通过 SE-0254 引入的。此功能使我们能够在不创建类型实例的情况下使用下标。让我们看看它是如何工作的：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous code, we create a structure named `Hello` and within this structure
    we define a `subscript`. The thing to note is the `static` keyword prior to the
    subscript declaration. We are now able to use this subscript as shown in the next
    line of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们创建了一个名为 `Hello` 的结构体，并在该结构体内部定义了一个 `subscript`。需要注意的是，在 `subscript`
    声明之前有一个 `static` 关键字。我们现在能够像下一行代码所示那样使用这个下标：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code, the `greeting` constant would contain the string `Hello
    Jon`. Note that we did not have to create an instance of the `Hello` structure
    to use the subscript.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`greeting` 常量将包含字符串 `Hello Jon`。请注意，我们不需要创建 `Hello` 结构的实例来使用下标。
- en: External names for subscripts
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下标的外部名称
- en: As mentioned earlier in this chapter, we can have multiple subscript signatures
    for our custom types. The appropriate subscript will be chosen based on the type
    of index passed into the subscript. However, there are times when we may wish
    to define multiple subscripts that have the same type. For this, we could use
    external names in a similar way to how we define external names for the parameters
    of a function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，我们可以为我们的自定义类型有多个下标签名。合适的下标将根据传递给下标的索引类型来选择。然而，有时我们可能希望定义多个具有相同类型的下标。为此，我们可以使用与定义函数参数外部名称类似的方式使用外部名称。
- en: 'Let''s rewrite the original `MathTable` structure to include two subscripts
    that each accept an integer as the subscript type. However, one will perform a
    multiplication operation, and the other will perform an addition operation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写原始的 `MathTable` 结构，以包含两个下标，每个下标都接受整数作为下标类型。然而，一个将执行乘法操作，另一个将执行加法操作：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, in this example we define two subscripts, and each subscript
    accepts an integer type. The difference between the two subscripts is the external
    name within the definition. In the first subscript, we define an external name,
    `multiply`, because we multiply the value of the subscript by the `num` property
    within this subscript. In the second `subscript`, we define an external name,
    `add`, because we add the value of the subscript to the `num` property within
    the subscript.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这个例子中，我们定义了两个下标，并且每个下标都接受整数类型。这两个下标之间的区别在于定义中的外部名称。在第一个下标中，我们定义了一个外部名称
    `multiply`，因为我们在这个下标中将下标的值乘以下标内的 `num` 属性。在第二个 `subscript` 中，我们定义了一个外部名称 `add`，因为我们在这个下标中将下标的值加以下标内的
    `num` 属性。
- en: 'Let''s look at how to use these two subscripts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这两个下标：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run this example, we will see that the correct subscript is used, based
    on the external name within the subscript.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例，我们将看到根据下标内的外部名称使用了正确的下标。
- en: Using external names within our subscript is very useful if we need multiple
    subscripts of the same type. I would not recommend using external names unless
    they are needed to distinguish between multiple subscripts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下标中使用外部名称非常有用，如果我们需要多个相同类型的下标。除非需要区分多个下标，否则我不建议使用外部名称。
- en: Multidimensional subscripts
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维下标
- en: While the most common subscripts are those that take a single parameter, subscripts
    are not limited to single parameters. They can take any number of input parameters,
    and these parameters can be of any type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最常见的下标是只接受单个参数的，但下标并不局限于单个参数。它们可以接受任意数量的输入参数，并且这些参数可以是任何类型。
- en: 'Let''s look at how we could use a multidimensional subscript to implement a
    Tic-Tac-Toe board. A Tic-Tac-Toe board looks similar to the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用多维下标来实现井字棋板。井字棋板看起来类似于以下图示：
- en: '![A picture containing clock  Description automatically generated](img/B16683_13_01.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![包含时钟的图片 描述自动生成](img/B16683_13_01.png)'
- en: 'Figure 13.1: Empty Tic-Tac-Toe board'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：空井字棋板
- en: The board can be represented by a two-dimensional array, where each dimension
    has three elements. The upper-left box of the board would be represented by the
    coordinates 0,0, while the lower-right box of the board would be represented by
    the coordinates 2,2\. The middle box would have the coordinates 1,1\. Each player
    will take turns placing their pieces (typically `x` or `o`) onto the board until
    one player has three pieces in a line or the board is full.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘可以用一个二维数组来表示，其中每个维度有三个元素。棋盘的左上角方框将表示坐标 0,0，而棋盘的右下角方框将表示坐标 2,2。中间的方框将具有坐标 1,1。每个玩家将轮流将他们的棋子（通常是
    `x` 或 `o`）放在棋盘上，直到一个玩家在一条线上有三个棋子或棋盘满了。
- en: 'Let''s look at how we could implement a Tic-Tac-Toe board using a multidimensional
    array and multidimensional subscripts:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用多维数组和多维下标来实现井字棋板：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We start the `TicTacToe` structure by defining a `3×3` array, also known as
    a matrix, which will represent the game board. We then define a subscript that
    can be used to set and retrieve player pieces on the board. The subscript will
    accept two integer values. We define multiple parameters for our subscripts by
    putting the parameters between parentheses. In this example, we are defining the
    subscript with the parameters `(x: Int, y: Int)`. We can then use the `x` and
    `y` variable names within our subscripts to access the values that are passed
    in.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use this subscript to set the user''s pieces on the board:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we run this code, we will see that we added the `x` piece to the center
    square and the `o` piece to the upper-left square, so our game board will look
    similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing clock  Description automatically generated](img/B16683_13_02.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Tic-Tac-Toe board with two player pieces'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to using only one type for our multidimensional subscripts.
    For example, we could have a subscript of `(x: Int, y: Double, z: String)`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add external names for our multidimensional subscript types to
    help identify what values are used for and to distinguish between subscripts that
    have the same types. Let''s take a look at how to use multiple types and external
    names with subscripts by creating a subscript that will return an array of string
    instances based on the values of the subscript:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `SayHello` structure, we define our subscript as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This defines a subscript with three elements. Each element has an external
    name (`messageText`, `messageName`, and `number`) and an internal name (`message`,
    `name`, and `number`). The first two elements are of the `String` type and the
    last one is an `Integer` type. We use the first two elements to create a message
    for the user that will repeat the number of times defined by the last (`number`)
    element. We will use this subscript as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we run this code, we will see that the `ret` variable contains an array of
    five strings, where each string equals `Bonjour Jon`. Now let's look at one of
    the most controversial new additions to the Swift language – dynamic member lookup.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic member lookup
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic member lookup enables a call to a property that will be dynamically
    resolved at runtime. This may not make a lot of sense without seeing an example,
    so let''s look at one. Let''s say that we had a structure that represented a baseball
    team. This structure has a property that represents the city the team was from
    and another property that represents the nickname of the team. The following code
    shows this structure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this structure, if we wanted to retrieve the full name of the baseball team,
    including the `city` and `nickname`, we could easily create a method as shown
    in the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is how you would do it in most object-oriented programming languages.
    However, in our code, which uses the `BaseballTeam` structure, we would retrieve
    the city and nickname as properties with the dot notation and the full name as
    a method. The following code shows how we would use both the `city` property and
    the `fullname` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can create a much cleaner interface using dynamic member lookups. To use
    dynamic member lookups, the first thing we need to do is to add the `@dynamicMemberLookup`
    attribute when we define the `BaseballTeam` structure, as shown in the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we will need to add the lookup to the `BaseballTeam` structure. This is
    done by implementing the `subscript(dynamicMember: )` subscript. The following
    code shows how we would create a lookup to retrieve both the full name and the
    winning percentage for the `BaseballTeam` structure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code will retrieve the key passed in and uses a `switch` statement, using
    that key, to determine what information to return from the subscript. With this
    code added to the `BaseballTeam` structure, we can use the lookup as shown in
    the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice how we are able to access both `fullname` and `percent` from the instance
    of the `BaseballTeam` structure as if they were normal properties. This makes
    our code much cleaner and easier to read. However, there is one thing to keep
    in mind when using lookups like this: there is no way to control what keys are
    passed into the lookup.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we called `fullname` and `percent`; however, we could
    just as easily have called flower or dog with no warning from the compiler. This
    is why there is a lot of controversy attached to dynamic member lookup, because
    there is no compile-time warning if you do something wrong.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If you use dynamic member lookup, make sure you verify the key and handle any
    instances when something unexpected is sent, as we did with the previous example
    using the default case of the `switch` statement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to use subscripts, let's take a quick look at when
    not to use custom subscripts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: When not to use a custom subscript
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in this chapter, creating custom subscripts can really enhance
    our code. However, we should avoid overusing them or using them in a way that
    is not consistent with standard subscript usage. The way to avoid overusing subscripts
    is to examine how subscripts are used in Swift's standard libraries.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding example, within the `MyNames` class, we define an array of
    names that are used within our application. As an example, let''s say that within
    our application we display this list of names and allow users to add names to
    it. Within the `MyNames` class, we then define the following subscript, which
    allows us to append a new name to the array:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would be a poor use of subscripts because its usage is not consistent
    with how subscripts are used within the Swift language itself—we are using it
    to accept a parameter and add that value. This might cause confusion when the
    class is used. It would be more appropriate to rewrite this subscript as a function,
    such as the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使用下标会是一个不好的选择，因为它的使用并不符合Swift语言本身对下标的用法——我们在这里使用它是为了接受一个参数并添加该值。当类被使用时，这可能会引起混淆。将这个下标重写为一个函数可能更合适，例如以下所示：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember, when you are using custom subscripts, make sure that you are using
    them appropriately.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你使用自定义下标时，确保你正在适当地使用它们。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we saw in this chapter, adding support for subscripts to our custom types
    can greatly enhance their readability and usability. We saw that subscripts can
    be used to add an abstraction layer between our backend storage class and external
    code. Subscripts can also be used in a similar manner to computed properties,
    where the subscript is used to calculate a value. As we noted, the key with subscripts
    is to use them appropriately and in a manner that is consistent with subscripts
    in the Swift language.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，为我们的自定义类型添加对下标的支持可以极大地增强它们的可读性和可用性。我们看到了下标可以用来在后台存储类和外部代码之间添加一个抽象层。下标也可以以类似的方式用于计算属性，其中下标用于计算一个值。正如我们指出的，使用下标的要点是适当地使用它们，并且与Swift语言中的下标用法保持一致。
- en: In the next chapter, we will look at what closures are and how to use them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨闭包是什么以及如何使用它们。
