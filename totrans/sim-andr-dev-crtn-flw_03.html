<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-28"><em class="italic"><a id="_idTextAnchor029"/>Chapter 2</em>: Understanding Kotlin Coroutines</h1>
			<p>In the previous chapter, you revisited the concept of asynchronous programming and how it helps you execute long-running tasks in the background without freezing the app and annoying your app’s users. You learned how to carry out asynchronous programming with Threads, AsyncTasks, and Executors. Finally, you were introduced to the new way of doing it on Android: Kotlin Coroutines and Flows.</p>
			<p>Coroutines is a <a id="_idIndexMarker057"/>Kotlin library for multithreading and asynchronous programming, such as making network calls and accessing files or databases. Kotlin Coroutine<a id="_idIndexMarker058"/>s is Google’s official recommendation for asynchronous programming on Android. Android Jetpack libraries, such as ViewModel, Lifecycle, WorkManager, and Room, include support for Kotlin Coroutines. Third-party Android libraries, such as Retrofit, now provide support for Kotlin Coroutines.</p>
			<p>In this chapter, we will dive deep into Kotlin Coroutines. You will learn how to use coroutines to carry out asynchronous programming in Android with simple code. You will also learn how to create coroutines in your Android app. Then, we will discuss other building blocks of coroutines, such as builders, scopes, dispatchers, contexts, and jobs.</p>
			<p>In this chapter, we’re going to cover the following topics:</p>
			<ul>
				<li>Creating coroutines in Android</li>
				<li>Exploring coroutine builders, scopes, and dispatchers</li>
				<li>Understanding coroutine contexts and jobs</li>
				<li>Exercise – using coroutines in an Android app</li>
			</ul>
			<p>By the end of this chapter, you will have an understanding of using Kotlin coroutines. You will be able to add coroutines for various cases in your Android apps. You will also understand the basic building blocks of Coroutines: builders, scopes, dispatchers, contexts, and jobs.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>For this chapter, you will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: Intel Core i5 or equivalent or higher, 4 GB of RAM minimum, and 4 GB available space.</p>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor031"/>Creating coroutines in Android</h1>
			<p>In this <a id="_idIndexMarker059"/>section, we will start by looking at how to create coroutines in Android. Coroutines provide an easy way to write asynchronous code with Kotlin’s standard functions. You can use coroutines when making a network call or when fetching data from or saving data to a local database.</p>
			<p>A simple coroutine looks as follows:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    performTask()</pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code">}</pre>
			<p>It has four parts: <strong class="source-inline">CoroutineScope</strong>, <strong class="source-inline">Dispatchers</strong>, <strong class="source-inline">launch</strong>, and the lambda function that will be executed by the coroutine. An instance of <strong class="source-inline">CoroutineScope</strong> was created for the coroutine’s scope. <strong class="source-inline">Dispatchers.IO</strong> is the dispatcher that will specify that this coroutine will run on the I/O dispatcher, the one usually used for <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) operations <a id="_idIndexMarker060"/>such as networking, database, and file processing. <strong class="source-inline">launch</strong> is the coroutine builder that creates the coroutine. We will explore these components in detail later in this chapter.</p>
			<p>The following diagram summarizes these parts of a coroutine:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_2.1_B1773.jpg" alt="Figure 2.1 – Parts of a coroutine&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Parts of a coroutine</p>
			<p>In Android Studio, the <strong class="bold">Editor</strong> window<a id="_idIndexMarker061"/> identifies the suspending function calls in your code with a gutter icon next to the line number. As shown on line <strong class="bold">16</strong> in the following screenshot, the <strong class="source-inline">performTask()</strong> call has the suspend function call gutter icon next to it:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_2.02_B17773.jpg" alt="Figure 2.2 – Android Studio suspend function call gutter icon&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Android Studio suspend function call gutter icon</p>
			<p>Let’s say <a id="_idIndexMarker062"/>you have an Android application that displays the list of movies that are currently playing in cinemas. So, let’s look at the ways you can use the <strong class="source-inline">suspend</strong> function and add coroutines to the project.</p>
			<p>If you’re using Retrofit 2.6.0 or above, you can mark the endpoint function as a suspending function with <strong class="source-inline">suspend</strong>, as follows:</p>
			<pre class="source-code">@GET("movie/now_playing")</pre>
			<pre class="source-code">suspend fun getMovies() : List&lt;Movies&gt;</pre>
			<p>Then, you can create a coroutine that will call the <strong class="source-inline">getMovies</strong> suspending function and display the list:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    val movies = movieService.getMovies()</pre>
			<pre class="source-code">    withContext(Dispatchers.Main) {</pre>
			<pre class="source-code">        displayMovies(movies)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This will create a <a id="_idIndexMarker063"/>coroutine that fetches the movies in the background. The <strong class="source-inline">withContext</strong> call will change the context of the coroutine to use <strong class="source-inline">Dispatchers.Main</strong> to display the fetched movies in the main thread.</p>
			<p>If you are using Room-KTX 2.1 or above, you can add the <strong class="source-inline">suspend</strong> keyword to your <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) functions <a id="_idIndexMarker064"/>so that the query or operation can be executed on the background thread and the result will be posted on the main thread. The following is an example:</p>
			<pre class="source-code">@Dao</pre>
			<pre class="source-code">interface MovieDao {</pre>
			<pre class="source-code">    @Query("SELECT * from movies")</pre>
			<pre class="source-code">    suspend fun getMovies(): List&lt;Movies&gt;</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>This will make the <strong class="source-inline">getMovies</strong> <a id="_idTextAnchor032"/>query a suspending function. When you call this function, Room-KTX internally executes the query on a background thread. The results can be displayed on the main thread without it freezing your app.</p>
			<p>When you create a coroutine inside another coroutine, the new coroutine becomes the child of the original coroutine. The original coroutine becomes the parent of the new coroutine. This can be seen in the following code:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    performTask1()</pre>
			<pre class="source-code">    launch {</pre>
			<pre class="source-code">        performTask2()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker065"/>second coroutine that was launched with <strong class="source-inline">performTask2</strong> was created using the <strong class="source-inline">Coroutine Scope</strong> of the parent coroutine.</p>
			<p>In this section, you explored how to add coroutines to your Android project and learned how to create coroutines for your app. In the next section, you will explore some of the building blocks of coroutines: builders, scopes, and dispatchers.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Exploring coroutine builders, scopes, and dispatchers</h1>
			<p>In this section, you will learn how to use coroutine builders and explore coroutine scopes and dispatchers. Coroutine builders are functions that are used to create coroutines. Coroutine scope is the scope with which the coroutines run. Dispatchers specify in what thread the coroutine will run.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor034"/>Coroutine builders</h2>
			<p>In the <a id="_idIndexMarker066"/>previous section, you created a coroutine with <strong class="source-inline">launch</strong>. However, there are other ways to create coroutines. Coroutine builders are the functions that you can use to create coroutines. To create a coroutine, you can use the following Kotlin coroutine builders:</p>
			<ul>
				<li><strong class="source-inline">launch</strong></li>
				<li><strong class="source-inline">async</strong></li>
				<li><strong class="source-inline">runBlocking</strong></li>
			</ul>
			<p><strong class="source-inline">async</strong> and <strong class="source-inline">launch</strong> need to be started on a coroutine scope. Meanwhile, <strong class="source-inline">runBlocking</strong> doesn’t need to be started from a coroutine scope.</p>
			<p>The <strong class="source-inline">launch</strong> keyword <a id="_idIndexMarker067"/>creates a coroutine and doesn’t return a value. Instead, it returns a <strong class="source-inline">Job</strong> object that represents the coroutine.</p>
			<p>The <strong class="source-inline">launch</strong> coroutine builder<a id="_idIndexMarker068"/> is ideal to use when you want to <a id="_idIndexMarker069"/>run a task and then forget about it (this means you are not waiting for the result of the operation). Here’s an example of using the <strong class="source-inline">launch</strong> coroutine builder:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    val scope = MainScope()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            delay(1_000)</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Once the activity has been created, a coroutine will be launched. This coroutine will call the <strong class="source-inline">delay</strong> suspending function to delay the coroutine for a second, resume, and display the progress bar; then, it’s done.</p>
			<p>On the other<a id="_idIndexMarker070"/> hand, the <strong class="source-inline">async</strong> builder<a id="_idIndexMarker071"/> is similar to <strong class="source-inline">launch</strong> but it returns a value: a <strong class="source-inline">Deferred</strong> object. Later, you can get this value with the <strong class="source-inline">await</strong> function. The <strong class="source-inline">async</strong> builder should be used when you want to execute a task and want to get the output of said task. An example of <a id="_idIndexMarker072"/>using the <strong class="source-inline">async</strong> coroutine builder is as follows:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    val scope = MainScope()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val textView =</pre>
			<pre class="source-code">          findViewById&lt;TextView&gt;(R.id.textView)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            val text = async {</pre>
			<pre class="source-code">                getText()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            delay(1_000)</pre>
			<pre class="source-code">            textView.text = text.await()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, a coroutine<a id="_idIndexMarker073"/> was started with <strong class="source-inline">async</strong> to call the <strong class="source-inline">getText</strong> function. This will return a deferred object called <strong class="source-inline">text</strong>. There will be a delay of 1 second and then the actual value from <strong class="source-inline">text</strong> will be called with <strong class="source-inline">text.await()</strong>, which will be set as the text for <strong class="source-inline">textView</strong>. With <strong class="source-inline">async</strong>, two tasks can be computed in parallel.</p>
			<p><strong class="source-inline">runBlocking</strong> starts a <a id="_idIndexMarker074"/>new coroutine and blocks the current thread until the task has been executed. This <a id="_idIndexMarker075"/>is useful for cases when you need to block the thread. Creating unit tests is one of these cases:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        runBlocking {</pre>
			<pre class="source-code">            delay(2_000)</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, the <strong class="source-inline">runBlocking</strong> code will create a coroutine and block the thread. After a delay of 2,000 milliseconds (2 seconds), it will display the progress bar. </p>
			<p>In this section, you explored how to use coroutine builders to create coroutines. You also learned about the <strong class="source-inline">async</strong>, <strong class="source-inline">launch</strong>, and <strong class="source-inline">runBlocking</strong> coroutine builders.</p>
			<p>In the next section, you will explore coroutine scopes.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Coroutine scopes</h2>
			<p><strong class="source-inline">CoroutineScope</strong> is the <a id="_idIndexMarker076"/>scope with which the coroutine will run. It defines the life cycle of the coroutines created from it, from its start to its end. If you cancel a scope, it will cancel all the coroutines it created. Coroutines follow the principle of structured concurrency – that is, a mechanism that provides the structure of a coroutine.</p>
			<p>The <strong class="source-inline">launch</strong> and <strong class="source-inline">async</strong> coroutine builders are extension functions from <strong class="source-inline">CoroutineScope</strong> for creating coroutines.</p>
			<p>For example, let’s say we have created a coroutine using <strong class="source-inline">MainScope</strong>:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    val scope = MainScope()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This launches a coroutine using <strong class="source-inline">MainScope</strong> to display the progress bar.</p>
			<p><strong class="source-inline">MainScope</strong> is the main <strong class="source-inline">CoroutineScope</strong> for the main thread, which uses <strong class="source-inline">Dispatchers.Main</strong> for its coroutine. It is normally used for creating coroutines that will update the user interface.</p>
			<p>You can also<a id="_idIndexMarker077"/> create a <strong class="source-inline">CoroutineScope</strong> instead of using <strong class="source-inline">MainScope</strong> by creating one with the <strong class="source-inline">CoroutineScope</strong> factory function. The <strong class="source-inline">CoroutineScope</strong> function requires you to pass in a coroutine context. <strong class="source-inline">CoroutineContext</strong> is a collection of elements for the coroutines that specify how the coroutine should run.</p>
			<p>You passed a dispatcher and both a dispatcher and a job in the previous examples for the coroutine context. Dispatchers and jobs are coroutine context elements. You will learn more about coroutine contexts later in this chapter.</p>
			<p>Your <strong class="source-inline">CoroutineScope</strong> must have a job and a way for the coroutine to be canceled, such as when <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, or <strong class="source-inline">ViewModel</strong> has been closed.</p>
			<p>In the next section, we will look at a built-in coroutine scope called <strong class="source-inline">lifecycleScope</strong>, which is part of Jetpack’s Lifecycle library.</p>
			<h3>lifecycleScope</h3>
			<p><strong class="source-inline">lifecycleScope</strong> is a <strong class="source-inline">CoroutineScope</strong> from<a id="_idIndexMarker078"/> Jetpack’s Lifecycle library that you can use to <a id="_idIndexMarker079"/>create coroutines. It is tied to the <strong class="source-inline">Lifecycle</strong> object (similar to your activity or fragment) and is automatically canceled when the life cycle is destroyed. Thus, you no longer need to manually cancel them. </p>
			<p><strong class="source-inline">lifecycleScope</strong> simplifies how scopes are created, how jobs are handled, and how they can be canceled within your activity or fragment. A <strong class="source-inline">lifecycleScope</strong> uses <strong class="source-inline">Dispatchers.Main.immediate</strong> for its dispatcher and a <strong class="source-inline">SupervisorJob</strong> for its job, such as <strong class="source-inline">viewModelScope</strong>.</p>
			<p>To use <strong class="source-inline">lifecycleScope</strong>, you must add the following line to your <strong class="source-inline">app/build.gradle</strong> file dependencies:</p>
			<pre class="source-code">implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.4.1"</pre>
			<p>An example of <strong class="source-inline">lifeCycleScope</strong> is as follows:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>When the<a id="_idIndexMarker080"/> activity is created, it launches a coroutine from <strong class="source-inline">lifecycleScope</strong> to display the progress bar.</p>
			<p>To change<a id="_idIndexMarker081"/> the dispatcher that the coroutine will use, you can pass in a dispatcher when using the <strong class="source-inline">launch</strong> and <strong class="source-inline">async</strong> coroutine builders:</p>
			<pre class="source-code">lifecycleScope.launch(Dispatchers.IO) { ... }</pre>
			<p>This will use the <strong class="source-inline">Dispatchers.IO</strong> dispatcher instead of the <strong class="source-inline">lifecycleScope</strong> object's default <strong class="source-inline">Dispatchers.Main.immediate</strong> for the coroutine that was launched.</p>
			<p>Aside from <strong class="source-inline">launch</strong>, <strong class="source-inline">lifecycleScope</strong> has additional coroutine builders, depending on the life cycle’s state:</p>
			<ul>
				<li><strong class="source-inline">launchWhenCreated</strong></li>
				<li><strong class="source-inline">launchWhenStarted</strong></li>
				<li><strong class="source-inline">launchWhenResumed</strong></li>
			</ul>
			<p>As the name suggests, <strong class="source-inline">launchWhenCreated</strong> launches the coroutine when the life cycle is created, <strong class="source-inline">launchWhenStarted</strong> launches the coroutine when the life cycle is started, and <strong class="source-inline">launchWhenResumed</strong> launches the coroutine when the life cycle goes back to<a id="_idIndexMarker082"/> the <strong class="bold">Resumed</strong> state.</p>
			<p>In the next section, we will look at a built-in <strong class="source-inline">CoroutineScope</strong> from <strong class="source-inline">ViewModel</strong> called <strong class="source-inline">viewModelScope</strong>.</p>
			<h3>viewModelScope</h3>
			<p><strong class="source-inline">viewModelScope</strong> is <a id="_idIndexMarker083"/>the ViewModel’s default <strong class="source-inline">CoroutineScope</strong> for<a id="_idIndexMarker084"/> creating coroutines. It is ideal to use if you need to do a long-running task from <strong class="source-inline">ViewModel</strong>. This scope and all running jobs are automatically canceled when <strong class="source-inline">ViewModel</strong> is cleared (that is, when <strong class="source-inline">onCleared</strong> is invoked).</p>
			<p><strong class="source-inline">viewModelScope</strong> simplifies the creation of <strong class="source-inline">Scope</strong>, handling the job, and canceling within <strong class="source-inline">ViewModel</strong>. A <strong class="source-inline">viewModelScope</strong> uses <strong class="source-inline">Dispatchers.Main.immediate</strong> for its dispatcher and uses a <strong class="source-inline">SupervisorJob</strong> for the job. A <strong class="source-inline">SupervisorJob</strong> is a special version of <strong class="source-inline">Job</strong> that allows its children to fail independently of each other.</p>
			<p>To use <strong class="source-inline">viewModelScope</strong>, you must add the following line to your <strong class="source-inline">app/build.gradle</strong> file dependencies:</p>
			<pre class="source-code">implementation "androidx.lifecycle:lifecycle-viewmodel-</pre>
			<pre class="source-code">  ktx:2.4.1"</pre>
			<p>You can use <strong class="source-inline">viewModelScope</strong> like so:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch {</pre>
			<pre class="source-code">            fetchMovies()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This launches a coroutine from <strong class="source-inline">viewModelScope</strong> that will be used to run the <strong class="source-inline">fetchMovies()</strong> function.</p>
			<p>To change the<a id="_idIndexMarker085"/> dispatcher that the coroutine will use, you can pass in a dispatcher when using the <strong class="source-inline">launch</strong> and <strong class="source-inline">async</strong> coroutine builders:</p>
			<pre class="source-code">viewModelScope.launch (Dispatchers.IO) { ... }</pre>
			<p>This will <a id="_idIndexMarker086"/>use <strong class="source-inline">Dispatchers.IO</strong> for the coroutine, instead of viewModelScope’s default of <strong class="source-inline">Dispatchers.Main</strong>.</p>
			<h3>coroutineScope{} and supervisorScope{}</h3>
			<p>The <strong class="source-inline">coroutineScope{}</strong> suspending<a id="_idIndexMarker087"/> builder<a id="_idIndexMarker088"/> allows you to create a <strong class="source-inline">CoroutineScope</strong> with the coroutine context from its outer scope. This calls the code block inside and does not complete until everything is done.</p>
			<p>You can use a <strong class="source-inline">coroutineScope{}</strong> builder like so:</p>
			<pre class="source-code">private suspend fun fetchAndDisplay() = coroutineScope {</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val movies = fetchMovies()</pre>
			<pre class="source-code">            displayMovies(movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val shows = fetchShows()</pre>
			<pre class="source-code">            DisplayShows(shows)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>This will create a coroutine scope that will call the <strong class="source-inline">fetchMovies</strong> function, set its return value to the <strong class="source-inline">movies</strong> object, and then call the <strong class="source-inline">displayMovies</strong> function with <strong class="source-inline">movies</strong>. Another child coroutine will call the <strong class="source-inline">fetchShows</strong> function, set its return value to the <strong class="source-inline">shows</strong> object, and then call the <strong class="source-inline">displayShows</strong> function with <strong class="source-inline">shows</strong>.</p>
			<p>When a <a id="_idIndexMarker089"/>child <a id="_idIndexMarker090"/>coroutine fails, it will cancel the parent coroutine and the sibling coroutines. If you do not want this to happen, you can use <strong class="source-inline">supervisorScope{}</strong> instead of <strong class="source-inline">coroutineScope{}</strong>.</p>
			<p>The <strong class="source-inline">supervisorScope{}</strong> builder<a id="_idIndexMarker091"/> is similar to<a id="_idIndexMarker092"/> the <strong class="source-inline">coroutineScope{}</strong> builder but the coroutine’s <strong class="source-inline">Scope</strong> has a <strong class="source-inline">SupervisorJob</strong>. This allows the children of <strong class="source-inline">supervisorScope</strong> to fail independently of each other.</p>
			<p>An example of <strong class="source-inline">supervisorScope</strong> is as follows:</p>
			<pre class="source-code"> private suspend fun fetchAndDisplayMovies() =</pre>
			<pre class="source-code">   supervisorScope {</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val movies = fetchMovies()</pre>
			<pre class="source-code">            displayMovies(movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val shows = fetchShows()</pre>
			<pre class="source-code">            displayShows(shows)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>This will create a supervisor scope (with a <strong class="source-inline">SupervisorJob</strong>) that will call the <strong class="source-inline">fetchMovies</strong> function. When a child coroutine fails, the parent and sibling coroutines will continue to work and will not be affected.</p>
			<h3>GlobalScope</h3>
			<p><strong class="source-inline">GlobalScope</strong> is a<a id="_idIndexMarker093"/> special <strong class="source-inline">CoroutineScope</strong> that is not<a id="_idIndexMarker094"/> tied to an object or a job. It should only be used in cases when you must run a task or tasks that will always be active while the application is alive. As such, if you want to use <strong class="source-inline">GlobalScope</strong>, you must annotate the call with <strong class="source-inline">@OptIn(DelicateCoroutinesApi::class)</strong>. </p>
			<p>For all other cases in Android, it is recommended to use <strong class="source-inline">viewModelScope</strong>, <strong class="source-inline">lifecycleScope</strong>, or a custom coroutine scope.</p>
			<h3>Test scopes</h3>
			<p>Kotlin<a id="_idIndexMarker095"/> has a <strong class="source-inline">kotlinx-coroutines-test</strong> library for testing coroutines. This testing library includes a special coroutine scope that you can use to create tests for your coroutines. You will learn more about testing coroutines in <a href="B17773_04_Epub.xhtml#_idTextAnchor051"><em class="italic">Chapter 4</em></a>, <em class="italic">Testing Kotlin Coroutines</em>.</p>
			<p>In this section, you learned about <strong class="source-inline">CoroutineScope</strong>, as well as about <strong class="source-inline">MainScope</strong> and creating coroutine scopes with the <strong class="source-inline">CoroutineScope</strong> function. You also learned about built-in scopes such as <strong class="source-inline">viewModelScope</strong> and <strong class="source-inline">lifecycleScope</strong>. </p>
			<p>In the next section, you will learn about coroutine dispatchers.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor036"/>Coroutine dispatchers</h2>
			<p>Coroutines have a <a id="_idIndexMarker096"/>context, which includes the coroutine dispatcher. Dispatchers specify what thread the coroutine will use to perform the task. The following dispatchers can be used:</p>
			<ul>
				<li><strong class="source-inline">Dispatchers.Main</strong>: This<a id="_idIndexMarker097"/> is used to run on Android’s main thread, usually for updates to the user interface. A special version of <strong class="source-inline">Dispatchers.Main</strong>, called <strong class="source-inline">Dispatchers.Main.immediate</strong>, is used to immediately execute the coroutine in the main thread. The <strong class="source-inline">viewModelScope</strong> and <strong class="source-inline">lifecycleScope</strong> coroutine scopes use <strong class="source-inline">Dispatchers.Main.immediate</strong> by default. </li>
				<li><strong class="source-inline">Dispatchers.IO</strong>: This<a id="_idIndexMarker098"/> is designed for networking operations, and for reading from or writing to files or databases.</li>
				<li><strong class="source-inline">Dispatchers.Default</strong>: This is <a id="_idIndexMarker099"/>used for CPU-intensive work, such as complicated computations or processing text, images, or videos. If you don’t set a dispatcher, <strong class="source-inline">Dispatchers.Default</strong> will be chosen by default.</li>
				<li><strong class="source-inline">Dispatchers.Unconfined</strong>: This<a id="_idIndexMarker100"/> is a special dispatcher that is not confined to any specific threads. It executes the coroutine in the current thread and resumes it in whatever thread that is used by the suspending function.</li>
			</ul>
			<p>You can set <a id="_idIndexMarker101"/>the dispatchers when setting the context in <strong class="source-inline">CoroutineScope</strong> or when using coroutine builders.</p>
			<p>When using <strong class="source-inline">MainScope</strong> as the coroutine scope for your coroutine, <strong class="source-inline">Dispatchers.Main</strong> is used by default:</p>
			<pre class="source-code">MainScope().launch { ... }</pre>
			<p>This coroutine will automatically use <strong class="source-inline">Dispatchers.Main</strong> so that you no longer need to specify it.</p>
			<p>If you used a different coroutine scope, you can pass in the dispatcher that will be used by the coroutine:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    fetchMovies()</pre>
			<pre class="source-code">}</pre>
			<p>The preceding code creates a <strong class="source-inline">CoroutineScope</strong> that will be run using <strong class="source-inline">Dispatchers.IO</strong> for the dispatcher.</p>
			<p>You can also pass in a dispatcher when using the <strong class="source-inline">launch</strong> and <strong class="source-inline">async</strong> coroutine builders:</p>
			<pre class="source-code">viewModelScope.launch(Dispatchers.Default) { ... }</pre>
			<p>This will launch a coroutine using the <strong class="source-inline">Dispatchers.Default</strong> dispatcher.</p>
			<p>To change the context of your coroutine, you can use the <strong class="source-inline">withContext</strong> function for the code that you want to use a different thread with. For example, in your suspending function, <strong class="source-inline">getMovies</strong>, which gets movies from your endpoint, you can use <strong class="source-inline">Dispatchers.IO</strong>:</p>
			<pre class="source-code">suspend fun getMovies(): List&lt;Movies&gt;  {</pre>
			<pre class="source-code">    withContext(Dispatchers.IO) { ... }</pre>
			<pre class="source-code">}</pre>
			<p>In the <a id="_idIndexMarker102"/>preceding code, the <strong class="source-inline">getMovies</strong> function uses <strong class="source-inline">Dispatchers.IO</strong> to fetch the list of movies from a network endpoint.</p>
			<p>In this section, you learned what dispatchers are and what dispatchers you can use, depending on your needs. You also learned how to use <strong class="source-inline">withContext</strong> to change the specific thread the coroutine runs on.</p>
			<p>In the next section, you will explore coroutine contexts and jobs.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor037"/>Understanding coroutine contexts and jobs</h1>
			<p>In this section, you will learn about coroutine contexts and jobs. Coroutines run in a coroutine context. A job is the context of the coroutine that allows you to manage the coroutine’s execution.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor038"/>Coroutine contexts</h2>
			<p>Each coroutine<a id="_idIndexMarker103"/> runs in a coroutine context. A coroutine context is a collection of elements for the coroutines that specifies how the coroutine should run. A coroutine scope has a default coroutine context; if it’s empty, it will have an <strong class="source-inline">EmptyCoroutineContext</strong>.</p>
			<p>When you create a <strong class="source-inline">CoroutineScope</strong> or use a coroutine builder, you can pass in a <strong class="source-inline">CoroutineContext</strong>. In the previous examples, we were passing a dispatcher:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO) {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">viewModelScope.launch(Dispatchers.Default) { ... }</pre>
			<p>The preceding example shows how to pass a dispatcher in the <strong class="source-inline">CoroutineScope</strong> function or in the coroutine builder.</p>
			<p>What you’re<a id="_idIndexMarker104"/> passing in these functions is a <strong class="source-inline">CoroutineContext</strong>. The following are some of the <strong class="source-inline">CoroutineContext</strong> elements<a id="_idIndexMarker105"/> you can use:</p>
			<ul>
				<li><strong class="source-inline">CoroutineDispatcher</strong></li>
				<li><strong class="source-inline">Job</strong></li>
				<li><strong class="source-inline">CoroutineName</strong></li>
				<li><strong class="source-inline">CoroutineExceptionHandler</strong></li>
			</ul>
			<p>The main <strong class="source-inline">CoroutineContext</strong> elements are dispatchers and jobs. Dispatchers specify the thread where the coroutine runs, while the job of the coroutine allows you to manage the coroutine’s task.</p>
			<p>Jobs allow you to manage the life cycle of the coroutine, from the creation of the coroutine to the completion of the task. You can use this job to cancel the coroutine itself. You’ll learn more about coroutine cancelations in <a href="B17773_03_Epub.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling Coroutines Cancelations and Exceptions</em>.</p>
			<p><strong class="source-inline">CoroutineName</strong> is<a id="_idIndexMarker106"/> another <strong class="source-inline">CoroutineContext</strong> you can use to set a string to name a coroutine. This name can be useful for debugging purposes. For example, you can add a <strong class="source-inline">CoroutineName</strong> using the following code:</p>
			<pre class="source-code">val scope = CoroutineScope(Dispatchers.IO)</pre>
			<pre class="source-code">scope.launch(CoroutineName("IOCoroutine")) {</pre>
			<pre class="source-code">    performTask()</pre>
			<pre class="source-code">}</pre>
			<p>This will give the name of <strong class="source-inline">IOCoroutine</strong> to the coroutine that was launched using the <strong class="source-inline">Dispatchers.IO</strong> dispatcher.</p>
			<p>As the coroutine context is a collection of elements for the coroutine, you can use operators such as the <strong class="source-inline">+</strong> symbol to combine context elements to create a new <strong class="source-inline">CoroutineContext</strong>:</p>
			<pre class="source-code">val context = Dispatchers.Main + Job()</pre>
			<p><strong class="source-inline">MainScope</strong>, <strong class="source-inline">viewModelScope</strong>, and <strong class="source-inline">lifecycleScope</strong>, for example, use something like the following for the coroutine scope’s context:</p>
			<pre class="source-code">SupervisorJob() + Dispatchers.Main.immediate</pre>
			<p>Another <a id="_idIndexMarker107"/>coroutine context element you can use is <strong class="source-inline">CoroutineExceptionHandler</strong>, an <a id="_idIndexMarker108"/>element you can use to handle exceptions. You will learn more about <strong class="source-inline">CoroutineExceptionHandler</strong> in <a href="B17773_03_Epub.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling Coroutines Cancelations and Exceptions</em>.</p>
			<p>In the previous section, you used the <strong class="source-inline">withContext</strong> function to change the dispatcher to specify a different thread to run your coroutine. As the name implies, this changes the coroutine context with the dispatcher, which is a <strong class="source-inline">CoroutineContext</strong> element itself:</p>
			<pre class="source-code">withContext(Dispatchers.IO) { ... }</pre>
			<p>This changes the coroutine context with a new dispatcher, <strong class="source-inline">Dispatchers.IO</strong>.</p>
			<p>In the next section, you will learn about jobs.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>Coroutine jobs</h2>
			<p>A <strong class="bold">job</strong> is<a id="_idIndexMarker109"/> a <strong class="source-inline">ContextCoroutine</strong> element <a id="_idIndexMarker110"/>that you can use for the coroutine context. You can use jobs to manage the coroutine’s tasks and its life cycle. Jobs can be canceled or joined together.</p>
			<p>The <strong class="source-inline">launch</strong> coroutine builder creates a new job, while the <strong class="source-inline">async</strong> coroutine builder returns a <strong class="source-inline">Deferred&lt;T&gt;</strong> object. <strong class="source-inline">Deferred</strong> is itself a <strong class="source-inline">Job</strong> object – that is, a job that has a result.</p>
			<p>To access the job from the coroutine, you can set it to a variable:</p>
			<pre class="source-code">val job = viewModelScope.launch(Dispatchers.IO) { ... }</pre>
			<p>The <strong class="source-inline">launch</strong> coroutine builder creates a coroutine running in the <strong class="source-inline">Dispatchers.IO</strong> thread and returns a job. A job can have children jobs, making it a parent job. <strong class="source-inline">Job</strong> has a <strong class="source-inline">children</strong> property you can use to get the job’s children:</p>
			<pre class="source-code">val job1 = viewModelScope.launch(Dispatchers.IO) { </pre>
			<pre class="source-code">    val movies = fetchMovies()</pre>
			<pre class="source-code">    val job2 = launch {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <strong class="source-inline">job2</strong> becomes a child of <strong class="source-inline">job1</strong>, which is the parent. This means that <strong class="source-inline">job2</strong> will inherit the coroutine context of the parent, though you can also change it.</p>
			<p>If a parent job is <a id="_idIndexMarker111"/>canceled or failed, its children are also automatically canceled. When a child’s job is canceled or failed, its parent will also be canceled. </p>
			<p>A <strong class="source-inline">SupervisorJob</strong> is a special version of a job that allows its children to fail independently of each other. </p>
			<p>Using a job also allows you to create a coroutine that you can later start instead of immediately running by default. To do this, you must use <strong class="source-inline">CoroutineStart.LAZY</strong> as the value of the <strong class="source-inline">start</strong> parameter in your coroutine builder and assign the result to a <strong class="source-inline">Job</strong> variable. Later, you can then use the <strong class="source-inline">start()</strong> function to run the coroutine, as shown here:</p>
			<pre class="source-code">val lazyJob = viewModelScope.launch (start=CoroutineStart.LAZY) {</pre>
			<pre class="source-code">    delay(1_000)</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">lazyJob.start()</pre>
			<p>This will create a lazy coroutine. When you are ready to start it, you can simply call <strong class="source-inline">lazyJob.start()</strong>.</p>
			<p>With the <strong class="source-inline">Job</strong> object, you can also use the <strong class="source-inline">join()</strong> suspending function to wait for the job to be completed before continuing with another job or task:</p>
			<pre class="source-code">viewModelScope.launch {</pre>
			<pre class="source-code">    val job1 = launch {</pre>
			<pre class="source-code">        showProgressBar()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    job1.join()</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    val job2 = launch {</pre>
			<pre class="source-code">        fetchMovies()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this <a id="_idIndexMarker112"/>example, <strong class="source-inline">job1</strong> will be run first and <strong class="source-inline">job2</strong> won’t be executed until the former job (<strong class="source-inline">job1</strong>) has finished.</p>
			<p>In the next section, you will learn more about the states of coroutine jobs.</p>
			<h3>Coroutine job states</h3>
			<p>A job has<a id="_idIndexMarker113"/> the following states:</p>
			<ul>
				<li>New</li>
				<li>Active</li>
				<li>Completing</li>
				<li>Completed</li>
				<li>Canceling</li>
				<li>Canceled</li>
			</ul>
			<p>These states of a job and its life cycle are summarized in the following diagram:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.03_B17773.jpg" alt="Figure 2.3 – Coroutine job life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Coroutine job life cycle</p>
			<p>When you start a <a id="_idIndexMarker114"/>coroutine, a job is<a id="_idIndexMarker115"/> created in the <strong class="bold">New</strong> state. It then becomes <strong class="bold">Active</strong> when the job automatically starts or when you call the <strong class="source-inline">start()</strong> or <strong class="source-inline">join()</strong> function. The job is in the <strong class="bold">Active</strong> state <a id="_idIndexMarker116"/>while the job is running. </p>
			<p>Completing a job moves it into<a id="_idIndexMarker117"/> the <strong class="bold">Completing</strong> state and then into<a id="_idIndexMarker118"/> the <strong class="bold">Completed</strong> state once its children complete their tasks.</p>
			<p>If a job is canceled manually or failed because of an exception, it will go into the <strong class="bold">Canceling</strong> state and<a id="_idIndexMarker119"/> then into<a id="_idIndexMarker120"/> the <strong class="bold">Canceled</strong> state once its children complete.</p>
			<p>A <strong class="source-inline">Job</strong> object has three properties you can use to check the state of the job:</p>
			<ul>
				<li><strong class="source-inline">isActive</strong>: This property<a id="_idIndexMarker121"/> is <strong class="source-inline">true</strong> when the job is running or completing, and <strong class="source-inline">false</strong> otherwise.</li>
				<li><strong class="source-inline">isComplete</strong>: This <a id="_idIndexMarker122"/>property is <strong class="source-inline">true</strong> when the job has finished its task (canceled or completed), and <strong class="source-inline">false</strong> otherwise.</li>
				<li><strong class="source-inline">isCancelled</strong>: This <a id="_idIndexMarker123"/>property is <strong class="source-inline">true</strong> if the job has been canceled or is being canceled, manually or because of an exception, and <strong class="source-inline">false</strong> otherwise.</li>
			</ul>
			<p>You will learn more about jobs and how they are used to cancel coroutines in <a href="B17773_03_Epub.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling Coroutines Cancelations and Exceptions</em>.</p>
			<p>In this section, you learned about coroutine contexts and jobs. <strong class="source-inline">CoroutineContext</strong> is a collection of coroutine context elements for the coroutines that specifies how the coroutine should run. Examples of <strong class="source-inline">CoroutineContext</strong> elements are dispatchers and jobs. A job is created from a coroutine. You can use it to manage the coroutine’s tasks and life cycle.</p>
			<p>Now, you will use what you have learned so far to add coroutines to an Android project.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor040"/>Exercise – using coroutines in an Android app</h1>
			<p>In this exercise, you <a id="_idIndexMarker124"/>will be working with an application that displays movies that are playing now in cinemas. You will be using The Movie Database API version 3 to get the list of movies. Go to <a href="https://developers.themoviedb.org/3">https://developers.themoviedb.org/3</a> and <a id="_idIndexMarker125"/>register for an API key. Once you’ve done that, follow these steps:</p>
			<ol>
				<li>Open the <strong class="source-inline">Movie App</strong> project in the <strong class="source-inline">Chapter02</strong> directory in this book’s code repository.</li>
				<li>Open <strong class="source-inline">MovieRepository</strong> and update <strong class="source-inline">apiKey</strong> with the value from The Movie Database API:<p class="source-code">private val apiKey = "your_api_key_here" </p></li>
				<li>Open the <strong class="source-inline">app/build.gradle</strong> file and add a dependency for <strong class="source-inline">kotlinx-coroutines-android</strong>:<p class="source-code">implementation ‘org.jetbrains.kotlinx:kotlinx-</p><p class="source-code">  coroutines-android:1.6.0’</p></li>
			</ol>
			<p>This will add the <strong class="source-inline">kotlinx-coroutines-core</strong> and <strong class="source-inline">kotlinx-coroutines-android</strong> libraries to your project, allowing you to use coroutines in your code. </p>
			<ol>
				<li value="4">Also, add <a id="_idIndexMarker126"/>the dependencies for the <strong class="source-inline">ViewModel</strong> extension library:<p class="source-code">implementation ‘androidx.lifecycle:lifecycle-</p><p class="source-code">  viewmodel-ktx:2.4.1’</p></li>
			</ol>
			<p>This will add the <strong class="source-inline">ViewModel</strong> KTX library to your project. It includes a <strong class="source-inline">viewModelScope</strong> for <strong class="source-inline">ViewModel</strong>. </p>
			<ol>
				<li value="5">Open the <strong class="source-inline">MovieViewModel</strong> class, navigate to the <strong class="source-inline">fetchMovies</strong> function, and add the following code:<p class="source-code">fun fetchMovies() {</p><p class="source-code">    _loading.value = true</p><p class="source-code">    viewModelScope.launch(Dispatchers.IO) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will create a coroutine that will run in <strong class="source-inline">Dispatchers.IO</strong> (on a background thread for network operations). The coroutine will be launched using <strong class="source-inline">viewModelScope</strong>.</p>
			<ol>
				<li value="6">In the <strong class="source-inline">fetchMovies</strong> coroutine, call the MovieRepository’s <strong class="source-inline">fetchMovies</strong> function to fetch the list of movies from The Movie Database API:<p class="source-code">fun fetchMovies() {</p><p class="source-code">    _loading.value = true</p><p class="source-code">    viewModelScope.launch(Dispatchers.IO) {</p><p class="source-code">        movieRepository.fetchMovies()</p><p class="source-code">        _loading.postValue(false)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The coroutine will be launched and will call the <strong class="source-inline">fetchMovies</strong> function from <strong class="source-inline">MovieRepository</strong>.</p>
			<ol>
				<li value="7">Run the<a id="_idIndexMarker127"/> application. You will see that the app displays a list of movies (with a poster and a title), as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.04_B17773.jpg" alt="Figure 2.4 –The app displaying a list of movies&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 –The app displaying a list of movies</p>
			<p>In this exercise, you created a coroutine using the ViewModel’s <strong class="source-inline">viewModelScope</strong>, used the <strong class="source-inline">launch</strong> coroutine <a id="_idIndexMarker128"/>builder, and executed a task to fetch the movies from the repository.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor041"/>Summary</h1>
			<p>In this chapter, you learned more about Kotlin coroutines and how you can use them for asynchronous programming in Android.</p>
			<p>You learned how to create coroutines with coroutine builders such as <strong class="source-inline">launch</strong>, <strong class="source-inline">async</strong>, and <strong class="source-inline">runBlocking</strong>. Then, you learned about dispatchers and using them to set the thread that the coroutines run on. You also learned about coroutine scopes and built-in scopes such as <strong class="source-inline">viewModelScope</strong> and <strong class="source-inline">lifecycleScope</strong>.</p>
			<p>After that, you learned about coroutine contexts and jobs. <strong class="source-inline">CoroutineContext</strong> is the context for the coroutine and includes elements such as dispatchers that the coroutine will run on and a job, which you can use to manage the coroutine’s task.</p>
			<p>Finally, you completed an exercise where you added a coroutine to an Android project. You used the ViewModel’s <strong class="source-inline">viewModelScope</strong> for the coroutine scope, the <strong class="source-inline">launch</strong> coroutine builder, and implemented the coroutine to fetch the list of movies using <strong class="source-inline">Dispatchers.IO</strong>.</p>
			<p>In the next chapter, you will learn how to handle coroutine cancelations, timeouts, and exceptions.</p>
		</div>
	</body></html>