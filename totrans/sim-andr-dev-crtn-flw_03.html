<html><head></head><body>
		<div><h1 id="_idParaDest-28"><em class="italic"><a id="_idTextAnchor029"/>Chapter 2</em>: Understanding Kotlin Coroutines</h1>
			<p>In the previous chapter, you revisited the concept of asynchronous programming and how it helps you execute long-running tasks in the background without freezing the app and annoying your app’s users. You learned how to carry out asynchronous programming with Threads, AsyncTasks, and Executors. Finally, you were introduced to the new way of doing it on Android: Kotlin Coroutines and Flows.</p>
			<p>Coroutines is a <a id="_idIndexMarker057"/>Kotlin library for multithreading and asynchronous programming, such as making network calls and accessing files or databases. Kotlin Coroutine<a id="_idIndexMarker058"/>s is Google’s official recommendation for asynchronous programming on Android. Android Jetpack libraries, such as ViewModel, Lifecycle, WorkManager, and Room, include support for Kotlin Coroutines. Third-party Android libraries, such as Retrofit, now provide support for Kotlin Coroutines.</p>
			<p>In this chapter, we will dive deep into Kotlin Coroutines. You will learn how to use coroutines to carry out asynchronous programming in Android with simple code. You will also learn how to create coroutines in your Android app. Then, we will discuss other building blocks of coroutines, such as builders, scopes, dispatchers, contexts, and jobs.</p>
			<p>In this chapter, we’re going to cover the following topics:</p>
			<ul>
				<li>Creating coroutines in Android</li>
				<li>Exploring coroutine builders, scopes, and dispatchers</li>
				<li>Understanding coroutine contexts and jobs</li>
				<li>Exercise – using coroutines in an Android app</li>
			</ul>
			<p>By the end of this chapter, you will have an understanding of using Kotlin coroutines. You will be able to add coroutines for various cases in your Android apps. You will also understand the basic building blocks of Coroutines: builders, scopes, dispatchers, contexts, and jobs.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>For this chapter, you will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: Intel Core i5 or equivalent or higher, 4 GB of RAM minimum, and 4 GB available space.</p>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor031"/>Creating coroutines in Android</h1>
			<p>In this <a id="_idIndexMarker059"/>section, we will start by looking at how to create coroutines in Android. Coroutines provide an easy way to write asynchronous code with Kotlin’s standard functions. You can use coroutines when making a network call or when fetching data from or saving data to a local database.</p>
			<p>A simple coroutine looks as follows:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    performTask()</pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code">}</pre>
			<p>It has four parts: <code>CoroutineScope</code>, <code>Dispatchers</code>, <code>launch</code>, and the lambda function that will be executed by the coroutine. An instance of <code>CoroutineScope</code> was created for the coroutine’s scope. <code>Dispatchers.IO</code> is the dispatcher that will specify that this coroutine will run on the I/O dispatcher, the one usually used for <code>launch</code> is the coroutine builder that creates the coroutine. We will explore these components in detail later in this chapter.</p>
			<p>The following diagram summarizes these parts of a coroutine:</p>
			<div><div><img src="img/Figure_2.1_B1773.jpg" alt="Figure 2.1 – Parts of a coroutine&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Parts of a coroutine</p>
			<p>In Android Studio, the <code>performTask()</code> call has the suspend function call gutter icon next to it:</p>
			<div><div><img src="img/Figure_2.02_B17773.jpg" alt="Figure 2.2 – Android Studio suspend function call gutter icon&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Android Studio suspend function call gutter icon</p>
			<p>Let’s say <a id="_idIndexMarker062"/>you have an Android application that displays the list of movies that are currently playing in cinemas. So, let’s look at the ways you can use the <code>suspend</code> function and add coroutines to the project.</p>
			<p>If you’re using Retrofit 2.6.0 or above, you can mark the endpoint function as a suspending function with <code>suspend</code>, as follows:</p>
			<pre class="source-code">@GET("movie/now_playing")</pre>
			<pre class="source-code">suspend fun getMovies() : List&lt;Movies&gt;</pre>
			<p>Then, you can create a coroutine that will call the <code>getMovies</code> suspending function and display the list:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    val movies = movieService.getMovies()</pre>
			<pre class="source-code">    withContext(Dispatchers.Main) {</pre>
			<pre class="source-code">        displayMovies(movies)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This will create a <a id="_idIndexMarker063"/>coroutine that fetches the movies in the background. The <code>withContext</code> call will change the context of the coroutine to use <code>Dispatchers.Main</code> to display the fetched movies in the main thread.</p>
			<p>If you are using Room-KTX 2.1 or above, you can add the <code>suspend</code> keyword to your <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) functions <a id="_idIndexMarker064"/>so that the query or operation can be executed on the background thread and the result will be posted on the main thread. The following is an example:</p>
			<pre class="source-code">@Dao</pre>
			<pre class="source-code">interface MovieDao {</pre>
			<pre class="source-code">    @Query("SELECT * from movies")</pre>
			<pre class="source-code">    suspend fun getMovies(): List&lt;Movies&gt;</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>This will make the <code>getMovies</code> <a id="_idTextAnchor032"/>query a suspending function. When you call this function, Room-KTX internally executes the query on a background thread. The results can be displayed on the main thread without it freezing your app.</p>
			<p>When you create a coroutine inside another coroutine, the new coroutine becomes the child of the original coroutine. The original coroutine becomes the parent of the new coroutine. This can be seen in the following code:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    performTask1()</pre>
			<pre class="source-code">    launch {</pre>
			<pre class="source-code">        performTask2()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker065"/>second coroutine that was launched with <code>performTask2</code> was created using the <code>Coroutine Scope</code> of the parent coroutine.</p>
			<p>In this section, you explored how to add coroutines to your Android project and learned how to create coroutines for your app. In the next section, you will explore some of the building blocks of coroutines: builders, scopes, and dispatchers.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Exploring coroutine builders, scopes, and dispatchers</h1>
			<p>In this section, you will learn how to use coroutine builders and explore coroutine scopes and dispatchers. Coroutine builders are functions that are used to create coroutines. Coroutine scope is the scope with which the coroutines run. Dispatchers specify in what thread the coroutine will run.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor034"/>Coroutine builders</h2>
			<p>In the <a id="_idIndexMarker066"/>previous section, you created a coroutine with <code>launch</code>. However, there are other ways to create coroutines. Coroutine builders are the functions that you can use to create coroutines. To create a coroutine, you can use the following Kotlin coroutine builders:</p>
			<ul>
				<li><code>launch</code></li>
				<li><code>async</code></li>
				<li><code>runBlocking</code></li>
			</ul>
			<p><code>async</code> and <code>launch</code> need to be started on a coroutine scope. Meanwhile, <code>runBlocking</code> doesn’t need to be started from a coroutine scope.</p>
			<p>The <code>launch</code> keyword <a id="_idIndexMarker067"/>creates a coroutine and doesn’t return a value. Instead, it returns a <code>Job</code> object that represents the coroutine.</p>
			<p>The <code>launch</code> coroutine builder<a id="_idIndexMarker068"/> is ideal to use when you want to <a id="_idIndexMarker069"/>run a task and then forget about it (this means you are not waiting for the result of the operation). Here’s an example of using the <code>launch</code> coroutine builder:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    val scope = MainScope()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            delay(1_000)</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Once the activity has been created, a coroutine will be launched. This coroutine will call the <code>delay</code> suspending function to delay the coroutine for a second, resume, and display the progress bar; then, it’s done.</p>
			<p>On the other<a id="_idIndexMarker070"/> hand, the <code>async</code> builder<a id="_idIndexMarker071"/> is similar to <code>launch</code> but it returns a value: a <code>Deferred</code> object. Later, you can get this value with the <code>await</code> function. The <code>async</code> builder should be used when you want to execute a task and want to get the output of said task. An example of <a id="_idIndexMarker072"/>using the <code>async</code> coroutine builder is as follows:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    val scope = MainScope()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val textView =</pre>
			<pre class="source-code">          findViewById&lt;TextView&gt;(R.id.textView)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            val text = async {</pre>
			<pre class="source-code">                getText()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            delay(1_000)</pre>
			<pre class="source-code">            textView.text = text.await()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, a coroutine<a id="_idIndexMarker073"/> was started with <code>async</code> to call the <code>getText</code> function. This will return a deferred object called <code>text</code>. There will be a delay of 1 second and then the actual value from <code>text</code> will be called with <code>text.await()</code>, which will be set as the text for <code>textView</code>. With <code>async</code>, two tasks can be computed in parallel.</p>
			<p><code>runBlocking</code> starts a <a id="_idIndexMarker074"/>new coroutine and blocks the current thread until the task has been executed. This <a id="_idIndexMarker075"/>is useful for cases when you need to block the thread. Creating unit tests is one of these cases:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        runBlocking {</pre>
			<pre class="source-code">            delay(2_000)</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, the <code>runBlocking</code> code will create a coroutine and block the thread. After a delay of 2,000 milliseconds (2 seconds), it will display the progress bar. </p>
			<p>In this section, you explored how to use coroutine builders to create coroutines. You also learned about the <code>async</code>, <code>launch</code>, and <code>runBlocking</code> coroutine builders.</p>
			<p>In the next section, you will explore coroutine scopes.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Coroutine scopes</h2>
			<p><code>CoroutineScope</code> is the <a id="_idIndexMarker076"/>scope with which the coroutine will run. It defines the life cycle of the coroutines created from it, from its start to its end. If you cancel a scope, it will cancel all the coroutines it created. Coroutines follow the principle of structured concurrency – that is, a mechanism that provides the structure of a coroutine.</p>
			<p>The <code>launch</code> and <code>async</code> coroutine builders are extension functions from <code>CoroutineScope</code> for creating coroutines.</p>
			<p>For example, let’s say we have created a coroutine using <code>MainScope</code>:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    val scope = MainScope()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This launches a coroutine using <code>MainScope</code> to display the progress bar.</p>
			<p><code>MainScope</code> is the main <code>CoroutineScope</code> for the main thread, which uses <code>Dispatchers.Main</code> for its coroutine. It is normally used for creating coroutines that will update the user interface.</p>
			<p>You can also<a id="_idIndexMarker077"/> create a <code>CoroutineScope</code> instead of using <code>MainScope</code> by creating one with the <code>CoroutineScope</code> factory function. The <code>CoroutineScope</code> function requires you to pass in a coroutine context. <code>CoroutineContext</code> is a collection of elements for the coroutines that specify how the coroutine should run.</p>
			<p>You passed a dispatcher and both a dispatcher and a job in the previous examples for the coroutine context. Dispatchers and jobs are coroutine context elements. You will learn more about coroutine contexts later in this chapter.</p>
			<p>Your <code>CoroutineScope</code> must have a job and a way for the coroutine to be canceled, such as when <code>Activity</code>, <code>Fragment</code>, or <code>ViewModel</code> has been closed.</p>
			<p>In the next section, we will look at a built-in coroutine scope called <code>lifecycleScope</code>, which is part of Jetpack’s Lifecycle library.</p>
			<h3>lifecycleScope</h3>
			<p><code>lifecycleScope</code> is a <code>CoroutineScope</code> from<a id="_idIndexMarker078"/> Jetpack’s Lifecycle library that you can use to <a id="_idIndexMarker079"/>create coroutines. It is tied to the <code>Lifecycle</code> object (similar to your activity or fragment) and is automatically canceled when the life cycle is destroyed. Thus, you no longer need to manually cancel them. </p>
			<p><code>lifecycleScope</code> simplifies how scopes are created, how jobs are handled, and how they can be canceled within your activity or fragment. A <code>lifecycleScope</code> uses <code>Dispatchers.Main.immediate</code> for its dispatcher and a <code>SupervisorJob</code> for its job, such as <code>viewModelScope</code>.</p>
			<p>To use <code>lifecycleScope</code>, you must add the following line to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source-code">implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.4.1"</pre>
			<p>An example of <code>lifeCycleScope</code> is as follows:</p>
			<pre class="source-code"> class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        super.onCreate(savedInstanceState)</pre>
			<pre class="source-code">        setContentView(R.layout.activity_main)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val progressBar =</pre>
			<pre class="source-code">          findViewById&lt;ProgressBar&gt;(R.id.progressBar)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            progressBar.isVisible = true</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>When the<a id="_idIndexMarker080"/> activity is created, it launches a coroutine from <code>lifecycleScope</code> to display the progress bar.</p>
			<p>To change<a id="_idIndexMarker081"/> the dispatcher that the coroutine will use, you can pass in a dispatcher when using the <code>launch</code> and <code>async</code> coroutine builders:</p>
			<pre class="source-code">lifecycleScope.launch(Dispatchers.IO) { ... }</pre>
			<p>This will use the <code>Dispatchers.IO</code> dispatcher instead of the <code>lifecycleScope</code> object's default <code>Dispatchers.Main.immediate</code> for the coroutine that was launched.</p>
			<p>Aside from <code>launch</code>, <code>lifecycleScope</code> has additional coroutine builders, depending on the life cycle’s state:</p>
			<ul>
				<li><code>launchWhenCreated</code></li>
				<li><code>launchWhenStarted</code></li>
				<li><code>launchWhenResumed</code></li>
			</ul>
			<p>As the name suggests, <code>launchWhenCreated</code> launches the coroutine when the life cycle is created, <code>launchWhenStarted</code> launches the coroutine when the life cycle is started, and <code>launchWhenResumed</code> launches the coroutine when the life cycle goes back to<a id="_idIndexMarker082"/> the <strong class="bold">Resumed</strong> state.</p>
			<p>In the next section, we will look at a built-in <code>CoroutineScope</code> from <code>ViewModel</code> called <code>viewModelScope</code>.</p>
			<h3>viewModelScope</h3>
			<p><code>viewModelScope</code> is <a id="_idIndexMarker083"/>the ViewModel’s default <code>CoroutineScope</code> for<a id="_idIndexMarker084"/> creating coroutines. It is ideal to use if you need to do a long-running task from <code>ViewModel</code>. This scope and all running jobs are automatically canceled when <code>ViewModel</code> is cleared (that is, when <code>onCleared</code> is invoked).</p>
			<p><code>viewModelScope</code> simplifies the creation of <code>Scope</code>, handling the job, and canceling within <code>ViewModel</code>. A <code>viewModelScope</code> uses <code>Dispatchers.Main.immediate</code> for its dispatcher and uses a <code>SupervisorJob</code> for the job. A <code>SupervisorJob</code> is a special version of <code>Job</code> that allows its children to fail independently of each other.</p>
			<p>To use <code>viewModelScope</code>, you must add the following line to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source-code">implementation "androidx.lifecycle:lifecycle-viewmodel-</pre>
			<pre class="source-code">  ktx:2.4.1"</pre>
			<p>You can use <code>viewModelScope</code> like so:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch {</pre>
			<pre class="source-code">            fetchMovies()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This launches a coroutine from <code>viewModelScope</code> that will be used to run the <code>fetchMovies()</code> function.</p>
			<p>To change the<a id="_idIndexMarker085"/> dispatcher that the coroutine will use, you can pass in a dispatcher when using the <code>launch</code> and <code>async</code> coroutine builders:</p>
			<pre class="source-code">viewModelScope.launch (Dispatchers.IO) { ... }</pre>
			<p>This will <a id="_idIndexMarker086"/>use <code>Dispatchers.IO</code> for the coroutine, instead of viewModelScope’s default of <code>Dispatchers.Main</code>.</p>
			<h3>coroutineScope{} and supervisorScope{}</h3>
			<p>The <code>coroutineScope{}</code> suspending<a id="_idIndexMarker087"/> builder<a id="_idIndexMarker088"/> allows you to create a <code>CoroutineScope</code> with the coroutine context from its outer scope. This calls the code block inside and does not complete until everything is done.</p>
			<p>You can use a <code>coroutineScope{}</code> builder like so:</p>
			<pre class="source-code">private suspend fun fetchAndDisplay() = coroutineScope {</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val movies = fetchMovies()</pre>
			<pre class="source-code">            displayMovies(movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val shows = fetchShows()</pre>
			<pre class="source-code">            DisplayShows(shows)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>This will create a coroutine scope that will call the <code>fetchMovies</code> function, set its return value to the <code>movies</code> object, and then call the <code>displayMovies</code> function with <code>movies</code>. Another child coroutine will call the <code>fetchShows</code> function, set its return value to the <code>shows</code> object, and then call the <code>displayShows</code> function with <code>shows</code>.</p>
			<p>When a <a id="_idIndexMarker089"/>child <a id="_idIndexMarker090"/>coroutine fails, it will cancel the parent coroutine and the sibling coroutines. If you do not want this to happen, you can use <code>supervisorScope{}</code> instead of <code>coroutineScope{}</code>.</p>
			<p>The <code>supervisorScope{}</code> builder<a id="_idIndexMarker091"/> is similar to<a id="_idIndexMarker092"/> the <code>coroutineScope{}</code> builder but the coroutine’s <code>Scope</code> has a <code>SupervisorJob</code>. This allows the children of <code>supervisorScope</code> to fail independently of each other.</p>
			<p>An example of <code>supervisorScope</code> is as follows:</p>
			<pre class="source-code"> private suspend fun fetchAndDisplayMovies() =</pre>
			<pre class="source-code">   supervisorScope {</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val movies = fetchMovies()</pre>
			<pre class="source-code">            displayMovies(movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        launch {</pre>
			<pre class="source-code">            val shows = fetchShows()</pre>
			<pre class="source-code">            displayShows(shows)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>This will create a supervisor scope (with a <code>SupervisorJob</code>) that will call the <code>fetchMovies</code> function. When a child coroutine fails, the parent and sibling coroutines will continue to work and will not be affected.</p>
			<h3>GlobalScope</h3>
			<p><code>GlobalScope</code> is a<a id="_idIndexMarker093"/> special <code>CoroutineScope</code> that is not<a id="_idIndexMarker094"/> tied to an object or a job. It should only be used in cases when you must run a task or tasks that will always be active while the application is alive. As such, if you want to use <code>GlobalScope</code>, you must annotate the call with <code>@OptIn(DelicateCoroutinesApi::class)</code>. </p>
			<p>For all other cases in Android, it is recommended to use <code>viewModelScope</code>, <code>lifecycleScope</code>, or a custom coroutine scope.</p>
			<h3>Test scopes</h3>
			<p>Kotlin<a id="_idIndexMarker095"/> has a <code>kotlinx-coroutines-test</code> library for testing coroutines. This testing library includes a special coroutine scope that you can use to create tests for your coroutines. You will learn more about testing coroutines in <a href="B17773_04_Epub.xhtml#_idTextAnchor051"><em class="italic">Chapter 4</em></a>, <em class="italic">Testing Kotlin Coroutines</em>.</p>
			<p>In this section, you learned about <code>CoroutineScope</code>, as well as about <code>MainScope</code> and creating coroutine scopes with the <code>CoroutineScope</code> function. You also learned about built-in scopes such as <code>viewModelScope</code> and <code>lifecycleScope</code>. </p>
			<p>In the next section, you will learn about coroutine dispatchers.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor036"/>Coroutine dispatchers</h2>
			<p>Coroutines have a <a id="_idIndexMarker096"/>context, which includes the coroutine dispatcher. Dispatchers specify what thread the coroutine will use to perform the task. The following dispatchers can be used:</p>
			<ul>
				<li><code>Dispatchers.Main</code>: This<a id="_idIndexMarker097"/> is used to run on Android’s main thread, usually for updates to the user interface. A special version of <code>Dispatchers.Main</code>, called <code>Dispatchers.Main.immediate</code>, is used to immediately execute the coroutine in the main thread. The <code>viewModelScope</code> and <code>lifecycleScope</code> coroutine scopes use <code>Dispatchers.Main.immediate</code> by default. </li>
				<li><code>Dispatchers.IO</code>: This<a id="_idIndexMarker098"/> is designed for networking operations, and for reading from or writing to files or databases.</li>
				<li><code>Dispatchers.Default</code>: This is <a id="_idIndexMarker099"/>used for CPU-intensive work, such as complicated computations or processing text, images, or videos. If you don’t set a dispatcher, <code>Dispatchers.Default</code> will be chosen by default.</li>
				<li><code>Dispatchers.Unconfined</code>: This<a id="_idIndexMarker100"/> is a special dispatcher that is not confined to any specific threads. It executes the coroutine in the current thread and resumes it in whatever thread that is used by the suspending function.</li>
			</ul>
			<p>You can set <a id="_idIndexMarker101"/>the dispatchers when setting the context in <code>CoroutineScope</code> or when using coroutine builders.</p>
			<p>When using <code>MainScope</code> as the coroutine scope for your coroutine, <code>Dispatchers.Main</code> is used by default:</p>
			<pre class="source-code">MainScope().launch { ... }</pre>
			<p>This coroutine will automatically use <code>Dispatchers.Main</code> so that you no longer need to specify it.</p>
			<p>If you used a different coroutine scope, you can pass in the dispatcher that will be used by the coroutine:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO).launch {</pre>
			<pre class="source-code">    fetchMovies()</pre>
			<pre class="source-code">}</pre>
			<p>The preceding code creates a <code>CoroutineScope</code> that will be run using <code>Dispatchers.IO</code> for the dispatcher.</p>
			<p>You can also pass in a dispatcher when using the <code>launch</code> and <code>async</code> coroutine builders:</p>
			<pre class="source-code">viewModelScope.launch(Dispatchers.Default) { ... }</pre>
			<p>This will launch a coroutine using the <code>Dispatchers.Default</code> dispatcher.</p>
			<p>To change the context of your coroutine, you can use the <code>withContext</code> function for the code that you want to use a different thread with. For example, in your suspending function, <code>getMovies</code>, which gets movies from your endpoint, you can use <code>Dispatchers.IO</code>:</p>
			<pre class="source-code">suspend fun getMovies(): List&lt;Movies&gt;  {</pre>
			<pre class="source-code">    withContext(Dispatchers.IO) { ... }</pre>
			<pre class="source-code">}</pre>
			<p>In the <a id="_idIndexMarker102"/>preceding code, the <code>getMovies</code> function uses <code>Dispatchers.IO</code> to fetch the list of movies from a network endpoint.</p>
			<p>In this section, you learned what dispatchers are and what dispatchers you can use, depending on your needs. You also learned how to use <code>withContext</code> to change the specific thread the coroutine runs on.</p>
			<p>In the next section, you will explore coroutine contexts and jobs.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor037"/>Understanding coroutine contexts and jobs</h1>
			<p>In this section, you will learn about coroutine contexts and jobs. Coroutines run in a coroutine context. A job is the context of the coroutine that allows you to manage the coroutine’s execution.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor038"/>Coroutine contexts</h2>
			<p>Each coroutine<a id="_idIndexMarker103"/> runs in a coroutine context. A coroutine context is a collection of elements for the coroutines that specifies how the coroutine should run. A coroutine scope has a default coroutine context; if it’s empty, it will have an <code>EmptyCoroutineContext</code>.</p>
			<p>When you create a <code>CoroutineScope</code> or use a coroutine builder, you can pass in a <code>CoroutineContext</code>. In the previous examples, we were passing a dispatcher:</p>
			<pre class="source-code">CoroutineScope(Dispatchers.IO) {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">viewModelScope.launch(Dispatchers.Default) { ... }</pre>
			<p>The preceding example shows how to pass a dispatcher in the <code>CoroutineScope</code> function or in the coroutine builder.</p>
			<p>What you’re<a id="_idIndexMarker104"/> passing in these functions is a <code>CoroutineContext</code>. The following are some of the <code>CoroutineContext</code> elements<a id="_idIndexMarker105"/> you can use:</p>
			<ul>
				<li><code>CoroutineDispatcher</code></li>
				<li><code>Job</code></li>
				<li><code>CoroutineName</code></li>
				<li><code>CoroutineExceptionHandler</code></li>
			</ul>
			<p>The main <code>CoroutineContext</code> elements are dispatchers and jobs. Dispatchers specify the thread where the coroutine runs, while the job of the coroutine allows you to manage the coroutine’s task.</p>
			<p>Jobs allow you to manage the life cycle of the coroutine, from the creation of the coroutine to the completion of the task. You can use this job to cancel the coroutine itself. You’ll learn more about coroutine cancelations in <a href="B17773_03_Epub.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling Coroutines Cancelations and Exceptions</em>.</p>
			<p><code>CoroutineName</code> is<a id="_idIndexMarker106"/> another <code>CoroutineContext</code> you can use to set a string to name a coroutine. This name can be useful for debugging purposes. For example, you can add a <code>CoroutineName</code> using the following code:</p>
			<pre class="source-code">val scope = CoroutineScope(Dispatchers.IO)</pre>
			<pre class="source-code">scope.launch(CoroutineName("IOCoroutine")) {</pre>
			<pre class="source-code">    performTask()</pre>
			<pre class="source-code">}</pre>
			<p>This will give the name of <code>IOCoroutine</code> to the coroutine that was launched using the <code>Dispatchers.IO</code> dispatcher.</p>
			<p>As the coroutine context is a collection of elements for the coroutine, you can use operators such as the <code>+</code> symbol to combine context elements to create a new <code>CoroutineContext</code>:</p>
			<pre class="source-code">val context = Dispatchers.Main + Job()</pre>
			<p><code>MainScope</code>, <code>viewModelScope</code>, and <code>lifecycleScope</code>, for example, use something like the following for the coroutine scope’s context:</p>
			<pre class="source-code">SupervisorJob() + Dispatchers.Main.immediate</pre>
			<p>Another <a id="_idIndexMarker107"/>coroutine context element you can use is <code>CoroutineExceptionHandler</code>, an <a id="_idIndexMarker108"/>element you can use to handle exceptions. You will learn more about <code>CoroutineExceptionHandler</code> in <a href="B17773_03_Epub.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling Coroutines Cancelations and Exceptions</em>.</p>
			<p>In the previous section, you used the <code>withContext</code> function to change the dispatcher to specify a different thread to run your coroutine. As the name implies, this changes the coroutine context with the dispatcher, which is a <code>CoroutineContext</code> element itself:</p>
			<pre class="source-code">withContext(Dispatchers.IO) { ... }</pre>
			<p>This changes the coroutine context with a new dispatcher, <code>Dispatchers.IO</code>.</p>
			<p>In the next section, you will learn about jobs.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>Coroutine jobs</h2>
			<p>A <code>ContextCoroutine</code> element <a id="_idIndexMarker110"/>that you can use for the coroutine context. You can use jobs to manage the coroutine’s tasks and its life cycle. Jobs can be canceled or joined together.</p>
			<p>The <code>launch</code> coroutine builder creates a new job, while the <code>async</code> coroutine builder returns a <code>Deferred&lt;T&gt;</code> object. <code>Deferred</code> is itself a <code>Job</code> object – that is, a job that has a result.</p>
			<p>To access the job from the coroutine, you can set it to a variable:</p>
			<pre class="source-code">val job = viewModelScope.launch(Dispatchers.IO) { ... }</pre>
			<p>The <code>launch</code> coroutine builder creates a coroutine running in the <code>Dispatchers.IO</code> thread and returns a job. A job can have children jobs, making it a parent job. <code>Job</code> has a <code>children</code> property you can use to get the job’s children:</p>
			<pre class="source-code">val job1 = viewModelScope.launch(Dispatchers.IO) { </pre>
			<pre class="source-code">    val movies = fetchMovies()</pre>
			<pre class="source-code">    val job2 = launch {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <code>job2</code> becomes a child of <code>job1</code>, which is the parent. This means that <code>job2</code> will inherit the coroutine context of the parent, though you can also change it.</p>
			<p>If a parent job is <a id="_idIndexMarker111"/>canceled or failed, its children are also automatically canceled. When a child’s job is canceled or failed, its parent will also be canceled. </p>
			<p>A <code>SupervisorJob</code> is a special version of a job that allows its children to fail independently of each other. </p>
			<p>Using a job also allows you to create a coroutine that you can later start instead of immediately running by default. To do this, you must use <code>CoroutineStart.LAZY</code> as the value of the <code>start</code> parameter in your coroutine builder and assign the result to a <code>Job</code> variable. Later, you can then use the <code>start()</code> function to run the coroutine, as shown here:</p>
			<pre class="source-code">val lazyJob = viewModelScope.launch (start=CoroutineStart.LAZY) {</pre>
			<pre class="source-code">    delay(1_000)</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">lazyJob.start()</pre>
			<p>This will create a lazy coroutine. When you are ready to start it, you can simply call <code>lazyJob.start()</code>.</p>
			<p>With the <code>Job</code> object, you can also use the <code>join()</code> suspending function to wait for the job to be completed before continuing with another job or task:</p>
			<pre class="source-code">viewModelScope.launch {</pre>
			<pre class="source-code">    val job1 = launch {</pre>
			<pre class="source-code">        showProgressBar()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    job1.join()</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    val job2 = launch {</pre>
			<pre class="source-code">        fetchMovies()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this <a id="_idIndexMarker112"/>example, <code>job1</code> will be run first and <code>job2</code> won’t be executed until the former job (<code>job1</code>) has finished.</p>
			<p>In the next section, you will learn more about the states of coroutine jobs.</p>
			<h3>Coroutine job states</h3>
			<p>A job has<a id="_idIndexMarker113"/> the following states:</p>
			<ul>
				<li>New</li>
				<li>Active</li>
				<li>Completing</li>
				<li>Completed</li>
				<li>Canceling</li>
				<li>Canceled</li>
			</ul>
			<p>These states of a job and its life cycle are summarized in the following diagram:</p>
			<div><div><img src="img/Figure_2.03_B17773.jpg" alt="Figure 2.3 – Coroutine job life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Coroutine job life cycle</p>
			<p>When you start a <a id="_idIndexMarker114"/>coroutine, a job is<a id="_idIndexMarker115"/> created in the <code>start()</code> or <code>join()</code> function. The job is in the <strong class="bold">Active</strong> state <a id="_idIndexMarker116"/>while the job is running. </p>
			<p>Completing a job moves it into<a id="_idIndexMarker117"/> the <strong class="bold">Completing</strong> state and then into<a id="_idIndexMarker118"/> the <strong class="bold">Completed</strong> state once its children complete their tasks.</p>
			<p>If a job is canceled manually or failed because of an exception, it will go into the <strong class="bold">Canceling</strong> state and<a id="_idIndexMarker119"/> then into<a id="_idIndexMarker120"/> the <strong class="bold">Canceled</strong> state once its children complete.</p>
			<p>A <code>Job</code> object has three properties you can use to check the state of the job:</p>
			<ul>
				<li><code>isActive</code>: This property<a id="_idIndexMarker121"/> is <code>true</code> when the job is running or completing, and <code>false</code> otherwise.</li>
				<li><code>isComplete</code>: This <a id="_idIndexMarker122"/>property is <code>true</code> when the job has finished its task (canceled or completed), and <code>false</code> otherwise.</li>
				<li><code>isCancelled</code>: This <a id="_idIndexMarker123"/>property is <code>true</code> if the job has been canceled or is being canceled, manually or because of an exception, and <code>false</code> otherwise.</li>
			</ul>
			<p>You will learn more about jobs and how they are used to cancel coroutines in <a href="B17773_03_Epub.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling Coroutines Cancelations and Exceptions</em>.</p>
			<p>In this section, you learned about coroutine contexts and jobs. <code>CoroutineContext</code> is a collection of coroutine context elements for the coroutines that specifies how the coroutine should run. Examples of <code>CoroutineContext</code> elements are dispatchers and jobs. A job is created from a coroutine. You can use it to manage the coroutine’s tasks and life cycle.</p>
			<p>Now, you will use what you have learned so far to add coroutines to an Android project.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor040"/>Exercise – using coroutines in an Android app</h1>
			<p>In this exercise, you <a id="_idIndexMarker124"/>will be working with an application that displays movies that are playing now in cinemas. You will be using The Movie Database API version 3 to get the list of movies. Go to <a href="https://developers.themoviedb.org/3">https://developers.themoviedb.org/3</a> and <a id="_idIndexMarker125"/>register for an API key. Once you’ve done that, follow these steps:</p>
			<ol>
				<li>Open the <code>Movie App</code> project in the <code>Chapter02</code> directory in this book’s code repository.</li>
				<li>Open <code>MovieRepository</code> and update <code>apiKey</code> with the value from The Movie Database API:<pre>private val apiKey = "your_api_key_here" </pre></li>
				<li>Open the <code>app/build.gradle</code> file and add a dependency for <code>kotlinx-coroutines-android</code>:<pre>implementation ‘org.jetbrains.kotlinx:kotlinx-
  coroutines-android:1.6.0’</pre></li>
			</ol>
			<p>This will add the <code>kotlinx-coroutines-core</code> and <code>kotlinx-coroutines-android</code> libraries to your project, allowing you to use coroutines in your code. </p>
			<ol>
				<li value="4">Also, add <a id="_idIndexMarker126"/>the dependencies for the <code>ViewModel</code> extension library:<pre>implementation ‘androidx.lifecycle:lifecycle-
  viewmodel-ktx:2.4.1’</pre></li>
			</ol>
			<p>This will add the <code>ViewModel</code> KTX library to your project. It includes a <code>viewModelScope</code> for <code>ViewModel</code>. </p>
			<ol>
				<li value="5">Open the <code>MovieViewModel</code> class, navigate to the <code>fetchMovies</code> function, and add the following code:<pre>fun fetchMovies() {
    _loading.value = true
    viewModelScope.launch(Dispatchers.IO) {
    }
}</pre></li>
			</ol>
			<p>This will create a coroutine that will run in <code>Dispatchers.IO</code> (on a background thread for network operations). The coroutine will be launched using <code>viewModelScope</code>.</p>
			<ol>
				<li value="6">In the <code>fetchMovies</code> coroutine, call the MovieRepository’s <code>fetchMovies</code> function to fetch the list of movies from The Movie Database API:<pre>fun fetchMovies() {
    _loading.value = true
    viewModelScope.launch(Dispatchers.IO) {
        movieRepository.fetchMovies()
        _loading.postValue(false)
    }
}</pre></li>
			</ol>
			<p>The coroutine will be launched and will call the <code>fetchMovies</code> function from <code>MovieRepository</code>.</p>
			<ol>
				<li value="7">Run the<a id="_idIndexMarker127"/> application. You will see that the app displays a list of movies (with a poster and a title), as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.04_B17773.jpg" alt="Figure 2.4 –The app displaying a list of movies&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 –The app displaying a list of movies</p>
			<p>In this exercise, you created a coroutine using the ViewModel’s <code>viewModelScope</code>, used the <code>launch</code> coroutine <a id="_idIndexMarker128"/>builder, and executed a task to fetch the movies from the repository.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor041"/>Summary</h1>
			<p>In this chapter, you learned more about Kotlin coroutines and how you can use them for asynchronous programming in Android.</p>
			<p>You learned how to create coroutines with coroutine builders such as <code>launch</code>, <code>async</code>, and <code>runBlocking</code>. Then, you learned about dispatchers and using them to set the thread that the coroutines run on. You also learned about coroutine scopes and built-in scopes such as <code>viewModelScope</code> and <code>lifecycleScope</code>.</p>
			<p>After that, you learned about coroutine contexts and jobs. <code>CoroutineContext</code> is the context for the coroutine and includes elements such as dispatchers that the coroutine will run on and a job, which you can use to manage the coroutine’s task.</p>
			<p>Finally, you completed an exercise where you added a coroutine to an Android project. You used the ViewModel’s <code>viewModelScope</code> for the coroutine scope, the <code>launch</code> coroutine builder, and implemented the coroutine to fetch the list of movies using <code>Dispatchers.IO</code>.</p>
			<p>In the next chapter, you will learn how to handle coroutine cancelations, timeouts, and exceptions.</p>
		</div>
	</body></html>