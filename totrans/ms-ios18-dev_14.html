<html><head></head><body>
		<div><h1 id="_idParaDest-258" class="chapter-number"><a id="_idTextAnchor430"/><st c="0">14</st></h1>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor431"/><st c="3">Improving the App Quality with Swift Testing</st></h1>
			<p><st c="48">Why is testing part of a coding book? </st><st c="87">Isn’t testing part of the </st><strong class="bold"><st c="113">Quality Assurance</st></strong><st c="130"> (</st><strong class="bold"><st c="132">QA</st></strong><st c="134">) </st><st c="137">team’s remit?</st></p>
			<p><st c="150">You will soon discover that testing is part of our development cycle and our culture as iOS developers. </st><st c="255">Many developers see testing as an essential task that they don’t have time for. </st><st c="335">Unfortunately, they pay the price later with bugs and </st><st c="389">long refactors.</st></p>
			<p><st c="404">In this chapter, we will do </st><st c="433">the following:</st></p>
			<ul>
				<li><st c="447">Understand the importance </st><st c="474">of testing</st></li>
				<li><st c="484">Learn the testing history </st><st c="511">of Xcode</st></li>
				<li><st c="519">Explore the Swift Testing </st><st c="546">framework basics</st></li>
				<li><st c="562">Understand how to manage tests with suites, test plans, </st><st c="619">and </st><em class="italic"><st c="623">Schemes</st></em></li>
				<li><st c="630">Learn tips that can help us maintain </st><st c="668">our tests</st></li>
			</ul>
			<p><st c="677">By the end of this chapter, you will be ready to leverage your testing skills with </st><st c="761">Swift Testing.</st></p>
			<p><st c="775">Before we answer the </st><em class="italic"><st c="797">how</st></em><st c="800"> question, let’s start with </st><st c="828">the </st><em class="italic"><st c="832">why</st></em><st c="835">.</st></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor432"/><st c="836">Technical requirements</st></h1>
			<p><st c="859">You must download Xcode version 16.0 or above for this chapter from Apple’s </st><st c="936">App Store.</st></p>
			<p><st c="946">You’ll also need to run the latest version of macOS (Ventura or above). </st><st c="1019">Search for </st><code><st c="1030">Xcode</st></code><st c="1035"> in the App Store, and select and download the latest version. </st><st c="1098">Launch Xcode, and follow any additional installation instructions that your system may prompt you with. </st><st c="1202">Once Xcode has fully launched, you’re ready </st><st c="1246">to go.</st></p>
			<p><st c="1252">This chapter includes many code examples, some of which can be found in the following GitHub </st><st c="1346">repository: </st><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter14"><st c="1358">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter14</st></a></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor433"/><st c="1441">Understanding the importance of testing</st></h1>
			<p><st c="1481">For many developers, testing</st><a id="_idIndexMarker869"/><st c="1510"> is an unnecessary overhead they must deal with when </st><st c="1563">writing code.</st></p>
			<p><st c="1576">This way of thinking is somehow understandable. </st><st c="1625">We’ve finished writing our code, built an application, and seen that everything runs as expected. </st><st c="1723">Instead of moving to our next task, we need to change the target, adding a test function just so we can see again that it works fine. </st><st c="1857">Why waste our time </st><st c="1876">on it?</st></p>
			<p><st c="1882">Also, in many cases, writing these test functions takes a lot of work. </st><st c="1954">How can we test a SwiftUI view or a network call? </st><st c="2004">What does it </st><st c="2017">even mean?</st></p>
			<p><st c="2027">These all summarize why testing is not a common practice, or at least </st><st c="2098">not enough.</st></p>
			<p><st c="2109">The root of this problem is how developers approach testing and writing code in general. </st><st c="2199">Testing is more than checking whether our functions run as expected; it’s about code structure, separation of concerns, the writing process, working culture, and how we treat our </st><st c="2378">day-to-day jobs.</st></p>
			<p><st c="2394">Let’s look at the </st><st c="2413">following function:</st><a id="_idTextAnchor434"/><a id="_idTextAnchor435"/></p>
			<pre class="source-code"><st c="2432">
func canUserAddTask(to list: List, user: User) -&gt; Bool {
    if list.isLocked {
        return false
    }
    if !list.allowedRoles.contains(user.role) {
        return false
    }
    return [.privateList,
      .publicList].contains(list.sharingAttribute)
}</st></pre>			<p><st c="2651">This function checks whether a user can add a task to a specific list based on criteria, such as permissions, list type, and status. </st><st c="2785">Now, imagine we need to ensure that this function works properly. </st><st c="2851">How can we do that? </st><st c="2871">Do we need to run our app in different states to see </st><st c="2924">the results?</st></p>
			<p><st c="2936">We all know that ensuring our code runs correctly is part of our development process. </st><st c="3023">This is a classic example of how writing test cases and running an app in different states can ease our development process. </st><st c="3148">We understand why testing is so important when adding future tasks</st><a id="_idIndexMarker870"/><st c="3214"> such as refactoring and </st><st c="3239">bug fixes.</st></p>
			<p><st c="3249">Before we delve into Swift Testing, let’s understand the testing history in </st><st c="3326">Apple platforms.</st></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor436"/><st c="3342">Learning the testing history in Apple platforms</st></h1>
			<p><st c="3390">As Apple development tools</st><a id="_idIndexMarker871"/><st c="3417"> evolved over the years, the testing tools</st><a id="_idIndexMarker872"/><st c="3459"> have </st><st c="3465">also developed.</st></p>
			<p><st c="3480">The first dedicated testing framework</st><a id="_idIndexMarker873"/><st c="3518"> for Apple platforms was </st><strong class="bold"><st c="3543">SenTestingKit</st></strong><st c="3556">, based on the OCUnit open </st><st c="3583">source framework.</st></p>
			<p><st c="3600">SenTestingKit was introduced in 2005 and integrated into Xcode, providing basic functionality for writing and running </st><st c="3719">Objective-C code.</st></p>
			<p><st c="3736">In 2013, Apple introduced </st><strong class="bold"><st c="3763">XCTest</st></strong><st c="3769">, which takes a more modern</st><a id="_idIndexMarker874"/><st c="3796"> approach to testing, with better Xcode integration and support for Objective-C </st><st c="3876">and Swift.</st></p>
			<p><st c="3886">Let’s take the code example in the </st><em class="italic"><st c="3922">Understanding the importance of testing</st></em><st c="3961"> section and see an example of an </st><st c="3995">XCTest test:</st></p>
			<pre class="source-code"><st c="4007">
class CanUserAddTaskTests: XCTestCase {
    func testCanAddTaskWhenListIsLocked() {
        let list = List(id: "1", isLocked: true,
          sharingAttribute: .privateList, allowedRoles:
          [.admin, .member])
        let user = User(role: .admin)
        XCTAssertFalse(canUserAddTask(to: list, user:
          user), "User should not be able to add a task
          when the list is locked")
    }
}</st></pre>			<p><st c="4345">In this user example, we see a simple</st><a id="_idIndexMarker875"/><st c="4383"> test function that tests whether a user can add a task to a </st><st c="4444">locked list.</st></p>
			<p><st c="4456">There are a few things </st><st c="4480">worth noting:</st></p>
			<ul>
				<li><st c="4493">The test function is part of the </st><code><st c="4527">CanUserAddTaskTests</st></code><st c="4546"> class, inherited from the </st><code><st c="4573">XCTestCase</st></code><st c="4583"> superclass.</st></li>
				<li><st c="4595">The test function name starts with the </st><code><st c="4635">test</st></code><st c="4639"> phrase. </st><st c="4648">The </st><code><st c="4652">test</st></code><st c="4656"> phrase indicates the XCTest framework, which is a </st><st c="4707">testing function.</st></li>
				<li><st c="4724">The test validation expression is done by a specific function (</st><code><st c="4788">XCTAssertFalse</st></code><st c="4803">) that checks whether a particular expression is </st><code><st c="4853">false</st></code><st c="4858">. We have a list of functions for </st><st c="4892">various conditions.</st></li>
			</ul>
			<p><st c="4911">While these are all part of how we write tests</st><a id="_idIndexMarker876"/><st c="4958"> in Xcode, they are not aligned with the modern Swift/SwiftUI approach – working with structs, macros, and more simple and generic Swift functions. </st><st c="5106">That’s where Swift Testing comes into </st><st c="5144">the picture.</st></p>
			<p><st c="5156">Let’s explore Swift </st><st c="5177">Testing together.</st></p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor437"/><st c="5194">Exploring the Swift Testing basics</st></h1>
			<p><st c="5229">We will start our journey</st><a id="_idIndexMarker877"/><st c="5255"> by adding the Swift Testing framework to an </st><st c="5300">existing project.</st></p>
			<p><st c="5317">Select </st><strong class="bold"><st c="5325">File</st></strong><st c="5329"> | </st><strong class="bold"><st c="5332">New</st></strong><st c="5335"> | </st><strong class="bold"><st c="5338">Target</st></strong><st c="5344"> from the Xcode’s menu to do that. </st><st c="5379">Then, in the template chooser, locate </st><strong class="bold"><st c="5417">Unit Testing Bundle</st></strong><st c="5436"> and select it (</st><em class="italic"><st c="5452">Figure 14</st></em><em class="italic"><st c="5462">.1</st></em><st c="5464">):</st></p>
			<div><div><img src="img/B21795_14_1.jpg" alt="Figure 14.1: The new target template chooser"/><st c="5467"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5636">Figure 14.1: The new target template chooser</st></p>
			<p><em class="italic"><st c="5680">Figure 14</st></em><em class="italic"><st c="5690">.1</st></em><st c="5692"> shows the template chooser window in Xcode. </st><st c="5737">When performing a search for testing, </st><strong class="bold"><st c="5775">Unit Testing Bundle</st></strong><st c="5794"> is easy to locate. </st><st c="5814">Note that we also have a </st><strong class="bold"><st c="5839">UI Testing Bundle</st></strong><st c="5856"> template. </st><st c="5867">However, UI testing isn’t supported yet in Swift Testing, so we’ll focus now on </st><st c="5947">unit testing.</st></p>
			<p class="callout-heading"><st c="5960">How can we perform UI testing?</st></p>
			<p class="callout"><st c="5991">UI testing, also known</st><a id="_idIndexMarker878"/><st c="6014"> as end-to-end testing, is a different</st><a id="_idIndexMarker879"/><st c="6052"> topic in app testing. </st><st c="6075">It is also what we call “black-box” testing, meaning that the test function doesn’t know the internal code, only the user interface components. </st><st c="6219">The basic way to conduct a UI test is to use XCTest, Apple’s previous testing framework. </st><st c="6308">However, there are services that provide simpler or multi-platform ways of running UI </st><st c="6394">tests remotely.</st></p>
			<p><st c="6409">Once you select the </st><strong class="bold"><st c="6430">Unit Testing Bundle</st></strong><st c="6449"> template, hit </st><strong class="bold"><st c="6464">Next</st></strong><st c="6468">. Now, we’ll need to fill in some details about our new test target (</st><em class="italic"><st c="6537">Figure 14</st></em><em class="italic"><st c="6547">.2</st></em><st c="6549">):</st></p>
			<div><div><img src="img/B21795_14_2.jpg" alt="Figure 14.2: Choosing options for our new test target"/><st c="6552"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="6806">Figure 14.2: Choosing options for our new test target</st></p>
			<p><st c="6859">In </st><em class="italic"><st c="6863">Figure 14</st></em><em class="italic"><st c="6872">.2</st></em><st c="6874">, we can fill in the target’s name, team, and bundle identifier. </st><st c="6939">We can also choose between the old XCTest and the new Swift Testing frameworks. </st><st c="7019">In this case, we’ll select </st><strong class="bold"><st c="7046">Swift Testing</st></strong><st c="7059">.</st></p>
			<p><st c="7060">Hit </st><strong class="bold"><st c="7065">Save</st></strong><st c="7069">, and congratulations – you have</st><a id="_idIndexMarker880"/><st c="7101"> a new </st><st c="7108">testing target!</st></p>
			<p><st c="7123">Let’s write our </st><st c="7140">first test!</st></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor438"/><st c="7151">Adding a basic test</st></h2>
			<p><st c="7171">Our template </st><a id="_idIndexMarker881"/><st c="7185">comes with a basic, empty </st><st c="7211">test function:</st></p>
			<pre class="source-code"><st c="7225">
import Testing
struct Chapter14Tests {
    @Test func testExample() async throws {
        // Write your test here and use APIs like
       `#expect(...)` to check expected conditions.
    </st><st c="7392">}
}</st></pre>			<p><st c="7395">Even though the code</st><a id="_idIndexMarker882"/><st c="7416"> is very minimal, we can see a couple of changes compared </st><st c="7474">to XCTest:</st></p>
			<ul>
				<li><code><st c="7545">Testing</st></code><st c="7552">, and we should import it into every file we want </st><st c="7602">to test.</st></li>
				<li><code><st c="7698">XCTestCase</st></code><st c="7708">, we work with structs in Swift Testing. </st><strong class="bold"><st c="7749">Structs</st></strong><st c="7756"> are not only lighter</st><a id="_idIndexMarker883"/><st c="7777"> and easier to use but also more helpful when we try to run our tests in parallel. </st><st c="7860">Remember that structs are value types, meaning that each time we pass a struct, we get a copy of the data. </st><st c="7967">This helps when trying to check states </st><st c="8006">when testing.</st></li>
				<li><code><st c="8031">@Test</st></code><code><st c="8081">@Test</st></code><st c="8086"> macro, which helps the SwiftData framework manage </st><st c="8137">its tests.</st></li>
				<li><code><st c="8159">#expect</st></code><code><st c="8197">XCTAssert</st></code><st c="8206"> functions, we use the </st><code><st c="8229">#expect</st></code><st c="8236"> macro, which is helpful for any expression we want </st><st c="8288">to test.</st></li>
			</ul>
			<p><st c="8296">We can run our test quickly by tapping the diamond button next to the test function</st><a id="_idTextAnchor439"/><a id="_idTextAnchor440"/><st c="8380"> or pressing </st><em class="italic"><st c="8393">⌘</st></em><em class="italic"><st c="8394">U</st></em><st c="8395">. If everything works as expected, our test </st><st c="8439">should pass.</st></p>
			<p><st c="8451">Now, let’s fill our code with some actual tests. </st><st c="8501">In our example, we have a view model that handles a counter. </st><st c="8562">We have </st><code><st c="8570">increment</st></code><st c="8579"> and </st><code><st c="8584">decrement</st></code><st c="8593"> functions and a </st><code><st c="8610">count</st></code><st c="8615"> variable:</st></p>
			<pre class="source-code"><st c="8625">
class CounterViewModel: ObservableObject {
    @Published var count: Int = 0
    func increment(by value: Int) { }
    func decrement(by value: Int) {}
    func reset() {}
}</st></pre>			<p><st c="8783">Let’s test the </st><code><st c="8799">CounterViewModel</st></code><st c="8815"> functionality using </st><st c="8836">Swift Testing.</st></p>
			<p><st c="8850">The first thing we need to do is provide Swift Testing with access to our </st><st c="8925">app target:</st></p>
			<pre class="console"><st c="8936">
@testable import Chapter14</st></pre>			<p><st c="8963">We add the </st><code><st c="8975">@testable</st></code><st c="8984"> attribute to the </st><code><st c="9002">import</st></code><st c="9008"> command to enable access to </st><st c="9037">internal entities.</st></p>
			<p><st c="9055">Now, let’s write our first </st><st c="9083">test</st><a id="_idIndexMarker884"/><st c="9087"> function:</st></p>
			<pre class="source-code"><st c="9097">
    @Test func testViewModelIncrement() async throws {
//         preparation
        let viewmodel = CounterViewModel()
        viewmodel.count = 5
//        execution
        viewmodel.increment(by: 1)
//        verification
        #expect(viewmodel.count == 6)
    }</st></pre>			<p><st c="9306">In our test function, we initialize the view model, call its increment function, and verify the results. </st><st c="9412">The test fails if the expression inside the </st><code><st c="9456">#expect</st></code><st c="9463"> macro function </st><st c="9479">is </st><code><st c="9482">false</st></code><st c="9487">.</st></p>
			<p><st c="9488">These three stages – preparation, execution, and verification – are part of any test flow, regardless of whether we use Swift Testing or any other </st><st c="9636">testing framework.</st></p>
			<p><st c="9654">Now, let’s rename our struct (which contains this test) </st><code><st c="9711">CounterViewModelTests</st></code><st c="9732"> and run </st><st c="9741">our test.</st></p>
			<p><st c="9750">In Xcode, we can open the left pane on its tab (or just press </st><em class="italic"><st c="9813">⌘</st></em><em class="italic"><st c="9814">6</st></em><st c="9815">), and then we can see our test list (</st><em class="italic"><st c="9853">Figure 14</st></em><em class="italic"><st c="9863">.3</st></em><st c="9865">):</st></p>
			<div><div><img src="img/B21795_14_3.jpg" alt="Figure 14.3: The tests listed in Xcode"/><st c="9868"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10513">Figure 14.3: The tests listed in Xcode</st></p>
			<p><st c="10551">In </st><em class="italic"><st c="10555">Figure 14</st></em><em class="italic"><st c="10564">.3</st></em><st c="10566">, we can see the structure of our tests on the testing pane, which is reflected in the way we create our struct and </st><st c="10682">tes</st><a id="_idTextAnchor441"/><a id="_idTextAnchor442"/><st c="10685">t functions.</st></p>
			<p><st c="10698">At the beginning of this chapter, we discussed the differences between Swift Testing and Xcode by examining a simple code example. </st><st c="10830">One of these changes was the usage of the </st><code><st c="10872">@</st></code><code><st c="10873">Test</st></code><st c="10877"> macro.</st></p>
			<p><st c="10884">Besides indicating a test</st><a id="_idIndexMarker885"/><st c="10910"> function, the </st><code><st c="10925">@Test</st></code><st c="10930"> macro has additional features to help us configure </st><st c="10982">our tests.</st></p>
			<p><st c="10992">For example, let’s use the </st><code><st c="11020">@Test</st></code><st c="11025"> macro to provide a name to our </st><st c="11057">test function.</st></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor443"/><st c="11071">Providing names to our test functions</st></h2>
			<p><st c="11109">Providing expressive and meaningful</st><a id="_idIndexMarker886"/><st c="11145"> names to test functions </st><a id="_idIndexMarker887"/><st c="11170">is crucial and can be valuable when we have hundreds of tests in </st><st c="11235">our project.</st></p>
			<p><st c="11247">To do this in XCTest, we need to rename the test function to something </st><st c="11319">like this:</st></p>
			<pre class="source-code"><st c="11329">
func testViewModelIncremenetFunction_incrementBy1_accept5_expect6</st></pre>			<p><st c="11395">The function name describes the test correctly, but it feels cumbersome and awkward, especially when we have hundreds of </st><st c="11517">test functions.</st></p>
			<p><st c="11532">With the </st><code><st c="11542">@Test</st></code><st c="11547"> Swift macro, we can provide a readable name for </st><st c="11596">each test:</st></p>
			<pre class="source-code"><st c="11606">
@Test("Test the increment function. </st><st c="11643">Accepts 5 and expect 6. </st><st c="11667">") func testViewModelIncrement()</st></pre>			<p><st c="11699">Adding the test description to the </st><code><st c="11735">@Test</st></code><st c="11740"> Swift macro makes it much more readable, and it also integrates nicely with Xcode (</st><em class="italic"><st c="11824">Figure 14</st></em><em class="italic"><st c="11834">.4</st></em><st c="11836">):</st></p>
			<div><div><img src="img/B21795_14_4.jpg" alt="Figure 14.4: The test pane in Xcode, with a custom name"/><st c="11839"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11983">Figure 14.4: The test pane in Xcode, with a custom name</st></p>
			<p><em class="italic"><st c="12038">Figure 14</st></em><em class="italic"><st c="12048">.4</st></em><st c="12050"> shows the same test function as before, now with a readable and </st><st c="12115">meaningful name.</st></p>
			<p><st c="12131">The </st><code><st c="12136">@Test</st></code><st c="12141"> Swift macro provides much more than just naming our functions. </st><st c="12205">We can also use it to disable and enable tests. </st><st c="12253">Let’s see how to </st><st c="12270">do that.</st></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor444"/><st c="12278">Enabling and disabling tests</st></h2>
			<p><st c="12307">Sometimes, a test can become</st><a id="_idIndexMarker888"/><st c="12336"> irrelevant, and we want to remove it from our test list temporarily. </st><st c="12406">We can delete it or comment on it. </st><st c="12441">However, these solutions may need to be more comfortable and practical in the long run. </st><st c="12529">So, let’s use the </st><code><st c="12547">@Test</st></code><st c="12552"> macro to make that </st><st c="12572">more elegant.</st></p>
			<p><st c="12585">In Swift Testing, all tests are enabled by default. </st><st c="12638">To disable a specific test, we can use the </st><code><st c="12681">disabled()</st></code><st c="12691"> function:</st></p>
			<pre class="source-code"><st c="12701">
@Test("Test the incremenet function. </st><st c="12739">Accepts 5 and expect 6. </st><st c="12763">", .disabled()) func testViewModelIncrement()</st></pre>			<p><st c="12808">We can see that the </st><code><st c="12829">disabled()</st></code><st c="12839"> function is now one of the </st><code><st c="12867">@Test</st></code><st c="12872"> parameters. </st><st c="12885">In this case, the test function won’t run, and we can also see that the function is now disabled in the test pane (</st><em class="italic"><st c="13000">Figure 14</st></em><em class="italic"><st c="13010">.5</st></em><st c="13012">):</st></p>
			<div><div><img src="img/B21795_14_5.jpg" alt="Figure 14.5: A disabled test in the test pane"/><st c="13015"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13159">Figure 14.5: A disabled test in the test pane</st></p>
			<p><em class="italic"><st c="13204">Figure 14</st></em><em class="italic"><st c="13214">.5</st></em><st c="13216"> shows our test function grayed out. </st><st c="13253">In this case, performing an entire test run will skip </st><st c="13307">that test.</st></p>
			<p><st c="13317">However, there are cases where we need our test function to run only under specific conditions, such as when a user is logged in or in one particular A/B </st><st c="13472">test condition.</st></p>
			<p><st c="13487">In this case, we will implement the condition within the test function as a guard statement, which makes the test function succeed. </st><st c="13620">But that doesn’t sound like a good solution – having a test function succeed when it’s </st><st c="13707">not running.</st></p>
			<p><st c="13719">Fortunately, enabling a test function based on specific criteria is a feature Swift Testing supports. </st><st c="13822">All we need to do is add the enabled function within the </st><code><st c="13879">@Test</st></code><st c="13884"> macro head, including a </st><st c="13909">Boolean expression:</st></p>
			<pre class="source-code"><st c="13928">
@Test("Test the decrement function.", .</st><code><st c="14110">testTheDecrementFunction</st></code><st c="14134">. We added a condition to the test function that would run only if we enabled the ability to decrement in the app settings. </st><st c="14258">In this case, the </st><code><st c="14276">AppSettings.CanDecrement</st></code><st c="14300"> expression returns </st><code><st c="14320">false</st></code><st c="14325">. Therefore, Swift Testing skips the test functi</st><a id="_idTextAnchor445"/><a id="_idTextAnchor446"/><st c="14373">on </st><st c="14377">at runtime.</st></p>
			<p><st c="14388">When using the enabled function, precisely defining the test goal is essential. </st><st c="14469">For example, when using </st><code><st c="14493">AppSettings</st></code><st c="14504">, we may want to test the results of the decrement function when the feature is turned off. </st><st c="14596">We need to disable tests according to a Boolean expression only when it’s clear that the function is irrelevant under </st><st c="14714">specific conditions.</st></p>
			<p><st c="14734">If we try to run a test when the </st><code><st c="14768">enabled()</st></code><st c="14777"> function returns </st><code><st c="14795">false</st></code><st c="14800">, we’ll see something like </st><em class="italic"><st c="14827">Figure 14</st></em><em class="italic"><st c="14836">.6</st></em><st c="14838">:</st></p>
			<div><div><img src="img/B21795_14_6.jpg" alt="Figure 14.6: A skipped test function due to a specific false condition"/><st c="14840"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15020">Figure 14.6: A skipped test function due to a specific false condition</st></p>
			<p><st c="15090">In </st><em class="italic"><st c="15094">Figure 14</st></em><em class="italic"><st c="15103">.6</st></em><st c="15105">, we can see that the test function is not grayed out, as in the case of using the </st><code><st c="15188">disabled()</st></code><st c="15198"> function. </st><st c="15209">However, it wasn’t running, and we can also see the skipped icon on </st><st c="15277">the right.</st></p>
			<p><st c="15287">We have seen how to provide readable names</st><a id="_idIndexMarker889"/><st c="15330"> to test functions and how to disable or enable tests. </st><st c="15385">Now, let’s discuss another excellent Swift Testing feature – </st><em class="italic"><st c="15446">tags</st></em><st c="15450">.</st></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor447"/><st c="15451">Tagging our test functions</st></h2>
			<p><st c="15478">Generally, we group tests</st><a id="_idIndexMarker890"/><st c="15504"> according to our project</st><a id="_idIndexMarker891"/><st c="15529"> structure. </st><st c="15541">For example, we could create a structure of test functions for a specific class or a structure. </st><st c="15637">Another example would be to create a test structure for a particular feature or service. </st><st c="15726">However, there are additional ways we can organize our test functions. </st><st c="15797">We could arrange them according to priority – critical or sanity tests – or according to their system levels, such as UI or business </st><st c="15930">logic layers.</st></p>
			<p><st c="15943">Instead of finding workarounds for that organization problem, Swift Testing</st><a id="_idIndexMarker892"/><st c="16019"> provides an organization feature </st><st c="16053">called </st><strong class="bold"><st c="16060">tags</st></strong><st c="16064">.</st></p>
			<p><st c="16065">We’ll start by defining a new tag in the </st><st c="16107">test bundle:</st></p>
			<pre class="source-code"><st c="16119">
extension Tag {
    @Tag static let critical: Self
}</st></pre>			<p><st c="16168">We extended the </st><code><st c="16185">Tag</st></code><st c="16188"> structure in this code and added a new static variable, </st><st c="16245">named </st><code><st c="16251">critical</st></code><st c="16259">.</st></p>
			<p><st c="16260">We can define and use as many</st><a id="_idIndexMarker893"/><st c="16290"> tags as we want across our bundle. </st><st c="16326">Therefore, it is a best practice</st><a id="_idIndexMarker894"/><st c="16358"> to manage all our tags in one place and a </st><st c="16401">separate file.</st></p>
			<p><st c="16415">Now that we have a new tag, let’s add it to one of </st><st c="16467">our tests:</st></p>
			<pre class="source-code"><st c="16477">
@Test("Test t</st><a id="_idTextAnchor448"/><a id="_idTextAnchor449"/><st c="16491">he reset function",</st><strong class="bold"><st c="16511"> .tags(.critical))</st></strong><st c="16528">
    func testResetFunction() {</st></pre>			<p><st c="16555">In this code example, another </st><code><st c="16586">@Test</st></code><st c="16591"> macro function, called </st><code><st c="16615">tags()</st></code><st c="16621">, provides the new </st><code><st c="16640">critical</st></code><st c="16648"> static variable we created in the previous </st><st c="16692">code example.</st></p>
			<p><st c="16705">Note that we can provide multiple tags to the same </st><st c="16757">test function:</st></p>
			<pre class="source-code"><st c="16771">
.tags(.critical, .calculations, .performance))</st></pre>			<p><st c="16817">In this example, we marked a specific function with three </st><st c="16876">different tags.</st></p>
			<p><st c="16891">The ability to mark a function with multiple tags can be powerful, as it provides flexibility with our </st><st c="16995">tests’ organization.</st></p>
			<p><st c="17015">One thing is missing here – even though tagging functions look lovely, we haven’t discussed how to actually use </st><st c="17128">our tagging.</st></p>
			<p><st c="17140">Let’s look at </st><em class="italic"><st c="17155">Figure 14</st></em><em class="italic"><st c="17164">.7</st></em><st c="17166">:</st></p>
			<div><div><img src="img/B21795_14_7.jpg" alt="Figure 14.7: The Tags section of the test pane in Xcode"/><st c="17168"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="17384">Figure 14.7: The Tags section of the test pane in Xcode</st></p>
			<p><em class="italic"><st c="17439">Figure 14</st></em><em class="italic"><st c="17449">.7</st></em><st c="17451"> shows a new section called </st><code><st c="17542">critical</st></code> <em class="italic"><st c="17550">tag</st></em><st c="17554"> we defined for our </st><code><st c="17574">reset()</st></code><st c="17581"> function in the last code example. </st><st c="17617">Xcode scans our tags’ usage and organizes them for us. </st><st c="17672">This is how deep the Swift Testing integration with </st><st c="17724">Xcode is.</st></p>
			<p><st c="17733">Now that we have all our tags</st><a id="_idIndexMarker895"/><st c="17763"> listed, we can run all our critical</st><a id="_idIndexMarker896"/><st c="17799"> tests (</st><em class="italic"><st c="17807">Figure 14</st></em><em class="italic"><st c="17817">.8</st></em><st c="17819">):</st></p>
			<div><div><img src="img/B21795_14_8.jpg" alt="Figure 14.8: Running all critical tests"/><st c="17822"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="17828">Figure 14.8: Running all critical tests</st></p>
			<p><st c="17867">In </st><em class="italic"><st c="17871">Figure 14</st></em><em class="italic"><st c="17880">.8</st></em><st c="17882">, the run button is on the right. </st><st c="17916">Tapping it will run all our critical </st><st c="17953">marked tests.</st></p>
			<p><st c="17966">Now, for the practical usage of tags in testing, working with tags is similar to how tagging works in other places. </st><st c="18083">When we group tests in files, we usually do that by </st><em class="italic"><st c="18135">concern</st></em><st c="18142"> – a layer, service, module, and so on. </st><st c="18182">Conversely, tagging helps us group tests by their </st><em class="italic"><st c="18232">types</st></em><st c="18237"> (sanity, smoke or regression, integration, or unit) or a </st><em class="italic"><st c="18295">property</st></em><st c="18303"> (a priority, </st><st c="18317">for example).</st></p>
			<p class="callout-heading"><st c="18330">What are smoke tests?</st></p>
			<p class="callout"><st c="18352">We write </st><strong class="bold"><st c="18362">smoke tests</st></strong><st c="18373"> to check a system’s operations</st><a id="_idIndexMarker897"/><st c="18404"> by testing basic functionality. </st><st c="18437">While they may sound like a sanity test, they are much lighter and faster than that. </st><st c="18522">For example, we can try to perform a login and a basic data sync, and the results can indicate</st><a id="_idIndexMarker898"/><st c="18616"> whether we have a severe problem with our app or </st><st c="18666">the backend.</st></p>
			<p><st c="18678">Working methodologically with the tagging system can enhance our testing and open </st><st c="18761">new possibilities.</st></p>
			<p><st c="18779">Our </st><code><st c="18784">@Test</st></code><st c="18789"> macro</st><a id="_idIndexMarker899"/><st c="18795"> features</st><a id="_idIndexMarker900"/><st c="18804"> list doesn’t end with tagging. </st><st c="18836">Let’s examine a Swift Testing feature that can save us a lot of time – </st><em class="italic"><st c="18907">arguments</st></em><st c="18916">.</st></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor450"/><st c="18917">Working with arguments</st></h2>
			<p><st c="18940">Imagine the following</st><a id="_idIndexMarker901"/><st c="18962"> scenario. </st><st c="18973">We wrote a Swift function</st><a id="_idIndexMarker902"/><st c="18998"> that performs a very clever calculation – for example, a function that converts meters </st><st c="19086">to yards:</st></p>
			<pre class="source-code"><st c="19095">
struct UnitConverter {
    static func metersToYards(_ meters: Double) -&gt; Double {
        return meters * 1.09361
    }
}</st></pre>			<p><st c="19202">Our function takes a </st><code><st c="19224">meters</st></code><st c="19230"> parameter and returns its value in yards. </st><st c="19273">It looks like a straightforward function, but we must perform several tests to see whether it works </st><st c="19373">as expected.</st></p>
			<p><st c="19385">So, let’s write tests for </st><st c="19412">this function:</st></p>
			<pre class="source-code"><st c="19426">
struct UnitConverterTests {
    @Test func testConvertingMetersToYards_1meter() {
        #expect(UnitConverter.metersToYards(1.0) ==
          1.09361)
    }
    @Test func testConvertingMetersToYards_3_5meter() {
        #expect(UnitConverter.metersToYards(3.5) ==
          3.827635)
    }
}</st></pre>			<p><st c="19669">In this code example, we wrote</st><a id="_idIndexMarker903"/><st c="19700"> two test functions that perform the same test but with different parameters. </st><st c="19778">They even have very similar names. </st><st c="19813">Even though this solution works fine, it doesn’t scale up very nicely. </st><st c="19884">What if we want to test 10 different</st><a id="_idIndexMarker904"/><st c="19920"> variants or parameters? </st><st c="19945">And what if we need to change the function name we </st><st c="19996">are testing?</st></p>
			<p><st c="20008">One option is to perform one test function that contains all of the </st><st c="20077">different options:</st></p>
			<pre class="source-code"><st c="20095">
@Test func testConvertingMetersToYards () {
      #expect(UnitConverter.metersToYards(1.0) == 1.09361)
      #expect(UnitConv</st><a id="_idTextAnchor451"/><a id="_idTextAnchor452"/><st c="20209">erter.metersToYards(3.5) == 3.827635)
    }</st></pre>			<p><st c="20249">We created one test function with two </st><code><st c="20288">#expect</st></code><st c="20295"> statements in this code example. </st><st c="20329">That will probably work; however, managing and monitoring them is more challenging now that we have both statements in </st><st c="20448">one function.</st></p>
			<p><st c="20461">To solve that, Swift Testing has a feature named </st><strong class="bold"><st c="20511">arguments</st></strong><st c="20520">, which allows us to run our tests with different </st><st c="20570">values repeatedly.</st></p>
			<p><st c="20588">Let’s see that </st><st c="20604">in action:</st></p>
			<pre class="source-code"><st c="20614">
@Test(</st><strong class="bold"><st c="20621">arguments</st></strong><st c="20631">: [(1.0, 1.09361), (3.5, 3.827635)])
    func testConvertingMetersToYards(data: </st><strong class="bold"><st c="20708">(Double,</st></strong>
<strong class="bold"><st c="20716">      Double)</st></strong><st c="20724">) {
        #expect(UnitConverter.metersToYards</st><strong class="bold"><st c="20764">(data.0) ==</st></strong>
<strong class="bold"><st c="20776">          data.1)</st></strong><st c="20784">
    }</st></pre>			<p><st c="20786">This code example may look a little cumbersome, but it is straightforward. </st><st c="20861">We performed three </st><st c="20880">changes here:</st></p>
			<ul>
				<li><st c="20893">We added the </st><code><st c="20907">arguments</st></code> <em class="italic"><st c="20916">parameter</st></em><st c="20926"> to the </st><code><st c="20934">@Test</st></code><st c="20939"> macro, which contains an array of tuples. </st><st c="20982">Each tuple represents a few meters and its corresponding number of yards. </st><st c="21056">For example, the </st><code><st c="21073">(1.0, 1.09361)</st></code><st c="21087"> tuple represents a conversion between 1 meter and 1.09361 yards. </st><st c="21153">This array is the list of test variants we are going </st><st c="21206">to do.</st></li>
				<li><st c="21212">We added a </st><em class="italic"><st c="21224">new tuple parameter called </st></em><code><st c="21251">data</st></code><em class="italic"><st c="21255"> to our test function</st></em><st c="21276">. With each test run, Swift Testing passes a tuple from the arguments list to the function using this parameter. </st><st c="21389">The parameter type must be aligned with the </st><st c="21433">argument type.</st></li>
				<li><st c="21447">In the </st><code><st c="21455">#expect</st></code><st c="21462"> macro, we now </st><em class="italic"><st c="21477">compare the two tuple values</st></em><st c="21505"> instead of fixed sizes, like in the </st><st c="21542">previous examples.</st></li>
			</ul>
			<p><st c="21560">The term </st><em class="italic"><st c="21570">arguments</st></em><st c="21579"> can be misleading. </st><st c="21599">In the context</st><a id="_idIndexMarker905"/><st c="21613"> of testing, it means</st><a id="_idIndexMarker906"/><st c="21634"> that arguments allow us to run our code in different use cases </st><st c="21698">and states.</st></p>
			<p><st c="21709">And if passing all the different use cases within the </st><code><st c="21764">@Test</st></code><st c="21769"> macro is cumbersome, we can store them in a </st><st c="21814">separate variable:</st></p>
			<pre class="source-code"><st c="21832">
let convertingTests: [(Double, Double)] = [(1.0, 1.09361),
                                           (3.5, 3.827635)]
struct UnitConverterTests {
    @Test(arguments: convertingTests)
    func testConvertingMetersToYards(data: (Double,
      Double)) {
        #expect(UnitConverter.metersToYards(data.0) ==
          data.1)
    }
}</st></pre>			<p><st c="22088">In this code example, we moved our use cases into a dedicated constant for </st><st c="22164">better readability.</st></p>
			<p><st c="22183">If we look at the Xcode testing pane again, we can now see a list of our use cases and their states (</st><em class="italic"><st c="22285">Figure 14</st></em><em class="italic"><st c="22295">.9</st></em><st c="22297">):</st></p>
			<div><div><img src="img/B21795_14_9.jpg" alt="Figure 14.9: Argument testing in the Xcode testing pane"/><st c="22300"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22519">Figure 14.9: Argument testing in the Xcode testing pane</st></p>
			<p><em class="italic"><st c="22574">Figure 14</st></em><em class="italic"><st c="22584">.9</st></em><st c="22586"> shows why argument testing in Swift Testing is so powerful. </st><st c="22647">Instead of having several test functions in the list, we can see one with several </st><st c="22729">use cases.</st></p>
			<p><st c="22739">Argument testing adds another</st><a id="_idIndexMarker907"/><st c="22769"> layer to our testing, something</st><a id="_idIndexMarker908"/><st c="22801"> we don’t have </st><st c="22816">in XCTest.</st></p>
			<p class="callout-heading"><st c="22826">Why doesn’t XCTest support parametrized testing?</st></p>
			<p class="callout"><st c="22875">Using attributes to perform parametrized</st><a id="_idIndexMarker909"/><st c="22916"> testing is not new in the testing world. </st><st c="22958">Most testing frameworks support adding arguments to their test functions out of the box. </st><st c="23047">However, even though it is possible to perform parametrized tests in XCTest, it requires creating several test functions that call a central function that performs the actual test. </st><st c="23228">This is an ad hoc and unnatural solution. </st><st c="23270">The reason is that Apple wanted to create a simple testing framework, and locating the test function</st><a id="_idIndexMarker910"/><st c="23370"> in XCTest works according to a simple function signature (functions that start with the phrase </st><code><st c="23466">test</st></code><st c="23470">). </st><st c="23474">Adding arguments made the locating </st><st c="23509">process complex.</st></p>
			<p><st c="23525">Now that we have reviewed the Swift Testing basics, let’s see how to manage </st><st c="23602">our tests.</st></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor453"/><st c="23612">Managing our tests</st></h1>
			<p><st c="23631">Anyone who has previously worked</st><a id="_idIndexMarker911"/><st c="23664"> with tests knows that writing tests is one thing and managing them in the long run </st><st c="23748">is another.</st></p>
			<p><st c="23759">If you don’t have testing experience, you might think that simply running all your tests one after the other is sufficient. </st><st c="23884">But down the road, things become much more complex – different configurations, environments, and even test goals – all translating to a need for a more robust testing </st><st c="24051">management system.</st></p>
			<p><st c="24069">Before managing our testing system, let’s review our Xcode </st><st c="24129">testing structure.</st></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor454"/><st c="24147">Going over the testing structure</st></h2>
			<p><st c="24180">So far, we have discussed</st><a id="_idIndexMarker912"/><st c="24206"> how to write testing functions, but besides grouping them in structures, we haven’t discussed anything related to </st><st c="24321">managing them.</st></p>
			<p><st c="24335">A whole set of tools can help us manage our test efficiency in Xcode. </st><st c="24406">Let’s review the different blocks that can help us adapt a flexible system to </st><st c="24484">our needs:</st></p>
			<ul>
				<li><strong class="bold"><st c="24494">A testing suite</st></strong><st c="24510">: A testing suite can group</st><a id="_idIndexMarker913"/><st c="24538"> several testing functions and </st><st c="24569">child suites.</st></li>
				<li><strong class="bold"><st c="24582">A test plan</st></strong><st c="24594">: A test plan groups different test </st><a id="_idIndexMarker914"/><st c="24631">functions and test suites. </st><st c="24658">It can include or exclude test functions marked with tags. </st><st c="24717">But it doesn’t stop there – test plans can run multiple times in different configurations with different data and environments. </st><st c="24845">This is a powerful tool that can help scale up our </st><st c="24896">testing strategy.</st></li>
				<li><strong class="bold"><st c="24913">A Scheme</st></strong><st c="24922">: Inside each </st><em class="italic"><st c="24937">Scheme</st></em><st c="24943">, we have several build options. </st><st c="24976">One is </st><strong class="bold"><st c="24983">Test</st></strong><st c="24987">, where we must describe what will happen when testing that specific </st><em class="italic"><st c="25056">Scheme</st></em><st c="25062">. In the </st><strong class="bold"><st c="25071">Test Build</st></strong><st c="25081"> option, we can define </st><a id="_idIndexMarker915"/><st c="25104">precisely what test plans we will run</st><a id="_idIndexMarker916"/><st c="25141"> and on </st><st c="25149">which target.</st></li>
			</ul>
			<p><st c="25162">When we look at the different testing building blocks, we can see that the testing structure is complex and requires </st><st c="25280">some thinking.</st></p>
			<p><st c="25294">Let’s try to explain the hierarchy by examining </st><em class="italic"><st c="25343">Figure 14</st></em><em class="italic"><st c="25352">.10</st></em><st c="25355">:</st></p>
			<div><div><img src="img/B21795_14_10.jpg" alt="Figure 14.10: Relations between the different building blocks of testing"/><st c="25357"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25501">Figure 14.10: Relations between the different building blocks of testing</st></p>
			<p><em class="italic"><st c="25573">Figure 14</st></em><em class="italic"><st c="25583">.10</st></em><st c="25586"> shows the relations between the different building blocks of testing. </st><st c="25657">Next, we will learn how to build them together, starting with </st><st c="25719">test suites.</st></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor455"/><st c="25731">Grouping our test functions into test suites</st></h2>
			<p><st c="25776">The first building block</st><a id="_idIndexMarker917"/><st c="25801"> we are going to discuss is the </st><strong class="bold"><st c="25833">test suite</st></strong><st c="25843">. In fact, we have already built a test suite in </st><st c="25892">this chapter:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="25905">struct UnitConverterTests</st></strong><st c="25931"> {
    @Test func testConvertingMetersToYards_1meter() {
        #expect(UnitConverter.metersToYards(1.0) ==
          1.09361)
    }
}</st></pre>			<p><st c="26040">Do you remember this code example? </st><st c="26076">We wrote it in the </st><em class="italic"><st c="26095">Working with arguments</st></em><st c="26117"> section and created a similar test suite for earlier examples. </st><st c="26181">So, yes, the struct containing our test functions is considered to be a test suite, and Swift Testing recognizes and displays this in the </st><st c="26319">test pane.</st></p>
			<p><st c="26329">However, we can annotate a test suite with the </st><code><st c="26377">@Suite</st></code><st c="26383"> attribute for better customization. </st><st c="26420">Let’s add it to our latest </st><st c="26447">test suite:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="26458">@Suite("Unit converter tests")</st></strong><st c="26489">
struct UnitConverterTests {
    @Test func testConvertingMetersToYards_1meter() {
        #expect(UnitConverter.metersToYards(1.0) ==
          1.09361}
}</st></pre>			<p><st c="26622">In this code example, we added</st><a id="_idIndexMarker918"/><st c="26653"> the </st><code><st c="26658">@Suite</st></code><st c="26664"> swift macro to our </st><code><st c="26684">UnitConverterTests</st></code><st c="26702"> structure and, by doing so, gave it a more </st><st c="26746">readable name.</st></p>
			<p><st c="26760">Let’s see what our test suite looks like in the test pane in Xcode (</st><em class="italic"><st c="26829">Figure 14</st></em><em class="italic"><st c="26839">.11</st></em><st c="26842">):</st></p>
			<div><div><img src="img/B21795_14_11.jpg" alt="Figure 14.11: The suite in the Xcode test pane"/><st c="26845"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="26971">Figure 14.11: The suite in the Xcode test pane</st></p>
			<p><st c="27017">In </st><em class="italic"><st c="27021">Figure 14</st></em><em class="italic"><st c="27030">.11</st></em><st c="27033">, we can see our new test suite displayed in the </st><st c="27082">test pane.</st></p>
			<p><st c="27092">If using the </st><code><st c="27106">@Suite</st></code><st c="27112"> macro sounds like how we used the </st><code><st c="27147">@Test</st></code><st c="27152"> macro, you are not mistaken; it’s the same idea – providing more information by using </st><st c="27239">a macro.</st></p>
			<p><st c="27247">And, just like the </st><code><st c="27267">@Test</st></code><st c="27272"> macro, we can also mark test suites </st><st c="27309">with tags:</st></p>
			<pre class="source-code"><st c="27319">
@Suite("Unit converter tests", .</st><strong class="bold"><st c="27352">tags(.critical)</st></strong><st c="27368">)
struct UnitConverterTests {
}</st></pre>			<p><st c="27400">In this code example, we marked our new test suite with the critical tag we declared in the </st><em class="italic"><st c="27493">Tagging our test </st></em><em class="italic"><st c="27510">functions</st></em><st c="27519"> section.</st></p>
			<p><st c="27528">In addition, we can also disable the whole test suite using the same </st><code><st c="27598">disabled()</st></code><st c="27608"> function we used in the </st><em class="italic"><st c="27633">Enabling and disabling </st></em><em class="italic"><st c="27656">tests</st></em><st c="27661"> section:</st></p>
			<pre class="source-code"><st c="27670">
@Suite("Unit converter tests", .</st><strong class="bold"><st c="27703">disabled()</st></strong><st c="27714">)
struct UnitConverterTests {
}</st></pre>			<p><st c="27746">In this code example, we disabled</st><a id="_idIndexMarker919"/><st c="27780"> the </st><code><st c="27785">Unit converter tests</st></code><st c="27805"> test suite, and Swift Test will not execute any of its tests in the next </st><st c="27879">test run.</st></p>
			<p><st c="27888">Another neat usage for a test suite is its ability to contain nested </st><st c="27958">test suites:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="27970">@Suite("Unit converter tests")</st></strong><st c="28001">
struct UnitConverterTests {
    </st><strong class="bold"><st c="28030">@Suite("From meters to yards")</st></strong><st c="28060">
    struct FromMetersToYardsTests {
    // our test functions
    }
}</st></pre>			<p><st c="28118">In this code example, we have a test suite named </st><code><st c="28168">From meters to yards</st></code><st c="28188">, which is part of a bigger test suite named </st><code><st c="28233">Unit </st></code><code><st c="28238">converter tests</st></code><st c="28253">.</st></p>
			<p><st c="28254">Let’s see how this is reflected in the Xcode pane (</st><em class="italic"><st c="28306">Figure 14</st></em><em class="italic"><st c="28316">.12</st></em><st c="28319">):</st></p>
			<div><div><img src="img/B21795_14_12.jpg" alt="Figure 14.12: Nested test suites in the test pane"/><st c="28322"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="28553">Figure 14.12: Nested test suites in the test pane</st></p>
			<p><em class="italic"><st c="28602">Figure 14</st></em><em class="italic"><st c="28612">.12</st></em><st c="28615"> shows how our new nested test suite is reflected in the test pane. </st><st c="28683">We can also customize the nested suites, such as adding tags and </st><st c="28748">disabling them.</st></p>
			<p><st c="28763">Now that we know how to define a test suite and tags, it is recommended that we remember each feature’s role. </st><st c="28874">We use test suites to group different test methods by concern – typically, by writing test functions for a specific class or </st><st c="28999">a structure.</st></p>
			<p><st c="29011">Conversely, we use tags to mark our tests</st><a id="_idIndexMarker920"/><st c="29053"> by their type – </st><code><st c="29070">critical</st></code><st c="29078">, </st><code><st c="29080">performance</st></code><st c="29091">, </st><code><st c="29093">integration</st></code><st c="29104">, and so on. </st><st c="29117">If these are the different roles for tags and test suites, what do we do when we want to manage something such as a sanity or a </st><st c="29245">regression test?</st></p>
			<p><st c="29261">That’s what </st><em class="italic"><st c="29274">test plans</st></em> <st c="29284">are for.</st></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor456"/><st c="29293">Building test plans</st></h2>
			<p><st c="29313">To better understand</st><a id="_idIndexMarker921"/><st c="29334"> the different testing components, we can think of an app with two layers – the business logic and the UI. </st><st c="29441">The business logic layer is important, but it doesn’t describe how a user will use our app – the different use cases </st><st c="29558">and flows.</st></p>
			<p><st c="29568">We must build the UI layer to complete our app, which handles user stories and flows. </st><st c="29655">The business logic is analogous to the different testing suites and functions. </st><st c="29734">These are the building blocks of our testing. </st><st c="29780">However, testing is always in the context of a specific </st><st c="29836">development process.</st></p>
			<p><st c="29856">Let’s try to come up with different</st><a id="_idIndexMarker922"/> <st c="29892">development processes:</st></p>
			<ul>
				<li><strong class="bold"><st c="29915">Feature development</st></strong><st c="29935">: We build new features, often adding new classes, structures, </st><st c="29999">and entities</st></li>
				<li><strong class="bold"><st c="30011">Fixing bugs</st></strong><st c="30023">: We modify </st><st c="30036">existing code</st></li>
				<li><strong class="bold"><st c="30049">Refactoring code</st></strong><st c="30066">: We modify existing code for better scalability, maintenance, </st><st c="30130">or performance</st></li>
				<li><strong class="bold"><st c="30144">Deployment</st></strong><st c="30155">: We prepare an app for deployment </st><a id="_idIndexMarker923"/><st c="30191">for QA </st><st c="30198">or production</st></li>
			</ul>
			<p><st c="30211">This is only a partial list of different development processes, but it demonstrates that we are always in the context of a process when </st><st c="30348">we develop.</st></p>
			<p><st c="30359">When we build our testing system, we can describe this process using a test plan. </st><st c="30442">Let’s add a new test plan to see how </st><st c="30479">it works.</st></p>
			<h3><st c="30488">Adding a new test plan</st></h3>
			<p><strong class="bold"><st c="30511">Test plans</st></strong><st c="30522"> are a new feature in Xcode, added</st><a id="_idIndexMarker924"/><st c="30556"> to Xcode 11 in 2019. </st><st c="30578">They allow us to pick tests or test suites and run them in a specific configuration and environment. </st><st c="30679">Test plans are our way of expressing how our test functions will </st><st c="30744">be executed.</st></p>
			<p><st c="30756">We always run our tests as part of a test plan. </st><st c="30805">By default, Xcode creates a test plan for us automatically (</st><em class="italic"><st c="30865">Figure 14</st></em><em class="italic"><st c="30875">.13</st></em><st c="30878">):</st></p>
			<div><div><img src="img/B21795_14_13.jpg" alt="Figure 14.13: The autocreated test plan"/><st c="30881"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31151">Figure 14.13: The autocreated test plan</st></p>
			<p><st c="31190">In </st><em class="italic"><st c="31194">Figure 14</st></em><em class="italic"><st c="31203">.13</st></em><st c="31206">, we can see that Xcode</st><a id="_idIndexMarker925"/><st c="31229"> created a test plan for us called </st><a href="B21795_14.xhtml#_idTextAnchor430"><em class="italic"><st c="31264">Chapter 14</st></em></a><st c="31274">. To create a new test plan, we can tap the test plan pop-up menu and select </st><strong class="bold"><st c="31351">New Test Plan</st></strong><st c="31364">. After we provide a name for our new test plan, we can see it in our Xcode main pane (</st><em class="italic"><st c="31451">Figure 14</st></em><em class="italic"><st c="31461">.14</st></em><st c="31464">):</st></p>
			<div><div><img src="img/B21795_14_14.jpg" alt="Figure 14.14: The new test plan in Xcode"/><st c="31467"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="32011">Figure 14.14: The new test plan in Xcode</st></p>
			<p><em class="italic"><st c="32051">Figure 14</st></em><em class="italic"><st c="32061">.14</st></em><st c="32064"> shows a new test plan called </st><strong class="bold"><st c="32094">Sanity</st></strong><st c="32100">, which has its own </st><st c="32120">customization screen.</st></p>
			<p><st c="32141">There are many things we can do to customize</st><a id="_idIndexMarker926"/><st c="32186"> our new </st><st c="32195">test plan:</st></p>
			<ul>
				<li><st c="32205">We can define precisely which test target we want to run. </st><st c="32264">So far, we have worked on a single test target, but it is possible to have several test targets. </st><st c="32361">Once we choose the different test targets, we will see the list of test suites and functions and mark what tests we should include </st><st c="32492">or exclude.</st></li>
				<li><st c="32503">We can include or exclude tests marked with specific tags. </st><st c="32563">For example, we can choose to include only tests marked with the </st><code><st c="32628">critical</st></code><st c="32636"> tag for the </st><code><st c="32741">performance</st></code><st c="32752"> tag. </st><st c="32758">This is where the tags become </st><st c="32788">extremely helpful.</st></li>
				<li><st c="32806">If we already have many tests written in XCTest, we can include them in our test plan. </st><st c="32894">This capability is crucial to preserve </st><st c="32933">backward compatibility.</st></li>
			</ul>
			<p><st c="32956">As we can see, the test plan is very flexible in deciding what tests will </st><st c="33031">be included.</st></p>
			<p><st c="33043">However, control over the list of test suites and functions is only a fraction of what we can do with test plans. </st><st c="33158">We can do even more </st><st c="33178">with configurations.</st></p>
			<h3><st c="33198">Configuring our test plan</st></h3>
			<p><st c="33224">When we started explaining</st><a id="_idIndexMarker927"/><st c="33251"> test plans, we said that part of the idea of creating one is defining the environment in which the test plan runs. </st><st c="33367">One example of such an environment is localization – language, region, and location can influence our app in certain </st><st c="33484">use cases.</st></p>
			<p><st c="33494">Trying to simulate an environment for our test functions can be challenging; therefore, test plans have a feature called </st><strong class="bold"><st c="33616">Configurations</st></strong><st c="33630"> (</st><em class="italic"><st c="33632">Figure 14</st></em><em class="italic"><st c="33641">.15</st></em><st c="33644">):</st></p>
			<div><div><img src="img/B21795_14_15.jpg" alt="Figure 14.15: The test plan’s Configurations tab"/><st c="33647"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="34627">Figure 14.15: The test plan’s Configurations tab</st></p>
			<p><em class="italic"><st c="34675">Figure 14</st></em><em class="italic"><st c="34685">.15</st></em><st c="34688"> shows a tab bar at the top of the </st><strong class="bold"><st c="34723">Sanity</st></strong><st c="34729"> main pane. </st><st c="34741">The </st><strong class="bold"><st c="34745">Tests</st></strong><st c="34750"> tab defines the included tests in the test plan, and the </st><strong class="bold"><st c="34808">Configurations</st></strong><st c="34822"> tab defines the different configurations for the </st><st c="34872">test plan.</st></p>
			<p><st c="34882">To add a new configuration, we tap the plus button at the bottom of </st><st c="34951">the window.</st></p>
			<p><st c="34962">A test plan can have many configurations. </st><st c="35005">Each configuration contains a list of settings that can affect our test results. </st><st c="35086">Let’s examine </st><st c="35100">them briefly:</st></p>
			<ul>
				<li><strong class="bold"><st c="35113">Arguments</st></strong><st c="35123">: Each app can run with different Launch and environment variables. </st><st c="35192">We can use them to override our A/B test configuration or define a specific API endpoint. </st><st c="35282">Arguments are powerful tools that help us adjust our app to </st><st c="35342">our needs.</st></li>
				<li><strong class="bold"><st c="35352">Localization</st></strong><st c="35365">: Language, region, and location are all part of the localization list of settings that we can define. </st><st c="35469">These settings can influence available features, texts, measurement units, and </st><st c="35548">other behavior.</st></li>
				<li><strong class="bold"><st c="35563">UI testing</st></strong><st c="35574">: If our test plan includes UI tests (not supported yet in Swift Testing), we can decide what happens during screen capturing if there is a </st><st c="35715">test failure.</st></li>
				<li><strong class="bold"><st c="35728">Distribution</st></strong><st c="35741">: Some APIs can behave differently when running on the App Store than on TestFlight – for example, collecting beta testers’ feedback, sandbox issues, and enabling/disabling beta </st><st c="35920">testing features.</st></li>
				<li><strong class="bold"><st c="35937">Test Execution</st></strong><st c="35952">: Here, we can define the test plan execution behavior, including the execution order, timeouts, and </st><st c="36054">repetition settings.</st></li>
				<li><strong class="bold"><st c="36074">Runtime API Checking, Runtime Sanitization</st></strong><st c="36117">: Different runtime settings such as memory management, main thread checker, </st><st c="36195">and sanitization.</st></li>
			</ul>
			<p><st c="36212">That’s a long list of settings! </st><st c="36245">I felt that when I looked at </st><em class="italic"><st c="36274">Figure 14</st></em><em class="italic"><st c="36283">.15</st></em><st c="36286">, but now we have confirmation after reviewing almost </st><st c="36340">each one.</st></p>
			<p><st c="36349">However, the idea behind configurations</st><a id="_idIndexMarker928"/><st c="36389"> is that we don’t need to redefine all the settings each time we create a new configuration. </st><st c="36482">If you open your Xcode and create a new test plan, you can see something called </st><strong class="bold"><st c="36562">Shared Settings</st></strong><st c="36577"> (</st><em class="italic"><st c="36579">Figure 14</st></em><em class="italic"><st c="36588">.16</st></em><st c="36591">):</st></p>
			<div><div><img src="img/B21795_14_16.jpg" alt="Figure 14.16: Shared Settings"/><st c="36594"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="36721">Figure 14.16: Shared Settings</st></p>
			<p><em class="italic"><st c="36750">Figure 14</st></em><em class="italic"><st c="36760">.16</st></em><st c="36763"> focuses on the list of configurations with </st><strong class="bold"><st c="36807">Shared Settings</st></strong><st c="36822"> at the top. </st><st c="36835">The </st><strong class="bold"><st c="36839">Shared Settings</st></strong><st c="36854"> configuration contains the settings for all configurations unless we explicitly change a specific setting for a </st><st c="36967">particular configuration.</st></p>
			<p><st c="36992">Consider a typical use case – we would probably want the same settings for all configurations except for one or two (e.g., a configuration for different locations or distributions). </st><st c="37175">In this case, we will have the same settings except for the region or the </st><st c="37249">distribution method.</st></p>
			<p><st c="37269">Xcode executes all the configurations in a sequence when running a test plan. </st><st c="37348">However, you can disable a specific configuration by right-clicking on it in the configurations list and </st><st c="37453">selecting </st><strong class="bold"><st c="37463">Disable</st></strong><st c="37470">.</st></p>
			<p><st c="37471">So, let’s say we created a sanity test plan</st><a id="_idIndexMarker929"/><st c="37515"> and a regression test plan. </st><st c="37544">What do we do from here? </st><st c="37569">How can we tell Xcode what to execute when running tests? </st><st c="37627">This is where the </st><em class="italic"><st c="37645">Scheme</st></em><st c="37651"> comes </st><st c="37658">into play.</st></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor457"/><st c="37668">Setting up a Scheme</st></h2>
			<p><st c="37688">This chapter is about Swift Testing, not the Xcode</st><a id="_idIndexMarker930"/><st c="37739"> build system, but we can’t discuss testing and </st><st c="37787">ignore </st><strong class="bold"><st c="37794">Schemes</st></strong><st c="37801">.</st></p>
			<p><st c="37802">Schemes are fundamental to managing our project’s build and execution configurations. </st><st c="37889">A </st><em class="italic"><st c="37891">Scheme</st></em><st c="37897"> defines how our project is built, executed, </st><st c="37942">and tested.</st></p>
			<p><st c="37953">We can write dozens of test functions and create as many test plans as we want, but the bottom line is that when we select </st><strong class="bold"><st c="38077">Test</st></strong><st c="38081"> from the Xcode menu or run tests from our CI/CD environment, the </st><em class="italic"><st c="38147">Scheme</st></em><st c="38153"> defines precisely what </st><st c="38177">will happen.</st></p>
			<p class="callout-heading"><st c="38189">What is CI/CD?</st></p>
			<p class="callout"><strong class="bold"><st c="38204">CI/CD</st></strong><st c="38210"> stands for </st><strong class="bold"><st c="38222">Continuous Integrations/Continuous Deployment</st></strong><st c="38267">. We use these practices</st><a id="_idIndexMarker931"/><st c="38291"> to automate our app build and deploy process. </st><st c="38338">A crucial part of this process is testing – before we deploy a build to TestFlight or the App Store, we want to perform testing to ensure we don’t have regressions or other issues. </st><st c="38519">When we build our CI/CD process, we often choose what Scheme </st><st c="38580">to execute.</st></p>
			<p><st c="38591">Looking at the Xcode window, we can locate the </st><em class="italic"><st c="38639">Scheme</st></em><st c="38645"> name next to the project name. </st><st c="38677">Tapping it will open a list of Schemes where we can change the current </st><em class="italic"><st c="38748">Scheme</st></em><st c="38754"> or edit it (</st><em class="italic"><st c="38767">Figure 14</st></em><em class="italic"><st c="38777">.17</st></em><st c="38780">):</st></p>
			<div><div><img src="img/B21795_14_17.jpg" alt="Figure 14.17: Editing the current Scheme"/><st c="38783"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="39710">Figure 14.17: Editing the current Scheme</st></p>
			<p><em class="italic"><st c="39750">Figure 14</st></em><em class="italic"><st c="39760">.17</st></em><st c="39763"> shows how to reach</st><a id="_idIndexMarker932"/><st c="39782"> the pop-up </st><em class="italic"><st c="39794">Scheme</st></em><st c="39800"> menu. </st><st c="39807">Tapping on the </st><strong class="bold"><st c="39822">Edit Scheme…</st></strong><st c="39834"> option leads us to the </st><strong class="bold"><st c="39858">Edit Scheme</st></strong><st c="39869"> screen (</st><em class="italic"><st c="39878">Figure 14</st></em><em class="italic"><st c="39888">.18</st></em><st c="39891">):</st></p>
			<div><div><img src="img/B21795_14_18.jpg" alt="Figure 14.18: The Edit Scheme screen"/><st c="39894"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="40152">Figure 14.18: The Edit Scheme screen</st></p>
			<p><em class="italic"><st c="40188">Figure 14</st></em><em class="italic"><st c="40198">.18</st></em><st c="40201"> shows that the </st><em class="italic"><st c="40217">Scheme</st></em><st c="40223"> has six different actions—</st><strong class="bold"><st c="40250">Build</st></strong><st c="40256">, </st><strong class="bold"><st c="40258">Run</st></strong><st c="40261">, </st><strong class="bold"><st c="40263">Test</st></strong><st c="40267">, </st><strong class="bold"><st c="40269">Profile</st></strong><st c="40276">, </st><strong class="bold"><st c="40278">Analyze</st></strong><st c="40285">, and </st><strong class="bold"><st c="40291">Archive</st></strong><st c="40298">. In this screenshot, we will focus on the </st><strong class="bold"><st c="40341">Test</st></strong><st c="40345"> action.</st></p>
			<p><st c="40353">Besides choosing the configuration (</st><strong class="bold"><st c="40390">Debug</st></strong><st c="40396"> or </st><strong class="bold"><st c="40400">Release</st></strong><st c="40407"> in our case), we can determine what test plans to run. </st><st c="40463">We can add an existing or new test plan using the plus button at the </st><st c="40532">bottom left.</st></p>
			<p><st c="40544">That’s where we decide what happens when executing the </st><strong class="bold"><st c="40600">Test</st></strong><st c="40604"> action on our </st><em class="italic"><st c="40619">Scheme</st></em><st c="40625">. Having several </st><em class="italic"><st c="40642">Schemes</st></em><st c="40649"> configured differently for various purposes can be valuable when we connect our project to a </st><st c="40743">CI/CD system.</st></p>
			<p><st c="40756">For example, we can run a performance test once a month and sanity every night, just by creating two different Schemes that run different </st><st c="40895">test plans.</st></p>
			<p><st c="40906">Now that we know how to create</st><a id="_idIndexMarker933"/><st c="40937"> test functions, suites, test plans, and Schemes, let’s flip to the other side of the equation and see how to write </st><st c="41053">testable code.</st></p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor458"/><st c="41067">Tips to write testable code</st></h1>
			<p><st c="41095">One of the biggest challenges </st><a id="_idIndexMarker934"/><st c="41126">developers face when they try to write tests for code is struggling to write tests for existing functions that could be more testable – for example, functions that contain code that performs network requests or functions that have external dependencies that are difficult to </st><st c="41401">set up.</st></p>
			<p><st c="41408">Writing testable code usually goes hand in hand with writing clean and efficient code. </st><st c="41496">However, we should still follow some writing guidelines if we want our functions to </st><st c="41580">be testable.</st></p>
			<p><st c="41592">Let’s explore some of </st><st c="41615">them now.</st></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor459"/><st c="41624">Writing pure functions</st></h2>
			<p><strong class="bold"><st c="41647">Pure functions</st></strong><st c="41662"> are functions that, given the same</st><a id="_idIndexMarker935"/><st c="41697"> input, always return</st><a id="_idIndexMarker936"/><st c="41718"> the same output and don’t rely on external states or have any </st><st c="41781">side effects.</st></p>
			<p><st c="41794">For instance, take the </st><st c="41818">following example:</st></p>
			<pre class="source-code"><st c="41836">
class NumberFilter {
    var numbers: [Int] = []
    var filteredNumbers: [Int] = []
    </st><strong class="bold"><st c="41914">func filterNumbers(predicate: (Int) -&gt; Bool) {</st></strong><st c="41960">
        self.filteredNumbers =
          self.numbers.filter(predicate)
    }
}</st></pre>			<p><st c="42018">This code example contains a </st><code><st c="42048">NumberFilter</st></code><st c="42060"> class with a function called </st><code><st c="42090">filterNumbers</st></code><st c="42103">. This class performs a predicate on an instance variable and stores the results in another </st><st c="42195">instance variable.</st></p>
			<p><st c="42213">This is a classic example of a non-pure function, since it relies on an external variable and has a side effect. </st><st c="42327">Now, imagine we want to test this function – it requires us to set up a </st><code><st c="42399">NumberFilter</st></code><st c="42411"> instance and set the </st><code><st c="42433">numbers</st></code><st c="42440"> variable. </st><st c="42451">In addition, we need to check the result using the same </st><code><st c="42507">NumberFilter</st></code><st c="42519"> instance, with the </st><code><st c="42539">filtersNumbers</st></code><st c="42553"> instance.</st></p>
			<p><st c="42563">The class can change down the road and may require more setup than before, breaking </st><st c="42648">our test.</st></p>
			<p><st c="42657">Instead, we can make this function</st><a id="_idIndexMarker937"/><st c="42692"> pure, </st><st c="42699">like this:</st></p>
			<pre class="source-code"><st c="42709">
func filterNumbers(_ numbers: [Int], predicate: (Int) -&gt; Bool) -&gt; [Int] {
    return numbers.filter(predicate)
}</st></pre>			<p><st c="42818">In the modified example, our function</st><a id="_idIndexMarker938"/><st c="42856"> receives the input as a parameter and returns the results as part of its output. </st><st c="42938">This change makes it agnostic to external states and easy </st><st c="42996">to test.</st></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor460"/><st c="43004">Separating your code based on concerns</st></h2>
			<p><st c="43043">As always, a good separation </st><a id="_idIndexMarker939"/><st c="43073">is crucial for our project maintenance (which we will cover in more detail in </st><a href="B21795_15.xhtml#_idTextAnchor463"><em class="italic"><st c="43151">Chapter 15</st></em></a><st c="43161">). </st><st c="43165">However, separation is also essential </st><st c="43203">for testing.</st></p>
			<p><st c="43215">The fundamental separation of concerns idea states that each part of our code, whether a variable, function, class, or module, should have one and only </st><st c="43368">one responsibility.</st></p>
			<p><st c="43387">Let’s take the following code as </st><st c="43421">an example:</st></p>
			<pre class="source-code"><st c="43432">
func processAndSaveData(_ input: String) -&gt; Bool {
   // Data processing
   let processedData = // &lt;perform some data manipulation
      code&gt;
   // Data saving
   return databaseService.saveData(processedData)
}</st></pre>			<p><st c="43627">The </st><code><st c="43632">processAndSaveData</st></code><st c="43650"> function is responsible for two tasks – processing the input data and saving it to the </st><st c="43738">database service.</st></p>
			<p><st c="43755">We can see that the string processing code uses the same function that performs data saving. </st><st c="43849">If we want to test whether the string processing succeeded, we must also ensure that the output has been saved successfully. </st><st c="43974">These two responsibilities are coupled, which makes the code very difficult </st><st c="44050">to test.</st></p>
			<p><st c="44058">To solve that, we can separate the processing code into </st><st c="44115">another function:</st></p>
			<pre class="source-code"><st c="44132">
func processAndSaveData(_ input: String) -&gt; Bool {
    // Data processing
    let processedData = processData(input)
    // Data saving
    return databaseService.saveData(processedData)
}
</st><strong class="bold"><st c="44306">private func processData(_ input: String) -&gt; String {</st></strong>
<strong class="bold"><st c="44359">    return input.reversed()</st></strong><st c="44383">
}</st></pre>			<p><st c="44385">In this example, we gave the processing data task its own function, and now it is possible to test it regardless</st><a id="_idIndexMarker940"/><st c="44497"> of the </st><st c="44505">data-saving part.</st></p>
			<p><st c="44522">Our last tip also discusses coupling but, in another context – </st><em class="italic"><st c="44586">protocols</st></em><st c="44595">.</st></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor461"/><st c="44596">Performing mocking using protocols</st></h2>
			<p><st c="44631">Sometimes, we don’t have a choice</st><a id="_idIndexMarker941"/><st c="44665"> but to test functions</st><a id="_idIndexMarker942"/><st c="44687"> that reach our network or any external service that can’t really simulate </st><st c="44762">during tests.</st></p>
			<p><st c="44775">To overcome that, we can easily create mocks for these services </st><st c="44840">using </st><strong class="bold"><st c="44846">protocols</st></strong><st c="44855">.</st></p>
			<p><st c="44856">Look at the </st><st c="44869">following code:</st></p>
			<pre class="source-code"><st c="44884">
class UserViewModel {
    private let networkService</st><strong class="bold"><st c="44933">: NetworkServiceProtocol</st></strong><st c="44958">
    var user: User?
    </st><st c="44975">init(networkService</st><strong class="bold"><st c="44994">: NetworkServiceProtocol)</st></strong><st c="45020"> {
        self.networkService = networkService
    }
    func fetchUserDetails(for userId: String, completion:
      @escaping () -&gt; Void) {
        networkService.fetchUserDetails(for: userId) {
          [weak self] user in
            self?.user = user
            completion()
        }
    }
}</st></pre>			<p><st c="45243">This code example contains a </st><code><st c="45273">UserViewModel</st></code><st c="45286"> class that fetches user details from the server and stores the results in an instance variable. </st><st c="45383">Testing the </st><code><st c="45395">fetchUserDetails</st></code><st c="45411"> function requires performing a request to the server, which can make our </st><st c="45485">test unstable.</st></p>
			<p><st c="45499">To solve that, we can create a mock class that conforms to </st><code><st c="45559">NetworkServiceProtocol</st></code><st c="45581"> and simulate the </st><st c="45599">network service:</st></p>
			<pre class="source-code"><st c="45615">
class MockNetworkService: NetworkServiceProtocol {
    var userToReturn: User?
    </st><st c="45691">func fetchUserDetails(for userId: String, completion:
    @escaping (User?) -&gt; Void) {
        completion(userToReturn)
    }
}</st></pre>			<p><st c="45802">This example demonstrates a mock</st><a id="_idIndexMarker943"/><st c="45835"> class that accepts</st><a id="_idIndexMarker944"/><st c="45854"> a user’s return and can easily mock the whole network process. </st><st c="45918">We achieved that by using a protocol and dependency injection, and we can do the same to store data, authenticate, and </st><st c="46037">so on.</st></p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor462"/><st c="46043">Summary</st></h1>
			<p><st c="46051">Testing is crucial to our mission to produce stable, high-quality code. </st><st c="46124">Remember, writing tests is not just a fundamental part of being a professional iOS developer – it is also part of a culture of doing </st><st c="46257">things right.</st></p>
			<p><st c="46270">In this chapter, we’ve learned about the testing history in Xcode, covered the Swift Testing basics by writing simple tests, learned how to manage our tests using suites, test plans, and Schemes, and even discussed some useful tips to make our code more testable. </st><st c="46535">Now, we should be able to set up a new test plan for </st><st c="46588">our project!</st></p>
			<p><st c="46600">Our following and final chapter, on architecture, touches on some of the principles we discussed here and will also help us create a </st><st c="46734">stable project.</st></p>
		</div>
	<div></body></html>