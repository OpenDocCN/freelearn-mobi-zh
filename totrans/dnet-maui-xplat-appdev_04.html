<html><head></head><body>
<div><div><h1 class="chapterNumber">3</h1>
<h1 class="chapterTitle" id="_idParaDest-84">User Interface Design with XAML</h1>
<p class="normal">In the previous chapter, we created a new .NET MAUI project named <code class="inlineCode">PassXYZ.Vault</code>. As we progress through this book, we will enhance it with the skills and knowledge we acquire. In the last chapter, we got a glimpse of user interface implementation in XAML. In this chapter, we will delve deeper into creating user interfaces using XAML.</p>
<p class="normal">The <strong class="keyWord">eXtensible Application Markup Language (XAML)</strong> is <a id="_idIndexMarker184"/>an XML-based language that is used to define user interfaces<a id="_idIndexMarker185"/> for <strong class="keyWord">Windows Presentation Foundation (WPF)</strong>, <strong class="keyWord">Universal Windows Platform (UWP)</strong>, Xamarin.Forms, and .NET MAUI. The XAML dialects in <a id="_idIndexMarker186"/>these platforms share the same syntax but differ in their vocabularies.</p>
<p class="normal">XAML allows developers to define user interfaces in XML-based <em class="italic">markup language</em> rather than in any <em class="italic">programming language</em>. It is possible to write all our user interfaces in code, but user interface design with XAML will be more succinct and more visually coherent. Because XAML does not use a programming language, it cannot contain code. This is a disadvantage, but it is also an advantage as it forces the developer to separate the logic from the user interface design. </p>
<p class="normal">The following topics will be covered in this chapter:</p>
<ul>
<li class="bulletList">How to create a XAML page</li>
<li class="bulletList">Basic XAML syntax</li>
<li class="bulletList">XAML markup extension</li>
<li class="bulletList">How to design user interfaces with the master-detail pattern</li>
<li class="bulletList">Localization of .NET MAUI apps</li>
</ul>
<h1 class="heading-1" id="_idParaDest-85">Technical requirements</h1>
<p class="normal">To test and debug the source code in this chapter, you need to have Visual Studio 2022 installed on your PC. Please refer to the <em class="italic">Development environment setup</em> section in <em class="chapterRef">Chapter 1</em>, <em class="italic">Getting Started with .NET MAUI</em>, for the details.</p>
<p class="normal">The source code for this chapter is available in the following GitHub repository:</p>
<p class="normal"><a href="https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03">https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03</a></p>
<p class="normal">To check out the source code of this chapter, we can use the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ git clone -b 2nd/chapter03 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition.git PassXYZ.Vault2
</code></pre>
<p class="normal">To find out more about the source code in this book, please refer to the <em class="italic">Managing the source code in this book</em> section in <em class="chapterRef">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>.</p>
<h1 class="heading-1" id="_idParaDest-86">Creating a XAML page</h1>
<p class="normal">Before we delve into <a id="_idIndexMarker187"/>XAML syntax, let’s first understand how to create a XAML page in Visual Studio and through the <strong class="keyWord">dotnet</strong> command line.</p>
<p class="normal">To create a XAML page using Visual Studio, right-click on the project node, then select <strong class="screenText">Add &gt; New Item…</strong>. This will bring up the dialog box shown in <em class="italic">Figure 3.1</em>:</p>
<figure class="mediaobject"><img alt="" height="573" src="img/B21554_03_01.png" width="825"/></figure>
<p class="packt_figref">Figure 3.1: Adding a XAML page</p>
<p class="normal">On this screen, select <strong class="screenText">Content Page</strong> from the templates and click <strong class="screenText">Add</strong>. This action will generate a pair of<a id="_idIndexMarker188"/> files – a XAML file and a C# code-behind file.</p>
<p class="normal">The same can be achieved using a <code class="inlineCode">dotnet</code> command. To locate all .NET MAUI templates, we can use the following <code class="inlineCode">dotnet</code> command in the PowerShell console:</p>
<figure class="mediaobject"><img alt="" height="237" src="img/B21554_03_02.png" width="824"/></figure>
<p class="packt_figref">Figure 3.2: dotnet command for listing templates</p>
<p class="normal">From the preceding<a id="_idIndexMarker189"/> output, we can observe that the short name of the XAML content page is <code class="inlineCode">maui-page-xaml</code>. We can create a XAML page using the following command:</p>
<figure class="mediaobject"><img alt="" height="202" src="img/B21554_03_03.png" width="825"/></figure>
<p class="packt_figref">Figure 3.3: Creating a XAML page</p>
<p class="normal">The preceding command will generate two files named <code class="inlineCode">ItemsPage.xaml</code> and <code class="inlineCode">ItemsPage.xaml.cs</code>. You may notice a warning message about post-creation actions. This is a known issue, and you can find more information about it at <a href="https://github.com/dotnet/maui/issues/4994">https://github.com/dotnet/maui/issues/4994</a>.</p>
<p class="normal">However, this is not something we need to worry about.</p>
<div><p class="normal"><strong class="keyWord">What is the “code-behind”?</strong></p>
<p class="normal">In .NET MAUI, the term <strong class="keyWord">code-behind</strong> refers to the <a id="_idIndexMarker190"/>code file associated with <a id="_idIndexMarker191"/>a <strong class="keyWord">user interface (UI)</strong> definition file, typically a XAML file. The code-behind file contains the logic for handling UI events, data binding, and other app functionality related to the UI. The code-behind file is a C# (.cs) file with the same name as the related XAML file. For example, if we have an <code class="inlineCode">ItemsPage.xaml</code> file, the code-behind file will be named <code class="inlineCode">ItemsPage.xaml.cs</code>.</p>
<p class="normal">The code-behind file <a id="_idIndexMarker192"/>includes a class that inherits from a .NET MAUI base page type, usually <code class="inlineCode">ContentPage</code>, <code class="inlineCode">NavigationPage</code>, or <code class="inlineCode">TabbedPage</code>. The class declaration is marked as a partial class that matches the class definition in the XAML file, allowing for seamless integration between the XAML UI definition and its corresponding code.</p>
</div>
<h1 class="heading-1" id="_idParaDest-87">XAML syntax</h1>
<p class="normal">Since XAML is an<a id="_idIndexMarker193"/> XML-based language, to understand it better, we need to understand basic XML syntax first. In an XML file, it starts with an XML declaration or prolog. The content of XML or XAML files includes a hierarchy of elements. Each element may have attributes associated with it. </p>
<p class="normal">Let’s review <code class="inlineCode">App.xaml</code> in the project that we created in <em class="chapterRef">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>, as an example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version = "1.0" encoding = "UTF-8" ?&gt;
&lt;Application 
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  xmlns:local="clr-namespace:PassXYZ.Vault"
  x:Class="PassXYZ.Vault.App"&gt;
    &lt;Application.Resources&gt;
      &lt;ResourceDictionary.MergedDictionaries&gt;
        &lt;ResourceDictionary Source="…/Colors.xaml" /&gt;
        &lt;ResourceDictionary Source="…/Styles.xaml" /&gt;
      &lt;/ResourceDictionary.MergedDictionaries&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;
</code></pre>
<p class="packt_figref">Listing 3.1: <code class="inlineCode">App.xaml</code> (<a href="https://epa.ms/App3-1">https://epa.ms/App3-1</a>)</p>
<h2 class="heading-2" id="_idParaDest-88">XML declaration</h2>
<p class="normal">At the start of <code class="inlineCode">App.xaml</code>, we can see the following<a id="_idIndexMarker194"/> XML declaration:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version = "1.0" encoding = "UTF-8" ?&gt;
</code></pre>
<p class="normal">This declaration<a id="_idIndexMarker195"/> specifies the version of XML being used and the character encoding. In <code class="inlineCode">App.xaml</code>, XML version 1.0 is used and the character encoding is set to UTF-8.</p>
<h2 class="heading-2" id="_idParaDest-89">Element</h2>
<p class="normal">In <em class="italic">Listing 3.1</em>, the content <a id="_idIndexMarker196"/>of <code class="inlineCode">App.xaml</code> begins with the <code class="inlineCode">Application</code> root element. Every XML document must contain a single root element that encompasses all other elements. Elements can have child elements, also known as nested elements, such as <code class="inlineCode">ResourceDictionary</code>.</p>
<p class="normal">Elements are composed of a start tag, the content, and an end tag, as seen in the <code class="inlineCode">Application</code> tag:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Application&gt;
…
&lt;/Application&gt;
</code></pre>
<p class="normal">The start tag is enclosed in angle brackets (e.g., <code class="inlineCode">&lt;Application&gt;</code>), and the end tag includes a forward slash before the element name (e.g., <code class="inlineCode">&lt;/Application&gt;</code>). The content can be any text or nested elements.</p>
<p class="normal">For an empty element, the end tag can be omitted by adding a forward slash at the end of the start tag, like so:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Application /&gt;
</code></pre>
<p class="normal">When discussing an XML element, we may use the terms <strong class="keyWord">element</strong>, <strong class="keyWord">node</strong>, and <strong class="keyWord">tag</strong>. <strong class="keyWord">Element</strong> refers <a id="_idIndexMarker197"/>to the start and end tag of that element<a id="_idIndexMarker198"/> together. <strong class="keyWord">Tag</strong> refers to either the start or end tag of the element. <strong class="keyWord">Node</strong> refers <a id="_idIndexMarker199"/>to an element and all its inner content, including all child elements.</p>
<p class="normal">A XAML document consists of many nested elements, with only one top element, known as the root element. In .NET MAUI, the root element is usually <code class="inlineCode">Application</code>, <code class="inlineCode">ContentPage</code>, <code class="inlineCode">Shell</code>, or <code class="inlineCode">ResourceDictionary</code>.</p>
<p class="normal">For each XAML file, we typically have a corresponding C# code-behind file. Let’s review the code-behind file in <em class="italic">Listing 3.2</em>:</p>
<pre class="programlisting code"><code class="hljs-code">using PassXYZ.Vault.Services;
using PassXYZ.Vault.Views;
namespace PassXYZ.Vault;
public partial class App : Application                             //(1)
{
  public App() 
  {
    InitializeComponent();                                         //(2)
    MainPage = new AppShell();
  }
}
</code></pre>
<p class="packt_figref">Listing 3.2: <code class="inlineCode">App.xaml.cs</code> (<a href="https://epa.ms/App3-2">https://epa.ms/App3-2</a>)</p>
<p class="normal">In XAML, elements usually represent actual C# classes that are instantiated to objects at runtime. Together, the XAML and code-behind files define a complete class. For example, <code class="inlineCode">App.xaml</code> (<em class="italic">Listing 3.1</em>) and <code class="inlineCode">App.xaml.cs</code> (<em class="italic">Listing 3.2</em>) define the <code class="inlineCode">App</code> class, which is a sub-class of <code class="inlineCode">Application</code>.</p>
<p class="normal"><strong class="keyWord">(1)</strong> The <code class="inlineCode">App</code> class, whose full name is <code class="inlineCode">PassXYZ.Vault.App</code>, is the same as the one defined in the XAML file using the <code class="inlineCode">x:Class</code> attribute:</p>
<pre class="programlisting code"><code class="hljs-code">x:Class="PassXYZ.Vault.App"
</code></pre>
<p class="normal"><strong class="keyWord">(2)</strong> In the constructor of <a id="_idIndexMarker200"/>the <code class="inlineCode">App</code> class, the <code class="inlineCode">InitializeComponent</code> method is called to load the XAML and parse it. UI elements defined in the XAML file are created at this point. We can access these UI elements by the name defined with the <code class="inlineCode">x:Name</code> attribute, as we’ll see shortly.</p>
<h2 class="heading-2" id="_idParaDest-90">Attribute</h2>
<p class="normal">An element can have multiple <a id="_idIndexMarker201"/>unique attributes. An attribute provides additional information about XML elements. An XML attribute is a name-value pair attached to an element. In XAML, an element represents a C# class and the attributes represent the members of this class:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Button x:Name="loginButton" VerticalOptions="Center"
IsEnabled="True" Text="Login"/&gt;
</code></pre>
<p class="normal">As we can see in the above, four attributes – <code class="inlineCode">x:Name</code>, <code class="inlineCode">VerticalOptions</code>, <code class="inlineCode">IsEnabled</code>, and <code class="inlineCode">Text</code> – are defined for the <code class="inlineCode">Button</code> element. To define an attribute, we need to specify the attribute’s name and value with an equal sign. The attribute value should be enclosed in double or single quotes. For example, <code class="inlineCode">IsEnabled</code> is the attribute name and <code class="inlineCode">"True"</code> is the attribute value.</p>
<p class="normal">In this example, the <code class="inlineCode">x:Name</code> attribute<a id="_idIndexMarker202"/> is a special one. It does not refer to a member of the <code class="inlineCode">Button</code> class, but rather refers to the variable holding the instance of the <code class="inlineCode">Button</code> class. Without the <code class="inlineCode">x:Name</code> attribute, an anonymous instance of the <code class="inlineCode">Button</code> class will be created. With the <code class="inlineCode">x:Name</code> attribute declared, we can refer to the instance of the <code class="inlineCode">Button</code> class using the <code class="inlineCode">loginButton</code> variable in the code-behind file.</p>
<h2 class="heading-2" id="_idParaDest-91">XML and XAML namespaces</h2>
<p class="normal">In XML<a id="_idIndexMarker203"/> or XAML, we can declare namespaces just like we do in C#. Namespaces help to group elements and attributes to avoid name conflicts when the same name is used in a different scope. Namespaces can be defined using the <code class="inlineCode">xmlns</code> attribute with the following syntax:</p>
<pre class="programlisting code"><code class="hljs-code">
</code></pre>
<p class="normal">The XAML namespace<a id="_idIndexMarker204"/> definition has two components: a prefix and an identifier. Both the prefix and the identifier can be any string, as allowed by the W3C namespaces in the XML 1.0 specification. If the prefix is omitted, the namespace becomes the default namespace. </p>
<p class="normal">In <em class="italic">Listing 3.1</em>, the following namespace is the default one:</p>
<pre class="programlisting code"><code class="hljs-code">
</code></pre>
<p class="normal">This default namespace allows us to refer to .NET MAUI classes without a prefix, such as <code class="inlineCode">ContentPage</code>, <code class="inlineCode">Label</code>, or <code class="inlineCode">Button</code>.</p>
<p class="normal">For the namespace declaration, the <code class="inlineCode">x</code> prefix is used, like so:</p>
<pre class="programlisting code"><code class="hljs-code">
</code></pre>
<p class="normal">The <code class="inlineCode">xmlns:x</code> namespace declaration specifies elements and attributes that are intrinsic to XAML. This namespace is one of the most important ones that we will use in the UI design with XAML. To comprehend its usage, we can create a content page with an identical structure using both C# and XAML in the subsequent sections.</p>
<h2 class="heading-2" id="_idParaDest-92">Creating a new page using XAML</h2>
<p class="normal">First, let’s create a new page <a id="_idIndexMarker205"/>using XAML. To create a content page in XAML, we can use the <code class="inlineCode">dotnet</code> command, as we have done previously:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet new maui-page-xaml -n NewPage1
The template ".NET MAUI ContentPage (XAML)" was created successfully.
Processing post-creation actions...
The post action 84c0da21-51c8-4541-9940-6ca19af04ee6 is not supported.
Description: Opens NewPage1.xaml in the editor.
</code></pre>
<p class="normal">The preceding command generates a XAML file (<code class="inlineCode">NewPage1.xaml</code>) and a C# code-behind file (<code class="inlineCode">NewPage1.xaml.cs</code>). We can update the XAML file to the following. Since we aren’t adding any logic, we can ignore the code-behind file (<code class="inlineCode">NewPage1.xaml.cs</code>) in this example:</p>
<p class="normal"><code class="inlineCode">NewPage1.xaml</code></p>
<pre class="programlisting code"><code class="hljs-code">&lt;ContentPage
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  x:Class="MauiApp1.NewPage1"                                    //(1)
  Title="NewPage1"&gt;
  &lt;StackLayout x:Name="layout"&gt;                                  //(2)
    &lt;Label Text="Welcome to .NET MAUI!"
      VerticalOptions="Center"
      HorizontalOptions="Center" /&gt;
    &lt;BoxView HeightRequest="150" WidthRequest="150"
      HorizontalOptions="Center"&gt;
      &lt;BoxView.Color&gt;
        &lt;Color x:FactoryMethod="FromRgba"&gt;                      //(3)
          &lt;x:Arguments&gt;                                         //(4)
            &lt;x:Int32&gt;192&lt;/x:Int32&gt;                              //(5)
            &lt;x:Int32&gt;75&lt;/x:Int32&gt;
            &lt;x:Int32&gt;150&lt;/x:Int32&gt;
            &lt;x:Int32&gt;128&lt;/x:Int32&gt;
          &lt;/x:Arguments&gt;
        &lt;/Color&gt;
      &lt;/BoxView.Color&gt;
    &lt;/BoxView&gt;
  &lt;/StackLayout&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="normal"><code class="inlineCode">NewPage1.xaml.cs</code></p>
<pre class="programlisting code"><code class="hljs-code">namespace MauiApp1;
public partial class NewPage1 : ContentPage {
  public NewPage1() {
    InitializeComponent();
  }
}
</code></pre>
<p class="normal">For comparison <a id="_idIndexMarker206"/>purposes with the XAML version we just created, let’s create the same content page using C# only in the next section. Then we will have a look at the lines numbered in the preceding code.</p>
<h3 class="heading-3" id="_idParaDest-93">Creating the same new page using C#</h3>
<p class="normal">To create the same content<a id="_idIndexMarker207"/> page using only C# code, let’s use the following command:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet new maui-page-csharp -n NewPage1
The template ".NET MAUI ContentPage (C#)" was created successfully.
Processing post-creation actions...
The post action 84c0da21-51c8-4541-9940-6ca19af04ee6 is not supported.
Description: Opens NewPage1.cs in the editor.
</code></pre>
<p class="normal">The preceding command generates a content page in the <code class="inlineCode">NewPage1.cs</code> C# file. We can implement the same logic in C# like so:</p>
<p class="normal"><code class="inlineCode">NewPage1.cs</code></p>
<pre class="programlisting code"><code class="hljs-code">namespace MauiApp1;
public class NewPage1 : ContentPage {                        //[1]
  public NewPage1() {
    var layout = new StackLayout                             //[2]
    {
      Children = {
        new Label { Text = "Welcome to .NET MAUI!" },
        new BoxView {
          HeightRequest = 150,
          WidthRequest = 150,
          HorizontalOptions = LayoutOptions.Center,
          Color = Color.FromRgba(192, 75, 150, 128)          //[3]
        }
      }
    };
    Content = layout;
  }
}
</code></pre>
<p class="normal">Here, we <a id="_idIndexMarker208"/>have created the same content page (<code class="inlineCode">NewPage1</code>) twice in both XAML and C#. XAML cannot contain programming logic, but it can be used to declare user interface elements and put the logic in the C# code-behind file. Within both versions of <code class="inlineCode">NewPage1</code>, we created a content page that contains <code class="inlineCode">Label</code> and <code class="inlineCode">BoxView</code> elements. In the XAML version, we used attributes defined in the <code class="inlineCode">xmlns:x</code> namespace to specify the UI elements:</p>
<p class="normal"><strong class="keyWord">(1)</strong> A content page called <code class="inlineCode">NewPage1</code> is created in XAML. The <code class="inlineCode">x:Class</code> attribute specifies the class name – that is, <code class="inlineCode">NewPage1</code>. In the C# code-behind file, a partial class of <code class="inlineCode">NewPage1</code> is defined. In the constructor, the <code class="inlineCode">InitializeComponent</code> method is invoked to load the UI defined in XAML.</p>
<p class="normal"><strong class="keyWord">[1]</strong> We can create the same content page, <code class="inlineCode">NewPage1</code>, using C# directly as a derived class of <code class="inlineCode">ContentPage</code>.</p>
<p class="normal">We defined a <code class="inlineCode">StackLayout</code> in the content page and the variable name used to refer to it is <strong class="keyWord">layout</strong> in both the XAML and C# versions:</p>
<p class="normal"><strong class="keyWord">(2)</strong> In XAML, <code class="inlineCode">x:Name</code> specifies the variable name of <code class="inlineCode">StackLayout</code>.</p>
<p class="normal"><strong class="keyWord">[2]</strong> In C#, we can declare the variable as <code class="inlineCode">layout</code>.</p>
<p class="normal"><strong class="keyWord">(3)</strong> <code class="inlineCode">x:FactoryMethod</code> specifies a factory method that can be used to initialize an object.</p>
<p class="normal"><strong class="keyWord">[3]</strong> In C# code, we can call the <code class="inlineCode">Color.FromRgba</code> function directly, but we have to use the <code class="inlineCode">x:FactoryMethod</code> attribute in XAML to do the same.</p>
<p class="normal"><strong class="keyWord">(4)</strong> <code class="inlineCode">x:Arguments</code> is used to specify arguments when we call <code class="inlineCode">Color.FromRgba</code> in XAML.</p>
<p class="normal"><strong class="keyWord">(5)</strong> <code class="inlineCode">x:Int</code> is used to specify integer <a id="_idIndexMarker209"/>arguments. For other data types, we can use <code class="inlineCode">x:Double</code>, <code class="inlineCode">xChar</code>, or <code class="inlineCode">x:Boolean</code>.</p>
<p class="normal">For more information about the <code class="inlineCode">xmlns:x</code> namespace, please refer to the Microsoft documentation at <a href="https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/">https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/</a>.</p>
<p class="normal"><strong class="keyWord">Common Language Runtime (CLR)</strong> types can <a id="_idIndexMarker210"/>be referenced in XAML by declaring a XAML namespace with a prefix. As shown in <em class="italic">Listing 3.1</em>, we can refer to our C# namespace, <code class="inlineCode">PassXYZ.Vault</code>, like so:</p>
<pre class="programlisting code"><code class="hljs-code">xmlns:local="clr-namespace:PassXYZ.Vault"
</code></pre>
<p class="normal">To declare a CLR namespace, we can use <code class="inlineCode">clr-namespace:</code> or <code class="inlineCode">using:</code>. If the CLR namespace is defined in a different assembly, <code class="inlineCode">assembly=</code> is used to specify the assembly that contains the referenced CLR namespace. The value is the name of the assembly without the file extension. In our case, it has been omitted since the <code class="inlineCode">PassXYZ.Vault</code> namespace is within the same assembly as our application code.</p>
<p class="normal">We will see more uses of namespaces later in this chapter.</p>
<h1 class="heading-1" id="_idParaDest-94">XAML markup extensions</h1>
<p class="normal">Even though we can<a id="_idIndexMarker211"/> initialize class instances using XAML elements and set class members using XAML attributes, we can only set them as predefined constants in a XAML document.</p>
<p class="normal">To enhance the power and flexibility of XAML by allowing element attributes to be set from a variety of sources, we can use XAML markup extensions. With XAML markup extensions, we can set an attribute to values defined somewhere else, or a result processed by code at runtime.</p>
<p class="normal">XAML markup extensions can be specified in curly braces, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Button Margin="0,10,0,0" Text="Learn more"
        Command="{Binding OpenWebCommand}"
        BackgroundColor="{DynamicResource PrimaryColor}"
        TextColor="White" /&gt;
</code></pre>
<p class="normal">In the preceding code, both the <code class="inlineCode">BackgroundColor</code> and <code class="inlineCode">Command</code> attributes have been set to markup extensions. <code class="inlineCode">BackgroundColor</code> has been set to <code class="inlineCode">DynamicResource</code> and <code class="inlineCode">Command</code> has been set to the <code class="inlineCode">OpenWebCommand</code> method defined in the view model.</p>
<p class="normal">Here, we’ve provided a brief introduction to markup extensions, so don’t concern yourself with the usage of markup extensions for now. We will delve deeper into markup extensions when we use them later. In the next chapter, <em class="chapterRef">Chapter 4</em>, <em class="italic">Exploring MVVM and Data Binding</em>, we will detail the usage of data binding. </p>
<p class="normal">Please refer to the following Microsoft <a id="_idIndexMarker212"/>documentation to find out more information about markup extensions: <a href="https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume">https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume</a>.</p>
<p class="normal">Now that we’ve learned the basics about XAML, we can use it to work on our user interface design.</p>
<h1 class="heading-1" id="_idParaDest-95">Building a user interface</h1>
<p class="normal">Equipped with basic <a id="_idIndexMarker213"/>knowledge of XAML, let’s take a bird’s-eye view of the .NET MAUI user interface building blocks. We will explore them in greater depth as we encounter them in subsequent chapters.</p>
<p class="normal">A page<a id="_idIndexMarker214"/> is the top-level user interface element that typically occupies all the screens or windows. We introduced how to create pages using the Visual Studio template or <code class="inlineCode">dotnet</code> command at the beginning of this chapter. Each page generally contains at least one layout element, which is used to organize the design of controls on a page. Examples of pages are <code class="inlineCode">ContentPage</code>, <code class="inlineCode">NavigationPage</code>, <code class="inlineCode">TabbedPage</code>, <code class="inlineCode">FlyoutPage</code>, and <code class="inlineCode">Shell</code>.</p>
<p class="normal">Within a content page, we utilize views (or controls) as the building blocks of the user interface. To organize views into groups, we can use layout components as containers for the views.</p>
<h2 class="heading-2" id="_idParaDest-96">Layouts</h2>
<p class="normal"><strong class="keyWord">Layouts</strong> are container <a id="_idIndexMarker215"/>components that help organize and arrange UI elements (or views) within your app. They control the position, size, and alignment of the UI components based on specific rules. </p>
<p class="normal">Layouts allow you to create consistent and adaptive user interfaces that work on different screen sizes and device orientations. Examples include <code class="inlineCode">StackLayout</code>, <code class="inlineCode">Grid</code>, <code class="inlineCode">FlexLayout</code>, <code class="inlineCode">RelativeLayout</code>, and <code class="inlineCode">AbsoluteLayout</code>.</p>
<h3 class="heading-3" id="_idParaDest-97">StackLayout</h3>
<p class="normal"><code class="inlineCode">StackLayout</code> organizes <a id="_idIndexMarker216"/>elements in a one-dimensional stack, either horizontally or vertically. It is <a id="_idIndexMarker217"/>often used as a parent layout, which contains other child layouts. The default orientation is vertical. However, we should not use <code class="inlineCode">StackLayout</code> to generate a layout similar to a table by using nested <code class="inlineCode">StackLayout</code> horizontally and vertically. The following code shows an example of bad practice:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;StackLayout&gt;
    &lt;StackLayout Orientation="Horizontal"&gt;
        &lt;Label Text="Name:" /&gt;
        &lt;Entry Placeholder="Enter your name" /&gt;
    &lt;/StackLayout&gt;
    &lt;StackLayout Orientation="Horizontal"&gt;
        &lt;Label Text="Age:" /&gt;
        &lt;Entry Placeholder="Enter your age" /&gt;
    &lt;/StackLayout&gt;
    &lt;StackLayout Orientation="Horizontal"&gt;
        &lt;Label Text="Address:" /&gt;
        &lt;Entry Placeholder="Enter your address" /&gt;
    &lt;/StackLayout&gt;
&lt;/StackLayout&gt;
</code></pre>
<p class="normal">In the preceding code, we employed a <code class="inlineCode">StackLayout</code> as the parent layout, where the default orientation is vertical. Then, we nested multiple <code class="inlineCode">StackLayout</code> controls with a horizontal orientation to generate a form for data entry. </p>
<p class="normal">However, using nested <code class="inlineCode">StackLayouts</code> to create a layout similar to a table is not optimized for such scenarios, and it might lead to performance and layout issues. In this situation, we should utilize the <code class="inlineCode">Grid</code> control.</p>
<p class="normal"><code class="inlineCode">StackLayout</code> is <a id="_idIndexMarker218"/>a frequently<a id="_idIndexMarker219"/> used layout control. There are two sub-types of <code class="inlineCode">StackLayout</code> that help us directly design the layout horizontally or vertically.</p>
<h4 class="heading-4">HorizontalStackLayout</h4>
<p class="normal"><code class="inlineCode">HorizontalStackLayout</code> is a<a id="_idIndexMarker220"/> one-dimensional horizontal stack. For example, we <a id="_idIndexMarker221"/>can generate a row like so:</p>
<pre class="programlisting code"><code class="hljs-code">    &lt;HorizontalStackLayout&gt;
        &lt;Label Text="Name:" /&gt;
        &lt;Entry Placeholder="Enter your name" /&gt;
    &lt;/HorizontalStackLayout&gt;
</code></pre>
<h4 class="heading-4">VerticalStackLayout</h4>
<p class="normal"><code class="inlineCode">VerticalStackLayout</code> is a <a id="_idIndexMarker222"/>one-dimensional vertical stack. For example, we can display <a id="_idIndexMarker223"/>an error message after a form is submitted with an error like so:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;VerticalStackLayout&gt;
  &lt;Label Text="The Form Is Invalid" /&gt;
  &lt;Button Text="OK"/&gt;
&lt;/VerticalStackLayout&gt;
</code></pre>
<h3 class="heading-3" id="_idParaDest-98">Grid</h3>
<p class="normal"><code class="inlineCode">Grid</code> organizes<a id="_idIndexMarker224"/> elements in rows and columns. We can specify rows and columns with <a id="_idIndexMarker225"/>the <code class="inlineCode">RowDefinitions</code> and <code class="inlineCode">ColumnDefinitions</code> properties. In the previous example, we created a form where the user can enter their name, age, and address using a nested <code class="inlineCode">StackLayout</code>. We can do this in the <code class="inlineCode">Grid</code> layout like so:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="50" /&gt;
        &lt;RowDefinition Height="50" /&gt;
        &lt;RowDefinition Height="50" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Label Text="Name:" /&gt;
    &lt;Entry Grid.Column="1"
           Placeholder="Enter your name" /&gt;
    &lt;Label Grid.Row="1" Text="Age:" /&gt;
    &lt;Entry Grid.Row="1" Grid.Column="1"
           Placeholder="Enter your age" /&gt;
    &lt;Label Grid.Row="2" Text="Address:" /&gt;
    &lt;Entry Grid.Row="2"
           Grid.Column="1"
           Placeholder="Enter your address" /&gt;
&lt;/Grid&gt;
</code></pre>
<p class="normal">In the preceding example, we created a <code class="inlineCode">Grid</code> layout with two columns and three rows.</p>
<h3 class="heading-3" id="_idParaDest-99">FlexLayout</h3>
<p class="normal"><code class="inlineCode">FlexLayout</code> is similar<a id="_idIndexMarker226"/> to a <code class="inlineCode">StackLayout</code> in that it displays child elements either horizontally<a id="_idIndexMarker227"/> or vertically in a stack. The difference is a <code class="inlineCode">FlexLayout</code> can also wrap its children if there are too many to fit in a single row or column. As an example, we can create a <code class="inlineCode">FlexLayout</code> with five labels in a row. If we specify the <code class="inlineCode">Direction</code> property as <code class="inlineCode">Row</code>, these labels will be displayed in one row. We can also specify the <code class="inlineCode">Wrap</code> property, which can cause the items to wrap to the next row if there are too many items to fit in a row:</p>
<pre class="programlisting code"><code class="hljs-code">        &lt;FlexLayout Direction="Row" Wrap="Wrap"&gt;
            &lt;Label Text="Item 1" Padding="10"/&gt;
            &lt;Label Text="Item 2" Padding="10"/&gt;
            &lt;Label Text="Item 3" Padding="10"/&gt;
            &lt;Label Text="Item 4" Padding="10"/&gt;
            &lt;Label Text="Item 5" Padding="10"/&gt;
        &lt;/FlexLayout&gt;
</code></pre>
<h3 class="heading-3" id="_idParaDest-100">AbsoluteLayout</h3>
<p class="normal"><code class="inlineCode">AbsoluteLayout</code> is a layout<a id="_idIndexMarker228"/> control that enables you to position and size child elements based on<a id="_idIndexMarker229"/> X and Y coordinates in addition to width and height. It is particularly useful in scenarios where you need fine-grained control over the exact position and size of your UI elements.</p>
<p class="normal">Here are some common use <a id="_idIndexMarker230"/>cases for <code class="inlineCode">AbsoluteLayout</code>:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Overlap UI elements</strong>: <code class="inlineCode">AbsoluteLayout</code> allows you to position elements on top of others, which can create some effective visuals or display content over a background image.</li>
<li class="bulletList"><strong class="keyWord">Custom controls</strong>: If you are developing custom controls that require precise control over the layout of their components, <code class="inlineCode">AbsoluteLayout</code> should be your go-to choice.</li>
<li class="bulletList"><strong class="keyWord">Complex UI presentation</strong>: You may need to create intricate UIs that don’t fit within a standard grid or stack layout. In such scenarios, <code class="inlineCode">AbsoluteLayout</code> gives you the control required to position items accurately.</li>
<li class="bulletList"><strong class="keyWord">Positioning based on the parent size</strong>: <code class="inlineCode">AbsoluteLayout</code> allows you to position children relative to the bounds of their parent. This makes it easier to place elements at specific positions or in response to certain events.</li>
<li class="bulletList"><strong class="keyWord">Animations</strong>: If you need to animate elements, such as moving them around the screen or resizing them, <code class="inlineCode">AbsoluteLayout</code> can simplify this process by providing direct access to the location, width, and height properties of child elements.</li>
</ul>
<p class="normal">Generally speaking, there are three benefits of using <code class="inlineCode">AbsoluteLayout</code> for building layouts:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Precise control</strong>: <code class="inlineCode">AbsoluteLayout</code> provides control over the position, size, and layering of child elements, which can be beneficial when working on custom or complex UI designs.</li>
<li class="bulletList"><strong class="keyWord">Performance</strong>: Since <code class="inlineCode">AbsoluteLayout</code> doesn’t require complex calculations to arrange elements, it can offer better performance compared to other layout types, especially when dealing with a large number of child elements.</li>
<li class="bulletList"><strong class="keyWord">Responsive layouts</strong>: With the support of proportional values, <code class="inlineCode">AbsoluteLayout</code> can help create responsive designs that can scale with different screen sizes and<a id="_idIndexMarker231"/> orientations.</li>
</ul>
<p class="normal">However, it’s important to <a id="_idIndexMarker232"/>note that using <code class="inlineCode">AbsoluteLayout</code> everywhere is not recommended. It is better suited for specific scenarios where other layouts cannot meet the required design or functionality requirements. The disadvantages of <code class="inlineCode">AbsoluteLayout</code> include the difficulty of maintaining the responsive behavior of the UI and the potential for unexpected behavior when there are changes to the parent or child elements. Instead, you should use other layouts (e.g., <code class="inlineCode">Grid</code>, <code class="inlineCode">StackLayout</code>, or <code class="inlineCode">FlexLayout</code>) whenever their features are adequate for your design needs.</p>
<p class="normal">In the following example, we are creating a <code class="inlineCode">BoxView</code> control in the layout at (0, 0) with both width and height equal to <code class="inlineCode">10</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;AbsoluteLayout Margin="20"&gt;
    &lt;BoxView Color="Silver"
        AbsoluteLayout.LayoutBounds="0, 0, 10, 10" /&gt;
&lt;/AbsoluteLayout&gt;
</code></pre>
<p class="normal">We have provided an overview of <a id="_idIndexMarker233"/>layout controls. For more detailed information, please refer to the following Microsoft documentation: <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/</a>.</p>
<h2 class="heading-2" id="_idParaDest-101">Views</h2>
<p class="normal"><strong class="keyWord">Views</strong> (also known as controls) are<a id="_idIndexMarker234"/> the individual UI elements that users interact with or that display content on a screen. They are placed within layouts and, in turn, on pages. Views include basic UI controls like <code class="inlineCode">Label</code>, <code class="inlineCode">Button</code>, <code class="inlineCode">Entry</code>, and <code class="inlineCode">Image</code>, as well as more advanced UI controls, such as <code class="inlineCode">CollectionView</code>, <code class="inlineCode">ListView</code>, and <code class="inlineCode">WebView</code>.</p>
<p class="normal">Please refer to the following Microsoft document about the controls in .NET MAUI: <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/</a>.</p>
<p class="normal">In this section, we’ll go through some controls that will be frequently used in this book. </p>
<h3 class="heading-3" id="_idParaDest-102">Label</h3>
<p class="normal"><code class="inlineCode">Label</code> is used to <a id="_idIndexMarker235"/>display<a id="_idIndexMarker236"/> single-line or multi-line text. It can display text with a certain format, such as color, space, text decorations, and even HTML text. To create a <code class="inlineCode">Label</code>, we can use the simplest format, like so:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Label Text="Hello world" /&gt;
</code></pre>
<h3 class="heading-3" id="_idParaDest-103">Image</h3>
<p class="normal">In the user interface<a id="_idIndexMarker237"/> design, we usually use icons to decorate other controls or <a id="_idIndexMarker238"/>display images as backgrounds. The <code class="inlineCode">Image</code> control can display an image from a local file, a URI, an embedded resource, or a stream. The following code shows an example of how to create an <code class="inlineCode">Image</code> control in the simplest form:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Image Source="dotnet_bot.png" /&gt;
</code></pre>
<h3 class="heading-3" id="_idParaDest-104">Editor</h3>
<p class="normal">In our app, the<a id="_idIndexMarker239"/> users need to enter or edit a single line of text or multiple lines of<a id="_idIndexMarker240"/> text. We have two controls to serve this purpose: <code class="inlineCode">Editor</code> and <code class="inlineCode">Entry</code>.</p>
<p class="normal"><code class="inlineCode">Editor</code> can be used to enter or edit multiple lines of text. The following is an example of the <code class="inlineCode">Editor</code> control:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Editor Placeholder="Enter your description here" /&gt;
</code></pre>
<h3 class="heading-3" id="_idParaDest-105">Entry</h3>
<p class="normal"><code class="inlineCode">Entry</code> can be used to<a id="_idIndexMarker241"/> enter <a id="_idIndexMarker242"/>or edit a single line of text. To design a login page, we can use <code class="inlineCode">Entry</code> controls to enter a username and password. When users interact with an <code class="inlineCode">Entry</code>, the behavior of the keyboard can be customized through the <code class="inlineCode">Keyboard</code> property. </p>
<p class="normal">When users enter their passwords, the <code class="inlineCode">IsPassword</code> property can be set to reflect the typical behavior on a login page. The following is an example of a password entry:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Entry Placeholder="Enter your password" Keyboard="Text"   IsPassword="True" /&gt;
</code></pre>
<h3 class="heading-3" id="_idParaDest-106">ListView</h3>
<p class="normal">In user interface<a id="_idIndexMarker243"/> design, a common use case involves displaying a collection <a id="_idIndexMarker244"/>of data. In .NET MAUI, several controls can be utilized to display a collection of data, such as <code class="inlineCode">CollectionView</code>, <code class="inlineCode">ListView</code>, and <code class="inlineCode">CarouselView</code>. In our app, we will employ <code class="inlineCode">ListView</code> to display password entries, groups, and the contents of an entry. We will introduce the usage of <code class="inlineCode">ListView</code> when introducing <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemDetailPage</code> in <em class="chapterRef">Chapter 4</em>, <em class="italic">Exploring MVVM and Data Binding</em>.</p>
<p class="normal">With all these building blocks in place, we can construct a content page. Typically, an application consists of multiple pages implementing different functionalities. To create a functional app, we need to navigate between these pages.</p>
<p class="normal">Navigation refers to the process of moving between various pages or views within your app, enabling users to interact with multiple screens and access a range of features. Navigation is a crucial aspect of app design, as it determines the user’s journey through the app and assists them in finding the information they require. In .NET MAUI, navigation management is handled using <code class="inlineCode">NavigationPage</code>, <code class="inlineCode">TabbedPage</code>, <code class="inlineCode">Shell</code>, or custom navigation if necessary.</p>
<h1 class="heading-1" id="_idParaDest-107">Master-detail UI design</h1>
<p class="normal">There are various ways to<a id="_idIndexMarker245"/> implement navigation within an app. In our app’s navigation design, we employ the master-detail pattern.</p>
<p class="normal">The master-detail pattern is a widely utilized user interface design approach. Many examples of it can be found in frequently used apps. For instance, in the Mail app on Windows, a list of emails is displayed in the master view along with the details of the selected email:</p>
<figure class="mediaobject"><img alt="Figure 3.2: Mail in Windows" height="495" src="img/B21554_03_04.png" width="825"/></figure>
<p class="packt_figref">Figure 3.4: Mail in Windows</p>
<p class="normal">In <em class="italic">Figure 3.4</em>, three <a id="_idIndexMarker246"/>panels are present in the design. The left panel resembles a navigation drawer. When selecting a folder from the left panel, a list of emails is shown in the middle panel. The currently selected email is displayed in the right panel.</p>
<div><p class="normal"><strong class="keyWord">Note</strong></p>
<p class="normal"><strong class="keyWord">Navigation drawers</strong> provide <a id="_idIndexMarker247"/>access to destinations and app functionality, such as the menu in the desktop environment. It typically slides in from the left and is triggered by tapping an icon in the top-left corner of the screen. It displays a list of choices to navigate to and is widely used in mobile and web user interface design. Xamarin.Forms and .NET MAUI <code class="inlineCode">Shell</code> use navigation drawers as their top-level navigation methods.</p>
</div>
<p class="normal">The original KeePass UI design, shown in <em class="italic">Figure 3.5</em>, also uses three panels (left, right, and bottom) on the main page. The left panel is a classic tree view that acts like a navigation drawer. The right panel is used to display the list of password entries, while the bottom panel serves<a id="_idIndexMarker248"/> to exhibit the details of an entry:</p>
<figure class="mediaobject"><img alt="Figure 3.3: KeePass UI design" height="586" src="img/B21554_03_05.png" width="825"/></figure>
<p class="packt_figref">Figure 3.5: KeePass UI design</p>
<p class="normal">The master-detail pattern works well on a wide range of device types and display sizes.</p>
<p class="normal">Considering different display sizes, two popular modes can be used:</p>
<ul>
<li class="bulletList">Side-by-side</li>
<li class="bulletList">Stacked</li>
</ul>
<h2 class="heading-2" id="_idParaDest-108">Side-by-side</h2>
<p class="normal">When ample <a id="_idIndexMarker249"/>horizontal space is available on a large display, the side-by-side approach tends to be a sensible choice. The Mail app in <em class="italic">Figure 3.4</em> and the KeePass app in <em class="italic">Figure 3.5</em> serve as good examples. In this mode, both the master view and the detail view can be seen simultaneously.</p>
<h2 class="heading-2" id="_idParaDest-109">Stacked</h2>
<p class="normal">When using a <a id="_idIndexMarker250"/>mobile device, the screen size is typically smaller, with the vertical space being larger than the horizontal one. In such instances, the stacked approach is more suitable.</p>
<p class="normal">In the stacked mode, the master view occupies the entire screen space. Upon making a selection, the detail view then takes up the full screen space:</p>
<figure class="mediaobject"><img alt="" height="486" src="img/B21554_03_06.png" width="825"/></figure>
<p class="packt_figref">Figure 3.6: PassXYZ.Vault</p>
<p class="normal">In <em class="italic">Figure 3.6</em>, we can observe the app navigation from the user’s perspective. We have a list of flyout items to choose from:</p>
<ul>
<li class="bulletList"><strong class="keyWord">About</strong></li>
<li class="bulletList"><strong class="keyWord">Browse</strong></li>
<li class="bulletList"><strong class="keyWord">Logout</strong></li>
</ul>
<p class="normal">Upon selecting <strong class="keyWord">Browse</strong>, we view the list of items on the master page (<code class="inlineCode">ItemsPage</code>). From this page, if we choose an item, we will go to the item’s detail page (<code class="inlineCode">ItemDetailPage</code>). If we want to <a id="_idIndexMarker251"/>select another item, we must return to the master page and make another selection.</p>
<p class="normal">We will discuss flyout items in <em class="chapterRef">Chapter 5</em>, <em class="italic">Navigation Using .NET MAUI Shell and NavigationPage</em>. In this section, we will examine the implementation of <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemDetailPage</code>. However, before delving into the specifics, let’s explore layouts, which serve as containers for user interface elements.</p>
<h2 class="heading-2" id="_idParaDest-110">Navigation in the master-detail UI design</h2>
<p class="normal">As shown in <em class="italic">Figure 3.6</em>, we <a id="_idIndexMarker252"/>employ a stacked master-detail pattern in our navigation scheme. There is a flyout menu to display a list of pages. Within this list of pages, a page of the <code class="inlineCode">ItemsPage</code> type is utilized to display a list of password entries. When users select an entry, details about the password entry are shown in <code class="inlineCode">ItemDetailPage</code>.</p>
<p class="normal">Let’s review the implementation of <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemDetailPage</code>.</p>
<h3 class="heading-3" id="_idParaDest-111">ItemDetailPage</h3>
<p class="normal">In our <a id="_idIndexMarker253"/>app, <code class="inlineCode">ItemDetailPage</code> serves <a id="_idIndexMarker254"/>as the detail page of the master-detail pattern, displaying an item’s content. In <code class="inlineCode">ItemDetailPage</code>, we essentially present the <code class="inlineCode">Item</code> data model. Although it appears quite simple for now, we will gradually enhance it throughout this book:</p>
<pre class="programlisting code"><code class="hljs-code">using System;
namespace PassXYZ.Vault.Models {
    public class Item {
        public string Id { get; set; }
        public string Text { get; set; }
        public string Description { get; set; }
    }
}
</code></pre>
<p class="packt_figref">Listing 3.3: <code class="inlineCode">Item.cs</code> (<a href="https://epa.ms/Item3-3">https://epa.ms/Item3-3</a>)</p>
<p class="normal">As shown in <em class="italic">Listing 3.3</em>, the <code class="inlineCode">Item</code> class includes three properties: <code class="inlineCode">ID</code>, <code class="inlineCode">Text</code>, and <code class="inlineCode">Description</code>. The <code class="inlineCode">Item</code> instance is loaded by the <code class="inlineCode">LoadItemId</code> function in <code class="inlineCode">ItemDetailViewModel</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">  public async void LoadItemId(string itemId)
  {
    if (itemId == null) { 
      throw new ArgumentNullException(nameof(itemId)); }
    var item = await dataStore.GetItemAsync(itemId);
    if (item == null) { 
      logger.LogDebug("cannot find {itemId}", itemId); 
      return; }
    Id = item.Id;
    Name = item.Name;
    Description = item.Description;
  }
</code></pre>
<p class="normal">In <code class="inlineCode">LoadItemId</code>, the <code class="inlineCode">GetItemAsync</code> method of the <code class="inlineCode">IDataStore</code> interface is invoked to obtain the item by its ID.</p>
<p class="normal">After loading <a id="_idIndexMarker255"/>the item, we can present the data <a id="_idIndexMarker256"/>to the user in <code class="inlineCode">ItemDetailPage.xaml</code>, as shown in <em class="italic">Listing 3.4</em>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  x:Class="PassXYZ.Vault.Views.ItemDetailPage"
  Title="{Binding Title}"&gt;
  &lt;StackLayout Spacing="20" Padding="15"&gt;
    &lt;Label Text="Name:" FontSize="Medium" /&gt;
    &lt;Label Text="{Binding Name}" FontSize="Small"/&gt;
    &lt;Label Text="Description:" FontSize="Medium" /&gt;
    &lt;Label Text="{Binding Description}" FontSize="Small"/&gt;
  &lt;/StackLayout&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="packt_figref">Listing 3.4: <code class="inlineCode">ItemDetailPage.xaml</code> (<a href="https://epa.ms/ItemDetailPage3-4">https://epa.ms/ItemDetailPage3-4</a>)</p>
<p class="normal"><em class="italic">Listing 3.4</em> represents the XAML file of <code class="inlineCode">ItemDetailPage</code>. The item detail content page includes an instance of <code class="inlineCode">StackLayout</code> and four instances of <code class="inlineCode">Label</code>.</p>
<p class="normal">Within <code class="inlineCode">StackLayout</code>, the <a id="_idIndexMarker257"/>default orientation<a id="_idIndexMarker258"/> is <code class="inlineCode">Vertical</code>, causing the <code class="inlineCode">Label</code> controls to be arranged vertically on the item detail page (refer to <em class="italic">Figure 3.4</em>). Both <code class="inlineCode">Name</code> and <code class="inlineCode">Description</code> are linked to the model data in the view model through data binding, which will be introduced in the next chapter.</p>
<h3 class="heading-3" id="_idParaDest-112">ItemsPage</h3>
<p class="normal"><code class="inlineCode">ItemsPage</code> serves as the <a id="_idIndexMarker259"/>master page of the master-detail pattern in our app, presenting a list of items<a id="_idIndexMarker260"/> that users can browse.</p>
<p class="normal"><em class="italic">Listing 3.5</em> showcases the implementation of <code class="inlineCode">ItemsPage</code>. To display a list of items, a <code class="inlineCode">ListView</code> control is employed. <code class="inlineCode">ListView</code> is a control designed for displaying a scrollable vertical list of selectable data items:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  x:Class="PassXYZ.Vault.Views.ItemsPage"                  //(1)
  Title="{Binding Title}"
  xmlns:local="clr-namespace:PassXYZ.Vault.ViewModels"     //(5)
  xmlns:model="clr-namespace:PassXYZ. Vault.Models"        //(6)
  x:DataType="local:ItemsViewModel"                        //(2)
  x:Name="BrowseItemsPage"&gt;                                //(3)
  
  &lt;ContentPage.ToolbarItems...&gt;
  &lt;StackLayout&gt;
    &lt;ListView x:Name="ItemsListView"                       //(4)
      ItemsSource="{Binding Items}"
      VerticalOptions="FillAndExpand"
      HasUnevenRows="False"
      RowHeight="84"
      RefreshCommand="{Binding LoadItemsCommand}"
      IsPullToRefreshEnabled="true"
      IsRefreshing="{Binding IsBusy, Mode=OneWay}"
      CachingStrategy="RetainElement"
      ItemSelected="OnItemSelected"&gt;
        &lt;ListView.ItemTemplate&gt;
          &lt;DataTemplate...&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
  &lt;/StackLayout&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="packt_figref">Listing 3.5: <code class="inlineCode">ItemsPage.xaml</code> (<a href="https://epa.ms/ItemsPage3-5">https://epa.ms/ItemsPage3-5</a>)</p>
<p class="normal">Let’s examine this code in greater detail:</p>
<p class="normal"><strong class="keyWord">(1)</strong> <code class="inlineCode">x:Class</code>: This is utilized to define the class name of a partial class shared between the markup and code-behind file. <code class="inlineCode">PassXYZ.Vault.Views.ItemsPage</code> is the class name defined here.</p>
<p class="normal"><strong class="keyWord">(3)</strong> <code class="inlineCode">x:Name</code>: While <code class="inlineCode">x:Class</code> defines the class name in XAML, <code class="inlineCode">x:Name</code> defines the instance name. We can refer to the <code class="inlineCode">BrowseItemsPage</code> instance name in the code-behind file.</p>
<p class="normal"><strong class="keyWord">(2)</strong> <code class="inlineCode">x:DataType</code>: Setting <code class="inlineCode">x:DataType</code> to the appropriate type defined in the view model enables compiled binding, which can significantly improve performance. The view model referred to here is <code class="inlineCode">ItemsViewModel</code>.</p>
<p class="normal">In addition to the <a id="_idIndexMarker261"/>standard <a id="_idIndexMarker262"/>namespace, we have defined two more namespaces so that we can reference the objects in the view model <strong class="keyWord">(5)</strong> and model <strong class="keyWord">(6)</strong>. We will discuss the view model and model in the next chapter.</p>
<p class="normal"><strong class="keyWord">(4)</strong> We define a <code class="inlineCode">ListView</code> control for displaying the list of items. The <code class="inlineCode">ListView</code> control comprises numerous properties. The following properties must be defined when using the <code class="inlineCode">ListView</code> control:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ItemsSource</code>, of the <code class="inlineCode">IEnumerable</code> type, specifies the collection of items to display. It binds to <code class="inlineCode">Items</code>, which is defined in the view model.</li>
<li class="bulletList"><code class="inlineCode">ItemTemplate</code>, of the <code class="inlineCode">DataTemplate</code> type, specifies the template to apply to each item in the collection of items to be displayed.</li>
</ul>
<p class="normal">In <em class="italic">Listing 3.5</em>, <code class="inlineCode">DataTemplate</code> is collapsed. Upon expanding it, we will see the following code snippet. This default implementation comes from the Visual Studio template. The appearance of this data template is inadequate, and we will enhance it later:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;DataTemplate&gt;
    &lt;ViewCell&gt;
        &lt;StackLayout Padding="10" x:DataType="model:Item"&gt;
            &lt;Label Text="{Binding Text}"
              LineBreakMode="NoWrap"
              Style="{DynamicResource ListItemTextStyle}"
              FontSize="16" /&gt;
            &lt;Label Text="{Binding Description}"
              LineBreakMode="NoWrap"
              Style="{DynamicResource
                  ListItemDetailTextStyle}"
              FontSize="13" /&gt;
        &lt;/StackLayout&gt;
    &lt;/ViewCell&gt;
&lt;/DataTemplate&gt;
</code></pre>
<p class="normal">This <code class="inlineCode">DataTemplate</code> implementation comprises a <code class="inlineCode">ViewCell</code> consisting of a <code class="inlineCode">StackLayout</code> with two <code class="inlineCode">Label</code> controls, as seen in the preview in <em class="italic">Figure 3.6</em>.</p>
<p class="normal">The <code class="inlineCode">DataTemplate</code> implementation<a id="_idIndexMarker263"/> must reference a <code class="inlineCode">Cell</code> class to display items. There are built-in cells<a id="_idIndexMarker264"/> available, as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">TextCell</code>, which displays primary and secondary text on separate lines.</li>
<li class="bulletList"><code class="inlineCode">ImageCell</code>, which exhibits an image alongside primary and secondary text on separate lines.</li>
<li class="bulletList"><code class="inlineCode">SwitchCell</code>, which showcases text and a switch that can be switched on or off.</li>
<li class="bulletList"><code class="inlineCode">EntryCell</code>, which presents a label and text that’s editable.</li>
<li class="bulletList"><code class="inlineCode">ViewCell</code>, which is a custom cell with an appearance defined by a <code class="inlineCode">View</code>. This cell type should be utilized when fully customizing the appearance of each item in a <code class="inlineCode">ListView</code>.</li>
</ul>
<p class="normal">Typically, <code class="inlineCode">SwitchCell</code> and <code class="inlineCode">EntryCell</code> are only used in a <code class="inlineCode">TableView</code> and can’t be employed in a <code class="inlineCode">ListView</code>.</p>
<pre>Name</code> and <code class="inlineCode">Description</code> is not straightforward. In KeePass, an icon is usually attached to the password entry. By using a new data template, we can enhance its appearance, like so:</pre>
<pre class="programlisting code"><code class="hljs-code">&lt;DataTemplate&gt;
  &lt;ViewCell&gt;
    &lt;Grid Padding="10" x:DataType="model:Item" &gt;             //(1)
      &lt;Grid.RowDefinitions&gt;                                  //(2)
        &lt;RowDefinition Height="32" /&gt;
        &lt;RowDefinition Height="32" /&gt;
      &lt;/Grid.RowDefinitions&gt;
      &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
      &lt;/Grid.ColumnDefinitions&gt;
      &lt;Grid Grid.RowSpan="2" Padding="10"&gt;                   //(3)
        &lt;Grid.ColumnDefinitions&gt;
          &lt;ColumnDefinition Width="32" /&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Image Grid.Column="0" Source="icon.png"
          HorizontalOptions="Fill" VerticalOptions="Fill" /&gt;
      &lt;/Grid&gt;
      &lt;Label Text="{Binding Text}" Grid.Column="1"
        LineBreakMode="NoWrap" MaxLines="1"
        Style="{DynamicResource ListItemTextStyle}"
        FontAttributes="Bold" FontSize="Small" /&gt;
      &lt;Label Text="{Binding Description}"
        Grid.Row="1" Grid.Column="1"
        LineBreakMode="TailTruncation" MaxLines="1"
        Style="{DynamicResource ListItemDetailTextStyle}"
        FontSize="Small" /&gt;
    &lt;/Grid&gt;
  &lt;/ViewCell&gt;
&lt;/DataTemplate&gt;
</code></pre>
<p class="normal">Let’s examine this <a id="_idIndexMarker265"/>code in<a id="_idIndexMarker266"/> more detail:</p>
<p class="normal"><strong class="keyWord">(1)</strong> To improve <code class="inlineCode">ViewCell</code>'s appearance, we replaced the <code class="inlineCode">StackLayout</code> with <code class="inlineCode">Grid</code> as the layout class. <code class="inlineCode">Grid</code> is a layout that organizes its children into rows and columns.</p>
<p class="normal"><strong class="keyWord">(2)</strong> Since we want to display two rows with an icon on the left, we created a grid containing two columns and two rows, as shown here:</p>
<figure class="mediaobject"><img alt="" height="165" src="img/B21554_03_07.png" width="535"/></figure>
<p class="packt_figref">Figure 3.7: Layout of an entry or a group</p>
<p class="normal">We can use different font styles for <code class="inlineCode">Name</code> and <code class="inlineCode">Description</code> so that users can easily differentiate them visually.</p>
<p class="normal"><strong class="keyWord">(3)</strong> To center the icon within the first two columns, we merged the two rows into a <code class="inlineCode">Grid</code> control. The attached <code class="inlineCode">Grid.RowSpan</code> property can be used to merge rows.</p>
<p class="normal">A <code class="inlineCode">Grid</code> can function as a parent layout containing other child layouts. To maintain a specific size for the icon and position it at the center of the merged cell, we can use another <code class="inlineCode">Grid</code> as the parent of the <code class="inlineCode">Image</code> control. This child <code class="inlineCode">Grid</code> contains only one row and one column with a specific size.</p>
<p class="normal">In the <code class="inlineCode">Image</code> control, we can use a default image (<code class="inlineCode">icon.png</code>) from the resource. Customization can be applied once we introduce our model in the next chapter.</p>
<p class="normal">In the <a id="_idIndexMarker267"/>customized <code class="inlineCode">ViewCell</code>, we can <a id="_idIndexMarker268"/>display a key-value pair of data with an associated icon.</p>
<p class="normal">Refer to <em class="italic">Figure 3.8</em> for the improved preview:</p>
<figure class="mediaobject"><img alt="" height="893" src="img/B21554_03_08.png" width="412"/></figure>
<p class="packt_figref">Figure 3.8: Improved ItemsPage</p>
<p class="normal">With this knowledge, we’ve covered the fundamentals of user interface design using XAML. A common challenge in user interface design is providing support for multiple languages. In the remainder of this chapter, we will learn how to support multiple languages when designing user interfaces in XAML.</p>
<h1 class="heading-1" id="_idParaDest-113">Supporting multiple languages – localization</h1>
<p class="normal">To accommodate multiple<a id="_idIndexMarker269"/> languages, we can utilize the .NET built-in mechanism for localizing applications. In .NET, resources files can be used to support localization by consolidating all text and other resources required for an application’s user interface in one location. In a XAML file, we can use the <code class="inlineCode">x:Static</code> markup extension to access the string defined in resources files.</p>
<h2 class="heading-2" id="_idParaDest-114">Creating a .resx file</h2>
<p class="normal">We can generate a <a id="_idIndexMarker270"/>resources file for each supported language. Resources files are XML files with a <code class="inlineCode">.resx</code> extension, which are compiled into binary resources files during the build process. To add a resources file, right-click the project node and select <strong class="screenText">Add &gt; New Item... &gt; Resources File</strong>, as shown in <em class="italic">Figure 3.9</em>:</p>
<figure class="mediaobject"><img alt="Figure 3.7: Creating a Resources File" height="471" src="img/B21554_03_09.png" width="825"/></figure>
<p class="packt_figref">Figure 3.9: Creating a resources file</p>
<p class="normal">We can create the <code class="inlineCode">Resources.resx</code> resources file in the <code class="inlineCode">Properties</code> folder.</p>
<p class="normal">To support <a id="_idIndexMarker271"/>different cultures, we can add additional resources files with cultural information as part of the resources file’s name:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Resources.resx</code>: The resources file for the default culture, which we will set to <strong class="keyWord">en-US</strong> (US English).</li>
<li class="bulletList"><code class="inlineCode">Resources.zh-Hans.resx</code>: The resources file for the <strong class="keyWord">zh-Hans</strong> culture, which is simplified Chinese.</li>
<li class="bulletList"><code class="inlineCode">Resources.zh-Hant.resx</code>: The resources file for the <strong class="keyWord">zh-Hant</strong> culture, which is traditional Chinese.</li>
</ul>
<p class="normal">Upon creating the resources file, the following <code class="inlineCode">ItemGroup</code> will be added to the project file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ItemGroup&gt;
  &lt;Compile Update="Properties\Resources.Designer.cs"&gt;
    &lt;DesignTime&gt;True&lt;/DesignTime&gt;
      &lt;AutoGen&gt;True&lt;/AutoGen&gt;
      &lt;DependentUpon&gt;Resources.resx&lt;/DependentUpon&gt;
  &lt;/Compile&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup&gt;
  &lt;EmbeddedResource Update="Properties\Resources.resx"&gt;
    &lt;Generator&gt;ResXFileCodeGenerator&lt;/Generator&gt;
    &lt;LastGenOutput&gt;Resources.Designer.cs&lt;/LastGenOutput&gt;
  &lt;/EmbeddedResource&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p class="normal">To edit a resources file, click on the resources file and edit it in the resource editor, as shown in <em class="italic">Figure 3.10</em>:</p>
<figure class="mediaobject"><img alt="Figure 3.8: Resource editor" height="187" src="img/B21554_03_10.png" width="825"/></figure>
<p class="packt_figref">Figure 3.10: Resource editor</p>
<p class="normal">The resources file includes a list of key-value pairs for different languages:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">Name </code>field represents the string name that can be referenced in both XAML and C# files.</li>
<li class="bulletList">The <code class="inlineCode">Value</code> field contains the language-specific string that will be used according to the system language settings.</li>
<li class="bulletList">The <code class="inlineCode">Comment</code> field is employed as a remark for the key-value pair.</li>
</ul>
<p class="normal">To specify the default<a id="_idIndexMarker272"/> language, we need to set the value of <code class="inlineCode">NeutralLanguage</code> in <code class="inlineCode">&lt;PropertyGroup&gt;</code> in the project file, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
…
&lt;NeutralLanguage&gt;en-US&lt;/NeutralLanguage&gt;
…
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">In our project, we will use US English as the default culture, so <code class="inlineCode">NeutralLanguage</code> is set to <code class="inlineCode">en-US</code>.</p>
<h2 class="heading-2" id="_idParaDest-115">Localizing text</h2>
<p class="normal">Once the resources files have <a id="_idIndexMarker273"/>been configured, we can use localized content in our XAML file or C# files. Currently, our project contains five content pages. Let’s modify <code class="inlineCode">AboutPage</code> to support localization, as shown in <em class="italic">Listing 3.6</em>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  x:Class="PassXYZ.Vault.Views.AboutPage"
  xmlns:res="clr-namespace:PassXYZ.Vault.Properties"              //(1)
  Title="{Binding Title}"&gt;
  &lt;ContentPage.Resources...&gt;
  &lt;ScrollView&gt;
    &lt;StackLayout Margin="20"&gt;
      &lt;Grid Padding="10"...&gt;
      &lt;StackLayout Padding="10" &gt;
        &lt;Label HorizontalOptions="Center"
          Text="{x:Static res:Resources.Appname}"                 //(2)
          FontAttributes="Bold" FontSize="22" /&gt;
        &lt;Label x:Name="AppVersion" 
          HorizontalOptions="Center"
          FontSize="Small" /&gt;
        &lt;Grid HorizontalOptions="Center"...&gt;
        &lt;StackLayout...&gt;
      &lt;/StackLayout&gt;
    &lt;/StackLayout&gt;
  &lt;/ScrollView&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="packt_figref">Listing 3.6: <code class="inlineCode">AboutPage.xaml</code> (<a href="https://epa.ms/AboutPage3-6">https://epa.ms/AboutPage3-6</a>)</p>
<p class="normal">Text localization is done using the generated <code class="inlineCode">Resources</code> class. This class is named based on the default resources file name. In <em class="italic">Listing 3.6</em> <code class="inlineCode">AboutPage.xaml</code>, we added a new namespace <strong class="keyWord">(1)</strong> for the <code class="inlineCode">Resources</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">xmlns:res ="clr-namespace:PassXYZ.Vault.Properties "
</code></pre>
<p class="normal">In the <code class="inlineCode">Label</code> control <strong class="keyWord">(2)</strong>, to display<a id="_idIndexMarker274"/> our application name, we can refer to the resource string using the <code class="inlineCode">x:Static</code> XAML markup extension, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">        &lt;Label HorizontalOptions="Center"
          Text="{x:Static res:Resources.Appname}"
          FontAttributes="Bold" FontSize="22" /&gt;
</code></pre>
<p class="normal">In <em class="italic">Listing 3.6</em>, we collapsed most of the source code for conciseness. Please refer to the short URL of this book’s GitHub repository to review the full source code.</p>
<p class="normal">Localized text can be used in both XAML and C#. To use a resource string in C#, we can examine the <code class="inlineCode">Title</code> property in <em class="italic">Listing 3.6</em>. The <code class="inlineCode">Title</code> property of <code class="inlineCode">AboutPage</code> is connected to the <code class="inlineCode">Title</code> property in the <code class="inlineCode">AboutViewModel</code> class. Let’s see how we can use a resource string in <em class="italic">Listing 3.7</em>:</p>
<pre class="programlisting code"><code class="hljs-code">using System;
using System.Windows.Input;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Maui.Controls;
<strong class="hljs-keyword-slc">using</strong><strong class="hljs-slc"> PassXYZ.Vault.Properties;</strong>                                   //(1)
namespace PassXYZ.Vault.ViewModels
{
  public partial class AboutViewModel : ObservableObject
  {
    [ObservableProperty]
    private string? title = <strong class="hljs-slc">Properties.Resources.About</strong>;           //(2)
    [RelayCommand]
private async Task OpenWeb()...
public string GetStoreName()...
    public DateTime GetStoreModifiedTime()...
  }
}
</code></pre>
<p class="packt_figref">Listing 3.7: <code class="inlineCode">AboutViewModel.cs</code> (<a href="https://epa.ms/AboutViewModel3-7">https://epa.ms/AboutViewModel3-7</a>)</p>
<p class="normal">As shown in <em class="italic">Listing 3.7</em>, <strong class="keyWord">(1)</strong> we<a id="_idIndexMarker275"/> added the <code class="inlineCode">PassXYZ.Vault.Properties</code> namespace first. <strong class="keyWord">(2)</strong> We refer to the resource string as <code class="inlineCode">Properties.Resources.About</code>.</p>
<p class="normal">After we update <code class="inlineCode">AboutPage</code> with localization support, we can test it in the supported languages, as shown in <em class="italic">Figure 3.11</em>:</p>
<figure class="mediaobject"><img alt="" height="565" src="img/B21554_03_11.png" width="825"/></figure>
<p class="packt_figref">Figure 3.11: AboutPage in different languages</p>
<p class="normal">In <code class="inlineCode">AboutPage</code>, many <a id="_idIndexMarker276"/>resource strings are used for localization. In <em class="italic">Listing 3.6</em> and <em class="italic">Listing 3.7</em>, we collapsed most of the code; you can refer to the short URL for this book’s GitHub repository to review the source code online.</p>
<div><p class="normal"><strong class="keyWord">.NET MVVM Community Toolkit</strong></p>
<p class="normal">The .NET MVVM Community Toolkit<a id="_idIndexMarker277"/> is a comprehensive collection of helpers and tools aimed at simplifying the development process of applications following the <strong class="keyWord">Model-View-View-Model</strong> (<strong class="keyWord">MVVM</strong>) pattern<a id="_idIndexMarker278"/> based on .NET libraries. </p>
<p class="normal">The toolkit provides a wide array of features aimed at reducing boilerplate code, including converters, helpers, behaviors, commands, and services aimed at facilitating communication between classes in the MVVM pattern.</p>
<p class="normal">More details about the .NET MVVM Community Toolkit will be introduced in the next chapter.</p>
</div>
<h1 class="heading-1" id="_idParaDest-116">Summary</h1>
<p class="normal">In this chapter, we explored XAML syntax and applied the knowledge we gained to enhance the appearance of <code class="inlineCode">ItemsPage</code>. We will persist in refining the user interface of other pages throughout this book. To support multiple languages, we delved into .NET localization and created multiple resources files for the <code class="inlineCode">US-en</code>, <code class="inlineCode">zh-Hans</code>, and <code class="inlineCode">zh-Hant</code> languages. Additionally, we discovered how to access strings in the resources files using the XAML markup extension. Lastly, we utilized <code class="inlineCode">AboutPage</code> as an example to demonstrate the use of localized text in both XAML and C#.</p>
<p class="normal">In the next chapter, we will continue improving our app by introducing MVVM and data binding.</p>
<h1 class="heading-1" id="_idParaDest-117">Further reading</h1>
<ul>
<li class="bulletList">.NET Multi-platform App UI documentation: <a href="https://learn.microsoft.com/en-us/dotnet/maui/">https://learn.microsoft.com/en-us/dotnet/maui/</a></li>
<li class="bulletList">XAML - .NET MAUI: <a href="https://learn.microsoft.com/en-us/dotnet/maui/xaml/">https://learn.microsoft.com/en-us/dotnet/maui/xaml/</a></li>
<li class="bulletList">XAML markup extensions: <a href="https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions">https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions</a></li>
<li class="bulletList">KeePass – An open-source password manager: <a href="https://keepass.info/">https://keepass.info/</a></li>
</ul>
<h1 class="heading-1">Leave a review!</h1>
<p class="normal"><em class="italic">Enjoying this book? Help readers like you by leaving an Amazon review. Scan the QR code below for a 40% discount code.</em></p>
<p class="normal"><img alt="" height="182" src="img/Leave_a_review_QR.png" width="182"/></p>
<p class="normal"><em class="italic">*Limited Offer</em></p>
</div>
</div></body></html>