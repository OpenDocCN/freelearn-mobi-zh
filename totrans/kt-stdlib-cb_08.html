<html><head></head><body>
        

                            
                    <h1 class="header-title">Best Practices for the Android, JUnit, and JVM UI Frameworks</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Clean and safe <kbd>View</kbd> binding with the Android Extensions plugin</li>
<li>Applying coroutines for asynchronous UI programming on Android, JavaFX, and Swing</li>
<li>Easy class-serialization on Android using the <kbd>@Parcelize</kbd> annotation</li>
<li>Implementing a custom property delegate that provides lifecycle-aware values</li>
<li>Easy operations on <kbd>SharedPreferences</kbd></li>
<li>Less boilerplate <kbd>Cursor</kbd> data parsing</li>
<li>Mocking dependencies with the Mockito Kotlin library</li>
<li>Verifying function invocations</li>
<li>Unit tests for Kotlin coroutines</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>The current chapter is going to address problems specific to the popular frameworks that Kotlin uses most often. In general, it is going to focus on Android platform-specific aspects and asynchronous UI programming with coroutines both on the Android and JVM frameworks, such as JavaFX and Swing. It will also guide you through writing effective unit tests for the JVM platform using the JUnit framework (<a href="https://junit.org/junit5/">https://junit.org/junit5/</a>). The recipes related to unit-testing will include also more advanced topics, such as mocking dependencies with the <kbd>mockito-kotlin</kbd> (<a href="https://github.com/nhaarman/mockito-kotlin">https://github.com/nhaarman/mockito-kotlin</a>) library, testing asynchronous code based on the coroutines framework, and working with assertions provided by the standard library.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Clean and safe view-binding with the Android Extensions plugin</h1>
                
            
            
                
<p>In this recipe, we are going to explore the view-binding feature provided by the Kotlin Android Extensions plugin. It allows us to obtain references to <kbd>View</kbd> type elements declared in the XML layout files in an easy and robust way, without using the original <kbd>findViewById()</kbd> function. We are going to declare a <kbd>TextView</kbd> element in the <kbd>Activity</kbd> layout and obtain a reference to it in order to display a sample text in it. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In order to make use of the Kotlin Android Extensions plugin, we need to enable it in the Android project module-level <kbd>build.gradle</kbd> script by adding the following declaration:</p>
<pre><strong>apply plugin: 'kotlin-android-extensions'</strong></pre>
<p>You can examine the implementation and configuration of recipes related to the Android framework in the AndroidSamples project available in this book's GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow the Android-related recipes, you just need to create a new project in Android Studio.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new Activity in the project:</li>
</ol>
<pre style="padding-left: 60px"><strong>class MainActivity : AppCompatActivity() {}</strong></pre>
<ol start="2">
<li>Implement the UI layout in the <kbd>activity_main.xml</kbd> file under the <kbd>src/main/res/layout/</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;androidx.constraintlayout.widget.ConstraintLayout     xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&gt;</strong><br/><br/><strong>    &lt;TextView<br/>        android:id="@+id/text_field"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:textSize="56sp"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintLeft_toLeftOf="parent"<br/>        app:layout_constraintRight_toRightOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;</strong><br/><br/><strong>&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</strong></pre>
<ol start="3">
<li>Set the layout for the <kbd>MainActivity</kbd> inside the <kbd>onCreate()</kbd> hook function:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity : AppCompatActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        <strong>setContentView(R.layout.activity_main)</strong><br/>    }<br/>}</pre>
<ol start="4">
<li>Get a reference to the <kbd>TextView</kbd> declared in the XML layout and display a sample text in it:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity : AppCompatActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        <strong>text_field.text = "Bonjour!"</strong><br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As the result, the <kbd>MainActivity</kbd> class is going to display a greeting inside <kbd>TextView</kbd>:</p>
<div><img src="img/e9734da9-b156-4c59-8934-228b2aca2451.png" style="width:21.17em;height:40.25em;"/></div>
<p>Under the hood, the Android Extensions plugin has generated extension properties for the <kbd>MainActivity</kbd> class for each of the <kbd>View</kbd> elements declared in the <kbd>activity_main.xml</kbd> file. The generated properties have the same names as the IDs of their corresponding layout elements.</p>
<p>Compared to the standard way of obtaining references to <kbd>View</kbd> classes using the <kbd>findViewById(): View</kbd> function, the Android Extensions binding mechanism is much cleaner and more painless. It is also safe and robust as it does not require casting the <kbd>View</kbd> type to specific subclasses, and it regenerates all the extension properties whenever any changes are made to the XML layout files. Also, compared to other third-party view-binding libraries, it is much easier to use as it doesn't require any manual property declarations. It just works seamlessly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>By default, the Android Extensions plugin supports the <kbd>Activity</kbd>, <kbd>Fragment</kbd>, and <kbd>View</kbd> type containers where you can use the automatic view binding mechanism out of the box. However, there is a possibility to use any class as an Android Extensions container, by implementing the <kbd>LayoutContainer</kbd> interface. For example, it can be used in the <kbd>RecyclerView.ViewHolder</kbd> subclasses:</p>
<pre>class ViewHolder(override val containerView: View) : ViewHolder(containerView),<br/>    LayoutContainer {  <br/>    fun setupItemView(title: String) {  itemTitle.text = "Hello World!"  } <br/>}</pre>
<p>You can learn more about Android Extensions applications in the official reference: <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">https://kotlinlang.org/docs/tutorials/android-plugin.html</a>.<a href="https://kotlinlang.org/docs/tutorials/android-plugin.html"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying coroutines for asynchronous UI programming on Android, JavaFX, and Swing</h1>
                
            
            
                
<p>Most of the JVM-based GUI frameworks have one thing in common—they run a specific thread that is responsible for updating the state of the application's UI. In this recipe, we're going to learn how to execute tasks asynchronously in the background and switch to the UI thread to update the GUI of the app. We're going to create a simple counter, which is going to display the incremented integer value every second. The mechanism responsible for infinite counter-incrementing should operate in the background, however, it should switch to the UI thread context every time it needs to perform an update of the UI state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The first step to start working with Kotlin Coroutines is to add the core-framework dependency to the project:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.23.3' </pre>
<p>Apart from the Coroutines core dependency, we will need to add one of the framework-specific coroutines sub-modules, providing the coroutine-context implementation responsible for dispatching the coroutine on the UI thread. You can find the list of coroutines' framework sub-modules in the official guide: <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md">https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md</a>. In this recipe, we are going to target the Android platform, however, you can easily port the sample code to one of the supported frameworks such as, Android, Swing, or JavaFx.</p>
<p>You can examine the implementation and configuration of recipes related to the Android framework in the AndroidSamples project, available in the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow Android-related recipes, you just need to create a new project in Android Studio.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Add a new Activity subclass:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity: AppCompatActivity() {}</pre>
<ol start="2">
<li>Implement the UI layout in the <kbd>activity_main.xml</kbd> file under the <kbd>src/main/res/layout/</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" &gt;</strong><br/><br/><strong>    &lt;TextView<br/>        android:id="@+id/text_field"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:textSize="56sp"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintLeft_toLeftOf="parent"<br/>        app:layout_constraintRight_toRightOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;</strong><br/><br/><strong>        &lt;Button<br/>            android:id="@+id/cancel_btn"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:text="Cancel"<br/>            app:layout_constraintBottom_toBottomOf="parent"<br/>            app:layout_constraintLeft_toLeftOf="parent"<br/>            app:layout_constraintRight_toRightOf="parent"/&gt;</strong><br/><br/><strong>&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</strong></pre>
<ol start="3">
<li>Set the layout for <kbd>MainActivity</kbd> inside the <kbd>onCreate()</kbd> hook function:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity : AppCompatActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        <strong>setContentView(R.layout.activity_main)</strong><br/>    }<br/>}</pre>
<ol start="4">
<li>Start a new coroutine running in the background, incrementing the counter every second and displaying it in the <kbd>TextView</kbd> obtained from the XML layout:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity: AppCompatActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        <strong>val job = launch {<br/></strong><strong>            var counter = 1<br/>            while (true) {</strong><br/><strong>                delay(1000)</strong><br/><strong>                counter++</strong><br/><strong>                withContext(UI) {<br/>                    text_field.text = counter.toString()</strong><br/><strong>                }<br/>            }</strong><br/>        <strong>}</strong><br/>    }<br/>}</pre>
<ol start="5">
<li>Allow coroutine-cancellation by clicking the <strong>cancel</strong> button:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity: AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        text_field.text = "Bonjour!"<br/><br/>        val job = launch {<br/>            var counter = 1<br/>            while (true) {<br/>                delay(1000)<br/>                counter++<br/>                withContext(UI) {<br/>                    text_field.text = counter.toString()<br/>                }<br/>            }<br/>        }<br/><br/><strong>        cancel_btn.setOnClickListener {<br/>            job.cancel()</strong><br/><strong>        }</strong><br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The coroutine started in the <kbd>MainActivity.onCreate()</kbd> function is running an infinite <kbd>while</kbd> loop. Each iteration starts with a one-minute delay and incrementation of the counter variable. Next, we are applying the <kbd>withContext()</kbd> function in order to update <kbd>TextView</kbd> with the new value.</p>
<p>The <kbd>withContext()</kbd> function allows us to switch to a new coroutine dispatcher, obtained from the context argument, in order to execute a block of code passed to it. It doesn't create and start a new coroutine, but it modifies the context of the parent coroutine immediately. The new dispatcher is applied only temporarily to execute a given block of code. Any further operations executed inside the coroutine scope after the <kbd>withContext()</kbd> function call will be run with the original coroutine context.</p>
<p>We are assigning a <kbd>Job</kbd> instance returned by the coroutine to the <kbd>job</kbd> variable. Next, we are setting up the listener to the cancel button. Whenever the cancel button is clicked, the <kbd>cancel()</kbd> function is invoked on the coroutine <kbd>Job</kbd> reference.</p>
<p>As the result, our <kbd>MainActivity</kbd> implementation is going to update the <kbd>TextView</kbd> value every second. Once the cancel button is clicked, the update mechanism is stopped immediately.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you're developing an application using different JVM frameworks, in order to switch to the UI thread from the background, you can use the <kbd>withContext()</kbd> function with the <kbd>JavaFx</kbd> or <kbd>Swing</kbd> constants instead of the Android <kbd>UI</kbd> context constants.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to explore the basics of the coroutines framework, you should take a look at the recipes in <a href="331a4e70-5675-4383-970c-6f5fc75421cf.xhtml" target="_blank">Chapter 7</a>, <em>Making Asynchronous Programming Great Again</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Easy class serialization on Android using the @Parcelize annotation</h1>
                
            
            
                
<p>In this recipe, we are going to make use of the <kbd>@Parcelize</kbd> annotation to simplify the implementation of the Android <kbd>Parcelable</kbd> interface, allowing us to serialize objects efficiently. <kbd>@Parcelize</kbd> is available in the Kotlin Android Extensions plugin and provides automatic code-generation for Kotlin classes that implement the <kbd>Parcelable</kbd> interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We are going to implement the Android instrumented test case in order to verify the effect of a class serialization and deserialization in action. To make use of the Android KTX library, we need to add it to the project dependencies. In our case, we will need it in the <kbd>android-test</kbd> module. We can add it with the following declaration:</p>
<pre>androidTestImplementation 'androidx.core:core-ktx:1.0.+'</pre>
<p>In order to make use of the Kotlin Android Extensions plugin, we need to enable it in the Android project module-level <kbd>build.gradle</kbd> script by adding the following declaration:</p>
<pre><strong>apply plugin: 'kotlin-android-extensions'</strong></pre>
<p>You can examine the implementation and configuration of recipes related to the Android framework in the AndroidSamples project available in the book's GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow Android-related recipes, you just need to create a new project in Android Studio.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start by creating a sample User class that implements the <kbd>Parcelable</kbd> interface using the <kbd>@Parcelize</kbd> annotation:</li>
</ol>
<pre style="padding-left: 60px">@Parcelize<br/>data class User(val name: String, val address: Address): Parcelable<br/><br/>@Parcelize<br/>data class Address(val street: String, <br/>                   val number: String, <br/>                   val city: String): Parcelable</pre>
<ol start="2">
<li>Verify serialization and deserialization of the <kbd>User</kbd> class instance by writing and reading it from the <kbd>Bundle</kbd> instance:</li>
</ol>
<pre style="padding-left: 60px">@Test<br/>fun testUserParcelisation() {<br/>    // given<br/>    val originalUser = User("Bob", Address("Rue de Paris", "123",<br/>     "Warsaw"))<br/>    val bundle = Bundle()<br/><br/>    // when<br/>    bundle.putParcelable("my_user", originalUser)<br/><br/>    // then<br/>    val deserialisedUser = bundle.get("my_user") as User<br/>    assertEquals(originalUser, deserialisedUser)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have started by defining the <kbd>User</kbd> class, which contains a property of the <kbd>Address</kbd> class. Both <kbd>User</kbd> and <kbd>Address</kbd> are decorated with the <kbd>@Parcelize</kbd> annotation. It tells the Android Extensions plugin to generate code for the <kbd>Parcelable</kbd> interface implementation. Inside the <kbd>testUserParcelisation()</kbd> function, we are creating an instance of the <kbd>User</kbd> class and serializing it using the Android <kbd>Bundle</kbd> mechanism. We are putting the original <kbd>User</kbd> class instance to the <kbd>Bundle</kbd> under the <kbd>"my_user"</kbd> key, and later we deserialize its instance by calling <kbd>bundle.get("my_user") as User</kbd>. Finally, we compare the original and deserialized <kbd>User</kbd> instances using the <kbd>assertEquals()</kbd> function.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<div><kbd>@Parcelize</kbd> handles generating the <kbd>Parcelable</kbd> implementation for the following types:<br/>
<br/>
All the primitive types, <kbd>String</kbd>, <kbd>CharSequence</kbd>, objects and enums, <kbd>Exception</kbd>, <kbd>Size</kbd>, <kbd>SizeF</kbd>, <kbd>Bundle</kbd>, <kbd>IBinder</kbd>, <kbd>IInterface</kbd>, <kbd>FileDescriptor</kbd>, <kbd>SparseArray</kbd>, <kbd>SparseIntArray</kbd>, <kbd>SparseLongArray</kbd>, and <kbd>SparseBooleanArray</kbd>. It also supports any <kbd>Serializable</kbd> types (for example, <kbd>java.util.Date</kbd>), as well as <kbd>Collection</kbd> and <kbd>Array</kbd> types. It also works with nullable types.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can learn more about the features dedicated to Android development in the Kotlin Android Extensions plugin by studying the official guide: <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">https://kotlinlang.org/docs/tutorials/android-plugin.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a custom property delegate that provides lifecycle-aware values</h1>
                
            
            
                
<p>Often, we need to declare a class property, which should depend on the lifecycle state of <kbd>Activity</kbd> or <kbd>Fragment</kbd>. In this recipe, we are going to employ both the Kotlin <kbd>Lazy</kbd> delegate and the <kbd>Lifecycle</kbd> class provided by the Android Architecture Components library (<a href="https://developer.android.com/topic/libraries/architecture/">https://developer.android.com/topic/libraries/architecture/</a>). We are going to implement a custom property delegate that will provide values in a lazy manner. This means that they are going to be instantiated only on the first call. Moreover, we are going to clear their values once <kbd>Activity</kbd> or <kbd>Fragment</kbd> gets destroyed. This will avoid memory leaks, which can be caused by managing properties dependent on the <kbd>Context</kbd> instance with the standard <kbd>Lazy</kbd> delegate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The basic <kbd>Lazy</kbd> delegate initialized using the <kbd>lazy()</kbd> function provided by the standard library gives the desired possibility of declaring a property of a non-null type, which can only be instantiated after a certain lifecycle event. For example, we reference an element of a screen layout in a property only after the layout was set up inside the <kbd>Activity.onCreate()</kbd> hook function.</p>
<p class="mce-root"/>
<p>However, such an implementation using <kbd>Lazy</kbd> will cause a memory leak if the property holds a reference to the <kbd>Activity</kbd> instance internally, as it will not allow it to be deleted by a garbage collector. The reason for this is that the lazy delegate is caching the instance it's holding. We are going to implement our own property delegate, called <kbd>LifeCycleAwareLazy</kbd>, which will both extend the <kbd>Lazy</kbd> interface and clear the value it's holding when the activity is about to be destroyed.</p>
<p>We are going to use the <kbd>Lifecycle</kbd> library module available with the Android Architecture Components provided by Google. We need to add it to the project dependencies in the module-level <kbd>build.gradle</kbd> script:</p>
<pre>implementation "android.arch.lifecycle:runtime:1.1.1"<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare the <kbd>LifecycleAwareLazy</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class LifecycleAwareLazy&lt;T&gt;(lifecycle: Lifecycle, val initializer: () -&gt; T):             Lazy&lt;T&gt;, GenericLifecycleObserver</pre>
<ol start="2">
<li>Register an observer to the given <kbd>Lifecycle</kbd> instance inside the <kbd>init</kbd> block:</li>
</ol>
<pre style="padding-left: 60px">class LifecycleAwareLazy&lt;T&gt;(lifecycle: Lifecycle, val initializer: () -&gt; T):             Lazy&lt;T&gt;, GenericLifecycleObserver {<br/>   <strong> init {</strong><br/><strong>        lifecycle.addObserver(this)</strong><br/><strong>    }</strong><br/>}</pre>
<ol start="3">
<li>Implement an internal field that represents the current value stored by the delegate:</li>
</ol>
<pre style="padding-left: 60px">class LifecycleAwareLazy&lt;T&gt;(lifecycle: Lifecycle, val initializer: () -&gt; T):             Lazy&lt;T&gt;, GenericLifecycleObserver {<br/><br/>    init {<br/>        lifecycle.addObserver(this)<br/>    }<br/>    <br/>   <strong> private object UNINITIALIZED_VALUE</strong><br/><strong>    private var _value: Any? = UNINITIALIZED_VALUE<br/></strong>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>Implement the <kbd>value</kbd> property and the <kbd>isInitialized()</kbd> function required by the <kbd>Lazy</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">class LifecycleAwareLazy&lt;T&gt;(lifecycle: Lifecycle, val initializer: () -&gt; T): Lazy&lt;T&gt;, GenericLifecycleObserver {<br/><br/>    init {<br/>        lifecycle.addObserver(this)<br/>    }<br/><br/>    private object UNINITIALIZED_VALUE<br/>    private var _value: Any? = UNINITIALIZED_VALUE<br/><br/><strong>    @get:Synchronized</strong><br/>    <strong>override val value: T<br/>        </strong><strong>get() {</strong><br/><strong>            if (_value === UNINITIALIZED_VALUE) {</strong><br/><strong>                _value = initializer.invoke()</strong><br/><strong>            }</strong><br/><strong>            return _value as T<br/>        }</strong><br/><br/><strong>    override fun isInitialized(): Boolean = _value != UNINITIALIZED_VALUE</strong><br/>}<br/><br/></pre>
<ol start="5">
<li>Implement the <kbd>GenericLifecycleObserver</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">class LifecycleAwareLazy&lt;T&gt;(lifecycle: Lifecycle, val initializer: () -&gt; T): Lazy&lt;T&gt;, GenericLifecycleObserver {<br/><br/>    init {<br/>        lifecycle.addObserver(this)<br/>    }<br/><br/>    private object UNINITIALIZED_VALUE<br/>    private var _value: Any? = UNINITIALIZED_VALUE<br/><br/>    @get:Synchronized<br/>    override val value: T<br/>        get() {<br/>            if (_value === UNINITIALIZED_VALUE) {<br/>                _value = initializer.invoke()<br/>            }<br/>            return _value as T<br/>        }<br/><br/>    override fun isInitialized(): Boolean = _value != UNINITIALIZED_VALUE<br/><br/>    <strong>override fun onStateChanged(source: LifecycleOwner?, event: Lifecycle.Event?) {</strong><br/><strong>        when (event) {</strong><br/><strong>            Lifecycle.Event.ON_STOP -&gt; {</strong><br/><strong>                _value = UNINITIALIZED_VALUE</strong><br/><strong>            }</strong><strong>            </strong><br/><strong>            else -&gt; return<br/>        }</strong><br/><strong>    }</strong><br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>LifecycleAwareLazy</kbd> class we have implemented can be seen as an extended version of the standard <kbd>Lazy</kbd> delegate implementation. It observes events emitted by the <kbd>Lifecycle</kbd> instance passed to it in the constructor and handles the value accordingly. Internally, it contains the private <kbd>_value: Any?</kbd> mutable property set initially to the <kbd>UNINITIALIZED_VALUE</kbd> object, which represents an empty state. The <kbd>_value</kbd> property reflects the current state of the delegated property, which can be initialized or uninitialized. The <kbd>LifecycleAwareLazy</kbd> class exposes also the immutable <kbd>value</kbd> property, which is responsible for returning a final value of the delegated property. Not it is marked with the <kbd>@get:Synchronized</kbd> annotation which informs the compiler to generate thread-safe getter function for this property.</p>
<p>Inside the <kbd>value</kbd> property getter, the current value of the <kbd>_value</kbd> property is checked. Whenever it is equal to <kbd>UNINITIALIZED_VALUE</kbd>, first it gets reassigned to the result of the <kbd>initialiser</kbd> function passed in the constructor and then it is returned as the value of the delegated property.</p>
<div><kbd>Lifecycle</kbd> is a class that holds the information about the current lifecycle state of an associated component (such as an activity or a fragment). It allows other objects to observe this state by subscribing to the state-change events by passing a callback to the <kbd>Lifecycle.addObserver()</kbd> function. You can also obtain a current state by accessing the <kbd>Lifecycle.currentState</kbd> property.</div>
<p>Inside the <kbd>init</kbd> block, we are subscribing to the state updates of the <kbd>Lifecycle</kbd> object passed as the <kbd>LifecycleAwareLazy</kbd> constructor parameter. We are passing the <kbd>LifecycleAwareLazy</kbd> instance using the <kbd>GenericLifecycleObserver</kbd> implementation to the <kbd>lifecycle.addObserver(this)</kbd> function.</p>
<p class="mce-root"/>
<p>We implement the <kbd>GenericLifeObserver</kbd> interface by overriding the <kbd>onStateChanged()</kbd> function inside the <kbd>LifecycleAwareLazy</kbd> class. As you can see, we are updating the <kbd>_value</kbd> mutable property to the <kbd>UNINITIALIZED_VALUE</kbd> object whenever the <kbd>Lifecycle.Event.ON_STOP</kbd> event is emitted, meaning that the activity is about to be destroyed. This way, we can be sure that the <kbd>_value</kbd> property won't block the activity or fragment from being garbage-collected, even if it holds a reference to an activity <kbd>Context</kbd> instance directly or indirectly. This is a huge win compared to the standard lazy delegate, which can lead to potential memory leaks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to get familiar with the basics of the property-delegation pattern, take a look at the <em>Implementing delegated class properties </em>recipe from <a href="6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml" target="_blank">Chapter 5</a>, <em>Tasteful Design Patterns Adopting Kotlin Concepts</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Easy operations on SharedPreferences</h1>
                
            
            
                
<p>In this recipe, we will make use of the Android KTX library developed by Google, providing a set of useful extensions and utilities dedicated to Android app-development. We are going to apply extension functions that allow us to operate on the <kbd>SharedPreferences</kbd> class in a clean and robust way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In order to make use of the Android KTX library, we need to add it to the project dependencies. In our case, we will need it in the <kbd>android-test</kbd> module. We can add it with the following declaration:</p>
<pre>androidTestImplementation 'androidx.core:core-ktx:1.0.+'</pre>
<p>We are going to implement the Android instrumented test case in order to verify the effects of the operations we'll perform on <kbd>SharedPreferences</kbd>. You can examine the implementation and configuration of recipes related to the Android framework in the AndroidSamples project available in the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow Android-related recipes, you just need to create a new project in Android Studio.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a function that returns the <kbd>SharedPreferences</kbd> instance:</li>
</ol>
<pre style="padding-left: 60px">fun getDefaultSharedPreferences() =                                 PreferenceManager.getDefaultSharedPreferences(InstrumentationRegistry.getContext())</pre>
<ol start="2">
<li>Save a sample string to the <kbd>SharedPreferences</kbd> instance:</li>
</ol>
<pre style="padding-left: 60px"><strong>@Test<br/>fun testUserParcelization() {</strong><br/><strong>    val prefs = getDefaultSharedPreferences()</strong><br/><strong>    val userName: String = "Gonzo"<br/>    prefs.edit {<br/>        putString("user_name", userName)</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<ol start="3">
<li>Verify whether the string was successfully saved:</li>
</ol>
<pre style="padding-left: 60px">@Test<br/>fun testSharedPrefs() {<br/>    val prefs = getDefaultSharedPreferences()<br/>    val userName: String = "Gonzo"<br/>    prefs.edit {<br/>        putString("user_name", userName)<br/>    }<br/><br/>    <strong>val DEFAULT_VALUE = "empty"<br/>    val fetchedUserName = prefs.getString("user_name",<br/>     DEFAULT_VALUE)</strong><br/><strong>    assertSame(userName, fetchedUserName)</strong><br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We are using the <kbd>edit()</kbd> extension function provided by the KTX library for the <kbd>SharedPreferences</kbd> class. It takes the lambda block, including the operations we want to perform on the <kbd>SharedPreferences.Editor</kbd> instance, and automatically invokes the <kbd>SharedPreferences.Editor.apply()</kbd> function to submit the transaction. The lambda block passed to the <kbd>edit()</kbd> function implements the type, <kbd>SharedPreferences.Editor.() -&gt; Unit</kbd>, which allows us to access an instance of <kbd>Editor</kbd> through the implicit <kbd>this</kbd> modifier.</p>
<p class="mce-root"/>
<p>If you'd like to submit operations applied to the <kbd>Editor</kbd> using the blocking <kbd>commit()</kbd> instead of the asynchronous <kbd>apply()</kbd> function, you should pass an additional <kbd>commit = true</kbd> parameter to the <kbd>edit()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to get familiar with more features offered by the Android KTX library, take a look at the library's official guide: <a href="https://developer.android.com/kotlin/ktx">https://developer.android.com/kotlin/ktx</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Less boilerplate Cursor data parsing</h1>
                
            
            
                
<p>In this recipe, we are going to learn how to work with the Android <kbd>Cursor</kbd> type in a more effective and easy way.  We are going to create an extension function for the <kbd>Cursor</kbd> type, allowing us to query it in a clean way. We will also implement a practical example showing how to access the system-content resolver in order to fetch contacts stored on the device and transform <kbd>Cursor</kbd> into a list of strings representing the contacts' names.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You can examine the implementation and configuration of the recipes related to the Android framework in the AndroidSamples project available in the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow Android-related recipes, you just need to create a new project in Android Studio.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Implement an extension function that allows us to fetch the values of a requested column name from <kbd>Cursor</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fun Cursor.getString(columnName: String): String? {<br/>    return getString(getColumnIndex(columnName))<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>Obtain the <kbd>Cursor</kbd> instance that points to the system contacts table:</li>
</ol>
<pre style="padding-left: 60px">val NOT_SPECIFIED = ""<br/>val content = getContext().contentResolver<br/>val projection = arrayOf(ContactsContract.Data.DISPLAY_NAME)<br/>val cursor =<br/>        content.query(ContactsContract.Contacts.CONTENT_URI,<br/>                projection,<br/>                NOT_SPECIFIED,<br/>                emptyArray(),<br/>                NOT_SPECIFIED)</pre>
<ol start="3">
<li>Invoke the <kbd>use</kbd> function on the <kbd>cursor</kbd> instance and iterate through the data inside its scope:</li>
</ol>
<pre style="padding-left: 60px">val NOT_SPECIFIED = ""<br/>val content = getContext().contentResolver<br/>val projection = arrayOf(ContactsContract.Data.DISPLAY_NAME)<br/>val cursor =<br/>        content.query(ContactsContract.Contacts.CONTENT_URI,<br/>                projection,<br/>                NOT_SPECIFIED,<br/>                emptyArray(),<br/>                NOT_SPECIFIED)<br/><br/><strong>val contacts = cursor.use {<br/>    val contactsList = mutableListOf&lt;String?&gt;()</strong><br/><strong>    while (it.moveToNext()) {</strong><br/><strong>        val contactName = it.getString(ContactsContract.Data.DISPLAY_NAME)</strong><br/><strong>        contactsList.add(contactName)</strong><br/><strong>    }</strong><br/><strong>    contactsList</strong><br/><strong>}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We are applying the <kbd>use()</kbd> extension function provided by the standard library to execute a set of operations on the <kbd>Cursor</kbd> instance. <kbd>use()</kbd> can be invoked on any class that implements the <kbd>Closeable</kbd> interface. Internally, after executing the lambda block passed to it as an argument, <kbd>use()</kbd> automatically invokes the <kbd>close()</kbd> function on the object it was called on. Thanks to that, we can safely perform any operation on the <kbd>Cursor</kbd> instance and be sure that, even if some of them fail or result in throwing an exception, the cursor will eventually be closed. </p>
<p class="mce-root"/>
<p>Inside the <kbd>use()</kbd> function's scope, we are iterating the cursor with the <kbd>while</kbd> loop by moving it to the next row in each iteration. For each of the rows, we are using the <kbd>getString()</kbd> extension function to obtain the current contact display name from the cursor. It allows us to avoid code duplication by combining <kbd>Cursor.getString()</kbd> and <kbd>Cursor.getColumnIndex()</kbd> together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mocking dependencies with the Mockito Kotlin library</h1>
                
            
            
                
<p>Often when writing unit test cases for complex classes, we face the problem of instantiating a great number of properties that the class we want to test depends on. Although this problem could be solved with dependency injection, it is faster, more efficient, and more desirable to mock a behavior of a specific object without instantiating it at all. In this recipe, we are going to explore how to use the Mockito Kotlin library to mock dependencies when writing a unit test for a simple registration form that contains an internal dependency whose behavior we are going to mock.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We are going to use the JUnit library, which provides the core framework for running test-case classes. We need to add it our project's list of project dependencies by declaring it in the <kbd>gradle.build</kbd> script:</p>
<pre>implementation group: 'junit', name: 'junit', version: '4.12'</pre>
<p>In order to make use of the Kotlin Mockito library, we can add it to the project dependencies with the following declaration:</p>
<pre>implementation 'com.nhaarman:mockito-kotlin:1.5.0'</pre>
<p>You can examine the implementation and configuration of the recipes related to the Android framework in the AndroidSamples project available in the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow Android-related recipes, you just need to create a new project in Android Studio.</p>
<p class="mce-root"/>
<p>In this recipe, we are going to write a unit test for the <kbd>RegistrationFormController</kbd> class, declared as follows:</p>
<pre>class RegistrationFormController(val api: RegistrationApi) {<br/>    var currentEmailAddress: String = ""<br/><br/>    fun isEmailValid(): Boolean = currentEmailAddress.contains("@")<br/><br/>    fun checkIfEmailCanBeRegistered(): Boolean =<br/>        isEmailIsValid() &amp;&amp; api.isEmailAddressAvailable(currentEmailAddress)<br/>}</pre>
<p><kbd>RegistrationApi</kbd> is defined as the following interface:</p>
<pre>interface RegistrationApi {<br/>    fun isEmailAddressAvailable(email: String): Boolean<br/>} </pre>
<p>Since we don't want to implement the <kbd>RegistrationApi</kbd> interface in order to instantiate the <kbd>RegistrationFormController</kbd> class, we are going to mock it instead using the Mockito Kotlin <kbd>mock()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li> Create a new test class:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>}</pre>
<ol start="2">
<li>Create a mocked instance of the <kbd>RegistrationApi</kbd> interface as the test-class property:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/><strong>    private val api = mock&lt;RegistrationApi&gt;()</strong><br/>}</pre>
<ol start="3">
<li>Add a class property of the <kbd>RegistrationFormController</kbd> type:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    private val api = mock&lt;RegistrationApi&gt;()<br/>    <strong>private var registrationFormController</strong><strong> = <br/>        RegistrationFormController(api = api)</strong><br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>Create the test method to check whether <kbd>checkIfEmailCanBeRegistered()</kbd> behaves correctly for an invalid email address occurrence: </li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    private val api = mock&lt;RegistrationApi&gt;()<br/>    private lateinit var registrationFormController: RegistrationFormController<br/><br/>    @Before<br/>    fun setup() {<br/>        registrationFormController = RegistrationFormController(api = api)<br/>    }<br/><br/>    <strong>@Test<br/>    fun `email shouldn't be registered if it's not valid`() {</strong><br/><strong>        // given<br/>        assertNotNull(registrationFormController)</strong><br/><strong>        whenever(api.isEmailAddressAvailable(anyString())) doReturn(true)</strong><br/><strong>        // when<br/>        registrationFormController.currentEmailAddress = "Hilary"<br/>        // then<br/>        assertFalse(registrationFormController.checkIfEmailCanBeRegistered())</strong><br/><strong>    }<br/></strong>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Inside the <kbd>`email shouldn't be registered if it's not valid`()</kbd> test method, we are setting up our mocked <kbd>RegistrationApi</kbd> property to return <kbd>true</kbd> any time its <kbd>isEmailAddressAvailable()</kbd> function is invoked, regardless of the string value passed to it. Next, we are updating the <kbd>currentEmailAddress</kbd> property of the <kbd>RegistrationFormController</kbd> class with an invalid email address value. The test is going to pass because the <kbd>isEmailIsValid()</kbd> function works correctly and returns <kbd>false</kbd> for a given email address value.</p>
<p class="mce-root"/>
<p>As you can see, thanks to the mocking, we've avoided implementing the dependency of the class we were testing. It's a proper technique that allows us to test the specific parts of the business logic while mimicking the desired behavior of the dependencies. Mocking can be also useful when we are not able to instantiate the dependencies because they are specific to a platform that is not compatible with the pure JVM (that is, Android).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can look into the <em>Verifying function invocations</em> recipe in order to explore how to check whether any specific interactions with the mocked dependency were observed</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Verifying function invocations</h1>
                
            
            
                
<p>Along with the possibility of simulating the particular behavior of dependencies in test methods, mocking allows us to verify whether specific functions of the mocked objects were invoked. In this recipe, we are going to write a unit tests for a simple registration-form controller. The registration form contains two internal dependencies that we are going to mock using the Mockito Kotlin library. We are going to test whether the proper functions are being invoked in different scenarios.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We are going to use the JUnit library to provide a core framework for running test-case classes. We need to add it to our project's list of project dependencies by declaring it in the <kbd>gradle.build</kbd> script:</p>
<pre>implementation group: 'junit', name: 'junit', version: '4.12'</pre>
<p>In order to make use of the Kotlin Mockito library, we can add it to the project dependencies with the following declaration:</p>
<pre>implementation 'com.nhaarman:mockito-kotlin:1.5.0'</pre>
<p>You can examine the implementation and configuration of recipes related to the Android framework in the AndroidSamples project available in the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow Android-related recipes, you just need to create a new project in Android Studio.</p>
<p class="mce-root"/>
<p>In this recipe, we are going to write a unit test for the <kbd>RegistrationFormController</kbd> class, declared as follows:</p>
<pre>class RegistrationForm(val api: RegistrationApi, val view: TextView) {<br/>    var currentEmailAddress: String by <br/>        Delegates.observable("", ::onEmailAddressNewValue)<br/><br/>    fun onEmailAddressNewValue(prop: KProperty&lt;*&gt;, old: String,<br/>     new: String) {<br/>        if (checkIfEmailCanBeRegistered()) {<br/>            view.showSuccessMessage("Email address is available!")<br/>        } else {<br/>            view.showErrorMessage("This email address is not<br/>             available.")<br/>        }<br/>    }<br/><br/>    fun checkIfEmailCanBeRegistered(): Boolean =<br/>            isEmailIsValid() &amp;&amp; api.isEmailAddressAvailable(currentEmailAddress)<br/><br/>    fun isEmailIsValid(): Boolean = currentEmailAddress.contains("@")<br/><br/>}</pre>
<p>It contains the <kbd>RegistrationApi</kbd> property which is defined as the following interface:</p>
<pre>interface RegistrationApi {<br/>    fun isEmailAddressAvailable(email: String): Boolean<br/>} </pre>
<p>and the <kbd>TextView</kbd> type property defined as follows:</p>
<pre>interface TextView {<br/>    fun showSuccessMessage(message: String)<br/>    fun showErrorMessage(message: String)<br/>}</pre>
<p>Since we don't want to implement the <kbd>RegistrationApi</kbd> and <kbd>TextView</kbd> interface in order to instantiate the <kbd>RegistrationFormController</kbd> class in our test, we are going to mock them using the Mockito Kotlin <kbd>mock()</kbd> function.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new test class:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>}</pre>
<ol start="2">
<li style="color: black">Create a mocked instance of the <kbd>RegistrationApi</kbd> interface as the test-class property:</li>
</ol>
<pre style="color: black;padding-left: 60px">class MyTest {<br/>    private val api = mock&lt;RegistrationApi&gt;()<br/>}</pre>
<ol start="3">
<li>Create a mocked <kbd>TextView</kbd> instance:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    private val api = mock&lt;RegistrationApi&gt;()<br/><strong>    private val view = mock&lt;TextView&gt;()</strong><br/>}</pre>
<ol start="4">
<li>Create the <kbd>RegistrationFormController</kbd> object as the <kbd>MyTest</kbd> class property:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    private val api = mock&lt;RegistrationApi&gt;()<br/>    private val view = mock&lt;TextView&gt;()<br/>   <strong> private var registrationForm = RegistrationForm(api, view)</strong><br/>}</pre>
<ol start="5">
<li>Add a test method to verify whether the success message is shown if the address is available:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    private val api = mock&lt;RegistrationApi&gt;()<br/>    private val view = mock&lt;TextView&gt;()<br/>    private var registrationForm = RegistrationForm(api, view)<br/><br/><strong>    @Test<br/>    fun `should display success message when email address is available`() {</strong><br/><strong>        // given<br/>        assertNotNull(registrationForm)</strong><br/><strong>        // when we update the currentEmailAddress to any String<br/>        whenever(api.isEmailAddressAvailable(ArgumentMatchers.anyString()))             doReturn(true)</strong><br/><strong>        registrationForm.currentEmailAddress = "hilary@gmail.com"<br/>        // then<br/>        assertTrue(registrationForm.checkIfEmailCanBeRegistered())</strong><br/><strong>        verify(view).showSuccessMessage("Email address is <br/>         available!")</strong><br/><strong>    }</strong><br/>}</pre>
<ol start="6">
<li>Add a test method to verify whether the error message is shown if the address is not available:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    private val api = mock&lt;RegistrationApi&gt;()<br/>    private val view = mock&lt;TextView&gt;()<br/>    private var registrationForm = RegistrationForm(api, view)<br/><br/>    @Test<br/>    fun `should display success message when email address is available`() {<br/>        // given<br/>        assertNotNull(registrationForm)<br/>        // when we update the currentEmailAddress to any String<br/>        whenever(api.isEmailAddressAvailable(ArgumentMatchers.anyString()))             doReturn(true)<br/>        registrationForm.currentEmailAddress = "hilary@gmail.com"<br/>        // then<br/>        assertTrue(registrationForm.checkIfEmailCanBeRegistered())<br/>        verify(view).showSuccessMessage("Email address is available!")<br/>    }<br/><br/> <strong>   @Test</strong><br/><strong>    fun `should display error message when email address isn't available`() {</strong><br/><strong>        // given<br/>        assertNotNull(registrationForm)</strong><br/><strong>        // when<br/>        registrationForm.currentEmailAddress = "hilary@gmail.com"<br/>        whenever(api.isEmailAddressAvailable(ArgumentMatchers.anyString()))             doReturn(false)</strong><br/><strong>        // then<br/>        assertTrue(registrationForm.isEmailIsValid())</strong><br/><strong>        verify(view).showErrorMessage(anyString())</strong><br/><strong>    }</strong><br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Apart from behavior-mocking, Mockito Kotlin provides a reliable way of verifying interactions with mocked dependencies that occurred while executing the test method. In both the <kbd>`should display success message when email address is available`()</kbd> and  <kbd>`should display error message when email address isn't available`()</kbd> functions, we just want to check whether the desired function of the <kbd>TextView</kbd> dependency was invoked. In order to do this, we are invoking the <kbd>verify()</kbd> function. For example, in order to check whether the <kbd>showErrorMessage()</kbd> function has been called on the mocked <kbd>view: TextView</kbd> dependency, we call the following code:</p>
<pre><strong>verify(view).showErrorMessage(anyString())</strong></pre>
<p>If the <kbd>showErrorMessage()</kbd> is not invoked, the test method will fail and the proper log message will be printed to the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit tests for Kotlin coroutines</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to effectively test code that uses coroutines internally. We are going to write a unit test for the part of a code that runs asynchronously in the background while trying to authorize the given user credentials using an external API. We are going to employ the Kotlin Mockito library to mock the calls to the external API and the <kbd>TextCoroutineContext</kbd> class, allowing us to test asynchronous code with ease.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We are going to use the JUnit library to provide the core framework for running test-case classes. We need to add it to our project's list of project dependencies by declaring it in the <kbd>gradle.build</kbd> script:</p>
<pre>implementation group: 'junit', name: 'junit', version: '4.12'</pre>
<p>In order to make use of the Kotlin Mockito library, we can add it to the project dependencies with the following declaration:</p>
<pre>implementation 'com.nhaarman:mockito-kotlin:1.5.0'</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>You can examine the implementation and configuration of recipes related to the Android framework in the AndroidSamples project available in the GitHub repository: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/</a>. To follow Android-related recipes, you just need to create a new project in Android Studio.</p>
<p>In this recipe, we are going to write a unit test for the <kbd>Authenticator</kbd> class, defined as follows:</p>
<pre>class Authenticator(val api: Api) {<br/><br/>    fun tryToAuthorise(encodedUserNameAndPassword: ByteArray, <br/>                       context: CoroutineContext): Deferred&lt;String&gt; =<br/>            async(context) {<br/>                var authToken = api.authorise(encodedUserNameAndPassword)<br/><br/>                var retryCount = 0<br/>                while (authToken.isEmpty() &amp;&amp; retryCount &lt;= 8) {<br/>                    delay(10, TimeUnit.SECONDS)<br/>                    authToken = api.authorise(encodedUserNameAndPassword)<br/>                    retryCount++<br/>                }<br/><br/>                authToken<br/>            }<br/>}</pre>
<p>The <kbd>Api</kbd> property is given as the following interface:</p>
<pre>interface Api {<br/>    // returns a non-empty auth token when the given credentials were authorised<br/>    fun authorise(encodedUserNameAndPassword: ByteArray): String<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new test class:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>Add a mocked <kbd>Api</kbd> type test-class property:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/><strong>    val api: Api = mock()</strong><br/>}</pre>
<ol start="3">
<li>Instantiate the <kbd>Authenticator</kbd> class as the class property:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    val api: Api = mock()<br/><strong>    val authenticator = Authenticator(api)</strong><br/>}</pre>
<ol start="4">
<li>Implement the test to verify whether the <kbd>Api.authorise()</kbd> function is called at least 10 times in case of consecutive failed authorization attempts:</li>
</ol>
<pre style="padding-left: 60px">class MyTest {<br/>    val api: Api = mock()<br/>    val authenticator = Authenticator(api)<br/><br/>    <strong>@Test<br/>    fun `should retry auth at least 10 times when Api returns empty<br/>    token`() {</strong><br/><strong>        whenever(api.authorise(any())) doReturn ""<br/><br/>        val context = TestCoroutineContext()</strong><br/><br/><strong>        runBlocking(context) {<br/>          authenticator.tryToAuthorise("admin:1234".toByteArray(),<br/>            context)</strong><br/><strong>                   .await()</strong><br/><strong>            context.advanceTimeBy(100, TimeUnit.SECONDS)</strong><br/><strong>            verify(api, atLeast(10)).authorise(any())</strong><br/><strong>        }<br/>    }</strong><br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, with mocking, we've avoided implementing the <kbd>Api</kbd> dependency of the <kbd>Authenticator</kbd> class we were writing the test for. In fact, we are not interested in testing real results returned by the <kbd>Api</kbd> implementation. We want to test the mechanism of the <kbd>tryToAuthorise()</kbd> function and verify whether it's going to retry calling the <kbd>Api.authorise()</kbd> function at least 10 times in case of constant authorization failures. This is why we have set up the <kbd>api</kbd> mock to always return an empty string for the <kbd>authorise()</kbd> function result.</p>
<p>As you can imagine, such a test would take a lot of time to complete because, internally, the <kbd>tryToAuthorise()</kbd> function waits for 10 seconds before retrying the authorization. In order to avoid the too-long execution time, we need to artificially move forward in time by 100 seconds and check whether the <kbd>Api.authorise()</kbd> function was invoked at least 10 times. We are able to do this by scheduling the two coroutines started with the <kbd>runBlocking()</kbd> function, and internally inside the <kbd>tryToAuthorise()</kbd> function, to run on the same instance of <kbd>TestCoroutineContext</kbd>. Then, to move forward in time by 100 seconds, we just call the <kbd>advanceTimeBy(100, TimeUnit.SECONDS)</kbd> function on the <kbd>TestCoroutineContext</kbd> instance. As a result, our test method is going to complete in less than a second. </p>


            

            
        
    </body></html>