["```swift\n-(void) startGameEasy {\n    [[CCDirector sharedDirector] replaceScene:\n     [MTPlayfieldScene sceneWithRows:2 andColumns:2]];\n}\n\n-(void) startGameMedium {\n    [[CCDirector sharedDirector] replaceScene:\n     [MTPlayfieldScene sceneWithRows:3 andColumns:4]];\n}\n\n-(void) startGameHard {\n    [[CCDirector sharedDirector] replaceScene:\n     [MTPlayfieldScene sceneWithRows:4 andColumns:5]];\n}\n```", "```swift\n#import <Foundation/Foundation.h>\n#import \"cocos2d.h\"\n#import \"MTMenuLayer.h\"\n\n@interface MTMenuScene : CCScene {\n}\n\n+(id)scene;\n\n@end\n```", "```swift\n#import \"MTMenuScene.h\"\n\n@implementation MTMenuScene\n\n+(id)scene {\n    return( [ [ [ self alloc ] init ] autorelease ] );\n}\n\n-(id) init\n{\n  if( (self=[super init])) {\n        MTMenuLayer *layer = [MTMenuLayer node];\n        [self addChild: layer];\n  }\n  return self;\n}\n\n@end\n```", "```swift\n-(void) makeTransition:(ccTime)dt\n{\n  [[CCDirector sharedDirector] replaceScene:\n     [CCTransitionFade transitionWithDuration:1.0\n        scene:[MTMenuScene scene] withColor:ccWHITE]];\n} \n```", "```swift\n+(id) sceneWithRows:(NSInteger)numRows\n         andColumns:(NSInteger)numCols {\n  return [[[self alloc] sceneWithRows:numRows\n                             andColumns:numCols]\n                                    autorelease];\n}\n\n-(id) sceneWithRows:(NSInteger)numRows\n         andColumns:(NSInteger)numCols {\n\n  if( (self=[super init])) {\n        // Create an instance of the MTPlayfieldLayer\n        MTPlayfieldLayer *layer = [MTPlayfieldLayer\n                                   layerWithRows:numRows\n                                   andColumns:numCols];\n        [self addChild: layer];\n  }\n  return self;\n} \n```", "```swift\n#import <Foundation/Foundation.h>\n#import \"cocos2d.h\"\n#import \"MTMemoryTile.h\"\n#import \"SimpleAudioEngine.h\"\n#import \"MTMenuScene.h\"\n\n@interface MTPlayfieldLayer : CCLayer {\n    CGSize size; // The window size from CCDirector\n\n    CCSpriteBatchNode *memorysheet;\n\n    CGSize tileSize; // Size (in points) of the tiles\n\n    NSMutableArray *tilesAvailable;\n    NSMutableArray *tilesInPlay;\n    NSMutableArray *tilesSelected; \n\n    CCSprite *backButton;\n\n    NSInteger maxTiles;\n\n    float boardWidth; // Max width of the game board\n    float boardHeight; // Max height of the game board\n\n    NSInteger boardRows; // Total rows in the grid\n    NSInteger boardColumns; // Total columns in the grid\n\n    NSInteger boardOffsetX; // Offset from the left\n    NSInteger boardOffsetY; // Offset from the bottom\n    NSInteger padWidth; // Space between tiles\n    NSInteger padHeight; // Space between tiles\n\n    NSInteger playerScore; // Current score value\n    CCLabelTTF *playerScoreDisplay; // Score label\n\n    NSInteger livesRemaining; // Lives value\n    CCLabelTTF *livesRemainingDisplay; // Lives label\n    BOOL isGameOver;\n}\n\n+(id) layerWithRows:(NSInteger)numRows\n         andColumns:(NSInteger)numCols;\n\n@end\n```", "```swift\n+(id) layerWithRows:(NSInteger)numRows\n         andColumns:(NSInteger)numCols {\n  return [[[self alloc] initWithRows:numRows\n                    andColumns:numCols] autorelease];\n}\n\n-(id) initWithRows:(NSInteger)numRows\n        andColumns:(NSInteger)numCols {\n    if (self == [super init]) {\n\n        self.isTouchEnabled = YES;\n\n        // Get the window size from the CCDirector\n        size = [[CCDirector sharedDirector] winSize];\n\n        // Preload the sound effects\n        [self preloadEffects];\n\n        // make sure we've loaded the spritesheets\n        [[CCSpriteFrameCache sharedSpriteFrameCache]\n         addSpriteFramesWithFile:@\"memorysheet.plist\"];\n        memorysheet = [CCSpriteBatchNode\n                batchNodeWithFile:@\"memorysheet.png\"];\n\n        // Add the batch node to the layer\n        [self addChild:memorysheet];\n\n        // Add the back Button to the bottom right corner\n        backButton = [CCSprite spriteWithSpriteFrameName:\n                      @\"backbutton.png\"];\n        [backButton setAnchorPoint:ccp(1,0)];\n        [backButton setPosition:ccp(size.width - 10, 10)];\n        [memorysheet addChild:backButton];\n\n        // Maximum size of the actual playing field\n        boardWidth = 400;\n        boardHeight = 320;\n\n        // Set the board rows and columns\n        boardRows = numRows;\n        boardColumns = numCols;\n\n        // If the total number of card positions is\n        // not even, remove one row\n        // This against an impossible board\n        if ( (boardRows * boardColumns) % 2 ) {\n            boardRows--;\n        }\n\n        // Set the number of images to choose from\n        // We need 2 of each, so we halve the total tiles\n        maxTiles = (boardRows * boardColumns) / 2;\n        // Set up the padding between the tiles\n        padWidth = 10;\n        padHeight = 10;\n\n        // We set the desired tile size\n        float tileWidth = ((boardWidth -\n                            (boardColumns * padWidth))\n                           / boardColumns) - padWidth;\n        float tileHeight = ((boardHeight -\n                             (boardRows * padHeight))\n                            / boardRows) - padHeight;\n\n        // We force the tiles to be square\n        if (tileWidth > tileHeight) {\n            tileWidth = tileHeight;\n        } else {\n            tileHeight = tileWidth;\n        }\n\n        // Store the tileSize so we can use it later\n        tileSize = CGSizeMake(tileWidth, tileHeight);\n\n        // Set the offset from the edge\n        boardOffsetX = (boardWidth - ((tileSize.width +\n                        padWidth) * boardColumns)) / 2;\n        boardOffsetY = (boardHeight - ((tileSize.height+\n                        padHeight) * boardRows)) / 2;\n\n        // Set the score to zero\n        playerScore = 0;\n\n        // Initialize the arrays\n\n        // Populate the tilesAvailable array\n        [self acquireMemoryTiles];\n\n        // Generate the actual playfield on-screen\n        [self generateTileGrid];\n\n        // Calculate the number of lives left\n        [self calculateLivesRemaining];\n\n        // We create the score and lives display here\n        [self generateScoreAndLivesDisplay];\n    }\n  return self;\n}\n```", "```swift\n    NSMutableArray *tilesAvailable;\n    NSMutableArray *tilesInPlay;\n    NSMutableArray *tilesSelected; \n```", "```swift\n        tilesAvailable = [[NSMutableArray alloc]\n                          initWithCapacity:maxTiles];\n        tilesInPlay = [[NSMutableArray alloc]\n                       initWithCapacity:maxTiles];\n        tilesSelected = [[NSMutableArray alloc]\n                         initWithCapacity:2]; MTPlayfieldLayer.m:\n- (void) dealloc\n{ \n    // Release of the arrays\n    [tilesAvailable release];\n    [tilesInPlay release];\n    [tilesSelected release];\n\n  [super dealloc];\n }\n```", "```swift\n#import <Foundation/Foundation.h>\n#import \"cocos2d.h\"\n#import \"SimpleAudioEngine.h\"\n\n// MemoryTile is a subclass of CCSprite\n@interface MTMemoryTile : CCSprite {\n    NSInteger _tileRow;\n    NSInteger _tileColumn;\n\n    NSString *_faceSpriteName;\n\n    BOOL isFaceUp;\n}\n\n@property (nonatomic, assign) NSInteger tileRow;\n@property (nonatomic, assign) NSInteger tileColumn;\n@property (nonatomic, assign) BOOL isFaceUp;\n@property (nonatomic, retain) NSString *faceSpriteName;\n\n// Exposed methods to interact with the tile\n-(void) showFace;\n-(void) showBack;\n-(void) flipTile;\n-(BOOL) containsTouchLocation:(CGPoint)pos;\n\n@end \n```", "```swift\n@synthesize propertyName = _variableName;\n```", "```swift\n@implementation MTMemoryTile\n\n@synthesize tileRow = _tileRow;\n@synthesize tileColumn = _tileColumn;\n@synthesize faceSpriteName = _faceSpriteName;\n@synthesize isFaceUp;\n\n-(void) dealloc {\n    // We set this to nil to let the string go away\n    self.faceSpriteName = nil;\n\n    [super dealloc];\n}\n\n-(void) showFace {\n    // Instantly swap the texture used for this tile\n    // to the faceSpriteName \n    [self setDisplayFrame:[[CCSpriteFrameCache\n                            sharedSpriteFrameCache]\n                spriteFrameByName:self.faceSpriteName]];\n\n    self.isFaceUp = YES;\n}\n\n-(void) showBack {\n    // Instantly swap the texture to the back image\n    [self setDisplayFrame:[[CCSpriteFrameCache\n                            sharedSpriteFrameCache]\n                spriteFrameByName:@\"tileback.png\"]];\n\n    self.isFaceUp = NO;\n}\n\n-(void) changeTile {\n    // This is called in the middle of the flipTile\n    // method to change the tile image while the tile is\n    // \"on edge\", so the player doesn't see the switch\n    if (isFaceUp) {\n        [self showBack];\n    } else {\n        [self showFace];\n    }\n}\n\n-(void) flipTile {\n    // This method uses the CCOrbitCamera to spin the\n    // view of this sprite so we simulate a tile flip\n\n    // Duration is how long the total flip will last\n    float duration = 0.25f;\n\n    CCOrbitCamera *rotateToEdge = [CCOrbitCamera\n                actionWithDuration:duration/2 radius:1\n                deltaRadius:0 angleZ:0 deltaAngleZ:90\n                angleX:0 deltaAngleX:0];\n    CCOrbitCamera *rotateFlat = [CCOrbitCamera\n                actionWithDuration:duration/2 radius:1\n                deltaRadius:0 angleZ:270 deltaAngleZ:90\n                angleX:0 deltaAngleX:0];\n    [self runAction:[CCSequence actions: rotateToEdge,\n                      [CCCallFunc actionWithTarget:self\n                      selector:@selector(changeTile)],\n                      rotateFlat, nil]];\n\n    // Play the sound effect for flipping\n    [[SimpleAudioEngine sharedEngine] playEffect:\n                                    SND_TILE_FLIP];\n}\n\n- (BOOL)containsTouchLocation:(CGPoint)pos\n{\n    // This is called from the CCLayer to let the object\n    // answer if it was touched or not\n  return CGRectContainsPoint(self.boundingBox, pos);\n}\n@end\n```", "```swift\n-(void) acquireMemoryTiles {\n    // This method will create and load the MemoryTiles\n    // into the tilesAvailable array\n\n    // We assume the tiles all use standard names\n    for (int cnt = 1; cnt <= maxTiles; cnt++) {\n        // Load the tile into the array\n        // We loop so we add each tile in the array twice\n        // This gives us a matched pair of each tile\n        for (NSInteger tileNo = 1; tileNo <= 2; tileNo++) {\n            // Generate the tile image name\n            NSString *imageName = [NSString\n                    stringWithFormat:@\"tile%i.png\", cnt];\n\n            //Create a new MemoryTile with this image\n            MTMemoryTile *newTile = [MTMemoryTile\n                    spriteWithSpriteFrameName:imageName];\n\n            // We capture the image name for the card face\n            [newTile setFaceSpriteName:imageName]; \n\n            // We want the tiles to start face down\n            [newTile showBack];\n\n            // Add the MemoryTile to the array\n            [tilesAvailable addObject:newTile];\n        }\n    }\n}\n```", "```swift\n-(CGPoint) tilePosforRow:(NSInteger)rowNum\n               andColumn:(NSInteger)colNum {\n    // Generate the coordinates for each tile\n    float newX = boardOffsetX +\n            (tileSize.width + padWidth) * (colNum - .5);\n    float newY = boardOffsetY +\n            (tileSize.height + padHeight) * (rowNum - .5);\n\n    return ccp(newX, newY);\n}\n```", "```swift\n-(void) generateTileGrid {\n    // This method takes the tilesAvailable array,\n    // and deals the tiles out to the board randomly\n    // Tiles used will be moved to the tilesInPlay array\n\n    // Loop through all the positions on the board\n    for (NSInteger newRow = 1; newRow <= boardRows; newRow++) {\n        for (NSInteger newCol = 1; newCol <= boardColumns;\n           newCol++) {\n\n            // We randomize each card slot\n            NSInteger rndPick = (NSInteger)arc4random() %\n                                ([tilesAvailable count]);\n\n            // Grab the MemoryTile from the array\n            MTMemoryTile *newTile = [tilesAvailable\n                                objectAtIndex:rndPick];\n\n            // Let the card \"know\" where it is\n            [newTile setTileRow:newRow];\n            [newTile setTileColumn:newCol];\n\n            // Scale the tile to size\n            float tileScaleX = tileSize.width /\n                            newTile.contentSize.width;\n\n            // We scale by X only (tiles are square)\n            [newTile setScale:tileScaleX];\n\n            // Set the positioning for the tile\n            [newTile setPosition:[self tilePosforRow:newRow\n                                        andColumn:newCol]];\n\n            // Add the tile as a child of our batch node\n            [self addChild:newTile];\n\n            // Since we don't want to re-use this tile,\n            // we remove it from the array\n            [tilesAvailable removeObjectAtIndex:rndPick];\n\n            // We retain the MemoryTile for later access\n            [tilesInPlay addObject:newTile];\n        }\n    }    \n}\n```", "```swift\n-(void) ccTouchesEnded:(NSSet *)touches\n             withEvent:(UIEvent *)event {\n\n    // If game over, go back to the main menu on any touch\n    if (isGameOver) {\n        [[CCDirector sharedDirector]\n                    replaceScene:[MTMenuScene node]];\n    }\n\n    UITouch *touch = [touches anyObject];\n\n    CGPoint location = [touch locationInView: [touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                            convertToGL:location];\n\n    // If the back button was pressed, we exit\n    if (CGRectContainsPoint([backButton boundingBox],\n                            convLoc)) {\n        [[CCDirector sharedDirector]\n                replaceScene:[MTMenuScene node]];\n    }\n\n    // If we have 2 tiles face up, do not respond\n    if ([tilesSelected count] == 2) {\n        return;\n    } else {\n        // Iterate through tilesInPlay to see which tile\n        // was touched\n        for (MTMemoryTile *aTile in tilesInPlay) {\n            if ([aTile containsTouchLocation:convLoc] &&\n                [aTile isFaceUp] == NO) {\n                // Flip the tile\n                [aTile flipTile];\n                // Hold the tile in a buffer array\n                [tilesSelected addObject:aTile];\n\n                // Call the score/fail check,\n                // if it is the second tile\n                if ([tilesSelected count] == 2) {\n                    // We delay so player can see cards\n                   [self scheduleOnce:@selector(checkForMatch)\n                                 delay:1.0];\n                   break;\n                }\n\n            }\n        }\n    }\n}\n```", "```swift\n-(void) checkForMatch {\n    // Get the MemoryTiles for this comparison\n    MTMemoryTile *tileA = [tilesSelected objectAtIndex:0];\n    MTMemoryTile *tileB = [tilesSelected objectAtIndex:1];\n\n    // See if the two tiles matched\n    if ([tileA.faceSpriteName\n            isEqualToString:tileB.faceSpriteName]) {\n        // We remove the matching tiles\n        [self removeMemoryTile:tileA];\n        [self removeMemoryTile:tileB];\n    } else {\n        // No match, flip the tiles back\n        [tileA flipTile];\n        [tileB flipTile];\n    }\n\n    // Remove the tiles from tilesSelected\n    [tilesSelected removeAllObjects];\n}\n\n-(void) removeMemoryTile:(MTMemoryTile*)thisTile {\n    [thisTile removeFromParentAndCleanup:YES];\n}\n```", "```swift\n-(CGPoint) scorePosition {\n    return ccp(size.width - 10 - tileSize.width/2,\n               (size.height/4) * 3);\n}\n\n-(CGPoint) livesPosition {\n    return ccp(size.width - 10 - tileSize.width/2,\n               size.height/4);\n}\n```", "```swift\n-(void) scoreThisMemoryTile:(MTMemoryTile*)aTile {\n    // We set a baseline speed for the tile movement\n    float tileVelocity = 600.0;\n\n    // We calculate the time needed to move the tile\n    CGPoint moveDifference = ccpSub([self scorePosition],\n                                    aTile.position);\n    float moveDuration = ccpLength(moveDifference) /\n                                    tileVelocity;\n    // Define the movement actions\n    CCMoveTo *move = [CCMoveTo actionWithDuration:\n               moveDuration position:[self scorePosition]];\n    CCScaleTo *scale = [CCScaleTo actionWithDuration:0.5\n                                            scale:0.001];\n    CCDelayTime *delay = [CCDelayTime\n                          actionWithDuration:0.5];\n    CCCallFuncND *remove = [CCCallFuncND\n                    actionWithTarget:self\n                    selector:@selector(removeMemoryTile:)\n                    data:aTile];\n\n    // Run the actions\n    [aTile runAction:[CCSequence actions:move, scale,\n                      delay, remove, nil]];\n\n    // Play the sound effect\n    [[SimpleAudioEngine sharedEngine]\n                        playEffect:SND_TILE_SCORE];\n\n    // Remove the tile from the tilesInPlay array\n    [tilesInPlay removeObject:aTile];\n\n    // Add 1 to the player's score\n    playerScore++;\n\n    // Recalculate the number of lives left\n    [self calculateLivesRemaining];\n}\n```", "```swift\n-(void) animateScoreDisplay {\n    // We delay for a second to allow the tiles to get\n    // to the scoring position before we animate\n    CCDelayTime *firstDelay = [CCDelayTime\n                actionWithDuration:1.0];\n    CCScaleTo *scaleUp = [CCScaleTo\n                actionWithDuration:0.2 scale:2.0];\n    CCCallFunc *updateScoreDisplay = [CCCallFunc\n                actionWithTarget:self\n                selector:@selector(updateScoreDisplay)];\n    CCDelayTime *secondDelay = [CCDelayTime\n                actionWithDuration:0.2];\n    CCScaleTo *scaleDown = [CCScaleTo\n                actionWithDuration:0.2 scale:1.0];\n\n    [playerScoreDisplay runAction:[CCSequence actions:\n                firstDelay, scaleUp, updateScoreDisplay,\n                secondDelay, scaleDown, nil]];\n} \n\n-(void) updateScoreDisplay {\n    // Change the score display to the new value\n    [playerScoreDisplay setString:\n     [NSString stringWithFormat:@\"%i\", playerScore]];\n\n    // Play the \"score\" sound\n    [[SimpleAudioEngine sharedEngine]\n                            playEffect:SND_SCORE];\n} \n```", "```swift\n-(void) animateLivesDisplay {\n    // We delay for a second to allow the tiles to flip back\n    CCScaleTo *scaleUp = [CCScaleTo\n            actionWithDuration:0.2 scale:2.0];\n    CCCallFunc *updateLivesDisplay = [CCCallFunc\n            actionWithTarget:self\n            selector:@selector(updateLivesDisplay)];\n    CCCallFunc *resetLivesColor = [CCCallFunc\n            actionWithTarget:self\n            selector:@selector(resetLivesColor)];\n    CCDelayTime *delay = [CCDelayTime\n            actionWithDuration:0.2];\n    CCScaleTo *scaleDown = [CCScaleTo\n            actionWithDuration:0.2 scale:1.0];\n    [livesRemainingDisplay runAction:[CCSequence actions:\n            scaleUp, updateLivesDisplay, delay, scaleDown,\n            resetLivesColor, nil]];\n}\n\n-(void) updateLivesDisplayQuiet {\n    // Change the lives display without the fanfare\n    [livesRemainingDisplay setString:[NSString\n            stringWithFormat:@\"%i\", livesRemaining]];\n}\n\n-(void) updateLivesDisplay {\n    // Change the lives display to the new value\n    [livesRemainingDisplay setString:[NSString\n            stringWithFormat:@\"%i\", livesRemaining]];\n    // Change the lives display to red\n    [livesRemainingDisplay setColor:ccRED];\n\n    // Play the \"wrong\" sound\n    [[SimpleAudioEngine sharedEngine]\n                        playEffect:SND_TILE_WRONG];\n\n    [self checkForGameOver];\n}\n\n-(void) calculateLivesRemaining {\n    // Lives equal half of the tiles on the board\n    livesRemaining = [tilesInPlay count] / 2;\n}\n\n-(void) resetLivesColor {\n    // Change the Lives counter back to blue\n    [livesRemainingDisplay setColor:ccBLUE];\n} \n```", "```swift\n-(void) checkForGameOver {\n    NSString *finalText;\n    // Player wins\n    if ([tilesInPlay count] == 0) {\n        finalText = @\"You Win!\";\n    // Player loses\n    } else if (livesRemaining <= 0) {\n        finalText = @\"You Lose!\";\n    } else {\n        // No game over conditions met\n        return;\n    }\n\n    // Set the game over flag\n    isGameOver = YES;\n\n    // Display the appropriate game over message\n    CCLabelTTF *gameOver = [CCLabelTTF\n                    labelWithString:finalText\n                    fontName:@\"Marker Felt\" fontSize:60];\n    [gameOver setPosition:ccp(size.width/2,size.height/2)];\n    [self addChild:gameOver z:50];\n}\n```", "```swift\n-(void) checkForMatch {\n    // Get the MemoryTiles for this comparison\n    MTMemoryTile *tileA = [tilesSelected objectAtIndex:0];\n    MTMemoryTile *tileB = [tilesSelected objectAtIndex:1];\n\n    // See if the two tiles matched\n    if ([tileA.faceSpriteName\n            isEqualToString:tileB.faceSpriteName]) {\n        // We start the scoring, lives, and animations\n        [self scoreThisMemoryTile:tileA];\n        [self scoreThisMemoryTile:tileB];\n        [self animateScoreDisplay];\n        [self calculateLivesRemaining];\n        [self updateLivesDisplayQuiet];\n        [self checkForGameOver];\n\n    } else {\n        // No match, flip the tiles back\n        [tileA flipTile];\n        [tileB flipTile];\n\n        // Take off a life and update the display\n        livesRemaining--;\n        [self animateLivesDisplay];\n    }\n\n    // Remove the tiles from tilesSelected\n    [tilesSelected removeAllObjects];\n}\n```", "```swift\n    // Initialize the SimpleAudioEngine\n    [SimpleAudioEngine sharedEngine]; \n```", "```swift\n-(void) preloadEffects {\n    // Preload all of our sound effects\n    [[SimpleAudioEngine sharedEngine]\n                        preloadEffect:SND_TILE_FLIP];\n    [[SimpleAudioEngine sharedEngine]\n                        preloadEffect:SND_TILE_SCORE];\n    [[SimpleAudioEngine sharedEngine]\n                        preloadEffect:SND_TILE_WRONG];\n    [[SimpleAudioEngine sharedEngine]\n                        preloadEffect:SND_SCORE];\n}\n```", "```swift\n#define SND_TILE_FLIP @\"button.caf\"\n#define SND_TILE_SCORE @\"whoosh.caf\"\n#define SND_TILE_WRONG @\"buzzer.caf\"\n#define SND_SCORE @\"harprun.caf\" \n```", "```swift\n    [[SimpleAudioEngine sharedEngine]\n                            playEffect:SND_SCORE];\n```"]