- en: Functional Programming and Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've made good progress over the last eight chapters. You've already
    learned the concepts of **functional programming** (**FP**) and some awesome Kotlin
    features such as coroutines and delegates, which are not exactly from FP theories
    (in fact, delegates are from the OOP paradigm), but all of them enable us to get
    more benefits out of FP.
  prefs: []
  type: TYPE_NORMAL
- en: 'This short chapter is dedicated to combining other programming principles/paradigms
    with FP to get the best output from them. Here''s a list of the topics that we
    will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining FP with OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to RxKotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Combining FP with OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FP and OOP are both old age programming paradigms, having their set of benefits
    and disadvantages. For instance, it is difficult to strictly follow FP without
    any side effects and all pure functions, especially for beginners in FP and with
    complex project requirements. However, with OOP systems, it is difficult to avoid
    side effects; also, OOP systems are often termed as a nightmare for concurrent
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: FP doesn't acknowledge state, whereas in real life, states cannot be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: All these hassles can be avoided by using/combining OOP with FP. The most general
    style of mixing OOP and FP that has been professed can be summarized as functional
    in the small, object-oriented in the large. This is a simple and the most efficient
    idea of combining OOP with FP. This concept talks about using OOP at a higher
    level in your code, that is, in the modular architecture, and you can use OOP
    for classes and interfaces, while using FP at the lower level, that is, while
    writing methods/functions.
  prefs: []
  type: TYPE_NORMAL
- en: To break this concept, consider a structure where you are writing classes and
    interfaces as you normally do with OOP, and then while writing functions/methods,
    you follow the FP style of working with pure functions, monads, and immutability.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier in this book, we believe that Kotlin is the best language
    if you want a mixture of OOP and FP.
  prefs: []
  type: TYPE_NORMAL
- en: Functional reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of functional reactive programming emerged by combining FP paradigms
    with reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of **functional reactive programming** says it is a programming
    paradigm for reactive programming (asynchronous dataflow programming) using the
    building blocks of FP (for example, `map`, `reduce`, and `filter`).
  prefs: []
  type: TYPE_NORMAL
- en: So, let's begin by defining reactive programming, and then we will discuss combining
    them with FP.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive programming** is a modern programming paradigm, which talks about
    propagation of change, that is, instead of representing the world as a series
    of states, reactive programming models behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is an asynchronous programming paradigm that revolves around
    data streams and the propagation of change. In simpler words, those programs which
    propagate all the changes that affected its data/data streams to all the interested
    parties (such as end users, components and sub-parts, and other programs that
    are somehow related) are called **reactive programs**.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is best defined with Reactive Manifesto, as described in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive Manifesto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Reactive Manifesto** ([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    is a document, defining the four reactive principles, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: The system responds in a timely manner. Responsive systems
    focus on providing rapid and consistent response times, so they deliver a consistent
    quality of service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: In case the system faces any failure, it stays responsive. Resilience
    is achieved by replication, containment, isolation, and delegation. Failures are
    contained within each component, isolating components from each other, so when
    failure occurs in a component, it will not affect the other components or the
    system as a whole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic**: Reactive systems can react to changes and stays responsive under
    varying workloads. Reactive systems achieve elasticity in a cost-effective way
    on commodity hardware and software platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven**: In order to establish the resilient principle, reactive
    systems need to establish a boundary between components by relying on asynchronous
    message-passing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By implementing all the preceding four principles, a system becomes reliable
    and responsive, thus reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Functional reactive frameworks for Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For writing reactive programs, we need a library. There are several reactive
    programming libraries for Kotlin out there to help us on these. Here''s a list
    of the available libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: RxKotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactor-Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux-Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxKotlin/RxJava and other Reactive Java (ReactiveX) frameworks can also be used
    with Kotlin (as Kotlin is 100% interoperable with Java-bidirectional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will focus on RxKotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RxKotlin** is a specific implementation of reactive programming for Kotlin,
    which is influenced by FP. It favors function composition, the avoidance of global
    state, and side effects. It relies on the observer pattern of producer/consumer,
    with a lot of operators that allow composing, scheduling, throttling, transforming,
    error handling, and life cycle management. ReactiveX frameworks are backed by
    a large community and Netflix.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactor-Kotlin is also based on FP; it is widely accepted and is backed by Spring
    Framework. Both RxKotlin and Reactor-Kotlin share a lot of similarities (probably
    because of **Reactive Streams** specifications).
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and setting up RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download and build RxKotlin from GitHub ([https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)).
    It does not require any other dependencies. The documentation on the GitHub Wikipedia
    page is well-structured. Here is how you can check out the project from GitHub
    and run the build as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can also use Maven and Gradle, as instructed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: We are using RxKotlin version 2.2.0 for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at what RxKotlin is all about. We will begin with something
    well-known, and gradually we will get into the secrets of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the Pull mechanism with the RxJava Push mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxKotlin revolves around the `Observable` type that represents a system of real-life
    events and data, intended for push mechanisms, thus it is lazy and can be used
    in both ways—synchronously and asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''ll be easier for us to understand if we start with a simple example that
    works with a list of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0caf4afc-685f-495d-86b9-f47683dea1ac.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's go through the program line by line to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: At comment `1`, we created a `list` with seven items (the `list` contains data
    of mixed data types with the help of `Any` class). At comment `2`, we created
    `iterator` from the `list`, so that we can iterate over the data. In comment `3`,
    we created a `while` loop to pull data from the `list` with the help of an `iterator`,
    and then at comment `4`, we printed it.
  prefs: []
  type: TYPE_NORMAL
- en: The thing to notice here is that we're pulling data from the `list` while the
    current thread is blocked till the data is received and ready. For instance, think
    of getting that data from a network call/database query instead of just a list,
    and in that case, how long the thread will be blocked. You can obviously create
    a separate thread for those operations, but that too will increase complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Just give it a thought, which one is a better approach, making the program wait
    for data or pushing data to the program whenever it's available?
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of the ReactiveX framework (be it RxKotlin or RxJava) are
    the observables. The `Observable` class is opposite to Iterator. It has an underlying
    collection or computation that produces values that can be consumed by a consumer.
    But the difference is that the consumer doesn't pull these values from the producer
    like in the Iterator pattern; instead the producer pushes the values as notifications
    to the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take the same example again, this time with `observable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This program''s output is the same as the previous one; it prints all the items
    in the list. The difference is in its approach. So, let''s see how it actually
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a list (the same as the previous one)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Observable` instance is created by the `list`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We subscribe to the observer (we're using named arguments for lambda; we will
    cover them in detail later)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we subscribe to the `observable` variable, each data will be pushed to `onNext`
    as it gets ready; it'll call `onComplete` when all the data is pushed, and `onError`
    if any error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: So, you learned how to use the `Observable` instances and that they are quite
    similar to the Iterator instances, something we're quite familiar with. We can
    use these `Observable` instances for building asynchronous streams and pushing
    data updates to their subscribers (even to multiple subscribers). This was a simple
    implementation of the reactive programming paradigm. The data is being propagated
    to all the interested parties—the subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, in reactive programming, `Observable` has an underlying
    computation that produces values that can be consumed by a consumer (`Observer`).
    The most important thing here is that the consumer (`Observer`) doesn''t pull
    values here; rather, `Observable` pushes the values to the consumer. So, we can
    say that an `Observable` interface is a push-based, composable Iterator that emits
    its items through a series of operators to the final `Observer`, which finally
    consumes the items. Let''s now break these things down sequentially to understand
    it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observer` subscribes to `Observable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable` starts emitting the items that it has in it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observer` reacts to whatever item the `Observable` emits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's delve into how `Observable` works through its events/methods, namely
    `onNext`, `onComplete`, and `onError`.
  prefs: []
  type: TYPE_NORMAL
- en: How Observable works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we stated earlier, an `Observable` value has the following three most important
    events/methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onNext`: The `Observable` interface passes all the items one by one to this
    method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`: When all the items have gone through the `onNext` method, the
    `Observable` calls the `onComplete` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: When the `Observable` faces any error, it calls the `onError` method
    to deal with the error, if defined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing to note here is that the item in `Observable` that we are talking
    about can be anything; it is defined as `Observable<T>`, where `T` can be any
    class. Even an array/list can be assigned as `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a1883a3-293a-427e-82f6-3e786e9e9dea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a code example to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared the observer instance of the `Any` datatype
    at comment `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we take the benefit of the `Any` datatype. In Kotlin, every class is a
    child class of `Any`. Also, in Kotlin, everything is a class and object; there
    is no separate primitive datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observer` interface has four methods declared in it. The `onComplete()`
    method at comment `2` gets called when `Observable` is finished with all its items
    without any error. At comment `3`, we defined the `onNext(item: Any)` function,
    which will be called by the `observable` value  for each item it has to emit.
    In that method, we printed the data to the console. At comment `4`, we defined
    the `onError(e: Throwable)` method, which will be called in case the `Observable` interface
    faces an error. At comment `5`, the `onSubscribe(d: Disposable)` method will get
    called whenever the `Observer` subscribes to `Observable`. At comment `6`, we
    created an `Observable` from a list (`val observable`) and subscribed to the `observable` value
    with the `observer` value at comment `7`. At comment `8`, we again created `observable`
    (`val observableOnList`), which holds lists as items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2785f2bc-9a0a-4d42-9f16-d71184dfe82e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, as you can see in the output, for the first subscription (comment `7`),
    when we subscribe to the `observable` value, it calls the `onSubscribe` method,
    then the `Observable` property starts emitting items, as `observer` starts receiving
    them on the `onNext` method and prints them. When all the items are emitted from
    the `Observable` property, it calls the `onComplete` method to denote that all
    the items have been successfully emitted. It is the same with the second one,
    except that here, each item is a list.
  prefs: []
  type: TYPE_NORMAL
- en: As we gained some grip on `Observables`, you can now learn a few ways to create
    Observable factory methods for `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable.create method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At any time, you can create your own custom implementation of `Observable`
    with the `Observable.create` method. This method takes an instance of the `ObservableEmitter<T>`
    interface as a source to observe. Take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, we created an instance of the `Observer` interface as the previous example.
    I will not elaborate the `observer` value, as we have already seen an overview
    in the previous example, and will see this in detail later in this chapter. At
    comment `1`, we created an `Observable` value with the `Observable.create` method.
    We have emitted four strings from the `Observable` value with the help of `onNext`
    method, then notified it is complete with the `onComplete` method. At comment
    `2`, we almost did the same except here, instead of calling `onComplete`, we called
    `onError` with a custom `Exception` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a3f8053-dcf0-4265-9e46-6457e646e21a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Observable.create` method is useful, especially when you are working with
    a custom data structure and want to have a control over which values are getting
    emitted. You can also emit values to the observer from a different thread.
  prefs: []
  type: TYPE_NORMAL
- en: The **Observable contract** ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    states that Observables must issue notifications to observers serially (not in
    parallel). They may issue these notifications from different threads, but there
    must be a formal happens-before relationship between the notifications.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable.from methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Observable.from` methods are comparatively simpler than the `Observable.create`
    method. You can create the `Observable` instances from nearly every Kotlin structure
    with the help of from methods.
  prefs: []
  type: TYPE_NORMAL
- en: In RxKotlin 1, you will have `Observale.from` as a method; however, from RxKotlin
    2.0 (as with RxJava2.0), operator overloads have been renamed with a postfix,
    such as `fromArray`, `fromIterable`, and `fromFuture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At comment `1`, we used the `Observable.fromIterable` method to create `Observable`
    from an `Iterable` instance (here, `list`). At comment `2`. We called the `Observable.fromCallable`
    method to create `Observable` from a `Callable` instance, we did the same at comment
    `3`, where we called the `Observable.fromFuture` method to derive `Observable`
    from a `Future` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0acfe4dd-acb4-44c8-b9f7-33e32fc9722e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Iterator<T>.toObservable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to the extension functions of Kotlin, you can turn any `Iterable` instance,
    such as `list`, to `Observable` without much effort. We have already used this
    method in [Chapter 1](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml), *Kotlin – Data
    Types, Objects, and Classes*, but again take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ed751e5-b092-40cf-b3b0-82c6b2c25d1c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, aren''t you curious to look into the `toObservable` method? Let''s do it.
    You can find this method inside the `observable.kt` file provided with the `RxKotlin`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, it uses the `Observable.from` method internally, thanks again to the extension
    functions of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Subscriber – the Observer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In RxKotlin 1.x, the `Subscriber` operator essentially became an `Observer` type
    in RxKotlin 2.x. There is an `Observer` type in RxKotlin 1.x, but the `Subscriber` value
    is what you pass to the `subscribe()` method, and it implements `Observer`. In
    RxJava 2.x, a `Subscriber` operator only exists when talking about `Flowables`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the previous examples in this chapter, an `Observer` type
    is an interface with four methods in it, namely `onNext(item:T)`, `onError(error:Throwable)`,
    `onComplete()`, and `onSubscribe(d:Disposable)`. As stated earlier, when we connect `Observable` to
    `Observer`, it looks for these four methods in the `Observer` type and calls them.
    Here is a short description of the following four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onNext`: The `Observable` calls this method of `Observer` to pass each of
    the items one by one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`: When the `Observable` wants to denote that it''s done with passing
    items to the `onNext` method, it calls the `onComplete` method of `Observer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: When `Observable` faces any error, it calls the `onError` method
    to deal with the error if defined in the `Observer ` type, otherwise it throws
    the exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubscribe`: This method is called whenever a new `Observable` subscribes
    to `Observer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing and disposing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have `Observable` (the thing that should be observed upon) and we have
    the `Observer` type (that should be observed), now what? How do we connect them?
    `Observable` and `Observer` are like an input device (be it keyboard or mouse)
    and the computer; we need something to connect them (even wireless input devices
    have some connectivity channels, be it Bluetooth or Wi-Fi).
  prefs: []
  type: TYPE_NORMAL
- en: The `subscribe` operator serves the purpose of the media by connecting an `Observable` interface
    to `Observer`. We can pass one to three methods (`onNext`, `onComplete`, and `onError`)
    to the `subscribe` operator, or we can pass an instance of the `Observer` interface
    to the subscribe operator to get the `Observable` interface connected with `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s look at an example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have created an `Observable` instance (at comment `1`) and
    used it twice with different overload `subscribe` operators. At comment `2`, we
    passed three methods as arguments to the `subscribe` method. The first parameter
    is the `onNext` method, the second one is the `onError` method, and the last one
    is `onComplete`. At comment `2`, we passed an instance of the `Observer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The output can be easily predicted, so we are skipping it.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have got the concepts of subscribing, and can do it now. What about if
    you want to stop the emissions after some period of subscription? There must be
    a way, right? So, let's inspect this.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the `onSubscribe` method of `Observer`? There was a parameter on that
    method which we haven't discussed yet. While you subscribe, if you pass the methods
    instead of the `Observer` instance, then the `subscribe` operator will return
    an instance of `Disposable`, or if you use an instance of `Observer`, then you
    will get the instance of `Disposable` in the parameter of the `onSubscribe` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the instance of the `Disposable` interface to stop emissions at
    any given time. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `Observable.interval` factory method. This method takes two
    parameters describing the interval period and time unit; it then emits integers
    sequentially starting from zero. `Observable` created with `interval` never completes
    and never stops until you dispose off them, or the program stops execution. I
    thought it would be the perfect fit in this scenario as we want to stop the `Observable`
    midway here.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this example, at comment `1`, we created `Observable` with the `Observable.interval`
    factory method that will emit an integer after each `100` milliseconds interval.
  prefs: []
  type: TYPE_NORMAL
- en: At comment `2`, I have declared `lateinit var disposable` of the `Disposable` type (`lateinit`
    means the variable will get initialized at a later point in time). At comment
    `3`, inside the `onSubscribe` method, we will assign the received parameter value
    to the `disposable` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We intend to stop the execution after the sequence reached `10`, that is, after
    `10` is emitted, the emission should be stopped immediately. To achieve this,
    we placed a check inside the `onNext` method, where we are checking the value
    of the emitted item. We check whether it's equal to or greater than `10`, and
    if the emission is not already stopped (disposed), then we dispose the emission
    (comment `5`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df453c98-95e6-4a48-954d-6a5d66d66886.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can see that no integer got emitted after the `disposable.dispose()`
    method was called, though the execution waited for 500 milliseconds more (100*10
    = 1000 milliseconds to print the sequence till `10`, and we called the delay method
    with `1500`, thus 500 milliseconds after emitting `10`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious to know the `Disposable` interface, then the following is
    the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It has one property that denotes that the emission is already notified to stop
    (disposed) and a method to notify the emission to stop (dispose).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about combining FP concepts with OOP and reactive
    programming. We even discussed RxKotlin and covered the setup and basic usage
    of RxKotlin.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about more advanced FP concepts—monads, functors, and applicatives,
    and how to implement them with Kotlin. Monads, functors, and applicatives are
    some of the must-know concepts and are often referred to as the building blocks
    of FP. So, don't skip the next chapter if you are truly willing to learn about
    FP. Turn the page now.
  prefs: []
  type: TYPE_NORMAL
