- en: Functional Programming and Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程和响应式编程
- en: So far, we've made good progress over the last eight chapters. You've already
    learned the concepts of **functional programming** (**FP**) and some awesome Kotlin
    features such as coroutines and delegates, which are not exactly from FP theories
    (in fact, delegates are from the OOP paradigm), but all of them enable us to get
    more benefits out of FP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在过去的八章中取得了良好的进展。你已经学习了**函数式编程**（**FP**）的概念，以及一些令人惊叹的Kotlin特性，如协程和委托，它们并不完全来自FP理论（实际上，委托来自OOP范式），但所有这些都能使我们从FP中获得更多好处。
- en: 'This short chapter is dedicated to combining other programming principles/paradigms
    with FP to get the best output from them. Here''s a list of the topics that we
    will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇简短的章节致力于将其他编程原则/范式与FP结合，以从它们中获得最佳输出。以下是本章我们将涵盖的主题列表：
- en: Combining FP with OOP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将FP与OOP结合
- en: Functional reactive programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式响应式编程
- en: Introduction to RxKotlin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxKotlin简介
- en: So, let's get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Combining FP with OOP
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将FP与OOP结合
- en: FP and OOP are both old age programming paradigms, having their set of benefits
    and disadvantages. For instance, it is difficult to strictly follow FP without
    any side effects and all pure functions, especially for beginners in FP and with
    complex project requirements. However, with OOP systems, it is difficult to avoid
    side effects; also, OOP systems are often termed as a nightmare for concurrent
    programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: FP和OOP都是老牌的编程范式，各有其优势和劣势。例如，在FP中严格遵循无副作用和所有纯函数是很困难的，尤其是对于FP初学者和面对复杂项目需求时。然而，在OOP系统中，很难避免副作用；此外，OOP系统通常被称为并发程序的噩梦。
- en: FP doesn't acknowledge state, whereas in real life, states cannot be avoided.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: FP不承认状态，而在现实生活中，状态是无法避免的。
- en: All these hassles can be avoided by using/combining OOP with FP. The most general
    style of mixing OOP and FP that has been professed can be summarized as functional
    in the small, object-oriented in the large. This is a simple and the most efficient
    idea of combining OOP with FP. This concept talks about using OOP at a higher
    level in your code, that is, in the modular architecture, and you can use OOP
    for classes and interfaces, while using FP at the lower level, that is, while
    writing methods/functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用/结合OOP和FP，可以避免所有这些麻烦。最普遍的混合OOP和FP的风格可以概括为：在细节上函数式，在整体上面向对象。这是将OOP与FP结合的简单而高效的方法。这个概念讨论的是在代码中以更高的层次使用OOP，即在模块化架构中，你可以使用OOP来定义类和接口，而在较低层次，即在编写方法/函数时，使用FP。
- en: To break this concept, consider a structure where you are writing classes and
    interfaces as you normally do with OOP, and then while writing functions/methods,
    you follow the FP style of working with pure functions, monads, and immutability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打破这个概念，考虑一个结构，其中你像使用OOP一样编写类和接口，然后在编写函数/方法时，遵循FP风格的纯函数、单子和不变性。
- en: As stated earlier in this book, we believe that Kotlin is the best language
    if you want a mixture of OOP and FP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书前面所述，我们相信如果你想要OOP和FP的混合，Kotlin是最好的语言。
- en: Functional reactive programming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式响应式编程
- en: The concept of functional reactive programming emerged by combining FP paradigms
    with reactive programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程的概念是通过将FP范式与响应式编程相结合而出现的。
- en: The definition of **functional reactive programming** says it is a programming
    paradigm for reactive programming (asynchronous dataflow programming) using the
    building blocks of FP (for example, `map`, `reduce`, and `filter`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式响应式编程**的定义表明，它是一种用于响应式编程（异步数据流编程）的编程范式，使用FP的构建块（例如，`map`、`reduce`和`filter`）。'
- en: So, let's begin by defining reactive programming, and then we will discuss combining
    them with FP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从定义响应式编程开始，然后我们将讨论将它们与FP结合。
- en: '**Reactive programming** is a modern programming paradigm, which talks about
    propagation of change, that is, instead of representing the world as a series
    of states, reactive programming models behavior.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式编程**是一种现代编程范式，它讨论的是变化的传播，也就是说，不是将世界表示为一系列状态，而是响应式编程模型行为。'
- en: Reactive programming is an asynchronous programming paradigm that revolves around
    data streams and the propagation of change. In simpler words, those programs which
    propagate all the changes that affected its data/data streams to all the interested
    parties (such as end users, components and sub-parts, and other programs that
    are somehow related) are called **reactive programs**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是一种异步编程范式，它围绕数据流和变化的传播。简单来说，那些将影响其数据/数据流的所有变化传播给所有相关方（如最终用户、组件和子部分，以及其他以某种方式相关的程序）的程序被称为**响应式程序**。
- en: Reactive programming is best defined with Reactive Manifesto, as described in
    the following section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程最好通过以下章节中描述的《响应式宣言》来定义。
- en: The Reactive Manifesto
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《响应式宣言》
- en: 'The **Reactive Manifesto** ([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    is a document, defining the four reactive principles, which are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 《**响应式宣言**》([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))是一份文件，定义了四个响应式原则，如下所述：
- en: '**Responsive**: The system responds in a timely manner. Responsive systems
    focus on providing rapid and consistent response times, so they deliver a consistent
    quality of service.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：系统及时响应。响应性系统侧重于提供快速和一致的反应时间，因此它们提供一致的服务质量。'
- en: '**Resilient**: In case the system faces any failure, it stays responsive. Resilience
    is achieved by replication, containment, isolation, and delegation. Failures are
    contained within each component, isolating components from each other, so when
    failure occurs in a component, it will not affect the other components or the
    system as a whole.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：如果系统遇到任何故障，它仍然保持响应。通过复制、遏制、隔离和委派来实现弹性。故障被包含在每个组件内部，使组件彼此隔离，因此当某个组件发生故障时，它不会影响其他组件或整个系统。'
- en: '**Elastic**: Reactive systems can react to changes and stays responsive under
    varying workloads. Reactive systems achieve elasticity in a cost-effective way
    on commodity hardware and software platforms.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：响应式系统可以响应变化，并在不同的工作负载下保持响应。响应式系统以成本效益的方式在通用硬件和软件平台上实现弹性。'
- en: '**Message-driven**: In order to establish the resilient principle, reactive
    systems need to establish a boundary between components by relying on asynchronous
    message-passing.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：为了建立弹性原则，响应式系统需要通过依赖异步消息传递来在组件之间建立边界。'
- en: By implementing all the preceding four principles, a system becomes reliable
    and responsive, thus reactive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现前面提到的四个原则，系统变得可靠且响应迅速，因此是响应式的。
- en: Functional reactive frameworks for Kotlin
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin的功能响应式框架
- en: 'For writing reactive programs, we need a library. There are several reactive
    programming libraries for Kotlin out there to help us on these. Here''s a list
    of the available libraries:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写响应式程序，我们需要一个库。目前有几种针对Kotlin的响应式编程库可以帮助我们。以下是可用库的列表：
- en: RxKotlin
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxKotlin
- en: Reactor-Kotlin
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reactor-Kotlin
- en: Redux-Kotlin
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux-Kotlin
- en: RxKotlin/RxJava and other Reactive Java (ReactiveX) frameworks can also be used
    with Kotlin (as Kotlin is 100% interoperable with Java-bidirectional)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxKotlin/RxJava和其他响应式Java（ReactiveX）框架也可以与Kotlin一起使用（因为Kotlin与Java双向100%兼容）
- en: In this book, we will focus on RxKotlin.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将重点关注RxKotlin。
- en: Getting started with RxKotlin
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用RxKotlin
- en: '**RxKotlin** is a specific implementation of reactive programming for Kotlin,
    which is influenced by FP. It favors function composition, the avoidance of global
    state, and side effects. It relies on the observer pattern of producer/consumer,
    with a lot of operators that allow composing, scheduling, throttling, transforming,
    error handling, and life cycle management. ReactiveX frameworks are backed by
    a large community and Netflix.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**RxKotlin**是针对Kotlin的响应式编程的具体实现，它受到FP的影响。它倾向于函数组合、避免全局状态和副作用。它依赖于生产者/消费者观察者模式，并有许多操作符允许组合、调度、节流、转换、错误处理和生命周期管理。ReactiveX框架得到了一个大型社区和Netflix的支持。'
- en: Reactor-Kotlin is also based on FP; it is widely accepted and is backed by Spring
    Framework. Both RxKotlin and Reactor-Kotlin share a lot of similarities (probably
    because of **Reactive Streams** specifications).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor-Kotlin也是基于FP的；它被广泛接受，并得到Spring框架的支持。RxKotlin和Reactor-Kotlin有很多相似之处（可能是因为**Reactive
    Streams**规范）。
- en: Downloading and setting up RxKotlin
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和设置RxKotlin
- en: 'You can download and build RxKotlin from GitHub ([https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)).
    It does not require any other dependencies. The documentation on the GitHub Wikipedia
    page is well-structured. Here is how you can check out the project from GitHub
    and run the build as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载并构建RxKotlin（[https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)）。它不需要任何其他依赖项。GitHub维基百科页面上的文档结构良好。以下是您如何从GitHub检出项目并运行构建的步骤：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can also use Maven and Gradle, as instructed on the page.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用Maven和Gradle，如页面上的说明。
- en: We are using RxKotlin version 2.2.0 for this book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中使用RxKotlin版本2.2.0。
- en: Now, let's take a look at what RxKotlin is all about. We will begin with something
    well-known, and gradually we will get into the secrets of the library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看RxKotlin究竟是什么。我们将从一个众所周知的事物开始，然后逐渐深入到库的秘密。
- en: Comparing the Pull mechanism with the RxJava Push mechanism
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将拉取机制与RxJava推送机制进行比较
- en: RxKotlin revolves around the `Observable` type that represents a system of real-life
    events and data, intended for push mechanisms, thus it is lazy and can be used
    in both ways—synchronously and asynchronously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: RxKotlin围绕表示现实生活事件和数据系统的`Observable`类型，旨在用于推送机制，因此它是懒加载的，可以以同步和异步两种方式使用。
- en: 'It''ll be easier for us to understand if we start with a simple example that
    works with a list of data:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从与数据列表一起工作的简单示例开始，这将更容易理解：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/0caf4afc-685f-495d-86b9-f47683dea1ac.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0caf4afc-685f-495d-86b9-f47683dea1ac.jpg)'
- en: Let's go through the program line by line to understand how it works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析程序，了解它是如何工作的。
- en: At comment `1`, we created a `list` with seven items (the `list` contains data
    of mixed data types with the help of `Any` class). At comment `2`, we created
    `iterator` from the `list`, so that we can iterate over the data. In comment `3`,
    we created a `while` loop to pull data from the `list` with the help of an `iterator`,
    and then at comment `4`, we printed it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`1`中，我们创建了一个包含七个项目的`list`（`list`通过`Any`类帮助包含混合数据类型的数据）。在注释`2`中，我们从`list`创建了一个`iterator`，这样我们就可以遍历数据。在注释`3`中，我们创建了一个`while`循环，使用`iterator`从`list`中拉取数据，然后在注释`4`中打印它。
- en: The thing to notice here is that we're pulling data from the `list` while the
    current thread is blocked till the data is received and ready. For instance, think
    of getting that data from a network call/database query instead of just a list,
    and in that case, how long the thread will be blocked. You can obviously create
    a separate thread for those operations, but that too will increase complexity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的事情是，我们在当前线程阻塞直到收到并准备好数据时从`list`中拉取数据。例如，想象一下从网络调用/数据库查询而不是从列表中获取数据，在这种情况下，线程将被阻塞多长时间。显然，您可以为此操作创建一个单独的线程，但这也会增加复杂性。
- en: Just give it a thought, which one is a better approach, making the program wait
    for data or pushing data to the program whenever it's available?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考一下，哪种方法更好，让程序等待数据，还是当数据可用时将数据推送到程序？
- en: The building blocks of the ReactiveX framework (be it RxKotlin or RxJava) are
    the observables. The `Observable` class is opposite to Iterator. It has an underlying
    collection or computation that produces values that can be consumed by a consumer.
    But the difference is that the consumer doesn't pull these values from the producer
    like in the Iterator pattern; instead the producer pushes the values as notifications
    to the consumer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveX框架（无论是RxKotlin还是RxJava）的构建块是可观察的。`Observable`类与迭代器相反。它有一个底层集合或计算，产生可以被消费者消费的值。但不同之处在于，消费者不像在迭代器模式中那样从生产者那里拉取这些值；相反，生产者将值作为通知推送到消费者。
- en: 'So, let''s take the same example again, this time with `observable`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们再次使用相同的示例，这次使用`observable`：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This program''s output is the same as the previous one; it prints all the items
    in the list. The difference is in its approach. So, let''s see how it actually
    works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结果与上一个相同；它打印出列表中的所有项目。不同之处在于其方法。因此，让我们看看它实际上是如何工作的：
- en: Created a list (the same as the previous one)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个列表（与上一个相同）
- en: An `Observable` instance is created by the `list`
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`list`创建了一个`Observable`实例
- en: We subscribe to the observer (we're using named arguments for lambda; we will
    cover them in detail later)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们订阅了观察者（我们使用lambda的命名参数；我们将在后面详细讨论它们）
- en: As we subscribe to the `observable` variable, each data will be pushed to `onNext`
    as it gets ready; it'll call `onComplete` when all the data is pushed, and `onError`
    if any error occurs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅`observable`变量时，每个数据都会在准备好后推送到`onNext`；当所有数据都推送后，它会调用`onComplete`，如果发生任何错误，则会调用`onError`。
- en: So, you learned how to use the `Observable` instances and that they are quite
    similar to the Iterator instances, something we're quite familiar with. We can
    use these `Observable` instances for building asynchronous streams and pushing
    data updates to their subscribers (even to multiple subscribers). This was a simple
    implementation of the reactive programming paradigm. The data is being propagated
    to all the interested parties—the subscribers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你学习了如何使用`Observable`实例，并且它们与我们所熟悉的迭代器实例相当相似。我们可以使用这些`Observable`实例来构建异步流并将数据更新推送到它们的订阅者（甚至是多个订阅者）。这是一个简单的响应式编程范式实现。数据正在传播到所有感兴趣的各方——订阅者。
- en: Observables
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象
- en: 'As we discussed earlier, in reactive programming, `Observable` has an underlying
    computation that produces values that can be consumed by a consumer (`Observer`).
    The most important thing here is that the consumer (`Observer`) doesn''t pull
    values here; rather, `Observable` pushes the values to the consumer. So, we can
    say that an `Observable` interface is a push-based, composable Iterator that emits
    its items through a series of operators to the final `Observer`, which finally
    consumes the items. Let''s now break these things down sequentially to understand
    it better:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，在响应式编程中，`Observable`有一个底层计算，产生可以被消费者（`Observer`）消费的值。这里最重要的东西是，消费者（`Observer`）在这里不是拉取值；而是`Observable`将值推送到消费者。因此，我们可以说`Observable`接口是一个基于推送、可组合的迭代器，通过一系列操作符将项目发射到最后一个`Observer`，最终消费这些项目。现在让我们按顺序分解这些内容，以更好地理解：
- en: '`Observer` subscribes to `Observable`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observer`订阅`Observable`'
- en: '`Observable` starts emitting the items that it has in it'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable`开始发出它所包含的项目'
- en: '`Observer` reacts to whatever item the `Observable` emits'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observer`对`Observable`发出的任何项目做出反应'
- en: So, let's delve into how `Observable` works through its events/methods, namely
    `onNext`, `onComplete`, and `onError`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们深入了解`Observable`是如何通过其事件/方法工作的，即`onNext`、`onComplete`和`onError`。
- en: How Observable works
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable`的工作原理'
- en: 'As we stated earlier, an `Observable` value has the following three most important
    events/methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，一个`Observable`值有以下三个最重要的事件/方法：
- en: '`onNext`: The `Observable` interface passes all the items one by one to this
    method'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：`Observable`接口将所有项目逐个传递给此方法'
- en: '`onComplete`: When all the items have gone through the `onNext` method, the
    `Observable` calls the `onComplete` method'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：当所有项目都通过`onNext`方法后，`Observable`调用`onComplete`方法'
- en: '`onError`: When the `Observable` faces any error, it calls the `onError` method
    to deal with the error, if defined'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：当`Observable`遇到任何错误时，它调用`onError`方法来处理错误，如果已定义'
- en: One thing to note here is that the item in `Observable` that we are talking
    about can be anything; it is defined as `Observable<T>`, where `T` can be any
    class. Even an array/list can be assigned as `Observable`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们所说的`Observable`中的项目可以是任何东西；它定义为`Observable<T>`，其中`T`可以是任何类。甚至可以将数组/列表分配为`Observable`。
- en: 'Let''s look at the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图示：
- en: '![](img/9a1883a3-293a-427e-82f6-3e786e9e9dea.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a1883a3-293a-427e-82f6-3e786e9e9dea.png)'
- en: 'Here''s a code example to understand it better:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，以更好地理解它：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we declared the observer instance of the `Any` datatype
    at comment `1`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在注释`1`处声明了`Any`数据类型的观察者实例。
- en: Here, we take the benefit of the `Any` datatype. In Kotlin, every class is a
    child class of `Any`. Also, in Kotlin, everything is a class and object; there
    is no separate primitive datatype.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了`Any`数据类型的好处。在Kotlin中，每个类都是`Any`类的子类。此外，在Kotlin中，一切都是类和对象；没有单独的原始数据类型。
- en: 'The `Observer` interface has four methods declared in it. The `onComplete()`
    method at comment `2` gets called when `Observable` is finished with all its items
    without any error. At comment `3`, we defined the `onNext(item: Any)` function,
    which will be called by the `observable` value  for each item it has to emit.
    In that method, we printed the data to the console. At comment `4`, we defined
    the `onError(e: Throwable)` method, which will be called in case the `Observable` interface
    faces an error. At comment `5`, the `onSubscribe(d: Disposable)` method will get
    called whenever the `Observer` subscribes to `Observable`. At comment `6`, we
    created an `Observable` from a list (`val observable`) and subscribed to the `observable` value
    with the `observer` value at comment `7`. At comment `8`, we again created `observable`
    (`val observableOnList`), which holds lists as items.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer` 接口中有四个声明的方法。注释 `2` 中的 `onComplete()` 方法在 `Observable` 完成所有项目且没有任何错误时被调用。在注释
    `3` 中，我们定义了 `onNext(item: Any)` 函数，这个函数将由 `observable` 值对每个要发射的项目调用。在这个方法中，我们将数据打印到控制台。在注释
    `4` 中，我们定义了 `onError(e: Throwable)` 方法，当 `Observable` 接口遇到错误时将被调用。在注释 `5` 中，`onSubscribe(d:
    Disposable)` 方法将在 `Observer` 订阅到 `Observable` 时被调用。在注释 `6` 中，我们从一个列表中创建了一个 `Observable`
    (`val observable`) 并使用注释 `7` 中的 `observer` 值订阅了 `observable` 值。在注释 `8` 中，我们再次创建
    `observable` (`val observableOnList`)，它包含列表作为项目。'
- en: 'The output of the program is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/2785f2bc-9a0a-4d42-9f16-d71184dfe82e.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2785f2bc-9a0a-4d42-9f16-d71184dfe82e.jpg)'
- en: So, as you can see in the output, for the first subscription (comment `7`),
    when we subscribe to the `observable` value, it calls the `onSubscribe` method,
    then the `Observable` property starts emitting items, as `observer` starts receiving
    them on the `onNext` method and prints them. When all the items are emitted from
    the `Observable` property, it calls the `onComplete` method to denote that all
    the items have been successfully emitted. It is the same with the second one,
    except that here, each item is a list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你在输出中看到的，对于第一次订阅（注释 `7`），当我们订阅到 `observable` 值时，它调用 `onSubscribe` 方法，然后
    `Observable` 属性开始发射项目，因为 `observer` 开始在 `onNext` 方法中接收它们并将它们打印出来。当 `Observable`
    属性的所有项目都被发射出来后，它调用 `onComplete` 方法来表示所有项目都已成功发射。第二个也是同样的，只是这里的每个项目都是一个列表。
- en: As we gained some grip on `Observables`, you can now learn a few ways to create
    Observable factory methods for `Observable`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐渐掌握了 `Observables`，你现在可以学习一些创建 `Observable` 工厂方法的方法。
- en: The Observable.create method
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.create 方法
- en: 'At any time, you can create your own custom implementation of `Observable`
    with the `Observable.create` method. This method takes an instance of the `ObservableEmitter<T>`
    interface as a source to observe. Take a look at the following code example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，你都可以使用 `Observable.create` 方法创建自己的自定义 `Observable` 实现。这个方法接受一个 `ObservableEmitter<T>`
    接口的实例作为观察的来源。看看下面的代码示例：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we created an instance of the `Observer` interface as the previous example.
    I will not elaborate the `observer` value, as we have already seen an overview
    in the previous example, and will see this in detail later in this chapter. At
    comment `1`, we created an `Observable` value with the `Observable.create` method.
    We have emitted four strings from the `Observable` value with the help of `onNext`
    method, then notified it is complete with the `onComplete` method. At comment
    `2`, we almost did the same except here, instead of calling `onComplete`, we called
    `onError` with a custom `Exception` function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `Observer` 接口的实例，就像之前的例子一样。我不会详细解释 `observer` 值，因为我们已经在之前的例子中看到了概述，并且将在本章后面详细讨论。在注释
    `1` 中，我们使用 `Observable.create` 方法创建了一个 `Observable` 值。我们通过 `onNext` 方法从这个 `Observable`
    值中发射了四个字符串，然后使用 `onComplete` 方法通知它完成。在注释 `2` 中，我们几乎做了同样的事情，只是在这里，我们不是调用 `onComplete`，而是调用带有自定义
    `Exception` 函数的 `onError`。
- en: 'Here is the output of the program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序的输出：
- en: '![](img/0a3f8053-dcf0-4265-9e46-6457e646e21a.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a3f8053-dcf0-4265-9e46-6457e646e21a.jpg)'
- en: The `Observable.create` method is useful, especially when you are working with
    a custom data structure and want to have a control over which values are getting
    emitted. You can also emit values to the observer from a different thread.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.create` 方法很有用，尤其是在你使用自定义数据结构并且想要控制哪些值被发射出来时。你还可以从不同的线程向观察者发射值。'
- en: The **Observable contract** ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    states that Observables must issue notifications to observers serially (not in
    parallel). They may issue these notifications from different threads, but there
    must be a formal happens-before relationship between the notifications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Observable 合约** ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    指出，Observables 必须按顺序（而不是并行）向观察者发出通知。它们可以从不同的线程发出这些通知，但通知之间必须存在正式的“发生之前”关系。'
- en: The Observable.from methods
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The Observable.from methods
- en: The `Observable.from` methods are comparatively simpler than the `Observable.create`
    method. You can create the `Observable` instances from nearly every Kotlin structure
    with the help of from methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.from` 方法相对于 `Observable.create` 方法来说比较简单。您可以使用 from 方法从几乎任何 Kotlin
    结构中创建 `Observable` 实例。'
- en: In RxKotlin 1, you will have `Observale.from` as a method; however, from RxKotlin
    2.0 (as with RxJava2.0), operator overloads have been renamed with a postfix,
    such as `fromArray`, `fromIterable`, and `fromFuture`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxKotlin 1 中，你将拥有 `Observale.from` 作为一种方法；然而，从 RxKotlin 2.0（与 RxJava2.0 相同），操作符重载已被重命名为后缀，例如
    `fromArray`、`fromIterable` 和 `fromFuture`。
- en: 'Let''s take a look at the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At comment `1`, we used the `Observable.fromIterable` method to create `Observable`
    from an `Iterable` instance (here, `list`). At comment `2`. We called the `Observable.fromCallable`
    method to create `Observable` from a `Callable` instance, we did the same at comment
    `3`, where we called the `Observable.fromFuture` method to derive `Observable`
    from a `Future` instance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `1` 中，我们使用了 `Observable.fromIterable` 方法从 `Iterable` 实例（此处为 `list`）创建 `Observable`。在注释
    `2` 中，我们调用了 `Observable.fromCallable` 方法从 `Callable` 实例创建 `Observable`，在注释 `3`
    中，我们调用了 `Observable.fromFuture` 方法从 `Future` 实例派生出 `Observable`。
- en: 'Here is the output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/0acfe4dd-acb4-44c8-b9f7-33e32fc9722e.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0acfe4dd-acb4-44c8-b9f7-33e32fc9722e.jpg)'
- en: Iterator<T>.toObservable
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iterator<T>.toObservable
- en: 'Thanks to the extension functions of Kotlin, you can turn any `Iterable` instance,
    such as `list`, to `Observable` without much effort. We have already used this
    method in [Chapter 1](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml), *Kotlin – Data
    Types, Objects, and Classes*, but again take a look at this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Kotlin 的扩展函数，您可以将任何 `Iterable` 实例（如 `list`）轻松地转换为 `Observable`。我们已经在 [第
    1 章](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml)，*Kotlin – 数据类型、对象和类* 中使用了此方法，但再次看看这个：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/0ed751e5-b092-40cf-b3b0-82c6b2c25d1c.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ed751e5-b092-40cf-b3b0-82c6b2c25d1c.jpg)'
- en: 'So, aren''t you curious to look into the `toObservable` method? Let''s do it.
    You can find this method inside the `observable.kt` file provided with the `RxKotlin`
    package:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您难道不好奇想看看 `toObservable` 方法吗？让我们来做这件事。您可以在 `RxKotlin` 包提供的 `observable.kt`
    文件中找到此方法：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, it uses the `Observable.from` method internally, thanks again to the extension
    functions of Kotlin.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它内部使用 `Observable.from` 方法，这要归功于 Kotlin 的扩展函数。
- en: Subscriber – the Observer interface
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subscriber – the Observer interface
- en: In RxKotlin 1.x, the `Subscriber` operator essentially became an `Observer` type
    in RxKotlin 2.x. There is an `Observer` type in RxKotlin 1.x, but the `Subscriber` value
    is what you pass to the `subscribe()` method, and it implements `Observer`. In
    RxJava 2.x, a `Subscriber` operator only exists when talking about `Flowables`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxKotlin 1.x 中，`Subscriber` 操作符在 RxKotlin 2.x 中本质上变成了 `Observer` 类型。在 RxKotlin
    1.x 中有一个 `Observer` 类型，但 `Subscriber` 值是你传递给 `subscribe()` 方法的，并且实现了 `Observer`。在
    RxJava 2.x 中，`Subscriber` 操作符仅在谈论 `Flowables` 时存在。
- en: 'As you can see in the previous examples in this chapter, an `Observer` type
    is an interface with four methods in it, namely `onNext(item:T)`, `onError(error:Throwable)`,
    `onComplete()`, and `onSubscribe(d:Disposable)`. As stated earlier, when we connect `Observable` to
    `Observer`, it looks for these four methods in the `Observer` type and calls them.
    Here is a short description of the following four methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本章前面的示例中所见，`Observer` 类型是一个接口，其中包含四个方法，即 `onNext(item:T)`、`onError(error:Throwable)`、`onComplete()`
    和 `onSubscribe(d:Disposable)`。如前所述，当我们连接 `Observable` 到 `Observer` 时，它会在 `Observer`
    类型中寻找这四个方法并调用它们。以下是以下四个方法的简要描述：
- en: '`onNext`: The `Observable` calls this method of `Observer` to pass each of
    the items one by one'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：`Observable` 调用此方法将每个项逐个传递给 `Observer`'
- en: '`onComplete`: When the `Observable` wants to denote that it''s done with passing
    items to the `onNext` method, it calls the `onComplete` method of `Observer`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：当 `Observable` 想表示它已经完成了向 `onNext` 方法传递项的操作时，它调用 `Observer` 的
    `onComplete` 方法'
- en: '`onError`: When `Observable` faces any error, it calls the `onError` method
    to deal with the error if defined in the `Observer ` type, otherwise it throws
    the exception'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：当`Observable`遇到任何错误时，它会调用`onError`方法来处理错误，如果`Observer`类型中定义了错误处理，否则它将抛出异常'
- en: '`onSubscribe`: This method is called whenever a new `Observable` subscribes
    to `Observer`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubscribe`：每当一个新的`Observable`订阅到`Observer`时，都会调用此方法'
- en: Subscribing and disposing
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅和处置
- en: So, we have `Observable` (the thing that should be observed upon) and we have
    the `Observer` type (that should be observed), now what? How do we connect them?
    `Observable` and `Observer` are like an input device (be it keyboard or mouse)
    and the computer; we need something to connect them (even wireless input devices
    have some connectivity channels, be it Bluetooth or Wi-Fi).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有`Observable`（应该观察的事物）和`Observer`类型（应该观察的类型），现在怎么办？我们如何将它们连接起来？`Observable`和`Observer`就像一个输入设备（无论是键盘还是鼠标）和计算机；我们需要某种东西来连接它们（即使是无线输入设备也有一些连接通道，无论是蓝牙还是Wi-Fi）。
- en: The `subscribe` operator serves the purpose of the media by connecting an `Observable` interface
    to `Observer`. We can pass one to three methods (`onNext`, `onComplete`, and `onError`)
    to the `subscribe` operator, or we can pass an instance of the `Observer` interface
    to the subscribe operator to get the `Observable` interface connected with `Observer`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`操作符的作用是连接`Observable`接口和`Observer`，充当媒体的作用。我们可以向`subscribe`操作符传递一到三个方法（`onNext`、`onComplete`和`onError`），或者我们可以向`subscribe`操作符传递`Observer`接口的实例，以获取与`Observer`连接的`Observable`接口。'
- en: 'So, let''s look at an example now:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在让我们来看一个例子：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we have created an `Observable` instance (at comment `1`) and
    used it twice with different overload `subscribe` operators. At comment `2`, we
    passed three methods as arguments to the `subscribe` method. The first parameter
    is the `onNext` method, the second one is the `onError` method, and the last one
    is `onComplete`. At comment `2`, we passed an instance of the `Observer` interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`Observable`实例（在注释`1`处），并使用不同的重载`subscribe`操作符使用了两次。在注释`2`中，我们将三个方法作为参数传递给了`subscribe`方法。第一个参数是`onNext`方法，第二个是`onError`方法，最后一个是`onComplete`。在注释`2`中，我们传递了`Observer`接口的实例。
- en: The output can be easily predicted, so we are skipping it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出很容易预测，所以我们跳过它。
- en: So, we have got the concepts of subscribing, and can do it now. What about if
    you want to stop the emissions after some period of subscription? There must be
    a way, right? So, let's inspect this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经了解了订阅的概念，现在可以这样做。如果你想在订阅一段时间后停止发射，怎么办？肯定有办法，对吧？那么，让我们检查一下。
- en: Remember the `onSubscribe` method of `Observer`? There was a parameter on that
    method which we haven't discussed yet. While you subscribe, if you pass the methods
    instead of the `Observer` instance, then the `subscribe` operator will return
    an instance of `Disposable`, or if you use an instance of `Observer`, then you
    will get the instance of `Disposable` in the parameter of the `onSubscribe` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记得`Observer`的`onSubscribe`方法吗？在那个方法中有一个我们还没有讨论过的参数。当你订阅时，如果你传递方法而不是`Observer`实例，那么`subscribe`操作符将返回一个`Disposable`实例，或者如果你使用`Observer`实例，那么你将在`onSubscribe`方法的参数中得到`Disposable`实例。
- en: 'You can use the instance of the `Disposable` interface to stop emissions at
    any given time. Let''s look at an example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Disposable`接口的实例在任何给定时间停止发射。让我们来看一个例子：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we used the `Observable.interval` factory method. This method takes two
    parameters describing the interval period and time unit; it then emits integers
    sequentially starting from zero. `Observable` created with `interval` never completes
    and never stops until you dispose off them, or the program stops execution. I
    thought it would be the perfect fit in this scenario as we want to stop the `Observable`
    midway here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了`Observable.interval`工厂方法。此方法接受两个参数，描述间隔期间和时间单位；然后按顺序发射从零开始的整数。使用`interval`创建的`Observable`永远不会完成，也永远不会停止，除非你取消它们，或者程序停止执行。我认为它非常适合这个场景，因为我们想在中间停止`Observable`。
- en: So, in this example, at comment `1`, we created `Observable` with the `Observable.interval`
    factory method that will emit an integer after each `100` milliseconds interval.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，在注释`1`处，我们使用`Observable.interval`工厂方法创建了`Observable`，该方法将在每个`100`毫秒间隔后发射一个整数。
- en: At comment `2`, I have declared `lateinit var disposable` of the `Disposable` type (`lateinit`
    means the variable will get initialized at a later point in time). At comment
    `3`, inside the `onSubscribe` method, we will assign the received parameter value
    to the `disposable` variable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`2`中，我声明了`lateinit var disposable`为`Disposable`类型（`lateinit`意味着变量将在稍后的时间点初始化）。在注释`3`中，在`onSubscribe`方法内部，我们将接收到的参数值分配给`disposable`变量。
- en: We intend to stop the execution after the sequence reached `10`, that is, after
    `10` is emitted, the emission should be stopped immediately. To achieve this,
    we placed a check inside the `onNext` method, where we are checking the value
    of the emitted item. We check whether it's equal to or greater than `10`, and
    if the emission is not already stopped (disposed), then we dispose the emission
    (comment `5`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在序列达到`10`后停止执行，也就是说，在`10`被发出后，应立即停止发射。为了实现这一点，我们在`onNext`方法内部放置了一个检查，在那里我们检查发出的项的值。我们检查它是否等于或大于`10`，如果发射尚未停止（未处置），那么我们就处置发射（注释`5`）。
- en: 'Here is the output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![](img/df453c98-95e6-4a48-954d-6a5d66d66886.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df453c98-95e6-4a48-954d-6a5d66d66886.jpg)'
- en: From the output, we can see that no integer got emitted after the `disposable.dispose()`
    method was called, though the execution waited for 500 milliseconds more (100*10
    = 1000 milliseconds to print the sequence till `10`, and we called the delay method
    with `1500`, thus 500 milliseconds after emitting `10`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到在调用`disposable.dispose()`方法后，没有整数被发出，尽管执行等待了500毫秒更多（100*10 = 1000毫秒来打印序列直到`10`，我们使用`1500`调用延迟方法，因此是在发出`10`后的500毫秒）。
- en: 'If you are curious to know the `Disposable` interface, then the following is
    the definition:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇想了解`Disposable`接口，那么以下是其定义：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It has one property that denotes that the emission is already notified to stop
    (disposed) and a method to notify the emission to stop (dispose).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个属性表示发射已经被通知停止（已处置），以及一个通知发射停止（处置）的方法。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about combining FP concepts with OOP and reactive
    programming. We even discussed RxKotlin and covered the setup and basic usage
    of RxKotlin.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将FP概念与OOP和响应式编程相结合。我们甚至讨论了RxKotlin，并涵盖了RxKotlin的设置和基本用法。
- en: The next chapter is about more advanced FP concepts—monads, functors, and applicatives,
    and how to implement them with Kotlin. Monads, functors, and applicatives are
    some of the must-know concepts and are often referred to as the building blocks
    of FP. So, don't skip the next chapter if you are truly willing to learn about
    FP. Turn the page now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍更高级的FP概念——单子、函子、应用，以及如何使用Kotlin实现它们。单子、函子和应用是一些必须了解的概念，通常被称为FP的构建块。所以，如果你真正想学习FP，不要跳过下一章。现在就翻到下一页。
