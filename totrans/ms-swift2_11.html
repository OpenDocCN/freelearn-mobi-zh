<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Working with Generics"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Working with Generics</h1></div></div></div><p>My first experience with generics was back in 2004, when they were first introduced in the Java programming language. I can still remember picking up my copy of <span class="emphasis"><em>The Java Programming Language</em></span>, <span class="emphasis"><em>Fourth edition</em></span>, which covered Java 5, and reading about Java's implementation of generics. Since then, I have used generics in a number of projects, not only in Java but in other languages as well. If you are familiar with generics in other languages, such as Java, the syntax that Swift uses will be familiar to you. Generics allow us to write very flexible and reusable code; however, just like with subscripts, we need to make sure that we use them properly and do not overuse them.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An introduction to generics</li><li class="listitem" style="list-style-type: disc">Creating and using generic functions</li><li class="listitem" style="list-style-type: disc">Creating and using generic classes</li><li class="listitem" style="list-style-type: disc">Using associated types with protocols</li></ul></div><div class="section" title="An introduction to generics"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec71"/>An introduction to generics</h1></div></div></div><p>The <a class="indexterm" id="id471"/>concept of generics has been around for a while, so it should not be a new concept to developers coming from languages such as Java or C#. Swift's implementation of generics is very similar to these languages. For those developers coming from other languages such as Objective-C, which do not have generics, they might seem a bit foreign at first.</p><p>Generics allow us to write very flexible and reusable code that avoids duplication. With a type safe language, such as Swift, we often need to write functions or types that are valid for multiple types. For example, we might need to write a function that swaps the values of two variables; however, we may use this function to swap two string types, two int types, and two double types. Without generics, we will need to write three separate functions; however, with generics, we can write one generic function to provide the swap functionality for multiple types. Generics allow us to tell a function or type—I know Swift is a type-safe language, but I do not know the type that will be needed yet. I will give you a placeholder for now and will let you know what type to enforce later.</p><p>In Swift, we<a class="indexterm" id="id472"/> have the ability to define both generic functions and generic types. Let's look at generic functions first.</p></div></div>
<div class="section" title="Generic functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec72"/>Generic functions</h1></div></div></div><p>Let's <a class="indexterm" id="id473"/>begin by examining the problem that generics try to solve and then we will see how generics solve this problem. Let's say that we wanted to create functions that swapped the values of two variables (as described in the introduction); however, for our application, we have a need to swap two ints, two doubles, and two strings. Without generics, this would require us to write three separate functions. The following code shows what these functions would look similar to:</p><div class="informalexample"><pre class="programlisting">func swapInts (inout a: Int, inout b: Int) {
    let tmp = a
    a = b
    b = tmp
}

func swapDoubles(inout a: Double, inout b: Double) {
    let tmp = a
    a = b
    b = tmp
}

func swapStrings(inout a: String, inout b: String) {
    let tmp = a
    a = b
    b = tmp
}</pre></div><p>With these three functions, we can swap the original values of two ints, two doubles, and two strings. Now, let's say, as we develop our application further, we find out that we also need to swap the values of two UInt32, two floats, or even a couple of custom types. We might easily end up with eight or nine swap functions. The worst part is that each of these functions contains duplicate code. The only difference between these functions is the type of variable change. While this solution does work, generics offer a much more elegant and simple solution that eliminates the duplication of code. Let's see how we would condense all these three preceding functions into a single generic function:</p><div class="informalexample"><pre class="programlisting">func swap&lt;T&gt;(inout a: T, inout b: T) {
    let tmp = a
    a = b
    b = tmp
}</pre></div><p>Let's look at how we defined the <code class="literal">swap()</code> function. The function itself looks pretty similar to a normal function, except for the capital <code class="literal">T</code>. The capital <code class="literal">T</code>, as used in the <code class="literal">swap()</code> function, is a placeholder type and tells Swift that we will be defining the type later. When we do define the type, the type we define will replace all the placeholders.</p><p>To define a <a class="indexterm" id="id474"/>generic function, we include the placeholder type between two angular brackets (<code class="literal">&lt;T&gt;</code>) after the function's name. We can then use that placeholder type in place of any type definition within the parameter definitions, the return type, or the function itself. The big thing to keep in mind is that, once the placeholder is defined as a type, all the other placeholder assume that type. Therefore, any variable or constant defined with that placeholder must conform to that type.</p><p>There is nothing special about the capital <code class="literal">T</code>, we could use any valid identifier in place of <code class="literal">T</code>. The following definitions are perfectly valid:</p><div class="informalexample"><pre class="programlisting">func swap&lt;G&gt;(inout a: G, inout b: G) {
  //Statements
}

func swap&lt;xyz&gt;(inout a: xyz, inout b: xyz) {
  //Statements
}</pre></div><p>In most documentation, generic placeholders are defined with either <code class="literal">T</code> (for type) or <code class="literal">E</code> (for element). For standard purposes, we will use <code class="literal">T</code> to define generic placeholders in this book. It is also good practice to use <code class="literal">T</code> to define a generic placeholder within our code so that the placeholder is easily recognized when we are looking at the code at a later time.</p><p>If we need to use multiple generic types, we can create multiple placeholders by separating them with commas. The following example shows how to define multiple placeholders for a single function:</p><div class="informalexample"><pre class="programlisting">func testGeneric&lt;T,E&gt;(a:T, b:E) {
    
}</pre></div><p>In this example, we are defining two generic placeholders, <code class="literal">T</code> and <code class="literal">E</code>. In this case, we can set the <code class="literal">T</code> placeholder to one type and the <code class="literal">E</code> placeholder to a different type.</p><p>Let's look at how to call a generic function. The following code will swap two integers using the <code class="literal">swapGeneric&lt;T&gt;(inout a: T, inout b: T)</code> function:</p><div class="informalexample"><pre class="programlisting">var a = 5
var b = 10
swap(&amp;a, b: &amp;b)

print("a:  \(a) b:  \(b)")</pre></div><p>If we run this code, the <code class="literal">a:  10  b:  5</code> line will be printed to the console. We can see that we do not<a class="indexterm" id="id475"/> have to do anything special to call a generic function. The function infers the type from the first parameter and then sets all the remaining placeholders to that type. Now, if we need to swap the values of two strings, we will call the same function like this:</p><div class="informalexample"><pre class="programlisting">var c = "My String 1"
var d = "My String 2"
swapGeneric(&amp;c, b: &amp;d)
print("c:  \(c) d:  \(d)")</pre></div><p>We can see that we call the function in exactly the same way as we called it when we wanted to swap two integers. One thing that we cannot do is pass two different types into the <code class="literal">swap()</code> function because we defined only one generic placeholder. If we attempt to run the following code, we will receive an error:</p><div class="informalexample"><pre class="programlisting">var a = 5
var c = "My String 1"
swapGeneric(&amp;a, b: &amp;c)</pre></div><p>The error that we will receive is <code class="literal">cannot invoke 'swap' with an argument list of type '(inout Int, b: inout String</code>, which tells us that we are attempting to use a string value with an int value when the function wants only type. The reason the function is looking for an Int value is that the first parameter that we pass into the function is an Int value; therefore, all the generic types in the function became Int types.</p><p>Now, let's say we have the following function that has multiple generic types defined:</p><div class="informalexample"><pre class="programlisting">func testGeneric&lt;T,E&gt;(a:T, b:E) {
    print("\(a)  \(b)")
}</pre></div><p>This function would accept parameters of different types; however; since they are of different types, we would be unable to swap the values because the types are different. There are also other limitations on generics. For example, we may think that the following generic function would be valid; however, we would receive an error if we tried to implement it:</p><div class="informalexample"><pre class="programlisting">func genericEqual&lt;T&gt;(a: T, b: T) -&gt; Bool{
    return a == b
}</pre></div><p>The error that we receive is <code class="literal">binary operator '==' cannot be applied to two 'T' operands</code>. Since the type of the arguments is unknown at the time the code is compiled, Swift does not know if it is able to use the equal operator on the types; therefore, the error is thrown. We might think that this is a limit that will make generics hard to use; however, we have a way to tell Swift that we expect the type, represented by the placeholder will have a certain functionality. This is done with type constraints.</p><p>A type<a class="indexterm" id="id476"/> constraint specifies that a generic type must inherit from a specific class or conform to a particular protocol. This allows us to use the methods and properties defined by the parent class or protocol within the generic function. Let's look at how to use type constraints by rewriting the <code class="literal">genericEqual()</code> function to use the comparable protocol:</p><div class="informalexample"><pre class="programlisting">func testGenericComparable&lt;T: Comparable&gt;(a: T, b: T) -&gt; Bool{
    return a &gt;= b
}</pre></div><p>To specify the type constraint, we put the class or protocol constraint after the generic placeholder, where the generic placeholder and the constraint are separated by a colon. This new function works as we might expect, and it will compare the values of the two parameters and return <code class="literal">true</code> if they are equal or <code class="literal">false</code> if they are not.</p><p>We can declare multiple constraints just like we declare multiple generic types. The following example shows how to declare two generic types with different constraints:</p><div class="informalexample"><pre class="programlisting">func testFunction&lt;T: MyClass, E: MyProtocol&gt;(a: T, b: E) {
}</pre></div><p>In this function, the type defined by the <code class="literal">T</code> placeholder must inherit from the <code class="literal">MyClass</code> class, and the type defined by the <code class="literal">E</code> placeholder must implement the <code class="literal">MyProtocol</code> protocol. Now that we have looked at generic functions, let's take a look at generic types.</p></div>
<div class="section" title="Generic types"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec73"/>Generic types</h1></div></div></div><p>We have <a class="indexterm" id="id477"/>already had a general introduction to how generic types work when we looked at Swift arrays and dictionaries. A generic type is a class, structure, or enum that can work with any type, just like the way the Swift arrays and dictionaries work. As we recall, Swift arrays and dictionaries are written so that they can contain any type. The catch is we cannot mix-and-match different types within an array or dictionary. When we create an instance of our generic type, we define the type that the instance will work with. After we define that type, we cannot change the type for that instance.</p><p>To demonstrate <a class="indexterm" id="id478"/>how to create a generic type, let's create a simple <code class="literal">List</code> class. This class will use a Swift array as the backend storage for the list and will let us add items to the list or retrieve values from the list.</p><p>Let's begin by seeing how to define our generic list type:</p><div class="informalexample"><pre class="programlisting">class List&lt;T&gt; {
}</pre></div><p>The preceding code defines the generic list type. We can see that we use the <code class="literal">&lt;T&gt;</code> tag to define a generic placeholder, just like we did when we defined a generic function. This <code class="literal">T</code> placeholder can then be used anywhere within the type instead of a concrete type definition.</p><p>To create an<a class="indexterm" id="id479"/> instance of this type, we would need to define the type of items that our list will hold. The following examples show how to create instances of the generic list type for various types:</p><div class="informalexample"><pre class="programlisting">var stringList = List&lt;String&gt;()
var intList = List&lt;Int&gt;()
var customList = List&lt;MyObject&gt;()</pre></div><p>The preceding example creates three instances of the <code class="literal">List</code> class. The <code class="literal">stringList</code> instance can be used with String types, the <code class="literal">intList</code> instance can be used with Int types, and the <code class="literal">customList</code> instance can be used with instances of the <code class="literal">MyObject</code> type.</p><p>We are not limited to using generics only with classes. We can also define structures and enums as generics. The following examples show how to define a generic structure and a generic enum:</p><div class="informalexample"><pre class="programlisting">struct GenericStruct&lt;T&gt; {
    
}

enum GenericEnum&lt;T&gt; {
    
}</pre></div><p>The next step in our <code class="literal">List</code> class is to add the backend storage array. The items stored in this array need to be of the same type as we define when we initiate the class; therefore, we will use the <code class="literal">T</code> placeholder when we define the type for the array. The following code shows the <code class="literal">List</code> class with an array named <code class="literal">items</code>. The <code class="literal">items</code> array will be defined using the <code class="literal">T</code> placeholder, so it will hold the same types as we defined for the class:</p><div class="informalexample"><pre class="programlisting">class List&lt;T&gt; {
    var items = [T]()
}</pre></div><p>This code defines our generic list type and uses <code class="literal">T</code> as the type placeholder. We can then use the <code class="literal">T</code> placeholder anywhere in the class to define the type of an item. That item will then be of the same type that we defined when we created the instance of the <code class="literal">List</code> class. Therefore, if we create an instance of the list type like this <code class="literal">var stringList = List&lt;String&gt;()</code>, the items array will be an array of string instances. If we created an instance of the list type like this <code class="literal">var intList = List&lt;Int&gt;()</code>, the item array will be an array of Int instances.</p><p>Now, we will need to add the <code class="literal">addItems()</code> method that will be used to add an item to the list. We will use the <code class="literal">T</code> placeholder within the method declaration to define that the item parameter will be of the same type as we declared when we initiated the class. Therefore, if we create an instance of the list type to use the string type, we would be required to use the string type<a class="indexterm" id="id480"/> as the parameter for the <code class="literal">addItems()</code> method. However, if we create an instance of the list type to use the int type, we would be required to use the int type as the parameter for the <code class="literal">addItems()</code> method.</p><p>Here is the code for the <code class="literal">addItems()</code> function:</p><div class="informalexample"><pre class="programlisting">func addItem(item: T) {
    items.append(item)
}</pre></div><p>To create a standalone generic function, we add the <code class="literal">&lt;T&gt;</code> declaration after the function name to declare that it is a generic function; however, when we use a generic method within a generic type, we do not need the <code class="literal">&lt;T&gt;</code> declaration. Instead, all we need to do is to use the type that we defined in the class declaration. If we wanted to introduce another generic type, we could define it with the method declaration.</p><p>Now, let's add the <code class="literal">getItemAtIndex()</code> method that will return the item from the backend array, at the specified index:</p><div class="informalexample"><pre class="programlisting">func getItemAtIndex(index: Int) -&gt; T? {
    if items.count &gt; index {
        return items[index]
    } else {
        return nil
    }
}</pre></div><p>The <code class="literal">getItemAtIndex()</code> method accepts one argument that is the index of the item we want to retrieve. We then use the <code class="literal">T</code> placeholder to specify that our return type is an optional that might be of type <code class="literal">T</code> or <code class="literal">nil</code>. If the backend storage array contains an item at the specified index, we will return that item; otherwise, we return no value.</p><p>Now, let's look at our entire generic list class:</p><div class="informalexample"><pre class="programlisting">class List&lt;T&gt; {
    var items = [T]()
    
    func addItem(item: T) {
        items.append(item)
    }
    
    func getItemAtIndex(index: Int) -&gt; T? {
        if items.count &gt; index {
            return items[index]
        } else {
            return nil
        }
    }
}</pre></div><p>As we can see, we <a class="indexterm" id="id481"/>initially defined the generic <code class="literal">T</code> placeholder type in the class declaration. We then used this placeholder type within our class. In our <code class="literal">List</code> class, we use this placeholder in three places. We use it as the type for our items array, as the parameter type for our <code class="literal">addItem()</code> method, and as the associated value for the optional return type in the <code class="literal">getItemAtIndex()</code> method.</p><p>Now, let's look at how to use the <code class="literal">List</code> class. When we use a generic type, we define the type to be used within the class between angle brackets, such as <code class="literal">&lt;type&gt;</code>. The following code shows how to use the <code class="literal">List</code> class to store string types:</p><div class="informalexample"><pre class="programlisting">var list = List&lt;String&gt;()
list.addItem("Hello")
list.addItem("World")
print(list.getItemAtIndex(1))</pre></div><p>In this code, we start off by creating an instance of the list type called <code class="literal">list</code> and set it to store <code class="literal">String</code> types. We then use the <code class="literal">addItem()</code> method twice to store two items in the list instance. Finally, we use the <code class="literal">getItemAtIndex()</code> method to retrieve the item at index number <code class="literal">1</code>, which will display <code class="literal">Optional(World)</code> to the console.</p><p>We can also define our generic types with multiple placeholder types, similar to how we use multiple placeholders in our generic methods. To use multiple placeholder types, we would separate them with commas. The following example shows how to define multiple placeholder types:</p><div class="informalexample"><pre class="programlisting">class MyClass&lt;T,E&gt;{

}</pre></div><p>We then create an instance of the <code class="literal">MyClass</code> type that uses the <code class="literal">String</code> and <code class="literal">Int</code> types, such as:</p><div class="informalexample"><pre class="programlisting">var mc = MyClass&lt;String, Int&gt;()</pre></div><p>We can also use type constraints with generic types. Once again, using a type constraint for a generic type is exactly the same as using one with a generic function. The following code shows how to use a type constraint to ensure that the generic type conforms to the comparable protocol:</p><div class="informalexample"><pre class="programlisting">class MyClass&lt;T: Comparable&gt;{}</pre></div><p>So far, in this chapter, we have seen how to use placeholder types with functions and types. At times, it can be useful to declare one or more placeholder types in a protocol. These types are known <a class="indexterm" id="id482"/>as <span class="strong"><strong>associated types</strong></span>.</p></div>
<div class="section" title="Associated types"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec74"/>Associated types</h1></div></div></div><p>An associated type<a class="indexterm" id="id483"/> declares a placeholder name that can be used instead of a type within a protocol. The actual type to be used is not specified until the protocol is adopted. While creating generic functions and types, we used a very similar syntax. Defining associated types for a protocol, however, is very different. We specify an associated type using the <code class="literal">typealias</code> keyword.</p><p>Let's see how to use associated types when we define a protocol. In this example, we will define the <code class="literal">QueueProtocol</code> protocol that will define the capabilities that need to be implemented by the queue that implements it:</p><div class="informalexample"><pre class="programlisting">protocol QueueProtocol {
    typealias QueueType
    mutating func addItem(item: QueueType)
    mutating func getItem() -&gt; QueueType?
    func count() -&gt; Int
}</pre></div><p>In this protocol, we define one associated type named <code class="literal">QueueType</code>. We then used this associated type twice within the protocol—once as the parameter type for the <code class="literal">addItem()</code> method and once when we define the return type of the <code class="literal">getItem()</code> method as an optional type that might return the associated type of <code class="literal">QueueType</code> or a <code class="literal">nil</code>.</p><p>Any type that implements the <code class="literal">QueueProtocol</code> protocol must be able to specify the type to use for the <code class="literal">QueueType</code> placeholder and must also ensure that only items of that type are used where the protocol uses the <code class="literal">QueueType</code> placeholder.</p><p>Let's look at how to implement <code class="literal">QueueProtocol</code> in a non-generic class called <code class="literal">IntQueue</code>. This class will implement the <code class="literal">QueueProtocol</code> protocol using the <code class="literal">Int</code> type:</p><div class="informalexample"><pre class="programlisting">class IntQueue: QueueProtocol {
  var items = [Int]()
  
  func addItem(item: Int) {
    items.append(item)
  }
  
  func getItem() -&gt; Int? {
    if items.count &gt; 0 {
      return items.removeAtIndex(0)
    }
    else {
      return nil
    }
  }
  
  func count() -&gt; Int {
    return items.count
  }
}</pre></div><p>In the <code class="literal">IntQueue</code> class, we<a class="indexterm" id="id484"/> begin by defining our backend storage mechanism to be an array of <code class="literal">Int</code> types. We then implement each of the methods defined in the <code class="literal">QueueProtocol</code> protocol, replacing the <code class="literal">QueueType</code> placeholder defined in the protocol with the Int type. In the <code class="literal">addItem()</code> method, the parameter type is defined to be an <code class="literal">Int</code> type, and in the <code class="literal">getItem()</code> method the return type is defined to be an optional that might return an <code class="literal">Int</code> type or no value.</p><p>We use the <code class="literal">IntQueue</code> class as we would use any other class. The following code shows this:</p><div class="informalexample"><pre class="programlisting">var intQ = IntQueue()
intQ.addItem(2)
intQ.addItem(4)
print(intQ.getItem())
intQ.addItem(6)</pre></div><p>We begin by creating an instance of the <code class="literal">IntQueue</code> class named <code class="literal">intQ</code>. We then call the <code class="literal">addItem()</code> method twice to add two values of the int type to the <code class="literal">intQ</code> instance. We then retrieve the first item in the <code class="literal">intQ</code> instance by calling the <code class="literal">getItem()</code> method. This line will print the number <code class="literal">Optional(2)</code> to the console. The final line of code adds another int type to the <code class="literal">intQ</code> instance.</p><p>In the preceding example, we implemented the <code class="literal">QueueProtocol</code> protocol in a non-generic way. This means that we replaced the placeholder types with an actual type (<code class="literal">QueueType</code> was replaced by the <code class="literal">Int</code> type). We can also implement the <code class="literal">QueueProtocol</code> protocol with a generic type. Let's see how to implement the <code class="literal">QueueProtocol</code> protocol in a generic type called <code class="literal">GenericQueue</code>:</p><div class="informalexample"><pre class="programlisting">class GenericQueue&lt;T&gt;: QueueProtocol {
    var items = [T]()
    
    func addItem(item: T) {
        items.append(item)
    }
    
    func getItem() -&gt; T? {
        if items.count &gt; 0 {
            return items.removeAtIndex(0)
        } else {
            return nil
        }
    }
    
    func count() -&gt; Int {
        return items.count
    }
}</pre></div><p>As we can<a class="indexterm" id="id485"/> see, the <code class="literal">GenericQueue</code> implementation is very similar to the <code class="literal">IntQueue</code> implementation, except that we define the type to use as the generic placeholder <code class="literal">T</code>. We can then use the <code class="literal">GenericQueue</code> class as we would use any generic class. Let's take a look at how to use the <code class="literal">GenericQueue</code> class:</p><div class="informalexample"><pre class="programlisting">var intQ2 = GenericQueue&lt;Int&gt;()
intQ2.addItem(2)
intQ2.addItem(4)
print(intQ2.getItem())
intQ2.addItem(6)</pre></div><p>We begin by creating an instance of the <code class="literal">GenericQueue</code> class that will use the <code class="literal">Int</code> type. This instance is named <code class="literal">intQ2</code>. Next, we call the <code class="literal">addItem()</code> method twice to add two Int types to the <code class="literal">intQ2</code> instance. We then retrieve the first <code class="literal">Int</code> type that was added using the <code class="literal">getItem()</code> method and print the value to the console. This line will print the number <code class="literal">2</code> to the console.</p><p>One of the things that we should watch out for while using generics is to avoid using them when we should be using protocols. This is, in my opinion, one of the most common misuses of generics in other languages. Let's take a look at an example so that we know what to avoid.</p><p>Let's say that we define a protocol called <code class="literal">WidgetProtocol</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">protocol WidgetProtocol {
    //Code
}</pre></div><p>Now, let's say that we want to create a custom type (or function) that will use various implementations of the <code class="literal">WidgetProtocol</code> protocol. I have seen a couple of instances where developers have used generics with a type constraint to create custom types like this:</p><div class="informalexample"><pre class="programlisting">class MyClass&lt;T: WidgetProtocol&gt; {
    var myProp: T?
    func myFunc(myVar: T) {
        //Code
    }
}</pre></div><p>While this is a perfectly valid use of generics, it is recommended that we avoid implementations like this. It is a lot cleaner and easier to read if we use <code class="literal">WidgetProtocol</code> without generics. For example, we can write a non-generic version of the <code class="literal">MyClass</code> type like this:</p><div class="informalexample"><pre class="programlisting">class MyClass {
    var myProp: WidgetProtocol?
    func myFunc(myVar: WidgetProtocol) {
        
    }
}</pre></div><p>The second <a class="indexterm" id="id486"/>non-generic version of the <code class="literal">MyClass</code> type is a lot easier to read and understand; therefore, this should be the preferable way to implement the class. However, there is nothing preventing us from using either implementation of the <code class="literal">MyClass</code> type.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec75"/>Summary</h1></div></div></div><p>Generic types can be incredibly useful, and they are also the basis of the Swift standard collection types (array and dictionary); however, as mentioned in the introduction to this chapter, we have to be careful to use them correctly.</p><p>We have seen a couple of examples in this chapter that show how generics can make our lives easier. The <code class="literal">swapGeneric()</code> function that was shown at the beginning of the chapter is a good use of a generic function because it allows us to swap the two values of any type we choose while only implementing the swap code once.</p><p>The generic list type is also a good example of how to make custom collection types that can be used to hold any type. How we implemented the generic list type in this chapter is similar to how Swift implements the array and dictionary with generics.</p></div></body></html>