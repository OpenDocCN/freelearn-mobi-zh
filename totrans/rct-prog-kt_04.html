<html><head></head><body>
        

                            
                    <h1 class="header-title">Introduction to Backpressure and Flowables</h1>
                
            
            
                
<p>So far, we were trying to understand the push-based architecture of reactive programming. By now, we have gained a good understanding of <kbd>Observables</kbd>. We now understand that an <kbd>Observable</kbd> emits items to be consumed by an <kbd>Observer</kbd> for further processing. However, while going through previous chapters, did you ever think of a situation where the <kbd>Observable</kbd> emits items faster than the <kbd>Observer</kbd> can consume them? This whole chapter is devoted to this problem. We will start by trying to understand how and when this problem may occur, and then we will try to solve the problem.</p>
<p>So, in this chapter, we will focus on the following topics, and by the end of the chapter we should have a solution to the problem mentioned earlier:</p>
<ul>
<li>Understanding backpressure</li>
<li>Flowables and Subscriber</li>
<li>Creating Flowables with <kbd>Flowable.create()</kbd></li>
<li>Using Observable and Flowables together</li>
<li>Backpressure operators</li>
<li>An <kbd>Flowable.generate()</kbd> operator</li>
</ul>
<p>So, now, let's start with backpressure—the problem with Observables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding backpressure</h1>
                
            
            
                
<p>The only problem with <kbd>Observable</kbd> is when an <kbd>Observer</kbd> cannot cope with the pace of an <kbd>Observable</kbd>. An <kbd>Observable</kbd>, by default, chains work by pushing items synchronously to the <kbd>Observer</kbd>, one at a time. However, if the <kbd>observer</kbd> has to perform some time-consuming computations, this may take longer than the interval of each item emission of <kbd>Observable</kbd>. Confused? Let's consider this example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = Observable.just(1,2,3,4,5,6,7,8,9)//(1) 
      val subject = BehaviorSubject.create&lt;Int&gt;() 
      subject.observeOn(Schedulers.computation())//(2) 
            .subscribe({//(3) 
                println("Subs 1 Received $it") 
                runBlocking { delay(200) }//(4) 
            }) 
 
            subject.observeOn(Schedulers.computation())//(5) 
            .subscribe({//(6) 
                println("Subs 2 Received $it") 
             }) 
             observable.subscribe(subject)//(7) 
            runBlocking { delay(2000) }//(8) 
    } </pre>
<p>The code is quite simple. We created <kbd>Observable</kbd> on comment <kbd>(1)</kbd>, then, we created <kbd>BehaviorSubject</kbd>, and then, on comment <kbd>(3)</kbd> and <kbd>(6)</kbd>, we <kbd>subscribe</kbd> to <kbd>BehaviorSubject</kbd>. On comment <kbd>(7)</kbd>, after subscribing to <kbd>BehaviorSubject</kbd>, we will use <kbd>BehaviorSubject</kbd> to subscribe to the <kbd>Observable</kbd> so that <kbd>Observers</kbd> of <kbd>BehaviorSubject</kbd> should get all the emissions. On comment <kbd>(4)</kbd>, inside the first subscription, we used the <kbd>delay</kbd> method to simulate a time-taking subscriber. There is a new code on comment <kbd>(2)</kbd> and <kbd>(6)</kbd>, <kbd>subject.observeOn(Schedulers.computation())</kbd>; we will discuss this method in detail in the later chapters, but, for now, just keep in mind that this <kbd>observeOn</kbd> method helps us specify a thread to run the subscription, and <kbd>Scheduler.computation()</kbd> provides us a with a thread to perform computations. On comment <kbd>(8)</kbd>, we used the <kbd>delay</kbd> method to wait for the execution, as the execution will occur in the background.</p>
<p>Based on the knowledge we gathered from previous chapters, we can easily say that subscriptions should print all the numbers from <kbd>1</kbd>-<kbd>9</kbd> in an interleaved manner, or shouldn't they? Let's see the output first:</p>
<div><img height="240" width="534" class=" image-border" src="img/4ac5b382-cfbb-4287-852b-1563caf72f32.png"/></div>
<p>Shocked to see the output? Instead of working in an interleaved manner, subscription <kbd>2</kbd> completes printing all the numbers before subscription <kbd>1</kbd> prints even the second number, even though it starts printing first. So, why did it break the behavior of <kbd>Hot Observables</kbd>? Why didn't both the <kbd>Observers</kbd> work in an interleaved manner? Let's inspect. The program actually didn't break the behavior of <kbd>Hot Observables</kbd>, the <kbd>subject</kbd> actually emitted once for both of the <kbd>observers</kbd>; however, as for the first <kbd>observer</kbd>, each computation took long, <strong>the emissions got queued</strong>; and this is obviously not any good, as this could lead to a lot of problems, including the <kbd>OutOfMemoryError</kbd> exceptions.</p>
<p>Still have doubts? Let's look at another example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = Observable.just(1,2,3,4,5,6,7,8,9)//(1) 
      observable 
         .map { MyItem(it) }//(2) 
         .observeOn(Schedulers.computation())//(3) 
         .subscribe({//(4) 
           println("Received $it") 
           runBlocking { delay(200) }//(5) 
          }) 
          runBlocking { delay(2000) }//(6) 
    } 
 
    data class MyItem (val id:Int) { 
      init { 
        println("MyItem Created $id")//(7) 
      } 
    } </pre>
<p>In this example, we eliminated the <kbd>Subject</kbd> and multiple <kbd>Subscribers</kbd> to make the program simpler and easier to understand. We have already introduced the <kbd>map</kbd> operator in the previous chapter that we used on comment <kbd>(2)</kbd> to convert the <kbd>Int</kbd> items to the <kbd>MyItem</kbd> object.</p>
<p>If you forgot the <kbd>map</kbd> operator from the previous chapter, it takes a source observable, processes items emitted by them on runtime, and creates another observable to observe on. Put simply, the <kbd>map</kbd> operator sits before subscribe to process each item emitted by <kbd>observable</kbd> before passing the new generated item to <kbd>observer</kbd>. We will also take a closer look at the <kbd>map</kbd> operator in the later chapters.</p>
<p>Here, we used it to keep track of each emission. Whenever an emission will occur, it will be passed instantly to the <kbd>map</kbd> operator, where we are creating an object of the <kbd>MyItem</kbd> class. In the <kbd>init</kbd> block of the <kbd>MyItem</kbd> class, we are printing the value passed to it; so, as soon as an item is emitted, it will be printed by the <kbd>MyItem</kbd> class.</p>
<p>Here, the <kbd>MyItem</kbd> class is a <kbd>data class</kbd>, that is, it will have the getter of <kbd>val id</kbd> and <kbd>toString</kbd> methods by default.</p>
<p>The remaining part of the program is almost the same; let's take a look at the output, then we will continue to discuss:</p>
<div><img height="269" width="534" class=" image-border" src="img/e134d6db-0b28-4a7b-8a19-bf392981c0af.png"/></div>
<p>As we can see in the output, the creation of many <kbd>MyItem</kbd>, as known as emissions was quite fast, and completed even before the <kbd>Observer</kbd> as known as consumer can even start printing.</p>
<p>So, the problem is that the emissions get queued in the consumer, while the consumer is busy processing previous emissions by the producer.</p>
<p>A solution to this problem could be a feedback channel from consumer to producer, through which the consumer can tell the producer to wait until it completes processing the previous emission. This way, consumers or messaging middleware will not become saturated and unresponsive under high load; instead, they may request fewer messages, letting the producer decide how to slow down. This feedback channel is called <strong>backpressure</strong>. Backpressure is not supported in <kbd>Observables</kbd> and <kbd>Observers</kbd>, the solution could be using <kbd>Flowables</kbd> and <kbd>Subscribers</kbd> instead. Let's learn what those are.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flowable</h1>
                
            
            
                
<p>We may call Flowables a backpressured version of Observables. Probably, the only difference between Flowables and Observables is that Flowable takes backpressure into consideration. Observable does not. That's it. Flowable hosts the default buffer size of 128 elements for operators, so, when the consumer is taking time, the emitted items may wait in the buffer.</p>
<p>Note that Flowables were added in ReactiveX 2.x (RxKotlin 2.X), and the previous versions don't include them. Instead, in previous versions, Observables was retrofitted to support backpressure that caused many unexpected <kbd>MissingBackpressureException</kbd>.<br/>
Here is the release note if you are interested:<br/>
<a href="https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#observable-and-flowable">https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#observable-and-flowable</a></p>
<p>We had a long discussion so far; let's now try our hands on code. At first, we will try a code with Observable, and then we will do the same with Flowables to see and understand the difference:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,1000)//(1) 
        .map { MyItem3(it) }//(2) 
        .observeOn(Schedulers.computation()) 
        .subscribe({//(3) 
          print("Received $it;\t") 
          runBlocking { delay(50) }//(4) 
         },{it.printStackTrace()}) 
         runBlocking { delay(60000) }//(5) 
     } 
     data class MyItem3 (val id:Int) { 
     init { 
       print("MyItem Created $id;\t") 
     } 
    } </pre>
<p>A simple code with the <kbd>Observable.range()</kbd> operator, which should emit numbers from <kbd>1</kbd> to <kbd>1000</kbd>. On comment <kbd>(2)</kbd>, we used the <kbd>map</kbd> operator to create the <kbd>MyItem3</kbd> object from <kbd>Int</kbd>. On comment <kbd>(3)</kbd>, we subscribed to <kbd>Observable</kbd>. On comment <kbd>(4)</kbd>, we ran a blocking delay to simulate a long running subscription code. On comment <kbd>(5)</kbd>, we, again, ran a blocking delay code to wait for the consumer to complete processing of all items before the program stops execution.</p>
<p>The whole output will take some space, so we will put parts of outputs as screenshots here:</p>
<div><img src="img/8f03dbe5-272a-4067-aa5a-6f41a368da45.jpg"/></div>
<p>If you take a closer look at the output (screenshots), you will notice that the Observable (producer) continued to emit items, though the Observer (consumer) was not at all in pace with it. Until the time Observer (producer) finished emitting all the Items, the Observer (consumer) processed only the very first item (item 1). As mentioned earlier, this could lead to a lot of problems, including the <kbd>OutOfMemory</kbd> error. Now, let's replace <kbd>Observable</kbd> with <kbd>Flowable</kbd> in this code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Flowable.range(1,1000)//(1) 
        .map { MyItem4(it) }//(2) 
        .observeOn(Schedulers.io()) 
        .subscribe({//(3) 
          println("Received $it") 
          runBlocking { delay(50) }//(4) 
        },{it.printStackTrace()}) 
        runBlocking { delay(60000) }//(5) 
    } 
    data class MyItem4 (val id:Int) { 
      init { 
        println("MyItem Created $id") 
      }  
   } </pre>
<p>The code is exactly the same as the previous one, just the single difference is that we wrote <kbd>Flowable.range()</kbd> instead of <kbd>Observable</kbd>. Now, let's see the output and note the difference:</p>
<div><img src="img/72fa4363-b05c-457c-93c3-05e2f646d968.jpg"/></div>
<p>Have you noted the difference? Flowable, instead of emitting all the items, emitted few items in a chunk, waited for the consumer to coup up then again continued, and completed in an interleaved manner. This reduces a lot of problems itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">When to use Flowables and Observables</h1>
                
            
            
                
<p>By now, you may think Flowable is a handy tool to use, so you could replace Observable everywhere. However, this may not always be the case. Although Flowable provides us with backpressure strategies, Observables are here for a reason, and both of them have their own advantages and disadvantages. So, when to use which? Let's see.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">When to use Flowables?</h1>
                
            
            
                
<p>The following are the situations when you should consider using Flowables. Remember, Flowables are slower than Observables:</p>
<ul>
<li>Flowables and backpressure are meant to help deal with larger amounts of data. So, use flowable if your source may emit 10,000+ items. Especially when the source is asynchronous so that the consumer chain may ask the producer to limit/regulate emissions when required.</li>
<li>If you are reading from/parsing a file or database.</li>
<li>When you want to emit from network IO operations/Streaming APIs that support blocking while returning results, which is how many IO sources work.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">When to use Observables?</h1>
                
            
            
                
<p>Now you know when to use Flowables, take a look at the conditions where you should prefer Observables:</p>
<ul>
<li>When you are dealing with a smaller amount of data (less than 10,000 emissions)</li>
<li>When you are performing strictly synchronous operations or operations with limited concurrency</li>
<li>When you are emitting UI events (while working with Android, JavaFX, or Swing)</li>
</ul>
<p>Also, keep in mind that Flowables are slower in comparison to Observables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flowable and Subscriber</h1>
                
            
            
                
<p>Instead of Observer, Flowable uses Subscriber, which is backpressure compatible. However, if you use lambda expressions, then you will not notice any differences. So, why use Subscriber instead of Observer? Because Subscriber supports some extra operations and backpressure. For instance, it can convey how many items it wishes to receive as a message to upstream. Or rather, we can say while using Subscriber; you must specify how many items you want to receive (request) from upstream; if you don't specify it, you will not receive any emissions.</p>
<p>As we already mentioned, using lambda with <kbd>Subscriber</kbd> is similar to Observe; this implementation will automatically request an unbounded number of emissions from the upstream. As with our last code, we didn't specify how many emissions we want, but it internally requested unbounded number of emissions, and that's why we received all the items emitted.</p>
<p>So, let's try replacing the previous program with a <kbd>Subscriber</kbd> instance:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Flowable.range(1, 1000)//(1) 
        .map { MyItem5(it) }//(2) 
        .observeOn(Schedulers.io()) 
        .subscribe(object : Subscriber&lt;MyItem5&gt; {//(3) 
          override fun onSubscribe(subscription: Subscription) { 
            subscription.request(Long.MAX_VALUE)//(4) 
           } 
 
           override fun onNext(s: MyItem5?) { 
             runBlocking { delay(50) } 
             println("Subscriber received " + s!!) 
           } 
 
           override fun onError(e: Throwable) { 
             e.printStackTrace() 
           } 
 
           override fun onComplete() { 
             println("Done!") 
           } 
          }) 
          runBlocking { delay(60000) } 
       } 
 
       data class MyItem5 (val id:Int) { 
       init { 
         println("MyItem Created $id") 
       } 
    } </pre>
<p>The output of the preceding program will be the same as for the previous one, so we are skipping the output here. Instead, let's understand the code. The program is almost identical to the previous one, until comment <kbd>(3)</kbd>, where we created an instance of <kbd>Subscriber</kbd>. The methods of <kbd>Subscriber</kbd> are identical with <kbd>Observer</kbd>; however, as I mentioned earlier, on the <kbd>subscribe</kbd> method, you have to request for the number of emissions that you want initially. We did the same on comment <kbd>(4)</kbd>; however, as we want to receive all emissions, we requested it with <kbd>Long.MAX_VALUE</kbd>.</p>
<p>So, how does the <kbd>request</kbd> method work? The <kbd>request()</kbd> method will request the number of emissions the <kbd>Subscriber</kbd> should listen on from the upstream, counting after the method is called. The <kbd>Subscriber</kbd> will ignore any further emissions after the requested emissions until you request for more.</p>
<p>So, let's modify this program to understand the <kbd>request</kbd> method better:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Flowable.range(1, 15) 
        .map { MyItem6(it) } 
        .observeOn(Schedulers.io()) 
        .subscribe(object : Subscriber&lt;MyItem6&gt; { 
           lateinit var subscription: Subscription//(1) 
           override fun onSubscribe(subscription: Subscription) { 
              this.subscription = subscription 
              subscription.request(5)//(2) 
           } 
 
           override fun onNext(s: MyItem6?) { 
             runBlocking { delay(50) } 
             println("Subscriber received " + s!!) 
               if(s.id == 5) {//(3) 
                  println("Requesting two more") 
                  subscription.request(2)//(4) 
                } 
            } 
 
            override fun onError(e: Throwable) { 
               e.printStackTrace() 
            } 
 
            override fun onComplete() { 
               println("Done!") 
            } 
           }) 
           runBlocking { delay(10000) } 
     } 
 
    data class MyItem6 (val id:Int) { 
      init { 
        println("MyItem Created $id") 
      } 
     } </pre>
<p>So, what are the tweaks we made in this program? Let's go through it. On comment <kbd>(1)</kbd>, we declared a <kbd>lateinit</kbd> variable of type <kbd>Subscription</kbd>, we initialized that subscription inside the <kbd>onSubscribe</kbd> method, just before comment <kbd>(2)</kbd>. On comment <kbd>(2)</kbd>, we requested for <kbd>5</kbd> items with <kbd>subscription.request(5)</kbd>. Then, inside <kbd>onNext</kbd>, on comment <kbd>(3)</kbd>, we checked if the received item is the <kbd>5</kbd><sup>th</sup> one (as we are using a range, the <kbd>5</kbd><sup>th</sup> item's value will be <kbd>5</kbd>); if the item is the <kbd>5</kbd><sup>th</sup> one, then we are again requesting for <kbd>2</kbd> more. So, the program should print seven items instead of the <kbd>1</kbd>-<kbd>15</kbd> range. Let's check the following output:</p>
<div><img src="img/aca45d47-71bd-43fd-ac4a-74f430a1cfe6.png"/></div>
<p>So, although <kbd>Flowable</kbd> emitted all the items for the range, it was never passed to <kbd>Subscriber</kbd> after <kbd>7</kbd>.</p>
<p>Note that the <kbd>request()</kbd> method just not goes all the way upstream, it just conveys to the latest preceding operator, which, in turn, decides on whether to/how to relay that information to further upstream.</p>
<p>So, we got some understanding on <kbd>Flowable</kbd> and <kbd>Subscriber</kbd>. Now, it's time to explore them in depth. We will start with creating a <kbd>Flowable</kbd> instance from scratch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating Flowable from scratch</h1>
                
            
            
                
<p>We learned about the <kbd>Observable.create</kbd> method in the previous chapter, but to make things less complicated, let's have a quick recap, and then we can continue with <kbd>Flowable.create</kbd>. Take a look at the following piece of code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observer: Observer&lt;Int&gt; = object : Observer&lt;Int&gt; { 
        override fun onComplete() { 
            println("All Completed") 
        } 
 
        override fun onNext(item: Int) { 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
       }//Create Observer 
 
       val observable: Observable&lt;Int&gt; = Observable.create&lt;Int&gt; {//1 
         for(i in 1..10) { 
            it.onNext(i) 
         } 
         it.onComplete() 
       } 
 
       observable.subscribe(observer) 
 
    } </pre>
<p>So, in this program, we created <kbd>Observable</kbd> with the <kbd>Observable.create</kbd> operator. This operator let's define our own custom <kbd>Observable</kbd>. We can write our own rules to emit items from <kbd>Observable</kbd>. It provides really great freedom, but the problem with <kbd>Observable</kbd> is here as well. It doesn't support backpressure. Wouldn't it be great if we could create a similar version with backpressure support? We will do it, but let's see the output first:</p>
<div><img src="img/b3578992-ead2-4a0c-aa26-51914541504d.jpg"/></div>
<p>So, as expected, it prints all the numbers from <kbd>1</kbd> through <kbd>10</kbd>. Now, as discussed earlier, let's try with <kbd>Flowable</kbd>:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val subscriber: Subscriber&lt;Int&gt; = object : Subscriber&lt;Int&gt; { 
        override fun onComplete() { 
          println("All Completed") 
        } 
 
        override fun onNext(item: Int) { 
          println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
          println("Error Occured ${e.message}") 
        } 
 
        override fun onSubscribe(subscription: Subscription) { 
          println("New Subscription ") 
          subscription.request(10) 
        } 
      }//(1) 
 
      val flowable: Flowable&lt;Int&gt; = Flowable.create&lt;Int&gt; ({ 
        for(i in 1..10) { 
          it.onNext(i) 
        } 
        it.onComplete() 
      },BackpressureStrategy.BUFFER)//(2) 
 
      flowable 
        .observeOn(Schedulers.io()) 
        .subscribe(subscriber)//(3) 
 
      runBlocking { delay(10000) } 
 
    } </pre>
<p>So, on comment <kbd>(1)</kbd>, we created an instance of <kbd>Subscriber</kbd>. Then, on comment <kbd>(2)</kbd>, we created an instance of <kbd>Flowable</kbd> with the <kbd>Flowable.create()</kbd> method, and, on comment <kbd>(3)</kbd>, we subscribed to it. However, focus on comment <kbd>(2)</kbd>—along with the <kbd>lambda</kbd>, we also passed another argument to the <kbd>Flowable.create</kbd> method, which is <kbd>BackpressureStrategy.BUFFER</kbd>. So, what is it? And what purpose does <kbd>BackpressureStrategy.BUFFER</kbd> serve? Let's inspect.</p>
<p><kbd>Flowable.create()</kbd> takes two parameters to create an instance of <kbd>Flowable</kbd>. The following is the definition of the <kbd>Flowable.create()</kbd> method:</p>
<pre>    fun &lt;T&gt; create(source:FlowableOnSubscribe&lt;T&gt;, <br/>    mode:BackpressureStrategy):Flowable&lt;T&gt; { 
      //... 
    } </pre>
<p>First parameter is the source from where the emissions will generate, and the second one is <kbd>BackpressureStrategy</kbd>; it is an <kbd>enum</kbd> that helps supporting backpressure (it basically helps choosing which strategy to follow for backpressure) by caching/buffering or dropping some of the emissions if the downstream can't keep up. The <kbd>enum BackpressureStrategy</kbd> has five underlying options for different kinds of implementations of backpressure. In this example, <kbd>BackpressureStrategy.BUFFER</kbd> buffers all the emissions until they are consumed by the downstream. This, obviously, is not an optimal implementation of backpressure and can cause <kbd>OutOfMemoryError</kbd> while handling too many emissions, but, at least it prevents <kbd>MissingBackpressureException</kbd> and can make your custom <kbd>Flowable</kbd> workable to a small degree. We will learn about a more robust way to implement backpressure later in this chapter using <kbd>Flowable.generate()</kbd>; however, for now, let's know about the options we can choose from <kbd>BackpressureStrategyenum</kbd>:</p>
<ul>
<li><kbd>BackpressureStrategy.MISSING</kbd>: This leads to no backpressure implementation at all; downstream has to deal with backpressure overflows. This option is helpful while using the <kbd>onBackpressureXXX()</kbd> operator. We will learn this example later in this chapter.</li>
<li><kbd>BackpressureStrategy.ERROR</kbd>: This, again, leads to no backpressure implementation and signals <kbd>MissingBackpressureException</kbd> the very moment the downstream cannot keep up with the source.</li>
<li><kbd>BackpressureStrategy.BUFFER</kbd>: This buffers all the emissions in an unbounded buffer until the downstream is able to consume them. This can lead to <kbd>OutOfMemoryError</kbd> if there are a lot of emissions to buffer.</li>
<li><kbd>BackpressureStrategy.DROP</kbd>: This strategy will let you drop all the emissions while the downstream is busy and can't keep up; when the downstream finishes the previous operation, it'll get the very first emission after its finishing time, and will miss any emissions in between. For example, say the source is emitting five values, <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, <kbd>4</kbd>, and <kbd>5</kbd> respectively, the downstream got busy after receiving <kbd>1</kbd> and while the source emitted <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd>, it got ready just before the source emitted <kbd>5</kbd>; the downstream will receive <kbd>5</kbd> only and will miss all remaining.</li>
<li><kbd>BackpressureStrategy.LATEST</kbd>: This strategy will let you drop all the emissions, but keeps the latest one while the downstream is busy and can't keep up; when the downstream finishes the previous operation it'll get the last emission just before it finished, and will miss any emissions in between. For example, say the source is emitting five values <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, <kbd>4</kbd>, and <kbd>5</kbd> respectively, the downstream got busy after receiving 1 and while the source emitted <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd>, it got ready just before the source emitted <kbd>5</kbd>; the downstream will receive both of them (if it didn't again get busy after receiving <kbd>4</kbd>, that it can't receive <kbd>5</kbd>).</li>
</ul>
<p>Let's implement some of these backpressure strategies as operators while creating Flowables from Observables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating Flowable from Observable</h1>
                
            
            
                
<p>The <kbd>Observable.toFlowable()</kbd> operator provides you with another way to implement <kbd>BackpressureStrategy</kbd> into non-backpressured source. This operator turns any <kbd>Observable</kbd> into a <kbd>Flowable</kbd>, so let's get our hands dirty, and, first, let's try converting an <kbd>Observable</kbd> into <kbd>Flowable</kbd> with the buffering strategy, then we will try out a few other strategies in the same example to understand it better. Please refer to the following code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val source = Observable.range(1, 1000)//(1) 
      source.toFlowable(BackpressureStrategy.BUFFER)//(2) 
        .map { MyItem7(it) } 
        .observeOn(Schedulers.io()) 
        .subscribe{//(3) 
          print("Rec. $it;\t") 
          runBlocking { delay(1000) } 
        } 
        runBlocking { delay(100000) } 
    } 
 
    data class MyItem7 (val id:Int) { 
      init { 
        print("MyItem init $id") 
      } 
   } </pre>
<p>So, on comment <kbd>(1)</kbd>, we created an <kbd>Observable</kbd> with the <kbd>Observable.range()</kbd> method. On comment <kbd>(2)</kbd>, we converted it to <kbd>Flowable</kbd> with <kbd>BackpressureStrategy.BUFFER</kbd>. Then, we subscribed to it with a lambda as the <kbd>Subscriber</kbd>. Let's see some portions of the output as a screenshot (as the complete output will be too long to paste here):</p>
<div><img src="img/76e322cc-775e-4395-bfac-e072f3fea9cc.jpg"/></div>
<p>So, as expected, the downstream here processes all the emissions, as the <kbd>BackpressureStrategy.BUFFER</kbd> buffers all the emissions until the downstream consumes.</p>
<p>So, now, let's try with <kbd>BackpressureStrategy.ERROR</kbd> and check what happens:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val source = Observable.range(1, 1000) 
      source.toFlowable(BackpressureStrategy.ERROR) 
        .map { MyItem8(it) } 
        .observeOn(Schedulers.io()) 
        .subscribe{ 
           println(it) 
           runBlocking { delay(600) } 
        } 
        runBlocking { delay(700000) } 
      } 
 
      data class MyItem8 (val id:Int) { 
      init { 
        println("MyItem Created $id") 
      } 
    } </pre>
<p>The following is the output:</p>
<div><img src="img/0d2e1672-ba50-4507-9990-f8c79e39bd9f.jpg"/></div>
<p>It showed an error as the downstream couldn't keep up with the upstream, as we described it earlier.</p>
<p>What would happen if we use the <kbd>BackpressureStrategy.DROP</kbd> option? Let's check:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val source = Observable.range(1, 1000) 
      source.toFlowable(BackpressureStrategy.DROP) 
        .map { MyItem9(it) } 
        .observeOn(Schedulers.computation()) 
        .subscribe{ 
           println(it) 
           runBlocking { delay(1000) } 
        } 
        runBlocking { delay(700000) } 
     } 
 
     data class MyItem9 (val id:Int) { 
     init { 
        println("MyItem Created $id") 
     } 
    } </pre>
<p>Everything is the same as in the previous example, except, here, we used the <kbd>BackpressureStrategy.DROP</kbd> option. Let's check the output:</p>
<div><img src="img/00d470ae-c820-4628-b4eb-783c975c50d8.jpg"/></div>
<p>So, as we can see in the preceding output, <kbd>BackpressureStrategy.DROP</kbd> stopped <kbd>Flowable</kbd> from emitting after <kbd>128</kbd>, as the downstream couldn't keep up with, just as we described earlier.</p>
<p>Now, as we have gained some grip on the options available in <kbd>BackpressureStrategy</kbd>, let's focus on the <kbd>BackpressureStrategy.MISSING</kbd> option and how to use them with the <kbd>onBackpressureXXX()</kbd> operators.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">BackpressureStrategy.MISSING and onBackpressureXXX()</h1>
                
            
            
                
<p><kbd>BackpressureStrategy.MISSING</kbd> implies that it'll not implement any backpressure strategy, so you need to explicitly tell <kbd>Flowable</kbd> which backpressure strategy to follow. The <kbd>onBackpressureXXX()</kbd> operators help you achieve the same, while providing you with some additional configuration options.</p>
<p>There are mainly three types of <kbd>onBackpressureXXX()</kbd> operators available:</p>
<ul>
<li><kbd>onBackpressureBuffer()</kbd></li>
<li><kbd>onBackpressureDrop()</kbd></li>
<li><kbd>onBackpressureLatest()</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Operator onBackpressureBuffer()</h1>
                
            
            
                
<p>This operator serves the purpose of <kbd>BackpressureStrategy.BUFFER</kbd>; except that here, you'll get some extra configuration options, such as buffer size, bounded or unbounded, and more. You may omit the configurations as well to use the default behavior.</p>
<p>So, let's look at some examples:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val source = Observable.range(1, 1000) 
      source.toFlowable(BackpressureStrategy.MISSING)//(1) 
        .onBackpressureBuffer()//(2) 
        .map { MyItem11(it) } 
        .observeOn(Schedulers.io()) 
        .subscribe{ 
           println(it) 
           runBlocking { delay(1000) } 
         } 
         runBlocking { delay(600000) } 
     } 
 
     data class MyItem11 (val id:Int) { 
     init { 
        println("MyItem Created $id") 
     } 
    } </pre>
<p>Again, we are using the previous program with little tweaks. On comment <kbd>(1)</kbd>, we created the <kbd>Flowable</kbd> instance with the <kbd>BackpressureStrategy.MISSING</kbd> option. On comment <kbd>(2)</kbd>, to deal with backpressure, we used <kbd>onBackpressureBuffer</kbd>; the output is similar to the one in the <kbd>BackpressureStrategy.BUFFER</kbd> example, so we are omitting this.</p>
<p>You can specify the buffer size by using <kbd>onBackpressureBuffer()</kbd>. So let's modify the <kbd>onBackpressureBuffer()</kbd> method call with <kbd>onBackpressureBuffer(20)</kbd>. The following is the output:</p>
<div><img src="img/0cda2981-c206-4f9f-8d0e-aabdc3e0c08d.jpg"/></div>
<p>Yes, that change resulted in an error—the buffer is full. We defined <kbd>20</kbd> to be the buffer size, but <kbd>Flowable</kbd> needed a lot more size. This could be avoided by implementing the <kbd>onError</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Operator onBackpressureDrop()</h1>
                
            
            
                
<p>Like <kbd>onBackpressureBuffer</kbd> matches with <kbd>BackpressureStrategy.BUFFER</kbd>, <kbd>onBackpressureDrop</kbd> matches with <kbd>BackpressureStrategy.DROP</kbd> in terms of backpressure strategy, with some configuration options.</p>
<p>So, let's now try this:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val source = Observable.range(1, 1000) 
      source.toFlowable(BackpressureStrategy.MISSING)//(1) 
        .onBackpressureDrop{ print("Dropped $it;\t") }//(2) 
        .map { MyItem12(it) } 
        .observeOn(Schedulers.io()) 
        .subscribe{ 
           print("Rec. $it;\t") 
           runBlocking { delay(1000) } 
        } 
        runBlocking { delay(600000) } 
    } 
 
    data class MyItem12 (val id:Int) { 
    init { 
        print("MyItem init $id;\t") 
    } 
   } </pre>
<p>As shown in the previous program, we used <kbd>BackpressureStrategy.MISSING</kbd> on comment <kbd>(1)</kbd>. On comment <kbd>(2)</kbd>, we used the <kbd>onBackpressureDrop()</kbd> operator. This operator provides a configuration option to pass a consumer instance, which will, in turn, consume the dropped emissions so you can further process it. We used this configuration and passed a lambda, which will print the dropped emissions, as shown in this screenshot:</p>
<div><img height="347" width="575" src="img/f97e804e-3a46-44ba-9946-b35e2a3cb8ca.jpg"/></div>
<p>As we can see from the output, <kbd>Flowable</kbd> dropped emissions after <kbd>128</kbd> (as it has an internal buffer for <kbd>128</kbd> emissions). The consumer instance of <kbd>onBackpressureDrop</kbd> completed processing even before the <kbd>Subscriber</kbd> instance started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Operator onBackpressureLatest()</h1>
                
            
            
                
<p>This operator works exactly the same as the <kbd>BackpressureStrategy.LATEST</kbd>-it drops all the emissions keeping the latest one when the downstream is busy and can't keep up. When the downstream finishes the previous operation, it'll get the last emission just before it finished. Unfortunately, this doesn't provide any configurations; you will probably not need it.</p>
<p>Let's take a look at this code example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val source = Observable.range(1, 1000) 
      source.toFlowable(BackpressureStrategy.MISSING)//(1) 
        .onBackpressureLatest()//(2) 
        .map { MyItem13(it) } 
        .observeOn(Schedulers.io()) 
        .subscribe{ 
          print("-&gt; $it;\t") 
          runBlocking { delay(100) } 
        } 
        runBlocking { delay(600000) } 
    }  
    data class MyItem13 (val id:Int) { 
    init { 
      print("init $id;\t") 
    } 
   } </pre>
<p>Here is the output:</p>
<div><img src="img/24916162-a378-4542-a0c7-1be9b2dbea9a.jpg"/></div>
<p>As we can see, the <kbd>Flowable</kbd> dropped all emissions after <kbd>128</kbd>, keeping only the last one (<kbd>1,000</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating Flowable with backpressure at source</h1>
                
            
            
                
<p>So far, we have learned to use standard libraries that handle backpressure at the downstream. However, is this optimal? Is it always desirable to cache and drop emissions whenever the downstream can't keep up? The answer to both questions is simply NO. Instead, the better policy would be to backpressure the source at the first place.</p>
<p><kbd>Flowable.generate()</kbd> serves the exact same purpose. It's somewhat similar to <kbd>Flowable.create()</kbd>, but with a little difference. Let's take a look at an example, and then we will try to understand how it works and what are the differences between <kbd>Flowable.create()</kbd> and <kbd>Flowable.generate()</kbd>.</p>
<p>Note that use <kbd>Flowable.fromIterable()</kbd> as it respects backpressure. So, consider using <kbd>Flowable.fromIterable()</kbd> whenever you can convert your source to an <kbd>Iterator</kbd>. Use <kbd>Flowable.generate()</kbd> only where you need something more specific, as it is way more complex.</p>
<p>Consider the following code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flowable = Flowable.generate&lt;Int&gt; { 
        it.onNext(GenerateFlowableItem.item) 
      }//(1) 
 
      flowable 
        .map { MyItemFlowable(it) } 
        .observeOn(Schedulers.io()) 
        .subscribe { 
          runBlocking { delay(100) } 
          println("Next $it") 
         }//(2) 
 
         runBlocking { delay(700000) } 
     } 
 
     data class MyItemFlowable(val id:Int) { 
       init { 
        println("MyItemFlowable Created $id") 
       } 
     } 
 
     object GenerateFlowableItem {//(3) 
       var item:Int = 0//(4) 
        get() { 
            field+=1 
            return field//(5) 
        } 
    } </pre>
<p>In that program, we created <kbd>Flowable</kbd> with the <kbd>Flowable.generate()</kbd> method. Unlike <kbd>Flowable.create()</kbd>, where <kbd>Flowable</kbd> emits items and <kbd>Subscriber</kbd> receives/waits for/buffers/drops them, <kbd>Flowable.generate()</kbd> generates items on request and emits them. <kbd>Flowable.generate()</kbd> accepts a lambda to use as the source, which may seem similar to <kbd>Flowable.create</kbd>, and calls it every time you request an item (unlike <kbd>Flowable.create</kbd>). So, for example, if you call the <kbd>onComplete</kbd> method inside the lambda, <kbd>Flowable</kbd> will emit only once. Also, you can't call <kbd>onNext</kbd> multiple times inside the lambda. If you called <kbd>onError</kbd>, then you will get an error on the very first call.</p>
<p>In this program, we created <kbd>object</kbd>, <kbd>GenerateFlowableItem</kbd>, with <kbd>var item</kbd>; the <kbd>var item</kbd> will automatically increment its value every time you access it (using a custom getter). So, the program should work like <kbd>Flowable.range(1, Int.MAX_VALUE)</kbd>, except that once the item reaches <kbd>Int.MAX_VALUE</kbd> instead of calling <kbd>onComplete</kbd>, it'll again repeat itself, starting from <kbd>Int.MIN_VALUE</kbd>.</p>
<p>In the output (omitted here as it is too large), <kbd>Flowable</kbd> emitted <kbd>128</kbd> items on the first go, then waited for the downstream to process <kbd>96</kbd> items, then <kbd>Flowable</kbd> again emitted <kbd>128</kbd> items, and the cycle continued. Until you unsubscribe from <kbd>Flowable</kbd> or the program execution stops, it will continue emitting items.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ConnectableFlowable</h1>
                
            
            
                
<p>So far, in this chapter, we've dealt with <kbd>Cold Observables</kbd>. What if we want to deal with hot source? Every type of Observable has their counterpart in Flowable. In the previous chapter, we started hot source with <kbd>ConnectableObservable</kbd>, so let's start with <kbd>ConnectableFlowable</kbd>.</p>
<p>As with Observable, <kbd>ConnectableFlowable</kbd> resembles an ordinary Flowable, except that it does not begin emitting items when it is subscribed, but only when its <kbd>connect()</kbd> method is called. In this way, you can wait for all intended <kbd>Subscribers</kbd> to <kbd>Flowable.subscribe()</kbd>, before <kbd>Flowable</kbd> begins emitting items. Please refer to the following code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val connectableFlowable = listOf<br/>      ("String 1","String 2","String   3","String 4",<br/>      "String  5").toFlowable()//(1) 
      .publish()//(2) 
      connectableFlowable. 
       subscribe({ 
         println("Subscription 1: $it") 
         runBlocking { delay(1000) } 
         println("Subscription 1 delay") 
       }) 
       connectableFlowable 
       .subscribe({ println("Subscription 2 $it")}) 
       connectableFlowable.connect() 
     } </pre>
<p>We tweaked the first example of <kbd>ConnectableObservable</kbd> from the previous chapter. As with <kbd>Observable</kbd>, you can use the <kbd>Iterable&lt;T&gt;.toFlowable()</kbd> extension function in the place of <kbd>Flowable.fromIterable()</kbd>. <kbd>Flowable.publish()</kbd> turns an ordinary <kbd>Flowable</kbd> into a <kbd>ConnectableFlowable</kbd>.</p>
<p>In this example, on comment <kbd>(1)</kbd>, we used the <kbd>Iterable&lt;T&gt;.toFlowable()</kbd> extension function to create <kbd>Flowable</kbd> from <kbd>List</kbd>, and on comment <kbd>(2)</kbd>, we used the <kbd>Flowable.publish()</kbd> operator to create <kbd>ConnectableFlowable</kbd> from <kbd>Flowable</kbd>.</p>
<p>The following is the output:</p>
<div><img class=" image-border" src="img/dcd29fcc-c333-4ed8-8ce5-3c680797db81.png"/></div>
<p>As we used <kbd>Flowable.fromIterable</kbd> (<kbd>Iterable&lt;T&gt;.toFlowable()</kbd> calls <kbd>Flowable.fromIterable</kbd> internally), which respects backpressure at the source, we can see <kbd>Flowable</kbd> waited for all the downstream to complete processing, then emitted the next item so that the downstreams can work in an interleaved manner.</p>
<p>By now, you may have been thinking of <kbd>Subjects</kbd>. It is a great tool, but, like <kbd>Observable</kbd>, <kbd>Subjects</kbd> also lack backpressure support. So, what is the counterpart for <kbd>Subjects</kbd> in Flowable?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Processor</h1>
                
            
            
                
<p>Processors are the counterparts for <kbd>Subjects</kbd> in Flowable. Every type of <kbd>Subject</kbd> has its counterpart as processor with backpressure support.</p>
<p>In the previous chapter (<a href="135f52d1-f19c-4f88-9299-d3c5bcec4898.xhtml" target="_blank">Chapter 3</a>, <em>Observables, Observers, and Subjects</em>), we started exploring <kbd>Subject</kbd>, with the <kbd>PublishSubject</kbd>; so, let's do the same here. Let's get started with <kbd>PublishProcessor</kbd>.</p>
<p>The following is an example of <kbd>PublishProcessor</kbd>:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flowable = listOf("String 1","String 2","String 3",<br/>      "String 4","String 5").toFlowable()//(1) 
 
      val processor = PublishProcessor.create&lt;String&gt;()//(2) 
 
      processor.//(3) 
         subscribe({ 
           println("Subscription 1: $it") 
           runBlocking { delay(1000) } 
           println("Subscription 1 delay") 
         }) 
      processor//(4) 
      .subscribe({ println("Subscription 2 $it")}) 
 
      flowable.subscribe(processor)//(5) 
 
    } </pre>
<p>So, in this example, on comment <kbd>(1)</kbd>, we created a <kbd>Flowable</kbd> with the <kbd>Iterable&lt;T&gt;.toFlowable()</kbd> method. On comment <kbd>(2)</kbd>, we created a <kbd>processor</kbd> instance with the <kbd>PublishProcessor.create()</kbd> method. On comment <kbd>(3)</kbd> and <kbd>(4)</kbd>, we subscribed to the <kbd>processor</kbd> instance, and, on comment <kbd>(5)</kbd>. we subscribed to the <kbd>Flowable</kbd> with the <kbd>processor</kbd> instance.</p>
<p>The following is the output:</p>
<div><img src="img/d71c8b78-b195-42c4-b863-7a6a22243b94.jpg"/></div>
<p>The <kbd>processor</kbd> is waiting for all its <kbd>Subscribers</kbd> to complete before pushing the next emission.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning Buffer, Throttle, and Window operators</h1>
                
            
            
                
<p>So far, we have learned about backpressure. We slowed down the source, dropped items, or used buffer, which will hold items until the consumer consumes it; however, will all these suffice? While handling backpressure at the downstream is not a good solution always, we cannot always slow down the source as well.</p>
<p>While using <kbd>Observable.interval</kbd>/<kbd>Flowable.interval</kbd>, you cannot slow down the source. A stop gap could be some operators that would somehow allow us to process the emissions simultaneously.</p>
<p>There are the three operators that could help us in that way:</p>
<ul>
<li><kbd>Buffer</kbd></li>
<li><kbd>Throttle</kbd></li>
<li><kbd>Window</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The buffer() operator</h1>
                
            
            
                
<p>Unlike the <kbd>onBackPressureBuffer()</kbd> operator, which buffers emissions until the consumer consumes, the <kbd>buffer()</kbd> operator will gather emissions as a batch and will emit them as a list or any other collection type.</p>
<p>So, let's look at this example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flowable = Flowable.range(1,111)//(1) 
      flowable.buffer(10)//(2) 
        .subscribe { println(it) } 
    } </pre>
<p>On comment <kbd>(1)</kbd>, we created a <kbd>Flowable</kbd> instance with the <kbd>Flowable.range()</kbd> method, which emits integers from <kbd>1</kbd> to <kbd>111</kbd>. On comment <kbd>(2)</kbd>, we used the <kbd>buffer</kbd> operator with <kbd>10</kbd> as the buffer size, so the <kbd>buffer</kbd> operator gathers <kbd>10</kbd> items from the <kbd>Flowable</kbd> and emits them as a list.</p>
<p>The following is the output, which satisfies the understanding:</p>
<div><img src="img/bc9ec64a-71c6-4d5f-9485-400fd44bd238.png"/></div>
<p>The <kbd>buffer</kbd> operator has quite good configuration options, such as the <kbd>skip</kbd> parameter.</p>
<p>It accepts a second integer parameter as the <kbd>skip</kbd> count. It works in a really interesting way. If the value of the <kbd>skip</kbd> parameter is exactly the same as the <kbd>count</kbd> parameter, then it will do nothing. Otherwise, it will first calculate the positive difference between the <kbd>count</kbd> and <kbd>skip</kbd> parameters as <kbd>actual_numbers_to_skip</kbd>, and, then, if the value of the <kbd>skip</kbd> parameter is greater than the value of the <kbd>count</kbd> parameter, it will skip the <kbd>actual_numbers_to_skip</kbd> items after the last item of each emission. Otherwise, if the value of the <kbd>count</kbd> parameter is greater than the value of the <kbd>skip</kbd> parameter, you'll get rolling buffers, that is, instead of skipping the items, it will skip the counts from the previous emissions.</p>
<p>Confused? Let's look at this example to clear things up:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flowable = Flowable.range(1,111) 
      flowable.buffer(10,15)//(1) 
       .subscribe { println("Subscription 1 $it") } 
 
      flowable.buffer(15,7)//(2) 
       .subscribe { println("Subscription 2 $it") } 
   } </pre>
<p>On comment <kbd>(1)</kbd>, we used buffer with count <kbd>10</kbd>, skip <kbd>15</kbd>, for the first subscription. On comment <kbd>(2)</kbd>, we used it as <kbd>count 15</kbd>, <kbd>skip 8</kbd>, for the second subscription. The following is the output:</p>
<div><img src="img/555b2f1d-2c34-47aa-b7fa-b29f10d1631b.png"/></div>
<p>For the first subscription, it skipped <kbd>5</kbd> items after each subscription (<kbd>15</kbd>-<kbd>10</kbd>). However, for the second one, it repeated items from the <kbd>8</kbd><sup>th</sup> item in each emission (<kbd>15</kbd>-<kbd>7</kbd>).</p>
<p>If the preceding uses of the <kbd>buffer</kbd> operator were not enough for you, then let me tell you the <kbd>buffer</kbd> operator also lets you do time-based buffering. Put simply, it can gather emissions from a source and emit them at a time interval. Interesting right? Let's explore it:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flowable = Flowable.interval(100, TimeUnit.MILLISECONDS)//(1) 
      flowable.buffer(1,TimeUnit.SECONDS)//(2) 
       .subscribe { println(it) } 
 
      runBlocking { delay(5, TimeUnit.SECONDS) }//(3) 
   } </pre>
<p>To understand things better, we used <kbd>Flowable.interval</kbd> in this example to create a <kbd>Flowable</kbd> instance on comment <kbd>(1)</kbd>. On comment <kbd>(2)</kbd>, we used the <kbd>buffer(timespan:Long, unit:TimeUnit)</kbd> overload to instruct the operator to buffer all emissions for a second and emit them as a list.</p>
<p>This is the output:</p>
<div><img src="img/a2c36cf3-831d-4050-8c67-f7ebd8393791.png"/></div>
<p>As you can see in the example, each of the emissions contains <kbd>10</kbd> items as <kbd>Flowable.interval()</kbd> is emitting one each <kbd>100</kbd> milliseconds and <kbd>buffer</kbd> is gathering emissions within a second timeframe (1 second = 1000 milliseconds, emission with a 100 milliseconds interval would result in 10 emissions in one second).</p>
<p>Another exciting feature of the buffer operator is that it can take another producer as the boundary, that is, the <kbd>buffer</kbd> operator will gather all the emissions of the source producer between two emissions of the boundary producer, and will emit the list on each boundary producer's emission.</p>
<p>Here is an example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val <a>boundaryFlowable </a>= Flowable.interval(350, TimeUnit.MILLISECONDS) 
 
      val flowable = Flowable.interval(100, TimeUnit.MILLISECONDS)//(1) 
      flowable.buffer(boundaryFlowable)//(2) 
       .subscribe { println(it) } 
 
      runBlocking { delay(5, TimeUnit.SECONDS) }//(3) 
     
    } </pre>
<p>And the following is the output:</p>
<div><img src="img/9ce6ae07-a8ca-4e01-af81-c1f7aecbcbb8.png"/></div>
<p>The <kbd>buffer</kbd> operator emits a gathered list whenever <kbd>boundaryFlowable</kbd> emits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The window() operator</h1>
                
            
            
                
<p>The <kbd>window()</kbd> operator works almost the same, except that, instead of buffering items in a <kbd>Collection</kbd> object, it buffers items in another producer.</p>
<p>Here is an example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flowable = Flowable.range(1,111)//(1) 
      flowable.window(10) 
        .subscribe { 
          flo-&gt;flo.subscribe {//(2) 
            print("$it, ") 
          } 
          println() 
       } 
    } </pre>
<p>Let's first see the output, as shown here, before we try to understand it:</p>
<div><img src="img/4f3538c8-9afa-4578-9f38-8b8cc88388b2.png"/></div>
<p>The <kbd>window</kbd> operator buffers <kbd>10</kbd> emissions in a new <kbd>Flowable</kbd> instance, which we will again subscribe to inside the <kbd>flowable.subscribe</kbd> lambda, and print them with a comma as a suffix.</p>
<p>The <kbd>window</kbd> operator also has same functionality as the other overloads of the <kbd>buffer</kbd> operator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The throttle() operators</h1>
                
            
            
                
<p>The <kbd>buffer()</kbd> and <kbd>window()</kbd> operators gather emissions. The <kbd>throttle</kbd> operators omit emissions. We will discuss it in greater detail in the later chapters, but we will take a look at it right now:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flowable = Flowable.interval(100, TimeUnit.MILLISECONDS)//(1) 
      flowable.throttleFirst(200,TimeUnit.MILLISECONDS)//(2) 
        .subscribe { println(it) } 
     
      runBlocking { delay(1,TimeUnit.SECONDS) } 
    } </pre>
<p>This is the output:</p>
<div><img src="img/6b13b98b-d740-4457-8bdd-6a09f049b4ae.png"/></div>
<p>The <kbd>throttleFirst</kbd> skips the first emissions in every <kbd>200</kbd> milliseconds.</p>
<p>There are <kbd>throttleLast</kbd> and <kbd>throttleWithTimeout</kbd> operators as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about backpressure. We learned how to support backpressure and Flowables as well as <kbd>processors</kbd>. We also learned how to support backpressure from consumers and producers.</p>
<p>Although we gained some grip on producers while working on real-time projects, we need to do asynchronous operations. In the next chapter, we will focus on the same. We will learn about asynchronous data operations, and we will learn more about the <kbd>map</kbd> operator, which we are already using.</p>
<p>Curious? Turn to <a href="e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml" target="_blank">Chapter 5</a>, <em>Asynchronous Data Operators and Transformations</em> right now.</p>


            

            
        
    </body></html>