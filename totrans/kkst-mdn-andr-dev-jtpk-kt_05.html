<html><head></head><body>
		<div id="_idContainer058">
			<h1 id="_idParaDest-65"><em class="italic"><a id="_idTextAnchor115"/>Chapter 4</em>: Handling Async Operations with Coroutines</h1>
			<p>In this chapter, we're focusing on another library that, although is not in the Jetpack library suite, is essential for writing solid applications: <strong class="bold">Kotlin coroutines</strong>.</p>
			<p>Coroutines represent a more convenient way of handling async work and concurrency jobs on Android.</p>
			<p>In this chapter, we will study how we can replace callbacks with coroutines in our Restaurants application. In the first section, <em class="italic">Introducing Kotlin coroutines</em>, we will gain a better understanding of what coroutines are, how they work, and why we need them in our apps.</p>
			<p>In the next section, <em class="italic">Exploring the basic elements of coroutines</em>, we will explore the core elements of coroutines, and we will understand how to use them to handle asynchronous work more concisely.</p>
			<p>Finally, in the <em class="italic">Using coroutines for async work</em> section, we will implement coroutines in our Restaurants application and let them handle the network requests. Additionally, we will add error handling and integrate some of the best practices when working with coroutines in Android apps.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing Kotlin coroutines</li>
				<li>Exploring the basic elements of coroutines</li>
				<li>Using coroutines for async work</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor116"/>Technical requirements</h1>
			<p>Building Compose-based Android projects with coroutines usually requires your day-to-day tools. However, to follow along with this chapter smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10, or a newer plugin, installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_03</strong> directory of the repository and importing the Android project entitled <strong class="source-inline">chapter_3_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_04</strong> directory:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app</a>.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor117"/>Introducing Kotlin coroutines</h1>
			<p><strong class="bold">Coroutines</strong> are<a id="_idIndexMarker281"/> part of the Kotlin API. They introduce a new and easier way of handling async work and concurrency jobs.</p>
			<p>Often, with Android, we need to run or execute different tasks behind the scenes. In the meantime, we don't want to block the main thread of the application and get an unresponsive UI.</p>
			<p>To mitigate this issue, coroutines<a id="_idIndexMarker282"/> allow you to execute async work much easier while providing main-thread safety for your Android apps. You can use the Coroutines API by launching one <strong class="bold">coroutine</strong>, or more, depending on your needs.</p>
			<p>In this section, we will cover three essential questions about the Coroutines API that derive from what we stated earlier:</p>
			<ul>
				<li>What is a coroutine?</li>
				<li>What are the features and advantages of coroutines?</li>
				<li>How do coroutines work?</li>
			</ul>
			<p>Let's jump in!</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor118"/>What is a coroutine?</h2>
			<p>A <a id="_idIndexMarker283"/>coroutine is a concurrency design pattern for async work. A <em class="italic">coroutine represents an instance of suspendable computation</em>.</p>
			<p>In other words, coroutines are sequences or blocks of code that represent a computational task that can be suspended. We call them <strong class="bold">suspendable</strong> because coroutines can be suspended and resumed mid-execution, which makes them efficient for concurrent tasks.</p>
			<p>When comparing coroutines with threads, we can say the following:</p>
			<ul>
				<li>A <a id="_idIndexMarker284"/>coroutine is a lightweight version of a thread but not a thread. Coroutines <a id="_idIndexMarker285"/>are light because creating coroutines doesn't allocate new threads – typically, coroutines use predefined thread pools.</li>
				<li>Like threads, coroutines can run in parallel, wait for each other, and communicate.</li>
				<li>Unlike threads, coroutines are very cheap: we can create thousands of them and pay very few penalties in terms of performance.</li>
			</ul>
			<p>Next, let's understand the purpose behind coroutines a bit better.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor119"/>The features and advantages of coroutines</h2>
			<p>By now, we know that on Android, coroutines can help us to move long-running async work from the main thread into a separate thread. Essentially, coroutines have two primary possible usages:</p>
			<ul>
				<li>For handling async work</li>
				<li>For handling<a id="_idIndexMarker286"/> multithreading</li>
			</ul>
			<p>In this chapter, we will only cover how to correctly handle async work with coroutines in Android apps.</p>
			<p>However, before we try to understand how to do that with coroutines, let's explore the advantages that coroutines bring over other alternatives that we've used in the past: <strong class="source-inline">AsyncTask</strong> classes, callbacks, and reactive frameworks. A coroutine is described as the following:</p>
			<ul>
				<li><strong class="bold">Lightweight</strong>: We can<a id="_idIndexMarker287"/> launch many coroutines on a single thread. Coroutines support execution suspension on the thread as opposed to blocking it, resulting in less memory overhead. Additionally, a coroutine is not always bound to a specific thread – it might start its execution on one thread and yield the result on a different one.</li>
				<li><strong class="bold">Easily cancelable</strong>: When canceling the parent coroutine, any children coroutines that were launched within the same scope will be canceled. If you have launched multiple coroutines that run operations concurrently, cancelation is straightforward and applies to the entire affected coroutine hierarchy; therefore, this eliminates any potential memory leaks.</li>
				<li><strong class="bold">Easily integrated with Jetpack libraries</strong>: By providing a suite of extensions. For example, coroutines provide custom scopes for many common Android components such as <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, <strong class="source-inline">ViewModel</strong>, and more. This means that you can launch coroutines safely from these components, as they will be canceled automatically when different lifecycle events occur, so you don't have to worry about memory leaks.<p class="callout-heading">Note</p><p class="callout">We have mentioned the word <em class="italic">scope</em> several times, and I promise that we will explain it later. Until then, you can think of the coroutine scope as an entity that controls the lifetime of launched coroutines.</p></li>
			</ul>
			<p>Now we have an idea of the features of coroutines. Yet, to better understand their purpose, first, we need to understand why we should offload async work from the main thread to a separate worker thread.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor120"/>How do coroutines work?</h2>
			<p>In Android<a id="_idIndexMarker288"/> runtime, the main thread is responsible for two things:</p>
			<ul>
				<li>Drawing the UI of the application on the screen</li>
				<li>Updating the UI upon user interactions</li>
			</ul>
			<p>Simplistically viewed, the main thread calls a drawing method on the screen canvas. This method might be familiar to you as the <strong class="source-inline">onDraw()</strong> method, and we can assume that for your device to render UI at 60 frames per second, the Android Runtime will call this method roughly every 16 milliseconds.</p>
			<p>If, for some reason, we execute heavy async work on the main thread, the application might freeze or stutter. This happens because the main thread was busy serving our async work; therefore, it missed several <strong class="source-inline">onDraw()</strong> calls that could have updated the UI and prevented the freezing effect.</p>
			<p>Let's say that we need to make a network request to our server. This operation might take time because we must wait for a response, which depends on the web API's speed and the user's connectivity. Let's imagine that such a method is named <strong class="source-inline">getNetworkResponse()</strong> and we are calling it from the main thread: </p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B17788_04_1.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Blocking the main thread with async work</p>
			<p>From the time it launched the network request, the main thread kept waiting for a response and couldn't do anything in the meantime. We can see that several <strong class="source-inline">onDraw()</strong> calls were missed because the main thread was busy executing our <strong class="source-inline">getNetworkResponse()</strong> method call and waiting for a result.</p>
			<p>To mitigate this issue, we've <a id="_idIndexMarker289"/>used many mechanisms in the past. Yet, coroutines are much easier to use and work perfectly with the Android ecosystem. So, it's time to see how they can enable us to execute async work:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B17788_04_2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Executing async work on a different thread by using a coroutine</p>
			<p>With coroutines, we can offload any nasty blocking calls – such as the <strong class="source-inline">getNetworkResponse()</strong> method call – from the main thread onto a coroutine.</p>
			<p>The coroutine works on a separate thread and is in charge of executing the network request and waiting for the response. This way, the main thread is not blocked, and no <strong class="source-inline">onDraw()</strong> calls are missed; therefore, we avoid getting any freezing screen effects.</p>
			<p>Now that we have a basic understanding of how coroutines work, it's time to explore the components that coroutines are based on.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor121"/>Exploring the basic elements of coroutines</h1>
			<p>A very simplistic<a id="_idIndexMarker290"/> approach for getting async work done with coroutines could be expressed as follows: first, define the suspended functions and then create coroutines that execute the suspended functions.</p>
			<p>Yet, we're not only unsure what suspending functions look like, but we also don't know how to allow coroutines to perform asynchronous work for us.</p>
			<p>Let's take things, step by step, and start with the two essential actions that we need to execute async work with coroutines:</p>
			<ul>
				<li>Creating suspending functions</li>
				<li>Launching coroutines</li>
			</ul>
			<p>All of these terms make little sense now, so let's address this, starting with suspending functions!</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor122"/>Creating suspending functions</h2>
			<p>The first thing that we need in order to work with coroutines is to define a suspending function where the blocking task resides.</p>
			<p>A <strong class="bold">suspending</strong> function<a id="_idIndexMarker291"/> is a special function that can be paused (suspended) and<a id="_idIndexMarker292"/> resumed at some later point in time. This allows us to execute long-running jobs while the function is suspended and, finally, resume it when the work is complete.</p>
			<p>Our regular function calls within our code are mostly executed synchronously on the main thread. Essentially, suspending functions allow us to execute jobs asynchronously in the background without blocking the thread where those functions are called from.</p>
			<p>Let's say that we need to save some details about a user to a local database. This operation takes time, so we need to display an animation until it finishes:</p>
			<p class="source-code">fun saveDetails(user: User) {</p>
			<p class="source-code">    startAnimation()</p>
			<p class="source-code">    <strong class="bold">database.storeUser(user)</strong></p>
			<p class="source-code">    stopAnimation()</p>
			<p class="source-code">}</p>
			<p>If this operation is called on the main thread, the animation will freeze for a few hundreds of milliseconds while the user's details are saved.</p>
			<p>Take a closer look at the code presented earlier and ask yourself the following: <em class="italic">which method call should be suspendable?</em></p>
			<p>Since the <strong class="source-inline">storeUser()</strong> method takes a while to finish, we want this method to be a suspending function because this function should be paused until the user's details are saved and then resumed when the job is done. This ensures that we do not block the main thread or<a id="_idIndexMarker293"/> freeze the animation.</p>
			<p>Yet, how can we make the <strong class="source-inline">storeUser()</strong> method a suspending function?</p>
			<p>A suspending function is a regular function that is marked with the <strong class="source-inline">suspend</strong> keyword:</p>
			<p class="source-code"><strong class="bold">suspend</strong> fun storeUser(user: User) {</p>
			<p class="source-code">    // blocking action</p>
			<p class="source-code">}</p>
			<p>We know that the <strong class="source-inline">storeUser()</strong> method saves details to a database, which takes a good while. So, in order to prevent this job from blocking the UI, we've marked the method with an additional <strong class="source-inline">suspend</strong> keyword.</p>
			<p>However, if we mark a method with the <strong class="source-inline">suspend</strong> keyword, trying to call it in our code results in a compilation error:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B17788_04_3.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Calling suspending functions from regular functions results in a compilation error</p>
			<p>Suspending functions can only be called from inside a coroutine or from inside another suspending function. Instead of calling our <strong class="source-inline">storeUser()</strong> suspending method from a regular method, let's create a coroutine and call it from there.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor123"/>Launching coroutines</h2>
			<p>To execute a<a id="_idIndexMarker294"/> suspend function, first, we need to create and launch a coroutine. To do that, we need to call a coroutine builder on a coroutine scope:</p>
			<p class="source-code">fun saveDetails(user: User) {</p>
			<p class="source-code">    <strong class="bold">GlobalScope.launch(Dispatchers.IO) {</strong></p>
			<p class="source-code"><strong class="bold">        </strong>startAnimation()</p>
			<p class="source-code">        database.storeUser(user)</p>
			<p class="source-code">        stopAnimation()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We have just launched our first coroutine and called our suspending function inside it! Let's break down what just happened:</p>
			<ul>
				<li>We've used a <strong class="source-inline">GlobalScope</strong> coroutine scope, which manages the coroutines that are launched within it.</li>
				<li>In the coroutine scope, we called the <strong class="source-inline">launch()</strong> coroutine builder to create a coroutine.</li>
				<li>Then, we passed the <strong class="source-inline">Dispatchers.IO</strong> dispatcher to the coroutine builder. In this case, we want to save the user details inside the database on a thread reserved for I/O operations.</li>
				<li>Inside the block that the <strong class="source-inline">launch()</strong> coroutine builder has provided us with, we call our <strong class="source-inline">storeUser()</strong> suspending function.</li>
			</ul>
			<p>Now we have successfully moved our blocking work away from the main thread to a worker thread. Therefore, we have made sure that the UI will not be blocked, and the animation will run smoothly.</p>
			<p>However, now that we have implemented suspending work in our <strong class="source-inline">saveDetails()</strong> method, you might be wondering what the order of function calls within this method will be.</p>
			<p>To better <a id="_idIndexMarker295"/>understand how the regular synchronous world blends with the suspending world, let's add some logs to our previous code snippet:</p>
			<p class="source-code">fun saveDetails(user: User) {</p>
			<p class="source-code">    Log.d("TAG", "Preparing to launch coroutine")</p>
			<p class="source-code">    GlobalScope.launch(Dispatchers.IO) {</p>
			<p class="source-code">        startAnimation()</p>
			<p class="source-code">        Log.d("TAG", "Starting to do async work")</p>
			<p class="source-code">        database.storeUser(user)</p>
			<p class="source-code">        Log.d("TAG", "Finished async work")</p>
			<p class="source-code">        stopAnimation()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    Log.d("TAG", "Continuing program <a id="_idTextAnchor124"/>execution")</p>
			<p class="source-code">}</p>
			<p>Remember, the only<a id="_idIndexMarker296"/> suspending function in this block of code that will take some time to compute is <strong class="source-inline">database.storeUser()</strong>. Now, let's imagine that we have run the preceding piece of code.</p>
			<p class="callout-heading">Exercise</p>
			<p class="callout">Before checking the following output, try to think about the order of the logs yourself. What do you expect the order of function calls to be?</p>
			<p>Let's see the output:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B17788_04_4.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – The output order of regular and suspending functions</p>
			<p>The order of the function calls is a bit out of order, but it is definitely correct. Let's see what happened:</p>
			<ol>
				<li>First, the log function with the <strong class="source-inline">Preparing to launch coroutine</strong> message was called. This method call was done on the main (UI) thread.</li>
				<li>Even though up next, we launched the coroutine, we can see that the second log function called was the last one in our code: <strong class="source-inline">Continuing program execution</strong>.</li>
			</ol>
			<p>This is because the coroutine is a bridge to the suspending world, so every function call from the coroutine will be run on a different thread from the main thread. More precisely, the operation of switching from the main thread to <strong class="source-inline">Dispatchers.IO</strong> will take some time. This means that all of these methods inside the coroutine will be executed after the method call outside of the coroutine.</p>
			<ol>
				<li value="3">The next log<a id="_idIndexMarker297"/> function call is with the <strong class="source-inline">Starting to do async work</strong> message. This method is called inside the coroutine on a thread reserved for I/O operations. This log marks the start of execution for all suspending work.</li>
				<li>Finally, after all of the blocking work from the <strong class="source-inline">database.storeUser()</strong> suspending function has been finished, the last log function call with the <strong class="source-inline">Finished async work</strong> message is called. This log marks the end of the coroutine execution.</li>
			</ol>
			<p>Now that we've understood how the regular world blends with the suspended world in terms of function calls, there are still many terms and concepts that have been thrown at you. Mainly, you might be wondering the following:</p>
			<ul>
				<li>What is a coroutine scope?</li>
				<li>What's a coroutine dispatcher?</li>
				<li>What's a coroutine builder?</li>
			</ul>
			<p>Let's clarify these concepts, starting with coroutine scopes.</p>
			<h3>Coroutine scopes</h3>
			<p>Essentially, coroutines <a id="_idIndexMarker298"/>run in <strong class="bold">coroutine scopes</strong>. To start a coroutine, first, you need a coroutine scope because it tracks all of the coroutines launched inside it and has the ability to cancel them. This way, you can control how long the coroutines should live and when they should be canceled.</p>
			<p>A coroutine scope contains a <strong class="source-inline">CoroutineContext</strong> object, which defines the context in which the coroutine runs. In the previous example, we used a predefined scope, <strong class="source-inline">GlobalScope</strong>, but you can also define a custom scope by constructing a <strong class="source-inline">CoroutineContext</strong> object and passing it to a <strong class="source-inline">CoroutineScope()</strong> function, as follows:</p>
			<p class="source-code">val job = Job()</p>
			<p class="source-code">val myScope = <strong class="bold">CoroutineScope(context = job + Dispatchers.IO)</strong></p>
			<p>The <strong class="source-inline">CoroutineScope()</strong> function expects a <strong class="source-inline">CoroutineContext</strong> object passed to its <strong class="source-inline">context</strong> parameter and knows how to build one out of the box. It does this by receiving elements with a special <strong class="source-inline">plus</strong> operator and then constructing the context behind the scenes.</p>
			<p>Most of the time, the two most important elements to construct a <strong class="source-inline">CoroutineContext</strong> object are the ones that we just passed:</p>
			<ul>
				<li>A <strong class="source-inline">Job</strong> object: This represents a cancelable component that controls the lifecycle of a coroutine launched in a specific scope. When a job is canceled, the job will cancel the coroutine it manages. For example, if we have defined a <strong class="source-inline">job</strong> object and a custom <strong class="source-inline">myScope</strong> object inside an <strong class="source-inline">Activity</strong> class, a good place to cancel the coroutine would be in the <strong class="source-inline">onDestroy()</strong> callback by calling the <strong class="source-inline">cancel()</strong> method on the <strong class="source-inline">job</strong> object:<p class="source-code">override fun onDestroy() {</p><p class="source-code">    super.onDestroy()</p><p class="source-code">    <strong class="bold">job.cancel()</strong></p><p class="source-code">}</p></li>
			</ul>
			<p>By doing this, we've ensured that our async work done within our coroutine, which uses the <strong class="source-inline">myScope</strong> scope, will stop when the activity has been destroyed and will not cause any memory leaks.</p>
			<ul>
				<li>A <strong class="source-inline">Dispatcher</strong> object: Marking a method as suspended provides no details about the thread pool it should run on. So, by passing a <strong class="source-inline">Dispatcher</strong> object to the <strong class="source-inline">CoroutineScope</strong> constructor, we can make sure that all suspended functions called in the coroutine that use this scope will default to the specified <strong class="source-inline">Dispatcher</strong> object. In our example, all coroutines launched in <strong class="source-inline">myScope</strong> will run their work, by default, in the <strong class="source-inline">Dispatchers.IO</strong> thread pool and will not block the UI.</li>
			</ul>
			<p>Note that the <strong class="source-inline">CoroutineContext</strong> object can also contain an exception handler object, which we will define later on.</p>
			<p>Apart from the custom scopes that you can define, as we did earlier, you can use predefined coroutine scopes that are bound to a certain lifecycle component. In such cases, you will no longer need to define a scope with a job or to manually cancel the coroutine scope:</p>
			<ul>
				<li><strong class="source-inline">GlobalScope</strong>: This allows the coroutines to live as long as the application is alive. In the previous example, we used this scope for simplicity, but <strong class="source-inline">GlobalScope</strong> should<a id="_idIndexMarker299"/> be avoided since the work launched within this coroutine scope is only canceled when the application has been destroyed. Using this scope in a component that has a narrower lifecycle than the application – such as an <strong class="source-inline">Activity</strong> component, might allow the coroutine to outlive that component's lifecycle and produce memory leaks.</li>
				<li><strong class="source-inline">lifecycleScope</strong>: This<a id="_idIndexMarker300"/> scopes coroutines to the lifecycle of a <strong class="source-inline">LifecycleOwner</strong> instance such as an <strong class="source-inline">Activity</strong> component or a <strong class="source-inline">Fragment</strong> component. We can use the <strong class="source-inline">lifecycleScope</strong> scope defined in the Jetpack KTX extensions package:<p class="source-code">class UserFragment : Fragment() {</p><p class="source-code">    ...</p><p class="source-code">    fun saveDetails(user: User) {</p><p class="source-code">        <strong class="bold">lifecycleScope</strong>.launch(Dispatchers.IO) {</p><p class="source-code">            startAnimation()</p><p class="source-code">            database.storeUser(user)</p><p class="source-code">            stopAnimation()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>By launching<a id="_idIndexMarker301"/> coroutines within this context, we ensure that if the <strong class="source-inline">Fragment</strong> component gets destroyed, the coroutine scope will automatically be canceled; therefore, this will also cancel our coroutine.</p>
			<ul>
				<li><strong class="source-inline">viewModelScope</strong>: To scope our coroutines to live as long as the <strong class="source-inline">ViewModel</strong> component<a id="_idIndexMarker302"/> does, we can use the predefined <strong class="source-inline">viewModelScope</strong> scope:<p class="source-code">class UserViewModel: ViewModel() {</p><p class="source-code">    fun saveDetails(user: User) {</p><p class="source-code">        // do some work</p><p class="source-code">        <strong class="bold">viewModelScope</strong>.launch(Dispatchers.IO) {</p><p class="source-code">            database.storeUser(user)</p><p class="source-code">        }</p><p class="source-code">        // do some other work</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>By launching coroutines within this context, we ensure that if the <strong class="source-inline">ViewModel</strong> component gets cleared, the coroutine scope will cancel its work – in other words, it will automatically <a id="_idIndexMarker303"/>cancel our coroutine.</p>
			<ul>
				<li><strong class="source-inline">rememberCoroutineScope</strong>: To scope a coroutine to the composition cycle of a composable function, we can <a id="_idIndexMarker304"/>use the predefined <strong class="source-inline">rememberCoroutineScope</strong> scope:<p class="source-code">@Composable</p><p class="source-code">fun UserComposable() {</p><p class="source-code">    <strong class="bold">val scope = rememberCoroutineScope()</strong></p><p class="source-code">    LaunchedEffect(key1 = "save_user") {</p><p class="source-code">        <strong class="bold">scope</strong>.launch(Dispatchers.IO) { </p><p class="source-code">            viewModel.saveUse<a id="_idTextAnchor125"/>r()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>Therefore, a coroutine's lifecycle is bound to the composition cycle of <strong class="source-inline">UserComposable</strong>. This means that when <strong class="source-inline">UserComposable</strong> leaves the composition, the scope will be automatically canceled, thereby preventing the coroutine from outliving the composition lifecycle of its parent composable.</p>
			<p>Since we want the coroutine to be launched only once upon composition and not at every recomposition, we wrapped the coroutine with a <strong class="source-inline">LaunchedEffect</strong> composable.</p>
			<p>Now that we covered what coroutine scopes are and how they allow us to control the lifetime of coroutines, it's time to better understand what dispatchers are.</p>
			<h3>Dispatchers</h3>
			<p>A <strong class="bold">CoroutineDispatcher</strong> object<a id="_idIndexMarker305"/> allows us to configure what thread pool our work should be executed on. The point of coroutines is to help us move blocking work away from the main thread. So, somehow, we need to instruct the coroutines what threads to use for the work that we pass to them.</p>
			<p>To do that, we need to configure the <strong class="source-inline">CoroutineContext</strong> object of the coroutines to set a specific dispatcher. In fact, when we covered coroutine scopes,<a id="_idTextAnchor126"/> we've explained how <strong class="source-inline">CoroutineContext</strong> is defined by a job and a dispatcher.</p>
			<p>When creating custom scopes, we can specify the default dispatcher right when we instantiate the scope, just as we did previously:</p>
			<p class="source-code">val myScope = CoroutineScope(context = job + <strong class="bold">Dispatchers.IO</strong>)</p>
			<p>In this case, the default dispatcher of <strong class="source-inline">myScope</strong> is <strong class="source-inline">Dispatchers.IO</strong>. This means that whatever suspending work we pass to the coroutines that are launched with <strong class="source-inline">myScope</strong>, the work will be moved to a special thread pool for I/O background work.</p>
			<p>In the case of predefined coroutine scopes, such as with <strong class="source-inline">lifecycleScope</strong>, <strong class="source-inline">viewModelScope</strong>, or <strong class="source-inline">rememberCoroutineScope</strong>, we can specify the desired default dispatcher when starting our coroutine:</p>
			<p class="source-code">scope.launch(<strong class="bold">Dispatchers.IO</strong>) {</p>
			<p class="source-code">    viewModel.saveUser()</p>
			<p class="source-code">}</p>
			<p>We start coroutines <a id="_idIndexMarker306"/>with coroutine builders such as <strong class="source-inline">launch</strong> or <strong class="source-inline">async</strong>, which we will cover in the next section. Until then, we need to understand that when launching a coroutine, we can also modify the <strong class="source-inline">CoroutineContext</strong> object of the coroutine by specifying a <strong class="source-inline">CoroutineDispatcher</strong> object.</p>
			<p>Now we've used <strong class="source-inline">Dispatchers.IO</strong> as a dispatcher throughout our examples. But are there any other dispatchers that are of use to us?</p>
			<p><strong class="source-inline">Dispatchers.IO</strong> is a dispatcher offered by the Coroutines API, but in addition to this, coroutines offer other dispatchers too. Let's list the most notable dispatchers as follows:</p>
			<ul>
				<li><strong class="source-inline">Dispatchers.Main</strong>: This <a id="_idIndexMarker307"/>dispatches work to the main thread on Android. It is ideal for light work (which doesn't block the UI) or actual UI function calls and interactions.</li>
				<li><strong class="source-inline">Dispatchers.IO</strong>: This <a id="_idIndexMarker308"/>dispatches blocking work to a background thread pool that specializes in handling disk-heavy or network-heavy operations. This dispatcher should be specified for suspending work on local databases or executing network requests.</li>
				<li><strong class="source-inline">Dispatchers.Default</strong>: This<a id="_idIndexMarker309"/> dispatches blocking work to a background thread pool that specializes in CPU-intensive tasks, such as sorting long lists, parsing JSON, and more.</li>
			</ul>
			<p>In the previous examples, we<a id="_idIndexMarker310"/> set a specific dispatcher of <strong class="source-inline">Dispatchers.IO</strong> for the <strong class="source-inline">CoroutineContext</strong> object of the coroutines launched, ensuring that suspended work will be dispatched by this specific dispatcher.</p>
			<p>But we've made a critical mistake! Let's take a look at the code again:</p>
			<p class="source-code">class UserFragment : Fragment() {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fun saveDetails(user: User) {</p>
			<p class="source-code">        lifecycleScope.launch(Dispatchers.IO) {</p>
			<p class="source-code">            startAnimation()</p>
			<p class="source-code">            database.storeUser(user)</p>
			<p class="source-code">            stopAnimation()</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The main issue with this code is that the <strong class="source-inline">startAnimation()</strong> and <strong class="source-inline">stopAnimation()</strong> functions are probably not even suspending functions, as they interact with the UI.</p>
			<p>We wanted to run our <strong class="source-inline">database.storeUser()</strong> blocking work on a background thread, so we specified the <strong class="source-inline">Dispatchers.IO</strong> dispatcher to the <strong class="source-inline">CoroutineContext</strong> object. But this means that all the rest of the code in the coroutine block (that is, the <strong class="source-inline">startAnimation()</strong> and <strong class="source-inline">stopAnimation()</strong> function calls) will be dispatched to a thread pool intended for background work instead of being dispatched to the main thread.</p>
			<p>To have more fine-grained control regarding what threads our functions are being dispatched to, coroutines allow us to control the dispatcher by using the <strong class="source-inline">withContext</strong> block, which creates a block of code that can run on a different dispatcher.</p>
			<p>Since <strong class="source-inline">startAnimation()</strong> and <strong class="source-inline">stopAnimation()</strong> have to work on the main thread, let's refactor our example.</p>
			<p>Let's launch our <a id="_idIndexMarker311"/>coroutine with the default dispatcher of <strong class="source-inline">Dispatchers.Main</strong>, and then wrap our work, which has to be run on a background thread (the <strong class="source-inline">database.storeUser(user)</strong> suspending function), with a <strong class="source-inline">withContext</strong> block:</p>
			<p class="source-code">fun saveDetails(user: User) {</p>
			<p class="source-code">    lifecycleScope.launch(<strong class="bold">Dispatchers.Main</strong>) {</p>
			<p class="source-code">        startAnimation()</p>
			<p class="source-code"><strong class="bold">        withContext(Dispatchers.IO) {</strong></p>
			<p class="source-code">            database.storeUser(user)</p>
			<p class="source-code">    <strong class="bold">    }</strong></p>
			<p class="source-code">        stopAnimation()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">withContext</strong> function allows us to define a more granular <strong class="source-inline">CoroutineContext</strong> object for the block that it exposes. In our case, we had to pass the <strong class="source-inline">Dispatchers.IO</strong> dispatcher to make sure our blocking work with the database will run on the background thread instead of being dispatched to the main thread.</p>
			<p>In other words, our coroutine will have all its work dispatched to the <strong class="source-inline">Dispatchers.Main</strong> dispatcher, unless <a id="_idIndexMarker312"/>you define another more granul<a id="_idTextAnchor127"/>ar context that has its own <strong class="source-inline">CoroutineDispatcher</strong> set.</p>
			<p>Now we've covered how to use dispatchers and how to ensure more granular control over how our work is dispatched to different threads. However, we haven't covered what the <strong class="source-inline">launch { }</strong> block means. Let's do that next.</p>
			<h3>Coroutine builders</h3>
			<p><strong class="bold">Coroutine builders</strong> (such as <strong class="source-inline">launch</strong>) are extension functions on <strong class="source-inline">CoroutineScope</strong> and<a id="_idIndexMarker313"/> allow us to create and start coroutines. Essentially, they are a bridge between the normal synchronous world with regular functions and the suspending world with suspending functions.</p>
			<p>Since we can't call suspending functions inside regular functions, a coroutine builder method executed on the <strong class="source-inline">CoroutineScope</strong> object creates a scoped coroutine that provides us with a block of code where we can call our suspending functions. Without scopes, we cannot create coroutines – which is good since this practice helps to prevent memory leaks.</p>
			<p>We can use three builder functions to create coroutines:</p>
			<ul>
				<li><strong class="source-inline">launch</strong>: This starts a coroutine that runs concurrently with the rest of the code. Coroutines started<a id="_idIndexMarker314"/> with <strong class="source-inline">launch</strong> won't return the result to the caller – instead, all of the suspending functions will run sequentially inside the block that <strong class="source-inline">launch</strong> exposes. It's our job to get the result from the suspending functions and then interact with that result:<p class="source-code">fun getUser() {</p><p class="source-code">    lifecycleScope.<strong class="bold">launch</strong>(Dispatchers.IO) {</p><p class="source-code">        val user = database.getUser()</p><p class="source-code">      <a id="_idTextAnchor128"/>  // show details to UI</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>Most of the time, if you don't need concurrent work, <strong class="source-inline">launch</strong> is the go-to option for starting coroutines since it allows you to run your suspending work inside the block of code provided and doesn't care about anything else.</p>
			<p>If no dispatcher is specified in the coroutine<a id="_idIndexMarker315"/> builder, the dispatcher that is going to be used is the dispatcher provided by default by the <strong class="source-inline">CoroutineScope</strong> used to start the coroutine. In our case, if we wouldn't have specified a dispatcher, our coroutine launched with the <strong class="source-inline">launch</strong> coroutine builder will have used the <strong class="source-inline">Dispatchers.Main</strong> dispatcher defined by default by <strong class="source-inline">lifecycleScope</strong>.</p>
			<p>Apart from <strong class="source-inline">lifecycleScope</strong>, <strong class="source-inline">viewModelScope</strong> also provides the same predefined dispatcher of <strong class="source-inline">Dispatchers.Main</strong>. <strong class="source-inline">GlobalScope</strong> on the other hand, defaults to <strong class="source-inline">Dispatchers.Default</strong> if no dispatcher was provided to the coroutine builder.</p>
			<ul>
				<li><strong class="source-inline">async</strong>: This starts a new <a id="_idIndexMarker316"/>coroutine, and it allows you to return the result as a <strong class="source-inline">Deferred&lt;T&gt;</strong> object, where <strong class="source-inline">T</strong> is your expected data type. The deferred object is a promise that your result, <strong class="source-inline">T</strong>, will be returned in the future. To start the coroutine and get a result, you need to call the suspending function, <strong class="source-inline">await</strong>, which blocks the calling thread:<p class="source-code">lifecycleScope.launch(Dispatchers.IO) {</p><p class="source-code">    val deferredAudio: Deferred&lt;Audio&gt; =</p><p class="source-code">        <strong class="bold">async</strong> { convertTextToSpeech(title) }</p><p class="source-code">    val titleAudio = deferredAudio<strong class="bold">.aw<a id="_idTextAnchor129"/>ait()</strong></p><p class="source-code">    playSound(titleAudio)</p><p class="source-code">}</p></li>
			</ul>
			<p>We can't use <strong class="source-inline">async</strong> in a normal function as it has to call the <strong class="source-inline">await</strong> suspending function to get the result. To fix that, first, we've created a parent coroutine with <strong class="source-inline">launch</strong> and started the child coroutine with <strong class="source-inline">async</strong> inside it. This means the child coroutine that was started with <strong class="source-inline">async</strong> inherits its <strong class="source-inline">CoroutineContext</strong> object from the parent coroutine that was started with <strong class="source-inline">launch</strong>.</p>
			<p>With <strong class="source-inline">async</strong>, we <a id="_idIndexMarker317"/>can get the results of the concurrent work in one place. Where the <strong class="source-inline">async</strong> coroutine builder shines (and where it's recommended to be used) is in tasks with parallel execution where results are required.</p>
			<p>Let's say that we need to simultaneously convert two pieces of text into speech and then play both results at the same time:</p>
			<p class="source-code">lifecycleScope.launch(Dispatchers.IO) {</p>
			<p class="source-code">    val deferredTitleAudio: Deferred&lt;Audio&gt; =</p>
			<p class="source-code">        async { convertTextToSpeech(title) }</p>
			<p class="source-code">    val deferredSubtitleAudio: Deferred&lt;Audio&gt; =</p>
			<p class="source-code">        async { convertTextToSpeech(subtitle) }</p>
			<p class="source-code">    playSounds(</p>
			<p class="source-code">        deferredTitleAudio.await(),</p>
			<p class="source-code">        deferredSubtitleAudio.await()</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>In this particular example, both the resulting <strong class="source-inline">deferredTitleAudio</strong> and <strong class="source-inline">deferredSubtitleAudio</strong> tasks <a id="_idIndexMarker318"/>will run in parallel.</p>
			<p>Since our Restaurants application hasn't featured concurrent work until now, we won't go any deeper in terms of concurrency topics.</p>
			<ul>
				<li><strong class="source-inline">runBlocking</strong>: This starts a<a id="_idIndexMarker319"/> coroutine that blocks the current thread on which<a id="_idIndexMarker320"/> it is invoked until the coroutine has been completed. This builder should be avoided for async work within our app since creating threads and blocking them is less efficient. However, this coroutine builder can be used for unit tests.</li>
			</ul>
			<p>Now that we have covered the basics of coroutines, it's high time we implement coroutines in our Restaurants application!</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor130"/>Using coroutines for async work</h1>
			<p>The first thing <a id="_idIndexMarker321"/>that we have to do is identify the async/heavy work that we have done in our Restaurants application.</p>
			<p>Without looking at the code, we know that our app retrieves a list of restaurants from the server. It does that by initiating a network request with Retrofit and then waits for a response. This action qualifies as an async job because we don't want to block the main (UI) thread while the app waits for the network response to arrive.</p>
			<p>If we check out the <strong class="source-inline">RestaurantsViewModel</strong> class, we can identify that the <strong class="source-inline">getRestaurants()</strong> method is the one place in our application where heavy blocking work is happening:</p>
			<p class="source-code">private fun getRestaurants() {</p>
			<p class="source-code">    restaurantsCall = restInterface.getRestaurants()</p>
			<p class="source-code">    restaurantsCall.enqueue(object : Callback</p>
			<p class="source-code">        &lt;List&lt;Restaurant&gt;&gt; {</p>
			<p class="source-code">            override fun onResponse(...) {</p>
			<p class="source-code">                response.body()?.let { restaurants -&gt; ... }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            override fun onFailure(...) {</p>
			<p class="source-code">                t.printStackTrace()</p>
			<p class="source-code">            }</p>
			<p class="source-code">        })</p>
			<p class="source-code">}</p>
			<p>When we implemented the network request, we used Retrofit's <strong class="source-inline">enqueue()</strong> method to which we passed a <strong class="source-inline">Callback</strong> object where we could wait for the result without blocking the main thread.</p>
			<p>To simplify the way <a id="_idIndexMarker322"/>we handle this async operation of getting the restaurants from the server, we will implement coroutines. This will allow us to ditch callbacks and make our code more concise.</p>
			<p>In this section, we will cover two main steps:</p>
			<ul>
				<li>Implementing coroutines instead of callbacks</li>
				<li>Improving the way our app works with coroutines</li>
			</ul>
			<p>Let's get started!</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor131"/>Implementing coroutines instead of callbacks</h2>
			<p>To handle async <a id="_idIndexMarker323"/>work with coroutines, we need to do the following:</p>
			<ul>
				<li>Define our async work in a suspending function.</li>
				<li>Next, create a coroutine and call the suspending function inside it to obtain the result asynchronously.</li>
			</ul>
			<p>Enough with the theory, it's time to code! Perform the following steps:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RestaurantsApiService</strong> interface, add the <strong class="source-inline">suspend</strong> keyword to the <strong class="source-inline">getRestaurants()</strong> method and replace the <strong class="source-inline">Call&lt;List&lt;Restaurant&gt;&gt;</strong> return type of the method with <strong class="source-inline">List&lt;Restaurant&gt;</strong>:<p class="source-code">interface RestaurantsApiService {</p><p class="source-code">    @GET("restaurants.json")</p><p class="source-code">    <strong class="bold">suspend</strong> fun getRestaurants(): <strong class="bold">List&lt;Restaurant&gt;</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Retrofit supports coroutines out of the box for network requests. This means that we can mark any method in our Retrofit interface with the <strong class="source-inline">suspend</strong> keyword; therefore, we can transform the network requests to suspending work that isn't blocking the main thread of the application.</p>
			<p>Because of this, the <strong class="source-inline">Call&lt;T&gt;</strong> return type is redundant. We no longer need Retrofit to return a <strong class="source-inline">Call</strong> object on which we would normally enqueue a <strong class="source-inline">Callback</strong> object to listen for the response – all of this will be handled by the Coroutines API.</p>
			<ol>
				<li value="2">Since we will no longer receive a <strong class="source-inline">Call</strong> object from Retrofit, we will also not need the <strong class="source-inline">Callback</strong> object in our <strong class="source-inline">RestaurantsViewModel</strong> class. Clean up the <strong class="source-inline">RestaurantsViewModel</strong> component: <ul><li>Remove <a id="_idIndexMarker324"/>the <strong class="source-inline">restaurantsCall: Call&lt;List&lt;Restaurant&gt;</strong> member variable.</li><li>Remove the <strong class="source-inline">restaurantsCall.cancel()</strong> method call inside the <strong class="source-inline">onCleared()</strong> callback.</li><li>Remove the entire body of the <strong class="source-inline">getRestaurants()</strong> method.</li></ul></li>
				<li>Inside the <strong class="source-inline">getRestaurants()</strong> method, call the <strong class="source-inline">restInterface.getRestaurants()</strong> suspending function and store the result<a id="_idTextAnchor132"/> in a <strong class="source-inline">restaurants</strong> varia<a id="_idTextAnchor133"/>ble:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    <strong class="bold">val restaurants = restInterface.getRestaurants()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The IDE will throw an error telling us that we cannot call the <strong class="source-inline">restInterface.getRestaurants()</strong> suspending function from the regular <strong class="source-inline">getRestaurants()</strong> function within the <strong class="source-inline">ViewModel</strong> component.</p>
			<p>To fix this, we must create a coroutine, launch it, and call the suspending function there.</p>
			<ol>
				<li value="4">Before creating a coroutine, we need to create a <strong class="source-inline">CoroutineScope</strong> object. Inside the <strong class="source-inline">ViewModel</strong> component, define a member variable of type <strong class="source-inline">Job</strong> and another of type <strong class="source-inline">CoroutineScope</strong>, just as we learned earlier:<p class="source-code">class RestaurantsViewModel(…): ViewModel() {</p><p class="source-code">    private var restInterface: RestaurantsApiService</p><p class="source-code">    val state = mutableStateOf(…)</p><p class="source-code">    <strong class="bold">val job = Job()</strong></p><p class="source-code">    <strong class="bold">private val scope = Coro<a id="_idTextAnchor134"/>utineScope(job + </strong></p><p class="source-code"><strong class="bold">        Dispatchers.IO)</strong></p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">job</strong> variable <a id="_idIndexMarker325"/>is the handle that will allow us to cancel the coroutine scope, while the <strong class="source-inline">scope</strong> variable will ensure we keep track of the coroutines that are going be to be launched with it.</p>
			<p>Since the network request is a heavy blocking operation, we want its suspending work to be executed on the <strong class="source-inline">IO</strong> thread pool to avoid blocking the main thread, so we specified the <strong class="source-inline">Dispatchers.IO</strong> dispatcher for our <strong class="source-inline">scope</strong> object.</p>
			<ol>
				<li value="5">Inside the <strong class="source-inline">onCleared()</strong> callback method, call the <strong class="source-inline">cancel()</strong> method in the newly created job variable:<p class="source-code">override fun onCleared() {</p><p class="source-code">    super.onCleared()</p><p class="source-code">    <strong class="bold">job.cancel()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>By calling <strong class="source-inline">cancel()</strong> on our <strong class="source-inline">job</strong> variable, we ensure that if the <strong class="source-inline">RestaurantsViewModel</strong> component is destroyed (for example, in scenarios where the user navigates to a different screen) the coroutine <strong class="source-inline">scope</strong> object will be canceled through its <strong class="source-inline">job</strong> object reference. Effectively, this will cancel any suspending work and prevent the coroutine from causing a memory leak.</p>
			<ol>
				<li value="6">Inside the <strong class="source-inline">getRestaurants()</strong> method in our <strong class="source-inline">ViewModel</strong> component, create a coroutine by calling <strong class="source-inline">launch</strong> on the previously defined <strong class="source-inline">scope</strong> object, and inside that<a id="_idIndexMarker326"/> body exposed by the coroutine add the existing code where we obtain the restaurants:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    <strong class="bold">scope.launch {</strong></p><p class="source-code">        val restaurants = restIn<a id="_idTextAnchor135"/>terface.getRestaurants()</p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Success! We have launched a coroutine that executes our suspending work of obtaining the restaurants from the server.</p>
			<ol>
				<li value="7">Next, add the initial code to update our <strong class="source-inline">State</strong> object with the newly received restaurants so that the Compose UI displays them:<p class="source-code">scope.launch {</p><p class="source-code">    val restaur<a id="_idTextAnchor136"/>ants = restInterface.getRestaurants()</p><p class="source-code">    <strong class="bold">state.value = restaurants.restoreSelections()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>However, this approach is flawed. Can you point out why?</p>
			<p>Well, we are updating the UI on an incorrect thread. Our <strong class="source-inline">scope</strong> is defined to run the coroutine on a thread from the <strong class="source-inline">Dispatchers.IO</strong> thread pool, but updating the UI should happen on the Main thread.</p>
			<ol>
				<li value="8">Inside the <strong class="source-inline">getRestaurants()</strong> method, wrap the line of code where the Compose <strong class="source-inline">State</strong> object is updated with a <strong class="source-inline">withContext</strong> block that specifies the <strong class="source-inline">Dispatchers.Main</strong> dispatcher:<p class="source-code">scope.launch {</p><p class="source-code">    val restaurants = restInterface.getRestaurants()</p><p class="source-code"><strong class="bold">    withContext(Dispatchers.Main) {</strong></p><p class="source-code"><strong class="bold">        state.va<a id="_idTextAnchor137"/>lue = restaurants.restoreSelections()</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>By doing this, we<a id="_idIndexMarker327"/> ensure that while heavy work is being done on the background threads, the UI is updated from the main thread.</p>
			<p>We have now successfully implemented coroutines in our app. We have defined a scope and created a coroutine where we executed our suspending work: a network request.</p>
			<ol>
				<li value="9">You can now <strong class="bold">Run</strong> the application and notice that on the outside, the behavior of the app hasn't changed. However, behind the scenes, our async work was done with the help of coroutines in a more elegant manner than before.</li>
			</ol>
			<p>Even so, there are a few things that could be improved. Let's tackle those next.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor138"/>Improving the way our app works with coroutines</h2>
			<p>Our app uses a coroutine to<a id="_idIndexMarker328"/> move heavy work from the main thread to specialized threads.</p>
			<p>However, if we think about our particular implementation, we can find some ways to improve our coroutine-related code:</p>
			<ul>
				<li>Use predefined scopes as opposed to custom scopes.</li>
				<li>Add error handling.</li>
				<li>Make sure that <a id="_idIndexMarker329"/>every <strong class="source-inline">suspend</strong> function is safe to be called on any <strong class="source-inline">Dispatcher</strong> object.</li>
			</ul>
			<p>Let's start with the fun one: replacing our custom scope with a predefined one!</p>
			<h3>Using predefined scopes as opposed to custom scopes</h3>
			<p>In our current implementation, we've defined a custom <strong class="source-inline">CoroutineScope</strong> object that will make sure that its<a id="_idIndexMarker330"/> coroutines will live as long as the <strong class="source-inline">RestaurantsViewModel</strong> instance. To achieve this, we pass a <strong class="source-inline">Job</strong> object to our <strong class="source-inline">CoroutineScope</strong> builder and cancel it when the <strong class="source-inline">ViewModel</strong> component is destroyed: on the <strong class="source-inline">onCleared()</strong> callback method.</p>
			<p>Now, remember that coroutines are well integrated with the Jetpack libraries, and when we define scopes, we also talk about predefined scopes such as <strong class="source-inline">lifecycleScope</strong>, <strong class="source-inline">viewModelScope</strong>, and more. These scopes make sure that their coroutines live as long as the component they are bound to, for example, <strong class="source-inline">lifecycleScope</strong> is bound to a <strong class="source-inline">Fragment</strong> or <strong class="source-inline">Activity</strong> component.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whenever you are launching a coroutine inside components such as <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, <strong class="source-inline">ViewModel</strong>, or even composable functions, remember that instead of creating and managing your own <strong class="source-inline">CoroutineScope</strong> object, you can use the predefined ones that take care of canceling coroutines automatically. By using predefined scopes, you can better avoid memory leaks as any suspending work is cancelled when needed.</p>
			<p>In our scenario, we can simplify our code and replace our custom <strong class="source-inline">CoroutineScope</strong> object with the <strong class="source-inline">viewModelScope</strong> one. Behind the scenes, this predefined scope will take care of canceling all of the coroutines launched with it when its parent <strong class="source-inline">ViewModel</strong> instance has been cleared or destroyed.</p>
			<p>Let's do that now:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">getRestaurants()</strong> method of the <strong class="source-inline">RestaurantsViewModel</strong> class, replace <strong class="source-inline">scope</strong> with <strong class="source-inline">viewModelScope</strong>:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    <strong class="bold">viewModelScope</strong>.launch {</p><p class="source-code">        val restaurants = …</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Since we <a id="_idIndexMarker331"/>will no longer use our <strong class="source-inline">scope</strong> object, we need to make sure that our coroutine will run the suspending work in the background, just as it did with the previous scope. Pass a <strong class="source-inline">D<a id="_idTextAnchor139"/>ispatchers.IO</strong> dispatcher to the <strong class="source-inline">launch</strong> method:<p class="source-code">viewModelScope.launch<strong class="bold">(Dispatchers.IO)</strong> {</p><p class="source-code">    val restaurants = restInterface.getRestaurants()</p><p class="source-code">    withContext(Dispatchers.Main) {</p><p class="source-code">        state.value = restaurants.restoreSelections()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Usually, the <strong class="source-inline">launch</strong> coroutine builder inherits <strong class="source-inline">CoroutineContext</strong> from its parent coroutine. In our particular case though, if no dispatcher is specified, coroutines launched with <strong class="source-inline">viewModelScope</strong> will default to using <strong class="source-inline">Dispatchers.Main</strong>.</p>
			<p>However, we want our network request to be executed on a background thread from the specialized I/O thread pool, so we passed an initial <strong class="source-inline">CoroutineContext</strong> object with a <strong class="source-inline">Dispatchers.IO</strong> dispatcher to our <strong class="source-inline">launch</strong> call.</p>
			<ol>
				<li value="3">Remove the <strong class="source-inline">onCleared()</strong> callback method entirely from the <strong class="source-inline">ViewModel</strong> class. We will no longer need to cancel our coroutine <strong class="source-inline">scope</strong> from a <strong class="source-inline">job</strong> object because <strong class="source-inline">viewModelScope</strong> takes care of that for us. </li>
				<li>Remove the <strong class="source-inline">job</strong> and <strong class="source-inline">scope</strong> member variables from the <strong class="source-inline">RestaurantsViewModel</strong> class.</li>
				<li>You can now <strong class="bold">Run</strong> the application and again notice that on the outside, the behavior<a id="_idIndexMarker332"/> of the app hasn't changed. Our code now works the same but is greatly simplified because we used a predefined scope instead of handling everything by ourselves.</li>
			</ol>
			<p>Next, we must re-add error handling to our project. However, this time, we will do it in the context of coroutines.</p>
			<h3>Adding error handling</h3>
			<p>In the previous<a id="_idIndexMarker333"/> implementation with callbacks, we received an error callback from Retrofit. However, with coroutines, it appears that since our suspending function returns <strong class="source-inline">List&lt;Restaurant&gt;&gt;</strong>, there is no room for error.</p>
			<p>Indeed, we are not handling any error that could be thrown. For example, if you try to launch the application without internet right now, Retrofit will throw a <strong class="source-inline">Throwable</strong> object, which, in turn, will crash our app with a similar error as follows:</p>
			<p class="source-code">E/AndroidRuntime: FATAL EXCEPTION: DefaultDispatcher-worker-1</p>
			<p>To handle errors, we can simply wrap suspending function calls in a <strong class="source-inline">try catch</strong> bl<a id="_idTextAnchor140"/>ock:</p>
			<p class="source-code">viewModelScope.launch(Dispatchers.IO) {</p>
			<p class="source-code">    <strong class="bold">try {</strong></p>
			<p class="source-code">        val restaurants = restInterface.getRestaurants()</p>
			<p class="source-code">        // show restaurants</p>
			<p class="source-code">    <strong class="bold">} catch (e: Exception) {</strong></p>
			<p class="source-code">        <strong class="bold">e.printStackTrace()</strong></p>
			<p class="source-code">    <strong class="bold">}</strong></p>
			<p class="source-code">}</p>
			<p>The preceding approach is fine, but the code becomes less concise because of another level of nesting. Additionally, to better support a single point of error handling, coroutines allow you to pass a <strong class="source-inline">CoroutineExceptionHandler</strong> object to the context of your <strong class="source-inline">CoroutineScope</strong> object:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B17788_04_5.jpg" alt="Figure 4.5 – The signature of CoroutineExceptionHandler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – The signature of CoroutineExceptionHandler</p>
			<p>The <strong class="source-inline">CoroutineExceptionHandler</strong> object allows us to handle errors thrown by any coroutine launched <a id="_idIndexMarker334"/>within a <strong class="source-inline">CoroutineScope</strong> object, no matter how nested it might be. This handler gives us access to a function that exposes the <strong class="source-inline">CoroutineContext</strong> object and the <strong class="source-inline">Throwable</strong> object thrown in this particular context.</p>
			<p>Let's add such a handler to the <strong class="source-inline">RestaurantsViewModel</strong> class. Perform the following steps:</p>
			<ol>
				<li value="1">Define an <strong class="source-inline">errorHandler</strong> member variable of type <strong class="source-inline">CoroutineExceptionHandler</strong> and print the stack trace of the <strong class="source-inline">exception: Throwable</strong> parameter:<p class="source-code">clas<a id="_idTextAnchor141"/>s RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    ...</p><p class="source-code"><strong class="bold">    private val errorHandler = </strong></p><p class="source-code"><strong class="bold">        CoroutineExceptionHandler { _, exception -&gt;</strong></p><p class="source-code"><strong class="bold">            exception.printStackTrace()</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>We're not interested in the first parameter of type <strong class="source-inline">CoroutineContext</strong>, so we named it with an underscore, <strong class="source-inline">_</strong>.</p>
			<ol>
				<li value="2">Inside the <strong class="source-inline">getRestaurants()</strong> method, pass the <strong class="source-inline">errorHandler</strong> variable to the <strong class="source-inline">launch</strong> block using the <strong class="source-inline">+</strong> operator:<p class="source-code">private fun getRestaurants() { </p><p class="source-code">       viewModelScope.launch(Dispatchers.IO +</p><p class="source-code">                             <strong class="bold">errorHandler</strong>) { </p><p class="source-code">            … </p><p class="source-code">       } </p><p class="source-code">}</p></li>
			</ol>
			<p>By passing our <strong class="source-inline">errorHandler</strong> variable to the <strong class="source-inline">launch</strong> method, we make sure that the <strong class="source-inline">CoroutineContext</strong> object of this coroutine sets this <strong class="source-inline">CoroutineExceptionHandler</strong>, which will allow us to handle errors inside our handler.</p>
			<ol>
				<li value="3">Try running the <a id="_idIndexMarker335"/>app again without the internet.</li>
			</ol>
			<p>Now the app shouldn't crash because the <strong class="source-inline">errorHandler</strong> variable will catch the <strong class="source-inline">Throwable</strong> object thrown by Retrofit and allow us to print its stack trace.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As an improvement, try to find a way of notifying the UI that an error has occurred, thereby informing the user of what just happened.</p>
			<p>We are now handling errors with coroutines, so it's time to move to the last point of improvement – handling the switch of dispatchers correctly.</p>
			<h3>Making sure that every suspending function is safe to be called on any dispatcher</h3>
			<p>When defining suspending functions, a good practice is to make sure that every suspending function can be called on any <strong class="source-inline">Dispatcher</strong> object. This way, the caller (in our case, the coroutine) doesn't have to worry about <a id="_idIndexMarker336"/>what thread will be needed to execute the suspending function.</p>
			<p>Let's analyze our code with the coroutine:</p>
			<p class="source-code">private fun getRestaurants() {</p>
			<p class="source-code">    viewModelScope.launch(Dispatchers.IO + errorHandler) {</p>
			<p class="source-code">        val restaurants = restInterface.getRestaurants()</p>
			<p class="source-code">        withContext(Dispatchers.Main) {</p>
			<p class="source-code">            state.value = restaurants.restoreSelections()</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">getRestaurants()</strong> method of the <strong class="source-inline">restInterface: RestaurantsApiService</strong> interface is a suspending function. This function should always be run on <strong class="source-inline">Dispatchers.IO</strong> since it executes a heavy I/O operation, that is, the network request.</p>
			<p>However, this would mean that whenever we have to call <strong class="source-inline">restInterface.getRestaurants()</strong>, we either have to call this suspending function from a coroutine that has a scope of <strong class="source-inline">Dispatchers.IO</strong> – just as we did previously – or always wrap it in a <strong class="source-inline">withContext(Dispatchers.IO)</strong> block inside the caller coroutine.</p>
			<p>Both of these alternatives don't scale well. Imagine that you have to call <strong class="source-inline">restInterface.getRestaurants()</strong> 10 times in the <strong class="source-inline">RestaurantsViewModel</strong> class. You would always have to be careful with setting the dispatcher when calling this function.</p>
			<p>Let's address this by creating a separate method where we can specify the correct dispatcher for our suspending function:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RestaurantsViewModel</strong> class, create a separate suspending method, called <strong class="source-inline">getRemoteRestaurants()</strong>, and wrap the <strong class="source-inline">restInterface.getRestaurants()</strong> call there with a <strong class="source-inline">withContext()</strong> block:<p class="source-code">private suspend fun getRemoteRestaurants(): List&lt;Restaurant&gt; {</p><p class="source-code">    return withContext(Dispatchers.<a id="_idTextAnchor142"/>IO) {</p><p class="source-code">        restInterface.getRestaurants()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>To the <strong class="source-inline">withContext</strong> method, we've passed the corresponding dispatcher for this suspending function: <strong class="source-inline">Dispatchers.IO</strong>.</p>
			<p>This <a id="_idIndexMarker337"/>means that whenever this suspending function is called (from a coroutine or another suspending function), the dispatcher will be switched to <strong class="source-inline">Dispatchers.IO</strong> for the <strong class="source-inline">restInterface.getRestaurants()</strong> call's execution.</p>
			<p>By doing so, we make sure that whoever is calling <strong class="source-inline">getRemoteRestaurants()</strong> will not have to care about the correct thread dispatcher for the content of this method.</p>
			<ol>
				<li value="2">In the <strong class="source-inline">getRestaurants()</strong> method of the <strong class="source-inline">ViewModel</strong> component, replace the <strong class="source-inline">restInterface.getRestaurants()</strong> method call with <strong class="source-inline">getRemoteRestaurants()</strong>:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    viewModelScope.launch(Dispatchers.IO +<a id="_idTextAnchor143"/> errorHandler) </p><p class="source-code">    {</p><p class="source-code">        val restaurants = <strong class="bold">getRemoteRestaurants()</strong></p><p class="source-code">        withContext(Dispatchers.Main) {</p><p class="source-code">            state.value = restaurants.restoreSelections()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Since the content of the <strong class="source-inline">getRemoteRestaurants()</strong> method will be called on its appropriate dispatcher, we no longer have to pass <strong class="source-inline">Dispatchers.IO</strong> to the launch<a id="_idIndexMarker338"/> block. Remove the <strong class="source-inline">Dispatchers.IO</strong> dispatcher from the coroutine <strong class="source-inline">launch</strong> block:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    <strong class="bold">viewModelScope.launch(errorHandler) {</strong></p><p class="source-code">        val restaurants = getRemoteRestaurants()</p><p class="source-code">        withContext(Dispatchers.Main) {</p><p class="source-code">            state.value = restaurants.</p><p class="source-code">                restoreSelections()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>By default, the launch block will inherit the <strong class="source-inline">CoroutineContext</strong> (and so its defined <strong class="source-inline">Dispatcher</strong> object) from its parent coroutine. In our case, there is no parent coroutine, so the <strong class="source-inline">launch</strong> block will launch a coroutine on the <strong class="source-inline">Dispatchers.Main</strong> thread which was predefined by the <strong class="source-inline">viewModelScope</strong> custom scope.</p>
			<ol>
				<li value="4">Since the coroutine will now run on the <strong class="source-inline">Dispatchers.Main</strong> thread, we can remove the redundant <strong class="source-inline">withContext(Dispatchers.Main)</strong> block from within the <strong class="source-inline">getRestaurants()</strong> method. The <strong class="source-inline">getRestaurants()</strong> method should now look like this:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        val restaurants = getRemoteRestaurants()</p><p class="source-code">        state.value = restaurants.restoreSelections()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, the <strong class="source-inline">getRestaurants()</strong> method where we launched the coroutine is much easier to read and understand. Our suspending function call, for instance, <strong class="source-inline">getRemoteRestaurants()</strong>, is called inside this coroutine on the <strong class="source-inline">Dispatchers.Main</strong> dispatcher. However, at the same time, our suspending function has its<a id="_idIndexMarker339"/> own <a id="_idTextAnchor144"/><strong class="source-inline">withContext()</strong> block with its corresponding <strong class="source-inline">Dispatcher</strong> object set:</p>
			<p class="source-code">private suspend fun getRemoteRestaurants()</p>
			<p class="source-code">        : List&lt;Restaurant&gt; {</p>
			<p class="source-code">    return withContext(Dispatchers.IO) {</p>
			<p class="source-code">        restInterface.getRestaurants()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This practice allows us to call suspending functions from coroutines with any given <strong class="source-inline">Dispatcher</strong> object, simply because the suspending functions have their own <strong class="source-inline">CoroutineContext</strong> object set with their appropriate <strong class="source-inline">Dispatcher</strong> objects.</p>
			<p>At runtime, even though the coroutines are launched on their initial <strong class="source-inline">Dispatcher</strong> object, when our suspending functions are called, the <strong class="source-inline">Dispatcher</strong> object is briefly overridden for every suspending function that is internally wrapped with a <strong class="source-inline">withContext</strong> block.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For Retrofit interface calls such as <strong class="source-inline">restInterface.getRestaurants()</strong>, we can skip wrapping them in <strong class="source-inline">withContext()</strong> blocks because Retrofit already does this behind the scenes and sets the <strong class="source-inline">Dispatchers.IO</strong> dispatcher for all suspending methods from within its interface.</p>
			<p>Finally, the<a id="_idIndexMarker340"/> application should behave the same. However, in terms of good practices, we made sure that the correct <strong class="source-inline">Dispatcher</strong> object is set for every suspending function out of the box, and without us having to manually set it in every coroutine.</p>
			<p>Now that we improved the way dispatchers are set within our suspending function and coroutine, it's time to wrap this chapter up.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor145"/>Summary</h1>
			<p>In this chapter, we learned how coroutines allow us to write async code in a much clearer and more concise way.</p>
			<p>We understood what coroutines are, how they work, and why they are needed in the first place. We unveiled the core elements of coroutines: from <strong class="source-inline">suspend</strong> functions to <strong class="source-inline">CoroutineScope</strong> objects, to <strong class="source-inline">CoroutineContext</strong> objects and <strong class="source-inline">Dispatcher</strong> objects.</p>
			<p>Then, we replaced the callbacks with coroutines in our Restaurants application and noticed how the code is much easier to understand and less nested. Additionally, we learned how to perform error handling with coroutines and integrated some of the best practices when working with coroutines.</p>
			<p>In the next chapter, we will add another Compose-based screen to our Restaurants application and learn how to navigate between screens in Compose with yet another Jetpack library.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor146"/>Further reading</h1>
			<p>While canceling coroutines might seem simple with the help of the associated <strong class="source-inline">Job</strong> objects, it's important to note that any cancelation must be cooperative. More specifically, when coroutines perform suspending work based on conditional statements, you must ensure the coroutine is cooperative with respect to canceling. </p>
			<p>You can read about this topic, in more detail, in the official documentation: <a href="https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative">https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative</a>.</p>
		</div>
	</body></html>