<html><head></head><body>
		<div><h1 id="_idParaDest-65"><em class="italic"><a id="_idTextAnchor115"/>Chapter 4</em>: Handling Async Operations with Coroutines</h1>
			<p>In this chapter, we're focusing on another library that, although is not in the Jetpack library suite, is essential for writing solid applications: <strong class="bold">Kotlin coroutines</strong>.</p>
			<p>Coroutines represent a more convenient way of handling async work and concurrency jobs on Android.</p>
			<p>In this chapter, we will study how we can replace callbacks with coroutines in our Restaurants application. In the first section, <em class="italic">Introducing Kotlin coroutines</em>, we will gain a better understanding of what coroutines are, how they work, and why we need them in our apps.</p>
			<p>In the next section, <em class="italic">Exploring the basic elements of coroutines</em>, we will explore the core elements of coroutines, and we will understand how to use them to handle asynchronous work more concisely.</p>
			<p>Finally, in the <em class="italic">Using coroutines for async work</em> section, we will implement coroutines in our Restaurants application and let them handle the network requests. Additionally, we will add error handling and integrate some of the best practices when working with coroutines in Android apps.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing Kotlin coroutines</li>
				<li>Exploring the basic elements of coroutines</li>
				<li>Using coroutines for async work</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor116"/>Technical requirements</h1>
			<p>Building Compose-based Android projects with coroutines usually requires your day-to-day tools. However, to follow along with this chapter smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10, or a newer plugin, installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_03</code> directory of the repository and importing the Android project entitled <code>chapter_3_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_04</code> directory:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app</a>.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor117"/>Introducing Kotlin coroutines</h1>
			<p><strong class="bold">Coroutines</strong> are<a id="_idIndexMarker281"/> part of the Kotlin API. They introduce a new and easier way of handling async work and concurrency jobs.</p>
			<p>Often, with Android, we need to run or execute different tasks behind the scenes. In the meantime, we don't want to block the main thread of the application and get an unresponsive UI.</p>
			<p>To mitigate this issue, coroutines<a id="_idIndexMarker282"/> allow you to execute async work much easier while providing main-thread safety for your Android apps. You can use the Coroutines API by launching one <strong class="bold">coroutine</strong>, or more, depending on your needs.</p>
			<p>In this section, we will cover three essential questions about the Coroutines API that derive from what we stated earlier:</p>
			<ul>
				<li>What is a coroutine?</li>
				<li>What are the features and advantages of coroutines?</li>
				<li>How do coroutines work?</li>
			</ul>
			<p>Let's jump in!</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor118"/>What is a coroutine?</h2>
			<p>A <a id="_idIndexMarker283"/>coroutine is a concurrency design pattern for async work. A <em class="italic">coroutine represents an instance of suspendable computation</em>.</p>
			<p>In other words, coroutines are sequences or blocks of code that represent a computational task that can be suspended. We call them <strong class="bold">suspendable</strong> because coroutines can be suspended and resumed mid-execution, which makes them efficient for concurrent tasks.</p>
			<p>When comparing coroutines with threads, we can say the following:</p>
			<ul>
				<li>A <a id="_idIndexMarker284"/>coroutine is a lightweight version of a thread but not a thread. Coroutines <a id="_idIndexMarker285"/>are light because creating coroutines doesn't allocate new threads – typically, coroutines use predefined thread pools.</li>
				<li>Like threads, coroutines can run in parallel, wait for each other, and communicate.</li>
				<li>Unlike threads, coroutines are very cheap: we can create thousands of them and pay very few penalties in terms of performance.</li>
			</ul>
			<p>Next, let's understand the purpose behind coroutines a bit better.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor119"/>The features and advantages of coroutines</h2>
			<p>By now, we know that on Android, coroutines can help us to move long-running async work from the main thread into a separate thread. Essentially, coroutines have two primary possible usages:</p>
			<ul>
				<li>For handling async work</li>
				<li>For handling<a id="_idIndexMarker286"/> multithreading</li>
			</ul>
			<p>In this chapter, we will only cover how to correctly handle async work with coroutines in Android apps.</p>
			<p>However, before we try to understand how to do that with coroutines, let's explore the advantages that coroutines bring over other alternatives that we've used in the past: <code>AsyncTask</code> classes, callbacks, and reactive frameworks. A coroutine is described as the following:</p>
			<ul>
				<li><strong class="bold">Lightweight</strong>: We can<a id="_idIndexMarker287"/> launch many coroutines on a single thread. Coroutines support execution suspension on the thread as opposed to blocking it, resulting in less memory overhead. Additionally, a coroutine is not always bound to a specific thread – it might start its execution on one thread and yield the result on a different one.</li>
				<li><strong class="bold">Easily cancelable</strong>: When canceling the parent coroutine, any children coroutines that were launched within the same scope will be canceled. If you have launched multiple coroutines that run operations concurrently, cancelation is straightforward and applies to the entire affected coroutine hierarchy; therefore, this eliminates any potential memory leaks.</li>
				<li><code>Activity</code>, <code>Fragment</code>, <code>ViewModel</code>, and more. This means that you can launch coroutines safely from these components, as they will be canceled automatically when different lifecycle events occur, so you don't have to worry about memory leaks.<p class="callout-heading">Note</p><p class="callout">We have mentioned the word <em class="italic">scope</em> several times, and I promise that we will explain it later. Until then, you can think of the coroutine scope as an entity that controls the lifetime of launched coroutines.</p></li>
			</ul>
			<p>Now we have an idea of the features of coroutines. Yet, to better understand their purpose, first, we need to understand why we should offload async work from the main thread to a separate worker thread.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor120"/>How do coroutines work?</h2>
			<p>In Android<a id="_idIndexMarker288"/> runtime, the main thread is responsible for two things:</p>
			<ul>
				<li>Drawing the UI of the application on the screen</li>
				<li>Updating the UI upon user interactions</li>
			</ul>
			<p>Simplistically viewed, the main thread calls a drawing method on the screen canvas. This method might be familiar to you as the <code>onDraw()</code> method, and we can assume that for your device to render UI at 60 frames per second, the Android Runtime will call this method roughly every 16 milliseconds.</p>
			<p>If, for some reason, we execute heavy async work on the main thread, the application might freeze or stutter. This happens because the main thread was busy serving our async work; therefore, it missed several <code>onDraw()</code> calls that could have updated the UI and prevented the freezing effect.</p>
			<p>Let's say that we need to make a network request to our server. This operation might take time because we must wait for a response, which depends on the web API's speed and the user's connectivity. Let's imagine that such a method is named <code>getNetworkResponse()</code> and we are calling it from the main thread: </p>
			<div><div><img src="img/B17788_04_1.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Blocking the main thread with async work</p>
			<p>From the time it launched the network request, the main thread kept waiting for a response and couldn't do anything in the meantime. We can see that several <code>onDraw()</code> calls were missed because the main thread was busy executing our <code>getNetworkResponse()</code> method call and waiting for a result.</p>
			<p>To mitigate this issue, we've <a id="_idIndexMarker289"/>used many mechanisms in the past. Yet, coroutines are much easier to use and work perfectly with the Android ecosystem. So, it's time to see how they can enable us to execute async work:</p>
			<div><div><img src="img/B17788_04_2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Executing async work on a different thread by using a coroutine</p>
			<p>With coroutines, we can offload any nasty blocking calls – such as the <code>getNetworkResponse()</code> method call – from the main thread onto a coroutine.</p>
			<p>The coroutine works on a separate thread and is in charge of executing the network request and waiting for the response. This way, the main thread is not blocked, and no <code>onDraw()</code> calls are missed; therefore, we avoid getting any freezing screen effects.</p>
			<p>Now that we have a basic understanding of how coroutines work, it's time to explore the components that coroutines are based on.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor121"/>Exploring the basic elements of coroutines</h1>
			<p>A very simplistic<a id="_idIndexMarker290"/> approach for getting async work done with coroutines could be expressed as follows: first, define the suspended functions and then create coroutines that execute the suspended functions.</p>
			<p>Yet, we're not only unsure what suspending functions look like, but we also don't know how to allow coroutines to perform asynchronous work for us.</p>
			<p>Let's take things, step by step, and start with the two essential actions that we need to execute async work with coroutines:</p>
			<ul>
				<li>Creating suspending functions</li>
				<li>Launching coroutines</li>
			</ul>
			<p>All of these terms make little sense now, so let's address this, starting with suspending functions!</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor122"/>Creating suspending functions</h2>
			<p>The first thing that we need in order to work with coroutines is to define a suspending function where the blocking task resides.</p>
			<p>A <strong class="bold">suspending</strong> function<a id="_idIndexMarker291"/> is a special function that can be paused (suspended) and<a id="_idIndexMarker292"/> resumed at some later point in time. This allows us to execute long-running jobs while the function is suspended and, finally, resume it when the work is complete.</p>
			<p>Our regular function calls within our code are mostly executed synchronously on the main thread. Essentially, suspending functions allow us to execute jobs asynchronously in the background without blocking the thread where those functions are called from.</p>
			<p>Let's say that we need to save some details about a user to a local database. This operation takes time, so we need to display an animation until it finishes:</p>
			<pre>fun saveDetails(user: User) {
    startAnimation()
    <strong class="bold">database.storeUser(user)</strong>
    stopAnimation()
}</pre>
			<p>If this operation is called on the main thread, the animation will freeze for a few hundreds of milliseconds while the user's details are saved.</p>
			<p>Take a closer look at the code presented earlier and ask yourself the following: <em class="italic">which method call should be suspendable?</em></p>
			<p>Since the <code>storeUser()</code> method takes a while to finish, we want this method to be a suspending function because this function should be paused until the user's details are saved and then resumed when the job is done. This ensures that we do not block the main thread or<a id="_idIndexMarker293"/> freeze the animation.</p>
			<p>Yet, how can we make the <code>storeUser()</code> method a suspending function?</p>
			<p>A suspending function is a regular function that is marked with the <code>suspend</code> keyword:</p>
			<pre><strong class="bold">suspend</strong> fun storeUser(user: User) {
    // blocking action
}</pre>
			<p>We know that the <code>storeUser()</code> method saves details to a database, which takes a good while. So, in order to prevent this job from blocking the UI, we've marked the method with an additional <code>suspend</code> keyword.</p>
			<p>However, if we mark a method with the <code>suspend</code> keyword, trying to call it in our code results in a compilation error:</p>
			<div><div><img src="img/B17788_04_3.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Calling suspending functions from regular functions results in a compilation error</p>
			<p>Suspending functions can only be called from inside a coroutine or from inside another suspending function. Instead of calling our <code>storeUser()</code> suspending method from a regular method, let's create a coroutine and call it from there.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor123"/>Launching coroutines</h2>
			<p>To execute a<a id="_idIndexMarker294"/> suspend function, first, we need to create and launch a coroutine. To do that, we need to call a coroutine builder on a coroutine scope:</p>
			<pre>fun saveDetails(user: User) {
    <strong class="bold">GlobalScope.launch(Dispatchers.IO) {</strong>
<strong class="bold">        </strong>startAnimation()
        database.storeUser(user)
        stopAnimation()
    }
}</pre>
			<p>We have just launched our first coroutine and called our suspending function inside it! Let's break down what just happened:</p>
			<ul>
				<li>We've used a <code>GlobalScope</code> coroutine scope, which manages the coroutines that are launched within it.</li>
				<li>In the coroutine scope, we called the <code>launch()</code> coroutine builder to create a coroutine.</li>
				<li>Then, we passed the <code>Dispatchers.IO</code> dispatcher to the coroutine builder. In this case, we want to save the user details inside the database on a thread reserved for I/O operations.</li>
				<li>Inside the block that the <code>launch()</code> coroutine builder has provided us with, we call our <code>storeUser()</code> suspending function.</li>
			</ul>
			<p>Now we have successfully moved our blocking work away from the main thread to a worker thread. Therefore, we have made sure that the UI will not be blocked, and the animation will run smoothly.</p>
			<p>However, now that we have implemented suspending work in our <code>saveDetails()</code> method, you might be wondering what the order of function calls within this method will be.</p>
			<p>To better <a id="_idIndexMarker295"/>understand how the regular synchronous world blends with the suspending world, let's add some logs to our previous code snippet:</p>
			<pre>fun saveDetails(user: User) {
    Log.d("TAG", "Preparing to launch coroutine")
    GlobalScope.launch(Dispatchers.IO) {
        startAnimation()
        Log.d("TAG", "Starting to do async work")
        database.storeUser(user)
        Log.d("TAG", "Finished async work")
        stopAnimation()
    }
    Log.d("TAG", "Continuing program <a id="_idTextAnchor124"/>execution")
}</pre>
			<p>Remember, the only<a id="_idIndexMarker296"/> suspending function in this block of code that will take some time to compute is <code>database.storeUser()</code>. Now, let's imagine that we have run the preceding piece of code.</p>
			<p class="callout-heading">Exercise</p>
			<p class="callout">Before checking the following output, try to think about the order of the logs yourself. What do you expect the order of function calls to be?</p>
			<p>Let's see the output:</p>
			<div><div><img src="img/B17788_04_4.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – The output order of regular and suspending functions</p>
			<p>The order of the function calls is a bit out of order, but it is definitely correct. Let's see what happened:</p>
			<ol>
				<li>First, the log function with the <code>Preparing to launch coroutine</code> message was called. This method call was done on the main (UI) thread.</li>
				<li>Even though up next, we launched the coroutine, we can see that the second log function called was the last one in our code: <code>Continuing program execution</code>.</li>
			</ol>
			<p>This is because the coroutine is a bridge to the suspending world, so every function call from the coroutine will be run on a different thread from the main thread. More precisely, the operation of switching from the main thread to <code>Dispatchers.IO</code> will take some time. This means that all of these methods inside the coroutine will be executed after the method call outside of the coroutine.</p>
			<ol>
				<li value="3">The next log<a id="_idIndexMarker297"/> function call is with the <code>Starting to do async work</code> message. This method is called inside the coroutine on a thread reserved for I/O operations. This log marks the start of execution for all suspending work.</li>
				<li>Finally, after all of the blocking work from the <code>database.storeUser()</code> suspending function has been finished, the last log function call with the <code>Finished async work</code> message is called. This log marks the end of the coroutine execution.</li>
			</ol>
			<p>Now that we've understood how the regular world blends with the suspended world in terms of function calls, there are still many terms and concepts that have been thrown at you. Mainly, you might be wondering the following:</p>
			<ul>
				<li>What is a coroutine scope?</li>
				<li>What's a coroutine dispatcher?</li>
				<li>What's a coroutine builder?</li>
			</ul>
			<p>Let's clarify these concepts, starting with coroutine scopes.</p>
			<h3>Coroutine scopes</h3>
			<p>Essentially, coroutines <a id="_idIndexMarker298"/>run in <strong class="bold">coroutine scopes</strong>. To start a coroutine, first, you need a coroutine scope because it tracks all of the coroutines launched inside it and has the ability to cancel them. This way, you can control how long the coroutines should live and when they should be canceled.</p>
			<p>A coroutine scope contains a <code>CoroutineContext</code> object, which defines the context in which the coroutine runs. In the previous example, we used a predefined scope, <code>GlobalScope</code>, but you can also define a custom scope by constructing a <code>CoroutineContext</code> object and passing it to a <code>CoroutineScope()</code> function, as follows:</p>
			<pre>val job = Job()
val myScope = <strong class="bold">CoroutineScope(context = job + Dispatchers.IO)</strong></pre>
			<p>The <code>CoroutineScope()</code> function expects a <code>CoroutineContext</code> object passed to its <code>context</code> parameter and knows how to build one out of the box. It does this by receiving elements with a special <code>plus</code> operator and then constructing the context behind the scenes.</p>
			<p>Most of the time, the two most important elements to construct a <code>CoroutineContext</code> object are the ones that we just passed:</p>
			<ul>
				<li>A <code>Job</code> object: This represents a cancelable component that controls the lifecycle of a coroutine launched in a specific scope. When a job is canceled, the job will cancel the coroutine it manages. For example, if we have defined a <code>job</code> object and a custom <code>myScope</code> object inside an <code>Activity</code> class, a good place to cancel the coroutine would be in the <code>onDestroy()</code> callback by calling the <code>cancel()</code> method on the <code>job</code> object:<pre>override fun onDestroy() {
    super.onDestroy()
    <strong class="bold">job.cancel()</strong>
}</pre></li>
			</ul>
			<p>By doing this, we've ensured that our async work done within our coroutine, which uses the <code>myScope</code> scope, will stop when the activity has been destroyed and will not cause any memory leaks.</p>
			<ul>
				<li>A <code>Dispatcher</code> object: Marking a method as suspended provides no details about the thread pool it should run on. So, by passing a <code>Dispatcher</code> object to the <code>CoroutineScope</code> constructor, we can make sure that all suspended functions called in the coroutine that use this scope will default to the specified <code>Dispatcher</code> object. In our example, all coroutines launched in <code>myScope</code> will run their work, by default, in the <code>Dispatchers.IO</code> thread pool and will not block the UI.</li>
			</ul>
			<p>Note that the <code>CoroutineContext</code> object can also contain an exception handler object, which we will define later on.</p>
			<p>Apart from the custom scopes that you can define, as we did earlier, you can use predefined coroutine scopes that are bound to a certain lifecycle component. In such cases, you will no longer need to define a scope with a job or to manually cancel the coroutine scope:</p>
			<ul>
				<li><code>GlobalScope</code>: This allows the coroutines to live as long as the application is alive. In the previous example, we used this scope for simplicity, but <code>GlobalScope</code> should<a id="_idIndexMarker299"/> be avoided since the work launched within this coroutine scope is only canceled when the application has been destroyed. Using this scope in a component that has a narrower lifecycle than the application – such as an <code>Activity</code> component, might allow the coroutine to outlive that component's lifecycle and produce memory leaks.</li>
				<li><code>lifecycleScope</code>: This<a id="_idIndexMarker300"/> scopes coroutines to the lifecycle of a <code>LifecycleOwner</code> instance such as an <code>Activity</code> component or a <code>Fragment</code> component. We can use the <code>lifecycleScope</code> scope defined in the Jetpack KTX extensions package:<pre>class UserFragment : Fragment() {
    ...
    fun saveDetails(user: User) {
        <strong class="bold">lifecycleScope</strong>.launch(Dispatchers.IO) {
            startAnimation()
            database.storeUser(user)
            stopAnimation()
        }
    }
}</pre></li>
			</ul>
			<p>By launching<a id="_idIndexMarker301"/> coroutines within this context, we ensure that if the <code>Fragment</code> component gets destroyed, the coroutine scope will automatically be canceled; therefore, this will also cancel our coroutine.</p>
			<ul>
				<li><code>viewModelScope</code>: To scope our coroutines to live as long as the <code>ViewModel</code> component<a id="_idIndexMarker302"/> does, we can use the predefined <code>viewModelScope</code> scope:<pre>class UserViewModel: ViewModel() {
    fun saveDetails(user: User) {
        // do some work
        <strong class="bold">viewModelScope</strong>.launch(Dispatchers.IO) {
            database.storeUser(user)
        }
        // do some other work
    }
}</pre></li>
			</ul>
			<p>By launching coroutines within this context, we ensure that if the <code>ViewModel</code> component gets cleared, the coroutine scope will cancel its work – in other words, it will automatically <a id="_idIndexMarker303"/>cancel our coroutine.</p>
			<ul>
				<li><code>rememberCoroutineScope</code>: To scope a coroutine to the composition cycle of a composable function, we can <a id="_idIndexMarker304"/>use the predefined <code>rememberCoroutineScope</code> scope:<pre>@Composable
fun UserComposable() {
    <strong class="bold">val scope = rememberCoroutineScope()</strong>
    LaunchedEffect(key1 = "save_user") {
        <strong class="bold">scope</strong>.launch(Dispatchers.IO) { 
            viewModel.saveUse<a id="_idTextAnchor125"/>r()
        }
    }
}</pre></li>
			</ul>
			<p>Therefore, a coroutine's lifecycle is bound to the composition cycle of <code>UserComposable</code>. This means that when <code>UserComposable</code> leaves the composition, the scope will be automatically canceled, thereby preventing the coroutine from outliving the composition lifecycle of its parent composable.</p>
			<p>Since we want the coroutine to be launched only once upon composition and not at every recomposition, we wrapped the coroutine with a <code>LaunchedEffect</code> composable.</p>
			<p>Now that we covered what coroutine scopes are and how they allow us to control the lifetime of coroutines, it's time to better understand what dispatchers are.</p>
			<h3>Dispatchers</h3>
			<p>A <strong class="bold">CoroutineDispatcher</strong> object<a id="_idIndexMarker305"/> allows us to configure what thread pool our work should be executed on. The point of coroutines is to help us move blocking work away from the main thread. So, somehow, we need to instruct the coroutines what threads to use for the work that we pass to them.</p>
			<p>To do that, we need to configure the <code>CoroutineContext</code> object of the coroutines to set a specific dispatcher. In fact, when we covered coroutine scopes,<a id="_idTextAnchor126"/> we've explained how <code>CoroutineContext</code> is defined by a job and a dispatcher.</p>
			<p>When creating custom scopes, we can specify the default dispatcher right when we instantiate the scope, just as we did previously:</p>
			<pre>val myScope = CoroutineScope(context = job + <strong class="bold">Dispatchers.IO</strong>)</pre>
			<p>In this case, the default dispatcher of <code>myScope</code> is <code>Dispatchers.IO</code>. This means that whatever suspending work we pass to the coroutines that are launched with <code>myScope</code>, the work will be moved to a special thread pool for I/O background work.</p>
			<p>In the case of predefined coroutine scopes, such as with <code>lifecycleScope</code>, <code>viewModelScope</code>, or <code>rememberCoroutineScope</code>, we can specify the desired default dispatcher when starting our coroutine:</p>
			<pre>scope.launch(<strong class="bold">Dispatchers.IO</strong>) {
    viewModel.saveUser()
}</pre>
			<p>We start coroutines <a id="_idIndexMarker306"/>with coroutine builders such as <code>launch</code> or <code>async</code>, which we will cover in the next section. Until then, we need to understand that when launching a coroutine, we can also modify the <code>CoroutineContext</code> object of the coroutine by specifying a <code>CoroutineDispatcher</code> object.</p>
			<p>Now we've used <code>Dispatchers.IO</code> as a dispatcher throughout our examples. But are there any other dispatchers that are of use to us?</p>
			<p><code>Dispatchers.IO</code> is a dispatcher offered by the Coroutines API, but in addition to this, coroutines offer other dispatchers too. Let's list the most notable dispatchers as follows:</p>
			<ul>
				<li><code>Dispatchers.Main</code>: This <a id="_idIndexMarker307"/>dispatches work to the main thread on Android. It is ideal for light work (which doesn't block the UI) or actual UI function calls and interactions.</li>
				<li><code>Dispatchers.IO</code>: This <a id="_idIndexMarker308"/>dispatches blocking work to a background thread pool that specializes in handling disk-heavy or network-heavy operations. This dispatcher should be specified for suspending work on local databases or executing network requests.</li>
				<li><code>Dispatchers.Default</code>: This<a id="_idIndexMarker309"/> dispatches blocking work to a background thread pool that specializes in CPU-intensive tasks, such as sorting long lists, parsing JSON, and more.</li>
			</ul>
			<p>In the previous examples, we<a id="_idIndexMarker310"/> set a specific dispatcher of <code>Dispatchers.IO</code> for the <code>CoroutineContext</code> object of the coroutines launched, ensuring that suspended work will be dispatched by this specific dispatcher.</p>
			<p>But we've made a critical mistake! Let's take a look at the code again:</p>
			<pre>class UserFragment : Fragment() {
    ...
    fun saveDetails(user: User) {
        lifecycleScope.launch(Dispatchers.IO) {
            startAnimation()
            database.storeUser(user)
            stopAnimation()
        }
    }
}</pre>
			<p>The main issue with this code is that the <code>startAnimation()</code> and <code>stopAnimation()</code> functions are probably not even suspending functions, as they interact with the UI.</p>
			<p>We wanted to run our <code>database.storeUser()</code> blocking work on a background thread, so we specified the <code>Dispatchers.IO</code> dispatcher to the <code>CoroutineContext</code> object. But this means that all the rest of the code in the coroutine block (that is, the <code>startAnimation()</code> and <code>stopAnimation()</code> function calls) will be dispatched to a thread pool intended for background work instead of being dispatched to the main thread.</p>
			<p>To have more fine-grained control regarding what threads our functions are being dispatched to, coroutines allow us to control the dispatcher by using the <code>withContext</code> block, which creates a block of code that can run on a different dispatcher.</p>
			<p>Since <code>startAnimation()</code> and <code>stopAnimation()</code> have to work on the main thread, let's refactor our example.</p>
			<p>Let's launch our <a id="_idIndexMarker311"/>coroutine with the default dispatcher of <code>Dispatchers.Main</code>, and then wrap our work, which has to be run on a background thread (the <code>database.storeUser(user)</code> suspending function), with a <code>withContext</code> block:</p>
			<pre>fun saveDetails(user: User) {
    lifecycleScope.launch(<strong class="bold">Dispatchers.Main</strong>) {
        startAnimation()
<strong class="bold">        withContext(Dispatchers.IO) {</strong>
            database.storeUser(user)
    <strong class="bold">    }</strong>
        stopAnimation()
    }
}</pre>
			<p>The <code>withContext</code> function allows us to define a more granular <code>CoroutineContext</code> object for the block that it exposes. In our case, we had to pass the <code>Dispatchers.IO</code> dispatcher to make sure our blocking work with the database will run on the background thread instead of being dispatched to the main thread.</p>
			<p>In other words, our coroutine will have all its work dispatched to the <code>Dispatchers.Main</code> dispatcher, unless <a id="_idIndexMarker312"/>you define another more granul<a id="_idTextAnchor127"/>ar context that has its own <code>CoroutineDispatcher</code> set.</p>
			<p>Now we've covered how to use dispatchers and how to ensure more granular control over how our work is dispatched to different threads. However, we haven't covered what the <code>launch { }</code> block means. Let's do that next.</p>
			<h3>Coroutine builders</h3>
			<p><code>launch</code>) are extension functions on <code>CoroutineScope</code> and<a id="_idIndexMarker313"/> allow us to create and start coroutines. Essentially, they are a bridge between the normal synchronous world with regular functions and the suspending world with suspending functions.</p>
			<p>Since we can't call suspending functions inside regular functions, a coroutine builder method executed on the <code>CoroutineScope</code> object creates a scoped coroutine that provides us with a block of code where we can call our suspending functions. Without scopes, we cannot create coroutines – which is good since this practice helps to prevent memory leaks.</p>
			<p>We can use three builder functions to create coroutines:</p>
			<ul>
				<li><code>launch</code>: This starts a coroutine that runs concurrently with the rest of the code. Coroutines started<a id="_idIndexMarker314"/> with <code>launch</code> won't return the result to the caller – instead, all of the suspending functions will run sequentially inside the block that <code>launch</code> exposes. It's our job to get the result from the suspending functions and then interact with that result:<pre>fun getUser() {
    lifecycleScope.<strong class="bold">launch</strong>(Dispatchers.IO) {
        val user = database.getUser()
      <a id="_idTextAnchor128"/>  // show details to UI
    }
}</pre></li>
			</ul>
			<p>Most of the time, if you don't need concurrent work, <code>launch</code> is the go-to option for starting coroutines since it allows you to run your suspending work inside the block of code provided and doesn't care about anything else.</p>
			<p>If no dispatcher is specified in the coroutine<a id="_idIndexMarker315"/> builder, the dispatcher that is going to be used is the dispatcher provided by default by the <code>CoroutineScope</code> used to start the coroutine. In our case, if we wouldn't have specified a dispatcher, our coroutine launched with the <code>launch</code> coroutine builder will have used the <code>Dispatchers.Main</code> dispatcher defined by default by <code>lifecycleScope</code>.</p>
			<p>Apart from <code>lifecycleScope</code>, <code>viewModelScope</code> also provides the same predefined dispatcher of <code>Dispatchers.Main</code>. <code>GlobalScope</code> on the other hand, defaults to <code>Dispatchers.Default</code> if no dispatcher was provided to the coroutine builder.</p>
			<ul>
				<li><code>async</code>: This starts a new <a id="_idIndexMarker316"/>coroutine, and it allows you to return the result as a <code>Deferred&lt;T&gt;</code> object, where <code>T</code> is your expected data type. The deferred object is a promise that your result, <code>T</code>, will be returned in the future. To start the coroutine and get a result, you need to call the suspending function, <code>await</code>, which blocks the calling thread:<pre>lifecycleScope.launch(Dispatchers.IO) {
    val deferredAudio: Deferred&lt;Audio&gt; =
        <strong class="bold">async</strong> { convertTextToSpeech(title) }
    val titleAudio = deferredAudio<strong class="bold">.aw<a id="_idTextAnchor129"/>ait()</strong>
    playSound(titleAudio)
}</pre></li>
			</ul>
			<p>We can't use <code>async</code> in a normal function as it has to call the <code>await</code> suspending function to get the result. To fix that, first, we've created a parent coroutine with <code>launch</code> and started the child coroutine with <code>async</code> inside it. This means the child coroutine that was started with <code>async</code> inherits its <code>CoroutineContext</code> object from the parent coroutine that was started with <code>launch</code>.</p>
			<p>With <code>async</code>, we <a id="_idIndexMarker317"/>can get the results of the concurrent work in one place. Where the <code>async</code> coroutine builder shines (and where it's recommended to be used) is in tasks with parallel execution where results are required.</p>
			<p>Let's say that we need to simultaneously convert two pieces of text into speech and then play both results at the same time:</p>
			<pre>lifecycleScope.launch(Dispatchers.IO) {
    val deferredTitleAudio: Deferred&lt;Audio&gt; =
        async { convertTextToSpeech(title) }
    val deferredSubtitleAudio: Deferred&lt;Audio&gt; =
        async { convertTextToSpeech(subtitle) }
    playSounds(
        deferredTitleAudio.await(),
        deferredSubtitleAudio.await()
    )
}</pre>
			<p>In this particular example, both the resulting <code>deferredTitleAudio</code> and <code>deferredSubtitleAudio</code> tasks <a id="_idIndexMarker318"/>will run in parallel.</p>
			<p>Since our Restaurants application hasn't featured concurrent work until now, we won't go any deeper in terms of concurrency topics.</p>
			<ul>
				<li><code>runBlocking</code>: This starts a<a id="_idIndexMarker319"/> coroutine that blocks the current thread on which<a id="_idIndexMarker320"/> it is invoked until the coroutine has been completed. This builder should be avoided for async work within our app since creating threads and blocking them is less efficient. However, this coroutine builder can be used for unit tests.</li>
			</ul>
			<p>Now that we have covered the basics of coroutines, it's high time we implement coroutines in our Restaurants application!</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor130"/>Using coroutines for async work</h1>
			<p>The first thing <a id="_idIndexMarker321"/>that we have to do is identify the async/heavy work that we have done in our Restaurants application.</p>
			<p>Without looking at the code, we know that our app retrieves a list of restaurants from the server. It does that by initiating a network request with Retrofit and then waits for a response. This action qualifies as an async job because we don't want to block the main (UI) thread while the app waits for the network response to arrive.</p>
			<p>If we check out the <code>RestaurantsViewModel</code> class, we can identify that the <code>getRestaurants()</code> method is the one place in our application where heavy blocking work is happening:</p>
			<pre>private fun getRestaurants() {
    restaurantsCall = restInterface.getRestaurants()
    restaurantsCall.enqueue(object : Callback
        &lt;List&lt;Restaurant&gt;&gt; {
            override fun onResponse(...) {
                response.body()?.let { restaurants -&gt; ... }
            }
            override fun onFailure(...) {
                t.printStackTrace()
            }
        })
}</pre>
			<p>When we implemented the network request, we used Retrofit's <code>enqueue()</code> method to which we passed a <code>Callback</code> object where we could wait for the result without blocking the main thread.</p>
			<p>To simplify the way <a id="_idIndexMarker322"/>we handle this async operation of getting the restaurants from the server, we will implement coroutines. This will allow us to ditch callbacks and make our code more concise.</p>
			<p>In this section, we will cover two main steps:</p>
			<ul>
				<li>Implementing coroutines instead of callbacks</li>
				<li>Improving the way our app works with coroutines</li>
			</ul>
			<p>Let's get started!</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor131"/>Implementing coroutines instead of callbacks</h2>
			<p>To handle async <a id="_idIndexMarker323"/>work with coroutines, we need to do the following:</p>
			<ul>
				<li>Define our async work in a suspending function.</li>
				<li>Next, create a coroutine and call the suspending function inside it to obtain the result asynchronously.</li>
			</ul>
			<p>Enough with the theory, it's time to code! Perform the following steps:</p>
			<ol>
				<li value="1">Inside the <code>RestaurantsApiService</code> interface, add the <code>suspend</code> keyword to the <code>getRestaurants()</code> method and replace the <code>Call&lt;List&lt;Restaurant&gt;&gt;</code> return type of the method with <code>List&lt;Restaurant&gt;</code>:<pre>interface RestaurantsApiService {
    @GET("restaurants.json")
    <strong class="bold">suspend</strong> fun getRestaurants(): <strong class="bold">List&lt;Restaurant&gt;</strong>
}</pre></li>
			</ol>
			<p>Retrofit supports coroutines out of the box for network requests. This means that we can mark any method in our Retrofit interface with the <code>suspend</code> keyword; therefore, we can transform the network requests to suspending work that isn't blocking the main thread of the application.</p>
			<p>Because of this, the <code>Call&lt;T&gt;</code> return type is redundant. We no longer need Retrofit to return a <code>Call</code> object on which we would normally enqueue a <code>Callback</code> object to listen for the response – all of this will be handled by the Coroutines API.</p>
			<ol>
				<li value="2">Since we will no longer receive a <code>Call</code> object from Retrofit, we will also not need the <code>Callback</code> object in our <code>RestaurantsViewModel</code> class. Clean up the <code>RestaurantsViewModel</code> component: <ul><li>Remove <a id="_idIndexMarker324"/>the <code>restaurantsCall: Call&lt;List&lt;Restaurant&gt;</code> member variable.</li><li>Remove the <code>restaurantsCall.cancel()</code> method call inside the <code>onCleared()</code> callback.</li><li>Remove the entire body of the <code>getRestaurants()</code> method.</li></ul></li>
				<li>Inside the <code>getRestaurants()</code> method, call the <code>restInterface.getRestaurants()</code> suspending function and store the result<a id="_idTextAnchor132"/> in a <code>restaurants</code> varia<a id="_idTextAnchor133"/>ble:<pre>private fun getRestaurants() {
    <strong class="bold">val restaurants = restInterface.getRestaurants()</strong>
}</pre></li>
			</ol>
			<p>The IDE will throw an error telling us that we cannot call the <code>restInterface.getRestaurants()</code> suspending function from the regular <code>getRestaurants()</code> function within the <code>ViewModel</code> component.</p>
			<p>To fix this, we must create a coroutine, launch it, and call the suspending function there.</p>
			<ol>
				<li value="4">Before creating a coroutine, we need to create a <code>CoroutineScope</code> object. Inside the <code>ViewModel</code> component, define a member variable of type <code>Job</code> and another of type <code>CoroutineScope</code>, just as we learned earlier:<pre>class RestaurantsViewModel(…): ViewModel() {
    private var restInterface: RestaurantsApiService
    val state = mutableStateOf(…)
    <strong class="bold">val job = Job()</strong>
    <strong class="bold">private val scope = Coro<a id="_idTextAnchor134"/>utineScope(job + </strong>
<strong class="bold">        Dispatchers.IO)</strong>
    …
}</pre></li>
			</ol>
			<p>The <code>job</code> variable <a id="_idIndexMarker325"/>is the handle that will allow us to cancel the coroutine scope, while the <code>scope</code> variable will ensure we keep track of the coroutines that are going be to be launched with it.</p>
			<p>Since the network request is a heavy blocking operation, we want its suspending work to be executed on the <code>IO</code> thread pool to avoid blocking the main thread, so we specified the <code>Dispatchers.IO</code> dispatcher for our <code>scope</code> object.</p>
			<ol>
				<li value="5">Inside the <code>onCleared()</code> callback method, call the <code>cancel()</code> method in the newly created job variable:<pre>override fun onCleared() {
    super.onCleared()
    <strong class="bold">job.cancel()</strong>
}</pre></li>
			</ol>
			<p>By calling <code>cancel()</code> on our <code>job</code> variable, we ensure that if the <code>RestaurantsViewModel</code> component is destroyed (for example, in scenarios where the user navigates to a different screen) the coroutine <code>scope</code> object will be canceled through its <code>job</code> object reference. Effectively, this will cancel any suspending work and prevent the coroutine from causing a memory leak.</p>
			<ol>
				<li value="6">Inside the <code>getRestaurants()</code> method in our <code>ViewModel</code> component, create a coroutine by calling <code>launch</code> on the previously defined <code>scope</code> object, and inside that<a id="_idIndexMarker326"/> body exposed by the coroutine add the existing code where we obtain the restaurants:<pre>private fun getRestaurants() {
    <strong class="bold">scope.launch {</strong>
        val restaurants = restIn<a id="_idTextAnchor135"/>terface.getRestaurants()
    <strong class="bold">}</strong>
}</pre></li>
			</ol>
			<p>Success! We have launched a coroutine that executes our suspending work of obtaining the restaurants from the server.</p>
			<ol>
				<li value="7">Next, add the initial code to update our <code>State</code> object with the newly received restaurants so that the Compose UI displays them:<pre>scope.launch {
    val restaur<a id="_idTextAnchor136"/>ants = restInterface.getRestaurants()
    <strong class="bold">state.value = restaurants.restoreSelections()</strong>
}</pre></li>
			</ol>
			<p>However, this approach is flawed. Can you point out why?</p>
			<p>Well, we are updating the UI on an incorrect thread. Our <code>scope</code> is defined to run the coroutine on a thread from the <code>Dispatchers.IO</code> thread pool, but updating the UI should happen on the Main thread.</p>
			<ol>
				<li value="8">Inside the <code>getRestaurants()</code> method, wrap the line of code where the Compose <code>State</code> object is updated with a <code>withContext</code> block that specifies the <code>Dispatchers.Main</code> dispatcher:<pre>scope.launch {
    val restaurants = restInterface.getRestaurants()
<strong class="bold">    withContext(Dispatchers.Main) {</strong>
<strong class="bold">        state.va<a id="_idTextAnchor137"/>lue = restaurants.restoreSelections()</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>By doing this, we<a id="_idIndexMarker327"/> ensure that while heavy work is being done on the background threads, the UI is updated from the main thread.</p>
			<p>We have now successfully implemented coroutines in our app. We have defined a scope and created a coroutine where we executed our suspending work: a network request.</p>
			<ol>
				<li value="9">You can now <strong class="bold">Run</strong> the application and notice that on the outside, the behavior of the app hasn't changed. However, behind the scenes, our async work was done with the help of coroutines in a more elegant manner than before.</li>
			</ol>
			<p>Even so, there are a few things that could be improved. Let's tackle those next.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor138"/>Improving the way our app works with coroutines</h2>
			<p>Our app uses a coroutine to<a id="_idIndexMarker328"/> move heavy work from the main thread to specialized threads.</p>
			<p>However, if we think about our particular implementation, we can find some ways to improve our coroutine-related code:</p>
			<ul>
				<li>Use predefined scopes as opposed to custom scopes.</li>
				<li>Add error handling.</li>
				<li>Make sure that <a id="_idIndexMarker329"/>every <code>suspend</code> function is safe to be called on any <code>Dispatcher</code> object.</li>
			</ul>
			<p>Let's start with the fun one: replacing our custom scope with a predefined one!</p>
			<h3>Using predefined scopes as opposed to custom scopes</h3>
			<p>In our current implementation, we've defined a custom <code>CoroutineScope</code> object that will make sure that its<a id="_idIndexMarker330"/> coroutines will live as long as the <code>RestaurantsViewModel</code> instance. To achieve this, we pass a <code>Job</code> object to our <code>CoroutineScope</code> builder and cancel it when the <code>ViewModel</code> component is destroyed: on the <code>onCleared()</code> callback method.</p>
			<p>Now, remember that coroutines are well integrated with the Jetpack libraries, and when we define scopes, we also talk about predefined scopes such as <code>lifecycleScope</code>, <code>viewModelScope</code>, and more. These scopes make sure that their coroutines live as long as the component they are bound to, for example, <code>lifecycleScope</code> is bound to a <code>Fragment</code> or <code>Activity</code> component.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whenever you are launching a coroutine inside components such as <code>Activity</code>, <code>Fragment</code>, <code>ViewModel</code>, or even composable functions, remember that instead of creating and managing your own <code>CoroutineScope</code> object, you can use the predefined ones that take care of canceling coroutines automatically. By using predefined scopes, you can better avoid memory leaks as any suspending work is cancelled when needed.</p>
			<p>In our scenario, we can simplify our code and replace our custom <code>CoroutineScope</code> object with the <code>viewModelScope</code> one. Behind the scenes, this predefined scope will take care of canceling all of the coroutines launched with it when its parent <code>ViewModel</code> instance has been cleared or destroyed.</p>
			<p>Let's do that now:</p>
			<ol>
				<li value="1">Inside the <code>getRestaurants()</code> method of the <code>RestaurantsViewModel</code> class, replace <code>scope</code> with <code>viewModelScope</code>:<pre>private fun getRestaurants() {
    <strong class="bold">viewModelScope</strong>.launch {
        val restaurants = …
        …
    }
}</pre></li>
				<li>Since we <a id="_idIndexMarker331"/>will no longer use our <code>scope</code> object, we need to make sure that our coroutine will run the suspending work in the background, just as it did with the previous scope. Pass a <code>D<a id="_idTextAnchor139"/>ispatchers.IO</code> dispatcher to the <code>launch</code> method:<pre>viewModelScope.launch<strong class="bold">(Dispatchers.IO)</strong> {
    val restaurants = restInterface.getRestaurants()
    withContext(Dispatchers.Main) {
        state.value = restaurants.restoreSelections()
    }
}</pre></li>
			</ol>
			<p>Usually, the <code>launch</code> coroutine builder inherits <code>CoroutineContext</code> from its parent coroutine. In our particular case though, if no dispatcher is specified, coroutines launched with <code>viewModelScope</code> will default to using <code>Dispatchers.Main</code>.</p>
			<p>However, we want our network request to be executed on a background thread from the specialized I/O thread pool, so we passed an initial <code>CoroutineContext</code> object with a <code>Dispatchers.IO</code> dispatcher to our <code>launch</code> call.</p>
			<ol>
				<li value="3">Remove the <code>onCleared()</code> callback method entirely from the <code>ViewModel</code> class. We will no longer need to cancel our coroutine <code>scope</code> from a <code>job</code> object because <code>viewModelScope</code> takes care of that for us. </li>
				<li>Remove the <code>job</code> and <code>scope</code> member variables from the <code>RestaurantsViewModel</code> class.</li>
				<li>You can now <strong class="bold">Run</strong> the application and again notice that on the outside, the behavior<a id="_idIndexMarker332"/> of the app hasn't changed. Our code now works the same but is greatly simplified because we used a predefined scope instead of handling everything by ourselves.</li>
			</ol>
			<p>Next, we must re-add error handling to our project. However, this time, we will do it in the context of coroutines.</p>
			<h3>Adding error handling</h3>
			<p>In the previous<a id="_idIndexMarker333"/> implementation with callbacks, we received an error callback from Retrofit. However, with coroutines, it appears that since our suspending function returns <code>List&lt;Restaurant&gt;&gt;</code>, there is no room for error.</p>
			<p>Indeed, we are not handling any error that could be thrown. For example, if you try to launch the application without internet right now, Retrofit will throw a <code>Throwable</code> object, which, in turn, will crash our app with a similar error as follows:</p>
			<pre>E/AndroidRuntime: FATAL EXCEPTION: DefaultDispatcher-worker-1</pre>
			<p>To handle errors, we can simply wrap suspending function calls in a <code>try catch</code> bl<a id="_idTextAnchor140"/>ock:</p>
			<pre>viewModelScope.launch(Dispatchers.IO) {
    <strong class="bold">try {</strong>
        val restaurants = restInterface.getRestaurants()
        // show restaurants
    <strong class="bold">} catch (e: Exception) {</strong>
        <strong class="bold">e.printStackTrace()</strong>
    <strong class="bold">}</strong>
}</pre>
			<p>The preceding approach is fine, but the code becomes less concise because of another level of nesting. Additionally, to better support a single point of error handling, coroutines allow you to pass a <code>CoroutineExceptionHandler</code> object to the context of your <code>CoroutineScope</code> object:</p>
			<div><div><img src="img/B17788_04_5.jpg" alt="Figure 4.5 – The signature of CoroutineExceptionHandler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – The signature of CoroutineExceptionHandler</p>
			<p>The <code>CoroutineExceptionHandler</code> object allows us to handle errors thrown by any coroutine launched <a id="_idIndexMarker334"/>within a <code>CoroutineScope</code> object, no matter how nested it might be. This handler gives us access to a function that exposes the <code>CoroutineContext</code> object and the <code>Throwable</code> object thrown in this particular context.</p>
			<p>Let's add such a handler to the <code>RestaurantsViewModel</code> class. Perform the following steps:</p>
			<ol>
				<li value="1">Define an <code>errorHandler</code> member variable of type <code>CoroutineExceptionHandler</code> and print the stack trace of the <code>exception: Throwable</code> parameter:<pre>clas<a id="_idTextAnchor141"/>s RestaurantsViewModel() : ViewModel() {
    ...
<strong class="bold">    private val errorHandler = </strong>
<strong class="bold">        CoroutineExceptionHandler { _, exception -&gt;</strong>
<strong class="bold">            exception.printStackTrace()</strong>
<strong class="bold">    }</strong>
    ...
}</pre></li>
			</ol>
			<p>We're not interested in the first parameter of type <code>CoroutineContext</code>, so we named it with an underscore, <code>_</code>.</p>
			<ol>
				<li value="2">Inside the <code>getRestaurants()</code> method, pass the <code>errorHandler</code> variable to the <code>launch</code> block using the <code>+</code> operator:<pre>private fun getRestaurants() { 
       viewModelScope.launch(Dispatchers.IO +
                             <strong class="bold">errorHandler</strong>) { 
            … 
       } 
}</pre></li>
			</ol>
			<p>By passing our <code>errorHandler</code> variable to the <code>launch</code> method, we make sure that the <code>CoroutineContext</code> object of this coroutine sets this <code>CoroutineExceptionHandler</code>, which will allow us to handle errors inside our handler.</p>
			<ol>
				<li value="3">Try running the <a id="_idIndexMarker335"/>app again without the internet.</li>
			</ol>
			<p>Now the app shouldn't crash because the <code>errorHandler</code> variable will catch the <code>Throwable</code> object thrown by Retrofit and allow us to print its stack trace.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As an improvement, try to find a way of notifying the UI that an error has occurred, thereby informing the user of what just happened.</p>
			<p>We are now handling errors with coroutines, so it's time to move to the last point of improvement – handling the switch of dispatchers correctly.</p>
			<h3>Making sure that every suspending function is safe to be called on any dispatcher</h3>
			<p>When defining suspending functions, a good practice is to make sure that every suspending function can be called on any <code>Dispatcher</code> object. This way, the caller (in our case, the coroutine) doesn't have to worry about <a id="_idIndexMarker336"/>what thread will be needed to execute the suspending function.</p>
			<p>Let's analyze our code with the coroutine:</p>
			<pre>private fun getRestaurants() {
    viewModelScope.launch(Dispatchers.IO + errorHandler) {
        val restaurants = restInterface.getRestaurants()
        withContext(Dispatchers.Main) {
            state.value = restaurants.restoreSelections()
        }
    }
}</pre>
			<p>The <code>getRestaurants()</code> method of the <code>restInterface: RestaurantsApiService</code> interface is a suspending function. This function should always be run on <code>Dispatchers.IO</code> since it executes a heavy I/O operation, that is, the network request.</p>
			<p>However, this would mean that whenever we have to call <code>restInterface.getRestaurants()</code>, we either have to call this suspending function from a coroutine that has a scope of <code>Dispatchers.IO</code> – just as we did previously – or always wrap it in a <code>withContext(Dispatchers.IO)</code> block inside the caller coroutine.</p>
			<p>Both of these alternatives don't scale well. Imagine that you have to call <code>restInterface.getRestaurants()</code> 10 times in the <code>RestaurantsViewModel</code> class. You would always have to be careful with setting the dispatcher when calling this function.</p>
			<p>Let's address this by creating a separate method where we can specify the correct dispatcher for our suspending function:</p>
			<ol>
				<li value="1">Inside the <code>RestaurantsViewModel</code> class, create a separate suspending method, called <code>getRemoteRestaurants()</code>, and wrap the <code>restInterface.getRestaurants()</code> call there with a <code>withContext()</code> block:<pre>private suspend fun getRemoteRestaurants(): List&lt;Restaurant&gt; {
    return withContext(Dispatchers.<a id="_idTextAnchor142"/>IO) {
        restInterface.getRestaurants()
    }
}</pre></li>
			</ol>
			<p>To the <code>withContext</code> method, we've passed the corresponding dispatcher for this suspending function: <code>Dispatchers.IO</code>.</p>
			<p>This <a id="_idIndexMarker337"/>means that whenever this suspending function is called (from a coroutine or another suspending function), the dispatcher will be switched to <code>Dispatchers.IO</code> for the <code>restInterface.getRestaurants()</code> call's execution.</p>
			<p>By doing so, we make sure that whoever is calling <code>getRemoteRestaurants()</code> will not have to care about the correct thread dispatcher for the content of this method.</p>
			<ol>
				<li value="2">In the <code>getRestaurants()</code> method of the <code>ViewModel</code> component, replace the <code>restInterface.getRestaurants()</code> method call with <code>getRemoteRestaurants()</code>:<pre>private fun getRestaurants() {
    viewModelScope.launch(Dispatchers.IO +<a id="_idTextAnchor143"/> errorHandler) 
    {
        val restaurants = <strong class="bold">getRemoteRestaurants()</strong>
        withContext(Dispatchers.Main) {
            state.value = restaurants.restoreSelections()
        }
    }
}</pre></li>
				<li>Since the content of the <code>getRemoteRestaurants()</code> method will be called on its appropriate dispatcher, we no longer have to pass <code>Dispatchers.IO</code> to the launch<a id="_idIndexMarker338"/> block. Remove the <code>Dispatchers.IO</code> dispatcher from the coroutine <code>launch</code> block:<pre>private fun getRestaurants() {
    <strong class="bold">viewModelScope.launch(errorHandler) {</strong>
        val restaurants = getRemoteRestaurants()
        withContext(Dispatchers.Main) {
            state.value = restaurants.
                restoreSelections()
        }
    }
}</pre></li>
			</ol>
			<p>By default, the launch block will inherit the <code>CoroutineContext</code> (and so its defined <code>Dispatcher</code> object) from its parent coroutine. In our case, there is no parent coroutine, so the <code>launch</code> block will launch a coroutine on the <code>Dispatchers.Main</code> thread which was predefined by the <code>viewModelScope</code> custom scope.</p>
			<ol>
				<li value="4">Since the coroutine will now run on the <code>Dispatchers.Main</code> thread, we can remove the redundant <code>withContext(Dispatchers.Main)</code> block from within the <code>getRestaurants()</code> method. The <code>getRestaurants()</code> method should now look like this:<pre>private fun getRestaurants() {
    viewModelScope.launch(errorHandler) {
        val restaurants = getRemoteRestaurants()
        state.value = restaurants.restoreSelections()
    }
}</pre></li>
			</ol>
			<p>Now, the <code>getRestaurants()</code> method where we launched the coroutine is much easier to read and understand. Our suspending function call, for instance, <code>getRemoteRestaurants()</code>, is called inside this coroutine on the <code>Dispatchers.Main</code> dispatcher. However, at the same time, our suspending function has its<a id="_idIndexMarker339"/> own <a id="_idTextAnchor144"/><code>withContext()</code> block with its corresponding <code>Dispatcher</code> object set:</p>
			<pre>private suspend fun getRemoteRestaurants()
        : List&lt;Restaurant&gt; {
    return withContext(Dispatchers.IO) {
        restInterface.getRestaurants()
    }
}</pre>
			<p>This practice allows us to call suspending functions from coroutines with any given <code>Dispatcher</code> object, simply because the suspending functions have their own <code>CoroutineContext</code> object set with their appropriate <code>Dispatcher</code> objects.</p>
			<p>At runtime, even though the coroutines are launched on their initial <code>Dispatcher</code> object, when our suspending functions are called, the <code>Dispatcher</code> object is briefly overridden for every suspending function that is internally wrapped with a <code>withContext</code> block.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For Retrofit interface calls such as <code>restInterface.getRestaurants()</code>, we can skip wrapping them in <code>withContext()</code> blocks because Retrofit already does this behind the scenes and sets the <code>Dispatchers.IO</code> dispatcher for all suspending methods from within its interface.</p>
			<p>Finally, the<a id="_idIndexMarker340"/> application should behave the same. However, in terms of good practices, we made sure that the correct <code>Dispatcher</code> object is set for every suspending function out of the box, and without us having to manually set it in every coroutine.</p>
			<p>Now that we improved the way dispatchers are set within our suspending function and coroutine, it's time to wrap this chapter up.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor145"/>Summary</h1>
			<p>In this chapter, we learned how coroutines allow us to write async code in a much clearer and more concise way.</p>
			<p>We understood what coroutines are, how they work, and why they are needed in the first place. We unveiled the core elements of coroutines: from <code>suspend</code> functions to <code>CoroutineScope</code> objects, to <code>CoroutineContext</code> objects and <code>Dispatcher</code> objects.</p>
			<p>Then, we replaced the callbacks with coroutines in our Restaurants application and noticed how the code is much easier to understand and less nested. Additionally, we learned how to perform error handling with coroutines and integrated some of the best practices when working with coroutines.</p>
			<p>In the next chapter, we will add another Compose-based screen to our Restaurants application and learn how to navigate between screens in Compose with yet another Jetpack library.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor146"/>Further reading</h1>
			<p>While canceling coroutines might seem simple with the help of the associated <code>Job</code> objects, it's important to note that any cancelation must be cooperative. More specifically, when coroutines perform suspending work based on conditional statements, you must ensure the coroutine is cooperative with respect to canceling. </p>
			<p>You can read about this topic, in more detail, in the official documentation: <a href="https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative">https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative</a>.</p>
		</div>
	</body></html>