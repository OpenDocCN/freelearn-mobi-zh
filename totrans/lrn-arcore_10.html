<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Mixing in Mixed Reality</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Mixed reality</strong> (<strong>MR</strong>) is the evolution of combining <strong>augmented reality</strong> and <strong>virtual reality</strong> into the same experience or app. MR typically uses a wearable device to overlay the virtual world on top of the user's reality. The concept first gained traction with Microsoft's introduction of HoloLens. HoloLens is a wearable glasses device that allows you to overlay your real world with virtual content using hand gestures, not unlike what we have been doing with ARCore in this whole book, except the difference of the wearable part and, of course, the price tag.</p>
<div class="mce-root packt_infobox"><span>Microsoft is currently leading the charge in mixed reality development with their platform of the same name, which is great exposure for the whole AR/VR and now MR space. Microsoft is a big technology company and, like many big technology giants, has decided to redefine the concept of mixed reality to also include virtual reality.</span></div>
<p class="mce-root">Wearable devices that allow users to experience mixed reality have been traditionally quite expensive, until just recently. Through group funding and other initiatives, there are now plenty of cheap, less-than $30 US wearable devices out there that will allow you to experience MR. This is perfect for anybody who wants to dive in and learn how to develop MR apps. Of course, not all MR platforms are designed for mobile devices, or will work with ARCore. Fortunately, an open source project called <strong>HoloKit</strong> has released a cardboard MR headset that is designed to work with ARCore.</p>
<div class="packt_quote CDPAlignLeft CDPAlign"><span>"I'm not confused. I'm just well mixed."<br/>
                                                                  - Robert Frost<br/>
  </span></div>
<p class="mce-root">In this chapter, we will build a combined AR / MR ARCore app that will be meant as a technology and learning demo that showcases the power of AR and MR. We will, of course, need to get our feet wet a little with VR as well, which should make things interesting. The following is the list of main items we will focus on in this chapter:</p>
<ul>
<li>Mixed reality and HoloKit</li>
<li>Introducing WRLD</li>
<li>Setting up WRLD for MR</li>
<li>Navigating the map</li>
<li>Mapping, GIS, and GPS</li>
<li>What's next</li>
</ul>
<p>This is a really big chapter with lots of material to go over. Unfortunately, we cannot include the content in a completed package due to licensing. However, we have tried to write each section in this chapter so that it can be used on its own, almost like a cookbook. This will allow you to pick and choose the components you want and don't want to use.</p>
<div class="packt_tip">To best experience the exercises in this chapter, it is recommended that you obtain a HoloKit. You should be able to obtain this device for around $30. If you are feeling adventurous, there are even plans available to build your own. Here's a link to where you can learn more about HoloKit and order your own at <a href="https://holokit.io/">https://holokit.io/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mixed reality and HoloKit</h1>
                </header>
            
            <article>
                
<p class="mce-root">HoloKit was created by Botau Hu, a brilliant new tech innovator that will surely experience great success in the industry. It's a <em>wearable</em> device that projects your mobile devices screen into a 3D holographic projection. This holographic projection is then overlaid onto the user's view, thus allowing them to experience a more immersive environment that often teeters on the edge of VR. The following is an illustration of what a HoloKit looks like fully assembled:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/d033fadf-2219-44c8-8fa1-29155231c5df.png" style="width:26.67em;height:15.00em;"/><br/>
<br/>
Fully assembled HoloKit</div>
<p>As you can see from the diagram, the device is quite similar in construction to that of <span>Google </span>Cardboard. Cardboard was Google's way of democratizing VR to the masses, and it worked. If you are unable to quickly get a HoloKit, you can also use a modified Google Cardboard. Just cut a slot in the cardboard for the device's camera and ensure not to move around too much.</p>
<p>One of the first things you will note about most mixed reality headsets is the ability of the user to see through their environment. This allows the user to still be spatially aware of their surroundings, while experiencing what could be an almost virtual experience. Since a user is more aware, MR devices are generally considered safer, and the user is much less prone to experiencing motion sickness and/or falling down. Currently, VR devices are not considered appropriate for those under the age of thirteen due to those issues.</p>
<p class="mce-root">VR motion sickness is often more a result of poor app performance or resolution. As it turns out, visual artifacts caused by a lagging app or poor resolution are responsible for placing additional strain on the user's brain. That strain will <span>then </span>manifest itself in the form of a severe headache or nausea. In the early days of VR, this was a big problem, but now the technology has improved enough for most users to be able to use an app for several hours at a time.</p>
<p>The <strong>Mirage Solo</strong> headset was developed by <em>Lenovo</em> for a game by Disney called <em>Jedi Challenges</em>. Jedi Challenges is really more a proof of concept and showcase for mixed reality and what is possible. It will likely also be a collector's item, since it is associated with the new Star Wars franchise and just happens to correspond to an up-and-coming tech revolution. The only truly unfortunate thing about this project is that Lenovo never released a developer kit; hopefully they will rectify this is in the future.</p>
<p>The following is an image of the Lenovo Mirage Solo headset:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/4f21f5f8-0271-45d2-966b-ffa171264b1f.png" style="width:38.42em;height:20.83em;"/><br/>
<br/>
Jedi Challenges Mixed Reality game</div>
<p>In order to complete the exercises in this chapter, you won't need HoloKit. HoloKit allows for you to switch from AR to MR/VR mode at the press of a button. This means that you can still work through all the exercises in this chapter. However, it does mean that you won't experience the magical experience of MR. In the next section, we set up HoloKit to work with ARCore and get ready to build our tech demo.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up HoloKit</h1>
                </header>
            
            <article>
                
<p>The great thing about HoloKit is that it comes complete with its own Unity template project. This makes our job of getting up and running with HoloKit quite painless. Open up Command Prompt or a shell window and do the following:</p>
<ol>
<li>If you haven't already done so, create a new folder from the root called <kbd>ARCore</kbd> and navigate to it:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir ARCore</strong><br/><strong>cd ARCore</strong></pre>
<ol start="2">
<li>Clone the HoloKit repository into it:</li>
</ol>
<pre style="padding-left: 60px"><strong>git clone -b android https://github.com/holokit/holokitsdk.git</strong></pre>
<ol start="3">
<li>That command clones the specific <strong>Android</strong> branch, which we will use. HoloKit is also supported for <strong>ARKit</strong> on <strong>iOS</strong>.</li>
<li>Open a new instance of the Unity editor. Create and open a new project called <kbd>HoloCore</kbd> in the <kbd>ARCore</kbd> folder.</li>
<li>In the <span class="packt_screen">Project</span> window, create a new folder under <span class="packt_screen">Assets</span> called <kbd>HoloCore</kbd>. Under that new folder, create our standard five new folders (<kbd>Scripts</kbd>, <kbd>Scenes</kbd>, <kbd>Materials</kbd>, <kbd>Models</kbd>, and <kbd>Prefabs</kbd>).</li>
<li>Open the <kbd>ARCore/holokitsdk/Assets</kbd> folder with a file explorer window. Make a copy of the <kbd>HoloKitSDK</kbd> folder and place it in the <kbd>ARCore/HoloCore/Assets</kbd> folder. When you are done, return to the editor, and you should see the assets getting imported and compiled. After the import is complete, confirm that your <span class="packt_screen">Project</span> window resembles the following:</li>
</ol>
<div class="CDPAlignCenter packt_figref CDPAlign"><img src="assets/fd6f2480-9553-4dab-8552-a125c461b64d.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Project window folders showing HoloKitSDK</div>
<ol start="7">
<li>If you are prompted to switch to <span class="packt_screen">Android</span>, elect to do so by clicking on <span class="packt_screen">OK</span>.</li>
<li>From the menu, select <span class="packt_screen"><strong>Edit</strong></span> | <span class="packt_screen"><strong>Project Settings</strong></span> | <span class="packt_screen"><strong>Player</strong></span>. This will open the <span class="packt_screen">Player</span> (as in app player) settings panel. Select the <span class="packt_screen">Android</span> tab and uncheck the <span class="packt_screen">Multithreaded</span> <span class="packt_screen">Rendering</span> option, and set the <span class="packt_screen">Package</span> name, <span class="packt_screen">API</span> <span class="packt_screen">Levels</span>, and <span class="packt_screen">ARCore Supported</span>, as shown:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/8ef6bef3-3451-40b9-8b41-0b9928b067b0.jpg" style="width:27.33em;height:30.67em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the Player settings for Android</div>
<ol start="9">
<li>Open up the <span class="packt_screen">HoloKit</span> sample scene <kbd>CubeOnTheFloor</kbd> in the <kbd>Assets/HoloKitSDK/Examples</kbd> folder.</li>
<li>From the menu, select <span class="packt_screen">File</span> | <span class="packt_screen">Save Scene as</span>, and save the scene as <span class="packt_screen">Main</span> in the <strong><kbd>Assets/HoloCore/Scenes</kbd></strong> folder.</li>
<li>Open up <span class="packt_screen">Build Settings</span> and add the current scene to the build.</li>
<li>Connect, build, and run. You should see a rather small button in the top corner with the letter <span class="packt_screen">C</span>. Press that button to switch from <span class="packt_screen">AR</span> to the <span class="packt_screen">MR</span> mode. When you are ready, put your device into the HoloKit headset and enjoy your first MR app.</li>
</ol>
<p>Unlike Google Cardboard, HoloKit needs to let the camera view the user's surroundings in order to track. As such, you may need to modify the headset by cutting out a larger hole for the device's camera to see through. Here's a pic of a HoloKit that needed to be modified in order to accommodate a Samsung Galaxy S8:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><br/>
<img src="assets/5118ff56-d549-4d98-9596-54040dc2d87d.jpg" style="width:21.33em;height:31.08em;"/><br/>
<br/>
Modified HoloKit to allow camera to visibly track</div>
<p>If you have another device that you want to hack, like Cardboard, then just ensure that you cut a space so that the camera is not blocked. Some other mixed reality headsets that work with mobile devices already have camera extensions. These camera extensions may support a fish eye lens, which allows for the device to see a wider area. This works quite well, since it essentially converts the camera into a sensor with a wide angle lens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How does it work?</h1>
                </header>
            
            <article>
                
<p>Before we get too far ahead of ourselves, let's break open the HoloKit project and take a look at how or what it does. Open up the Unity editor and complete the following:</p>
<ol>
<li>Find the <span class="packt_screen">HoloKitCameraRig</span> in the <span class="packt_screen">Hierarchy</span> window, and then select and expand it. Expand the children's children and so on until you can see the <span class="packt_screen">Left Eye</span> and <span class="packt_screen">Right Eye</span> objects, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/87e11eba-c03c-44ac-b224-10983823bbd0.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">View of the scene's 3 cameras in the Hierarchy window</div>
<ol start="2">
<li>The <span class="packt_screen">VideoSeeThroughCamera</span> is the main camera used when the app is in AR mode. When the app is in <span class="packt_screen">MR</span> mode, the <span class="packt_screen">Left Eye</span> and <span class="packt_screen">Right Eye</span> cameras are used to create the stereo 3D vision. Take a closer look at the <span class="packt_screen">Eye</span> cameras, and you will note that their position is slightly adjusted on the <em>x</em> axis. For the right camera, the amount is <span class="packt_screen">0.032</span>, and for the left it is <span class="packt_screen">-0.032</span>. This is how we generate 3D stereo projections, using an offset camera for each eye.</li>
</ol>
<ol start="3">
<li>The other components are as follows:
<ul>
<li><span class="packt_screen">HoloKitAmbientLight</span>: It is just a standard directional light with the <kbd>ARCore Environmental Light</kbd> script attached.</li>
<li><span class="packt_screen">HoloKitPlaneGenerator</span>: It is a base object for the <kbd>HelloARController</kbd> script, which we have seen plenty of before.</li>
<li><span class="packt_screen">HoloKitPlacementRoot</span>: It is our main anchor point for the scene's virtual objects.</li>
<li><span class="packt_screen">HoloKitCameraRig</span>: It is what controls the app view.</li>
<li><span class="packt_screen">HoloKitGazeManager</span>: It is new and allows the user to select objects just by positioning their gaze or view on the target. You can try this now with the current scene and the ball. Fix your gaze on the ball and see what happens.</li>
<li><span class="packt_screen">HoloKitPointCloud</span>: It serves the same function as its counterpart in ARCore.</li>
</ul>
</li>
</ol>
<ol start="4">
<li>Go through and continue to expand and inspect the rest of the objects in the scene.</li>
</ol>
<ol start="5">
<li>Connect, build, and run the scene again. This time, pay attention to the details and see if you can get the <span class="packt_screen">Gaze</span> to work.</li>
</ol>
<p>Well, hopefully that was relatively painless. Now, with HoloKit setup, we have the framework in place for our combined AR and MR app. We should expand on what our tech demo will do. The premise of our tech demo will be an app that allows the user to move between a traditional map interface and an AR or MR interface. The name HoloCore is a play on the ability to allow a user to drill into a map and render a 3D view in AR or MR. This also nicely ties in with the name ARCore. In the next section, we will look at adding a 3D map of the world to our app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing WRLD</h1>
                </header>
            
            <article>
                
<p>Mixed reality apps, because they provide spatial awareness to the user, are excellent for viewing massive objects or areas like a map. Unlike virtual reality, mixed provides a more intuitive and natural interface for movement since the user can also physically move their position. So, what better way to fully explore MR than by using it to view a 3D map of the world. Fortunately, there is a relative newcomer called <strong>WRLD</strong> that has started to make significant waves in AR / VR and MR, because it provides an excellent and simple solution for rendering a fairly-good 3D map.</p>
<div class="packt_infobox">WRLD is a great platform for general 3D mapping and visualization. It currently does not support more robust backend GIS services, but it certainly could. For those professional GIS developers with access to Esri CityEngine, there are also some great workflows for bringing CE models into Unity. This means that you can also experiment with CE models in MR.</div>
<p>WRLD is shipped as a Unity asset right to the <span class="packt_screen">Asset Store</span>, so installation is a breeze. However, before we install, we need to go to the WRLD site and get a developer account. WRLD is a commercial service that charges by usage. Fortunately, they offer free developer access for a limited, which is perfect for our tech demo. Open up a browser and complete the following:</p>
<ol>
<li>Browse to <a href="https://www.wrld3d.com/">wrld3d.com</a> and <span class="packt_screen">Sign Up</span> for an account. Ensure that you verify the account through email.</li>
<li>Return to the site and <span class="packt_screen">Sign In</span>.</li>
<li>Find and click on the <span class="packt_screen">Developers</span> link at the top of the page. This will take you to the <span class="packt_screen">Developers</span> page.</li>
<li>Click on the big <span class="packt_screen">Access API Keys</span> button at the top of the page.</li>
<li>Enter the name for your key, <kbd>HoloCore</kbd>, and click on <span class="packt_screen">Create API Key</span> to create the key, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6556db14-acba-4018-bf3d-7e3418ed1c22.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Creating a WRLD API key</div>
<ol start="6">
<li>Click on <span class="packt_screen">Copy API Key</span> to copy the key to your clipboard. We will use it shortly.</li>
<li>Return to the Unity editor and, from the menu, select <span class="packt_screen">Window</span> | <span class="packt_screen">Asset Store</span>. This will open a browser page inside the editor.</li>
</ol>
<ol start="8">
<li>Enter <kbd>WRLD</kbd> in the search box and click on the <span class="packt_screen">Search</span> button. This will open the asset page for <kbd>WRLD</kbd>, offering you to <span class="packt_screen">Download</span> the asset. Click on the <span class="packt_screen">Download</span> button, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/0e33f27b-45e8-4b02-bd94-2d9d66a47bc2.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Downloading the WRLD asset from the Asset Store</div>
<ol start="9">
<li>This will download the package. After the package downloads, you will be prompted with an asset import dialog. Just click on <span class="packt_screen">Import</span> to import everything. This may take a while, so stretch your legs and grab some refreshments.</li>
</ol>
<div class="packt_infobox">In some cases, you may want to be more careful on what you bring into your projects. For instance, if you were building a non-tech demo or proof of concept, you would likely remove any sample scenes or other excess from a project. We will talk more about keeping projects lean in <a href="e7c0bdd1-e380-4498-af5a-fe9e627eb6cb.xhtml" target="_blank">Chapter 11</a>, <em>Performance Tips and Troubleshooting</em>.</div>
<ol start="10">
<li>You may get a warning prompting you that the versions don't match with your version of Unity. Accept the warning and continue.</li>
<li>When you are prompted to get a key after you import <kbd>WRLD</kbd>, just click on <span class="packt_screen">Later</span>. After all, we already have a key.</li>
</ol>
<ol start="12">
<li>Next, you will probably be prompted to increase the shadow distance with the following dialog:</li>
</ol>
<div class="CDPAlignCenter packt_figref CDPAlign"><img src="assets/dd30d3f9-efd8-442a-9bb7-b5b0a10ad4a5.png"/> </div>
<div class="CDPAlignCenter CDPAlign packt_figref">Skip the Shadow settings dialog</div>
<ol start="13">
<li>Click on the <span class="packt_screen">Skip</span> button. We will need to adjust the lighting, materials, and shadows later manually.</li>
</ol>
<p>This imports the <kbd>WRLD</kbd> asset into our project. In the next section, we will cover how to set it up and run <kbd>WRLD</kbd> for our MR app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up WRLD for MR</h1>
                </header>
            
            <article>
                
<p>With the asset imported, we can now work on setting up <kbd>WRLD</kbd> to work in MR. The setup requires a little bit of customization, so jump back to Unity and complete the following:</p>
<ol>
<li>From the menu, select <span class="packt_screen"><strong>Assets</strong></span> | <span class="packt_screen"><strong>Setup WRLD Resources For</strong></span> | <span class="packt_screen"><strong>Android</strong></span>. This will ensure that the assets are optimized for <span class="packt_screen">Android</span>. We will also talk, in a later section, about how the materials can be manually optimized by updating or creating your own shaders.</li>
<li>Ensure that the <span class="packt_screen">Main</span> scene is loaded, and then select and expand the <span class="packt_screen"><strong>HoloKitPlacementRoot</strong></span>. Disable the <span class="packt_screen">DebugCube</span> and <span class="packt_screen">GazeTargetExample</span> child objects. If you forgot how to do this, check the <span class="packt_screen">Inspector</span> window.</li>
<li>Create a new child <kbd>GameObject</kbd> of <span class="packt_screen">HoloKitPlacementRoot</span> called <kbd>WRLD</kbd>. Go to the <span class="packt_screen">Inspector</span> window and use <span class="packt_screen">Add Component</span> to add the <kbd>Wrld Map</kbd> component to the object.</li>
</ol>
<ol start="4">
<li>Set the component properties of the <kbd>Wrld Map</kbd>, as shown:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/eff839f7-795d-4bd8-96a9-0c6afdc94785.png" style="width:34.67em;height:49.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting properties for the Wrld Map component</div>
<ol start="5">
<li>Select and drag the new <kbd>WRLD</kbd> object into your <kbd>Assets/HoloCore/Prefabs</kbd> folder to create a prefab that we can use later.</li>
<li>Select <span class="packt_screen">HoloKitCameraRig</span> from the <span class="packt_screen">Hierarchy</span> window and set the <span class="packt_screen">Transforms Y Position</span> to <kbd>300</kbd>. Since our map is at <kbd>0</kbd>, <kbd>0</kbd>, <kbd>0</kbd>, we want our viewer to look down from a height of around 300 meters or about 1000 feet. Then, expand the object until you see all of the children.</li>
<li>Select each of the cameras, <span class="packt_screen">VideoSeeThroughCamera</span>, <span class="packt_screen">Left Eye</span>, and <span class="packt_screen">Right Eye</span>, and, in the Inspector window, set the <span class="packt_screen">Clipping Planes Far</span> to <kbd>5000</kbd>, as illustrated:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/4eba6d12-0d4f-4c26-b9e1-a5aa820b503f.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the Far plane clipping distance</div>
<ol start="8">
<li>Adjusting the far clipping plane essentially expands our view to include all objects to a distance of <kbd>5000</kbd>. Previously, this was set for <kbd>1000</kbd>. You may also want to increase the <span class="packt_screen">Near Clipping Plane</span> to a larger value; <kbd>1</kbd> to <kbd>10</kbd> works well. If you note a slight flashing on the map, this is likely caused by the clipping plane being set to close.</li>
<li>Connect, build, and run. Set the app to run in <span class="packt_screen">MR</span> by clicking on the <span class="packt_screen">C</span> button and then inserting your device in HoloKit. Enjoy the experience of viewing a map in mixed reality.</li>
</ol>
<div class="packt_infobox">WRLD has several excellent examples on using their API on Unity and other platforms. We built this example in order to feature mixing realities, rather than recreating their examples. As such, we have omitted placing the map on a surface, but this is because WRLD already has a good example for ARKit and, likely, will in the future.</div>
<p>What you just experienced is quite fun, especially considering the minimal effort this example took to get setup, except that there are several things missing. Most certainly, we want to be able to move and zoom in and out of our map, so we will cover movement and navigating in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigating the map</h1>
                </header>
            
            <article>
                
<p>In a traditional AR app, you rarely move the user or player. The user or player move themselves, and the AR app works around that. We spent a good portion of this book understanding how ARCore tracks the user and understands their environment, which has worked quite well when working with small objects such as Andy. Except, if we want to render massive virtual objects or even embed new environments, then we need a way for the user to navigate those as well. Therefore, in this section, we will look to implement a mix of navigation methods from a standard touch interface to AR and MR versions. If you don't have a HoloKit or are not interested in trying MR, then you can stick to just working with the AR.</p>
<p>Before adding navigation to our app, we probably should look at how navigation is handled by default <span>in WRLD</span>. Open up the Unity editor and follow along:</p>
<ol>
<li>Save your current scene.</li>
<li>Create a new scene. Name it <kbd>Navigation</kbd> and save the scene in the <kbd>Assets/HoloCore/Scenes</kbd> folder.</li>
<li>From the <kbd>Assets/HoloCore/Prefabs</kbd> folder, drag the <kbd>WRLD</kbd> prefab we created earlier and drop it in the scene. Set the properties on the <kbd>Wrld Map</kbd>, as shown in this screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/cbf76eca-2a6e-4138-a9ed-4dc3a17c710c.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting properties for the WRLD prefab</div>
<ol start="4">
<li>This is more or less the default settings that you will use to just render the map to your device in a non-AR interface.</li>
<li>Open the <span class="packt_screen">Build Settings</span> dialog and add your new scene to the build. Uncheck the <span class="packt_screen">Main</span> scene, but don't delete it; we will turn it back on later.</li>
<li>Connect, build, and run. You will now see the map as the main element in your view. You can use touch gestures to move, pan, and zoom the map.</li>
</ol>
<p>As you can see by playing with the app, the map navigation is very slick using the touch interface. We will use this to allow the user to navigate the map with touch until they see an area of interest that they want to take a close look at. Then, they will be able to switch to <span class="packt_screen">AR</span> or <span class="packt_screen">MR</span> mode to view the items in more detail. In order to do this, we will use the scene we just created as our starting scene, and use our <span class="packt_screen">Main</span> scene to let the user switch to <span class="packt_screen">AR</span> or <span class="packt_screen">MR</span>.</p>
<div class="packt_infobox">Being able to switch between interface types like a regular touch-driven UI and AR or MR works all the time. An excellent example of this, of course, is the popular game <em>Pokemon Go</em> from Niantic Labs. This also happens to use a map and allows a user to switch to AR to catch Pokemon. If you are curious about how Pokemon Go was constructed, take a look at the book <em>Augmented Reality Game Development</em> by <em>Micheal Lanham</em>, also from <em>Packt</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Switching from AR to MR</h1>
                </header>
            
            <article>
                
<p>Being able to switch scenes and maintain state is common task, but it seems to require a bit of work in Unity. Open up the Unity editor to the <kbd>Navigation</kbd> scene and complete the following:</p>
<ol>
<li>Open up the <kbd>Assets/HoloCore/Scripts</kbd> folder and create a new script called <kbd>Singleton</kbd>. Go to the book's downloaded source <kbd>Code/Chapter_10</kbd> folder, copy the contents of the <kbd>Singleton.cs</kbd> file, and paste it into your new script. A <kbd>Singleton</kbd> is common pattern in Unity for creating an object you only want one of and when you never want that object destroyed. If you are new to <kbd>Singleton</kbd>, it will be in your best interest to spend some time and review the class.</li>
<li>Create a new script in the same folder called <kbd>SceneController</kbd> and replace the generated code with the following:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using UnityEngine;<br/>using UnityEngine.SceneManagement;<br/>using Wrld;<br/>using Wrld.Space;<br/>namespace Packt.HoloCore<br/>{<br/>  public class SceneController : Singleton&lt;SceneController&gt;<br/>  { <br/>    protected SceneController() { }<br/>  }<br/>}</pre>
<ol start="3">
<li><kbd>SceneController</kbd> is a <kbd>Singleton</kbd> with a <kbd>SceneController</kbd>. That circular reference may be a little confusing, so it is best to think of as a <kbd>SceneController</kbd> that is a <kbd>Singleton</kbd> which holds the <kbd>SceneController</kbd> <span>type. </span>Inside the class, we need to define a <kbd>protected</kbd> default constructor in order to force access through the <kbd>Instance</kbd>. We will look at how to use <kbd>Instance</kbd> shortly.</li>
<li>Enter the following right after the constructor:</li>
</ol>
<pre style="padding-left: 60px">public LatLongAltitude position;</pre>
<ol start="5">
<li>Next, we will add a single property to hold the <kbd>position</kbd> where the camera was last fixed. That way, when we switch scenes, we can just pass the <kbd>position</kbd> property back to the scene so that it can determine where to setup. <kbd>LatLongAltitude</kbd> is a spatial data type that holds the position of the camera in latitude, longitude, and altitude.</li>
<li>Add the following new method, <kbd>LoadScene</kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px">public void LoadScene(string scene, Camera mapCamera)<br/>{<br/>   if (Api.Instance.CameraApi.HasControlledCamera)<br/>   {<br/>     mapCamera = Api.Instance.CameraApi.GetControlledCamera(); <br/>   }<br/>   if(mapCamera == null) throw new ArgumentNullException("Camera", "Camera must be set, if map is not controlled.");<br/> <br/>  position = Api.Instance.CameraApi.ScreenToGeographicPoint(new Vector3(mapCamera.pixelHeight/2, mapCamera.pixelWidth/2, mapCamera.nearClipPlane), mapCamera);<br/> <br/>  SceneManager.LoadScene(scene, LoadSceneMode.Single);<br/>}</pre>
<ol start="7">
<li><kbd>LoadScene</kbd>, is where all the work happens. We will call <kbd>LoadScene</kbd> on the <kbd>SceneController</kbd>, passing in the <kbd>scene</kbd> name we want to load at the current <kbd>map</kbd> or WRLD camera. Inside the method, we first test to see whether the current <kbd>map</kbd> is being controlled; if it is, we just ignore the camera and use the controlled camera. Next, we test whether the <kbd>mapCamera</kbd> is null; if it is, we want to exit with an error. Otherwise, we extract the current position with <kbd>ScreenToGeographicPoint</kbd>. This method extracts<strong> </strong>the camera's main screen focal point, which we assume is at half pixel width and height of the screen; <kbd>mapCamera.nearClipPlane</kbd> sets the front of view frustum or camera if you recall from our earlier discussions, which equals the altitude of the camera above ground level, or the map <span>in this case</span>. At the end of the method, we use <kbd>SceneManager</kbd>, which is the Unity helper class for loading scenes. We call <kbd>LoadScene</kbd> with the option to replace the scene using <kbd>LoadSceneMode.Single</kbd>.</li>
</ol>
<p>That completes our <kbd>SceneController</kbd>. Now, the useful thing about being a <kbd>Singleton</kbd> is that we never have to physically add the component, because it is <span>now </span>always considered available. WRLD bases most of their Unity API on this pattern as well. We do still have to add some further code that can be activated from our scene.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the SceneSwitcher</h1>
                </header>
            
            <article>
                
<p>Let's add another script/component that will just activate our <kbd>SceneController</kbd>. Open up the editor and complete the following:</p>
<ol>
<li>Create a new C# script called <kbd>SceneSwitcher</kbd>, and replace all the pre-generated code with the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>namespace Packt.HoloCore<br/>{<br/>  public class SceneSwitcher : MonoBehaviour {<br/>  <br/>  }<br/>}</pre>
<ol start="2">
<li>Create the following property inside the class:</li>
</ol>
<pre style="padding-left: 60px">public Camera mapCamera;</pre>
<ol start="3">
<li>This is a placeholder for the <kbd>mapCamera</kbd>, the camera being used to render the <kbd>Wrld map</kbd>. We need this when the map is not being controlled by the camera, which is the case when the user is in AR / MR.</li>
<li>Then, create the following method:</li>
</ol>
<pre style="padding-left: 60px">public void SwitchScenes(string sceneName)<br/>{<br/>   SceneController.Instance.LoadScene(sceneName, mapCamera);<br/>}</pre>
<ol start="5">
<li>This method will be responsible for using the <kbd>LoadScene</kbd> on the <kbd>SceneController</kbd>. Note the use of <kbd>Instance</kbd> in between the class and method call. Remember that our <kbd>SceneController</kbd> is a <kbd>Singleton</kbd>, which is an object and not a static class. Therefore, we need an instance, and that is provided with a helper property called <kbd>Instance</kbd> in <kbd>Singleton</kbd> and so when calling a method on <kbd>SceneController</kbd>, we always call it through <kbd>Instance</kbd>.</li>
<li>Save all your files, if you haven't already done so, and return to Unity. Ensure that you have no compiler errors.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the SceneSwitcher prefab</h1>
                </header>
            
            <article>
                
<p>With the code complete, it is now time to build our <kbd>SceneSwitcher</kbd> prefab. Open the editor to the <kbd>Navigation</kbd> scene and complete the following:</p>
<ol>
<li>From the menu, select <span class="packt_screen">GameObject</span> | UI | <span class="packt_screen">Canvas</span>. Add the <kbd>SceneSwitcher</kbd> component (script) to the canvas and rename it as <kbd>SceneSwitcher</kbd>. Set the <span class="packt_screen">Map Camera</span> property on the <kbd>Scene Switcher</kbd> to use the <span class="packt_screen">Main Camera</span>.</li>
<li>Select the <strong>SceneSwitcher</strong> object in the <span class="packt_screen">Hierarchy</span> window and then, from the menu, select <span class="packt_screen">GameObject</span> | <span class="packt_screen">UI</span> | <span class="packt_screen">Panel</span>. Set the properties of the panel, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4a9ab0a9-5b10-480e-87d2-b1168333b080.jpg"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the properties on the Panel</div>
<ol start="3">
<li>Set the <span class="packt_screen">Anchor</span> by clicking on the button and then, when the <span class="packt_screen">Anchor Presets</span> menu opens, simultaneously press the pivot and position keys (<em>Shift</em> + <em>Alt</em> on Windows) and then click on the top-left corner. This will set the panel to anchor to the top left. You will also need to add a <span class="packt_screen">Grid Layout Group</span> component and set the properties specified.</li>
</ol>
<ol start="4">
<li>Select the <span class="packt_screen">Panel</span> and, from the menu, choose <span class="packt_screen">GameObject</span> | <span class="packt_screen">UI</span> | <span class="packt_screen">Button</span>. Rename the button <span class="packt_screen">Switch</span> and set the button text to <span class="packt_screen">Switch</span>.</li>
<li>Set an <span class="packt_screen">OnClick</span> handler for the <span class="packt_screen">Switch</span> button, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/3a757e63-cb52-4f4f-b13e-bb07e5d1ab50.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Adding a button OnClick handler</div>
<ol start="6">
<li>We set the parameter, which is a string, to <span class="packt_screen">Main</span>. <span class="packt_screen">Main</span> is the name of the scene we want to switch to when the user clicks on the button.</li>
<li>Drag the <kbd>SceneSwitcher</kbd> object from the <span class="packt_screen">Hierarchy</span> window and drop it into the <kbd>Assets/HoloCore/Prefabs</kbd> folder of the <span class="packt_screen">Project</span> window. This will create a new prefab for us to use in the <span class="packt_screen">Main</span> scene.</li>
<li>Double-click on the <span class="packt_screen">Main</span> scene in the <kbd>Assets/HoloCore/Scenes</kbd> folder. When prompted, save the <kbd>Navigation</kbd> scene changes, of course.</li>
<li>Drag the <kbd>SceneSwitcher</kbd> prefab from the <kbd>Assets/HoloCore/Prefabs</kbd> folder and drop it into an empty area of the <span class="packt_screen">Hierarchy</span> window.</li>
<li>Set the <span class="packt_screen">Map Camera</span> property on the <kbd>SceneSwitcher</kbd> component (on <kbd>SceneSwitcher</kbd> object) to the <span class="packt_screen">VideoSeeThroughCamera</span>.</li>
<li>Expand the <kbd>SceneSwitcher</kbd> object and locate the <span class="packt_screen">Switch</span> button. Change the <span class="packt_screen">OnClick</span> event handler to pass <kbd>Navigation</kbd>,<strong> </strong>which is the scene we want to load from <span class="packt_screen">Main</span>. Remember that the scene names must match exactly, so watch your case.</li>
<li>Save the scenes.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying the Wrld map script</h1>
                </header>
            
            <article>
                
<p>We are almost done; the last thing we need to do is let the <kbd>Wrld Map</kbd> script pull the last camera's position from our singleton <kbd>SceneController</kbd>. This means that we unfortunately have to modify the source of the <kbd>Wrld Map</kbd> script. Generally, we want to avoid modifying a third-party API, except that we have the source, and it really is our only option. Open up the <kbd>WrldMap</kbd> script, located in the <kbd>Assets/Wrld/API</kbd> folder, and follow along:</p>
<ol>
<li>Insert the following, between the lines identified:</li>
</ol>
<pre style="padding-left: 60px"><strong>using Wrld.Scripts.Utilities;  </strong>//after me<br/>using Packt.HoloCore;<br/><strong>#if UNITY_EDITOR  </strong>//before me</pre>
<ol start="2">
<li>Scroll down to the <kbd>SetupApi</kbd> method and insert the following code between the lines identified:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>config.Collisions.BuildingCollision = m_buildingCollisions; //after me</strong><em><strong><br/></strong></em><span>config.DistanceToInterest = SceneController.Instance.position.GetAltitude();</span><br/><span>config.LatitudeDegrees = SceneController.Instance.position.GetLatitude();</span><br/><span>config.LongitudeDegrees = SceneController.Instance.position.GetLongitude();</span><br/><strong>Transform rootTransform = null; //before me</strong></pre>
<ol start="3">
<li>All this does is set the map to the last position the camera was pointed at. You can see that we are using the <kbd>SceneController</kbd> singleton here to access the camera's last known position. You can see in the <kbd>SetupApi</kbd> method where a configuration object is defined and set. Hopefully, in the future, <kbd>Wrld</kbd> allows for this configuration to be passed into the script. If that was possible, we could just modify that configuration before it is passed to the <kbd>WrldMap</kbd> script, thus eliminating the need for us to add our own code in the class.</li>
<li>Save the file and return to Unity. Check for any errors.</li>
</ol>
<ol start="5">
<li>Open the <span class="packt_screen">Build Settings</span> dialog and ensure that both scenes are added, active, and in the order shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/5e6692a0-5ea2-40fc-8c14-6f1a8311348a.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the scenes and scene order on Build Settings dialog</div>
<ol start="6">
<li>Connect, build, and run the app. Since we are starting at <kbd>0</kbd>, <kbd>0</kbd> in latitude and longitude spatial coordinates, the map will start just off the coast of Africa, which is <kbd>0</kbd>, <kbd>0</kbd>. Use a pinch touch gesture to zoom out until you see the global view of the world. Use a touch slide gesture to pan the map to North America, currently the best place to view <kbd>WRLD</kbd> data. Choose an area that is familiar and zoom in until you start to see 3D objects. Then, press the <span class="packt_screen">Switch</span> button to switch the interface to <span class="packt_screen">MR</span> and <span class="packt_screen">AR</span>. You can switch back to the <span class="packt_screen">Main</span> view by pressing <span class="packt_screen">Switch</span> again. The following is an image showing the augmented reality mode and another user using the mixed reality mode with a <span class="packt_screen">HoloKit</span> headset:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d2c2037-bde3-4528-b0d2-baa90bd633c7.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Augmented reality view of the application running</div>
<ol start="7">
<li>We now have an app that lets a user navigate a map and then switch to view areas of interest in <span class="packt_screen">AR</span> or <span class="packt_screen">MR</span> mode. This works well, except that it would be better if the user started at their current position. In order to do that, we need to understand a bit more about mapping, GIS, and GPS, which we will cover in the next section.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping, GIS, and GPS</h1>
                </header>
            
            <article>
                
<p>Unity, as we already learned, tracks its objects in 3D space using a point with a <strong>Cartesian</strong> coordinate reference system of x, y, and z. When we plot a point on a map of the world, it is no different; we need to reference the point, except that now we need to use a spherical or <strong>geographic</strong> reference system to represent a position on the earth, because as we all know, the earth is spherical. However, converting between a geographic system and Cartesian system is expensive. Many mapping applications, therefore, use an intermediary reference known as <strong>earth-centered</strong>, <strong>earth-fixed</strong> (<strong>ECEF</strong>), which represents mapping data on an earth-fixed Cartesian coordinate reference system. The following is a diagram shows the differences between Cartesian, geographic, and ECEF coordinate reference systems:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/32cf584a-1169-4fd4-8e23-210c0e0ccbf9.jpg"/><br/>
<br/>
Comparison of coordinate reference systems</div>
<p>Now, you may have already noticed that WRLD supports ECEF out of the box. As we mentioned, since ECEF is already in a Cartesian frame of reference, the conversions are much easier and quicker. However, for us, we just want to position the camera at the user's geographic coordinate reference, which we can easily obtain from the user's device using GPS.</p>
<p>Accessing the user's GPS on their device takes a bit of work, but fortunately, we can do this all in one place. Let's open up the <kbd>SceneController</kbd> script and make the following modifications:</p>
<ol>
<li>Add two new properties at the top of the class:</li>
</ol>
<pre style="padding-left: 60px">public bool isLoaded;<br/>public string status;</pre>
<ol start="2">
<li>Create a new method just under the constructor:</li>
</ol>
<pre style="padding-left: 60px">void Awake()<br/>{<br/>  StartCoroutine(GetLocationPoint());<br/>}</pre>
<ol start="3">
<li>The <kbd>Awake</kbd> <span>method </span>is a special Unity method that runs when the <kbd>GameObject</kbd> first initializes. Inside of the method, we are calling <kbd>StartCoroutine</kbd>. <kbd>StartCoroutine</kbd> is another special method in Unity that allows you to create a <kbd>coroutine</kbd>. <kbd>Coroutines</kbd> are a way of interrupting or breaking your code flow, doing something else, and then returning to complete your original task. In the call, we are passing in a method call <kbd>GetLocationPoint()</kbd>, which sets up that method as a <kbd>coroutine</kbd>.</li>
<li>Add the following method to create the <kbd>coroutine</kbd>:</li>
</ol>
<pre style="padding-left: 60px">IEnumerator GetLocationPoint()<br/>{<br/>}</pre>
<ol start="5">
<li>A coroutine must return <kbd>IEnumerator</kbd>. By adding the return type, the method can now <kbd>yield</kbd> or interrupt its execution with a <kbd>yield return</kbd> statement that returns a <kbd>YieldInstruction</kbd>. We will see how to do that shortly.</li>
<li>Just inside <kbd>GetLocationPoint</kbd>, add the following line:</li>
</ol>
<pre style="padding-left: 60px">AndroidPermissionsManager.RequestPermission(new string[] { "android.permission.ACCESS_FINE_LOCATION" });</pre>
<ol start="7">
<li>This line of code prompts the user for access to the <kbd>location</kbd> services, also known as GPS. We do this in order to explicitly identify the user's <kbd>location</kbd>, provided that their device's GPS is not being blocked or the user has the <kbd>location</kbd> service disabled.</li>
</ol>
<div class="packt_infobox">Google has developed their own <kbd>location</kbd> service in essence by mapping wireless endpoint MAC addresses to geographic coordinates. Google does this by essentially war driving with its self-driving Street View cars. While those cars drive themselves around, they are also grabbing the MAC address of every wireless device that they can detect at the time of mapping that to a GPS <kbd>location</kbd>. As it turns out, this service can actually be more accurate for providing <kbd>location</kbd> in more dense metropolitan areas where GPS line of sight is difficult.</div>
<ol start="8">
<li>Then, add the following:</li>
</ol>
<pre style="padding-left: 60px">if (Input.location.isEnabledByUser == false)<br/>{<br/>  isLoaded = true;<br/>  yield return SetStatus("Location not authorized, starting at 0,0", 1.0f);<br/>  yield break;<br/>}</pre>
<ol start="9">
<li>This block of code checks whether the user had GPS enabled; if they don't, there is nothing we can do. We set <kbd>isLoaded</kbd> to <kbd>true</kbd>, which will be a flag to let outside methods know that we found or didn't find a <kbd>location</kbd>. Then, we <kbd>yield return</kbd> the results of a call to <kbd>SetStatus</kbd>. Remember that because we are in a <kbd>coroutine</kbd>, <kbd>yield return</kbd> means that we want to interrupt code execution at this point.</li>
<li>Scroll down just past the <kbd>GetLocationPoint</kbd> method and add the following new method:</li>
</ol>
<pre style="padding-left: 60px">public YieldInstruction SetStatus(string status, float time)<br/>{<br/>  this.status = status;<br/>  return new WaitForSeconds(time);<br/>}</pre>
<ol start="11">
<li>Inside the method, we are setting our <kbd>status</kbd> text, which will be a message we want to display back to the user. Then, we return a new <kbd>WaitForSeconds(time)</kbd>, where <kbd>time</kbd> represents the number of seconds to wait. There are many different forms of <kbd>YieldInstruction</kbd> that you can use to break your code. The <kbd><span>YieldInstruction</span></kbd> here just waits for a set number of seconds and then returns to continue the code where it left off. Keep in mind that after the <kbd>yield</kbd> has elapsed, for whatever reason, code will then resume from exactly where it left off.</li>
<li>Return to where we left off in <kbd>GetLocationPoint</kbd>. Right after the <kbd>yield return SetStatus</kbd> call, we are executing <kbd>yield break</kbd>. This line breaks the <kbd>coroutine</kbd> and exits the method, which is equivalent to return in a normal method.</li>
<li>Now that we understand <kbd>coroutines</kbd>, let's enter the next section of code:</li>
</ol>
<pre style="padding-left: 60px">yield return SetStatus("-----STARTING LOCATION SERVICE-----", 1);<br/>Input.location.Start();<br/><br/>// Wait until service initializes<br/>int maxWait = 30;<br/>while (Input.location.status == LocationServiceStatus.Initializing &amp;&amp; maxWait &gt; 0)<br/>{<br/>  yield return new WaitForSeconds(1);<br/>  maxWait--;<br/>}</pre>
<ol start="14">
<li>First, we start by setting a <kbd>status</kbd> message and letting the user know that we are starting the service, which we then do. After that, we continually loop, breaking every second with <kbd>yield return new WaitForSeconds(1)</kbd>, adjusting our counter <kbd>maxWait</kbd> for every iteration. We need to wait for the <kbd>location</kbd> service to initialize; sometimes this can take a while.</li>
<li>Enter the following code to handle when our counter has expired (<kbd>maxWait&lt;1</kbd>):</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">// Service didn't initialize in 20 seconds<br/> if (maxWait &lt; 1)<br/> {<br/>   yield return SetStatus("ERROR - Location service timed out, setting to 0,0,0", 10.0f);<br/>   isLoaded = true;<br/>   yield break;<br/> }</pre>
<ol start="16">
<li>Inside the <kbd>if</kbd> block, we set the <kbd>status</kbd> and <kbd>loaded</kbd> flag. Then, we return from the <kbd>coroutine</kbd> with <kbd>yield break</kbd>.</li>
<li>Next, we want to handle when the service fails or starts by entering the following:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">if (Input.location.status == LocationServiceStatus.Failed)<br/>{<br/>  yield return SetStatus("ERROR - Unable to determine device location.", 10.0f);<br/>  isLoaded = true;<br/>  yield break;<br/>}<br/>else<br/>{<br/>  //set the position<br/>  yield return SetStatus("-----SETTING LOCATION----", 10.0f);<br/>  position = new LatLongAltitude(Input.location.lastData.latitude, Input.location.lastData.longitude, Input.location.lastData.altitude);<br/>  isLoaded = true; <br/>}</pre>
<ol start="18">
<li>This code handles the service failure or success. In the failure path, we set an error message and exit. Otherwise, we set a <kbd>status</kbd> and wait for <kbd>10</kbd> seconds. We do this so that the user can read the message. Then, we set the position according to the geographic coordinates the device provides us with.</li>
<li>Finally, we stop the service with this:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> Input.location.Stop();</pre>
<ol start="21">
<li>We stop the service because we don't need to continually get <kbd>location</kbd> updates.<br/>
If you want to keep the service open and use it to track the user's <kbd>location</kbd>, such as Pokemon Go, then just ensure that you stop the service when the object is being destroyed. You can do this in a method called <kbd>OnDisable()</kbd>, which is another special Unity method that is used to clean up the object.</li>
<li>At this point, we also want to update and overload the <kbd>LoadScene</kbd> method with the following code:</li>
</ol>
<pre style="padding-left: 60px">public void LoadScene(string scene)<br/>{<br/>  SceneManager.LoadScene(scene, LoadSceneMode.Single);<br/>}<br/><br/>public void LoadScene(string scene, Camera mapCamera)<br/>{ <br/>  if (Api.Instance.CameraApi.HasControlledCamera)<br/>  {<br/>    mapCamera = Api.Instance.CameraApi.GetControlledCamera();<br/>  }<br/>  else if (mapCamera == null) throw new ArgumentNullException("Camera", "Camera must be set, if map is not controlled.");<br/>  position = Api.Instance.CameraApi.ScreenToGeographicPoint(new Vector3(mapCamera.pixelHeight / 2, mapCamera.pixelWidth / 2, mapCamera.nearClipPlane), mapCamera);<br/><br/>  Debug.LogFormat("cam position set {0}:{1}:{2}", position.GetLatitude(), position.GetLongitude(), position.GetAltitude());<br/>  SceneManager.LoadScene(scene, LoadSceneMode.Single);<br/>}</pre>
<ol start="23">
<li>We overloaded the method in order to allow two different behaviors when switching scenes. The new method we added won't worry about setting the <kbd>position</kbd> for the camera. We also added some logging, so we can see what values are being set by looking at our Android debug tools while running the app.</li>
<li>Save the file when you are done.</li>
</ol>
<p>The code we just set up was originally derived from the Unity sample, but it has been modified for your reuse. Since accessing the <kbd>location</kbd> service can take a while, we will add a new scene in order to handle the <kbd>location</kbd> service starting up. This will be a splash screen that you can make prettier later on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the Splash scene</h1>
                </header>
            
            <article>
                
<p>The <kbd>Splash</kbd> scene we are building is very basic for now, with just some status messages. You can, of course, style it and add any images you like later on. Open up the editor and complete the following:</p>
<ol>
<li>Create a new scene called <kbd>Splash</kbd> and save the scene to the <kbd>Assets/HoloCore/Scenes</kbd> folder.</li>
<li>From the menu, select <span class="packt_screen">GameObject</span> | <span class="packt_screen">UI</span> | <span class="packt_screen">Panel</span>. This will add a new <span class="packt_screen">Canvas</span> with a child <span class="packt_screen">Panel</span> and <span class="packt_screen">EventSystem</span>. Set the background color of <span class="packt_screen">Panel</span> to a dark gray.</li>
<li>Select the <span class="packt_screen">Panel</span> and, from the menu, select <span class="packt_screen">GameObject</span> | <span class="packt_screen">UI</span> | <span class="packt_screen">Text</span>. Change the name of the object to <kbd>Status</kbd> and set its properties in the <span class="packt_screen">Inspector</span> window, as shown:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/decf2da0-be21-4626-9c74-3b8befc51038.png" style="width:31.42em;height:48.25em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the Status text properties</div>
<ol start="4">
<li>This is the where we will display those status messages back to the user, which means that we need a script that can update the <kbd>status</kbd> messages as well as know when the service has been loaded and the application can start.</li>
</ol>
<ol start="5">
<li>Create a new C# script called <kbd>SceneLoader</kbd> in the <kbd>Assets/HoloCore/Scripts</kbd> folder and replace the pre-generated code with the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using UnityEngine.UI;<br/><br/>namespace Packt.HoloCore<br/>{<br/>  public class SceneLoader : MonoBehaviour<br/>  {<br/>    public string sceneName;<br/>    public Text statusText;<br/>    <br/>    void Update()<br/>    {<br/>      if (SceneController.Instance.isLoaded)<br/>      {<br/>        SceneController.Instance.LoadScene(sceneName);<br/>      }<br/>      else<br/>      {<br/>        statusText.text = SceneController.Instance.status;<br/>      }<br/>    }<br/>  }<br/>}</pre>
<ol start="6">
<li>This simple class is what we will use to track the status of our <kbd>SceneController</kbd>. All the action takes place in the <kbd>Update</kbd> method. We first check whether the <kbd>SceneController</kbd> has loaded by testing <kbd>isLoaded</kbd>. If the scene has not loaded, we display the <kbd>status</kbd> text in the <kbd>statusText.text</kbd> object. Remember that the <kbd>Update</kbd> method is run every rendering frame, so we are testing this condition several times a second. Save the script, and next, we need to add it as a component to our scene.</li>
<li>Return to the Unity editor and wait for the new class to compile.</li>
</ol>
<ol start="8">
<li>Create a new object called <kbd>ScreenLoader</kbd> and add the new <kbd>ScreenLoader</kbd> script to it. Then, set the properties of <kbd>SceneLoader</kbd> to what is shown here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/c6c0e1fe-e4d1-4a08-b4c7-9bded136ac6d.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the SceneLoader component properties</div>
<ol start="9">
<li>Set the <span class="packt_screen">Status Text</span> property to the <kbd>Status</kbd> object. You can use the bull's-eye icon to select the object from the scene or just drag the object from the <span class="packt_screen">Hierarchy</span> window and drop it into the slot.</li>
<li>Save the scene.</li>
<li>Open <span class="packt_screen">Build Settings</span>, add the <kbd>Splash</kbd> scene to the build, and ensure that it is the first scene, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/3891abf3-6dc3-49c9-949f-e556357cd172.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Adding the Splash scene to the build</div>
<ol start="12">
<li>Go ahead, connect, build, and run. You will now be taken to <kbd>location</kbd> as identified by the <kbd>Location</kbd> service, <span>that is, </span>if you allow the service to connect.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fixing the altitude issue</h1>
                </header>
            
            <article>
                
<p>You may notice an issue if you live above 500 meters above sea level. This issue happens because our AR camera is fixed at 500 meters altitude. The problem is that we have our AR camera at a fixed height; we now need to adjust that based on the camera's altitude. Open back up the editor and complete the following:</p>
<ol>
<li>Create a new C# script and replace the code with the following:</li>
</ol>
<pre style="padding-left: 60px">using System.Collections;<br/>using System.Collections.Generic;<br/>using UnityEngine;<br/><br/>namespace Packt.HoloCore<br/>{<br/>  public class SceneCameraMover : MonoBehaviour<br/>  {<br/>    void Awake()<br/>    {<br/>      var altitude = SceneController.Instance.position.GetAltitude();<br/>      transform.position = new Vector3(0f, (float)altitude, 0f);<br/>    }<br/>  }<br/>}</pre>
<ol start="2">
<li>This script creates a new class called <kbd>SceneCameraMover</kbd>. The job of <kbd>SceneCameraMover</kbd> is to move the AR camera into position when the view switches to AR / MR.</li>
<li>Save the script and return to Unity.</li>
<li>Open the <span class="packt_screen">Main</span> scene from the <kbd>Assets/HoloCore/Scenes</kbd> folder.</li>
<li>Expand <span class="packt_screen">HoloKitCameraRig</span> and select <span class="packt_screen">VideoSeeThroughCamera</span>. Then, add the script to the component using <span class="packt_screen">Add Component</span> and searching for <span class="packt_screen">SceneCameraMover</span>.</li>
<li>Set the <span class="packt_screen">Transform</span> on the <span class="packt_screen">HoloKitCameraRig</span> to <kbd>0</kbd>, <kbd>0</kbd>, <kbd>0</kbd>. We will now let the script move the camera to the position we need.</li>
</ol>
<ol start="7">
<li>Save the scenes and project.</li>
<li>Connect, build, and run. Go to an area that is well above sea level, say the mountains, and switch to AR / MR view. The camera should now position itself correctly based on the altitude you were viewing the scene at.</li>
</ol>
<p>Ensure that you explore other areas of interest around the world. In the next section, we will finish up the chapter and our discussion of AR and ARCore with the next steps, and we'll see where you can go to build your own incredible tech demo or commercial app.</p>
<div class="packt_tip">The online example demos from WRLD recommend using an alternate streaming camera for AR visuals in ARCore or ARKit apps. However, we found that adding an alternate camera, alongside the already two additional cameras for the HoloKit, caused the app to be more unstable than it already can be. If you don't plan to use MR or HoloKit, you likely want to experiment with the alternate streaming camera.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What's next?</h1>
                </header>
            
            <article>
                
<p>The tech demo we developed is an excellent example of the possibilities of integrating technologies across user experiences. This has already been done extensively, and one popular example is Pokemon Go. In fact, you can say that Pokemon Go put AR into our vocabulary. So what is the next big AR app you will develop with ARCore? Are you still trying to think of some ideas or possibilities? The following is a list of app ideas or industries that are investing heavily in AR right now:</p>
<ul>
<li><strong>Entertainment (Games)</strong>: Gaming and entertainment is the most competitive space you can be in. Developing an app for this space requires hard work and a bit of luck. There have been some grand successes in this space, but that was after some hard work and considerable backing.</li>
<li><strong>Healthcare (Emergency services)</strong>: The healthcare industry is diving into the AR / MR and VR world in full force. Since this industry is heavily funded, it is now a leader in these technologies. If you want to get into cutting-edge reality development, this is the space to be in. It can be more difficult to get into, since this industry has traditionally been more isolated, but now <span>there are plenty of opportunities </span>with the explosion of growth.</li>
<li><strong>Marketing (Retail)</strong>: As AR becomes more mainstream and readily available, we will come across new apps developed in this space. There have already been some great novel concepts used to encourage sales, which have worked, except that AR has become something of a novelty in this space as of late. However, if you talk to anyone in marketing, they will agree that some day a majority of advertising will be provided via AR. Until then though, perhaps you can think of the next great app that will sell hamburgers.</li>
<li><strong>Education (Knowledge transfer)</strong>: This is another really big industry that can be hard to get into, that is, if you are planning to put your app in a classroom. Alternatively, you can build an educational app that perhaps teaches you how to cook but is delivered through an app store. Either way, this can be a difficult industry to get into but very rewarding, especially if you like teaching or learning.</li>
<li><strong>Military</strong>: It's very difficult to get into, unless you have a military background or other established credentials. This likely means a strong educational background as well. This is an interesting industry if you can get in, and is certainly not for everyone. If this is your choice though, you will most certainly be working on cutting-edge apps or tools.</li>
<li><strong>Travel &amp; tourism (History)</strong>: This one crosses over with education, as some of the same principles may apply. Perhaps, it is showing someone a historical battle over the area where the real battle took place. There are plenty of opportunities for developers of all skill levels to work in this area building AR / MR apps.</li>
<li><strong>Design (All)</strong>: This one can tie in a lot with retail applications. Perhaps demonstrating an outfit overlaid onto someone's body or trying to determine whether a chair works in a room. We put this further down in the list because our expert survey listed this one lower as well. However, as we demonstrated, ARCore has plenty of great design applications.</li>
<li><strong>Industrial (Manufacturing)</strong>: Applications of AR can help human users as well as provide better foundations for future automation of systems or other processes. This means that the AR systems we build for humans now will also help us make the manufacturing robots of the future smarter.</li>
<li><strong>Automotive</strong>: We have already seen AR system in automobiles for a few years now. From heads-up displays to GPS devices, this industry has already embraced AR, although it isn't likely that developing an embedded AR app for this industry makes a lot of sense. Most users, drivers, would likely prefer to use an AR off their device. Perhaps it makes more sense for the automotive industry to provide a docking station for a mobile device in vehicles with an AR interface?</li>
<li><strong>Music</strong>: Think of this as more for the musician and not the audience. This is a set of AR tools that help musicians compose and work with music. Not for everyone and not well suited to ARCore, perhaps they will embed voice recognition or other audio recognition into ARCore someday.</li>
</ul>
<p>Whatever you plan to build as your next app, we sincerely wish you the best of luck and would eagerly like to hear about any great apps. Be sure to contact the author with your great app concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p><strong>Complete the following exercises on your own:</strong></p>
<ol>
<li>Go back to the <kbd>HoloCore</kbd> example and track the user's position with a block or sphere. Hint—the first part of this example is in the code download.</li>
<li>Track the user's position as they move on the map. Hint<span>—</span>you will now need to update the user's position from the most recent GPS readings.</li>
<li>Track multiple users' positions around you. Hint<span>—</span>you can use the Firebase Realtime Database to track the user's position in geographic coordinates.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">For this chapter, we diverted away from AR a little and explored mixing augmented and mixed reality. We discovered that we can easily experience mixed reality apps with a simple device called a HoloKit or other cheap headset. ARCore tracks the user well and is a great fit for adding the MR experience. Who knows, in the future when everyone is wearing MR glasses, will we even distinguish AR and MR as different? We then set up the HoloKit template app and went to work building a quick MR demo. After that, we expanded on our demo by adding in WRLD. WRLD, as we learned, is a fun and easy-to-use API that can quickly give us some large-scale impressive 3D scenery that is representative of the user's area. From there, we developed a number of scenes for all the users to move a map touch interface to a full mixed-reality view of the map, where we were able to obtain the user's geographic coordinates from their device's GPS and put them at the same position in WRLD. Finally, we looked to the future and industries that you can focus your app development skills on.</p>
<p>We complete our journey in the next chapter with a discussion of performance and troubleshooting, both of which will be helpful as you grow your skills to become a better AR developer.</p>


            </article>

            
        </section>
    </body></html>