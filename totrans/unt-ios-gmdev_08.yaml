- en: Chapter 8. Multimedia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 多媒体
- en: Now that we have spent some time exploring the gameplay components of our game
    and building systems for control, we need to spend some time examining the components
    of the game that deal with video and audio. Things such as background music, the
    sounds of enemies, and playing movies are important parts that our game needs.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们已经花了一些时间探索游戏的游戏玩法组件并构建控制系统，我们需要花一些时间检查游戏中的视频和音频组件。例如，背景音乐、敌人的声音以及播放电影都是我们游戏需要的重要部分。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn to play background music
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习播放背景音乐
- en: Learn how to add ambient sounds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何添加环境声音
- en: Learn how to play movies that are embedded in the application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在应用程序中播放嵌入的电影
- en: Learn how to stream movies from remote locations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何从远程位置流式传输电影
- en: So let's get on with it...
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们继续吧...
- en: Important preliminary points
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要预备事项
- en: This chapter assumes that you have some understanding of compressed audio formats
    such as MP3 and OGG, as well as video formats such as MP4\. Further, it assumes
    that you know how to create this content using your favorite tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对压缩音频格式（如MP3和OGG）以及视频格式（如MP4）有所了解。此外，它还假设您知道如何使用您喜欢的工具创建这些内容。
- en: Audio capabilities
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频功能
- en: Our game is very quiet right now. Even though we can see the actions of our
    player, we cannot hear what the player is doing — nor do we have a feel for the
    environment itself. We want to add some sounds that will exist in the environment
    and we want to provide some feedback when things happen in the game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在非常安静。尽管我们可以看到玩家的动作，但我们无法听到玩家在做什么——也无法感受到环境本身。我们希望添加一些存在于环境中的声音，并在游戏发生事件时提供一些反馈。
- en: Playing sounds
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放声音
- en: As discussed in the Unity Fundamentals, all audio that is played is done so
    from the perspective of the AudioListener. So, if we want to have something in
    our game make noise, we simply need to add an AudioSource to that GameObject and
    we will get a sound. In our design we call for having ambient sounds in the environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如在Unity基础知识中讨论的那样，所有播放的音频都是从AudioListener的角度进行的。因此，如果我们想让游戏中的某个东西发出声音，我们只需向该GameObject添加一个AudioSource，我们就会得到声音。在我们的设计中，我们要求环境中有环境声音。
- en: Time for action — Adding ambient sounds
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——添加环境声音
- en: While we're in our town we want it to sound like a town that is in the middle
    of the forest. To accomplish this we should have some ambient sound that is low
    volume that just blends in to the environment. A good source of Creative Commons
    licensed sounds is The Freesound Project which can be found at [http://www.freesound.org](http://www.freesound.org).
    There are a number of good candidates on the site and I have picked up one from
    user reinsamba for this test. You will find a copy of it in the assets folder
    of the project called `evening in the forest.wav`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在我们的城镇时，我们希望它听起来像森林中的城镇。为了实现这一点，我们应该有一些低音量的环境声音，它只是与环境融合。Creative Commons许可的音频的一个好来源是Freesound项目，可以在[http://www.freesound.org](http://www.freesound.org)找到。网站上有很多好的候选者，我已经从用户reinsamba那里挑选了一个用于这个测试。您可以在项目的资产文件夹中找到一个名为`evening
    in the forest.wav`的副本。
- en: To keep your assets organized create an `Ambient Audio` folder in your project.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持您的资产组织有序，在您的项目中创建一个`环境音频`文件夹。
- en: Simply drag the asset, an `evening in the forest.wav` file in this case, into
    the project and Unity will perform the necessary conversion:![Time for action
    — Adding ambient sounds](img/978-1-84969-040-9_8_1.jpg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地将资产拖动到项目中，在本例中是`evening in the forest.wav`文件，Unity将执行必要的转换：![添加环境声音的行动时间](img/978-1-84969-040-9_8_1.jpg)
- en: Now you have a usable AudioSource that can be added to other GameObjects in
    the scene. But remember, Unity will not distort the assets unless we tell it to
    by changing some properties of the original audio file. We brought in a fairly
    sizable AudioSource as a `.wav` file.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在您有一个可用的AudioSource，可以添加到场景中的其他GameObject中。但请记住，Unity不会扭曲资产，除非我们通过更改原始音频文件的一些属性来告诉它。我们引入了一个相当大的AudioSource作为`.wav`文件。
- en: Tell Unity to compress this asset by selecting **Compressed** from the **Audio
    Format** option so that the file doesn't take up as much space. Also, check the
    **Hardware decoding** checkbox so that Unity will use the iOS hardware built into
    an iOS device:![Time for action — Adding ambient sounds](img/978-1-84969-040-9_8_2.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Unity压缩这个资产，从**音频格式**选项中选择**压缩**，这样文件就不会占用太多空间。此外，勾选**硬件解码**复选框，以便Unity将使用iOS设备内置的iOS硬件：![添加环境声音的行动时间](img/978-1-84969-040-9_8_2.jpg)
- en: If hardware isn't available, Unity will automatically fall back to software
    decoding. In our case here we are going from a 26.2MB Wav file to a 0.6MB compressed
    MP3 file. If you want a higher quality sample you can adjust the Compression slider
    to a higher value, but in our case this is simple ambient noise so we don't need
    an excessive amount of fidelity.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有可用硬件，Unity将自动回退到软件解码。在我们的例子中，我们是从26.2MB的Wav文件转换到0.6MB的压缩MP3文件。如果您想要更高品质的样本，可以将压缩滑块调整到更高的值，但在这个例子中，这只是一个简单的环境噪音，所以我们不需要过度的保真度。
- en: Now that we have created the AudioSource we need to attach it to a GameObject
    so that it will play. Since this is the sound of the environment, we can attach
    this to the ground that the player will walk around on.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经创建了AudioSource，需要将其附加到一个GameObject上，以便它能够播放。由于这是环境声音，我们可以将其附加到玩家将行走的地面。
- en: Simply drag the Audio source onto the ground in the **Scene** view, or drag
    it over to the ground in the **Hierarchy** view. Either will result in an AudioSource
    Component being added to the ground.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地将Audio source拖动到**场景视图**中的地面，或者拖动到**层次结构视图**中的地面。两种方式都会在地面添加一个AudioSource组件。
- en: Ensure that the audio continues to play by selecting the **Loop** option from
    the **Audio Source properties** in the **Inspector:**
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**检查器**的**Audio Source属性**中选择**循环**选项，确保音频持续播放：
- en: '![Time for action — Adding ambient sounds](img/978-1-84969-040-9_8_3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 添加环境声音](img/978-1-84969-040-9_8_3.jpg)'
- en: We have told this AudioSource to loop its audio so we should hear this audio
    clip for the duration of the game while we're on this ground GameObject. One special
    note about compressed audio in iOS is that the compression process may tweak the
    beginning or end of your audio data, so you will want to listen to it after compressing
    it to make sure that it still loops properly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经告诉这个AudioSource循环其音频，所以我们应该在整个游戏过程中，在这个地面GameObject上听到这个音频剪辑。关于iOS中压缩音频的一个特殊说明是，压缩过程可能会调整您的音频数据的开始或结束，因此您在压缩后应该听一下，以确保它仍然可以正确循环。
- en: We didn't necessarily have to attach the sound to the ground, we could have
    attached it to a different object. For example, if we wanted to give a marketplace
    the sounds of marketplace chatter we could attach that directly to the GameObject
    that represents the marketplace and when the player walks away from it, the sound
    would diminish.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不一定需要将声音附加到地面上，我们也可以将其附加到不同的对象上。例如，如果我们想给市场添加市场嘈杂的声音，我们可以直接将其附加到代表市场的GameObject上，当玩家离开它时，声音会减弱。
- en: What just happened?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just created an ambient sound track for our world. By importing a `.wav`
    file and compressing it we have integrated an asset that is suitable for use on
    our mobile platform and can use the iOS device hardware to decompress the audio
    stream. Since we've attached this AudioSource to the ground of our world, we can
    be certain that it will be audible as we move through our environment. With this
    we have created some atmosphere for our world and given this area of the world
    a personality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们的世界创建了一个环境声音轨道。通过导入.wav文件并压缩它，我们整合了一个适合在移动平台上使用的资产，并且可以使用iOS设备硬件来解压缩音频流。由于我们已经将这个AudioSource附加到我们世界的地面上，我们可以确信，当我们穿过环境时，它将是可听见的。通过这种方式，我们为我们的世界创造了一些氛围，并给这个世界的这个区域赋予了个性。
- en: Time for action — Adding sounds to actions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 为动作添加声音
- en: While we have created some background ambient sounds, we still don't have any
    sounds for actions that take place in the game. For example, if we use our ranged
    attack swipe gesture and throw something, our player should make some sound as
    he is going through the throw animation and the thrown object should make a sound
    if it hits the ground — or some other object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经创建了一些背景环境声音，但我们还没有为游戏中发生的行为添加任何声音。例如，如果我们使用我们的远程攻击滑动手势并投掷某物，我们的玩家在投掷动画过程中应该发出一些声音，而投掷的物体如果击中地面——或者其他物体，也应该发出声音。
- en: 'Let''s import a simple sound that we will play when the player is going to
    throw something for their range attack. Once again I have utilized a Creative
    Commons Licensed sound from [www.freesound.org](http://www.freesound.org). The
    author of this sound is Sruddi1 and I have sampled the sound to contain a single
    grunt that will be the sound our character makes when they perform a ranged attack.
    I have compressed this sound similar to the steps used when importing our ambient
    sound:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入一个简单的声音，当玩家要进行远程攻击时，我们会播放这个声音。我再次使用了来自[www.freesound.org](http://www.freesound.org)的Creative
    Commons许可的声音。这个声音的作者是Sruddi1，我已经采样了这个声音，包含一个单一的咆哮声，这将是我们的角色在执行远程攻击时发出的声音。我已经将这个声音压缩得类似于导入环境声音时的步骤：
- en: '![Time for action — Adding sounds to actions](img/978-1-84969-040-9_8_4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 向动作添加声音](img/978-1-84969-040-9_8_4.jpg)'
- en: Now all we need to do is associate this grunt sound with a scripted action that
    would be the user throwing something. Accomplishing this is a simple extension
    of some of the skills we learned earlier in the book. Remember, from the scripting
    section that we can pass variables to scripts and those objects can be references
    to things from Unity. We need to create a simple script that represents the action
    and expose a variable that will contain the sound.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是将这个咆哮声与一个脚本动作关联起来，这个动作是用户扔东西。完成这个任务是对我们在书中早期学到的某些技能的简单扩展。记住，从脚本部分我们知道我们可以将变量传递给脚本，并且这些对象可以是Unity中的事物引用。我们需要创建一个简单的脚本来表示这个动作，并公开一个将包含声音的变量。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This script will now play the desired `AudioClip` whenever it is invoked. All
    you have to do is drag an `AudioClip` onto the component that you''ve attached
    this script to and that is what will be played:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本现在会在被调用时播放所需的`AudioClip`。你所要做的就是将一个`AudioClip`拖放到你附加此脚本的组件上，这就是将要播放的内容：
- en: '![Time for action — Adding sounds to actions](img/978-1-84969-040-9_8_5.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 向动作添加声音](img/978-1-84969-040-9_8_5.jpg)'
- en: It is important to note that you don't necessarily have to attach an `AudioClip`
    to an in-game object in order to play a sound. You can create a `GameObject` on
    the fly when you want to play an `AudioClip`. In fact, this is very useful if
    you want to create sounds on the fly as a result of detecting some event.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，你不必一定将`AudioClip`附加到游戏中的对象上才能播放声音。当你想要播放`AudioClip`时，可以即时创建一个`GameObject`。实际上，如果你想要在检测到某些事件时即时创建声音，这非常有用。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So if we have installed this `AudioEngine` to a `GameObject` in the scene we
    can simply reference it and tell it to play the specific `AudioClip` that we want
    to play and tell it where we want it to sound like it is positioned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们已经将这个`AudioEngine`安装到场景中的`GameObject`上，我们就可以简单地引用它，并告诉它播放我们想要播放的特定`AudioClip`，并告诉它声音的位置。
- en: What just happened?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have created a sound that will play whenever a user performs the ranged attack
    gesture. By updating our script which animates a player when the ranged attack
    gesture is detected, we have specified a new `AudioClip` that we can play in our
    script by performing a simple scripting call. We can perform similar actions now
    when a player swings a sword, hits an enemy, and so on. We only need to expose
    an `AudioClip` variable in those scripts and pass along the sound that we want
    to play.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个声音，当用户执行远程攻击手势时就会播放。通过更新我们的脚本，该脚本在检测到远程攻击手势时对玩家进行动画处理，我们已经在脚本中指定了一个新的`AudioClip`，我们可以通过简单的脚本调用来播放它。现在，当玩家挥剑、击中敌人等时，我们也可以执行类似操作。我们只需要在这些脚本中公开一个`AudioClip`变量，并传递我们想要播放的声音。
- en: Playing music
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放音乐
- en: Playing music in Unity has some particular nuances to get it working properly.
    While it is true that music is just like any other sound, just that it has a relationship
    to the player's position in the scene.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中播放音乐有一些特定的细微差别，以确保其正常工作。虽然音乐就像任何其他声音一样，只是它与玩家在场景中的位置有关。
- en: Time for action — The sound of music
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 音乐的声音
- en: In our application we want to have music playing constantly. We can accomplish
    this by attaching a `GameObject` to the player or camera object and having the
    music play from there. If you attempt this, your sound system will play music
    just fine until the scene changes. As such, the primary difference between playing
    sound and building a music system is making sure that the music keeps playing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们希望音乐持续播放。我们可以通过将`GameObject`附加到玩家或相机对象，并从那里播放音乐来实现这一点。如果您尝试这样做，您的声音系统将很好地播放音乐，直到场景改变。因此，播放声音和构建音乐系统的主要区别在于确保音乐继续播放。
- en: Create a folder called `Music`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Music`的文件夹。
- en: Import your favorite `.mp3` file into the game project. In the project's sample
    files you will find the track Orc March by basematic. You can find other creative
    commons music at [http://www.ccmixter.org/:](http://www.ccmixter.org/)![Time for
    action — The sound of music](img/978-1-84969-040-9_8_12.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您喜欢的`.mp3`文件导入游戏项目。在项目的示例文件中，您可以找到basematic创作的Orc March曲目。您可以在[http://www.ccmixter.org/:](http://www.ccmixter.org/)找到其他创意共享音乐![行动时间
    — 音乐的声音](img/978-1-84969-040-9_8_12.jpg)
- en: Create an empty Game Object called **MusicPlayer** and make it the child of
    the **Main Camera:**![Time for action — The sound of music](img/978-1-84969-040-9_8_13.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**MusicPlayer**的空游戏对象，并将其设置为**主相机**的子对象：![行动时间 — 音乐的声音](img/978-1-84969-040-9_8_13.jpg)
- en: Add an **Audio Source** component to the **MusicPlayer** Game Object.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**音频源**组件添加到**MusicPlayer**游戏对象。
- en: Next, we need to ensure that our **MusicPlayer** object does not get destroyed
    as we move between scenes, by creating a script in Unity that is attached to the
    next scene. To do this create a second scene in the game called `scene_2`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们的**MusicPlayer**对象在场景间移动时不会被销毁，通过在Unity中创建一个附加到下一个场景的脚本来实现。为此，在游戏中创建一个名为`scene_2`的第二个场景。
- en: 'Create a script called `MusicPreserver` and fill it with the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MusicPreserver`的脚本，并填充以下代码：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Attach the MusicPreserver script to the new scene.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MusicPreserver脚本附加到新场景。
- en: What just happened?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We can now play music in our game and have that music active as we move across
    scenes. This will give us the ability to set moods for areas of our game, yet
    give the flexibility of being able to change the scene data while the music continues
    to play.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在游戏中播放音乐，并在场景间移动时保持音乐播放。这将使我们能够为游戏中的区域设置情绪，同时保持更改场景数据时的灵活性。
- en: By default, when Unity loads a new level or scene, all of the objects in the
    previous scene are destroyed (which would normally stop our music). The key to
    preserving the music is the `DontDestroyOnLoad` method which will tell Unity to
    leave this Game Object alone when it is disposing of objects from the original
    scene. Now we can have real music sound tracks that span our entire game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当Unity加载新级别或场景时，前一个场景中的所有对象都会被销毁（这通常会停止我们的音乐）。保留音乐的关键是`DontDestroyOnLoad`方法，它将告诉Unity在处理原始场景的对象时不要动这个游戏对象。现在我们可以拥有跨越整个游戏的真实音乐音轨。
- en: Video capabilities
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频功能
- en: iOS devices have standard hardware accelerated playback for H.264 encoded video.
    Apple exposes interfaces to play this content using the `MPMoviePlayerController`
    class in the SDK. This class permits one to play a movie that is located on the
    device, or to stream one that is located at some arbitrary URL on the Internet.
    Unity exposes both of these methods in `iPhoneUtils` using the `PlayMovie` or
    `PlayMovieURL` methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备对H.264编码的视频具有标准的硬件加速播放。Apple通过SDK中的`MPMoviePlayerController`类公开接口来播放此内容。这个类允许用户播放位于设备上的电影，或者播放位于互联网上某个任意URL的电影。Unity通过`iPhoneUtils`中的`PlayMovie`或`PlayMovieURL`方法公开这两种方法。
- en: 'iOS device video encoding is very specific, regardless of whether you are streaming
    video in the WebKit web browser using a UIWebView or doing it in Unity. The video
    must be compressed using the following compression standards:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在WebKit网络浏览器中使用UIWebView流式传输视频，还是在Unity中这样做，iOS设备的视频编码都非常具体。视频必须使用以下压缩标准进行压缩：
- en: H.264 Baseline Profile Level 3.0 video
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H.264基线配置文件级别3.0视频
- en: Support resolutions up to 640x480 at 30fps
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持高达640x480分辨率，30fps的分辨率
- en: B Frames are not supported in the Baseline Profile
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线配置文件不支持B帧
- en: MPEG-4 Part 2 video (Simple Profile)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MPEG-4 Part 2视频（简单配置文件）
- en: If you need some tools to help you create video that will work with iOS devices,
    you can examine the Quicktime Player itself and its video export options, as well
    as Handbrake. Handbrake ( [http://www.handbrake.fr](http://www.handbrake.fr))
    has specific profiles for encoding video for the iOS platform devices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一些工具来帮助您创建与iOS设备兼容的视频，您可以检查Quicktime Player本身及其视频导出选项，以及Handbrake。Handbrake（[http://www.handbrake.fr](http://www.handbrake.fr)）为iOS平台设备提供了特定的编码视频配置文件。
- en: Time for action — Playing embedded video
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 播放嵌入视频
- en: For our application design we are supposed to play an introduction movie when
    the application first starts. This video is normally some animated logo or similar
    and in our case it will be the Sojourner Mobile intro movie (sometimes referred
    to as an interstitial).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序设计，我们应在应用程序首次启动时播放一个介绍电影。这个视频通常是某个动画标志或类似内容，在我们的案例中将是Sojourner Mobile介绍电影（有时被称为插页）。
- en: I'm going to assume that you aren't a video engineer and don't know a lot about
    MPEG-4, H.264, or B Frames, but you have some content that you want to get into
    your iOS project. This is one thing that gives a lot of new developers trouble
    and results in video not displaying on the device.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我将假设您不是视频工程师，对MPEG-4、H.264或B帧不太了解，但您有一些想要添加到iOS项目中的内容。这给许多新开发者带来了很多麻烦，并导致视频在设备上无法显示。
- en: We can avoid all of this drama by simply using a tool that was designed for
    producing content for iOS devices. One such tool that you can use for this is
    iMovie. It has functionality for exporting iOS device compliant video that you
    can use with your projects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用专为为iOS设备制作内容而设计的工具来避免所有这些麻烦。您可以用于此目的的一个这样的工具是iMovie。它具有导出iOS设备兼容视频的功能，您可以使用它来处理您的项目。
- en: Import your content into iMovie and export it using the **Share** menu:![Time
    for action — Playing embedded video](img/978-1-84969-040-9_8_7.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的内容导入iMovie，并使用**共享**菜单导出：![行动时间 — 播放嵌入视频](img/978-1-84969-040-9_8_7.jpg)
- en: When prompted for the video type that you want to export to, choose the Mobile
    size and press the **Export** button:![Time for action — Playing embedded video](img/978-1-84969-040-9_8_8.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示选择要导出的视频类型时，请选择移动尺寸并按**导出**按钮：![行动时间 — 播放嵌入视频](img/978-1-84969-040-9_8_8.jpg)
- en: Note that you can choose the Medium size as well, but since this is media that
    is being embedded into our game, and will count against our maximum application
    size, it is best to keep this content as small as possible so that you can keep
    it for other things such as game assets.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，您也可以选择中等尺寸，但由于这是将被嵌入到我们游戏中的媒体，并且将计入我们的最大应用大小限制，因此最好将此内容保持尽可能小，以便您可以为其他事物（如游戏资源）保留空间。
- en: Next we need to move the video into a special Unity assets folder called `StreamingAssets`.
    Unity will copy the files in this directory into our application bundle and put
    them in the appropriate location on the device so we can play them back at runtime:![Time
    for action — Playing embedded video](img/978-1-84969-040-9_8_6.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将视频移动到名为`StreamingAssets`的特殊Unity资源文件夹中。Unity将复制此目录中的文件到我们的应用程序包中，并将它们放在设备上的适当位置，以便我们可以在运行时播放它们：![行动时间
    — 播放嵌入视频](img/978-1-84969-040-9_8_6.jpg)
- en: Now that we have our asset in the game we need to play it. The best way to do
    this is to have a single scene that does nothing other than display our movie
    and then loads the IntroCity scene.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经在游戏中有了资产，我们需要播放它。最好的方法是有一个场景，除了显示我们的电影外，不做任何其他事情，然后加载IntroCity场景。
- en: Let's create a new scene called **GameIntro** that will serve this purpose:![Time
    for action — Playing embedded video](img/978-1-84969-040-9_8_9.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为**GameIntro**的新场景，它将为此目的服务：![行动时间 — 播放嵌入视频](img/978-1-84969-040-9_8_9.jpg)
- en: Now that we have our **GameIntro** scene we can create an empty **GameObject**
    and attach a script to it that will play our movie and load the next level after
    it's over.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了**GameIntro**场景，我们可以创建一个空的**GameObject**，并将其脚本附加到它上面，该脚本将播放我们的电影，并在电影结束后加载下一级。
- en: Now, all we need is a simple script that we can attach to this **GameObject**
    and have start in the `Start()` of the script. We need to use the C# co-routine
    version of the `Start()` method as opposed to our normal version.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要一个简单的脚本，我们可以将其附加到这个**GameObject**上，并在脚本的`Start()`方法中启动。我们需要使用C#的`Start()`方法的协程版本，而不是我们通常的版本。
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this script attached to our empty **GameObject** we now have a complete
    intro movie system and when we start the game we will be greeted with the Interstitial
    of our company.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将此脚本附加到我们的空**GameObject**，我们现在拥有了一个完整的介绍电影系统，当我们开始游戏时，我们将看到我们公司的插页广告。
- en: What just happened?
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just finished our introduction scene by playing a movie to display our
    studio intro movie and then loading the level that we had been working on, which
    is the beginning town-level. Now our content is beginning to feel like the content
    that we would find on the App Store.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过播放电影来展示我们的工作室介绍电影，然后加载我们一直在工作的关卡，即开始城镇关卡，从而完成了我们的介绍场景。现在我们的内容开始感觉像我们在App
    Store中找到的内容。
- en: Time for action — Streaming video
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 流式传输视频
- en: The first thing we need to do is make sure that an Internet connection is available.
    Once we know that the Internet is available we can start to stream our video.
    We need to check for a network connection because we want to respect the fact
    that our user may deactivate the network connection for Airplane Mode, trying
    to preserve battery life, or because our device may not be in an area of network
    connectivity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是确保互联网连接可用。一旦我们知道互联网可用，我们就可以开始流式传输我们的视频。我们需要检查网络连接，因为我们想尊重用户可能为了节省电池寿命而关闭网络连接以进入飞行模式，或者因为我们的设备可能不在网络连接区域。
- en: 'We can determine whether or not the iOS device can reach the network by using
    the iPhoneSettings'' `internetReachability` class variable. This will be updated
    as the network status changes and will also tell you what type of Internet connection
    you have available. For our purposes we simply need to check whether or not there
    is a connection of any kind. We can resolve this with a simple condition check:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用iPhoneSettings的`internetReachability`类变量来确定iOS设备是否可以连接到网络。这将随着网络状态的变化而更新，并也会告诉您您可用的互联网连接类型。对于我们的目的，我们只需要检查是否有任何类型的连接。我们可以通过简单的条件检查来解决这个问题：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is very important that you perform this check for Internet connectivity.
    If your application tries to reach out to the Internet and fails and you do not
    deal with this gracefully, by either showing an error that is visible to the user
    or not performing the functionality that requires network access, Apple will reject
    the application. You should be prepared to test your game in Airplane Mode exclusively
    to know whether or not it is going to behave properly if there is no network connectivity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此互联网连接检查非常重要。如果您的应用程序尝试连接到互联网但失败，并且您没有优雅地处理这种情况，无论是显示用户可见的错误还是不执行需要网络访问的功能，苹果公司将拒绝该应用程序。您应该准备好在仅限飞行模式的情况下测试您的游戏，以了解在没有网络连接的情况下它是否会表现正常。
- en: 'Now we know that we can reach the Internet, we want to stream some video to
    the device. I have stored a video online that the iOS device can stream from our
    server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以连接到互联网，我们希望将一些视频流式传输到设备上。我已经在网上存储了一个iOS设备可以从我们的服务器流式传输的视频：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see this isn't much different from playing back content that is stored
    on the device. As we want this to behave like a commercial we want to remove the
    player's ability to cancel this video or skip through it so we use the `iPhoneMovieControlMode.Hidden`
    enumeration to ensure that the player will have to watch the movie.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与播放设备上存储的内容并没有太大不同。因为我们希望它像商业广告一样表现，我们希望移除播放器取消此视频或跳过它的能力，所以我们使用`iPhoneMovieControlMode.Hidden`枚举来确保播放器必须观看这部电影。
- en: What just happened?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have performed network detection to determine whether or not an Internet
    connection is available. After ensuring that a network connection was available
    we connected to a stream on the Internet and began playing our commercial.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经执行了网络检测来确定互联网连接是否可用。在确认网络连接可用后，我们连接到互联网上的一个流并开始播放我们的商业广告。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we performed all of the steps necessary to handle multimedia
    in our project. We've given more of a soul to our game by providing the expected
    environmental cues of video and audio that people have come to expect in games,
    to make our games as professionally built as those already in the App Store.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们执行了处理项目中多媒体所需的所有步骤。我们通过提供人们已经期待在游戏中看到的视频和音频环境提示，给我们的游戏增添了更多的灵魂，使我们的游戏看起来像App
    Store中已有的专业游戏。
- en: 'Specifically, we covered:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to add ambient sound to the environment
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向环境中添加环境声音
- en: How to add background music to the game
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为游戏添加背景音乐
- en: How to play sound based upon actions in a script
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据脚本中的动作播放声音
- en: How to play video embedded in the Unity project
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何播放Unity项目中嵌入的视频
- en: How to detect whether or not our network connection is active
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测我们的网络连接是否活跃
- en: How to play video hosted on an external website
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何播放托管在外部网站上的视频
- en: Now that we've learned about these and formed the core of our game, it's time
    to take a step back and begin looking at how we can check for performance issues
    and debug our application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些并形成了游戏的核心，是时候退后一步，开始考虑如何检查性能问题并调试我们的应用程序了。
