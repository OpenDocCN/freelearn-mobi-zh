- en: Building iOS Apps with Swift
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be building our very own iOS app using Swift and the
    Xcode IDE. Once we've built our app, we'll look at how we can incorporate unit
    tests and **user interface** (**UI**) tests. Finally, we'll take a look at backward
    compatibility in Swift and iOS development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building an iOS App using Cocoa Touch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit and integration testing with XCTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface testing with XCUITest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backward compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need the latest version of Xcode from the Mac App Store.
  prefs: []
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3pMG44r](https://bit.ly/3pMG44r)'
  prefs: []
  type: TYPE_NORMAL
- en: Building an iOS App using Cocoa Touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this book is ultimately on the Swift programming language itself,
    as opposed to the use of the language to produce apps for Apple platforms or to
    build server-side services. That being said, it can't be ignored that the vast
    majority of the Swift code being written is to build, or build upon, iOS and iPadOS
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a brief look at how we can interact with Apple's
    Cocoa Touch frameworks using Swift and begin to build and create our very own
    iOS app.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cocoa Touch** is a name given to the collection of UI frameworks available
    as part of the iOS SDK. Its name derives from the Cocoa framework on macOS, which
    provides UI elements for macOS apps. While Cocoa on macOS is a framework in its
    own right, Cocoa Touch is a collection of frameworks that provide UI elements
    for iOS apps and handle the app''s life cycle; the core of these frameworks is
    **UIKit**.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll need to create a new iOS app project:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Xcode menu, choose File, then New.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the dialog box that opens, choose App from the iOS tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d0443fb-bcc3-4271-8a5b-f29776d14047.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Choosing a template
  prefs: []
  type: TYPE_NORMAL
- en: The next dialog box asks you to enter details about your app, pick a product
    name and organization name, and add an organization identifier in reverse DNS
    style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reverse DNS style means to take a website that you or your company owns and
    reverse the order of the domain name components. So, for example, [http://maps.google.com](http://maps.google.com)
    becomes `com.google.maps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9408b6c-f725-42c2-819e-38505ba39b10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Options for a new project
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the preceding choices as not all of them may be selected by
    default. For this recipe, the ones that are important to us are **Interface**
    and **Include Tests**, both of which we'll cover later on this in the chapter
    when we look at unit testing with XCTest and user interface testing with XCUITest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve chosen a save location on your Mac, you will be presented with
    the following Xcode layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5faac001-b8c2-4ba1-8e15-2c701e61a944.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – New project template
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have the start of our project – it's not much, but it's where all new
    iOS apps begin.
  prefs: []
  type: TYPE_NORMAL
- en: From this menu, press **Product** | **Run**. Xcode will now compile and run
    your app in a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing from a previous recipe, we''ll build our app based on data that
    is returned from the Public GitHub API:'
  prefs: []
  type: TYPE_NORMAL
- en: In the File Explorer, click on Main.storyboard; this view is a representation
    of what the app will look like and is called Interface Builder. At the moment,
    there is only one blank screen visible, which matches what the app looked like
    when we ran it earlier. This screen represents a `View Controller` object; as
    the name suggests, this is an object that controls views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will display our list of repositories in a table. We actually want to create
    a view controller class that is a subclass of `UITableViewController`. So, from
    the menu, choose File, then New, and select a Cocoa Touch Class template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d3b6cd05-c7f8-45d7-84dc-41449151fb0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – New file template
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be displaying repositories in this view controller, so let''s call
    it `ReposTableViewController`. Specify that it''s a subclass of `UITableViewController`
    and ensure that the language is Swift:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f93a8a2-25f9-4865-9869-05a4e38af8b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – New filename and subclass
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our view controller class, let's switch back to `Main.storyboard`
    and delete the blank view controller that was created for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the object library, find the Table View Controller option and drag it
    into the Interface Builder editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7c67a2b-ea93-4e2a-ab48-86624c08414d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Object library
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a table view controller, we want this controller to be part
    of our custom subclass. To do this, select the controller, go into the class inspector,
    enter `ReposTableViewController` as the Class type, and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e95442cb-b8d9-4c44-966f-872d167a4451.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Custom class inspector'
  prefs: []
  type: TYPE_NORMAL
- en: Although we have the view controller that will be displaying the repository
    names, when a user selects a repository, we want to present a new view controller
    that will show details about that particular repo. We will cover what type of
    view controller that is and how we present it shortly, but first, we need a mechanism
    for navigating between view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have ever used an iOS app, you will be familiar with the standard ***push***
    and ***pop*** way of navigating between views. The following screenshot shows
    an app in the middle of that transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5200aebe-b4c3-4185-85a2-be040038a1a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Push and pop view controller
  prefs: []
  type: TYPE_NORMAL
- en: 'The management of these view controllers, as well as their presentation and
    dismissal transitions, are handled by a navigation controller, which is provided
    by Cocoa Touch in the form of `UINavigationController`. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: To place our view controller inside a navigation controller, select `ReposTableViewController`
    in Interface Builder. Then, from the Xcode menu, go to Editor and then Embed In
    and choose Navigation Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will add a navigation controller to the storyboard and set the selected
    view controller as its root view controller (*if there is an existing v**iew con**troller*
    *already inside the storyboard from the initial project we created, this can be
    highlighted and deleted*).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to define which view controller is initially on the screen when
    the app starts. Select Navigation Controller on the left-hand side of the screen
    and within the property inspector, select Is Initial View Controller. You will
    see that an entry arrow will point toward the navigation controller on the left,
    indicating that it will be shown initially.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this set up, we can start working on our `ReposTableViewController` by
    selecting it from the File navigator menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we created our view controller, the template gave us a bunch of code, with
    some of it commented out. The first method that the template provides is `viewDidLoad`.
    This is part of a set of methods that cover the life cycle of the root view that
    the view controller is managing. Full details about the view life cycle and its
    relevant method calls can be found at [http://swiftbook.link/docs/vc-lifecycle](http://swiftbook.link/docs/vc-lifecycle).
  prefs: []
  type: TYPE_NORMAL
- en: '`viewDidLoad` is fired quite early on in the view controller''s life cycle
    but before the view controller is visible to the user. Due to this, it is a good
    place to configure the view and retrieve any information that you want to present
    to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give the view controller a title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you Build and Run the app, you'll see a navigation bar with the title
    we just added programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll fetch and display a list of GitHub repositories. Implement the
    following snippet of code in order to fetch a list of repos for a specific user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the following highlighted code to the top of the file, before the
    start of the class definition. We will also add a session property to the view
    controller, which is needed for the network request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may notice something a little different about the preceding functions since
    we're now making full use of Swift's **Codable** protocol. With Codable, we can
    map the JSON response from our API straight to our struct models, without the
    need to convert this into a dictionary and then iterate each key-value pair to
    a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our table view, each row of the table view will display the name of
    one of the repositories that we retrieve from the GitHub API. We need a place
    to store the repositories that we retrieve from the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `repos` array has an initially empty array value, but we will use this property
    to hold the fetched results from the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to fetch the repository data right now. So, instead, we''ll
    learn how to provide data to be used in the table view. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a couple of fake repositories so that we can temporarily populate
    our table view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The information in a table view is populated from the table view's data source,
    which can be any object that conforms to the `UITableViewDataSource`
  prefs: []
  type: TYPE_NORMAL
- en: protocol.
  prefs: []
  type: TYPE_NORMAL
- en: When the table view is displayed and the user interacts with it, the table view
    will ask the data source for the information it needs to populate the table view.
    For simple table view implementations, it is often the view controller that controls
    the table view that acts as the data source. In fact, when you create a subclass
    of `UITableViewController`, as we have, the view controller already conforms to
    `UITableViewDataSource` and is assigned as the table view's data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the methods defined in `UITableViewDataSource` were created as part
    of the `UITableViewController` template; the three we will take a look at are
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Data in a table view can be divided into sections, and information is presented
    in rows within those sections; information is referenced through an `IndexPath`
    that consists of a section integer value and a row integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that the data source methods ask us to provide is the number
    of sections that the table view will have. Our app will only be displaying a simple
    list of repositories, and as such, we only need one section, so we will return
    `1` from this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we have to provide is the number of rows the table view should
    have for a given section. If we had multiple sections, we could examine the provided
    section index and return the right number of rows, but since we only have one
    section, we can return the same number in all scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are displaying all the repositories we have retrieved, so the number of
    rows is simply the number of repositories in the `repos` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding two functions, we no longer use the `return` keyword.
    This is because, starting with Swift 5.1, you can now use ***implicit returns***
    in functions. As long as your function doesn't carry ambiguity about what should
    and should not be returned, the compiler can work this out for you. This allows
    for more streamlined syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have told the table view how many pieces of information to display,
    we must be able to display that information. A table view displays information
    in a type of view called `UITableViewCell`, and this cell is what we have to provide
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each index path within the section and row bounds that we have provided,
    we will be asked to provide a cell that will be displayed by the table view. A
    table view can be very large in size as it may need to represent a large amount
    of data. However, there are only a handful of cells that can be displayed to the
    user at any one time. This is because only a portion of the table view can be
    visible at any one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/380b9e3e-deeb-4714-8450-b1c62318e33c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Table view cell overview
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be efficient and prevent your app from slowing down as the user
    scrolls, the table view can reuse cells that have already been created but have
    since moved off-screen. Implementing cell reuse happens in two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering the cell's type with the table view with a reuse identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dequeuing a cell for a given reuse identifier. This will return a cell that
    has moved off-screen or create a new cell if none are available for reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How a cell is registered will depend on how it has been created. If the cell
    has been created and its subviews have also been laid out in the code, then the
    cell''s class is registered with the table view through this method on `UITableView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the cell has been laid out in `.xib` (usually called a "nib" for historical
    reasons), which is a visual layout file for views that''s similar to a storyboard,
    then the cell''s nib is registered with the table view through this method on
    `UITableView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, cells can be defined and laid out within the table view in a storyboard.
    One advantage of this approach is that there is no need to manually register the
    cell, as with the previous two approaches; registering with the table view is
    free. However, one disadvantage of this approach is that the cell layout is tied
    to the table view, so it can't be reused in other table views, unlike the previous
    two implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s layout our cell in the Storyboard since we will only be using it with
    one table view:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to our Main.storyboard file and select the table view in our `ReposTableViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the attributes inspector, change the number of prototype cells to `1`; this
    will add a cell to the table view in the main window. This cell will define the
    layout of all the cells that will be displayed in our table view. You should create
    a prototype cell for each type of cell layout you will need; we are only displaying
    one piece of information in our table view, so all our cells will be of the same
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a cell in the storyboard. The attributes inspector will switch to showing
    the attributes for the cell. The cell style will be set to custom, and often,
    this will be what you want it to be. When you are displaying multiple pieces of
    information in a cell, you will usually want to create a subclass of `UITableViewCell`,
    set this to be the cell's class in the class inspector, and then lay out subviews
    in this custom cell type. However, for this example, we just want to show the
    name of the repository. Due to this, we can use a basic cell style that just has
    one text label, without a custom subclass, so choose basic from the style dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to set the reuse identifier that we will use to dequeue the cell later,
    so type an appropriate string, such as `RepoCell`, into the reuse identifier box
    of the attributes inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/55156d4f-12b9-418f-806a-243ffe8ef104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Table view cell identifier
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a cell that is registered for reuse with the table view, we
    can go back to our view controller and complete our conformance with `UITableViewDataSource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `ReposTableViewController` contains some commented code that was created
    as part of the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can remove the `/* */` comment signifiers as we are ready
    to implement this method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This data source method will be called every time the table view needs to place
    a cell on-screen; this will happen the first time the table is displayed as it
    needs cells to fill the visible part of the table view. It will also be called
    when the user scrolls the table view in a way that will reveal a new cell so that
    it becomes visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the method''s definition, we can see that we are provided with the
    table view in question and the index path of the cell that is needed, and we are
    expected to return a `UITableViewCell`. The code provided by the template actually
    does most of the work for us; we just need to provide the reuse identifier that
    we set in the storyboard and set the title label of the cell so that we have the
    name of the correct repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The cell's `textLabel` property is optional because it only exists when the
    cell's style is not custom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve now provided everything the table view needs to display our repository
    information, let''s click on Build and Run and take a look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b43b056-b1b4-4e3f-a5d1-f10e2c7be73a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Our app's first run
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that we have our two test repositories displayed in our table view,
    let's replace our test data with real repositories from the GitHub API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added our `fetchRepos` method earlier, so all we need to do is call this
    method, set the results to our `repos` property, and tell our table view that
    it needs to reload since the data has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we did in the previous recipes, we fetched the repositories from the GitHub
    API and received a result enum informing us of whether this was a success or a
    failure. If it was successful, we store the resulting repository array in our
    `repos` property. Once we have handled the response, we call the `reloadData`
    method on `UITableView`, which instructs the table view to requery its source
    for cells to display.
  prefs: []
  type: TYPE_NORMAL
- en: We also provided a weak reference to `self` in our closure's capture list to
    prevent a retain cycle. You can find out more about why this is important in the
    *Closures* recipe of [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, there is an important consideration that needs to be addressed.
    The iOS platform is a multithreaded environment, which means that it can do more
    than one thing at once. This is critical to being able to maintain a responsive
    user interface, while also being able to process data and perform long-running
    tasks. The iOS system uses queues to manage this work and reserves the "main"
    queue for any work involving the user interface. Therefore, any time you need
    to interact with the user interface, it is important that this work is done from
    the main queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `fetchRepos` method presents a situation where this might not be true.
    Our `fetchRepos` method performs networking, and we provide closure to `URLSession`
    as part of creating a `URLSessionDataTask`, but there is no guarantee that this
    closure will be executed on the main thread. Therefore, when we receive a response
    from `fetchRepos`, we need to "dispatch" the work of handling that response to
    the main queue to ensure that our updates to the UI happen on the main queue.
    We can do this using the `Dispatch` framework, so we need to import that at the
    top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will be discussing multithreading and the `Dispatch` framework in greater
    depth in [Chapter 9](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml), *Performance
    and Responsiveness in Swift*.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Build and Run. After a few seconds, the table view will be filled with
    the names of various repositories from the GitHub API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have repositories being displayed to the user, the next piece of
    functionality we'll implement for our app is the ability to tap on a cell and
    have it display the repository's GitHub page in a WebView.
  prefs: []
  type: TYPE_NORMAL
- en: Actions triggered by the table view, such as when a user taps on a cell, are
    provided to the table view's delegate, which can be anything that conforms to
    `UITableViewDelegate`. As was the case with the table view's data source, our
    `ReposTableViewController` already conforms to `UITableViewDelegate` because it
    is a subclass of `UITableViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the documentation for the `UITableViewDelegate` protocol,
    you will see a lot of optional methods; this documentation can be found at [https://developer.apple.com/reference/uikit/uitableviewdelegate](https://developer.apple.com/reference/uikit/uitableviewdelegate).
    The one that''s relevant for our purposes is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be called on the table view''s delegate whenever a cell is selected
    by the user, so let''s implement this in our view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For the functionality it provides, we will use `SFSafariViewController`, passing
    it the repository''s URL. Then, we will pass that view controller to the `show`
    method, which will present the view controller in the most appropriate way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to `import SafariServices` at the top of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Build and Run, and once the repositories are loaded, tap on one of
    the cells. A new view controller will be pushed onto the screen, and the relevant
    repository web page will load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations – you've just built your first app and it looks great!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, our app fetches repositories from a specific, hardcoded GitHub username.
    It would be great if, rather than hardcoding the username, the user of the app
    could enter the GitHub username that the repositories will be retrieved for. So,
    let''s add this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a way for the user to enter their GitHub username; the most appropriate
    way to allow a user to enter a small amount of text is through the use of `UITextField`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the main storyboard, find Text Field in the object library, drag it over
    to the main window, and drop it on the navigation bar of our `ReposTableViewController`.
    Now, you need to increase the width of the Text Field. For now, just hard code
    this to around 300px by highlighting the respective Text Field and selecting the
    Size Inspector option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c8836cdf-8f9e-4a45-8790-756f56c5b899.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Adding a UITextField
  prefs: []
  type: TYPE_NORMAL
- en: Like a table view, `UITextField` communicates user events through a delegate,
    which needs to conform to `UITextFieldDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch back to `ReposTableViewController` and add conformance to `UITextFieldDelegate`;
    it is a common practice to add protocol conformance to an extension, so add the
    following at the bottom of `ReposTableViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With this conformance in place, we need to set our view controller to be the
    delegate of `UITextField`. Head back over to the main storyboard and select the
    text field, and then open the Connections Inspector. You will see that the text
    field has an outlet for its delegate property. Now, click, hold, and drag from
    the circle next to our delegate over to the symbol representing our Repos Table
    View Controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75b53f88-549f-4969-a485-95fbee819449.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – UITextField with IBOutlet
  prefs: []
  type: TYPE_NORMAL
- en: 'The delegate outlet should now have a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f9c8af2-5e15-471b-89ba-69cdbc7ee805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – UITextField delegate outlet
  prefs: []
  type: TYPE_NORMAL
- en: By taking a look at the documentation for `UITextFieldDelegate`, we can see
    that the `textFieldShouldReturn` method is called when the user presses the *Return*
    button on their keyboard after entering text, so this is the method we will implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch back to our `ReposViewController` and implement this method in
    our extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since repositories will be fetched here instead of when the view is loaded,
    let''s move the code from `viewDidLoad` to this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Cocoa Touch implements the programming design pattern **MVC**, which stands
    for **Model View Controller**; it is a way of structuring your code to keep its
    elements reusable, with well-defined responsibilities. In the MVC pattern, all
    code related to displaying information falls broadly into three areas of responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model** objects hold the data that will eventually be displayed on the screen;
    this might be data that was retrieved from the network or device, or that was
    generated when the app was running. These objects may be used in multiple places
    in the app, where different view representations of the same data may be required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View** objects represent the UI elements that are displayed on the screen;
    these may just display information that they are provided, or capture input from
    the user. View objects can be used in multiple places where the same visual element
    is needed, even if it is showing different data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller** objects act as bridges between the models and the views; they
    are responsible for obtaining the relevant model objects and for providing the
    data to be displayed to the right view objects at the right time. Controller objects
    are also responsible for handling user input from the views and updating the model
    objects as needed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c2ca3f73-1840-4f2a-b193-94407bbf5319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – MVC overview
  prefs: []
  type: TYPE_NORMAL
- en: 'With regards to displaying web content, our app provides us with a number of
    options for presenting web content:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WKWebView`, provided by the WebKit framework, is a view that uses the latest
    rendering and JavaScript engine for loading and displaying web content. While
    it is newer, it is less mature in some respects and has issues with caching content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SFSafariViewController`, provided by the `SafariServices` framework, is a
    view controller that displays web content, and also provides many of the features
    that are available in Mobile Safari, including sharing and adding to reading lists
    and bookmarks. It also provides a convenient button for opening the current site
    in Mobile Safari.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we need to do is dismiss the keyboard. Cocoa Touch refers to
    the object that is currently receiving user events as the first responder. Currently,
    this is the text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s the act of the text field becoming the first responder that caused the
    keyboard to appear on-screen. Therefore, to dismiss the keyboard, the text field
    just needs to resign its place as first responder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, click on Build and Run. At this point, you can enter any GitHub account
    name in the text field to retrieve a list of its public repositories. Note that
    if your Xcode simulator doesn't have the "soft keyboard" enabled, you can just
    press *Enter* on your physical keyboard to search for the repo.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information regarding what was covered in this recipe, please refer
    to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apple Documentation for GCD**: [https://developer.apple.com/documentation/dispatch](https://developer.apple.com/documentation/dispatch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apple Documentation UIKit**: [https://developer.apple.com/documentation/uikit](https://developer.apple.com/documentation/uikit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit and integration testing with XCTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It goes without saying that testing plays a massive part of the software development
    life cycle. Primarily, a lot of the focus is on physical user testing – putting
    your piece of code in the hands of those using it day in day out. To a degree,
    this should be one of our main focuses, but what about testing what **we**, as
    software developers do? How do we test and check the integrity of our codebase?
  prefs: []
  type: TYPE_NORMAL
- en: This is where unit and integration testing comes in. In this recipe, we'll cook
    up a unit and integration test for our previously written Cocoa Touch app. This
    will be written entirely in Swift using the Xcode IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in our existing CocoaTouch project, in the **File inspector**, look for
    a folder called `CocoaTouchTest`. Expand this and select the `CocoaTouchTests.swift`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this file, you'll notice a class named `CocoaTouchTests`, which, in turn,
    inherits from the `XCTestCase` class. `XCTestCase` offers a suite of functions
    that we can use when writing out our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly is a unit test? Well, it's a test (or in our case, just a function)
    that checks that another function is doing what it's supposed to be doing. Writing
    tests or functions using XCTestCase allows us to not only use the previously mentioned
    suite of helpers but also allows Xcode to visualize and report on metrics such
    as test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let's get stuck into cooking up our first unit test! In the `CocoaTouchTests.swift`
    file, you'll see some override functions that have already been generated by Xcode.
    Just ignore these for now; we'll work on them as/when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, let's go through this one bit at a time. We'll start with the `testThatRepoIsNotNil`
    function. The common practice when naming a unit test is for the name to be as
    descriptive as possible. Depending on your coding standard, you can choose to
    either camel case these or snake case them (I much prefer camel case), but when
    writing tests with Xcode, you always have to prefix these with the word "test".
  prefs: []
  type: TYPE_NORMAL
- en: So, what are we testing? Here, we're checking that our repo array is not nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at our `ReposTableViewController`, you''ll remember that we instantiated
    our "repo" model where the variable was declared, so this is a great test to start
    with. Let''s say someone tries to change this to an optional, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If this happens, the code in our CocoaTouch App will compile, but the test will
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at our test. Note that the function we''re calling
    to check our repo model is `viewControllerUnderTest`. This is how we access our
    `RepoTableViewContoller`. We can achieve this by adding the following class-level
    variable to our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to instantiate this. Add the following override method from `XCTestCase`
    to your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When running your unit test for this particular class, `setUp()` will run prior
    to any of your test cases running, allowing you to prep anything you may need,
    such as instantiating a class. Once the tests are complete and you want to free
    anything up or close anything down, you can simply do this with the `tearDown()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: This was and is a very basic test, but the main purpose here was not necessarily
    to look at testing practice, but how we'd do that in Swift. However, before we
    go any further, let's take a look at the `Assert` options that are available to
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we used `XCTAssertNotNil`, which worked perfectly for our scenario.
    However, the following options are also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These are just a handful of the common ones and they are pretty self-explanatory
    – an added bonus is that each one has an optional parameter of "message", which
    allows you to add a custom string. This allows you to be more specific about the
    assertion that took place (ideal for reporting in a CI/CD world).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the basics of how to write tests in Swift, we need to
    learn how to run them. There are two ways we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can run all the tests in our class in one go. We can do this by simply
    clicking on the diamond to the left of the class''s declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc143851-1a69-4c14-b320-93d3c37b6ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Class test case
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to run tests individually, then we can simply select the icon next
    to our individual test case, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ff0c578-0aab-4e37-b46e-94bb1a3c9b71.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Method test case
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes to plan and our tests pass, we''ll see the icon turn green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eeda5573-4e31-4556-adf9-05c74b748c63.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Method passed test case
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if one or more of the tests in our class fail, we''ll see the icon
    turn red:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fb7bb17-8232-46b9-b085-5a13e08034d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Method failed test case
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the keyboard shortcut of *CMD* + *U* will also get Xcode to run
    any tests associated with the main project. Remember, only functions that start
    with the word `test` will be treated as a test case (excluding the class name),
    so feel free to add a private function in your test case should you need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at how we would test networking logic in Swift using
    mock data to help us out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating the following test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by figuring out how we are going to call this. Once again, we''ll
    take advantage of our `viewControllerUnderTest` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This works as expected, but unfortunately, it's not that simple – this will
    simply call the API just like our app would. If we were to add any XCAsserts inside
    our code, they wouldn't be executed as our test and function will have finished
    and been torn down before the API has a chance to respond.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to mock some objects in our `viewControllerUnderTest`,
    starting with **URLSession** and **URLSessionDataTask**. So, why do we need to
    mock these two? Let''s start by taking a look at where we use them in our CocoaTouch
    app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using **URLSession** and one of its functions, **URLSessionDataTask**,
    by mocking URLSession. We're creating our own local session here that we can then
    use to call our `MockURLSessionDataTask`. So, the real question here is, what
    is our `MockURLSessionDataTask` doing? We're using this to pass in some mock data
    – data that we should expect from the API – and then running this through our
    logic. This guarantees the integrity of our tests every time!
  prefs: []
  type: TYPE_NORMAL
- en: 'We could create the following input in our own files, but for now, we''ll just
    append them to the bottom of our `CocoaTouchTests.swift` file. First, let''s look
    at our `MockURLSession`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is pretty self-explanatory – we simply override the
    `dataTask()` function with the following `MockURLSessionDataTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this looks a little complex, but all we are really doing here
    is adding our own `completionHandler`. This will allow it to be called synchronously
    from our test (stopping our test from running away with us).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this all together and head back over to our new test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by setting our `MockURLSession` for our `viewControllerUnderTest`.
    This is nice and simple. Now, line by line, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by adding in our main `responseObject`. This is what we are going
    to perform our XCAsserts against. Declare this as an optional variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call our function, much like we tried to earlier in this section.
    However, this time, we''ll assign the result to a variable and cast this as a
    `MockURLSessionDataTask`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we can pass in anything we want for the `userName` variable as
    we''re not going to be calling the API. Now, let''s fire the completion handler
    we created and force through our `mockData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve highlighted the `mockData` variable in the preceding code as we''ll need
    to add this to the JSON response we want to test against. You can get this by
    simply visiting the GitHub URL and copying this into a new, **empty** file in
    the project. I did this for my username and created a file called `mock_Data.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4c007ba-be6e-4948-8499-23dbba2adc0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Adding an empty file
  prefs: []
  type: TYPE_NORMAL
- en: Remember to select the CocoaTouch target when you're saving the file to disk;
    otherwise, the following steps won't work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a computed property in our `Test` class that simply reads in the
    file and spits out the `Data()` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can successfully pass our mock data through our `fetchRepos`
    function without the need to call the API. All we need to do now is write some
    asserts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What you test for here is really up to you – it's all based on the test cases
    you choose. Sometimes, thinking about what to test when you've already written
    a function can be a hard task. As a developer, it is easy for you to get "too
    close" to the project. This is where **test-driven development** (**TDD**) comes
    in, a methodology for writing tests prior to writing any code at all. Let's take
    a look at this and what we can achieve with it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing networking logic can be troublesome. I find that questions always arise,
    such as, what should you test? What exactly is being tested? However, if you can
    get your head around this, then you're well on your way to understanding the core
    fundamentals of unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try and break this down. The logic we want to test is our `fetchRepos()`
    function. This is easy – we just call it with a repository username that we know
    and write some XCAsserts against the list of repos that come back.
  prefs: []
  type: TYPE_NORMAL
- en: While that will work for now, what happens when the user removes a repo? Your
    test will fail. This isn't good because your logic is not actually flawed – it's
    just the data that is wrong, much like if the API decided to return some malformed
    JSON due to an internal server error. This isn't your code's fault – it's the
    API's fault, and it's the API's job to make sure that it works.
  prefs: []
  type: TYPE_NORMAL
- en: All you want to do is check that if the server gives you a specific response,
    with a specific piece of data, your logic does what it says it should do. So,
    how can we guarantee the integrity of the data coming back from an API? We can't
    – that's why we mock the data ourselves and, in turn, don't actually call the
    service at all.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD is a methodology that includes writing your unit test first, prior to actually
    writing your desired function. Some believe this is the only way to write code,
    while others preach about its usage when – and only when – necessary. For the
    record, I do the latter, but we're not here to get into the theory – we'll here
    to learn how to achieve this in Swift using XCTest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our CocoaTouch app, let''s say we''d like to write a function
    that validates UITextField for whitespaces. Perform the following steps to achieve
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by writing out the stub function, which will look something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Normally, here, I would litter my function with comments about what I'd like
    to achieve, but for TDD, we're going to do this the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back inside the `CocoaTouchTests.swift` file, add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Again, taking the name of our test as a literal description, we're going to
    check that our function correctly detects whitespaces in the middle of a `String()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write a test against the current function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With that, we're happy we've asserted everything we set out to do in our test
    cases. Now, we can go ahead and run our test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As expected, our test failed, which is obvious for two reasons. First, we didn't
    really write up our function, and second, we hardcoded the return type as **false**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We actually hardcoded the return type as false on purpose – we did this as
    the TDD methodology is done in three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fail test**: *Done, we did that.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pass test**: *Can be as messy as you like.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactor cod**e: *We can do this with the utmost confidence.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The idea is to write your unit test while covering all the scenarios and asserts
    that may be required for that test case and make it fail (like we did).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the foundation set up, we can now confidently move over to our function
    and code away, safe in the knowledge that we''ll be able to run our test to check
    if our function is broken or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is nothing special, but for the purpose of this section, it doesn't need
    to be. TDD with Swift doesn't have to be daunting. After all, it's just a methodology
    that works perfectly well with XCTest.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find out more information about **unit testing** at [https://developer.apple.com/documentation/xctest](https://developer.apple.com/documentation/xctest).
  prefs: []
  type: TYPE_NORMAL
- en: User interface testing with XCUITest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**User interface** (**UI**) testing has been around for a while. In theory,
    it''s done every day by any one person who is using, testing, or checking an app,
    but in terms of automation, it''s had its fair share of critics.'
  prefs: []
  type: TYPE_NORMAL
- en: However, with Swift and XCTest, this has never been easier, and the beauty regarding
    how we will implement this has an amazing hidden benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike unit testing, when we are testing against a function, piece of logic,
    or algorithm, user interface tests are exactly what they say on the tin. They
    are a way for us to test the UI and UX of the app – things that might not have
    necessarily been generated programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Head on over to the `CocoaTouchUITests.swift` file that was automatically generated
    when we created our project. Again, much like the unit tests, you'll notice some
    placeholder functions in there. We'll start by taking a look at one called `testExample()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With what we mentioned in the *Getting ready* section in mind, let''s take
    a look at our app and see what we would like to test. The first thing that comes
    to my mind is the search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1926f57d-e978-4082-8a62-618bcb28b18a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Search bar selected
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve made this mandatory to populate in order for our app to work,
    we want to make sure this is here all the time, so let''s write a UI test for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As the comment correctly states, in order for the tests to be successful, the
    app needs to be launched, which is taken care of by the `launch()` function. However,
    once our app has been launched, how do we tell it to check for a UITextField and,
    more importantly, a specific one (in the future, we could have multiple on our
    screen)?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we must start with the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve edited the name of the function to make it more applicable to what we
    are testing here. As you can see from the following highlighted code, we''ve told
    our test to select the `textFields` element and tap it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and run the test by clicking on the diamond to the left to watch your
    app come to life in the simulator. If you're quick enough, you'll see the cursor
    enter the text box just before the app closes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great work! The test passed, which means you've written your first UI test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding our previous test, we weren''t specific about the element being identified.
    For now, this is okay, but building a much bigger and complex app may require
    that you test certain aspects of specific elements. Let''s take a look at how
    we could achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: One way would be to set an accessibility identifier for our UITextField – a
    specific identifier that's required for accessibility purposes that, in turn,
    will allow our UI test to identify the control we want to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back over in our `RepoTableViewController.swift` file, create an `IBOutlet`
    for the `UITextField` object in question and add the following code, remembering
    to hook up the outlet to your ViewController:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, comment out or replace our generic `UTextField` tap test
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, run your test and watch it pass. Great stuff!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that we are identifying a `textField` and then matching a control type
    from `textField`. This approach will work wonders when we''re testing for nested
    components in specific views of your app. For example, you might want to search
    and match for a specific UIButton that you know is embedded within a specific
    UIScrollView:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, let''s take our test a little further. Notice the **`.tap()`**
    function we''re calling at the end of our element identification. There''s plenty
    more options to choose from, but we''ll start by splitting the element into its
    own variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that''s we''ve removed the **`.tap()`** function. Now, we can simply
    call this and any other available function via our `textField` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this to see it in action for yourself. Now, what if we go a little further?
    Add the following line and run the code once more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, at this point, you can see where we are going. One thing to bear
    in mind is that, since we are not mocking data here, we're making a live, asynchronous
    API call, which, depending on your connection speed or the API, could vary from
    test to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the results, we need our UI test to "wait" for a specific element
    to come into view. By design, we know that we are expecting a `UITableView` with
    populated cells, so let''s write our test based on that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Line 1 of the preceding code should now be all but familiar to us – we're building
    an element based on cells within a UITableView (we're not being specific at the
    time) to look for a specific cell with a label of `XcodeValidateJson`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we're doing an XCAssert against this element. Allow for a timeout of 5
    seconds for this to appear. If it appears beforehand, the test will pass; if not,
    it will fail.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've seen how functions such as `.tap()` and **`.typeText()`** can
    be used when we're interacting with our app. However, these are not standard functions
    of a `UIButton` to `UITextField`. When we're identifying our controls, the return
    type we get back is that of an `XCUIElement()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more options available that we can use to enhance our UI tests, thus
    allowing for an intricate yet worthy automated test. Let''s take a look at some
    of the additional options available to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Each comes with additional parameters that allow you to be specific and cover
    all the aspects of your user experience in the app (for example, `press()` has
    a duration parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this section, I mentioned that UI tests come with a great
    additional benefit, and this is something we have seen already: accessibility.
    Accessibility is an important factor when building mobile apps, and Apple gives
    us the best possible tools to do this with Xcode and the Swift programming languages.
    However, from a theory perspective, if you take the time to build our accessibility
    into your app, you''re indirectly making it much easier to build and shape the
    UI test around these identifiers – almost doing a good 50% of the work for you
    – while including an amazing feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, writing a good UI test can lead to improved accessibility in
    your app, making it really easy to have one complement the other when building
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find more information about **XCUITest** at [https://developer.apple.com/documentation/xctest/xcuielement](https://developer.apple.com/documentation/xctest/xcuielement).
  prefs: []
  type: TYPE_NORMAL
- en: Backward compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backward compatibility is inevitable. Unless you build an app for the latest
    version of iOS and plan to support that – and only that – version of iOS, you're
    going to have to handle backward compatibility at some point. In this recipe,
    we'll take a look at what Apple offers in terms of building for APIs that have
    been built with older versions of Swift.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also take a look at migration options from previous versions of Swift
    and if and how legacy projects can be updated to their latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We all want to use the latest shiny features in our app. Luckily, Apple makes
    this relatively easy for us to handle with the use of the **#available** check.
    So, how does this work? Well, primarily, it can work in three ways: at the function
    level, at the class level, and at the inline API level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the latter and have a look at how we would do this at the
    API level:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of setting `maskedCorners` on a layer in `UIView()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is standard for APIs with iOS 11 and above, but what happens if your app
    supports iOS? In an ideal world, you only want to support two versions of iOS
    (including the current one), but that's not always possible. For example, in some
    retail apps, you may have an existing percentage of customers who you need to
    support. This also happens in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if your Xcode project has been set up to support iOS 10, you''ll actually
    get a generated error, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d93f73b2-3623-41bb-ac6c-7ada401eab53.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Available API error
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the red indicator to the left and you''ll see the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f0e79776-f5e0-4b63-9b2c-7958b90f4898.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Available API error options
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously we''ve got three options here: add a version check
    against the API itself, add a check against the method, or enclose the entire
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and click Fix for the first option. You''ll see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're given the option to compile the API for a specific version of iOS,
    allowing us to make use of the API and use a fallback or contingency API, should
    we want to.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great way to keep up to date with the latest changes that are being
    made to iOS and keep your code base fresh. However, this can come with some downsides.
    For example, if the API you've targeted is for a specific feature, you may find
    yourself struggling to find a suitable fallback (or worse, having to depend on
    a third-party library). You must also think about testing – you're potentially
    doubling your testing efforts when they may have only required a light regression
    test for earlier versions of iOS. Now, you'll have to make sure certain features
    are tested on multiple versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the **enclosing instance method**, which allows
    us to wrap a whole function around a specific version check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our function and its contents stay intact – we just decorate
    the function with the highlighted change.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all well and good, but let''s try calling this function from somewhere
    else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75b04ffa-7b06-4ad0-96a5-b415a0e61feb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Available method error options
  prefs: []
  type: TYPE_NORMAL
- en: That's right – we're met with the same problem that we came across earlier,
    but this does have some advantages. For example, if your function relies on a
    lot of code that has a higher API level – which would be a great way to maintain
    and manage your codebase – when the time comes to move up to higher SDK support,
    refactoring doesn't become a mammoth job.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final "enclosing class" option follows a similar approach to the method
    approach, except this occurs at the class level. Your class is simply decorated
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift has come in many shapes and sizes since its release in 2013, with each
    new version offering a wider range of APIs and stability. The move to open source
    has had a massive part to play in that too, but moving from one version to another
    with each release has often been aided with the help of Xcode's migration tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'But be warned: you can''t simply take an app build in Swift 1.1 and migrate
    this to Swift 5.3 with Xcode 12 (as nice as that would be...).'
  prefs: []
  type: TYPE_NORMAL
- en: Each release, from Swift 3.0 onward, allows you to migrate via the migration
    tool. For example, Xcode 9 would let you go from **Swift 2.2** to **Swift 3**,
    Xcode 10 would let you go from **Swift 3** to **Swift 4**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't mean you have to support the latest version of Swift with the latest
    version of Xcode – the upgrade options are backward compatible too.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our CocoaTouch project uses **Swift 5**, but options to use **Swift
    4.2** and **Swift 4** are available via Xcode''s Build Settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39949859-68a5-4454-894a-1ce3fb79915e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – Select Swift Language Version option
  prefs: []
  type: TYPE_NORMAL
- en: If you need to go back any further, you'll have to download a previous version
    of Xcode from the Apple Developer portal. More often than not, multiple versions
    of Xcode can play nicely together, although this was only really supported from
    Xcode 9 onward – you've been warned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find more information about **Swift Version History** at [https://www.javatpoint.com/history-of-swift](https://www.javatpoint.com/history-of-swift).
  prefs: []
  type: TYPE_NORMAL
