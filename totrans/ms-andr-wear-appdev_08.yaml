- en: Chapter 8. Creating Custom UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"I have said that she had no face, but that meant she had a thousand
    faces."*                                                                     
                        |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*C. S. Lewis* |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, we will cover the design principles that are central to the
    Android Wear UI spaces and go over a few common Wear UI patterns. We then extend
    the `OnThisDay` activity to present the feed in a user-friendly format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code accompanying this chapter is available for reference on GitHub ([https://github.com/siddii/mastering-android-wear/tree/master/Chapter_8](https://github.com/siddii/mastering-android-wear/tree/master/Chapter_8)).
    For the sake of brevity, only code snippets are included as needed. The reader
    is encouraged to download the referenced code from GitHub and follow along as
    they progress through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Android Wear UI design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, it should be clear to us that wearable apps cannot always follow the
    same UI patterns that their handheld counterparts might. Wearable devices have
    a significantly smaller form factor and interacting with them places heavier constraints
    on user actions. For this reason, the Android Wear user interface APIs are functionally
    divided into *Suggest* functions and *Demand* functions.
  prefs: []
  type: TYPE_NORMAL
- en: The *Suggest* functions are embodied by the `Context` stream—a stream of information
    presented in a manner that is proactive and suggestive. Users are shown a vertical
    list of informational cards, which can be scrolled through until the user wishes
    to interact with a specific card.
  prefs: []
  type: TYPE_NORMAL
- en: The *Demand* functions are reflected in the cue card metaphor. A cue card can
    be opened by saying **OK Google**, or, we can open it by tapping on the background
    of the home screen. Each voice command activates a type of voice intent, which
    in turn can be associated with multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: When presented with intent, the user will have the opportunity to choose which
    application they would like the intent activated for. Applications can respond
    by adding/updating a stream card or launching another application.
  prefs: []
  type: TYPE_NORMAL
- en: Common UI patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will touch upon the most commonly implemented UI patterns in Android Wear
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cards that are displayed in the Context stream can be standard notifications,
    single-action cards, or an expandable stack that groups related notifications
    together. In each case, an icon located at the top-right edge of the card indicates
    the application that the card is associated with.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a single notification card does not suffice and more details
    may be needed. A swipe from right to left can reveal detail cards in addition
    to the main Context stream card. A swipe from left to right on a card causes it
    to be removed from the Context stream.
  prefs: []
  type: TYPE_NORMAL
- en: It is noteworthy that notifications dismissed on the wearable will cause them
    to be dismissed on a paired handheld as well due to the synchronized state shared
    by paired devices.
  prefs: []
  type: TYPE_NORMAL
- en: A card can optionally display action buttons to the right of detail cards. These
    actions may run on the wearable itself. Alternatively, they may be delegated to
    the companion handheld or they can cause a full-screen activity to run.
  prefs: []
  type: TYPE_NORMAL
- en: Countdowns and confirmations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user taps on an action button shown to the right of a detail card, the
    system can display a confirmation animation when the action completes.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it may be desired to give the user a chance to interrupt an action
    before it executes. One way to address this is to display a customizable countdown
    animation prior to the action invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Some actions may be critical in nature and it may be desired to highlight this
    by showing the user a confirmation step. The user would then have to confirm their
    intention to execute the action.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we should always weigh the option to delegate any heavy lifting
    work to the companion handheld whenever it is possible to do so. If this is the
    case for an action invoked on a card in the Context stream, then we may choose
    to display an animation on the wearable once the action button has been tapped
    by the user and the corresponding app has been launched on the handheld device.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the option to have on-card actions. These are actions that execute
    on the card itself. These are ideal when there is only one possible action that
    a tap can have. For instance, a car icon displaying on a notification showing
    an address can only imply directions and is thus a good candidate to be an on-card
    action. An on-card action should be unambiguous in its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative (that is, when there are multiple possible actions) is to invoke
    them via action buttons to the right of a detail card. For instance, in the case
    of a person's name, an on-card action is ambiguous, so separate action buttons
    would work better, for example, for actions such as call, e-mail, show details,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Card stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some cards may be related and it makes sense to group them together in a stack.
    For instance, to display new mail notifications, a card stack can group all new
    mail notifications together.
  prefs: []
  type: TYPE_NORMAL
- en: Users would click on the card stack to make it fan out and display the top edge
    of each card in the stack. Further tapping on a fanned-out card will open the
    card to its fully expanded state in the vertical list that is the Context stream.
  prefs: []
  type: TYPE_NORMAL
- en: When the user swipes vertically away from a card stack, all the cards in the
    stack return to their fully collapsed state and the singular stack displays again
    in the Context stream.
  prefs: []
  type: TYPE_NORMAL
- en: 2D Pickers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 2D Picker is a flexible UI pattern used in Android Wear apps. It allows
    us to build one-dimensional lists of cards or two-dimensional grids of cards,
    as dictated by requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the direction of the scroll can be set as either horizontal or
    vertical. Data presented to the user is distributed across pages, and each page
    then corresponds to a card.
  prefs: []
  type: TYPE_NORMAL
- en: One intuitive presentation is to display a vertical list of cards to the user
    comprising (say) results of a search. Each card in the vertical list presents
    a small amount of information, and more information can be obtained by scrolling
    horizontally from it to display subsequent cards containing the remaining pages
    of information.
  prefs: []
  type: TYPE_NORMAL
- en: The 2D Picker pattern is implemented by adding an instance of a `GridViewPager`
    element to the layout of the activity in question. This pager must then have an
    adapter set for it of the `GridPagerAdapter` type.
  prefs: []
  type: TYPE_NORMAL
- en: To make things simpler, an abstract class extending the `GridPageAdapter` class
    named `FragmentGridPageAdapter` defines the common behavior your adapter will
    need, so all you have to do is extend the `FragmentGridPageAdapter` class to implement
    your own adapter to provide a set of pages to populate the `GridViewPager` element
    with.
  prefs: []
  type: TYPE_NORMAL
- en: When using a 2D Picker presentation, we must ensure that we optimize it to get
    the speed. This can be done by keeping the cards simple and minimizing the number
    of cards in the picker.
  prefs: []
  type: TYPE_NORMAL
- en: The 2D Picker should be destroyed when the user makes a selection. Users may
    also initiate an exit from a 2D picker by swiping down on the first card or swiping
    right on a left-most card.
  prefs: []
  type: TYPE_NORMAL
- en: Selection lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a common pattern whereby possible choices are presented in a simple
    scrollable list. Users select an item from the list and thereby invoke an action.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Wear UI library provides an implementation of a list that is optimized
    for wearables, namely the `WearableListView` element. To create a list of this
    kind, you add a `WearableListView` element to your activity's layout definition and
    then set its adapter to an instance of your custom layout implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the OnThisDay activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that our initial implementation of the `OnThisDayActivity` activity from
    [Chapter 5](part0041.xhtml#aid-173721 "Chapter 5. Synchronizing Data"), *Synchronizing
    Data*, utilized a `TextView` method within a `ScrollView` method. Let's spruce
    that up using a few simple UI patterns we introduced in this chapter. We will
    intentionally keep this code simple to give you a chance to grasp the new API
    classes we use. You are encouraged to contrive use cases and experiment with more
    interesting patterns such as the 2D Picker.
  prefs: []
  type: TYPE_NORMAL
- en: Enough talk. It's time to write some code. We're now ready to improve our initial
    *On this day* feed presentation with a vertical list comprising cards. Each card
    can be dismissed by a swipe from left to right. The result is a far more usable
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The OnThisDayActivity activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following `showOnThisDay` method creates and sets up a `GridViewPager`
    instance that properly handles the layout depending on the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `DotsPageIndicator` is a page indicator for the `GridViewPager` class that
    helps to identify the current page with respect to the available pages on the
    current row. Dots represent pages; the current page can be distinguished by a
    dot of a distinct color and/or size.
  prefs: []
  type: TYPE_NORMAL
- en: The activity layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following activity layout shows the declaration of a `GridViewPage`r element where
    previously (in [Chapter 5](part0041.xhtml#aid-173721 "Chapter 5. Synchronizing
    Data"), *Synchronizing Data*) we had a `TextView` method within a `ScrollView`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We define an `OnThisDayGridPagerAdapter` class extending the `FragmentGridPagerAdapter`
    class. An instance of this class is set as the adapter attribute of the `GridViewPager`
    element. A private inner class named `Row` is used as a convenience container
    for Fragment objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the application and choose the **On this day…** activity, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity layout](img/image00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each item from the feed result is now presented as a card in a scrollable vertical
    list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity layout](img/image00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can take a look at the second example by just scrolling vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity layout](img/image00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over Android Wear design principles and surveyed the
    common UI patterns that the majority of wearable applications implement. We then
    put the API to use by writing some code to augment the **On this day...** activity
    of the `Today` app from [Chapter 5](part0041.xhtml#aid-173721 "Chapter 5. Synchronizing
    Data"), *Synchronizing Data*, with a `GridViewPager` component that displays a
    list of cards and lets the user interact with them.
  prefs: []
  type: TYPE_NORMAL
