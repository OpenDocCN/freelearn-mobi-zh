["```kt\nimport kotlin.concurrent.thread\n\nfun main(args: Array<String>) {\n   thread {\n      Thread.sleep(1000)\n      println(\"World!\")\n   }\n   print(\"Hello \")\n   Thread.sleep(2000)\n}\n```", "```kt\nfun main(args: Array<String>) {\n   val computation = thread {\n      Thread.sleep(1000)\n      println(\"World!\")\n   }\n   print(\"Hello \")\n   computation.join()\n}\n```", "```kt\nfun main(args: Array<String>) {\n   val threads = List(100){\n      thread {\n         Thread.sleep(1000)\n         print('.')\n      }\n   }\n   threads.forEach(Thread::join)\n}\n```", "```kt\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nfun main(args: Array<String>){\n   val executor = Executors.newFixedThreadPool(1024)\n   repeat(10000){\n      executor.submit {\n         Thread.sleep(1000)\n         print('.')\n      }\n   }\n   executor.shutdown() \n}\n```", "```kt\nimport kotlinx.coroutines.experimental.delay\nimport kotlinx.coroutines.experimental.launch\nimport kotlinx.coroutines.experimental.runBlocking\n\nfun main(args: Array<String>) = runBlocking {\n    launch {\n        delay(1000)\n        println(\"World\")\n    }\n    print(\"Hello \")\n    delay(2000)\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking {\n   val job = launch {\n      delay(1000)\n      println(\"World\")\n   }\n   print(\"Hello \")\n   job.join()\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking {\n      val jobs = List(10000) {\n         launch {\n            delay(1000)\n            print('.')\n         }\n      }\n      jobs.forEach { job -> job.join() }\n   }\n}\n```", "```kt\nenum class Gender {\n   MALE, FEMALE;\n\n   companion object {\n      fun valueOfIgnoreCase(name: String): Gender = valueOf(name.toUpperCase())\n   }\n}\n\ntypealias UserId = Int\n\ndata class User(val id: UserId, val firstName: String, val lastName: String, val gender: Gender)\n\ndata class Fact(val id: Int, val value: String, val user: User? = null)\n\ninterface UserService {\n   fun getFact(id: UserId): Fact\n}\n```", "```kt\ninterface UserClient {\n   fun getUser(id: UserId): User\n}\n\ninterface FactClient {\n   fun getFact(user: User): Fact\n}\n```", "```kt\nimport com.github.salomonbrys.kotson.*\nimport com.google.gson.GsonBuilder\nimport org.http4k.client.ApacheClient\n\nabstract class WebClient {\n   protected val apacheClient = ApacheClient()\n\n   protected val gson = GsonBuilder()\n         .registerTypeAdapter<User> {\n            deserialize { des ->\n               val json = des.json\n               User(json[\"info\"][\"seed\"].int,\n                     json[\"results\"][0][\"name\"][\"first\"].string.capitalize(),\n                     json[\"results\"][0][\"name\"][\"last\"].string.capitalize(),\n                     Gender.valueOfIgnoreCase(json[\"results\"][0][\"gender\"].string))\n\n            }\n         }\n         .registerTypeAdapter<Fact> {\n            deserialize { des ->\n               val json = des.json\n               Fact(json[\"value\"][\"id\"].int,\n                     json[\"value\"][\"joke\"].string)\n            }\n         }.create()!!\n}\n```", "```kt\nimport org.http4k.core.Method\nimport org.http4k.core.Request\n\nclass Http4KUserClient : WebClient(), UserClient {\n   override fun getUser(id: UserId): User {\n      return gson.fromJson(apacheClient(Request(Method.GET, \"https://randomuser.me/api\")\n            .query(\"seed\", id.toString()))\n            .bodyString())\n   }\n}\n```", "```kt\nclass Http4KFactClient : WebClient(), FactClient {\n   override fun getFact(user: User): Fact {\n      return gson.fromJson<Fact>(apacheClient(Request(Method.GET, \"http://api.icndb.com/jokes/random\")\n            .query(\"firstName\", user.firstName)\n            .query(\"lastName\", user.lastName))\n            .bodyString())\n            .copy(user = user)\n   }\n}\n```", "```kt\nclass MockUserClient : UserClient {\n   override fun getUser(id: UserId): User {\n      println(\"MockUserClient.getUser\")\n      Thread.sleep(500)\n      return User(id, \"Foo\", \"Bar\", Gender.FEMALE)\n   }\n}\n\nclass MockFactClient : FactClient {\n   override fun getFact(user: User): Fact {\n      println(\"MockFactClient.getFact\")\n      Thread.sleep(500)\n      return Fact(Random().nextInt(), \"FACT ${user.firstName}, ${user.lastName}\", user)\n   }\n}\n```", "```kt\ninterface UserRepository {\n   fun getUserById(id: UserId): User?\n   fun insertUser(user: User)\n}\n\ninterface FactRepository {\n   fun getFactByUserId(id: UserId): Fact?\n   fun insertFact(fact: Fact)\n}\n```", "```kt\nimport org.springframework.dao.EmptyResultDataAccessException\nimport org.springframework.jdbc.core.JdbcTemplate\n\nabstract class JdbcRepository(protected val template: JdbcTemplate) {\n   protected fun <T> toNullable(block: () -> T): T? {\n      return try {\n         block()\n      } catch (_: EmptyResultDataAccessException) {\n         null\n      }\n   }\n}\n```", "```kt\nimport org.springframework.jdbc.core.queryForObject\n\nclass JdbcUserRepository(template: JdbcTemplate) : JdbcRepository(template), UserRepository {\n   override fun getUserById(id: UserId): User? {\n      return toNullable {\n         template.queryForObject(\"select * from USERS where id = ?\", id) { resultSet, _ ->\n            with(resultSet) {\n               User(getInt(\"ID\"),\n                     getString(\"FIRST_NAME\"),\n                     getString(\"LAST_NAME\"),\n                     Gender.valueOfIgnoreCase(getString(\"GENDER\")))\n            }\n         }\n      }\n   }\n\n   override fun insertUser(user: User) {\n      template.update(\"INSERT INTO USERS VALUES (?,?,?,?)\",\n            user.id,\n            user.firstName,\n            user.lastName,\n            user.gender.name)\n   }\n}\n\nclass JdbcFactRepository(template: JdbcTemplate) : JdbcRepository(template), FactRepository {\n   override fun getFactByUserId(id: Int): Fact? {\n      return toNullable {\n         template.queryForObject(\"select * from USERS as U inner join FACTS as F on U.ID = F.USER where U.ID = ?\", id) { resultSet, _ ->\n            with(resultSet) {\n               Fact(getInt(5),\n                     getString(6),\n                     User(getInt(1),\n                           getString(2),\n                           getString(3),\n                           Gender.valueOfIgnoreCase(getString(4))))\n            }\n         }\n      }\n   }\n\n   override fun insertFact(fact: Fact) {\n      template.update(\"INSERT INTO FACTS VALUES (?,?,?)\", fact.id, fact.value, fact.user?.id)\n   }\n}\n```", "```kt\nfun initJdbcTemplate(): JdbcTemplate {\n   return JdbcTemplate(JdbcDataSource()\n         .apply {\n            setUrl(\"jdbc:h2:mem:facts_app;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false\")\n         })\n         .apply {\n            execute(\"CREATE TABLE USERS (ID INT AUTO_INCREMENT PRIMARY KEY, FIRST_NAME VARCHAR(64) NOT NULL, LAST_NAME VARCHAR(64) NOT NULL, GENDER VARCHAR(8) NOT NULL);\")\n            execute(\"CREATE TABLE FACTS (ID INT AUTO_INCREMENT PRIMARY KEY, VALUE_ TEXT NOT NULL, USER INT NOT NULL,  FOREIGN KEY (USER) REFERENCES USERS(ID) ON DELETE RESTRICT)\")\n         }\n}\n```", "```kt\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    block()\n    return this\n}\n```", "```kt\nclass MockUserRepository : UserRepository {\n   private val users = hashMapOf<UserId, User>()\n\n   override fun getUserById(id: UserId): User? {\n      println(\"MockUserRepository.getUserById\")\n      Thread.sleep(200)\n      return users[id]\n   }\n\n   override fun insertUser(user: User) {\n      println(\"MockUserRepository.insertUser\")\n      Thread.sleep(200)\n      users[user.id] = user\n   }\n}\n\nclass MockFactRepository : FactRepository {\n\n   private val facts = hashMapOf<UserId, Fact>()\n\n   override fun getFactByUserId(id: UserId): Fact? {\n      println(\"MockFactRepository.getFactByUserId\")\n      Thread.sleep(200)\n      return facts[id]\n   }\n\n   override fun insertFact(fact: Fact) {\n      println(\"MockFactRepository.insertFact\")\n      Thread.sleep(200)\n      facts[fact.user?.id ?: 0] = fact\n   }\n\n}\n```", "```kt\nclass SynchronousUserService(private val userClient: UserClient,\n                      private val factClient: FactClient,\n                      private val userRepository: UserRepository,\n                      private val factRepository: FactRepository) : UserService {\n\n   override fun getFact(id: UserId): Fact {\n      val user = userRepository.getUserById(id)\n      return if (user == null) {\n         val userFromService = userClient.getUser(id)\n         userRepository.insertUser(userFromService)\n         getFact(userFromService)\n      } else {\n         factRepository.getFactByUserId(id) ?: getFact(user)\n      }\n   }\n\n   private fun getFact(user: User): Fact {\n      val fact = factClient.getFact(user)\n      factRepository.insertFact(fact)\n      return fact\n   }\n}\n```", "```kt\nfun main(args: Array<String>) {\n\n   fun execute(userService: UserService, id: Int) {\n         val (fact, time) = inTime {\n            userService.getFact(id)\n         }\n         println(\"fact = $fact\")\n         println(\"time = $time ms.\")\n      }\n\n   val userClient = MockUserClient()\n   val factClient = MockFactClient()\n   val userRepository = MockUserRepository()\n   val factRepository = MockFactRepository()\n\n   val userService = SynchronousUserService(userClient,\n         factClient,\n         userRepository,\n         factRepository)\n\n   execute(userService, 1)\n   execute(userService, 2)\n   execute(userService, 1)\n   execute(userService, 2)\n   execute(userService, 3)\n   execute(userService, 4)\n   execute(userService, 5)\n   execute(userService, 10)\n   execute(userService, 100)   \n\n}\n```", "```kt\nimport kotlin.concurrent.thread\n\nclass CallbackUserClient(private val client: UserClient) {\n   fun getUser(id: Int, callback: (User) -> Unit) {\n      thread {\n         callback(client.getUser(id))\n      }\n   }\n}\n\nclass CallbackFactClient(private val client: FactClient) {\n   fun get(user: User, callback: (Fact) -> Unit) {\n      thread {\n         callback(client.getFact(user))\n      }\n   }\n}\n\nclass CallbackUserRepository(private val userRepository: UserRepository) {\n   fun getUserById(id: UserId, callback: (User?) -> Unit) {\n      thread {\n         callback(userRepository.getUserById(id))\n      }\n   }\n\n   fun insertUser(user: User, callback: () -> Unit) {\n      thread {\n         userRepository.insertUser(user)\n         callback()\n      }\n\n   }\n}\n\nclass CallbackFactRepository(private val factRepository: FactRepository) {\n   fun getFactByUserId(id: Int, callback: (Fact?) -> Unit) {\n      thread {\n         callback(factRepository.getFactByUserId(id))\n      }\n   }\n\n   fun insertFact(fact: Fact, callback: () -> Unit) {\n      thread {\n         factRepository.insertFact(fact)\n         callback()\n      }\n   }\n}\n```", "```kt\nclass CallbackUserService(private val userClient: CallbackUserClient,\n                    private val factClient: CallbackFactClient,\n                    private val userRepository: CallbackUserRepository,\n                    private val factRepository: CallbackFactRepository) : UserService {\n\n   override fun getFact(id: UserId): Fact {\n      var aux: Fact? = null\n      userRepository.getUserById(id) { user ->\n         if (user == null) {\n            userClient.getUser(id) { userFromClient ->\n               userRepository.insertUser(userFromClient) {}\n               factClient.get(userFromClient) { fact ->\n                  factRepository.insertFact(fact) {}\n                  aux = fact\n               }\n\n            }\n         } else {\n            factRepository.getFactByUserId(id) { fact ->\n               if (fact == null) {\n                  factClient.get(user) { factFromClient ->\n                     factRepository.insertFact(factFromClient) {}\n                     aux = factFromClient\n                  }\n               } else {\n                  aux = fact\n               }\n            }\n         }\n      }\n      while (aux == null) {\n         Thread.sleep(2)\n      }\n      return aux!!\n   }\n}\n```", "```kt\nimport java.util.concurrent.ExecutorService\nimport java.util.concurrent.Executors\n\nclass FutureUserService(private val userClient: UserClient,\n                  private val factClient: FactClient,\n                  private val userRepository: UserRepository,\n                  private val factRepository: FactRepository) : UserService {\n   override fun getFact(id: UserId): Fact {\n\n      val executor = Executors.newFixedThreadPool(2)\n\n      val user = executor.submit<User?> { userRepository.getUserById(id) }.get()\n      return if (user == null) {\n         val userFromService = executor.submit<User> { userClient.getUser(id) }.get()\n         executor.submit { userRepository.insertUser(userFromService) }\n         getFact(userFromService, executor)\n      } else {\n         executor.submit<Fact> {\n            factRepository.getFactByUserId(id) ?: getFact(user, executor)\n         }.get()\n      }.also {\n         executor.shutdown()\n      }\n   }\n\n   private fun getFact(user: User, executor: ExecutorService): Fact {\n      val fact = executor.submit<Fact> { factClient.getFact(user) }.get()\n      executor.submit { factRepository.insertFact(fact) }\n      return fact\n   }\n}\n```", "```kt\nimport nl.komponents.kovenant.Promise\nimport nl.komponents.kovenant.task\nimport nl.komponents.kovenant.then\n\nclass PromiseUserService(private val userClient: UserClient,\n                   private val factClient: FactClient,\n                   private val userRepository: UserRepository,\n                   private val factRepository: FactRepository) : UserService {\n\n   override fun getFact(id: UserId): Fact {\n\n      return (task {\n         userRepository.getUserById(id)\n      } then { user ->\n         if (user == null) {\n            task {\n               userClient.getUser(id)\n            } success  { userFromService ->\n               userRepository.insertUser(userFromService)\n            } then { userFromService ->\n               getFact(userFromService).get()\n            }\n         } else {\n            task { factRepository.getFactByUserId(id) ?: getFact(user).get() }\n         }\n      }).get().get()\n   }\n\n   private fun getFact(user: User): Promise<Fact, Exception> = task {\n      factClient.getFact(user)\n   } success  { fact ->\n      factRepository.insertFact(fact)\n   }\n}\n```", "```kt\nimport kotlinx.coroutines.experimental.Deferred\nimport kotlinx.coroutines.experimental.async\nimport kotlinx.coroutines.experimental.launch\nimport kotlinx.coroutines.experimental.runBlocking\n\nclass CoroutineUserService(private val userClient: UserClient,\n                     private val factClient: FactClient,\n                     private val userRepository: UserRepository,\n                     private val factRepository: FactRepository) : UserService {\n   override fun getFact(id: UserId): Fact = runBlocking {\n      val user = async { userRepository.getUserById(id) }.await()\n      if (user == null) {\n         val userFromService = async { userClient.getUser(id) }.await()\n         launch { userRepository.insertUser(userFromService) }\n         getFact(userFromService)\n      } else {\n         async { factRepository.getFactByUserId(id) ?: getFact(user) }.await()\n      }\n   }\n\n   private suspend fun getFact(user: User):Fact {\n      val fact: Deferred<Fact> = async { factClient.getFact(user) }\n      launch { factRepository.insertFact(fact.await()) }\n      return fact.await()\n   }\n}\n```", "```kt\nimport kotlinx.coroutines.experimental.*\n\nfun main(args: Array<String>) = runBlocking {\n   println(\"run blocking coroutineContext = $coroutineContext\")\n   println(\"coroutineContext[Job] = ${coroutineContext[Job]}\")\n   println(Thread.currentThread().name)\n   println(\"-----\")\n\n   val jobs = listOf(\n         launch {\n            println(\"launch coroutineContext = $coroutineContext\")\n            println(\"coroutineContext[Job] = ${coroutineContext[Job]}\")\n            println(Thread.currentThread().name)\n            println(\"-----\")\n         },\n         async {\n            println(\"async coroutineContext = $coroutineContext\")\n            println(\"coroutineContext[Job] = ${coroutineContext[Job]}\")\n            println(Thread.currentThread().name)\n            println(\"-----\")\n         },\n         launch(CommonPool) {\n            println(\"common launch coroutineContext = $coroutineContext\")\n            println(\"coroutineContext[Job] = ${coroutineContext[Job]}\")\n            println(Thread.currentThread().name)\n            println(\"-----\")\n         },\n         launch(coroutineContext) {\n            println(\"inherit launch coroutineContext = $coroutineContext\")\n            println(\"coroutineContext[Job] = ${coroutineContext[Job]}\")\n            println(Thread.currentThread().name)\n            println(\"-----\")\n         }\n   )\n\n   jobs.forEach { job ->\n      println(\"job = $job\")\n      job.join()\n   }\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking {\n\n   val job = launch {\n      repeat(1_000_000) {\n         launch(coroutineContext) {\n            delay(1000)\n            print('.')\n         }\n      }\n   }\n\n   job.join()\n}\n```", "```kt\nimport kotlinx.coroutines.experimental.delay\nimport kotlinx.coroutines.experimental.launch\nimport kotlinx.coroutines.experimental.runBlocking\n\nfun main(args: Array<String>) = runBlocking {\n    val result = CompletableDeferred<String>()\n\n   val world = launch {\n      delay(500)\n      result.complete(\"World (from another coroutine)\")\n   }\n\n   val hello =launch {\n      println(\"Hello ${result.await()}\")\n   }\n\n   hello.join()\n   world.join()\n}\n```", "```kt\nimport kotlinx.coroutines.experimental.channels.*\n\nfun main(args: Array<String>) = runBlocking<Unit> {\n   val channel = Channel<String>()\n\n   val world = launch {\n      delay(500)\n      channel.send(\"World (from another coroutine using a channel)\")\n   }\n\n   val hello = launch {\n      println(\"Hello ${channel.receive()}\")\n   }\n\n   hello.join()\n   world.join()\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking<Unit> {\n\n   val channel = Channel<Char>()\n\n   val jobs = List(1_000_000) {\n      launch {\n         delay(1000)\n         channel.send('.')\n      }\n   }\n\n   repeat(1_000_000) {\n      print(channel.receive())\n   }\n\n   jobs.forEach { job -> job.join() }\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking<Unit> {\n\n   val channel = Channel<Char>()\n\n   val sender = launch {\n      repeat(1000) {\n         delay(10)\n         channel.send('.')\n         delay(10)\n         channel.send(',')\n      }\n      channel.close()\n   }\n\n   for (msg in channel) {\n      print(msg)\n   }\n\n   sender.join()\n\n}\n```", "```kt\nfun dotsAndCommas(size: Int) = produce {\n   repeat(size) {\n      delay(10)\n      send('.')\n      delay(10)\n      send(',')\n   }\n}\n\nfun main(args: Array<String>) = runBlocking<Unit> {\n   val channel = dotsAndCommas(1000)\n\n   for (msg in channel) {\n      print(msg)\n   }\n}\n```", "```kt\ndata class Quote(val value: Double, val client: String, val item: String, val quantity: Int)\n\ndata class Bill(val value: Double, val client: String)\n\ndata class PickingOrder(val item: String, val quantity: Int)\n```", "```kt\nimport kotlinx.coroutines.experimental.CoroutineContext\n\nfun calculatePriceTransformer(coroutineContext: CoroutineContext, quoteChannel: ReceiveChannel<Quote>) = produce(coroutineContext) {\n   for (quote in quoteChannel) {\n      send(Bill(quote.value * quote.quantity, quote.client) to PickingOrder(quote.item, quote.quantity))\n   }\n}\n```", "```kt\nfun cheapBillFilter(coroutineContext: CoroutineContext, billChannel: ReceiveChannel<Pair<Bill, PickingOrder>>) = produce(coroutineContext) {\n   billChannel.consumeEach { (bill, order) ->\n      if (bill.value >= 100) {\n         send(bill to order)\n      } else {\n         println(\"Discarded bill $bill\")\n      }\n   }\n}\n```", "```kt\nsuspend fun splitter(filteredChannel: ReceiveChannel<Pair<Bill, PickingOrder>>,\n                accountingChannel: SendChannel<Bill>,\n                warehouseChannel: SendChannel<PickingOrder>) = launch {\n   filteredChannel.consumeEach { (bill, order) ->\n      accountingChannel.send(bill)\n      warehouseChannel.send(order)\n   }\n}\n```", "```kt\nsuspend fun accountingEndpoint(accountingChannel: ReceiveChannel<Bill>) = launch {\n   accountingChannel.consumeEach { bill ->\n      println(\"Processing bill = $bill\")\n   }\n}\n\nsuspend fun warehouseEndpoint(warehouseChannel: ReceiveChannel<PickingOrder>) = launch {\n   warehouseChannel.consumeEach { order ->\n      println(\"Processing order = $order\")\n   }\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking {\n\n   val quoteChannel = Channel<Quote>()\n   val accountingChannel = Channel<Bill>()\n   val warehouseChannel = Channel<PickingOrder>()\n\n   val transformerChannel = calculatePriceTransformer(coroutineContext, quoteChannel)\n\n   val filteredChannel = cheapBillFilter(coroutineContext, transformerChannel)\n\n   splitter(filteredChannel, accountingChannel, warehouseChannel)\n\n   warehouseEndpoint(warehouseChannel)\n\n   accountingEndpoint(accountingChannel)\n\n   launch(coroutineContext) {\n      quoteChannel.send(Quote(20.0, \"Foo\", \"Shoes\", 1))\n      quoteChannel.send(Quote(20.0, \"Bar\", \"Shoes\", 200))\n      quoteChannel.send(Quote(2000.0, \"Foo\", \"Motorbike\", 1))\n   }\n\n   delay(1000)\n   coroutineContext.cancelChildren()\n}\n```", "```kt\nimport kotlin.system.measureTimeMillis\n\nsuspend fun repeatInParallel(times: Int, block: suspend () -> Unit) {\n   val job = launch {\n      repeat(times) {\n         launch(coroutineContext) {\n            block()\n         }\n      }\n   }\n   job.join()\n}\n\nfun main(args: Array<String>) = runBlocking {\n   var counter = 0\n\n   val time = measureTimeMillis {\n      repeatInParallel(1_000_000) {\n         counter++\n      }\n   }\n   println(\"counter = $counter\")\n   println(\"time = $time\")\n}\n```", "```kt\nimport kotlinx.coroutines.experimental.*\n\nfun main(args: Array<String>) = runBlocking {\n   var counter = 0\n\n   val counterContext = newSingleThreadContext(\"CounterContext\")\n\n   val time = measureTimeMillis {\n      repeatInParallel(1_000_000) {\n         withContext(counterContext) {\n            counter++\n         }\n      }\n   }\n   println(\"counter = $counter\")\n   println(\"time = $time\")\n}\n```", "```kt\nimport java.util.concurrent.atomic.AtomicInteger\n\nfun main(args: Array<String>) = runBlocking {\n   val counter = AtomicInteger(0)\n\n   val time = measureTimeMillis {\n      repeatInParallel(1_000_000) {\n         counter.incrementAndGet()\n      }\n   }\n   println(\"counter = ${counter.get()}\")\n   println(\"time = $time\")\n}\n```", "```kt\nimport kotilnx.coroutines.experimental.sync.Mutex\nimport kotlinx.coroutines.experimental.sync.withLock\n\nfun main(args: Array<String>) = runBlocking {\n   val mutex = Mutex()\n   var counter = 0\n\n   val time = measureTimeMillis {\n      repeatInParallel(1_000_000) {\n         mutex.withLock {\n            counter++\n         }\n      }\n   }\n   println(\"counter = $counter\")\n   println(\"time = $time\")\n}\n```", "```kt\nimport kotlinx.coroutines.experimental.channels.actor\n\nsealed class CounterMsg\nobject IncCounter : CounterMsg()\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg()\n\nfun counterActor(start:Int) = actor<CounterMsg> {\n   var counter = start\n   for (msg in channel) {\n      when (msg) {\n         is IncCounter -> counter++\n         is GetCounter -> msg.response.complete(counter)\n      }\n   }\n}\n\n```", "```kt\nfun main(args: Array<String>) = runBlocking {\n   val counterActor = counterActor(0)\n\n   val time = measureTimeMillis {\n      repeatInParallel(1_000_000) {\n         counterActor.send(IncCounter)\n      }\n   }\n\n   val counter = CompletableDeferred<Int>()\n   counterActor.send(GetCounter(counter))\n   println(\"counter = ${counter.await()}\")\n   println(\"time = $time\")\n}\n```"]