- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Getting Started with WorkManager
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 WorkManager
- en: In Android, `WorkManager` is an API introduced by Google as part of the Android
    Jetpack library. It is a powerful and flexible background task scheduling library
    that allows you to perform deferrable, asynchronous tasks even when your app is
    not running or the device is in a low-power state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，`WorkManager` 是 Google 作为 Android Jetpack 库的一部分引入的 API。它是一个强大且灵活的后台任务调度库，允许您在您的应用未运行或设备处于低功耗状态时执行可延迟的异步任务。
- en: '`WorkManager` provides a unified API to schedule tasks that need to be executed
    at a specific time or under certain conditions. It takes care of managing and
    running tasks efficiently, depending on factors such as device idle state, network
    connectivity, and battery level.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager` 提供了一个统一的 API 来调度需要在特定时间或特定条件下执行的任务。它负责根据设备空闲状态、网络连接性和电池水平等因素高效地管理和运行任务。'
- en: Furthermore, `WorkManager` allows observation of work status and chain creation.
    This chapter will look into how we can implement `WorkManager` using examples
    and learn how it works and its use cases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`WorkManager` 允许观察工作状态和链式创建。本章将探讨如何通过示例实现 `WorkManager`，并学习其工作原理及其用例。
- en: 'In this chapter, we’ll be covering the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding the Jetpack `WorkManager` library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Jetpack `WorkManager` 库
- en: Understanding `WorkManager` state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `WorkManager` 状态
- en: Understanding threading in `WorkManager`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `WorkManager` 中的线程
- en: Understanding chaining and canceling work requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解链式和取消工作请求
- en: Implementing migration from Firebase `JobDispatcher` to the new recommended
    `WorkManager`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现从 Firebase `JobDispatcher` 迁移到新推荐 `WorkManager`
- en: How to debug `WorkManager`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调试 `WorkManager`
- en: Testing `Worker` implementations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 `Worker` 实现
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter utilizes step-by-step examples and does not create a complete project.
    `WorkManager` is helpful, but because the use case may vary, utilizing examples
    to see how the code fits your need is an excellent art to learn in programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用逐步示例，并不创建一个完整的项目。`WorkManager` 非常有用，但由于用例可能不同，利用示例来查看代码如何满足您的需求是学习编程中的一项优秀技能。
- en: Understanding the Jetpack WorkManager library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Jetpack WorkManager 库
- en: '**WorkManager** is one of the most powerful Jetpack libraries, and it is used
    for persistent work. The API allows observation of persistent status and the ability
    to create a complex chain of work. When building Android applications, it might
    be a requirement to have your data persist; if you need help to refresh your knowledge,
    you can reference[*Chapter 6*](B18827_06.xhtml#_idTextAnchor283), *Using the Room
    Database* *and Testing*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**WorkManager** 是最强大的 Jetpack 库之一，用于持久化工作。该 API 允许观察持久状态，并能够创建复杂的工作链。在构建 Android
    应用程序时，可能需要您的数据持久化；如果您需要帮助刷新您的知识，可以参考[*第 6 章*](B18827_06.xhtml#_idTextAnchor283)，*使用
    Room 数据库* *和测试*。'
- en: '`WorkManager` is the most-recommended API for any background process and is
    known to handle unique types of ongoing work as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager` 是任何后台进程最推荐的 API，并且已知可以处理如图所示的独特类型的工作：'
- en: '**Immediate**: As the name suggests, these are tasks that must be done immediately
    or completed soon'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立即执行**：正如其名所示，这些任务是必须立即完成或尽快完成的'
- en: '**Long-Running**: Tasks that run for a long time'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长时间运行**：运行时间较长的任务'
- en: '**Deferrable**: A task that can be rescheduled and can be assigned a different
    start time and can also run periodically'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可延迟的**：可以重新安排的任务，可以分配不同的开始时间，也可以定期运行'
- en: Some more sample use cases where you can use `WorkManager` are, for instance,
    if your company wants to create custom notifications, send analytics events, upload
    images, periodically sync your local data with the network, and more. Furthermore,
    `WorkManager` is the favored API and is highly recommended as it replaces all
    previous background scheduling APIs in Android.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `WorkManager` 的更多示例用例包括，例如，如果您的公司想要创建自定义通知、发送分析事件、上传图片、定期同步本地数据与网络，等等。此外，`WorkManager`
    是首选的 API，并且强烈推荐，因为它取代了 Android 中所有之前的后台调度 API。
- en: 'There are other APIs that are used for scheduling work. They are deprecated,
    and in this book, we will not cover them but will mention them since you might
    encounter them in work with legacy code; they are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他用于调度工作的 API。它们已被弃用，在这本书中，我们不会介绍它们，但会提及它们，因为您可能在处理遗留代码时遇到它们；它们如下：
- en: Firebase Job Dispatcher
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase Job Dispatcher
- en: Job Scheduler
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务调度器
- en: GCM `NetWorkManager`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCM `网络管理器`
- en: '`WorkManager`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkManager`'
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will go ahead and look at a simple example of how we can
    create our own custom notification using `WorkManager`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续查看一个简单的示例，说明我们如何使用`WorkManager`创建自己的自定义通知。
- en: You can also use the same concept to send logs or report analytics for your
    application if you are listening to any logs. We opt for this task because sending
    notifications to your users is crucial, and most applications do this, compared
    to uploading images. In addition, with Android 13 and the new API, it’s mandatory
    to request `android.permission.POST_NOTIFICATIONS`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在监听任何日志，您也可以使用相同的概念来发送应用程序的日志或报告分析。我们选择这个任务是因为向用户发送通知至关重要，而且大多数应用程序都会这样做，相比之下，上传图片的情况较少。此外，随着Android
    13和新的API，请求`android.permission.POST_NOTIFICATIONS`是强制性的。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For this recipe, you do not need to create a project, as the concepts can be
    used in an already-built project; instead, we will look at examples and walk through
    the examples with explanations:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，您不需要创建一个项目，因为可以在已经构建的项目中使用这些概念；相反，我们将查看示例，并带解释地走过这些示例：
- en: 'We will need to ensure we have the required dependency:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保我们有所需的依赖项：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can get the latest **version number** by following the documentation at
    [https://developer.android.com/jetpack/androidx/releases/work](https://developer.android.com/jetpack/androidx/releases/work).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查阅[https://developer.android.com/jetpack/androidx/releases/work](https://developer.android.com/jetpack/androidx/releases/work)上的文档来获取最新的**版本号**。
- en: 'Let us now go ahead and create our notification channel. For this, Google offers
    a great guide on how you can create one at [https://developer.android.com/develop/ui/views/notifications/channels](https://developer.android.com/develop/ui/views/notifications/channels),
    so copy the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在继续创建我们的通知通道。为此，谷歌提供了一个很好的指南，说明您如何在[https://developer.android.com/develop/ui/views/notifications/channels](https://developer.android.com/develop/ui/views/notifications/channels)创建一个，所以复制以下代码：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Also, note that creating different channels for separating notification types
    is possible. As recommended in Android 13, this makes it easier for users to turn
    them on and off if they do not need them. For example, a user might want to be
    aware of the latest brands your app is selling, compared to you sending your users
    info about old existing brands.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，创建不同的通道以区分通知类型是可能的。正如Android 13所推荐的那样，这使用户在不需要时更容易打开和关闭它们。例如，用户可能想了解您的应用程序正在销售的最新品牌，而不是您向用户发送有关现有品牌的旧信息。
- en: Now we can create our `workManagerInstance`. Let us think of a scenario where
    we need to fetch data from our servers every 20 or 30 mins and check whether notifications
    are available. In that case, we might encounter an issue where users are no longer
    using our application, which means the application will be put in the background,
    or the process might even be killed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的`workManagerInstance`。让我们考虑一个场景，我们需要每20或30分钟从我们的服务器获取数据，并检查是否有通知可用。在这种情况下，我们可能会遇到一个问题，即用户不再使用我们的应用程序，这意味着应用程序将被置于后台，或者进程甚至可能被终止。
- en: Hence the question becomes how do we fetch the data when the application is
    killed? This is when `WorkManager` comes to the rescue.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题变成了当应用程序被终止时我们如何获取数据？这就是`WorkManager`发挥作用的时候。
- en: 'We can now create an instance of `WorkManager`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建`WorkManager`的一个实例：
- en: '[PRE24]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will now need to go ahead and set the constraints:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要继续设置约束：
- en: '[PRE25]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will also need to set data to pass to the worker; hence we will create new
    value data, then we will put a string to the endpoint request:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要设置要传递给工作者的数据；因此，我们将创建新的值数据，然后我们将字符串放入端点请求中：
- en: '[PRE29]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can go ahead and create our `PeriodicWorkRequestBuilder<GetDataWorker>`.
    In our work, we will set the constraints, set our input data, and pass the `GetDataWorker()`
    type, which we will create and then build. Furthermore, since we want to be fetching
    the data every 20 or 30 mins from our server, we use `PeriodicWorkRequestBuilder<Type>()`
    for that purpose:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续创建我们的`PeriodicWorkRequestBuilder<GetDataWorker>`。在我们的工作中，我们将设置约束，设置我们的输入数据，并传递`GetDataWorker()`类型，我们将创建并构建它。此外，由于我们想要从服务器每20或30分钟获取数据，我们使用`PeriodicWorkRequestBuilder<Type>()`来达到这个目的：
- en: '[PRE31]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now finally call `workManagerInstance` and enqueue our job:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以最终调用`workManagerInstance`并排队我们的工作：
- en: '[PRE37]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now go ahead and construct our `GetDataWorker()`. In this class, we
    will extend the `Worker` class, which will override the `doWork()` function. In
    our case, however, instead of extending the `Worker` class, we will extend the
    `CoroutineWorker(context, workerParameters)`, which will help in our case since
    we will collect this data in a flow. We will also be using Hilt, so we will call
    `@HiltWorker`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以继续构建我们的 `GetDataWorker()`。在这个类中，我们将扩展 `Worker` 类，这将覆盖 `doWork()` 函数。然而，在我们的情况下，我们不会扩展
    `Worker` 类，而是扩展 `CoroutineWorker(context, workerParameters)`，这有助于我们收集数据流。我们还将使用
    Hilt，因此我们将调用 `@HiltWorker`：
- en: '[PRE39]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In our case, we are returning `success.` In our `getData()` function, we pass
    in the endpoint, and we can assume our data has two or three crucial attributes:
    the ID, the title, and the description.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们返回 `success.` 在我们的 `getData()` 函数中，我们传递端点，我们可以假设我们的数据有两个或三个关键属性：ID、标题和描述。
- en: 'We can now send notifications:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以发送通知：
- en: '[PRE58]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We also need to create a `PendingIntent.getActivity()`, which means when there
    is a click on the notification, the user will start an activity. For this to happen,
    we can `getStringExtra(NotificationConstants.NOTIFICATION_ID)` when a notification
    is clicked and put extras in our intent. This will need to happen in our activity:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个 `PendingIntent.getActivity()`，这意味着当点击通知时，用户将启动一个活动。为了实现这一点，我们可以在点击通知时调用
    `getStringExtra(NotificationConstants.NOTIFICATION_ID)` 并在我们的意图中添加额外的数据。这需要在我们的活动中发生：
- en: '[PRE79]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And on our `onResume()`, we can now call our `verifyIntent()` function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `onResume()` 中，我们现在可以调用我们的 `verifyIntent()` 函数：
- en: '[PRE88]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: And that’s it; we have custom notifications using our `WorkManager()`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们使用了 `WorkManager()` 来自定义通知。
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When creating a notification, the `importance` parameter helps determine how
    to interrupt the user for any given channel, hence why one should specify it in
    the `NotificationChannel` constructor. If the importance is high and the device
    is running Android 5.0+, you’re going to see a heads-up notification, otherwise,
    it will just be the icon in the status bar. However, it is essential to note that
    all notifications, regardless of their importance, appear in a non-interruptive
    UI at the top of your screen.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建通知时，`importance` 参数有助于确定如何为任何给定通道中断用户，因此为什么应该在 `NotificationChannel` 构造函数中指定它。如果重要性高且设备运行
    Android 5.0+，你将看到紧急通知，否则，它将只显示在状态栏上的图标。然而，重要的是要注意，所有通知，无论其重要性如何，都会出现在屏幕顶部的非中断性
    UI 中。
- en: The `WorkManager` word is very straightforward, hence removing ambiguity from
    the API. When using `WorkManager`, `Work` is referenced utilizing the `Worker`
    class. In addition, the `doWork()` function that we call runs asynchronously in
    the background thread offered by the `WorkManager()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager` 这个词非常直接，因此从 API 中消除了歧义。当使用 `WorkManager` 时，`Work` 通过 `Worker`
    类引用。此外，我们调用的 `doWork()` 函数在 `WorkManager()` 提供的后台线程中异步运行。'
- en: The `doWork()` function returns a `Result{}`, and this result can be `Success`,
    `Failure`, or `Retry`. When we return the successful `Result{}`, the work will
    be done and finished successfully. `Failure`, as the name suggests, means the
    work failed, and then we call `Retry`, which retries the work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`doWork()` 函数返回一个 `Result{}`，这个结果可以是 `Success`、`Failure` 或 `Retry`。当我们返回成功的
    `Result{}` 时，工作将完成并成功结束。`Failure`，正如其名所示，意味着工作失败，然后我们调用 `Retry`，以重试工作。'
- en: In our `GetDataWorker()`, we pass in `NotificationViewModel` and inject it into
    our worker using Hilt. Sometimes you might encounter a conflict. The good thing
    is there is support for such a case with four options for handling any conflict
    that might occur.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `GetDataWorker()` 中，我们传递 `NotificationViewModel` 并使用 Hilt 将其注入到我们的工作器中。有时你可能会遇到冲突。好消息是，对于可能发生的任何冲突，都有四种处理选项的支持。
- en: This case is unique to when you are scheduling unique work; it makes sense to
    tell `WorkManager` what action must be taken when a conflict arises. You can solve
    this problem easily by using the existing work policy, `ExisitingWorkPolicy`,
    which has `REPLACE`, `KEEP APPEND`, and `APPEND_OR_REPLACE`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是当你安排独特的工作时独有的；告诉 `WorkManager` 当出现冲突时必须采取什么行动是有意义的。你可以通过使用现有的工作策略 `ExisitingWorkPolicy`
    来轻松解决这个问题，它有 `REPLACE`、`KEEP APPEND` 和 `APPEND_OR_REPLACE` 选项。
- en: '`Replace`, as the name suggests, replaces the existing work, while `Keep` keeps
    existing work and ignores new work. When you call *Append*, this adds the new
    work to the existing one, and finally, `Append or Replace` simply does not depend
    on the pre-requisite work state.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，`Replace`会替换现有工作，而`Keep`会保留现有工作并忽略新工作。当您调用*Append*时，这会将新工作添加到现有工作，而`Append
    or Replace`则简单地不依赖于先决工作状态。
- en: Important note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`WorkManager` is a singleton, hence it can only be initialized once, that is,
    either in your app or in the library. And, if you are using any workers with custom
    dependencies, then you have to provide a `WorkerFactory()` to the config at the
    time of custom initialization.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager`是一个单例，因此它只能初始化一次，即在您的应用或库中。此外，如果您正在使用任何具有自定义依赖项的工作者，那么您必须在自定义初始化时向配置提供`WorkerFactory()`。'
- en: There’s more…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can only cover some `WorkManager` steps here. Google has great sample code
    labs that you can follow through and understand how to use `WorkManager`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只能涵盖一些`WorkManager`步骤。Google有一些很好的示例代码实验室，您可以跟随并了解如何使用`WorkManager`。
- en: 'To read more about `WorkManager`, you can use this link: [https://developer.android.com/guide/background/persistent](https://developer.android.com/guide/background/persistent).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于`WorkManager`的信息，您可以点击这个链接：[https://developer.android.com/guide/background/persistent](https://developer.android.com/guide/background/persistent)。
- en: Understanding WorkManager state
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解WorkManager状态
- en: In the previous recipe, *Understanding the Jetpack WorkManager library*, we
    looked into how we can use `WorkManager`. In that recipe, you might have noticed
    `Work` goes through a series of state changes, and the `doWork` function returns
    a result.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱**理解Jetpack WorkManager库**中，我们探讨了如何使用`WorkManager`。在那个菜谱中，您可能已经注意到`Work`会经历一系列状态变化，并且`doWork`函数返回一个结果。
- en: In this recipe, we will explore states in depth.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将深入探讨状态。
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will continue working on an example of how you can apply the concepts learned
    about in this recipe to your already-built project:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续探讨如何将在这个菜谱中学到的概念应用到您已经构建的项目中的示例：
- en: 'You might have noticed we mentioned before that we have three states: `Success`,
    `Failure`, and `Retry`. `Work` states, however, have different types of processes;
    we can have a one-time work state, periodic work state, or blocked state:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们之前提到过，我们有三种状态：`Success`、`Failure`和`Retry`。然而，`Work`状态有不同的处理类型；我们可以有一个一次性工作状态、周期性工作状态或阻塞状态：
- en: '[PRE92]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can look into this abstract class in more depth by clicking on the result
    and seeing how it is written.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击结果并查看其编写方式来深入了解这个抽象类。
- en: 'In the first recipe, *Understanding the Jetpack WorkManager library*, we looked
    into the steps of setting up `WorkManager`. Another great example is downloading
    files. You can override the `fun doWork()` and check whether your URI is not equal
    to null and return a success, else failure:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个菜谱**理解Jetpack WorkManager库**中，我们探讨了设置`WorkManager`的步骤。另一个很好的例子是下载文件。您可以重写`fun
    doWork()`并检查您的URI是否不等于null，然后返回成功，否则失败：
- en: '[PRE94]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'When handling a state, you can easily check when the state successfully specifies
    an action, when it failed to perform an action, and finally, when `WorkInfo.State`
    is equals to `RUNNING`, call `running()`; see the following code snippet:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理状态时，您可以轻松检查状态成功指定动作、未能执行动作以及当`WorkInfo.State`等于`RUNNING`时调用`running()`；请参阅以下代码片段：
- en: '[PRE110]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The success result returns an instance of `ListenableWorker.Result`, used to
    indicate that the work was completed successfully.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功结果返回一个`ListenableWorker.Result`实例，用于指示工作已成功完成。
- en: 'For the mentioned states, you can either use `enqueueUniqueWork()`, which is
    used for one time, or `PeriodicWorkRequestBuilder`, which is used for periodic
    work. In our example, we used `PeriodicWorkRequestBuilder<Type>`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于提到的状态，您可以使用`enqueueUniqueWork()`，它用于一次性工作，或者使用`PeriodicWorkRequestBuilder`，它用于周期性工作。在我们的例子中，我们使用了`PeriodicWorkRequestBuilder<Type>`：
- en: '[PRE126]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We always start our request with the *Enqueued* state for the one-time work
    state, which means the work will run as soon as the constraints are met. Thereafter,
    we move to *Running*, and if we hit a *Success*, the work is done.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是以**Enqueued**状态开始我们的请求，对于一次性工作状态，这意味着一旦满足约束条件，工作就会立即运行。之后，我们进入**Running**状态，如果遇到**Success**，则工作完成。
- en: If in any instance, we end up *Running* and we don’t hit *Success*, then it
    means we failed. Then, we will move back to *Enqueued* since we need to retry.
    *Figure 7**.1* and *Figure 7**.2* explain the states better for both one-time
    work and periodic work states.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何情况下，我们最终处于 *运行* 状态，但没有达到 *成功*，那么这意味着我们失败了。然后，我们将回到 *入队* 状态，因为我们需要重试。*图
    7.1* 和 *图 7.2* 更好地解释了一次性工作和周期性工作状态的状态。
- en: Finally, if it happens that our enqueued work gets cancelled, then we move it
    to cancelled.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们的入队工作被取消，那么我们就将其移动到已取消状态。
- en: '![Figure 7.1 – How one-time work requests work](img/Figure_7.1_B18827.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 一次性工作请求的工作方式](img/Figure_7.1_B18827.jpg)'
- en: Figure 7.1 – How one-time work requests work
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 一次性工作请求的工作方式
- en: While the preceding image shows the one-time work state, the following diagram
    depicts the periodic work state.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的图像显示了一次性工作状态，但下面的图表描述了周期性工作状态。
- en: "![Figure 7.2 – How the periodic wo\uFEFFrk state works](img/Figure_7.2_B18827.jpg)"
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 周期性工作状态的工作方式](img/Figure_7.2_B18827.jpg)'
- en: Figure 7.2 – How the periodic work state works
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 周期性工作状态的工作方式
- en: Understanding threading in WorkManager
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 WorkManager 中的线程处理
- en: You can think of `WorkManager` as any process that runs in a background thread.
    When we use the `Worker()`, and `WorkManager` calls the `doWork()` function, this
    action works in the background thread. In detail, the background thread comes
    from the `Executor` specified in the `WorkManager` configuration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `WorkManager` 想象为在后台线程中运行的任何进程。当我们使用 `Worker()`，并且 `WorkManager` 调用 `doWork()`
    函数时，这个动作在后台线程中执行。具体来说，后台线程来自 `WorkManager` 配置中指定的 `Executor`。
- en: You can also create your own custom executor for your application needs, but
    if that’s not needed, you can use the pre-existing one. This recipe will explore
    how threading in a `Worker()` works and how to create a custom executor.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为你的应用程序需求创建自己的自定义执行器，但如果这不是必需的，你可以使用现有的一个。这个菜谱将探讨 `Worker()` 中的线程处理以及如何创建自定义执行器。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, since we will be looking at examples, you can follow along by
    reading and seeing if this applies to you.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，因为我们将会查看示例，你可以通过阅读和查看它是否适用于你来进行跟随。
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s learn how threading works in `WorkManager`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在 `WorkManager` 中进行线程处理：
- en: 'In order to configure `WorkManager` manually, you will need to specify your
    executor. This can be done by calling `WorkManager.initialize()`, then passing
    the context, and the configuration builder:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了手动配置 `WorkManager`，你需要指定你的执行器。这可以通过调用 `WorkManager.initialize()`，然后传递上下文和配置构建器来完成：
- en: '[PRE128]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'In our earlier example in the previous recipe, *Understanding WorkManager state*,
    we spoke about a use case where we download files. These files can be in the form
    of PDF, JPG, PNG, or even MP4\. We will look at an example that downloads content
    20 times; you can specify how many times you want your content to download:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前的菜谱中，*理解 WorkManager 状态*，我们讨论了一个下载文件的使用案例。这些文件可以是 PDF、JPG、PNG 或甚至是 MP4 的形式。我们将查看一个下载内容
    20 次的示例；你可以指定你希望内容下载的次数：
- en: '[PRE134]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Currently, if we do not handle the case where the `Worker()` is stopped, it
    is good practice to ensure that it is dealt with because this is an edge case.
    To address this case, we need to override the `Worker.onStopped()` method or call
    `Worker.isStopped` where necessary to free up some resources:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，如果我们没有处理 `Worker()` 被停止的情况，那么确保处理这种情况是一个好的做法，因为这是一个边缘情况。为了处理这种情况，我们需要重写 `Worker.onStopped()`
    方法或在必要时调用 `Worker.isStopped` 以释放一些资源：
- en: '[PRE147]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Finally, when you stop the worker, the result is entirely ignored until you
    restart the process again. We used `CoroutineWorker` in our earlier example since
    `WorkManager` offers support for coroutines, hence why we collected the data in
    a flow.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当你停止工作线程时，结果将被完全忽略，直到你再次启动该过程。我们在先前的示例中使用了 `CoroutineWorker`，因为 `WorkManager`
    提供了对协程的支持，因此我们在流中收集了数据。
- en: Important note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Customizing your executor will require manually initializing `WorkManager`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 定制你的执行器需要手动初始化 `WorkManager`。
- en: How it works…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There is more to learn in the `WorkManager` Jetpack library, and it is fair
    to acknowledge that it can’t all be captured in just a few recipes. For instance,
    in some scenarios, when providing a custom threading strategy, you should use
    `ListenableWorker`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WorkManager` Jetpack 库中还有更多东西可以学习，并且公平地说，它不可能只通过几个菜谱就能全部涵盖。例如，在某些场景中，当提供自定义线程策略时，你应该使用
    `ListenableWorker`。
- en: The `ListenableWorker` is a class in the Android Jetpack `WorkManager` library
    that allows you to perform background work in a flexible and efficient manner.
    It is a subclass of the `Worker` class and adds the ability to return a `ListenableFuture`
    from its `doWork()` method, which allows for easier handling of asynchronous operations.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenableWorker` 是 Android Jetpack `WorkManager` 库中的一个类，它允许你以灵活和高效的方式执行后台工作。它是
    `Worker` 类的子类，并添加了从其 `doWork()` 方法返回 `ListenableFuture` 的能力，这使得异步操作的处理更加容易。'
- en: By using `ListenableWorker`, you can create a worker that returns a `ListenableFuture`
    and register callbacks that will be executed when the future completes. This can
    be useful for tasks such as network requests or database operations that require
    asynchronous operations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `ListenableWorker`，你可以创建一个返回 `ListenableFuture` 并注册当未来完成时将执行的回调的工人。这对于需要异步操作的任务，如网络请求或数据库操作，非常有用。
- en: The `Worker`, `CoroutineWorker`, and `RxWorker` derive from this particular
    class. `Worker`, as mentioned, runs in the background thread; `CoroutineWorker`
    is highly recommended for developers using Kotlin. `RxWorker` will not be touched
    upon here since Rx by itself is a big topic that caters to users that develop
    in reactive programming.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker`、`CoroutineWorker` 和 `RxWorker` 都从这个特定的类派生。正如之前提到的，`Worker` 在后台线程中运行；`CoroutineWorker`
    对于使用 Kotlin 的开发者来说非常推荐。`RxWorker` 在这里不会涉及，因为 Rx 本身是一个大主题，它针对的是在响应式编程中开发的用户。'
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Your application might be using Rx. In that case, there are details on how
    threading works in Rx and how you can use `RxWorker`. See more here: [https://developer.android.com/guide/background/persistent/threading/rxworker](https://developer.android.com/guide/background/persistent/threading/rxworker).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序可能正在使用 Rx。在这种情况下，这里有关于 Rx 中线程工作方式以及如何使用 `RxWorker` 的详细信息。更多信息请参阅：[https://developer.android.com/guide/background/persistent/threading/rxworker](https://developer.android.com/guide/background/persistent/threading/rxworker)。
- en: Understanding chaining and canceling work requests
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解链式操作和取消工作请求
- en: In Android development, ensuring you properly handle your application’s life
    cycle is crucial. Needless to say, this also applies to all background work, as
    a simple mistake can lead to your application draining the user’s battery, memory
    leaks, or even causing the application to crash or suffer from an **application
    not responding** (**ANR**) error. This could mean terrible reviews in the Play
    Store, which will later affect your business and causes stress for developers.
    How do you ensure this issue is handled well?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 开发中，确保你正确处理应用程序的生命周期至关重要。不用说，这也适用于所有后台工作，因为一个简单的错误可能导致应用程序耗尽用户的电池、内存泄漏，甚至导致应用程序崩溃或出现
    **应用程序无响应** （**ANR**） 错误。这可能导致 Play 商店中的糟糕评价，这最终会影响你的业务，并为开发者带来压力。你如何确保这个问题得到妥善处理？
- en: This can be done by ensuring all conflicts that arise while using `WorkManager`
    are appropriately handled or guaranteeing the policy we touched on in the previous
    recipe is well coded. In this recipe, we will look into chaining and canceling
    work requests and how to handle long-running work properly.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过确保在使用 `WorkManager` 时出现的所有冲突都得到适当的处理，或者保证我们在上一个菜谱中提到的策略得到良好的编码来实现。在这个菜谱中，我们将探讨链式操作和取消工作请求，以及如何正确处理长时间运行的工作。
- en: Say your project requires an order by which the operation should run; `WorkManager`
    gives you the ability to enqueue and create a chain that specifies multiple dependent
    tasks, and here you can set the order in which you want the operations to occur.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的项目需要按照特定的顺序运行操作；`WorkManager` 允许你入队并创建一个指定多个依赖任务的链，在这里你可以设置操作发生的顺序。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will look at an example of how you might chain your work;
    since this is concept-based, we will look at the example and explain how it works.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看一个示例，说明你如何链式操作你的工作；由于这是基于概念的，我们将查看示例并解释它是如何工作的。
- en: How to do it…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To perform chaining using `WorkManager`, follow these steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `WorkManager` 进行链式操作，请按照以下步骤进行：
- en: In our example, we will assume we have four unique `Worker` jobs to run in parallel.
    The output of these jobs will be passed to an upload `Worker`. Then, these will
    be uploaded to our server, like the sample project we had in the *Understanding
    the Jetpack WorkManager* *library* recipe.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将假设我们有四个独特的并行运行的 `Worker` 任务。这些任务的输出将被传递给一个上传 `Worker`。然后，这些任务将被上传到我们的服务器，就像我们在
    *Understanding the Jetpack WorkManager* *library* 菜单中看到的示例项目一样。
- en: 'We will have our `WorkManager()` and pass in our context; then we will call
    `beginWith` and pass a list of our jobs:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`WorkManager()`并传入我们的上下文；然后我们将调用`beginWith`并传递一个包含我们作业的列表：
- en: '[PRE161]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'To be able to maintain or preserve all our outputs from our job, we will need
    to use the `ArrayCreatingInputMerger::class`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够维护或保留我们作业的所有输出，我们需要使用`ArrayCreatingInputMerger::class`：
- en: '[PRE166]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: That is about it. There is definitely more to learn, but this serves our purpose.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。肯定还有更多东西要学，但这已经达到了我们的目的。
- en: How it works…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To be able to create the chain of work, we use `WorkManager.beginWith(OneTimeWorkRequest)`
    or use `WorkManager.beginWith` and pass a list of the one-time work requests that
    you have specified.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够创建工作链，我们使用`WorkManager.beginWith(OneTimeWorkRequest)`或者使用`WorkManager.beginWith`并传递一个包含你指定的单次工作请求的列表。
- en: The `WorkManager.beginWith<List<OneTimeWorkRequest>>` operations return an instance
    of `WorkContinuation`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager.beginWith<List<OneTimeWorkRequest>>`操作返回一个`WorkContinuation`实例。'
- en: We use the `WorkContinuation.enqueue()` function to enqueue our `WorkContinuation`
    chain. The `ArrayCreatingInputMerger` ensures we pair each key with an array.
    In addition, the `ArrayCreatingInputMerger` is a class in the Android Jetpack
    `WorkManager` library that allows you to merge input data from multiple `ListenableWorker`
    instances into a single array.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`WorkContinuation.enqueue()`函数将我们的`WorkContinuation`链入队列。`ArrayCreatingInputMerger`确保我们将每个键与一个数组配对。此外，`ArrayCreatingInputMerger`是Android
    Jetpack `WorkManager`库中的一个类，它允许你将多个`ListenableWorker`实例的输入数据合并成一个数组。
- en: 'Furthermore, if our keys are `unique`, we will get a result of one-element
    arrays. *Figure 7**.3* shows the output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们的键是`unique`，我们将得到一个只有一个元素的数组。*图7.3*显示了输出：
- en: '![Figure 7.3 – How the array creating input merger works](img/Figure_7.3_B18827.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 数组创建输入合并器的工作原理](img/Figure_7.3_B18827.jpg)'
- en: Figure 7.3 – How the array creating input merger works
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 数组创建输入合并器的工作原理
- en: If we have any colliding keys, then our values will be grouped together in our
    array, as in *Figure 7**.4*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有任何冲突的键，那么我们的值将按*图7.4*中的方式在我们的数组中分组。
- en: '![Figure 7.4 – Key collision and result](img/Figure_7.4_B18827.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 键冲突和结果](img/Figure_7.4_B18827.jpg)'
- en: Figure 7.4 – Key collision and result
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 键冲突和结果
- en: The rule of thumb is chains of work typically execute sequentially. This is
    reliant on the work being completed successfully. You might be wondering what
    happens when the job is enqueued in a chain of several work requests; just like
    a regular queue, all subsequent work is temporarily blocked until the first work
    request is completed. Think of it as *first come,* *first serve*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，工作链是顺序执行的。这取决于工作是否成功完成。你可能想知道当工作请求被添加到多个工作请求的队列中时会发生什么；就像一个常规队列一样，所有后续的工作都会暂时阻塞，直到第一个工作请求完成。把它想象成*先来先服务*。
- en: See also
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You might be wondering how you can support long-running workers; you can learn
    more at [https://developer.android.com/guide/background/persistent/how-to/long-running](https://developer.android.com/guide/background/persistent/how-to/long-running).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何支持长时间运行的工作者；你可以在[https://developer.android.com/guide/background/persistent/how-to/long-running](https://developer.android.com/guide/background/persistent/how-to/long-running)了解更多信息。
- en: Implementing migration from Firebase JobDispatcher to the new recommended WorkManager
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现从Firebase JobDispatcher到新推荐的工作管理器的迁移
- en: In the *Understanding the Jetpack WorkManager library* recipe, we talked about
    other libraries that are used for scheduling and executing deferrable background
    work. Firebase `JobDispatcher` is one of the popular ones. If you have used Firebase
    `JobDispatcher`, you might know it uses the `JobService()` subclass as its entry
    point. In this recipe, we will look at how you can migrate to the newly recommended
    `WorkManager`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在*理解Jetpack WorkManager库*的食谱中，我们讨论了用于安排和执行可延迟后台工作的其他库。Firebase `JobDispatcher`是其中之一。如果你使用过Firebase
    `JobDispatcher`，你可能知道它使用`JobService()`子类作为其入口点。在这个食谱中，我们将探讨如何迁移到新推荐的`WorkManager`。
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be looking at how we can migrate from `JobService` to `WorkerManager`.
    This might apply to your project or not. It is essential to cover it, though,
    due to the fact that `WorkManager` is highly recommended, and we all have some
    legacy code. However, if your project is new, you can skip this recipe.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何从`JobService`迁移到`WorkerManager`。这可能适用于你的项目，也可能不适用。然而，由于`WorkManager`被高度推荐，我们都有一些遗留代码，所以这一点是必须涵盖的。然而，如果你的项目是新的，你可以跳过这个食谱。
- en: How to do it…
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To migrate your Firebase `JobDispatcher` to `WorkManager`, follow these steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Firebase `JobDispatcher`迁移到`WorkManager`，请按照以下步骤操作：
- en: First, you will need to add the required dependency; for this, you can reference
    the *Understanding the Jetpack WorkManager* *library* recipe.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要添加所需的依赖项；为此，你可以参考*理解Jetpack WorkManager* *库*配方。
- en: 'If you already have Firebase `JobDispatcher` in your project, you might have
    code similar to the following code snippet:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经在你的项目中有了Firebase `JobDispatcher`，你可能会有以下代码片段类似的代码：
- en: '[PRE170]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'It is easier if your application utilizes `JobServices()`; then, it will map
    to `ListenableWorker`. However, if your application is utilizing `SimpleJobService`,
    then in that case, you should use `Worker`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用`JobServices()`，那么它将映射到`ListenableWorker`。然而，如果你的应用程序正在使用`SimpleJobService`，那么在这种情况下，你应该使用`Worker`：
- en: '[PRE181]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'If your project is using `Job.Builder.setRecurring(true)`, in this case, you
    should change it to the `PeriodicWorkRequest` a class offered by `WorkManager`.
    You can also specify your tag, service if the job is recurring, trigger window,
    and more:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的项目使用`Job.Builder.setRecurring(true)`，在这种情况下，你应该将其更改为`WorkManager`提供的`PeriodicWorkRequest`类。你也可以指定你的标签、服务（如果作业是重复的）、触发窗口等：
- en: '[PRE191]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: In addition, to be able to achieve what we want, we will need to input data
    that will act as the input data for our `Worker`, then build our `WorkRequest`
    with our input data and the specific constraint. You can reference the *Understanding
    the Jetpack WorkManager library* recipe, and finally, enqueue the Work Request.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了能够实现我们的目标，我们需要输入数据，这些数据将作为我们`Worker`的输入数据，然后使用我们的输入数据和特定的约束来构建我们的`WorkRequest`。你可以参考*理解Jetpack
    WorkManager库*配方，并最终将工作请求入队。
- en: Finally, you can create your work request as either one-time or periodic and
    ensure you handle any edge cases, such as canceling work.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以创建一次性的或周期性的工作请求，并确保你处理任何边缘情况，例如取消工作。
- en: How it works…
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In Firebase `JobDispatcher`, the `JobService.onStartJob()`, which is a function
    in the `JobSccheduler`, and `startWork()` are called on the main thread. In comparison,
    in `WorkManager`, the `ListenableWorker` is the basic unit of work. In our example,
    `YourWorker` implements the `ListenableWorker` and returns an instance of `ListenableFuture`,
    which helps in signaling work completion. However, you can implement your one-threading
    strategy based on your application’s needs.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase `JobDispatcher`中，`JobService.onStartJob()`，这是一个在`JobSccheduler`中的函数，以及`startWork()`在主线程上被调用。相比之下，在`WorkManager`中，`ListenableWorker`是基本的工作单元。在我们的例子中，`YourWorker`实现了`ListenableWorker`并返回一个`ListenableFuture`实例，这有助于在信号工作完成时使用。然而，你可以根据你的应用程序需求实现你的单线程策略。
- en: In Firebase, the `FirebaseJobBuilder` uses the `Job.Builder` serves as the Jobs
    metadata. In comparison, `WorkManager` uses `WorkRequest` to perform a similar
    role. `WorkManager` usually initializes itself by utilizing the `ContentProvider`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase中，`FirebaseJobBuilder`使用`Job.Builder`作为作业元数据。相比之下，`WorkManager`使用`WorkRequest`来执行类似的角色。`WorkManager`通常通过利用`ContentProvider`来初始化自己。
- en: How to debug WorkManager
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何调试WorkManager
- en: Any operation that requires working in the background and sometimes making network
    calls need proper exception handling. This is due to the fact that you do not
    want your users facing issues and a lack of exception handling coming back to
    haunt your team or you as a developer.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要在后台工作并有时进行网络调用的操作都需要适当的异常处理。这是因为你不想让你的用户面临问题，并且缺乏异常处理可能会让你的团队或作为开发者的你感到困扰。
- en: Hence, knowing how to debug `WorkManager` will come in handy, as this is one
    of those issues that might last for days if you have a bug. In this recipe, we
    will look at how to debug `WorkManager`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，了解如何调试`WorkManager`将非常有用，因为这是那些可能持续数日的问题之一。在这个配方中，我们将探讨如何调试`WorkManager`。
- en: Getting ready
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow this recipe, you must have completed all previous recipes of this
    chapter.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这个配方，你必须完成本章中所有之前的配方。
- en: How to do it…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You might encounter an issue where `WorkManager` no longer runs if it is out
    of sync. Follow this recipe to debug `WorkManager`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一个问题，即如果`WorkManager`不同步，它将不再运行。遵循这个配方来调试`WorkManager`：
- en: 'To be able to set up debugging, we will need to first create a custom initialization
    in our `AndroidManifest.xml` file, that is, by disabling the `WorkManager` initializer:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了设置调试，我们首先需要在我们的`AndroidManifest.xml`文件中创建一个自定义初始化，即通过禁用`WorkManager`初始化器：
- en: '[PRE194]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'After, we go ahead and set a minimum logging level to debug in our application
    class:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续在我们的应用程序类中设置一个最低日志级别以进行调试：
- en: '[PRE197]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Once this is done, we will be able to see logs with the prefix `WM-` in our
    debug level easily, which will make our debugging work much more straightforward,
    and voila, we can move one step closer to solving our issue.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，我们就能轻松地看到带有前缀`WM-`的日志，这将使我们的调试工作更加直接，哇，我们可以更近一步地解决我们的问题。
- en: How it works…
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Sometimes it might be helpful just to utilize the verbose `WorkManager` logs
    to capture any anomalies. In addition, you can enable logging and use your own
    custom initialization. That is what we do in the first step of our recipe. Furthermore,
    when we declare our own custom `WorkManager` configuration, our `WorkManager`
    will be initialized when we call the `WorkManager.getInstance(context)` and not
    naturally at application startup.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，仅仅利用详尽的`WorkManager`日志来捕获任何异常可能很有帮助。此外，你可以启用日志记录并使用你自己的自定义初始化。这就是我们在食谱的第一步所做的事情。此外，当我们声明自己的自定义`WorkManager`配置时，我们的`WorkManager`将在我们调用`WorkManager.getInstance(context)`时初始化，而不是在应用启动时自然初始化。
- en: Testing Worker implementations
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试工作实现
- en: Testing your `Worker` implementation is crucial, as it helps ensure your code
    is well handled and your team follows the proper guidelines for writing great
    code. This will be an integration test, which means we will add our code to the
    `androidTest` folder. This recipe will look into how to add tests for your worker.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的`Worker`实现至关重要，因为它有助于确保你的代码得到妥善处理，并且你的团队遵循编写优秀代码的正确指南。这将是一个集成测试，这意味着我们将把我们的代码添加到`androidTest`文件夹中。这个食谱将探讨如何为你的工作添加测试。
- en: Getting ready
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, you need to have completed all previous recipes
    of this chapter.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个食谱，你需要完成本章的所有先前食谱。
- en: How to do it…
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to get started with testing `WorkManager`. We will look
    at examples in this recipe:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始测试`WorkManager`。我们将在本食谱中查看示例：
- en: 'First, you need to add the testing dependency in your `build.gradle` file:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要在你的`build.gradle`文件中添加测试依赖：
- en: '[PRE204]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'In the scenario where something in the API changes in the future, there’s a
    stable version that you can use, and you can always find that in the documentation
    by following this link: [https://developer.android.com/jetpack/androidx/releases/work](https://developer.android.com/jetpack/androidx/releases/work).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来API中某些内容发生变化的情况下，有一个稳定的版本你可以使用，你可以在通过以下链接的文档中找到它：[https://developer.android.com/jetpack/androidx/releases/work](https://developer.android.com/jetpack/androidx/releases/work)。
- en: 'We will need to set up our `@Before` function, as provided by Google:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置由Google提供的`@Before`函数：
- en: '[PRE205]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Now that we have our `WorkManager` set up, we can go ahead and structure our
    test:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了`WorkManager`，我们可以继续构建我们的测试：
- en: '[PRE221]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'You can easily test and verify the states by following this example:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下示例轻松测试和验证状态：
- en: '[PRE229]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: You can add more tests such as verifying when the state is successful or checking
    initial delays; you can also go the extra mile and test the constraints and more.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加更多测试，例如验证状态成功时或检查初始延迟；你还可以更进一步，测试约束条件等。
- en: How it works…
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The library we use provides excellent support for testing `Worker`. For instance,
    we have `WorkManagerTestInitHelper` supplied to us through the library. Furthermore,
    we have the `SynchronousExecutor`, which makes our work as developers easier by
    ensuring synchronous writing tests is easy. Also, the issue of handling multiple
    threads, latches, and locks is dealt with.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的库为测试`Worker`提供了出色的支持。例如，我们通过库获得了`WorkManagerTestInitHelper`。此外，我们还有`SynchronousExecutor`，它通过确保同步编写测试变得容易，使我们的工作作为开发者变得更加容易。同时，处理多个线程、闩锁和锁的问题也得到了解决。
- en: In our `testGetDataWorkerHasNoData`, we create a request, then enqueue it and
    wait for the results. We later get the info, then assert when the state is failed,
    it should fail. You can also test when it is successful.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`testGetDataWorkerHasNoData`测试中，我们创建一个请求，然后将其入队并等待结果。我们稍后获取信息，然后断言当状态失败时，它应该失败。你也可以测试它成功的情况。
- en: There’s more…
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To test worker implementations with different variants, you can follow this
    link: [https://developer.android.com/guide/background/testing/persistent/worker-impl](https://developer.android.com/guide/background/testing/persistent/worker-impl).'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试不同变体的工作实现，你可以通过以下链接进行：[https://developer.android.com/guide/background/testing/persistent/worker-impl](https://developer.android.com/guide/background/testing/persistent/worker-impl)。
