- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with WorkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, `WorkManager` is an API introduced by Google as part of the Android
    Jetpack library. It is a powerful and flexible background task scheduling library
    that allows you to perform deferrable, asynchronous tasks even when your app is
    not running or the device is in a low-power state.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkManager` provides a unified API to schedule tasks that need to be executed
    at a specific time or under certain conditions. It takes care of managing and
    running tasks efficiently, depending on factors such as device idle state, network
    connectivity, and battery level.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, `WorkManager` allows observation of work status and chain creation.
    This chapter will look into how we can implement `WorkManager` using examples
    and learn how it works and its use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Jetpack `WorkManager` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `WorkManager` state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding threading in `WorkManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding chaining and canceling work requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing migration from Firebase `JobDispatcher` to the new recommended
    `WorkManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to debug `WorkManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing `Worker` implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter utilizes step-by-step examples and does not create a complete project.
    `WorkManager` is helpful, but because the use case may vary, utilizing examples
    to see how the code fits your need is an excellent art to learn in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Jetpack WorkManager library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WorkManager** is one of the most powerful Jetpack libraries, and it is used
    for persistent work. The API allows observation of persistent status and the ability
    to create a complex chain of work. When building Android applications, it might
    be a requirement to have your data persist; if you need help to refresh your knowledge,
    you can reference[*Chapter 6*](B18827_06.xhtml#_idTextAnchor283), *Using the Room
    Database* *and Testing*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkManager` is the most-recommended API for any background process and is
    known to handle unique types of ongoing work as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immediate**: As the name suggests, these are tasks that must be done immediately
    or completed soon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-Running**: Tasks that run for a long time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deferrable**: A task that can be rescheduled and can be assigned a different
    start time and can also run periodically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some more sample use cases where you can use `WorkManager` are, for instance,
    if your company wants to create custom notifications, send analytics events, upload
    images, periodically sync your local data with the network, and more. Furthermore,
    `WorkManager` is the favored API and is highly recommended as it replaces all
    previous background scheduling APIs in Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other APIs that are used for scheduling work. They are deprecated,
    and in this book, we will not cover them but will mention them since you might
    encounter them in work with legacy code; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Job Dispatcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Job Scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCM `NetWorkManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will go ahead and look at a simple example of how we can
    create our own custom notification using `WorkManager`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the same concept to send logs or report analytics for your
    application if you are listening to any logs. We opt for this task because sending
    notifications to your users is crucial, and most applications do this, compared
    to uploading images. In addition, with Android 13 and the new API, it’s mandatory
    to request `android.permission.POST_NOTIFICATIONS`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you do not need to create a project, as the concepts can be
    used in an already-built project; instead, we will look at examples and walk through
    the examples with explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to ensure we have the required dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can get the latest **version number** by following the documentation at
    [https://developer.android.com/jetpack/androidx/releases/work](https://developer.android.com/jetpack/androidx/releases/work).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now go ahead and create our notification channel. For this, Google offers
    a great guide on how you can create one at [https://developer.android.com/develop/ui/views/notifications/channels](https://developer.android.com/develop/ui/views/notifications/channels),
    so copy the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, note that creating different channels for separating notification types
    is possible. As recommended in Android 13, this makes it easier for users to turn
    them on and off if they do not need them. For example, a user might want to be
    aware of the latest brands your app is selling, compared to you sending your users
    info about old existing brands.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create our `workManagerInstance`. Let us think of a scenario where
    we need to fetch data from our servers every 20 or 30 mins and check whether notifications
    are available. In that case, we might encounter an issue where users are no longer
    using our application, which means the application will be put in the background,
    or the process might even be killed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hence the question becomes how do we fetch the data when the application is
    killed? This is when `WorkManager` comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create an instance of `WorkManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now need to go ahead and set the constraints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need to set data to pass to the worker; hence we will create new
    value data, then we will put a string to the endpoint request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can go ahead and create our `PeriodicWorkRequestBuilder<GetDataWorker>`.
    In our work, we will set the constraints, set our input data, and pass the `GetDataWorker()`
    type, which we will create and then build. Furthermore, since we want to be fetching
    the data every 20 or 30 mins from our server, we use `PeriodicWorkRequestBuilder<Type>()`
    for that purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now finally call `workManagerInstance` and enqueue our job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now go ahead and construct our `GetDataWorker()`. In this class, we
    will extend the `Worker` class, which will override the `doWork()` function. In
    our case, however, instead of extending the `Worker` class, we will extend the
    `CoroutineWorker(context, workerParameters)`, which will help in our case since
    we will collect this data in a flow. We will also be using Hilt, so we will call
    `@HiltWorker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our case, we are returning `success.` In our `getData()` function, we pass
    in the endpoint, and we can assume our data has two or three crucial attributes:
    the ID, the title, and the description.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now send notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to create a `PendingIntent.getActivity()`, which means when there
    is a click on the notification, the user will start an activity. For this to happen,
    we can `getStringExtra(NotificationConstants.NOTIFICATION_ID)` when a notification
    is clicked and put extras in our intent. This will need to happen in our activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And on our `onResume()`, we can now call our `verifyIntent()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that’s it; we have custom notifications using our `WorkManager()`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a notification, the `importance` parameter helps determine how
    to interrupt the user for any given channel, hence why one should specify it in
    the `NotificationChannel` constructor. If the importance is high and the device
    is running Android 5.0+, you’re going to see a heads-up notification, otherwise,
    it will just be the icon in the status bar. However, it is essential to note that
    all notifications, regardless of their importance, appear in a non-interruptive
    UI at the top of your screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `WorkManager` word is very straightforward, hence removing ambiguity from
    the API. When using `WorkManager`, `Work` is referenced utilizing the `Worker`
    class. In addition, the `doWork()` function that we call runs asynchronously in
    the background thread offered by the `WorkManager()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `doWork()` function returns a `Result{}`, and this result can be `Success`,
    `Failure`, or `Retry`. When we return the successful `Result{}`, the work will
    be done and finished successfully. `Failure`, as the name suggests, means the
    work failed, and then we call `Retry`, which retries the work.
  prefs: []
  type: TYPE_NORMAL
- en: In our `GetDataWorker()`, we pass in `NotificationViewModel` and inject it into
    our worker using Hilt. Sometimes you might encounter a conflict. The good thing
    is there is support for such a case with four options for handling any conflict
    that might occur.
  prefs: []
  type: TYPE_NORMAL
- en: This case is unique to when you are scheduling unique work; it makes sense to
    tell `WorkManager` what action must be taken when a conflict arises. You can solve
    this problem easily by using the existing work policy, `ExisitingWorkPolicy`,
    which has `REPLACE`, `KEEP APPEND`, and `APPEND_OR_REPLACE`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Replace`, as the name suggests, replaces the existing work, while `Keep` keeps
    existing work and ignores new work. When you call *Append*, this adds the new
    work to the existing one, and finally, `Append or Replace` simply does not depend
    on the pre-requisite work state.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkManager` is a singleton, hence it can only be initialized once, that is,
    either in your app or in the library. And, if you are using any workers with custom
    dependencies, then you have to provide a `WorkerFactory()` to the config at the
    time of custom initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can only cover some `WorkManager` steps here. Google has great sample code
    labs that you can follow through and understand how to use `WorkManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about `WorkManager`, you can use this link: [https://developer.android.com/guide/background/persistent](https://developer.android.com/guide/background/persistent).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WorkManager state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Understanding the Jetpack WorkManager library*, we
    looked into how we can use `WorkManager`. In that recipe, you might have noticed
    `Work` goes through a series of state changes, and the `doWork` function returns
    a result.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore states in depth.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will continue working on an example of how you can apply the concepts learned
    about in this recipe to your already-built project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed we mentioned before that we have three states: `Success`,
    `Failure`, and `Retry`. `Work` states, however, have different types of processes;
    we can have a one-time work state, periodic work state, or blocked state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can look into this abstract class in more depth by clicking on the result
    and seeing how it is written.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first recipe, *Understanding the Jetpack WorkManager library*, we looked
    into the steps of setting up `WorkManager`. Another great example is downloading
    files. You can override the `fun doWork()` and check whether your URI is not equal
    to null and return a success, else failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When handling a state, you can easily check when the state successfully specifies
    an action, when it failed to perform an action, and finally, when `WorkInfo.State`
    is equals to `RUNNING`, call `running()`; see the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The success result returns an instance of `ListenableWorker.Result`, used to
    indicate that the work was completed successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the mentioned states, you can either use `enqueueUniqueWork()`, which is
    used for one time, or `PeriodicWorkRequestBuilder`, which is used for periodic
    work. In our example, we used `PeriodicWorkRequestBuilder<Type>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We always start our request with the *Enqueued* state for the one-time work
    state, which means the work will run as soon as the constraints are met. Thereafter,
    we move to *Running*, and if we hit a *Success*, the work is done.
  prefs: []
  type: TYPE_NORMAL
- en: If in any instance, we end up *Running* and we don’t hit *Success*, then it
    means we failed. Then, we will move back to *Enqueued* since we need to retry.
    *Figure 7**.1* and *Figure 7**.2* explain the states better for both one-time
    work and periodic work states.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if it happens that our enqueued work gets cancelled, then we move it
    to cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – How one-time work requests work](img/Figure_7.1_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – How one-time work requests work
  prefs: []
  type: TYPE_NORMAL
- en: While the preceding image shows the one-time work state, the following diagram
    depicts the periodic work state.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.2 – How the periodic wo\uFEFFrk state works](img/Figure_7.2_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – How the periodic work state works
  prefs: []
  type: TYPE_NORMAL
- en: Understanding threading in WorkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of `WorkManager` as any process that runs in a background thread.
    When we use the `Worker()`, and `WorkManager` calls the `doWork()` function, this
    action works in the background thread. In detail, the background thread comes
    from the `Executor` specified in the `WorkManager` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create your own custom executor for your application needs, but
    if that’s not needed, you can use the pre-existing one. This recipe will explore
    how threading in a `Worker()` works and how to create a custom executor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, since we will be looking at examples, you can follow along by
    reading and seeing if this applies to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s learn how threading works in `WorkManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to configure `WorkManager` manually, you will need to specify your
    executor. This can be done by calling `WorkManager.initialize()`, then passing
    the context, and the configuration builder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our earlier example in the previous recipe, *Understanding WorkManager state*,
    we spoke about a use case where we download files. These files can be in the form
    of PDF, JPG, PNG, or even MP4\. We will look at an example that downloads content
    20 times; you can specify how many times you want your content to download:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Currently, if we do not handle the case where the `Worker()` is stopped, it
    is good practice to ensure that it is dealt with because this is an edge case.
    To address this case, we need to override the `Worker.onStopped()` method or call
    `Worker.isStopped` where necessary to free up some resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, when you stop the worker, the result is entirely ignored until you
    restart the process again. We used `CoroutineWorker` in our earlier example since
    `WorkManager` offers support for coroutines, hence why we collected the data in
    a flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Customizing your executor will require manually initializing `WorkManager`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to learn in the `WorkManager` Jetpack library, and it is fair
    to acknowledge that it can’t all be captured in just a few recipes. For instance,
    in some scenarios, when providing a custom threading strategy, you should use
    `ListenableWorker`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListenableWorker` is a class in the Android Jetpack `WorkManager` library
    that allows you to perform background work in a flexible and efficient manner.
    It is a subclass of the `Worker` class and adds the ability to return a `ListenableFuture`
    from its `doWork()` method, which allows for easier handling of asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: By using `ListenableWorker`, you can create a worker that returns a `ListenableFuture`
    and register callbacks that will be executed when the future completes. This can
    be useful for tasks such as network requests or database operations that require
    asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `Worker`, `CoroutineWorker`, and `RxWorker` derive from this particular
    class. `Worker`, as mentioned, runs in the background thread; `CoroutineWorker`
    is highly recommended for developers using Kotlin. `RxWorker` will not be touched
    upon here since Rx by itself is a big topic that caters to users that develop
    in reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your application might be using Rx. In that case, there are details on how
    threading works in Rx and how you can use `RxWorker`. See more here: [https://developer.android.com/guide/background/persistent/threading/rxworker](https://developer.android.com/guide/background/persistent/threading/rxworker).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding chaining and canceling work requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android development, ensuring you properly handle your application’s life
    cycle is crucial. Needless to say, this also applies to all background work, as
    a simple mistake can lead to your application draining the user’s battery, memory
    leaks, or even causing the application to crash or suffer from an **application
    not responding** (**ANR**) error. This could mean terrible reviews in the Play
    Store, which will later affect your business and causes stress for developers.
    How do you ensure this issue is handled well?
  prefs: []
  type: TYPE_NORMAL
- en: This can be done by ensuring all conflicts that arise while using `WorkManager`
    are appropriately handled or guaranteeing the policy we touched on in the previous
    recipe is well coded. In this recipe, we will look into chaining and canceling
    work requests and how to handle long-running work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Say your project requires an order by which the operation should run; `WorkManager`
    gives you the ability to enqueue and create a chain that specifies multiple dependent
    tasks, and here you can set the order in which you want the operations to occur.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will look at an example of how you might chain your work;
    since this is concept-based, we will look at the example and explain how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform chaining using `WorkManager`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will assume we have four unique `Worker` jobs to run in parallel.
    The output of these jobs will be passed to an upload `Worker`. Then, these will
    be uploaded to our server, like the sample project we had in the *Understanding
    the Jetpack WorkManager* *library* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will have our `WorkManager()` and pass in our context; then we will call
    `beginWith` and pass a list of our jobs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be able to maintain or preserve all our outputs from our job, we will need
    to use the `ArrayCreatingInputMerger::class`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is about it. There is definitely more to learn, but this serves our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to create the chain of work, we use `WorkManager.beginWith(OneTimeWorkRequest)`
    or use `WorkManager.beginWith` and pass a list of the one-time work requests that
    you have specified.
  prefs: []
  type: TYPE_NORMAL
- en: The `WorkManager.beginWith<List<OneTimeWorkRequest>>` operations return an instance
    of `WorkContinuation`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `WorkContinuation.enqueue()` function to enqueue our `WorkContinuation`
    chain. The `ArrayCreatingInputMerger` ensures we pair each key with an array.
    In addition, the `ArrayCreatingInputMerger` is a class in the Android Jetpack
    `WorkManager` library that allows you to merge input data from multiple `ListenableWorker`
    instances into a single array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if our keys are `unique`, we will get a result of one-element
    arrays. *Figure 7**.3* shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – How the array creating input merger works](img/Figure_7.3_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – How the array creating input merger works
  prefs: []
  type: TYPE_NORMAL
- en: If we have any colliding keys, then our values will be grouped together in our
    array, as in *Figure 7**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Key collision and result](img/Figure_7.4_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Key collision and result
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb is chains of work typically execute sequentially. This is
    reliant on the work being completed successfully. You might be wondering what
    happens when the job is enqueued in a chain of several work requests; just like
    a regular queue, all subsequent work is temporarily blocked until the first work
    request is completed. Think of it as *first come,* *first serve*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be wondering how you can support long-running workers; you can learn
    more at [https://developer.android.com/guide/background/persistent/how-to/long-running](https://developer.android.com/guide/background/persistent/how-to/long-running).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing migration from Firebase JobDispatcher to the new recommended WorkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Understanding the Jetpack WorkManager library* recipe, we talked about
    other libraries that are used for scheduling and executing deferrable background
    work. Firebase `JobDispatcher` is one of the popular ones. If you have used Firebase
    `JobDispatcher`, you might know it uses the `JobService()` subclass as its entry
    point. In this recipe, we will look at how you can migrate to the newly recommended
    `WorkManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be looking at how we can migrate from `JobService` to `WorkerManager`.
    This might apply to your project or not. It is essential to cover it, though,
    due to the fact that `WorkManager` is highly recommended, and we all have some
    legacy code. However, if your project is new, you can skip this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To migrate your Firebase `JobDispatcher` to `WorkManager`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you will need to add the required dependency; for this, you can reference
    the *Understanding the Jetpack WorkManager* *library* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you already have Firebase `JobDispatcher` in your project, you might have
    code similar to the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is easier if your application utilizes `JobServices()`; then, it will map
    to `ListenableWorker`. However, if your application is utilizing `SimpleJobService`,
    then in that case, you should use `Worker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your project is using `Job.Builder.setRecurring(true)`, in this case, you
    should change it to the `PeriodicWorkRequest` a class offered by `WorkManager`.
    You can also specify your tag, service if the job is recurring, trigger window,
    and more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition, to be able to achieve what we want, we will need to input data
    that will act as the input data for our `Worker`, then build our `WorkRequest`
    with our input data and the specific constraint. You can reference the *Understanding
    the Jetpack WorkManager library* recipe, and finally, enqueue the Work Request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can create your work request as either one-time or periodic and
    ensure you handle any edge cases, such as canceling work.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Firebase `JobDispatcher`, the `JobService.onStartJob()`, which is a function
    in the `JobSccheduler`, and `startWork()` are called on the main thread. In comparison,
    in `WorkManager`, the `ListenableWorker` is the basic unit of work. In our example,
    `YourWorker` implements the `ListenableWorker` and returns an instance of `ListenableFuture`,
    which helps in signaling work completion. However, you can implement your one-threading
    strategy based on your application’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: In Firebase, the `FirebaseJobBuilder` uses the `Job.Builder` serves as the Jobs
    metadata. In comparison, `WorkManager` uses `WorkRequest` to perform a similar
    role. `WorkManager` usually initializes itself by utilizing the `ContentProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: How to debug WorkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any operation that requires working in the background and sometimes making network
    calls need proper exception handling. This is due to the fact that you do not
    want your users facing issues and a lack of exception handling coming back to
    haunt your team or you as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, knowing how to debug `WorkManager` will come in handy, as this is one
    of those issues that might last for days if you have a bug. In this recipe, we
    will look at how to debug `WorkManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow this recipe, you must have completed all previous recipes of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might encounter an issue where `WorkManager` no longer runs if it is out
    of sync. Follow this recipe to debug `WorkManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to set up debugging, we will need to first create a custom initialization
    in our `AndroidManifest.xml` file, that is, by disabling the `WorkManager` initializer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we go ahead and set a minimum logging level to debug in our application
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once this is done, we will be able to see logs with the prefix `WM-` in our
    debug level easily, which will make our debugging work much more straightforward,
    and voila, we can move one step closer to solving our issue.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it might be helpful just to utilize the verbose `WorkManager` logs
    to capture any anomalies. In addition, you can enable logging and use your own
    custom initialization. That is what we do in the first step of our recipe. Furthermore,
    when we declare our own custom `WorkManager` configuration, our `WorkManager`
    will be initialized when we call the `WorkManager.getInstance(context)` and not
    naturally at application startup.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Worker implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing your `Worker` implementation is crucial, as it helps ensure your code
    is well handled and your team follows the proper guidelines for writing great
    code. This will be an integration test, which means we will add our code to the
    `androidTest` folder. This recipe will look into how to add tests for your worker.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along with this recipe, you need to have completed all previous recipes
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to get started with testing `WorkManager`. We will look
    at examples in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to add the testing dependency in your `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the scenario where something in the API changes in the future, there’s a
    stable version that you can use, and you can always find that in the documentation
    by following this link: [https://developer.android.com/jetpack/androidx/releases/work](https://developer.android.com/jetpack/androidx/releases/work).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to set up our `@Before` function, as provided by Google:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our `WorkManager` set up, we can go ahead and structure our
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can easily test and verify the states by following this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can add more tests such as verifying when the state is successful or checking
    initial delays; you can also go the extra mile and test the constraints and more.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library we use provides excellent support for testing `Worker`. For instance,
    we have `WorkManagerTestInitHelper` supplied to us through the library. Furthermore,
    we have the `SynchronousExecutor`, which makes our work as developers easier by
    ensuring synchronous writing tests is easy. Also, the issue of handling multiple
    threads, latches, and locks is dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: In our `testGetDataWorkerHasNoData`, we create a request, then enqueue it and
    wait for the results. We later get the info, then assert when the state is failed,
    it should fail. You can also test when it is successful.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test worker implementations with different variants, you can follow this
    link: [https://developer.android.com/guide/background/testing/persistent/worker-impl](https://developer.android.com/guide/background/testing/persistent/worker-impl).'
  prefs: []
  type: TYPE_NORMAL
