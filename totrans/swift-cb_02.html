<html><head></head><body><div id="sbo-rt-content"><section>&#13;
&#13;
                            <header class="header-title chapter-title">&#13;
                    Mastering the Building Blocks&#13;
                </header>&#13;
            &#13;
            <article>&#13;
                &#13;
<p>The previous chapter explained the basic types that form the building blocks of the Swift language. In this chapter, we will build on this knowledge to create more complex structures, such as arrays and dictionaries, before moving on and looking at some of the little gems Swift offers, such as tuples and typealias. Finally, we'll round off this chapter by looking at extensions and access control <span>â€“ both of which are</span> key components that contribute to a sound yet efficient codebase.</p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Bundling variables into tuples</li>&#13;
<li>Ordering your data with arrays</li>&#13;
<li>Containing your data in sets</li>&#13;
<li>Storing key-value pairs with dictionaries</li>&#13;
<li>Subscripts for custom types</li>&#13;
<li>Changing your name with typealias</li>&#13;
<li>Getting property changing notifications using property observers</li>&#13;
<li>Extending functionality with extensions</li>&#13;
<li>Controlling access with access control</li>&#13;
</ul>&#13;
<p>Let's get started!</p>&#13;
<h1 id="uuid-dc97d04f-f2d4-40c6-b434-26c9cd380659">Technical requirements</h1>&#13;
<p>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02" target="_blank">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/2YGayJh" target="_blank">https://bit.ly/2YGayJh</a></p>&#13;
<h1 id="uuid-48696491-91b7-44d1-8711-6750bc9dc742">Bundling variables into tuples</h1>&#13;
<p>A <strong>tuple</strong> is a combination of two or more values that can be treated as one. If you have ever wished you could return more than one value from a function or method, you should find tuples very interesting.</p>&#13;
<h2 id="uuid-1bb837b4-ec19-4ba2-9ba4-052ef8df338f">Getting ready</h2>&#13;
<p>Create a new playground and add the following statement:</p>&#13;
<pre>import Foundation </pre>&#13;
<p>This example uses one function from <kbd>Foundation</kbd>. We will delve into Foundation in more detail in <a href="a632f18a-5826-4757-90bc-7701c78edaaf.xhtml">Chapter 5</a>, <em>Beyond the Standard Library</em>, but for now, we just need to import it.</p>&#13;
<h2 id="uuid-4ecc2d36-67b2-492c-81ee-0e154348d801">How to do it...</h2>&#13;
<p>Let's imagine that we are building an app that pulls movie ratings from multiple sources and presents them together to help the user decide which movie to watch. These sources may use different rating systems, such as the following:</p>&#13;
<ul>&#13;
<li>Number of stars out of 5</li>&#13;
<li>Points out of 10</li>&#13;
<li>Percentage score</li>&#13;
</ul>&#13;
<p>We want to normalize these ratings <span>so that they can be compared directly and</span> displayed side by side. We want all the ratings to be represented as a number of stars out of 5, so we will write a function that will return the number of whole stars out of 5. We will then use this to display the correct number of stars in our <strong>user interface</strong> (<strong>UI</strong>).</p>&#13;
<p>Our UI also includes a label that will read <span class="packt_screen">x Star Movie</span>, where <strong>x</strong> is the number of stars. It would be useful if our function returned both the number of stars and a string that we can put in the UI. We can use a tuple to do this. Let's get started:</p>&#13;
<ol>&#13;
<li>Create a function to normalize the star ratings. The following function takes a rating and a total possible rating, and then returns a tuple of the normalized rating and a string to display in the UI:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func normalizedStarRating(forRating rating: Float, <br/>   ofPossibleTotal total: Float) -&gt; (Int, String) {<br/> <br/>} </pre>&#13;
<ol start="2">&#13;
<li>Inside the function, calculate the fraction of the total score. Then, multiply that by our normalized total score, 5, and round it to the nearest whole number:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let fraction = rating / total <br/>let ratingOutOf5 = fraction * 5 <br/>let roundedRating = round(ratingOutOf5) // Rounds to the nearest <br/>  // integer.</pre>&#13;
<ol start="3">&#13;
<li>Still within the function, take the rounded fraction and convert it from a <kbd>Float</kbd> into an <kbd>Int</kbd>. Then, create the display string and return both <kbd>Int</kbd> and <kbd>String</kbd> as a tuple:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let numberOfStars = Int(roundedRating) // Turns a Float into an Int <br/>let ratingString = "\(numberOfStars) Star Movie" <br/>return (numberOfStars, ratingString) </pre>&#13;
<ol start="4">&#13;
<li>Call our new function and store the result in a constant:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let ratingAndDisplayString = normalisedStarRating(forRating: 5, <br/>                               ofPossibleTotal: 10)</pre>&#13;
<ol start="5">&#13;
<li>Retrieve the number of stars rating from the tuple and print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let ratingNumber = ratingAndDisplayString.0 <br/>print(ratingNumber) // 3 - Use to show the right number of stars</pre>&#13;
<ol start="6">&#13;
<li>Retrieve the display string from the tuple and print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let ratingString = ratingAndDisplayString.1 <br/>print(ratingString) // "3 Star Movie" - Use to put in the label</pre>&#13;
<p>With that, we have created and used a tuple.</p>&#13;
<h2 id="uuid-fbf6db07-fa31-4899-ab19-7111fc403fce">How it works...</h2>&#13;
<p>A tuple is declared as a comma-separated list of the types it contains, within brackets. In the preceding code, you can see a tuple being declared as <kbd>(Int, String)</kbd>. The function, <kbd>normalizedStarRating</kbd>, normalizes the rating and creates <kbd>numberOfStars</kbd> as the closest round number of stars and <kbd>ratingString</kbd> as a display string. These values are then combined into a tuple by putting them, separated by a comma, within brackets; that is, <kbd>(numberOfStars, ratingString)</kbd>. This tuple value is then returned by the function.</p>&#13;
<p>Next, let's look at what we can do with that returned tuple value:</p>&#13;
<pre>let ratingAndDisplayString = normalizedStarRating(forRating: 5, <br/>                               ofPossibleTotal: 10) </pre>&#13;
<p>Calling our function returns a tuple that we store in a constant called <kbd>ratingAndDisplayString</kbd>. We can access the tuple's components by accessing the numbered member of the tuple:</p>&#13;
<pre>let ratingNumber = ratingAndDisplayString.0 <br/>print(ratingNumber) // 3 - Use to show the right number of stars <br/><br/>let ratingString = ratingAndDisplayString.1 <br/>print(ratingString) // "3 Star Movie" - Use to put in the label </pre>&#13;
<div class="packt_infobox">As is the case with most numbered systems in programming languages, the member numbering system starts with <kbd>0</kbd>. The number that's used to identify a certain place within a numbered collection is called an index.</div>&#13;
<p class="p1">There is another way to retrieve the <span>components</span> of a tuple that can be easier to remember than the numbered index. By specifying a tuple of variable names, each value of the tuple will be assigned to the respective variable names. Due to this, we can simplify accessing the tuple values and printing the result:</p>&#13;
<pre>let (nextNumber, nextString) = normalizedStarRating(forRating: 8, <br/>                                 ofPossibleTotal: 10)<br/>print(nextNumber) // 4<br/>print(nextString) // "4 Star Movie"</pre>&#13;
<p>Since the numerical value is the first value in the returned tuple, this gets assigned to the <kbd>nextNumber</kbd> constant, while the second value, the string, gets assigned to <kbd>nextString</kbd>. These can then be used like any other constant and removes the need to remember which index refers to which value. </p>&#13;
<p class="mce-root"/>&#13;
<h2 id="uuid-766bee09-4cd4-4a70-8eeb-0c1e0102bd6c">There's more...</h2>&#13;
<p>As we mentioned previously, accessing a tuple's components via a number is not ideal as we have to remember their order in the tuple to ensure that we are accessing the correct one. To provide some context, we can add labels to the tuple components, which can be used to identify them when they are accessed. Tuple labels are defined in a similar way to parameter labels, preceding the type and separated by a <kbd>:</kbd>. Let's add labels to the function we created in this recipe and then use those labels to access the tuple values:</p>&#13;
<pre>func normalizedStarRating(forRating rating: Float, <br/>                          ofPossibleTotal total: Float) <br/>                          -&gt; (starRating: Int, displayString: String) { <br/> <br/>    let fraction = rating / total <br/>    let ratingOutOf5 = fraction * 5 <br/>    let roundedRating = round(ratingOutOf5) // Rounds to the nearest <br/>      // integer. <br/>    let numberOfStars = Int(roundedRating) // Turns a Float into an Int <br/>    let ratingString = "\(numberOfStars) Star Movie" <br/><br/>    return (starRating: numberOfStars, displayString: ratingString) <br/>} <br/> <br/>let ratingAndDisplayString = normalizedStarRating(forRating: 5, <br/>                              ofPossibleTotal: 10) <br/><br/>let ratingInt = ratingAndDisplayString.starRating <br/>print(ratingInt) // 3 - Use to show the right number of stars <br/><br/>let ratingString = ratingAndDisplayString.displayString <br/>print(ratingString) // "3 Stars" - Use to put in the label </pre>&#13;
<p>As part of the function declaration, we can see the tuple being declared: </p>&#13;
<pre>(starRating: Int, displayString: String)</pre>&#13;
<p>When a tuple of that type is created, the provided values are preceded by the label:</p>&#13;
<pre>return (starRating: numberOfStars, displayString: ratingString)</pre>&#13;
<p class="mce-root">To access the components of the tuple, we can use these labels (although the number of indexes still work):</p>&#13;
<pre>let ratingValue = ratingAndDisplayString.starRating <br/>print(ratingValue) // 3 - Use to show the right number of stars <br/><br/>let ratingString = ratingAndDisplayString.displayString <br/>print(ratingString) // "3 Stars" - Use to put in the label</pre>&#13;
<p>Tuples are a convenient and lightweight way to bundle values together.</p>&#13;
<div class="packt_tip">In this example, we created a tuple with two components. However, a tuple can contain any number of components.</div>&#13;
<h2 id="uuid-bb028bbd-d63a-4077-bab9-dbb75848de89">See also</h2>&#13;
<p>Further information about tuples can be found in Apple's documentation on the Swift language at <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html"><span class="URLPACKT">https://docs.swift.org/swift-book/ReferenceManual/Types.html</span></a>.</p>&#13;
<h1 id="uuid-e635ca0d-f55e-428e-9ddd-bb4feb986cc3">Ordering your data with arrays</h1>&#13;
<p>So far in this book, we have learned about many different Swift constructs: <strong>classes</strong>, <strong>structs</strong>, <strong>enums</strong>, <strong>closures</strong>, <strong>protocols</strong>, and <strong>tuples</strong>. However, it is rare to deal with just one instance of these on their own. Often, we will have many of these constructs, and we need a way to collect multiple instances and place them in useful data structures. Over the next few recipes, we will examine three collection data structures provided by Swift; that is, <strong>arrays</strong>, <strong>sets</strong>, and <strong>dictionaries</strong> (dictionaries are often called <strong>hash tables</strong> in other programming languages):</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/9466565c-ce50-4e7d-bcae-1107183c6582.png" style="" width="912" height="354"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2.1 â€“ <span>Collection of data structures</span></div>&#13;
<p>While doing this, we will look at how to use them to store and access information, and then examine their relative characteristics.</p>&#13;
<h2 id="uuid-27ce4b18-3e5e-408e-a6c6-1c1d05a93253">Getting started</h2>&#13;
<p class="mce-root"><span>First, let's investigate </span><strong>arrays</strong><span>, which are ordered lists of elements. We won't be using any components from the previous recipes, so you can create a new playground for this recipe.</span></p>&#13;
<h2 id="uuid-0c3d271b-45fd-4e3b-b607-f2684ef568af">How to do it...</h2>&#13;
<p>Let's use an array to organize a list of movies to watch:</p>&#13;
<ol>&#13;
<li>Create an array called <kbd>moviesToWatch</kbd>. This will hold our strings:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var moviesToWatch: Array&lt;String&gt; = Array()</pre>&#13;
<ol start="2">&#13;
<li>Append three movies to the end of our movie list array:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">moviesToWatch.append("The Shawshank Redemption") <br/>moviesToWatch.append("Ghostbusters") <br/>moviesToWatch.append("Terminator 2")</pre>&#13;
<ol start="3">&#13;
<li>Print the names of each movie in the list, in turn:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(moviesToWatch[0]) // "The Shawshank Redemption"<br/>print(moviesToWatch[1]) // "Ghostbusters"<br/>print(moviesToWatch[2]) // "Terminator 2"</pre>&#13;
<ol start="4">&#13;
<li>Print a count of the number of movies in the list so far:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(moviesToWatch.count) // 3</pre>&#13;
<ol start="5">&#13;
<li>Insert a new movie into the list so that it's the third one in it. Since arrays are zero-based, this is done at index 2:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">moviesToWatch.insert("The Matrix", at: 2)</pre>&#13;
<ol start="6">&#13;
<li>Print the list count to check it has increased by one and print the newly updated list:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(moviesToWatch.count) // 4<br/>print(moviesToWatch)<br/>// The Shawshank Redemption<br/>// Ghostbusters<br/>// The Matrix<br/>// Terminator 2</pre>&#13;
<ol start="7">&#13;
<li>Use the <kbd>first</kbd> and <kbd>last</kbd> array properties to access their respective values and print them:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let firstMovieToWatch = moviesToWatch.first <br/>print(firstMovieToWatch as Any) // Optional("The Shawshank <br/>  Redemption") <br/>let lastMovieToWatch = moviesToWatch.last <br/>print(lastMovieToWatch as Any) // Optional("Terminator 2") </pre>&#13;
<ol start="8">&#13;
<li><span>Use an index subscript to access the second movie in the list and print it. Then, set a new value to that same subscript. Once you've done that, print the list count to check the number of movies that haven't changed and print the list to check that the second array element has changed:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let secondMovieToWatch = moviesToWatch[1] <br/>print(secondMovieToWatch) // "Ghostbusters"<br/>moviesToWatch[1] = "Ghostbusters (1984)" <br/>print(moviesToWatch.count) // 4 <br/>print(moviesToWatch) <br/>// The Shawshank Redemption <br/>// Ghostbusters (1984) <br/>// The Matrix <br/>// Terminator 2 </pre>&#13;
<ol start="9">&#13;
<li>Create a new array of spy movies by initializing it with some movies using the array literal syntax:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let spyMovieSuggestions: [String] = ["The Bourne Identity", <br/>                                     "Casino Royale", <br/>                                     "Mission Impossible"] </pre>&#13;
<ol start="10">&#13;
<li>Combine the two arrays we have created using the addition operator (<kbd>+</kbd>) and assign them back to the <kbd>moviesToWatch</kbd> variable. Then, print the array count so that it reflects the two lists combined and print the new list:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">moviesToWatch = moviesToWatch + spyMovieSuggestions <br/>print(moviesToWatch.count) // 7 <br/>print(moviesToWatch) <br/>// The Shawshank Redemption <br/>// Ghostbusters (1984) <br/>// The Matrix <br/>// Terminator 2 <br/>// The Bourne Identity <br/>// Casino Royale <br/>// Mission Impossible </pre>&#13;
<ol start="11">&#13;
<li>Next, use an array convenience initializer to create an array that contains three entries that are the same. Then, update each array element so that the rest of their movie titles are shown:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var starWarsTrilogy = Array&lt;String&gt;(repeating: "Star Wars: ", <br/>  count: 3) <br/>starWarsTrilogy[0] = starWarsTrilogy[0] + "A New Hope"  <br/>starWarsTrilogy[1] = starWarsTrilogy[1] + "Empire Strikes Back"  <br/>starWarsTrilogy[2] = starWarsTrilogy[2] + "Return of the Jedi"  <br/>print(starWarsTrilogy)  <br/>// Star Wars: A New Hope <br/>// Star Wars: Empire Strikes Back <br/>// Star Wars: Return of the Jedi</pre>&#13;
<ol start="12">&#13;
<li>Let's replace part of our existing movie list with our <kbd>starWarsTrilogy</kbd> list, and then print the count and list:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">moviesToWatch.replaceSubrange(2...4, with: starWarsTrilogy) <br/>print(moviesToWatch.count) // 7 <br/>print(moviesToWatch) <br/>// The Shawshank Redemption <br/>// Ghostbusters (1984) <br/>// Star Wars: A New Hope <br/>// Star Wars: Empire Strikes Back <br/>// Star Wars: Return of the Jedi <br/>// Casino Royale <br/>// Mission Impossible</pre>&#13;
<ol start="13">&#13;
<li>Lastly, remove the last movie in the list and check that the array count has reduced by one:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">moviesToWatch.remove(at: 6) <br/>print(moviesToWatch.count) // 6 <br/>print(moviesToWatch) <br/>// The Shawshank Redemption <br/>// Ghostbusters (1984) <br/>// Star Wars: A New Hope <br/>// Star Wars: Empire Strikes Back <br/>// Star Wars: Return of the Jedi <br/>// Casino Royale</pre>&#13;
<p>With that, we've looked at many ways we can create and manipulate arrays.</p>&#13;
<h2 id="uuid-f83731e1-2906-4194-90be-e1ab8431323b">How it works...</h2>&#13;
<p>When creating an array, we need to specify the type of elements that will be stored in the array. The array element type is declared in angular brackets as part of the array's type declaration. In our case, we are storing strings:</p>&#13;
<pre>var moviesToWatch: Array&lt;String&gt; = Array() <br/>moviesToWatch.append("The Shawshank Redemption") <br/>moviesToWatch.append("Ghostbusters") <br/>moviesToWatch.append("Terminator 2") </pre>&#13;
<p>The preceding code uses a Swift language feature called <strong>generics</strong>, which can be found in many programming languages, and will be covered in detail in <a href="abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml" target="_blank">Chapter 4</a>, <em>Generics, Operators, and Nested Types</em>.</p>&#13;
<p>The <kbd>append</kbd> method of <kbd>Array</kbd> will add a new element to the end of the array. Now that we have put some elements in the array, we can retrieve and print those elements:</p>&#13;
<pre>print(moviesToWatch[0]) // "The Shawshank Redemption" <br/>print(moviesToWatch[1]) // "Ghostbusters" <br/>print(moviesToWatch[2]) // "Terminator 2" </pre>&#13;
<p>Elements in an array are numbered with a zero-based index, so the first element in the array is at index 0, the second is at index 1, the third is at index 2, and so on. We can access the elements in the array using a subscript, in which we provide the index of the element we want to access. A subscript is specified in square brackets, after the array instance's name.</p>&#13;
<p>When an element is accessed using the index subscript, no check is done to ensure you have provided a valid index. In fact, if an index is provided that the array doesn't contain, this will cause a crash. Instead, we can use some index helper methods on <kbd>Array</kbd> to ensure that we have an index that is valid for this array. Let's use one of these helper methods to check an index that we know is valid for our array, and then another that we know is not valid:</p>&#13;
<pre class="mce-root">let index5 = moviesToWatch.index(moviesToWatch.startIndex,<br/>                                 offsetBy: 5,<br/>                                 limitedBy: moviesToWatch.endIndex)<br/>print(index5 as Any) // Optional(5)<br/><br/>let index10 = moviesToWatch.index(moviesToWatch.startIndex,<br/>                                  offsetBy: 10,<br/>                                  limitedBy: moviesToWatch.endIndex)<br/>print(index10 as Any) // nil</pre>&#13;
<p>The <kbd>index</kbd> method lets us specify the index we want as an offset of the first index parameter, but as something that's limited by the last index parameter. This will return the valid index if it is within the bounds, or <kbd>nil</kbd> if it is not. By the end of the playground, the <kbd>moviesToWatch</kbd> array contains six elements, in which case retrieving index 5 is successful but index 10 returns <kbd>nil</kbd>.</p>&#13;
<p>In the next chapter, we will cover how to make decisions based on whether this index exists, but for now, it's just useful to know that this method is available.</p>&#13;
<p><span>Arrays have a </span><kbd>count</kbd><span> property that tells us how many elements they store. So, when we add an element, this value will change:</span></p>&#13;
<pre>print(moviesToWatch.count) // 3 </pre>&#13;
<p><span>Elements can be inserted anywhere in the array using the same zero-based index that we used in the preceding code:</span></p>&#13;
<pre>moviesToWatch.insert("The Matrix", at: 2) </pre>&#13;
<p>So, by inserting <kbd>"The Matrix"</kbd> at index 2, it will be placed at the third position in our array, and all the elements at position 2 or greater will be moved down by 1.</p>&#13;
<p>This increases the array's count:</p>&#13;
<pre>print(moviesToWatch.count) // 4</pre>&#13;
<p>The array also provides some helpful computed properties for accessing elements at either end of the array:</p>&#13;
<pre>let firstMovieToWatch = moviesToWatch.first <br/>print(firstMovieToWatch as Any) // Optional("The Shawshank Redemption") <br/>let lastMovieToWatch = moviesToWatch.last <br/>print(firstMovieToWatch as Any) // Optional("Terminator 2") <br/>let secondMovieToWatch = moviesToWatch[1] <br/>print(secondMovieToWatch) // "Ghostbusters" </pre>&#13;
<p>These properties are optional values as the array may be empty, and if it is, these will be <kbd>nil</kbd>. However, accessing an array element via an index subscript returns a non-optional value.</p>&#13;
<p>In addition to retrieving values via the subscript, we can also assign values to an array subscript:</p>&#13;
<pre>moviesToWatch[1] = "Ghostbusters (1984)" </pre>&#13;
<p>This will replace the element at the given index with the new value.</p>&#13;
<p>When we created our first array, we created an empty array and then appended values to it. Additionally, an array literal can be used to <span>create an array</span> that already contains values:</p>&#13;
<pre>let spyMovieSuggestions: [String] = ["The Bourne Identity", <br/>                                     "Casino Royale", <br/>                                     "Mission Impossible"] </pre>&#13;
<p>An array type can be specified with the element type enclosed by square brackets, and the array literal can be defined by comma-separated elements within square brackets. So, we can define an array of integers like this:</p>&#13;
<pre>let fibonacci: [Int] = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] </pre>&#13;
<p>As we learned in the previous chapter, the compiler can often infer the type from the value we assign, and when the type is inferred, we don't need to specify it. In both the preceding arrays, <kbd>spyMovieSuggestions</kbd> and <kbd>fibonacci</kbd>, all the elements in the array are of the same type; that is, <kbd>String</kbd> and <kbd>Int</kbd>, respectively. Since these types can be inferred, we don't need to define them:</p>&#13;
<pre>let spyMovieSuggestions = ["The Bourne Identity", "Casino Royale", <br/>  "Mission Impossible"]<br/>let fibonacci = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] </pre>&#13;
<p>Arrays can be combined using the <kbd>+</kbd> operator:</p>&#13;
<pre>moviesToWatch = moviesToWatch + spyMovieSuggestions</pre>&#13;
<p>This will create a new array by appending the elements in the second array to the first.</p>&#13;
<p><span>The array provides a convenience initializer that will fill an array with repeating elements. We can use this initializer to create an array with the name of a well-known movie trilogy:</span></p>&#13;
<pre>var starWarsTrilogy = Array&lt;String&gt;(repeating: "Star Wars: ", count: 3)</pre>&#13;
<p>We can then combine subscript access, string appending, and subscript assignment to add the full movie name to our trilogy array:</p>&#13;
<pre>starWarsTrilogy[0] = starWarsTrilogy[0] + "A New Hope" <br/>starWarsTrilogy[1] = starWarsTrilogy[1] + "Empire Strikes Back" <br/>starWarsTrilogy[2] = starWarsTrilogy[2] + "Return of the Jedi" </pre>&#13;
<p>The array also provides a helper for replacing a range of values with the values contained in another array:</p>&#13;
<pre>moviesToWatch.replaceSubrange(2...4, with: starWarsTrilogy)</pre>&#13;
<p>Here, we have specified a range using <kbd>...</kbd> to indicate a range between two integer values, inclusive of those values. So, this range contains the integers 2, 3, and 4.</p>&#13;
<p>We will specify ranges in this way in subsequent chapters. Alternatively, you can specify a range that goes up to, but not including, the top of the range. This is known as a half-open range:</p>&#13;
<pre>moviesToWatch.replaceSubrange(2..&lt;5, with: starWarsTrilogy)  </pre>&#13;
<p>For our arrays, we've added elements, accessed them, and replaced them, so we need to know how to remove elements from an array:</p>&#13;
<pre>moviesToWatch.remove(at: 6) </pre>&#13;
<p>Provide the index of the element to the <kbd>remove</kbd> method. By doing this, the element at that index will be removed from the array, and all the subsequent elements will move up one place to fill the empty space. This will reduce the array's count by 1:</p>&#13;
<pre>print(moviesToWatch.count) // 6 </pre>&#13;
<h2 id="uuid-c5e4d28c-2fd3-4eb4-8674-a13ba494c9fe">There's more...</h2>&#13;
<p>If you are familiar with Objective-C, you will have used <kbd>NSArray</kbd>, which provides similar functionalities to a Swift array. You may also remember that <kbd>NSArray</kbd> is immutable, which means its contents can't be changed once it's been created. If you need to change its contents, then an <kbd>NSMutableArray</kbd> should be used instead. Due to this, you may be wondering if Swift has similar concepts of mutable and immutable arrays. It does but rather than using separate mutable and immutable types, you create a mutable array by declaring it as a variable and an immutable array by declaring it as a constant:</p>&#13;
<pre>let evenNumbersTo10 = [2, 4, 6, 8, 10] <br/>evenNumbersTo10.append(12) // Doesn't compile <br/><br/>var evenNumbersTo12 = evenNumbersTo10<br/>evenNumbersTo12.append(12) // Does compile</pre>&#13;
<p>To understand why this is the case, it's important to know that an array is a value type, as are the other collection types in Swift.</p>&#13;
<p>As we saw in the previous chapter, a value type is immutable in nature and creates a changed copy whenever it is mutated. Therefore, by assigning the array to a constant using <kbd>let</kbd>, we prevent any new value from being assigned, making mutating the array impossible.</p>&#13;
<h2 id="uuid-dad0e63f-55ff-4d3c-bc46-d35cea4cbe8a">See also</h2>&#13;
<p>Further information about arrays can be found in Apple's documentation on the Swift language at <a href="https://developer.apple.com/documentation/swift/array">https://developer.apple.com/documentation/swift/array</a>.<a href="https://developer.apple.com/documentation/swift/array"/></p>&#13;
<p>Arrays use generics to define the element type they contain. Generics will be discussed in detail in <a href="abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml">Chapter 4</a>, <em>Generics, Operators, and Nested Types</em>.</p>&#13;
<h1 id="uuid-5e546884-b523-4b15-8e56-f5ea3e76f3b3">Containing your data in sets</h1>&#13;
<p>The next collection type we will look at is a <strong>set</strong>. Sets differ from arrays in two important ways. The elements in a set are stored <em>unordered</em>, and each unique element is only held once. In this recipe, we will learn how to create and manipulate sets.</p>&#13;
<h2 id="uuid-2ff7a809-e29a-434f-9cae-f10d6d4fbb3d">How to do it...</h2>&#13;
<p>First, let's explore some ways we can create sets and perform set algebra on them:</p>&#13;
<ol>&#13;
<li>Create an array that contains the first nine Fibonacci numbers, and also a set containing the same:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let fibonacciArray: Array&lt;Int&gt; = [1, 1, 2, 3, 5, 8, 13, 21, 34] <br/>let fibonacciSet: Set&lt;Int&gt; = [1, 1, 2, 3, 5, 8, 13, 21, 34] <br/>print(fibonacciArray.count) // 9 <br/>print(fibonacciSet.count) // 8</pre>&#13;
<ol start="2">&#13;
<li>Print out the number of elements in each collection using the <kbd>count</kbd> property. Despite being created with the same elements, the count value is different:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(fibonacciArray.count) // 9 <br/>print(fibonacciSet.count) // 8 </pre>&#13;
<ol start="3">&#13;
<li>Insert an element into a set of animals, remove an element, and check whether a set contains a given element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var animals: Set&lt;String&gt; = ["cat", "dog", "mouse", "elephant"] <br/>animals.insert("rabbit") <br/>print(animals.contains("dog")) // true <br/>animals.remove("dog") <br/>print(animals.contains("dog")) // false</pre>&#13;
<ol start="4">&#13;
<li>Create some sets containing common mathematical number groups. We will use these to explore some methods for set algebra:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let evenNumbers = Set&lt;Int&gt;(arrayLiteral: 2, 4, 6, 8, 10) <br/>let oddNumbers: Set&lt;Int&gt; = [1, 3, 5, 7, 9] <br/>let squareNumbers: Set&lt;Int&gt; = [1, 4, 9] <br/>let triangularNumbers: Set&lt;Int&gt; = [1, 3, 6, 10]</pre>&#13;
<ol start="5">&#13;
<li>Obtain the union of two sets and print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let evenOrTriangularNumbers = evenNumbers.union(triangularNumbers) <br/>  // 2, 4, 6, 8, 10, 1, 3, unordered <br/>print(evenOrTriangularNumbers.count) // 7 </pre>&#13;
<ol start="6">&#13;
<li>Obtain the intersection of two sets and print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let oddAndSquareNumbers = oddNumbers.intersection(squareNumbers) <br/>  // 1, 9, unordered <br/>print(oddAndSquareNumbers.count) // 2 </pre>&#13;
<ol start="7">&#13;
<li>Obtain the symmetric difference of two sets and print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let squareOrTriangularNotBoth = <br/>  squareNumbers.symmetricDifference(triangularNumbers) <br/>   // 4, 9, 3, 6, 10, unordered <br/>print(squareOrTriangularNotBoth.count) // 5</pre>&#13;
<ol start="8">&#13;
<li>Obtain the result of subtracting one set from another and print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let squareNotOdd = squareNumbers.subtracting(oddNumbers) // 4 <br/>print(squareNotOdd.count) // 1 </pre>&#13;
<p>Next, we will examine the set membership comparison methods that are available:</p>&#13;
<ol start="1">&#13;
<li>Create some sets with overlapping membership:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let animalKingdom: Set&lt;String&gt; = ["dog", "cat", "pidgeon", <br/>                                  "chimpanzee", "snake", "kangaroo", <br/>                                  "giraffe", "elephant", "tiger", <br/>                                  "lion", "panther"] <br/><br/>let vertebrates: Set&lt;String&gt; = ["dog", "cat", "pidgeon", <br/>                                "chimpanzee", "snake", "kangaroo", <br/>                                "giraffe", "elephant", "tiger", <br/>                                "lion", "panther"]<br/> <br/>let reptile: Set&lt;String&gt; = ["snake"] <br/><br/>let mammals: Set&lt;String&gt; = ["dog", "cat", "chimpanzee", <br/>                            "kangaroo", "giraffe", "elephant", <br/>                            "tiger", "lion", "panther"]<br/> <br/>let catFamily: Set&lt;String&gt; = ["cat", "tiger", "lion", "panther"] <br/><br/>let domesticAnimals: Set&lt;String&gt; = ["cat", "dog"]</pre>&#13;
<ol start="2">&#13;
<li>Use the <kbd>isSubset</kbd> method to determine whether one set is a subset of another. Then, print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(mammals.isSubset(of: animalKingdom)) // true</pre>&#13;
<ol start="3">&#13;
<li>Use the <kbd>isSuperset</kbd> method to determine whether one set is a superset of another. Then, print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(mammals.isSuperset(of: catFamily)) // true</pre>&#13;
<ol start="4">&#13;
<li>Use the <kbd>isStrictSubset</kbd> method to determine whether one set is a strict subset of another. Then, print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(vertebrates.isStrictSubset(of: animalKingdom)) // false <br/>print(mammals.isStrictSubset(of: animalKingdom)) // true</pre>&#13;
<ol start="5">&#13;
<li>Use <span>the </span><kbd>isStrictSuperset</kbd><span> method to determine whether one set is a strict superset of another. Then, print the result:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(animalKingdom.isStrictSuperset(of: vertebrates)) // false <br/>print(animalKingdom.isStrictSuperset(of: domesticAnimals))  // true </pre>&#13;
<ol start="6">&#13;
<li>Use <span>the </span><kbd>isDisjoint</kbd><span> method to determine whether one set is disjointed with another. Then, print the result:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(catFamily.isDisjoint(with: reptile)) // true</pre>&#13;
<h2 id="uuid-0701c534-a076-4f7a-8e47-6ac05fb69767">How it works...</h2>&#13;
<p>Sets are created in almost the same way as arrays, and like arrays, we have to specify the element type that we will be stored in them:</p>&#13;
<pre>let fibonacciArray: Array&lt;Int&gt; = [1, 1, 2, 3, 5, 8, 13, 21, 34] <br/>let fibonacciSet: Set&lt;Int&gt; = [1, 1, 2, 3, 5, 8, 13, 21, 34] </pre>&#13;
<p>Arrays and sets store their elements differently. If you provide multiple elements of the same value to an array, it will store them multiple times. A set works differently; it will only store one version of each unique element. Therefore, in the preceding Fibonacci number sequence, the array stores two elements for the first two values, <kbd>1, 1</kbd>, but the set will store this as just one <kbd>1</kbd> element. This leads to the collections having different counts, despite being created with the same values:</p>&#13;
<pre>print(fibonacciArray.count) // 9 <br/>print(fibonacciSet.count) // 8</pre>&#13;
<p>This ability to store elements uniquely is made possible due to a requirement that a set has regarding the type of elements it can hold. A set's elements must conform to the <kbd>Hashable</kbd> protocol. This protocol requires a <kbd>hashValue</kbd> property to be provided as an <kbd>Int</kbd>, and the set uses this <kbd>hashValue</kbd> to do its uniqueness comparison. Both the <kbd>Int</kbd> and <kbd>String</kbd> types conform to <kbd>Hashable</kbd>, but any custom types that will be stored in a set will also need to conform to <kbd>Hashable</kbd>.</p>&#13;
<p>A set's <kbd>insert</kbd>, <kbd>remove</kbd>, and <kbd>contains</kbd> methods work as you would expect, with the compiler enforcing that the correct types are provided. This compiler type checking is done thanks to the <strong>generics</strong> constraints that all the collection types have. We will cover generics in more detail in <a href="abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml" target="_blank">Chapter 4</a>, <em>Generics, Operators, and Nested Types</em>.</p>&#13;
<h3 id="uuid-0f2b434f-4685-4191-9a27-a2996e685b6b">Union</h3>&#13;
<p>The <kbd>union</kbd> method returns a set containing all the unique elements from the set that the method is called on, as well as the set that was provided as a parameter:</p>&#13;
<pre>let evenOrTriangularNumbers = evenNumbers.union(triangularNumbers) <br/>  // 2,4,6,8,10,1,3,unordered </pre>&#13;
<p>The following diagram depicts the <span class="packt_screen">Union</span> of <span class="packt_screen">Set A</span> and <span class="packt_screen">Set B</span>:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/59c17cc6-b85a-4ac7-b5a7-b785c46250b0.png" style="" width="523" height="441"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.2 â€“ Union of sets</div>&#13;
<h3 id="uuid-40a043df-6461-405b-a3ed-48aa0ad6fcdf">Intersection</h3>&#13;
<p>The <kbd>intersection</kbd> method returns a set of unique elements that were contained in both the set that the method was called on and the set that was provided as a parameter:</p>&#13;
<pre>let oddAndSquareNumbers = oddNumbers.intersection(squareNumbers) <br/>  // 1, 9, unordered</pre>&#13;
<p>The following diagram depicts the <span class="packt_screen">Intersection</span> of <span class="packt_screen">Set A</span> and <span class="packt_screen">Set B</span>:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/51783c0f-21db-4fd7-9014-e85a1e07c9fb.png" style="" width="523" height="442"/></div>&#13;
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.3 â€“ Set intersection</span></div>&#13;
<h3 id="uuid-084ee65e-9504-4b37-91e6-5c0cff025464">Symmetric difference</h3>&#13;
<p>The <kbd>symmetricDifference</kbd> method returns a set of unique elements that are in either the set the method is called on, or the set that's provided as a parameter, but not elements that are in both:</p>&#13;
<pre>let squareOrTriangularNotBoth =<br/>  squareNumbers.symmetricDifference(triangularNumbers)  <br/>// 4, 9, 3, 6, 10, unordered </pre>&#13;
<div class="packt_infobox">This <kbd>set</kbd> operation is sometimes referred to as method is so <span><kbd>exclusiveOr</kbd>, both other programming languages, including previous versions of Swift.</span></div>&#13;
<p>The following diagram depicts the <span class="packt_screen">Symmetric Difference</span> of <span class="packt_screen">Set A</span> and <span class="packt_screen">Set B</span>:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/df2aff4d-ef9d-4390-8b76-4065c892a8ed.png" style="" width="522" height="442"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.4 â€“ Symmetric difference</span></div>&#13;
<h3 id="uuid-87ad0b91-61ab-489e-90bf-1a5ae0caafe8">Subtracting</h3>&#13;
<p>The <kbd>subtracting</kbd> method returns a unique set of elements that can be found in the set the method was called on, but not in the set that was passed as a parameter. Unlike the other set manipulation methods we've mentioned, this will not necessarily return the same value if you swap the set that the method is called on with the set provided as a parameter:</p>&#13;
<pre>let squareNotOdd = squareNumbers.subtracting(oddNumbers) // 4 </pre>&#13;
<p><span>The following diagram depicts the set that's created by </span><span class="packt_screen">Subtracting</span><span> </span><span class="packt_screen">Set B</span><span> from </span><span class="packt_screen">Set A</span><span>:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/4a012c09-14cc-4871-a56c-eeefaceb6520.png" style="" width="520" height="437"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.5â€“ Subtracting a set</span></div>&#13;
<h3 id="uuid-cf2b1aaa-9c2d-4a3f-8fe8-176d6e0faaf1">Membership comparison</h3>&#13;
<p>In addition to set manipulation methods, there are a number of methods we can use to determine information about set membership.</p>&#13;
<p>The <kbd>isSubset</kbd> method will return true if all the elements in the set that the method is called on are contained within the set that's passed as a parameter:</p>&#13;
<pre>print(mammals.isSubset(of: animalKingdom)) // true</pre>&#13;
<p>The following diagram depicts <span class="packt_screen">Set B</span> as the <span class="packt_screen">subset</span> of <span class="packt_screen">Set A</span>:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/6e8393bc-3f75-4167-b2a9-7b8838b91fb8.png" style="" width="347" height="388"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.6 â€“ Subset</span></div>&#13;
<p>This will also return true if the two sets are equal (they contain the same elements). If you only want a true value if the set that the method is called on is a subset and <em>not</em> equal, then you can use <kbd>isStrictSubset</kbd>:</p>&#13;
<pre>print(vertebrates.isStrictSubset(of: animalKingdom)) // false <br/>print(mammals.isStrictSubset(of: animalKingdom)) // true </pre>&#13;
<p>The <kbd>isSuperset</kbd> method will return true if all the elements in the set that have been passed as a parameter are within the set that the method is called on:</p>&#13;
<pre>print(mammals.isSuperset(of: catFamily)) // true </pre>&#13;
<p>The following diagram depicts <span class="packt_screen">Set A</span> as the <span class="packt_screen">superset</span> of <span class="packt_screen">Set B</span>:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/b5a19446-b50f-428a-8c8e-08ea715425c0.png" style="" width="345" height="388"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.7 â€“ Superset</span></div>&#13;
<p>This will also return true if the two sets are equal (they contain the same elements). If you only want a true value if the set that the method is called on is a superset and not equal, then you can use <kbd>isStrictSuperset</kbd>:</p>&#13;
<pre>print(animalKingdom.isStrictSuperset(of: vertebrates))     // false <br/>print(animalKingdom.isStrictSuperset(of: domesticAnimals)) // true</pre>&#13;
<p>The <kbd>isDisjoint</kbd> method will return true if there are no common elements between the set that the method is called on and the set that was passed as a parameter:</p>&#13;
<pre>print(catFamily.isDisjoint(with: reptile)) // true </pre>&#13;
<p>The following diagram shows that <span class="packt_screen">Set A</span> and <span class="packt_screen">Set B</span> are <span class="packt_screen">disjoint</span>:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/d287cfca-139b-4ee9-b258-15d8ad631be0.png" style="" width="586" height="395"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.8 â€“ Disjoint</span></div>&#13;
<p>As with arrays, a set can be declared immutable by assigning it to a <kbd>let</kbd> constant instead of a <kbd>var</kbd> variable:</p>&#13;
<pre>let planets: Set&lt;String&gt; = ["Mercury", "Venus", "Earth", <br/>                            "Mars", "Jupiter", "Saturn", <br/>                            "Uranus", "Neptune", "Pluto"] <br/>planets.remove("Pluto") // Doesn't compile </pre>&#13;
<p>This is because a set, like the other collection types, is a value type. Removing an element would mutate the set, which creates a new copy, but a <kbd>let</kbd> constant can't have a new value assigned to it, so the compiler prevents any mutating operations.</p>&#13;
<h2 id="uuid-2add36f1-27b7-4e24-85a0-c4d604b7453f">See also</h2>&#13;
<p>Further information about arrays can be found in Apple's documentation on the Swift language at <a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html">https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html</a>.</p>&#13;
<p>Sets use generics to define the element types they contain. Generics will be discussed in detail in <a href="abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml" target="_blank">Chapter 4</a>, <em>Generics, Operators, and Nested Types</em>.</p>&#13;
<h1 id="uuid-2c456859-432e-4754-8d05-058b3833c1f4">Storing key-value pairs with dictionaries</h1>&#13;
<p>The last collection type we will look at is the <strong>dictionary</strong>. This is a familiar construct in programming languages, where it is sometimes referred to as a <strong>hash table</strong>. A dictionary holds a collection of pairings between a key and a value. The <strong>key</strong> can be any element that conforms to the <kbd>Hashable</kbd> protocol (just like elements in a set), while the <strong>value</strong> can be any type. The contents of a dictionary is not stored in order, unlike an array; instead, the <em>key</em> is used both when storing a value and as a lookup when retrieving a value.</p>&#13;
<h2 id="uuid-edfde330-bc02-45a4-9060-03dbc853ed70">Getting ready</h2>&#13;
<p>In this recipe, we will use a dictionary to store details of people at a place of work. We need to store and retrieve a person's information based on their role in the organization, such as a company directory. To hold this person's information, we will use a modified version of our <kbd>Person</kbd> class from <a href="f9d48715-ffca-464f-95bf-722958f02e72.xhtml" target="_blank">Chapter 1</a>, <em>Swift Building Blocks</em>.</p>&#13;
<p>Enter the following code into a new playground:</p>&#13;
<pre>struct PersonName { <br/>    let givenName: String <br/>    let familyName: String <br/>} <br/> <br/>enum CommunicationMethod { <br/>    case phone <br/>    case email <br/>    case textMessage <br/>    case fax <br/>    case telepathy <br/>    case subSpaceRelay <br/>    case tachyons <br/>} <br/> <br/>class Person { <br/>    let name: PersonName <br/>    let preferredCommunicationMethod: CommunicationMethod <br/>     <br/>    convenience init(givenName: String, <br/>                     familyName: String, <br/>                     commsMethod: CommunicationMethod) { <br/>        let name = PersonName(givenName: givenName, familyName: <br/>          familyName) <br/>        self.init(name: name, commsMethod: commsMethod) <br/>    } <br/>     <br/>    init(name: PersonName, commsMethod: CommunicationMethod) { <br/>        self.name = name <br/>        preferredCommunicationMethod = commsMethod <br/>    } <br/><br/>    var displayName: String {<br/>        return "\(name.givenName) \(name.familyName)"<br/>    }<br/>} </pre>&#13;
<h2 id="uuid-13634240-25bf-4210-ae88-c575e8028b95">How to do it...</h2>&#13;
<p>Let's use the <kbd>Person</kbd> object we defined previously to build up our workplace directory using a dictionary:</p>&#13;
<ol>&#13;
<li>Create a <kbd>Dictionary</kbd> for the employee directory:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var crew = Dictionary&lt;String, Person&gt;()</pre>&#13;
<ol start="2">&#13;
<li><span>Populate the dictionary with employee details:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">crew["Captain"] = Person(givenName: "Jean-Luc", <br/>                         familyName: "Picard", <br/>                         commsMethod: .phone)<br/><br/>crew["First Officer"] = Person(givenName: "William", <br/>                               familyName: "Riker", <br/>                               commsMethod: .email)<br/><br/>crew["Chief Engineer"] = Person(givenName: "Geordi", <br/>                                familyName: "LaForge", <br/>                                commsMethod: .textMessage)<br/><br/>crew["Second Officer"] = Person(givenName: "Data", <br/>                                familyName: "Soong", <br/>                                commsMethod: .fax)<br/><br/>crew["Councillor"] = Person(givenName: "Deanna", <br/>                            familyName: "Troi", <br/>                            commsMethod: .telepathy)<br/><br/>crew["Security Officer"] = Person(givenName: "Tasha", <br/>                                  familyName: "Yar", <br/>                                  commsMethod: .subSpaceRelay)<br/><br/>crew["Chief Medical Officer"] = Person(givenName: "Beverly", <br/>                                       familyName: "Crusher", <br/>                                       commsMethod: .tachyons)</pre>&#13;
<ol start="3">&#13;
<li>Retrieve an array of all the keys in the dictionary. This will give us an array of all the roles in the organization:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let roles = Array(crew.keys) <br/>print(roles)</pre>&#13;
<ol start="4">&#13;
<li>Use a key to retrieve one of the employees and print the result:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let firstRole = roles.first! // Chief Medical Officer <br/>let cmo = crew[firstRole]! // Person: Beverly Crusher <br/>print("\(firstRole): \(cmo.displayName)")<br/>// Chief Medical Officer: Beverly Crusher</pre>&#13;
<ol start="5">&#13;
<li>Replace a value in the dictionary by assigning a new value against an existing key. T<span>he previous value for the key is discarded when a new value is set</span>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(crew["Security Officer"]!.name.givenName) // Tasha<br/><br/>crew["Security Officer"] = Person(givenName: "Worf", <br/>                                  familyName: "Son of Mogh", <br/>                                  commsMethod: .subSpaceRelay)<br/><br/>print(crew["Security Officer"]!.name.givenName) // Worf</pre>&#13;
<p>With that, we have learned how to create, populate, and look up values in a dictionary.</p>&#13;
<h2 id="uuid-d49324a7-e451-4a88-9cdc-f9040d16e52c">How it works...</h2>&#13;
<p>As with the other collection types, when we create a dictionary, we need to provide the types that the dictionary will be holding. For dictionaries, there are two types that we need to define. The first is the type of the key (which must conform to <kbd>Hashable</kbd>), while the second is the type of the value being stored against the key. For our dictionary, we are using <kbd>String</kbd> for the key and <kbd>Person</kbd> for the values being stored:</p>&#13;
<pre>var crew = Dictionary&lt;String, Person&gt;() </pre>&#13;
<p>As with an array, we can specify a <kbd>dictionary</kbd> type using square brackets and create one using a dictionary literal, where <kbd>:</kbd> separates the key and the value:</p>&#13;
<pre>let intByName: [String: Int] = ["one": 1, "two": 2, "three": 3] </pre>&#13;
<p>Therefore, we can change our dictionary definition so that it looks like this:</p>&#13;
<pre>var crew: [String: Person] = [:] </pre>&#13;
<p>The <kbd>[:]</kbd> symbol denotes an empty dictionary as a dictionary literal.</p>&#13;
<p>Elements are added to a dictionary using a subscript. Unlike an array, which takes an <kbd>Int</kbd> index in the subscript, a dictionary takes the key and then pairs the given value with the given key. In the following example, we are assigning a <kbd>Person</kbd> object to the <kbd>"Captain"</kbd> key:</p>&#13;
<pre>crew["Captain"] = Person(givenName: "Jean-Luc", <br/>                         familyName: "Picard", <br/>                         commsMethod: .phone) </pre>&#13;
<p>If no value currently exists, the assigned value will be added. If a value already exists for the given key, the old value will be replaced with the new value and the old value will be discarded.</p>&#13;
<p>There are properties on the dictionary that provide all the keys and values. These properties are of a custom collection type that can be passed to an array initializer to create an array:</p>&#13;
<pre>let roles = Array(crew.keys)  <br/>print(roles)  </pre>&#13;
<p>To display all the dictionary's keys, as provided by the <kbd>keys</kbd> property, we can either create an array or iterate over the collection directly. We will cover iterating over a collection's values in the next chapter, so for now, we will create an array.</p>&#13;
<p>Next, we will use one of the values from an array of keys, alongside the crew, to retrieve full details about the associated <kbd>Person</kbd>:</p>&#13;
<pre>let firstRole = roles.first! // Chief Medical Officer <br/>let cmo = crew[firstRole]! // Person: Beverly Crusher <br/>print("\(firstRole): \(cmo.displayName)")<br/>// Chief Medical Officer: Beverly Crusher</pre>&#13;
<p>We get the first element using the <kbd>first</kbd> property, but since this is an optional type, we need to force unwrap it using <kbd>!</kbd>. We can pass <kbd>firstRole</kbd>, which is now a non-optional <kbd>String</kbd> to the dictionary subscript, to get the <kbd>Person</kbd> object associated with that key. The return type for retrieving the value via subscript is also optional, so it also needs to be force unwrapped before we print its values.</p>&#13;
<div class="packt_infobox"><strong>Force unwrapping</strong> is usually an unsafe thing to do since if we force unwrap a value that turns out to be <kbd>nil</kbd>, our code will crash. We advise you to check that a value isn't <kbd>nil</kbd> before unwrapping the optional. We will cover how to do this in the next chapter.</div>&#13;
<h2 id="uuid-a8c34e38-ecef-4208-b2b0-693a351d16d5">There's more...</h2>&#13;
<p>In this recipe, we used strings as the keys for our dictionary. However, we can also use a type that conforms to the <kbd>Hashable</kbd> protocol.</p>&#13;
<p>One downside of using <kbd>String</kbd> as a key for our employee directory is that it is very easy to mistype an employee's role or look for a role that you expect to exist but doesn't. So, we can improve our implementation by using something that conforms to <kbd>Hashable</kbd> and is better suited to being used as a key in our model.</p>&#13;
<p class="mce-root">We have a finite set of employee roles in our model, and an <strong>enumeration</strong> is perfect for representing a finite number of options, so let's define our roles as an enum:</p>&#13;
<pre>enum Role: String { <br/>    case captain = "Captain" <br/>    case firstOfficer = "First Officer" <br/>    case secondOfficer = "Second Officer" <br/>    case chiefEngineer = "Chief Engineer" <br/>    case councillor = "Councillor" <br/>    case securityOfficer = "Security Officer" <br/>    case chiefMedicalOfficer = "Chief Medical Officer" <br/>}</pre>&#13;
<p>Now, let's change our <kbd>Dictionary</kbd> definition so that it uses this new <kbd>enum</kbd> as a key, and then insert our employees using these <kbd>enum</kbd> values:</p>&#13;
<pre>var crew = Dictionary&lt;Role, Person&gt;() <br/><br/>crew[.captain] = Person(givenName: "Jean-Luc", <br/>                        familyName: "Picard", <br/>                        commsMethod: .phone) <br/><br/>crew[.firstOfficer] = Person(givenName: "William", <br/>                             familyName: "Riker", <br/>                             commsMethod: .email) <br/><br/>crew[.chiefEngineer] = Person(givenName: "Geordi", <br/>                              familyName: "LaForge", <br/>                              commsMethod: .textMessage) <br/><br/>crew[.secondOfficer] = Person(givenName: "Data", <br/>                              familyName: "Soong", <br/>                              commsMethod: .fax) <br/><br/>crew[.councillor] = Person(givenName: "Deanna", <br/>                           familyName: "Troi", <br/>                           commsMethod: .telepathy) <br/><br/>crew[.securityOfficer] = Person(givenName: "Tasha", <br/>                                familyName: "Yar", <br/>                                commsMethod: .subSpaceRelay) <br/><br/>crew[.chiefMedicalOfficer] = Person(givenName: "Beverly", <br/>                                    familyName: "Crusher", <br/>                                    commsMethod: .tachyons) </pre>&#13;
<p>You will also need to change all the other uses of <kbd>crew</kbd> so that they use the new enum-based key.</p>&#13;
<p>Let's take a look at how and why this works. We created <kbd>Role</kbd> as a <kbd>String</kbd>-based enum:</p>&#13;
<pre>enum Role: String { <br/>    //... <br/>} </pre>&#13;
<p>Defining it in this way has two benefits:</p>&#13;
<ul>&#13;
<li>We intend to display these roles to the user, so we will need a string representation of the <kbd>Role</kbd> enum, regardless of how we defined it.</li>&#13;
<li>Enums have a little bit of protocol and generics magic in them, which means that if an enum is backed by a type that implements the <kbd>Hashable</kbd> protocol (as <kbd>String</kbd> does), the enum also automatically implements the <kbd>Hashable</kbd> protocol. Therefore, defining <kbd>Role</kbd> as being String-based satisfies the dictionary requirement of a key being <kbd>Hashable</kbd> without us having to do any extra work.</li>&#13;
</ul>&#13;
<p>With our <kbd>crew</kbd> dictionary now defined as having a Role-based key, all subscript operations have to use a value in the role enum:</p>&#13;
<pre>crew[.captain] = Person(givenName: "Jean-Luc", <br/>                        familyName: "Picard", <br/>                        commsMethod: .phone) <br/>let cmo = crew[.chiefMedicalOfficer] </pre>&#13;
<p>The compiler enforces this, so it's no longer possible to use an incorrect role when interacting with our employee directory. This pattern of using Swift's constructs and type system to enforce the correct use of your code is something we should strive to do, as it can reduce bugs and prevent our code from being used in unexpected ways.</p>&#13;
<h2 id="uuid-478740fc-1ee9-4e7f-ba84-6894da92f0d8">See also</h2>&#13;
<p>Further information about dictionaries can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/collections">http://swiftbook.link/docs/collections</a>.</p>&#13;
<h1 id="uuid-fd932a35-ae9d-47a9-8255-4e88ff57a5fe">Subscripts for custom types</h1>&#13;
<p>By using collection types, we have seen that their elements are accessed through subscripts. However, it's not just collection types that can have subscripts; your own custom types can provide subscript functionality too.</p>&#13;
<h2 id="uuid-89903ecb-6f42-4ea9-be92-69e39a30bda3">Getting ready</h2>&#13;
<p>In this recipe, we will create a simple game of <em>tic-tac-toe</em>, also known as <em>Noughts and Crosses</em>. To do this, we need a three-by-three grid of positions, with each position being filled by either a nought from Player 1, a cross from Player 2, or nothing. We can store these positions in an array of arrays.</p>&#13;
<p>The initial game setup code uses the concepts we've already covered in this book, so we won't go into its implementation. Enter the following code into a new playground so that we can see how subscripts can improve its usage:</p>&#13;
<pre>enum GridPosition: String { <br/>    case player1 = "o" <br/>    case player2 = "x" <br/>    case empty = " " <br/>} <br/> <br/>struct TicTacToe { <br/>     <br/>    var gridStorage: [[GridPosition]] = [] <br/>     <br/>    init() { <br/>        gridStorage.append(Array(repeating: .empty, count: 3)) <br/>        gridStorage.append(Array(repeating: .empty, count: 3)) <br/>        gridStorage.append(Array(repeating: .empty, count: 3)) <br/>    } <br/>     <br/>    func gameStateString() -&gt; String { <br/>        var stateString = "-------------\n" <br/>        stateString += printableString(forRow: gridStorage[0]) <br/>        stateString += "-------------\n" <br/>        stateString += printableString(forRow: gridStorage[1]) <br/>        stateString += "-------------\n" <br/>        stateString += printableString(forRow: gridStorage[2]) <br/>        stateString += "-------------\n" <br/>         <br/>        return stateString <br/>    } <br/>     <br/>    func printableString(forRow row: [GridPosition]) -&gt; String { <br/>        var rowString = "| \(row[0].rawValue) " <br/>        rowString += "| \(row[1].rawValue) " <br/>        rowString += "| \(row[2].rawValue) |\n" <br/>        return rowString <br/>    } <br/>} </pre>&#13;
<h2 id="uuid-68b51014-a6aa-430d-b490-25df9234fc90">How to do it...</h2>&#13;
<p>Let's run through how we can use the tic-tac-toe game defined previously, as well as how we can improve how it is used, using a subscript. We will also examine how this works:</p>&#13;
<ol>&#13;
<li>Let's create an instance of our <kbd>TicTacToe</kbd> grid:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var game = TicTacToe()</pre>&#13;
<ol start="2">&#13;
<li>For a player to make a move, we need to change the <kbd>GridPosition</kbd> value that's been assigned to the relevant place in the array of arrays. This is used to store the grid positions. Player 1 will place a nought in the middle position of the grid, which would be row position 1, column position 1 (since it's a zero-based array):</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// Move 1 <br/>game.gridStorage[1][1] = .player1 <br/>print(game.gameStateString()) <br/>/* <br/>------------- <br/>|   |   |   | <br/>------------- <br/>|   | o |   | <br/>------------- <br/>|   |   |   | <br/>------------- <br/>*/</pre>&#13;
<ol start="3">&#13;
<li>Next, Player 2 places their cross in the top-right position, which is row position 0, column position 2:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// Move 2 <br/>game.gridStorage[0][2] = .player2 <br/>print(game.gameStateString()) <br/>/* <br/>------------- <br/>|   |   | x | <br/>------------- <br/>|   | o |   | <br/>------------- <br/>|   |   |   | <br/>------------- <br/>*/  </pre>&#13;
<p style="padding-left: 60px">We can make moves in our game. We can do this by adding information directly to the <kbd>gridStorage</kbd> array, which isn't ideal. The player shouldn't need to know how the moves are stored, and we should be able to change how we store the game information without having to change how the moves are made. To solve this, let's create a subscript of our game struct so that making a move in the game is just like assigning a value to an array.</p>&#13;
<ol start="4">&#13;
<li>Add the following subscript method to the <kbd>TicTacToe</kbd> <span>struct:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct TicTacToe { <br/>    var gridStorage: [[GridPosition]] = [] <br/>    //... <br/>    subscript(row: Int, column: Int) -&gt; GridPosition { <br/>        get { <br/>            return gridStorage[row][column] <br/>        } <br/>        set(newValue) { <br/>            gridStorage[row][column] = newValue <br/>        } <br/>    } <br/>    //... <br/>} </pre>&#13;
<ol start="5">&#13;
<li>So, now, we can change how each player makes their move and finish the game:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// Move 1 <br/>game[1, 1] = .player1 <br/>print(game.gameStateString()) <br/>/*  <br/> ------------- <br/> |   |   |   | <br/> ------------- <br/> |   | o |   | <br/> ------------- <br/> |   |   |   | <br/> ------------- <br/> */  <br/> <br/>// Move 2 <br/>game[0, 2] = .player2 <br/>print(game.gameStateString()) <br/>/*  <br/> ------------- <br/> |   |   | x | <br/> ------------- <br/> |   | o |   | <br/> ------------- <br/> |   |   |   | <br/> ------------- <br/> */  <br/> <br/>// Move 3 <br/>game[0, 0] = .player1 <br/>print(game.gameStateString()) <br/>/*  <br/> ------------- <br/> | o |   | x | <br/> ------------- <br/> |   | o |   | <br/> ------------- <br/> |   |   |   | <br/> ------------- <br/> */  <br/> <br/>// Move 4 <br/>game[1, 2] = .player2 <br/>print(game.gameStateString()) <br/>/*  <br/> ------------- <br/> | o |   | x | <br/> ------------- <br/> |   | o | x | <br/> ------------- <br/> |   |   |   | <br/> ------------- <br/> */  <br/> <br/>// Move 5 <br/>game[2, 2] = .player1 <br/>print(game.gameStateString()) <br/>/*  <br/> ------------- <br/> | o |   | x | <br/> ------------- <br/> |   | o | x | <br/> ------------- <br/> |   |   | o | <br/> ------------- <br/> */  </pre>&#13;
<ol start="6">&#13;
<li>Just like when using an array, we can use a subscript to access the value, as well as assign a value to it:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let topLeft = game[0, 0] <br/>let middle = game[1, 1] <br/>let bottomRight = game[2, 2] <br/>let p1HasWon = (topLeft == .player1)<br/>                &amp;&amp; (middle == .player1)<br/>                &amp;&amp; (bottomRight == .player1) </pre>&#13;
<h2 id="uuid-bd2bde15-e206-4f0e-9ed8-561d1d45eced">How it works...</h2>&#13;
<p>Subscript functionality can be defined within a class, struct, or enum, or declared within a protocol as a requirement. To do this, we can define <kbd>subscript</kbd> (which is a reserved keyword that activates the required functionality) with input parameters and an output type:</p>&#13;
<pre>subscript(row: Int, column: Int) -&gt; GridPosition</pre>&#13;
<p>This subscript definition works like a computed property, where <kbd>get</kbd> can be defined to allow you to access values through <kbd>subscript</kbd> and <kbd>set</kbd> can be defined to assign values using <kbd>subscript</kbd>:</p>&#13;
<pre>subscript(row: Int, column: Int) -&gt; GridPosition {<br/>    get {<br/>        return gridStorage[row][column]<br/>    }<br/>    set(newValue) {<br/>        gridStorage[row][column] = newValue<br/>    }<br/>}</pre>&#13;
<p>Any number of input parameters can be defined, and these should be provided as comma-separated values in the subscript:</p>&#13;
<pre>game[1, 2] = .player2 // Assigning a value<br/>let topLeft = game[0, 0] // Accessing a value</pre>&#13;
<h2 id="uuid-fc529b58-1f09-4989-8b45-f6c869264d3c">There's more...</h2>&#13;
<p>Just like parameters defined in a function, <kbd>subscript</kbd> parameters can have additional labels. If defined, these become required at the call site, so the <kbd>subscript</kbd> we added can alternatively be defined as follows:</p>&#13;
<pre>subscript(atRow row: Int, atColumn column: Int) -&gt; GridPosition </pre>&#13;
<p>In this case, when using the <kbd>subscript</kbd>, we would also provide the labels in the <kbd>subscript</kbd>:</p>&#13;
<pre>game[atRow: 1, atColumn: 2] = .player2 // Assigning a value <br/>let topLeft = game[atRow: 0, atColumn: 0] // Accessing a value</pre>&#13;
<h2 id="uuid-ae481c0b-4e8d-4ca7-a376-953196baedcd">See also</h2>&#13;
<p>Further information about subscripts can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/subscripts">http://swiftbook.link/docs/subscripts</a>.</p>&#13;
<h1 id="uuid-1b3c7636-29ae-4daf-a041-0b4ac14fe8c3">Changing your name with typealias</h1>&#13;
<p>The <kbd>typealias</kbd> declaration allows you to create an alias for a type (and is therefore pretty accurately named!). You can specify a name that can be used in place of any given type of definition. If this type is quite complex, a typeAlias can be a useful way to simplify its use.</p>&#13;
<h2 id="uuid-407e5d57-9ab1-45e4-88eb-573f88c3f79e">How to do it...</h2>&#13;
<p>We will use a typealias to replace an array definition:</p>&#13;
<ol>&#13;
<li>First, let's create something we can store in an array. In this instance, let's create a <kbd>Pug</kbd> struct:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct Pug { <br/>    let name: String <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Now, we can create an array that will contain instances of a <kbd>Pug</kbd> struct:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let pugs = [Pug]() </pre>&#13;
<div class="packt_infobox">As you may or may not know, the collective noun for a group of pugs is called a <strong>grumble</strong>.</div>&#13;
<ol start="3">&#13;
<li>We can set up a <kbd>typealias</kbd> to define an array of pugs as a <kbd>Grumble</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">typealias Grumble = [Pug] </pre>&#13;
<ol start="4">&#13;
<li>With this defined, we can substitute <kbd>Grumble</kbd> wherever we would use <kbd>[Pug]</kbd> or <kbd>Array&lt;Pug&gt;</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var grumble = Grumble()</pre>&#13;
<ol start="5">&#13;
<li>However, this isn't some new type <span>â€“</span> it is just an array with all the same functionalities:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let marty = Pug(name: "Marty McPug") <br/>let wolfie = Pug(name: "Wolfgang Pug") <br/>let buddy = Pug(name: "Buddy") <br/>grumble.append(marty) <br/>grumble.append(wolfie) <br/>grumble.append(buddy)</pre>&#13;
<h2 id="uuid-1509a562-f2cf-4c5f-8b71-2089ab2eb331">There's more...</h2>&#13;
<p>The preceding example allows us to use types in a more natural and expressive way. In addition, we can use a <kbd>typealias</kbd> to simplify a more complex type that may be used in multiple places.</p>&#13;
<p>To see how this might be useful, we can partially build an object to fetch program information:</p>&#13;
<pre>enum Channel { <br/>    case BBC1 <br/>    case BBC2 <br/>    case BBCNews <br/>    //... <br/>} <br/> <br/>class ProgrammeFetcher { <br/>     <br/>    func fetchCurrentProgrammeName(forChannel channel: Channel, <br/>       resultHandler: (String?, Error?) -&gt; Void) { <br/>        // ...  <br/>        // Do the work to get the current programme <br/>        // ... <br/>        let exampleProgramName = "Sherlock" <br/>        resultHandler(exampleProgramName, nil) <br/>    } <br/>     <br/>    func fetchNextProgrammeName(forChannel channel: Channel, <br/>       resultHandler: (String?, Error?) -&gt; Void) { <br/>        // ...  <br/>        // Do the work to get the next programme <br/>        // ... <br/>        let exampleProgramName = "Luther" <br/>        resultHandler(exampleProgramName, nil) <br/>    } <br/>} <br/> </pre>&#13;
<p>In the <kbd>ProgrammeFetcher</kbd> object, we have two methods that take a channel and a result handler closure. The result handler closure has the following definition. We have to define this twice; once for each method:</p>&#13;
<pre>(String?, Error?) -&gt; Void </pre>&#13;
<p>Instead, we can define this closure definition with a <kbd>typealias</kbd> called <kbd>FetchResultHandler</kbd> and replace each method definition with a reference to this <kbd>typealias</kbd>:</p>&#13;
<pre>class ProgrammeFetcher { <br/>     <br/>    <strong>typealias FetchResultHandler = (String?, Error?) -&gt; Void</strong> <br/>     <br/>    func fetchCurrentProgrammeName(forChannel channel: Channel, <br/>                                   resultHandler: <strong>FetchResultHandler</strong>) { <br/>        // Get next programme <br/>        let programmeName = "Sherlock" <br/>        resultHandler(programmeName, nil) <br/>    } <br/>     <br/>    func fetchNextProgrammeName(forChannel channel: Channel, <br/>                                resultHandler: <strong>FetchResultHandler</strong>) { <br/>        // Get next programme <br/>        let programmeName = "Luther" <br/>        resultHandler(programmeName, nil) <br/>    } <br/>} <br/> </pre>&#13;
<p>Not only does this save us from defining the closure type twice, but it is also a better description of the function that the closure performs.</p>&#13;
<p>Using <kbd>typealias</kbd> doesn't affect how we provide closure to the method:</p>&#13;
<pre>let fetcher = ProgrammeFetcher() <br/>fetcher.fetchCurrentProgrammeName(forChannel: .BBC1, <br/>   resultHandler: { programmeName, error in  <br/>    print(programmeName as Any) <br/>})</pre>&#13;
<h2 id="uuid-37253776-a7b1-4b32-b1d9-647cab553f48">See also</h2>&#13;
<p>Further information about typealias can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/declarations">http://swiftbook.link/docs/declarations</a>.</p>&#13;
<h1 id="uuid-3a94b423-239f-4e56-8962-21157af80579">Getting property changing notifications using property observers</h1>&#13;
<p>It's common to want to know when a property's value changes. Perhaps you want to update the value of another property or update some user interface element. In Objective-C, this was often accomplished by writing your own getter and setter or using <strong>Key-Value Observing</strong> (<strong>KVO</strong>), but in Swift, we have native support for property observers.</p>&#13;
<h2 id="uuid-c2a4e5d6-b658-4edd-949f-ef87f24f6bbc">Getting ready</h2>&#13;
<p>To examine property observers, we should create an object with a property that we want to observe. Let's create an object that manages users and a property that holds the current user's name:</p>&#13;
<pre>class UserManager { <br/>    var currentUserName: String = "Emmanuel Goldstein" <br/>} </pre>&#13;
<p>We want to present some friendly messages when the current user changes. We'll use property observers to do this.</p>&#13;
<h2 id="uuid-b638ef10-b40b-4a73-a839-01106187f06e">How to do it...</h2>&#13;
<p>Let's get started:</p>&#13;
<ol>&#13;
<li>Amend the <kbd>currentUserName</kbd> property definition so that it looks as follows:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class UserManager { <br/>    var currentUserName: String = "Emmanuel Goldstein" { <br/>        willSet (newUserName) { <br/>            print("Goodbye to \(currentUserName)") <br/>            print("I hear \(newUserName) is on their way!") <br/>        } <br/>        didSet (oldUserName) { <br/>            print("Welcome to \(currentUserName)") <br/>            print("I miss \(oldUserName) already!") <br/>        } <br/>    } <br/>} </pre>&#13;
<ol start="2">&#13;
<li>Create an instance of <kbd>UserManager</kbd> and change the current username. This will generate friendly messages:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let manager = UserManager() <br/> <br/>manager.currentUserName = "Dade Murphy" <br/>// Goodbye to Emmanuel Goldstein <br/>// I hear Dade Murphy is on their way! <br/>// Welcome to Dade Murphy <br/>// I miss Emmanuel Goldstein already! <br/> <br/>manager.currentUserName = "Kate Libby" <br/>// Goodbye to Dade Murphy <br/>// I hear Kate Libby is on their way! <br/>// Welcome to Kate Libby <br/>// I miss Dade Murphy already! </pre>&#13;
<h2 id="uuid-4324e26f-3d4a-43b5-9553-589d8058175d">How it works...</h2>&#13;
<p>Property observers can be added within curly brackets after the property declaration, and there are two types: <kbd>willSet</kbd> and <kbd>didSet</kbd>.</p>&#13;
<p>The <kbd>willSet</kbd> observer will be called before the property is set and provides the value that will be set on the property. This new value can be given a name within brackets; for example, <kbd>newUserName</kbd>:</p>&#13;
<pre>willSet (newUserName) { <br/>    //... <br/>} <br/>  </pre>&#13;
<p>The <kbd>didSet</kbd> observer will be called after the property is set and provides the value that the property had before being set. This old value can be given a name within brackets; for example, <kbd>oldUserName</kbd>:</p>&#13;
<pre>didSet (oldUserName) { <br/>    //... <br/>}</pre>&#13;
<h2 id="uuid-23ea1c7f-3225-41dd-b27e-30973930c3b2">There's more...</h2>&#13;
<p>The new value and old value that are passed into the property observers have implicit names, so there is no need to explicitly name them. The <kbd>willSet</kbd> observer is passed a value with an implicit name of <kbd>newValue</kbd>, and the <kbd>didSet</kbd> observer is passed a value with an implicit name of <kbd>oldValue</kbd>.</p>&#13;
<p>Therefore, we can remove our explicit names and use the implicit value names:</p>&#13;
<pre>class UserManager { <br/>    var currentUserName: String = "Emmanuel Goldstein" { <br/>        willSet { <br/>            print("Goodbye to \(currentUserName)") <br/>            print("I hear \(newValue) is on their way!") <br/>        } <br/>        didSet { <br/>            print("Welcome to \(currentUserName)") <br/>            print("I miss \(oldValue) already!") <br/>        } <br/>    } <br/>} </pre>&#13;
<h2 id="uuid-f90ed21d-fc07-4e52-8888-a5b656ed569c">See also</h2>&#13;
<p>Further information about property observers can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/properties">http://swiftbook.link/docs/properties</a>.</p>&#13;
<h1 id="uuid-5373dd9c-7adc-49ad-aa82-b46de79843e9">Extending functionality with extensions</h1>&#13;
<p>Extensions let us add functionality to our existing classes, structs, enums, and protocols. This can be especially useful when the original type is provided by an external framework, which means you aren't able to add functionality directly.</p>&#13;
<h2 id="uuid-2b2646a3-e0cd-43ca-8e73-ffb9f8046da4">Getting ready</h2>&#13;
<p>Imagine that we often need to obtain the first word from a given string. Rather than repeatedly writing the code to split the string into words and then retrieving the first word, we can extend the functionality of<span> </span><kbd>String</kbd><span> </span>to provide its own first word.</p>&#13;
<h2 id="uuid-e2406158-21c5-4d83-aa42-5f85d1d1ed39">How to do it...</h2>&#13;
<p>Let's get started:</p>&#13;
<ol>&#13;
<li>Create an extension of<span> </span><kbd>String</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension String { <br/> <br/>} </pre>&#13;
<ol start="2">&#13;
<li>Within the extension's curly brackets, add a function that returns the first word from the string:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension String {<br/>    func firstWord() -&gt; String {<br/>        let spaceIndex = firstIndex(of: " ") ?? endIndex<br/>        let word = prefix(upTo: spaceIndex)<br/>        return String(word)<br/>    }<br/>}</pre>&#13;
<ol start="3">&#13;
<li>Now, we can use this new method on<span> </span><kbd>String</kbd><span> </span>to get the first word from a phrase:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let llap = "Live long, and prosper" <br/>let firstWord = llap.firstWord() <br/>print(firstWord) // Live </pre>&#13;
<h2 id="uuid-63c5c903-77ff-4e9d-bf0d-f2823a9f6f00">How it works...</h2>&#13;
<p>We can define an extension using the <kbd>extension</kbd> keyword and then specify the type we want to extend. The implementation of this extension is defined within curly brackets:</p>&#13;
<pre>extension String { <br/>    //... <br/>} </pre>&#13;
<p>Methods and computed properties can be defined in extensions in the same way that they can be defined within classes, structs, and enums. Here, we will add a<span> </span><kbd>firstWord</kbd><span> </span>function to the<span> </span><kbd>String</kbd><span> </span>struct:</p>&#13;
<pre>extension String {<br/>    func firstWord() -&gt; String {<br/>        let spaceIndex = firstIndex(of: " ") ?? endIndex<br/>        let word = prefix(upTo: spaceIndex)<br/>        return String(word)<br/>    }<br/>}</pre>&#13;
<p>The implementation of the<span> </span><kbd>firstWord</kbd><span> </span>method is not important for this recipe, so we'll just touch on it briefly.</p>&#13;
<p>In Swift,<span> </span><kbd>String</kbd><span> </span>is a collection, so we can use the collection methods to find the first index of an empty space. However, this could be <kbd>nil</kbd> since the string may contain only one word or no characters at all, so if the index is <kbd>nil</kbd>, we must use the<span> </span><kbd>endIndex</kbd><span> </span>instead. T<span>he nil coalescing operator (<kbd>??</kbd>) is only used to assign <kbd>endIndex</kbd> if <kbd>firstIndex(of: " ")</kbd> is <kbd>nil</kbd></span>. More generally, it will evaluate the value on the left-hand side of the operator, unless it is<span> </span><kbd>nil</kbd>, in which case it will assign the value on the right-hand side.</p>&#13;
<p>Then, we use the index of the first space to retrieve the substring up to the index, which has a <kbd>SubString</kbd> type. We then use that to create and return a<span> </span><kbd>String</kbd>.</p>&#13;
<p>Extensions can implement anything that uses the existing functionality, but they can't store information in a new property. Therefore, computed properties can be added, but stored properties cannot. Let's change our<span> </span><kbd>firstWord</kbd><span> </span>method so that it's a computed property instead:</p>&#13;
<pre>extension String {<br/>   var firstWord: String {<br/>       let spaceIndex = firstIndex(of: " ") ?? endIndex<br/>       let word = prefix(upTo: spaceIndex)<br/>       return String(word)<br/>   }<br/>} </pre>&#13;
<h2 id="uuid-bd003327-16d8-4a8a-b28f-2d59876c77f2">There's more...</h2>&#13;
<p>Extensions can also be used to add protocol conformance, so let's create a protocol that we want to add conformance to:</p>&#13;
<ol>&#13;
<li>The protocol declares that something can be represented as an<span> </span><kbd>Int</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">protocol IntRepresentable { <br/>    var intValue: Int { get } <br/>}</pre>&#13;
<ol start="2">&#13;
<li>We can extend<span> </span><kbd>Int</kbd><span> </span>and have it conform to<span> </span><kbd>IntRepresentable</kbd><span> </span>by returning itself:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension Int: IntRepresentable { <br/>    var intValue: Int { <br/>        return self <br/>    } <br/>} </pre>&#13;
<ol start="3">&#13;
<li>Next, we'll extend<span> </span><kbd>String</kbd>, and we'll use an<span> </span><kbd>Int</kbd><span> </span>constructor that takes a<span> </span><kbd>String</kbd><span> </span>and returns an<span> </span><kbd>Int</kbd><span> </span>if our <kbd>String</kbd><span> </span>contains digits that represent an integer:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension String: IntRepresentable { <br/>    var intValue: Int { <br/>        return Int(self) ?? 0 <br/>    } <br/>} </pre>&#13;
<ol start="4">&#13;
<li>We can also extend our own custom types and add conformance to the same protocol, so let's create an<span> </span><kbd>enum</kbd><span> </span>that can be<span> </span><kbd>IntRepresentable</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum CrewComplement: Int { <br/>    case enterpriseD = 1014  <br/>    case voyager = 150  <br/>    case deepSpaceNine = 2000  <br/>} </pre>&#13;
<ol start="5">&#13;
<li>Since our enum is Int-based, we can conform to <kbd>IntRepresentable</kbd> by providing a <kbd>rawValue</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension CrewComplement: IntRepresentable { <br/>    var intValue: Int { <br/>        return rawValue <br/>    } <br/>} </pre>&#13;
<ol start="6">&#13;
<li>We now have<span> </span><kbd>String</kbd>,<span> </span><kbd>Int</kbd>, and<span> </span><kbd>CrewComplement</kbd><span> </span>all conforming to<span> </span><kbd>IntRepresentable</kbd>, and since we didn't define<span> </span><kbd>String</kbd><span> </span>or<span> </span><kbd>Int</kbd>, we have only been able to add conformance through the use of extensions. This common conformance allows us to treat them as the same type:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var intableThings = [IntRepresentable]() <br/>intableThings.append(55) <br/>intableThings.append(1200) <br/>intableThings.append("5") <br/>intableThings.append("1009") <br/>intableThings.append(CrewComplement.enterpriseD) <br/>intableThings.append(CrewComplement.voyager) <br/>intableThings.append(CrewComplement.deepSpaceNine) <br/> <br/>let over1000 = intableThings.compactMap { $0.intValue &gt; 1000 ? <br/>  $0.intValue: nil } <br/>print(over1000) </pre>&#13;
<p>The preceding example includes the use of<span> </span><kbd>compactMap</kbd><span> </span>and the ternary operator, which haven't been covered in this book. Further information can be found in the<span> </span><em>See also</em><span> </span>section.</p>&#13;
<h2 id="uuid-cf63400a-d9e2-4d99-9eb8-94e59b878d6a">See also</h2>&#13;
<p>Further information about extensions can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/extensions">http://swiftbook.link/docs/extensions</a>.</p>&#13;
<p>The documentation for<span> </span><kbd>compactMap</kbd><span> can be found at </span><a href="https://developer.apple.com/documentation/swift/sequence/2950916-compactmap">https://developer.apple.com/documentation/swift/sequence/2950916-compactmap</a>.</p>&#13;
<p>Further information about the ternary operator can be found at <a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71">https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71</a>.</p>&#13;
<h1 id="uuid-ce3599bf-b2ec-4d3e-9788-3b3a1a2738ff">Controlling access with access control</h1>&#13;
<p>Swift provides fine-grained access control, allowing you to specify the visibility that your code has to other areas of code. This enables you to be deliberate about the interface you provide to other parts of the system, thus encapsulating implementation logic and helping separate the areas of concern.</p>&#13;
<p>Swift has five access levels:</p>&#13;
<ul>&#13;
<li><strong>Private</strong>: Only accessible within the existing scope (defined by curly brackets) or extensions in the same file.</li>&#13;
<li><strong>File private</strong>: Accessible to anything in the same file, but nothing outside the file.</li>&#13;
<li><strong>Internal</strong>: Accessible to anything in the same module, but nothing outside the module.</li>&#13;
<li><strong>Public</strong>: Accessible both inside and outside the module, but cannot be subclassed or overwritten outside of the defining module.</li>&#13;
<li><strong>Open</strong>: Accessible everywhere, with no restrictions in terms of its use, and can therefore be subclassed and overwritten.</li>&#13;
</ul>&#13;
<p>These can be applied to types, properties, and functions.</p>&#13;
<h2 id="uuid-9018508d-37a3-4371-8dcf-b47d0f939716">Getting ready</h2>&#13;
<p>To explore each of these access levels, we need to step outside our playground comfort zone and create a module. To have something that will hold our module and a playground that can use it, we will need to create an Xcode workspace:</p>&#13;
<ol>&#13;
<li>In Xcode, select <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Workspace...</span> from the menu:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/382a9997-8a62-4b03-82d8-ee46ffc86cb5.png" style="" width="1081" height="476"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.9 â€“ Xcode â€“ New project</span></div>&#13;
<ol start="2">&#13;
<li>Give your workspace a name, such as <kbd>AccessControl</kbd>, and choose a save location. You will now see an empty workspace:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/e19c4f3f-0822-4566-a963-c85eb82bf34a.png" style="" width="945" height="442"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.10 â€“ Xcode â€“ New project structure</span></div>&#13;
<p style="padding-left: 60px" class="packt_figure CDPAlignLeft CDPAlign">In this workspace, we need to create a module. To illustrate the access controls that are available, let's have our module represent something that tightly controls which information it exposes, and which information it keeps hidden. One thing that fits this definition is Apple; that is, the company.</p>&#13;
<ol start="3">&#13;
<li>Create a new project from the Xcode menu by selecting <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Project...</span>:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/98ddc071-6982-47f5-b48d-81b953112ed3.png" style="" width="1077" height="474"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.11 â€“ New project</span></div>&#13;
<ol start="4">&#13;
<li>From the template selector, select <span class="packt_screen">Framework</span>:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/7099a811-ebef-4327-a2f3-028dcbeeed78.png" style="" width="1905" height="1163"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.12 â€“ New project framework</span></div>&#13;
<ol start="5">&#13;
<li>Name the project <kbd>AppleInc</kbd>:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/6fdc3f65-3799-4641-9595-0a65abfcca43.png" style="" width="1902" height="774"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.13 â€“ Naming the project</span></div>&#13;
<ol start="6">&#13;
<li>Choose a location. Then, at the bottom of the window, ensure that <span class="packt_screen">Add to:</span> has been set to the workspace we just created:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/ead95109-a886-435d-801c-185500b3605f.png" style="" width="892" height="215"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.14 â€“ New project workspace group</span></div>&#13;
<ol start="7">&#13;
<li>Now that we have a module, let's set up a playground to use it in. From the Xcode menu, select <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Playground...</span>:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/a804521f-f114-4011-887b-73fcb4aa093c.png" style="" width="1080" height="477"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.15 â€“ New playground</span></div>&#13;
<ol start="8">&#13;
<li>Give the playground a name and save it to a location:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/f392ab21-7d05-4a4c-9ff1-e4a826bfb62b.png" style="" width="1437" height="1072"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.16 â€“ New project</span></div>&#13;
<ol start="9">&#13;
<li>This playground will not be added to the workspace automatically; you will need to locate the playground you just created and drag it into the file explorer pane on the left-hand side of your workspace.</li>&#13;
<li>Press the run button on the Xcode toolbar to build the <kbd>AppleInc</kbd> <span>module:</span></li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/5aac1934-f7bf-4178-a60b-3b85db9563f9.png" style="" width="502" height="174"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 2.17 â€“ Xcode toolbar</span></div>&#13;
<ol start="11">&#13;
<li>Select the playground from the file navigator and add an import statement to the top of the file:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import AppleInc </pre>&#13;
<p>We are now ready to look into the different access controls that are available.</p>&#13;
<h2 id="uuid-4080a930-6054-469c-923f-6712b9b369f8">How to do it...</h2>&#13;
<p>Let's investigate the most restrictive of the access controls: <kbd>private</kbd>. Structures marked as <kbd>private</kbd> are only visible within the scope of the type they have been defined in, as well as any extensions of that type that are located in the same file. We know that Apple has super-secret areas where it works on its new products, so let's create one:</p>&#13;
<ol>&#13;
<li>Select the <kbd>AppleInc</kbd> group in the file navigator and create a new file by selecting <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">File...</span> from the menu. Let's call it <kbd>SecretProductDepartment</kbd>.</li>&#13;
<li>In this new file, create a <kbd>SecretProductDepartment</kbd> class using the <kbd>private</kbd> access control:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class SecretProductDepartment { <br/> <br/>    private var secretCodeWord = "Titan" <br/>    private var secretProducts = ["Apple Glasses", <br/>                                  "Apple Car", <br/>                                  "Apple Brain Implant"] <br/> <br/>    func nextProduct(codeWord: String) -&gt; String? { <br/>        let codeCorrect = codeWord == secretCodeWord <br/>        return codeCorrect ? secretProducts.first : nil <br/>    } <br/>} </pre>&#13;
<p style="padding-left: 60px"><span>Next, let's look at the</span><span> </span><kbd>fileprivate</kbd><span> </span><span>access control. Structures marked as</span><span> </span><kbd>fileprivate</kbd><span> </span><span>are only visible within the file that they are defined in, so a collection of related structures defined in the same file will be visible to each other, but anything outside the file will not see these structures.</span></p>&#13;
<p style="padding-left: 60px">When you buy an iPhone from the Apple Store, it's not made in-store; it's made in a factory that the public doesn't have access to. So, let's model this using <kbd>fileprivate</kbd>.</p>&#13;
<ol start="3">&#13;
<li>Create a new file called <kbd>AppleStore</kbd>. Then, create structures for <kbd>AppleStore</kbd> and <kbd>Factory</kbd> using the <kbd>fileprivate</kbd> access control:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">public enum DeviceModel {<br/>    case iPhone12<br/>    case iPhone12Mini<br/>    case iPhone12Pro<br/>    case iPhone12ProMax <br/>}<br/> <br/>public class AppleiPhone { <br/> <br/>    public let model: DeviceModel <br/> <br/>    fileprivate init(model: DeviceModel) { <br/>        self.model = model <br/>    } <br/>} <br/> <br/>fileprivate class Factory { <br/>    func makeiPhone(ofModel model: DeviceModel) -&gt; AppleiPhone { <br/>        return AppleiPhone(model: model) <br/>    } <br/>} <br/> <br/>public class AppleStore { <br/> <br/>    private var factory = Factory() <br/> <br/>    public func selliPhone(ofModel model: DeviceModel) <br/>                           -&gt; AppleiPhone { <br/>        return factory.makeiPhone(ofModel: model) <br/>    } <br/>}</pre>&#13;
<p style="padding-left: 60px">To investigate the <kbd>public</kbd> access control, we will be defining something that is visible outside the defining module but cannot be subclassed or overridden. Apple itself is the perfect candidate to model this behavior as certain parts of it are visible to the public. However, it closely guards its image and brand, so <em>subclassing</em> Apple to alter and customize it will not be allowed.</p>&#13;
<ol start="4">&#13;
<li><span>Create a new file called </span><kbd>Apple</kbd><span> and create a class for Apple that uses the <kbd>public</kbd> access control:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">public class Person { <br/> <br/>    public let name: String <br/> <br/>    public init(name: String) { <br/>        self.name = name <br/>    } <br/>} <br/> <br/>public class Apple { <br/> <br/>    public private(set) var ceo: Person <br/>    private var employees = [Person]() <br/>    public let store = AppleStore() <br/>    private let secretDepartment = SecretProductDepartment() <br/> <br/>    public init() { <br/>        ceo = Person(name: "Tim Cook") <br/>        employees.append(ceo) <br/>    } <br/> <br/>    public func newEmployee(person: Person) { <br/>        employees.append(person) <br/>    } <br/> <br/>    func weeklyProductMeeting() { <br/> <br/>        var superSecretProduct = <br/>          secretDepartment.nextProduct(codeWord: "Not sure...<br/>            Abracadabra?") // nil<br/><br/>        // Try again <br/>        superSecretProduct = <br/>          secretDepartment.nextProduct(givenCodeWord: "Titan") <br/>        print(superSecretProduct as Any) // "Apple Glasses" <br/>    } <br/>} </pre>&#13;
<p style="padding-left: 60px">Lastly, we have the <kbd>open</kbd> access control. Structures defined as <kbd>open</kbd> are available outside the module and can be subclassed and overridden without restriction. To explain this last control, we want to model something that exists within Apple's domain but is completely open and free from restrictions. So, for this, we can use the Swift language itself!</p>&#13;
<p style="padding-left: 60px">Swift has been open sourced by Apple, so while they maintain the project, the source code is fully available for others to take, modify, and improve.</p>&#13;
<ol start="5">&#13;
<li>Create a new file called <kbd>SwiftLanguage</kbd> and create a class for the Swift language that uses the <kbd>open</kbd> access control:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">open class SwiftLanguage { <br/> <br/>    open func versionNumber() -&gt; Float { <br/>        return 5.1 <br/>    } <br/> <br/>    open func supportedPlatforms() -&gt; [String] { <br/>        return ["iOS", "macOS", "tvOS", "watchOS", "Linux"] <br/>    } <br/>} </pre>&#13;
<p>We now have a module that uses Swift's access controls to provide interfaces that match our model and provide the appropriate visibility.</p>&#13;
<h2 id="uuid-2bc6cf74-1dc7-433a-99c7-2a25450448df">How it works...</h2>&#13;
<p>Let's examine our <kbd>SecretProductDepartment</kbd> class to see how its visibility matches our model:</p>&#13;
<pre>class SecretProductDepartment { <br/>     <br/>    private var secretCodeWord = "Titan" <br/>    private var secretProducts = ["Apple Glasses", <br/>                                  "Apple Car", <br/>                                  "Apple Brain Implant"]<br/>     <br/>    func nextProduct(codeWord: String) -&gt; String? { <br/>        let codeCorrect = codeWord == secretCodeWord <br/>        return codeCorrect ? secretProducts.first : nil <br/>    } <br/>} </pre>&#13;
<p>The <kbd>SecretProductDepartment</kbd> class is declared without an access control keyword, and when no access control is specified, the default control of <kbd>internal</kbd> is applied. Since we want the secret product department to be visible within Apple, but not from outside Apple, this is the correct access control to use.</p>&#13;
<p>The two properties of the <kbd>secretCodeWord</kbd> and <kbd>secretProducts</kbd> classes are marked as private, thus hiding their values and existence from anything outside the <kbd>SecretProductDepartment</kbd> class. To see this restriction in action, add the following to the same file, but outside the class:</p>&#13;
<pre>let insecureCodeWord = SecretProductDepartment().secretCodeWord <br/> </pre>&#13;
<p>When you try to build the module, you are told that <kbd>secretCodeWord</kbd> can't be accessed due to the <kbd>private</kbd> protection level.</p>&#13;
<p>While these properties are not directly accessible, we can provide an interface that allows the information to be provided in a controlled way. This is what the <kbd>nextProduct</kbd> method provides:</p>&#13;
<pre>func nextProduct(codeWord: String) -&gt; String? { <br/>    let codeCorrect = codeWord == secretCodeWord <br/>    return codeCorrect ? secretProducts.first : nil <br/>} </pre>&#13;
<p>If the correct codeword is passed, it will provide the name of the next product from the secret department, but the details of all other products, and the codeword itself, will be hidden. Since this method doesn't have a specified access control, it is set to the default of <kbd>internal</kbd>.</p>&#13;
<div class="packt_infobox">It's not possible for contents within a structure to have a more permissive access control than the structure itself. For instance, we can't define the <kbd>nextProduct</kbd> method as being <kbd>public</kbd> because this is more permissive than the class it is defined in, which is only <kbd>internal</kbd>.<br/>&#13;
Thinking about it, this is the obvious outcome as you cannot create an instance of an internal class outside of the defining module, so how can you possibly call a method on a class instance that you can't even create?</div>&#13;
<p>Next, let's look at the <kbd>AppleStore.swift</kbd> file we created. The purpose here is to provide people outside of Apple with the ability to purchase an iPhone through the Apple Store, but to restrict the creation of iPhones to just the factories where they are built, and then restrict access to those factories to just the Apple Store:</p>&#13;
<pre>public enum DeviceModel {<br/>    case iPhone12<br/>    case iPhone12Mini<br/>    case iPhone12Pro<br/>    case iPhone12ProMax <br/>}<br/> <br/>public class AppleiPhone { <br/>     <br/>    public let model: DeviceModel <br/>     <br/>    fileprivate init(model: DeviceModel) { <br/>        self.model = model <br/>    } <br/>} <br/> <br/>public class AppleStore { <br/>     <br/>    private var factory = Factory() <br/>     <br/>    public func selliPhone(ofModel model: DeviceModel) <br/>                           -&gt; AppleiPhone { <br/>        return factory.makeiPhone(ofModel: model) <br/>    } <br/>}   <br/> </pre>&#13;
<p>Since we want to be able to sell iPhones outside of the <kbd>AppleInc</kbd> module, the <kbd>DeviceModel</kbd> enum and the <kbd>AppleiPhone</kbd> and <kbd>AppleStore</kbd> classes are all declared as <kbd>public</kbd>. This has the benefit of making them available outside the module but preventing them from being subclassed or modified. Given how Apple protects the look and feel of their phones and stores, this seems correct for this model.</p>&#13;
<p>The Apple Store needs to get their iPhones from somewhere; that is, from the factory:</p>&#13;
<pre>fileprivate class Factory { <br/>     <br/>    func makeiPhone(ofModel model: DeviceModel) -&gt; AppleiPhone { <br/>        return AppleiPhone(model: model) <br/>    } <br/>} </pre>&#13;
<p>By making the <kbd>Factory</kbd> class <kbd>fileprivate</kbd>, it is only visible within this file, which is perfect because we only want the Apple Store to be able to use the factory to create iPhones.</p>&#13;
<p>We have also restricted the iPhone's initialization method so that it can only be accessed from structures in this file:</p>&#13;
<pre>fileprivate init(model: DeviceModel) </pre>&#13;
<p>The resulting iPhone is public, but only structures within this file can create iPhone class objects in the first place. In this case, this is done by the factory.</p>&#13;
<p>Next, let's look at the <kbd>Apple.swift</kbd> file:</p>&#13;
<pre>public class Person { <br/>     <br/>    public let name: String <br/>     <br/>    public init(name: String) { <br/>        self.name = name <br/>    } <br/>} <br/> <br/>public class Apple { <br/>     <br/>    public private(set) var ceo: Person <br/>    private var employees = [Person]() <br/>    public let store = AppleStore() <br/>    private let secretDepartment = SecretProductDepartment() <br/>     <br/>    public init() { <br/>        ceo = Person(name: "Tim Cook") <br/>        employees.append(ceo) <br/>    } <br/>     <br/>    public func newEmployee(person: Person) { <br/>        employees.append(person) <br/>    } <br/>     <br/>    func weeklyProductMeeting() { <br/>         <br/>        var superSecretProduct = <br/>          secretDepartment.nextProduct(givenCodeWord: "Not sure... <br/>            Abracadabra?") // nil <br/>         <br/>        // Try again <br/>        superSecretProduct = <br/>          secretDepartment.nextProduct(givenCodeWord: "Titan") <br/>        print(superSecretProduct) // "Apple Glasses"<br/>    } <br/>} </pre>&#13;
<p>The preceding code made both the <kbd>Person</kbd> and <kbd>Apple</kbd> classes public, along with the <kbd>newEmployee</kbd> method. This allows new employees to join the company. The CEO, however, is defined as both public and private:</p>&#13;
<pre>public private(set) var ceo: Person </pre>&#13;
<p>We can define a separate, more restrictive, access control for setting a property than the one that was set for getting it. This has the effect of making it a read-only property from outside the defining structure. This provides the access we require since we want the CEO to be visible outside of the <kbd>AppleInc</kbd> module, but we want to only be able to change the CEO from within Apple.</p>&#13;
<p>The final access control is <kbd>open</kbd>. We applied this to the <kbd>SwiftLanguage</kbd> class:</p>&#13;
<pre>open class SwiftLanguage { <br/>     <br/>    open func versionNumber() -&gt; Float { <br/>        return 5.0<br/>    } <br/>     <br/>    open func supportedPlatforms() -&gt; [String] { <br/>        return ["iOS", "macOSX", "tvOS", "watchOS", "Linux"] <br/>    } <br/>} </pre>&#13;
<p>By declaring the class and methods as <kbd>open</kbd>, we are allowing them to be subclassed, overridden, and modified by anyone, including those outside the <kbd>AppleInc</kbd> module. With the Swift language being fully open source, this matches what we are trying to achieve.</p>&#13;
<h2 id="uuid-e57540b9-4b0a-4406-be9d-29317e88d88f">There's more...</h2>&#13;
<p>With our module fully defined, let's see how things look from outside the module. We need to build the module to make it available to the playground. Select the playground; it should contain a statement that imports the <kbd>AppleInc</kbd> module:</p>&#13;
<pre>import AppleInc </pre>&#13;
<p>First, let's look at the most accessible class that we created; that is, <kbd>SwiftLanguage</kbd>. Let's subclass the <kbd>SwiftLanguage</kbd> class and override its behavior:</p>&#13;
<pre>class WinSwift: SwiftLanguage { <br/>     <br/>    override func versionNumber() -&gt; Float { <br/>        return 5.3 <br/>    } <br/>     <br/>    override func supportedPlatforms() -&gt; [String] { <br/>         <br/>        var supported = super.supportedPlatforms() <br/>        supported.append("Windows") <br/>         <br/>        return supported <br/>    } <br/>} </pre>&#13;
<p>Since <kbd>SwiftLanguage</kbd> is <kbd>open</kbd>, we can subclass it to add more supported platforms and increase its version number.</p>&#13;
<p>Next, let's create an instance of the <kbd>Apple</kbd> class and see how we can interact with it:</p>&#13;
<pre>let apple = Apple() <br/> <br/>let keith = Person(name: "Keith Moon") <br/>apple.newEmployee(person: keith) <br/> <br/>print("Current CEO: \(apple.ceo.name)") <br/>let craig = Person(name: "Craig Federighi") <br/>apple.ceo = <span><span>craig</span></span> // Doesn't compile </pre>&#13;
<p>We can create <kbd>Person</kbd> and provide it to Apple as a new employee since the <kbd>Person</kbd> class and the <kbd>newEmployee</kbd> method are declared as public. We can retrieve information about the CEO, but we aren't able to set a new CEO as we defined the property as <kbd>private (set)</kbd>.</p>&#13;
<p>Another one of the public interfaces <kbd>selliPhone</kbd> provided by the module allows us to buy an iPhone from the Apple Store:</p>&#13;
<pre>// Buy new iPhone  <br/>let boughtiPhone = apple.store.selliPhone(ofModel: .iPhone12Pro) <br/>// This works <br/> <br/>// Try and create your own iPhone <br/>let buildAniPhone = AppleiPhone(model: .iPhone12Pro) <br/>// Doesn't compile <br/> </pre>&#13;
<p>We can retrieve a new iPhone from the Apple Store because we declared the <kbd>selliPhone</kbd> method as <kbd>public</kbd>. However, we can't create a new iPhone directly since the iPhone's <kbd>init</kbd> method is declared as <kbd>fileprivate</kbd>.</p>&#13;
<h2 id="uuid-8fab235a-e559-4d07-a36c-d7c9dc99827b">See also</h2>&#13;
<p>Further information about access control can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/access-control">http://swiftbook.link/docs/access-control</a>.</p>&#13;
&#13;
&#13;
            </article>&#13;
&#13;
            &#13;
        </section>&#13;
    </div></body></html>