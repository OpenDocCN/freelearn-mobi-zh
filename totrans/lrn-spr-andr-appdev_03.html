<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Overview of Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring is a powerful, lightweight application framework that provides support for various frameworks, such as Hibernate, Struts, and JSF<span>. Spring Framework is one of the top enterprise frameworks for building the most complex, secure and robust products. This framework is very popular for Java developers, as most developers working in Java Enterprise are working with Spring. Nowadays, Spring supports the Kotlin language, so it's becoming more popular with other language users. In this book, we'll develop Spring projects in Kotlin.</span></p>
<p><span>In this chapter, we'll learn about the basics of Spring Framework. We'll discuss the basics of Spring and also see some examples of how to implement them with Spring MVC and SpringBoot.</span></p>
<p>This chapter covers the following topics:</p>
<ul>
<li style="font-weight: 400">Introduction to Spring</li>
<li style="font-weight: 400">The advantages of Spring</li>
<li style="font-weight: 400">Spring architecture</li>
<li style="font-weight: 400">Configuring beans</li>
<li style="font-weight: 400">Spring MVC</li>
<li style="font-weight: 400">SpringBoot</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>In <a href="bfdcd6b3-5a5a-4fc7-af79-67e780f46ccb.xhtml">Chapter 1</a>, <em>About the Environment,</em> we demonstrated how to set up the environment and what tools, software, and IDE are needed in order to develop Spring. To begin, visit<span> </span><a href="https://start.spring.io/">https://start.spring.io/</a><span> </span>and create your very first project. The following options will be available there:</p>
<ul>
<li style="font-weight: 400">A Maven project or a Gradle project (we've chosen Maven)</li>
<li style="font-weight: 400"><strong>Language</strong>: Java or Kotlin (we've chosen Kotlin)</li>
<li style="font-weight: 400"><strong>Spring Boot version</strong>: 2.1.1 (SNAPSHOT)</li>
</ul>
<p><span>Once you click on <span class="packt_screen">Create</span></span>, you need to <span>give information, such as </span><strong>Group</strong>, <strong>Artifact</strong>, <strong>Name</strong>, <strong>Description</strong>, <strong>Package Name</strong>, <strong>Packaging</strong>, and <strong>Java Version</strong>. </p>
<p>For this stage, there's no need to add any dependencies. Lastly, generate the project and import this into your IDE.</p>
<p>The source code with an example for this chapter is available on GitHub: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Spring</h1>
                </header>
            
            <article>
                
<p>Spring Framework is an open source framework. This is written in Java and developed by Pivotal software. Any Java-based enterprise applications can use the core of this framework. Spring Framework uses the <strong>Plain Old Java Object</strong> (<strong>POJO</strong>), which makes it easier to build an enterprise application.</p>
<div class="packt_infobox">A POJO is a Java object that isn't bound by any restriction other than those forced by the Java language specification. POJOs are used to increase the readability and reusability of an application.</div>
<p>Let's learn the advantages of Spring and architectures in the following sections.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The advantages of Spring</h1>
                </header>
            
            <article>
                
<p>Spring Framework is a component-rich framework with the following advantages:</p>
<ul>
<li style="font-weight: 400">Spring can be utilized for independent applications, web applications, and mobile applications.</li>
<li style="font-weight: 400">Spring has given an answer for free coupling through the creation of <strong>dependency injection </strong>(<strong>DI</strong>). This gives a configuration file (or annotation) to rearrange the conditions.</li>
<li style="font-weight: 400">It utilizes <strong>aspect-oriented programming</strong> (<strong>AOP</strong>) and makes it possible to isolate cross-cutting concerns, such as logging, reserving, and security. </li>
<li style="font-weight: 400">It limits boilerplate code. Spring has a huge amount of bundles and classes that decrease coding and keep away from the boilerplate code.</li>
<li style="font-weight: 400">It bolsters different frameworks, such as <em>ORM</em><span>,</span> <em>Hibernate</em><span>,</span> <em>Logging</em><span>, and </span><em>JEE</em><span>. </span></li>
<li style="font-weight: 400">Spring provides a simple and secure approach to dealing with login frameworks, forms, and so on.</li>
<li style="font-weight: 400">It handles <em>autowiring</em><span>, which can be a nightmare when building a complex web application.</span></li>
<li style="font-weight: 400">Spring Web Framework has a web <em>MVC framework</em>, <span>which gives leverage, rather than a legacy web framework.</span></li>
<li style="font-weight: 400">It has the ability to take out the creation of singleton and factory classes.</li>
<li style="font-weight: 400">Spring Framework incorporates support for overseeing business objects and presenting their administrations to the introduction-level segments with the aim.</li>
<li style="font-weight: 400">It underpins both <em>XML</em> <span>and</span> <em>annotation</em> <span>arrangements.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Architecture</h1>
                </header>
            
            <article>
                
<p>Spring Framework is a layered architecture that's composed of a few modules. All modules are based on the highest point of its core container. These modules give a developer everything they may require for use in the enterprise application development. In any case, developers allowed to pick the highlights they need and dispose of the modules that are of no use. </p>
<div class="mce-root packt_infobox"><strong>Modular programming</strong> is a software design technique. This separates the functionality of a program into independent modules so that each contains one specific functionality.</div>
<p>Here's a diagram of the Spring architecture:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c8913af-0b5c-4ccf-80d0-d9d3e457296c.png"/></p>
<p class="mce-root">Spring Framework has about 20 modules, which are grouped into <strong>Core Containers</strong>, <strong>Data Access/Integration</strong>, <strong>Web</strong>, <strong>AOP</strong>, <strong>Instrumentation</strong>, and <strong>Test.</strong></p>
<p>Let's learn about the components of Spring architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core containers</h1>
                </header>
            
            <article>
                
<p class="mce-root">This section consists of <strong>Core</strong>, <strong>Beans</strong>, <strong>Context</strong>, and <strong>Expression Language</strong> modules.</p>
<p class="mce-root"><span>The <strong>Core</strong> module is the center of the Spring architecture. This provides the implementation for features such as <strong>Inversion of Control</strong> (<strong>IoC</strong>) and  <strong>Dependency Injection</strong> (<strong>DI</strong>). IoC is o</span>ne of the center containers of the Spring core. <span>DI is another known name of</span> IoC. This container is responsible for creating forms of objects and controls the complete life cycle. During this life cycle, the system creates a dependency and the container injects those dependencies while it creates the bean. This inverse process of DI is basically called IoC.</p>
<p class="mce-root"><kbd>org.springframework.beans</kbd> and <kbd>org.springframework.context</kbd> are the two containers of Spring Framework's IoC. IoC has a root interface, called <kbd>BeanFactory</kbd>, which is executed by the items and holds various bean definitions, each bean being recognized by a String name. A propelled configuration component is given by this interface to deal with items. <kbd>ApplicationContext</kbd> is a sub-interface of <kbd>BeanFactory</kbd>, which includes more application-layer settings. For example, it includes <kbd>WebApplicationContext</kbd> for use in web applications. <kbd>ApplicationContext</kbd> is in charge of instantiating, designing, and collecting the beans.</p>
<p>The tasks of <span>object instantiation, configuration, and object assembling are specified for the container in the configuration metadata.</span> There are three ways to configure the metadata: through XML, annotation, or code. This occurs in spite of the way that we work with Kotlin, so we'll write code and metadata in the Kotlin language.</p>
<p>Here's a simple diagram of the flow of the <strong>Core</strong> container:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/660caf35-f1b3-4ca7-8571-aba84e886953.png" style="width:28.42em;height:21.17em;"/></p>
<p>The core container is the process of getting the Spring project ready to see the output. With the help of <strong>Java POJO Classes</strong>, which are mainly the business objects and the <strong>Metadata</strong> (the configuration metadata), t<span>he</span> <strong><span>Spring Container</span></strong> <span>represents the ready application as output.</span></p>
<p>The <strong>Bean</strong> module represents a bean, which is an object that's assembled, managed, and <span>instantiated</span> by the IoC Container.</p>
<p class="mce-root"><span>The</span> <strong>Context</strong> module s<span>upports EJB, JMS, Basic Remoting, and so on. The</span> <kbd>ApplicationContext</kbd> <span>interface is the point of concurrence of the <strong>Context</strong> module.</span><br/></p>
<p>The<strong> Expression Language</strong> module is normally used to execute logic, such as data query, sum, divide, and mod, in the application. To execute the logic, this module provides powerful expressions, as listed here:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Arithmetic</strong></td>
<td><kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>, <kbd>/</kbd>, <kbd>%</kbd>, <kbd>^</kbd></td>
</tr>
<tr>
<td><strong>Relational</strong></td>
<td><span><kbd>&lt;=</kbd>, <kbd>&gt;=</kbd>,</span><kbd>&lt;</kbd>, <kbd>&gt;</kbd>, <kbd>==</kbd>, <kbd>!=</kbd></td>
</tr>
<tr>
<td><strong>Logical</strong></td>
<td><kbd>&amp;&amp;</kbd>, <kbd>||</kbd>, <kbd>!</kbd></td>
</tr>
<tr>
<td><strong>Conditional</strong></td>
<td><kbd>?</kbd>, <kbd>:</kbd></td>
</tr>
<tr>
<td><strong>Regex</strong></td>
<td><kbd>matches</kbd></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data Access/Integration</h1>
                </header>
            
            <article>
                
<p><strong>Data Access/Integration</strong> is responsible for setting and getting<span> public or private data</span><span>. It</span> acts as a bridge between the data-access layer and the business layer. Here are some names of the data modules:</p>
<ul>
<li><strong>JDBC</strong>: <strong>Java Database Connectivity</strong> (<strong>JDBC</strong>) helps the application to connect with the database.</li>
<li><strong>O<span>bject-relational mapping</span></strong>: This uses as an integration layer for <strong>object-relational mapping</strong> (<strong>ORM</strong>) APIs.</li>
<li><strong><span>Object/XML mapping</span>:</strong> This uses as an integration layer for <strong>object/XML mapping</strong> (<strong>OXM</strong>) implementations.</li>
<li><strong> Java Messaging Service</strong>: This is used to provide support in Spring for the <strong>Java Messaging Service</strong> (<strong>JMS</strong>).</li>
<li><strong>Transactions</strong>: This is used <span>to provide programmatic and declarative transaction management for the POJO classes.</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web </h1>
                </header>
            
            <article>
                
<p>The <strong>web</strong> is the center of the Spring MVC framework. We can also integrate other technologies, such as JSF and Spring MVC. The web provides some basic integration features, such as login, logout, and uploading or downloading files. The web layer has four modules:</p>
<ul>
<li><strong>Web</strong>: This provides the basic web-oriented integration features.</li>
<li><strong>Web-servlet</strong>: <span>This module contains</span> Spring's MVC implementation for the web application.</li>
<li><strong>Web-struts</strong>: This module provides an enhanced and improved framework to make web development easier.</li>
<li><strong>Web-portlet</strong>: This module is an identical representation of the web MVC framework.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Aspect-oriented programming</h1>
                </header>
            
            <article>
                
<p><strong>Aspect-oriented programming</strong> (<strong>AOP</strong>)<span> is a</span> key <span>component</span> of Spring Framework. This provides a new way to think about the structure of a program. AOP can be implemented in Java and Kotlin. It can be configured in the bean.</p>
<p>AOP splits program logic into certain parts, called <strong>affirmed concerns</strong>. In any enterprise application, there are cross-cutting concerns, which should to be separate from the basic business logic. Logging, transaction handling, performance observing, and security are known as cross-cutting concerns within the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instrumentation</h1>
                </header>
            
            <article>
                
<p>Instrumentation is the capacity to screen the level of an item's performance, to analyze mistakes, and to compose the trace information. Instrumentation is one of the key highlights of Spring Framework for auditing application performance. Spring supports instrumentation through AOP and logging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test</h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the essential parts of an enterprise software development is <strong>testing</strong>. JUnit or TestNG can be used to test Spring components. This supports the unit and integration testing of Spring elements.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring beans</h1>
                </header>
            
            <article>
                
<p>A bean is an object that can be instantiated and assembled by the Spring IoC. These beans are created by configuring Spring's metadata. Here's a set of properties that represent each bean definition:</p>
<ul>
<li>Class</li>
<li>Name</li>
<li>Scope</li>
<li>Constructor-arg</li>
</ul>
<p>Let's learn about the configured metadata's uses in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring configuration metadata</h1>
                </header>
            
            <article>
                
<p><span><span>T</span></span>he three major functions that provide configuration metadata with the Spring container are as follows:</p>
<ul>
<li>XML-based configuration </li>
<li>Kotlin/Java-annotation-based configuration </li>
<li>Kotlin/Java-code-based configuration </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XML-based configuration</h1>
                </header>
            
            <article>
                
<p class="mce-root">The XML-based configuration was introduced in Spring 2.0, and enhanced and extended in Spring 2.5 and 3.0. The main reason for moving to XML-based configuration files was to make Spring XML configuration easier. The <em>classic</em> <kbd>&lt;bean/&gt;</kbd> based approach is good, but also adds some more configuration that can become complex in the big project.</p>
<p class="mce-root">Let's take a look at an example of an XML-based setup document with various bean definitions, including the scope, initialization technique, and destruction strategy, and then we'll discuss this. Here's a piece of code for <kbd>bean.xml</kbd>:</p>
<pre class="mce-root">&lt;!-- A simple bean definition --&gt;<br/><strong>&lt;bean id = "</strong>...<strong>" class = "</strong>...<strong>"&gt;</strong><br/>&lt;!-- collaborators and configuration--&gt;<br/><strong>&lt;/bean&gt;</strong><br/><br/>&lt;!-- A bean example with prototype scope --&gt;<br/><strong>&lt;bean id = "..." class = "..." scope = "prototype"&gt;<br/></strong>&lt;!-- collaborators and configuration--&gt;<br/><strong>&lt;/bean&gt;</strong><br/><br/>&lt;!-- A bean definition with initialization function --&gt;<br/><strong>&lt;bean id = "</strong>...<strong>" class = "</strong>...<strong>" init-function = "</strong>...<strong>"&gt;</strong><br/>&lt;!-- collaborators and configuration--&gt;<br/><strong>&lt;/bean&gt;</strong><br/><br/>&lt;!-- A bean definition with destruction function --&gt;<br/><strong>&lt;bean id = "</strong>...<strong>" class = "</strong>...<strong>" destroy-function = "</strong>...<strong>"&gt;</strong><br/>&lt;!-- collaborators and configuration for this bean go here --&gt;<br/><strong>&lt;/bean&gt;</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bean scopes</h1>
                </header>
            
            <article>
                
<p>We can choose to proclaim an extension for a bean while defining it. For instance, if we constrain Spring to deliver another bean occasion each time, we can initialize a prototype scope as an attribute of a bean. Additionally, if we need Spring to restore a similar bean example, we should proclaim the bean's scope attribute to be a <em>singleton</em>. </p>
<p>Spring Framework underpins the accompanying five scopes, three of which are accessible in the event that we utilize a web-aware <kbd>ApplicationContext</kbd>. Here are some common scopes:</p>
<ul>
<li><strong>Singleton</strong>: Returns the same instance that's used by default every time</li>
<li><strong>Prototype</strong>: Returns a different instance every time</li>
<li class="mce-root"><strong>Request</strong>: Defines an HTTP request that's visible in a single JSP page of the application</li>
<li class="mce-root"><strong>Session</strong>: Defines an HTTP session that's visible in all JSP pages of the application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton scope</h1>
                </header>
            
            <article>
                
<p>The default scope is <span>always</span> a <kbd>singleton</kbd>. This is a bean definition of the Spring IoC container that <span>returns a single object instance in every object initialization.</span> Here's a piece of code for the singleton scope:</p>
<pre>&lt;!-- A bean example with singleton scope --&gt;<br/>&lt;bean id = "..." class = "..." <strong>scope = "singleton"</strong>/&gt;<br/>&lt;!-- You can remove the scope for the singleton --&gt;<br/>&lt;bean id = "..." class = "..."/&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Let's take a look at an example of a <kbd>singleton</kbd> scope.</p>
<p>Create a Spring project in the IDE. To do this, create two <kbd>kt</kbd> files and a bean XML configuration file under the <kbd>src</kbd> folder. </p>
<p>Here's a piece of the code of <kbd>CreateUserGreeting.kt</kbd>:</p>
<pre><span>class </span>UserGreeting {<br/>    <span>private var </span><span>globalGreeting</span>: String? = <span>"Sasuke Uchiha"<br/></span><span><br/></span><span>    fun </span><span>setGreeting</span>(greeting: String) {<br/>        <span>globalGreeting </span>= greeting<br/>    }<br/><br/>    <span>fun </span><span>getGreeting</span>() {<br/>        <span>println</span>(<span>"Welcome, " </span>+ <span>globalGreeting</span>!! + <span>"!!"</span>)<br/>    }<br/>}</pre>
<p>The content of <strong><kbd><span>BeansScopeApplication</span>.kt</kbd> </strong>is as follows:</p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>val </span>context = ClassPathXmlApplicationContext(<span>"Beans.xml"</span>)<br/>    <br/>// first object<br/>    <span>val </span>objectA = context.getBean(<span>"userGreeting"</span><span>, </span>UserGreeting::<span>class</span>.<span>java</span>)<br/><br/>// set a value for greeting<br/>    objectA.setGreeting(<span>"Naruto Uzumaki"</span>)<br/><br/>    objectA.getGreeting()<br/><br/>    <span>val </span>objectB = context.getBean(<span>"userGreeting"</span><span>, </span>UserGreeting::<span>class</span>.<span>java</span>)<br/>    objectB.getGreeting()<br/>}</pre>
<p>The following is the <kbd>beans.xml</kbd><span> configuration file:</span></p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns </span><span>= "http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi </span><span>= "http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation </span><span>= "http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;bean </span><span>id</span><span>="userGreeting" </span><span>class </span><span>="ktPackage.UserGreeting" </span><strong><span>scope</span><span>="singleton"</span></strong><span>/&gt;<br/></span><span><br/></span><span>&lt;/beans&gt;</span></pre>
<p>After running this project, you will find this output:</p>
<pre>Welcome, Naruto Uzumaki!!  &lt;--- value of objectA <br/>Welcome, Naruto Uzumaki!!  &lt;--- value of objectB </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prototype scope</h1>
                </header>
            
            <article>
                
<p>A <kbd>prototype</kbd> scope creates a new instance of a bean in every object initialization. This scope is preferred for the stateful beans. The container doesn't manage the full life cycle of this <kbd>prototype</kbd> scope. Here's <span>a code piece for a </span><kbd>prototype</kbd> <span>scope:</span></p>
<pre>&lt;!-- A bean example with prototype scope --&gt;<br/>&lt;bean id = "..." class = "..." <strong>scope = "prototype"</strong>/&gt;</pre>
<p>Let's look at an example of a <kbd>prototype</kbd> scope.</p>
<p>Reuse the previous project and modify the bean XML configuration file, as follows:  </p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns </span><span>= "http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi </span><span>= "http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation </span><span>= "http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;bean </span><span>id</span><span>="userGreeting" </span><span>class </span><span>="ktPackage.UserGreeting" </span><strong><span>scope</span><span>="prototype"</span></strong><span>/&gt;<br/></span><span><br/></span><span>&lt;/beans&gt;</span></pre>
<p>Once we finish creating the source and bean configuration files, we can run the application. If there's no error, we'll get the following message:</p>
<pre>Welcome, Naruto Uzumaki!!  &lt;--- value of objectA <br/>Welcome, Sasuke Uchiha!!  &lt;--- value of objectB </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bean life cycle</h1>
                </header>
            
            <article>
                
<p><span>Occasionally, we need to instate assets in the bean classes. For instance, this is possible by making database associations or approving third-party services at the season of initialization before any customer request. Spring Framework gives distinctive courses through which we can give post-introduction and pre-annihilation techniques in a Spring bean life cycle.</span></p>
<p class="mce-root"/>
<p><span>These are as follows:</span><br/></p>
<ul>
<li class="mce-root">By actualizing the <kbd>InitializingBean</kbd> and <kbd>DisposableBean</kbd> interfaces—both of these interfaces announce a solitary strategy where we can instate/close assets in the bean. For <kbd>post-instatement</kbd>, we can execute the <kbd>InitializingBean</kbd> interface and <span>provide </span>an implementation of the <kbd>afterPropertiesSet()</kbd> function. For <kbd>pre-destroy</kbd>, we can actualize the <kbd>DisposableBean</kbd> interface and <span>provide </span>an implementation of the <kbd>destroy()</kbd> function. These <span>functions</span> are the callback techniques, which are similar to servlet audience implementations. This functionality is easy to utilize, yet it's not recommended, as it will cause tight coupling with Spring Framework in our bean implementations.</li>
<li class="mce-root">Giving <kbd>init-function</kbd> and <kbd>destroy-function</kbd> quality <span>values</span> for the bean in the Spring bean configuration file. This is the prescribed functionality<span> </span>as there's no immediate dependency to Spring Framework. We can also make our own <span>functions</span>.</li>
</ul>
<div class="mce-root packt_infobox">Both the <kbd>post-init</kbd> and <kbd>pre-destroy</kbd> functions shouldn't have any contentions, but they can throw exceptions. We would also have to get the bean occasion from the Spring application setting for these functions.</div>
<p>Let's see an example of the life cycle of a bean. Here, we'll look at how to initialize and destroy the bean function. Reuse the previous project and modify the bean XML configuration file as follows:</p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns </span><span>= "http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi </span><span>= "http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation </span><span>= "http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;bean </span><span>id</span><span>="userGreeting" </span><span>class </span><span>="ktPackage.UserGreeting" <strong>init-function = "afterPropertiesSet" </strong><br/><strong>      destroy-function = "destroy"</strong></span><span>/&gt;<br/></span><span><br/></span><span>&lt;/beans&gt;</span></pre>
<p>Now add two functions in <kbd>UserGreeting.kt</kbd>:</p>
<pre><span>class </span>UserGreeting {<br/>    <span>private var </span><span>globalGreeting</span>: String? = <span>"Sasuke Uchiha"<br/></span><span><br/></span><span>    </span><span>fun </span><span>setGreeting</span>(greeting: String) {<br/>        <span>globalGreeting </span>= greeting<br/>    }<br/><br/>    <span>fun </span><span>getGreeting</span>() {<br/>        <span>println</span>(<span>"Welcome, " </span>+ <span>globalGreeting</span>!! + <span>"!!"</span>)<br/>    }<br/><br/><strong>    <span>fun </span><span>afterPropertiesSet</span>(){</strong><br/><strong>        <span>println</span>(<span>"Bean is going to start."</span>)</strong><br/><strong>    }</strong><br/><br/><strong>    <span>fun </span><span>destroy</span>(){</strong><br/><strong>        <span>println</span>(<span>"Bean is going to destroy."</span>)</strong><br/><strong>    }</strong><br/>}</pre>
<p>Call <kbd>registerShutdownHook()</kbd> after the task is completed in the <kbd>main</kbd> function of <span><span>the class:</span></span></p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>val </span>context = ClassPathXmlApplicationContext(<span>"Beans.xml"</span>)<br/>    <span>val </span>objectA = context.getBean(<span>"userGreeting"</span><span>, </span>UserGreeting::<span>class</span>.<span>java</span>)<br/><br/>    objectA.setGreeting(<span>"Naruto Uzumaki"</span>)<br/>    objectA.getGreeting()<br/>    <strong>context.registerShutdownHook()</strong><br/>}</pre>
<p>The output will be as follows:</p>
<pre><strong>Bean is going to start.</strong><br/>Welcome, Naruto Uzumaki!!<br/><strong>Bean is going to destroy.</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection</h1>
                </header>
            
            <article>
                
<p>DI is a system where dependencies of an object are provided by outside containers. Spring DI helps in wiring a class with its dependencies and keeping them decoupled so that we can inject these dependencies at runtime.</p>
<p class="mce-root">The dependencies are characterized in the bean configuration. The two most common approaches to injecting objects utilizing XML are <em>constructor</em> <em>injection</em> <em>and setter injection,</em> which we'll take a look at now<em>:</em>Constructor injection</p>
<p class="mce-root"/>
<p>Constructor injections inject dependencies to the class constructor. Let's take a look at an example of the constructor injection. Reuse the previous project and modify the content of <kbd>beans.xml</kbd>:</p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns</span><span>="http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi</span><span>="http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation</span><span>="http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span><span>&gt;</span><span><br/></span><span>    <br/>    &lt;!--Constructor-based Dependency Injection Example Start--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="userGreeting" </span><span>class</span><span>="ktPackage.UserGreeting"</span><span>&gt;<br/></span><strong><span>        &lt;constructor-arg </span><span>ref</span><span>="userSurname" </span></strong><span><strong>/&gt;</strong><br/></span><span>    &lt;/bean&gt;<br/></span><strong><span>    &lt;bean </span><span>id</span><span>="userSurname" </span><span>class</span><span>="ktPackage.UserSurname"</span></strong><span><strong>/&gt;</strong><br/></span><span>    </span><span>&lt;!--Constructor-based Dependency Injection Example End--&gt;</span><span><br/></span><span>&lt;/beans&gt;</span></pre>
<p><kbd>constructor-arg</kbd> is utilized to inject dependencies. The reference of <kbd>constructor-arg</kbd> is an object of the constructor.</p>
<p><span>Create a class of</span><span> </span><kbd>UserSurname.kt</kbd> to see the use of the constructor injection<strong>.</strong> We'll get the surname from this class, as follows:</p>
<pre><strong><span>class </span>UserSurname {</strong><br/><strong>    <span>init </span>{</strong><br/><strong>        <span>println</span>(<span>"This is init of UserSurname"</span>)</strong><br/><strong>    }</strong><br/><br/><strong>    <span>fun </span><span>getSurname</span>(){</strong><br/><strong>        <span>println</span>(<span>"This is the surname of user"</span>)</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<p><span>Initialize</span> <kbd>UserSurname</kbd> <span>and add the <kbd>getUserSurname()</kbd> function to</span> <kbd>CreateUserGreeting.kt</kbd>:</p>
<pre><span>// added a constractor of UserSurname<br/>class </span>UserGreeting(<strong>surname: UserSurname</strong>) {<br/>    <strong><span>private var </span><span>userSurname</span>: UserSurname ?= surname</strong><br/><strong>    <span>init </span>{</strong><br/><strong>        <span>println</span>(<span>"It is a constructor for user's surname"</span>)</strong><br/><strong>    }</strong><br/><br/>    <span>private var </span><span>globalGreeting</span>: String? = <span>"Sasuke Uchiha"<br/></span><span><br/></span><span>    </span><span>fun </span><span>setGreeting</span>(greeting: String) {<br/>        <span>globalGreeting </span>= greeting<br/>    }<br/><br/>    <span>fun </span><span>getGreeting</span>() {<br/>        <span>println</span>(<span>"Welcome, " </span>+ <span>globalGreeting</span>!! + <span>"!!"</span>)<br/>    }<br/><br/>    <span>fun </span><span>afterPropertiesSet</span>(){<br/>        <span>println</span>(<span>"Bean is going to start."</span>)<br/>    }<br/><br/>    <span>fun </span><span>destroy</span>(){<br/>        <span>println</span>(<span>"Bean is going to destroy."</span>)<br/>    }<br/><br/>   <strong> <span>fun </span><span>getUserSurname</span>(){</strong><br/><strong>        <span>userSurname</span>?.getSurname()</strong><br/><strong>    }</strong><br/>}</pre>
<p><span>Now, if we call the <kbd>getUserSurname()</kbd> function in <kbd>BeansScopeApplication</kbd>, we'll get the <kbd>UserSurname</kbd><strong> </strong>class.</span></p>
<p>Here's the sample code of <kbd>BeansScopeApplication.kt</kbd><strong>:</strong></p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>val </span>context = ClassPathXmlApplicationContext(<span>"Beans.xml"</span>)<br/>    <span>val </span>objectA = context.getBean(<span>"userGreeting"</span><span>, </span>UserGreeting::<span>class</span>.<span>java</span>)<br/><strong>    objectA.getUserSurname()</strong><br/><span><br/></span><span>//    objectA.setGreeting("Naruto Uzumaki")<br/></span><span>//    objectA.getGreeting()<br/></span><span>//    context.registerShutdownHook()<br/></span>}</pre>
<p>The output will be as follows:</p>
<pre>This is init of UserSurname                &lt;------ init from UserSurname.kt<br/>It is a constructor for user's surname     &lt;------ init from UserGreeting.kt<br/>This is the surname of user                &lt;------ getUserSurname() of UserGreeting.kt</pre>
<p><strong>Setter injection</strong></p>
<p>In Spring, a setter injection is a kind of DI in which the framework injects the objects that are dependent on another object into the customer using a <kbd>setter</kbd> function. The container first calls the no contention constructor and then calls the setters. The setter-based injection will work regardless of whether a few dependencies have been injected utilizing the constructor.</p>
<p>Let's see an example of the <kbd>setter</kbd> injection. Here, reuse the previous project and modify the content of<span> </span><kbd>beans.xml</kbd>:</p>
<pre><span>&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;<br/>&lt;beans </span><span>xmlns</span><span>="http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi</span><span>="http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation</span><span>="http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span><span>&gt;</span><span><br/>&lt;!--Setter Injection Example Start--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="userGreeting" </span><span>class</span><span>="ktPackage.UserGreeting"</span><span>&gt;<br/></span><span>        &lt;property </span><span>name</span><span>="userSurnameClass" </span><span>ref</span><span>="userSurname"</span><span>/&gt;<br/></span><span>    &lt;/bean&gt;<br/></span><span>    &lt;bean </span><span>id</span><span>="userSurname" </span><span>class</span><span>="ktPackage.UserSurname"</span><span>/&gt;<br/></span><span>    </span><span>&lt;!--Setter Injection Example End--&gt;</span><span><br/></span><span>&lt;/beans&gt;</span></pre>
<p><span>After modifying the bean file, add a setter and getter of <kbd>UserSurname</kbd></span> to the<span> </span><kbd>CreateUserGreeting.kt</kbd> file:</p>
<pre><span>class </span>UserGreeting<span> </span>{<br/><span>    </span><strong><span>private var </span><span>userSurname</span>: UserSurname? = <span>null<br/></span><span><br/></span><span>    fun </span><span>setUserSurnameClass</span>(surname: UserSurname) {</strong><br/><strong>        <span>userSurname </span>= surname</strong><br/><strong>    }</strong><br/><br/><strong>    <span>fun </span><span>getUserSurnameClass</span>(): UserSurname? {</strong><br/><strong>        <span>return </span><span>userSurname<br/></span><span>    </span>}</strong><br/><span><br/>    private var </span><span>globalGreeting</span>: String? = <span>"Sasuke Uchiha"<br/></span><span><br/></span><span>    </span><span>fun </span><span>setGreeting</span>(greeting: String) {<br/>        <span>globalGreeting </span>= greeting<br/>    }<br/><br/>    <span>fun </span><span>getGreeting</span>() {<br/>        <span>println</span>(<span>"Welcome, " </span>+ <span>globalGreeting</span>!! + <span>"!!"</span>)<br/>    }<br/><br/>    <span>fun </span><span>afterPropertiesSet</span>() {<br/>        <span>println</span>(<span>"Bean is going to start."</span>)<br/>    }<br/><br/>    <span>fun </span><span>destroy</span>() {<br/>        <span>println</span>(<span>"Bean is going to destroy."</span>)<br/>    }<br/><br/>    <span>fun </span><span>getUserSurname</span>() {<br/>        <span>userSurname</span>?.getSurname()<br/>    }<br/>}</pre>
<p>The result will be as follows:</p>
<pre>This is init of UserSurname<br/>Setting User Surname in UserGreeting<br/>This is the surname of user</pre>
<p>An example of an empty string or <kbd>null</kbd> value is as follows:</p>
<pre class="mce-root">&lt;bean id="app" class="App"&gt;<br/>&lt;property name="name" value=""/&gt;<br/>&lt;/bean&gt;<br/>&lt;!-- If we need to pass an empty string or null as a value --&gt;<br/>&lt;bean id="app" class="App"&gt;<br/>&lt;property name="name"&gt;<strong>&lt;null/&gt;</strong>&lt;/property&gt;<br/>&lt;/bean&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auto-wiring beans</h1>
                </header>
            
            <article>
                
<p>We've been utilizing <kbd>&lt;constructor-arg&gt;</kbd> and <kbd>&lt;property&gt;</kbd> to inject dependencies. Instead, we can <kbd>autowire</kbd> the dependencies, which helps to diminish the measure of configurations that should be composed.</p>
<p class="mce-root">There are diverse choices for auto-wiring that manage the Spring container on the most proficient method to infuse the conditions. A <span>bean </span>has no auto-wiring by default. </p>
<p>Here are the two major types of auto-wiring:</p>
<ul>
<li class="mce-root"><kbd>byName</kbd>: To <kbd>autowire</kbd><span> a bean</span>, the Spring container<span> chooses the bean by the class name</span>. Here's an example of the use of<span> </span><kbd>byName</kbd>:</li>
</ul>
<pre class="graf graf--pre graf-after--li" style="padding-left: 30px">&lt;bean id="app" class="App" <strong>autowire="byName"</strong>/&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ul>
<li class="mce-root"><kbd>byType</kbd>: <span>To autowire a bean,</span> <span>the Spring container chooses the bean according to the class type. </span>Here is an example of the use of <kbd>byType</kbd>:</li>
</ul>
<pre class="graf graf--pre graf-after--li" style="padding-left: 30px">&lt;bean id="app" class="App" <strong>autowire="byType"</strong>/&gt;</pre>
<p>If there are multiple implementing classes for a <kbd>Service</kbd> interface, you'll find two types of scenario.</p>
<p><span>In the case of </span><kbd>services</kbd> (a cluster of <kbd>services</kbd> execute the <kbd>Service</kbd> interface),<span><span> bean </span></span>won't allow us to execute the <kbd>autowire</kbd> of <kbd>byName</kbd>. If there isn't an occurrence of <kbd>byName</kbd>, it will inject all the executing objects.</p>
<p class="mce-root">In the case of <strong><kbd>mainService</kbd></strong> (an object actualizes the <kbd>Service</kbd> interface), for the <kbd>byType</kbd>/constructor, allocate the autowire-applicant attribute in the <kbd>&lt;bean&gt;</kbd> tag of all executing classes as <kbd>false</kbd>, keeping one of them as <kbd>true</kbd>.</p>
<p>Here's an example of how to handle multiple implementing classes for a <kbd>Service</kbd> interface in <kbd>beans.xml</kbd>:</p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns</span><span>="http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi</span><span>="http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation</span><span>="http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;!--Beans Auto-Wiring Example Start--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="userGreeting" </span><span>class</span><span>="ktPackage.UserGreeting" </span><strong><span>autowire</span><span>="byType"</span></strong><span>/&gt;<br/></span><span>    &lt;bean </span><span>id</span><span>="userSurname" </span><span>class</span><span>="ktPackage.UserSurname" </span><strong><span>autowire-candidate</span><span>="true"</span></strong><span>/&gt;<br/></span><span>    &lt;bean </span><span>id</span><span>="xxxxx" </span><span>class</span><span>="ktPackage.XXXX" </span><strong><span>autowire-candidate</span><span>="false"</span></strong><span>/&gt; </span><span>&lt;!--demoClass--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="yyyyy" </span><span>class</span><span>="ktPackage.YYYY" </span><strong><span>autowire-candidate</span><span>="false"</span></strong><span>/&gt; </span><span>&lt;!--demoClass--&gt;<br/></span><span>    &lt;!--SBeans Auto-Wiring Example End--&gt;</span><span><br/></span><span>&lt;/beans&gt;</span></pre>
<p>For <kbd>byName</kbd>, either rename <kbd>mainService</kbd> in the application class to one of the actualizing classes (that is, <kbd>userSurname</kbd>), or rename the bean <kbd>id</kbd> of that class in the XML configuration to <kbd>mainService</kbd>:</p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns</span><span>="http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi</span><span>="http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation</span><span>="http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;!--Beans Auto-Wiring Example Start--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="userGreeting" </span><span>class</span><span>="ktPackage.UserGreeting" </span><strong><span>autowire</span><span>="byName"</span></strong><span>/&gt;<br/></span><span>    &lt;bean </span><strong><span>id</span><span>="mainService" </span></strong><span>class</span><span>="ktPackage.UserSurname"</span><span>/&gt;<br/></span><span>    &lt;bean </span><span>id</span><span>="xxxxx" </span><span>class</span><span>="ktPackage.XXXX"</span><span>/&gt; </span><span>&lt;!--demoClass--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="yyyyy" </span><span>class</span><span>="ktPackage.YYYY"</span><span>/&gt; </span><span>&lt;!--demoClass--&gt;<br/></span><span>    &lt;!--SBeans Auto-Wiring Example End--&gt;</span><span><br/></span><span>&lt;/beans&gt;</span></pre>
<p>Here are some limitations of auto-wiring:</p>
<ul>
<li><strong>Overriding possibility</strong>: To specify the dependencies, you can use the <kbd>&lt;constructor-arg&gt;</kbd> and <kbd>&lt;property&gt;</kbd> settings, which will override auto-wiring.</li>
<li><strong>Primitive data types</strong>: Primitives, strings, and classes can't be called.</li>
<li><strong>Confusing nature</strong>: Auto-wiring is less accurate than unequivocal wiring.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Annotation-based configuration</h1>
                </header>
            
            <article>
                
<p>Annotations are the new technology of<span> </span><span>DI<strong>.</strong> This started being used with </span>Spring 2.5. There was no need for any XML files to maintain the configuration. To use the annotation-based configuration, you need to create a component class in which you can implement bean configurations. Annotations are unique names or markers on the pertinent class, function, or field revelation.</p>
<p>Presumably, you're familiar with <kbd>@Override</kbd>, which is an annotation that tells the compiler that this annotation is an abrogated function.</p>
<p class="mce-root">In the preceding annotations, the conduct of Spring Framework was to a great extent controlled through XML configuration. Today, the utilization of annotations gives us many advantages through the way we design the practices of Spring Framework.</p>
<p>Here's a piece of <kbd>bean.xml</kbd><span> code:</span></p>
<div>
<pre><span>&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;<br/>&lt;beans <br/>       <br/>       <br/>       xsi:schemaLocation="http://www.springframework.org/schema/beans<br/>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br/>   http://www.springframework.org/schema/context<br/>   http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br/></span><span><br/></span><span>     &lt;context:annotation-config/&gt;<br/>   &lt;!-- bean definitions will be from here --&gt;</span><span><br/></span><span>&lt;/beans&gt;</span></pre></div>
<p class="mce-root">If we use <kbd>&lt;context:annotation-config/&gt;</kbd> in <kbd>bean.xml</kbd>, we can begin annotating the code to wire values into properties, functions, or constructors. We'll learn about a few essential annotations in the following sections<span><span>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @Required annotation</h1>
                </header>
            
            <article>
                
<p>The <kbd>@Required</kbd> annotation is applied to bean property-setter functions. The bean property must be populated in the XML configuration file at configuration-time. This annotation essentially shows that the setter function must be arranged to be dependency-injected with a value at configuration-time.</p>
<p>Add a user model and the <kbd>Main</kbd> class with a <kbd>bean.xml</kbd> configuration file.</p>
<p>The content of the<strong> </strong><span><kbd>bean.xml</kbd> </span><span>configuration file is as follows:</span></p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns</span><span>="http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi</span><span>="http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xmlns:</span><span>context</span><span>="http://www.springframework.org/schema/context"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation</span><span>="http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br/></span><span>   http://www.springframework.org/schema/context<br/></span><span>   http://www.springframework.org/schema/context/spring-context.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;</span><span>context</span><span>:annotation-config/&gt;  </span><span>&lt;!--after this tag, we have to write the beans--&gt;<br/></span><span><br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="users" </span><span>class</span><span>="requiredAnnotation.UsersForReq"</span><span>&gt;<br/></span><strong><span>        &lt;property </span><span>name</span><span>="name" </span><span>value</span><span>="Naruto Uzumaki"</span><span>/&gt;<br/></span><span>        &lt;property </span><span>name</span><span>="village" </span><span>value</span><span>="Konohagakure"</span></strong><span><strong>/&gt;</strong><br/></span><span>    &lt;/bean&gt;<br/></span><span>&lt;/beans&gt;</span></pre>
<p>The content of <kbd>UsersForReq.kt</kbd><strong> </strong>is as follows:</p>
<pre><span>class </span>Users{<br/>    <span>private var </span><span>village</span>: String? = <span>null<br/></span><span>    private var </span><span>name</span>: String? = <span>null<br/></span><span><br/></span><strong><span>    @Required<br/></span></strong><span>    fun </span><span>setVillage</span>(village: String?) {<br/>        <span>this</span>.<span>village </span>= village<br/>    }<br/><br/>    <span>fun </span><span>getVillage</span>(): String? {<br/>        <span>return </span><span>village<br/></span><span>    </span>}<br/><br/><strong>    <span>@Required<br/></span></strong><span>    fun </span><span>setName</span>(name: String) {<br/>        <span>this</span>.<span>name </span>= name<br/>    }<br/><br/>    <span>fun </span><span>getName</span>(): String? {<br/>        <span>return </span><span>name<br/></span><span>    </span>}<br/>}</pre>
<p>The content of <kbd>AnnotationBasedReqApp.kt</kbd><strong> </strong>is as follows:</p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>val </span>context = ClassPathXmlApplicationContext(<span>"requiredAnnotation/beans_for_req.xml"</span>)<br/>    <span>val </span>users = context.getBean(<span>"users"</span>) <span>as </span>UsersForReq<br/><br/>    <span>println</span>(<span>"Name: "</span>+users.getName())<br/>    <span>println</span>(<span>"Village: "</span>+users.getVillage())<br/>}</pre>
<p>The <span><span>output of this project </span></span>will be as follows:</p>
<pre>Name: Naruto Uzumaki<br/>Village: Konohagakure</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @Autowired annotation</h1>
                </header>
            
            <article>
                
<p>The <kbd>@Autowired</kbd> annotation helps us to connect constructors, fields, and setter functions. This annotation injects object dependencies. </p>
<p>Here's the sample code of how to use <kbd>@Autowired</kbd> on a property:</p>
<pre>class User(val name: String,<br/>            val id: String)<br/><br/>class Users{<br/>    <strong>@Autowired</strong><br/>    val user:User ?= null<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>Here's the sample code of how to use <kbd>@Autowired</kbd> on a property:</span></p>
<pre><span>class </span>UsersForAutowired{<br/>    <span>private lateinit var </span><span>userDetails</span>: UserDetails<br/><br/>    <span><strong>@Autowired</strong><br/></span><span>    fun </span><span>setUserDetails</span>(userDetails: UserDetails){<br/>        <span>this</span>.<span>userDetails </span>= userDetails<br/>    }<br/><br/>    <span>fun </span><span>getUserDetails</span>(){<br/>        <span>this</span>.<span>userDetails</span>.getDetails()<br/>    }<br/>}</pre>
<p>The content of<span> </span><kbd>UserDetails.kt</kbd><strong> </strong><span>is as follows:</span></p>
<pre><span>class </span>UserDetails{<br/>    <span>init </span>{<br/>        <span>println</span>(<span>"This class has all the details of the user"</span>)<br/>    }<br/><br/>    <span>fun </span><span>getDetails</span>(){<br/>        <span>println</span>(<span>"Name: Naruto Uzumaki"</span>)<br/>        <span>println</span>(<span>"Village: Konohagakure"</span>)<br/>    }<br/>}</pre>
<p>The output of the project will be as follows:</p>
<pre>This class has all the details of the user<br/>Name: Naruto Uzumaki<br/>Village: Konohagakure<br/><br/></pre>
<p>We can utilize the <kbd>@Autowired</kbd> annotation on properties to dispose of the setter functions. When we pass values of autowired properties utilizing <kbd>&lt;property&gt;</kbd>, Spring will allocate those properties with the passed values or references. So with the utilization of <kbd>@Autowired</kbd> on properties, the <kbd>UsersForAutowired.kt</kbd> file will become as follows:</p>
<pre><span>class </span>UsersForAutowired{<br/>   <strong> <span>init </span>{</strong><br/><strong>        <span>println</span>(<span>"UsersForAutowired constructor." </span>)</strong><br/><strong>    }</strong><br/><br/><strong>    <span>@Autowired<br/></span><span>    private lateinit var </span><span>userDetails</span>: UserDetails</strong><br/><br/>    <span>fun </span><span>getUserDetails</span>(){<br/>        <span>this</span>.<span>userDetails</span>.getDetails()<br/>    }<br/>}</pre>
<p>The result will be as follows:</p>
<pre>UsersForAutowired constructor.<br/>This class has all the details of the user<br/>Name: Naruto Uzumaki<br/>Village: Konohagakure</pre>
<p>You can <span>also </span><span>apply</span> <kbd>@Autowired</kbd> <span>to constructors. An</span> <kbd>@Autowired</kbd><span> </span><span>constructor</span><span> </span><span>annotation demonstrates that the constructor should be autowired when making the bean. This should be the case regardless of whether any</span> <kbd>&lt;constructor-arg&gt;</kbd><span> components are utilized when configuring the bean in the XML file. </span></p>
<p>Here is the modified content of<strong><span> </span></strong><kbd>UsersForAutowired.kt</kbd>:</p>
<pre><span>class </span>UsersForAutowired <span>@Autowired constructor</span>(<span>private var </span><span>userDetails</span>: UserDetails) {<br/>    <span>init </span>{<br/>        <span>println</span>(<span>"UsersForAutowired constructor."</span>)<br/>    }<br/><br/>    <span>fun </span><span>getUserDetails</span>() {<br/>        <span>this</span>.<span>userDetails</span>.getDetails()<br/>    }<br/>}</pre>
<p>The result will be as follows:</p>
<pre>This class has all the details of the user<br/>UsersForAutowired constructor.<br/>Name: Naruto Uzumaki<br/>Village: Konohagakure</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @Qualifier annotation</h1>
                </header>
            
            <article>
                
<p>You might create an excess of one bean of a similar type and need to wire just a single one of them with the property. In such cases, you can utilize the <kbd>@Qualifier</kbd> annotation alongside <kbd>@Autowired</kbd> to evacuate the disarray by determining which correct bean will be wired. In this section, we'll look at a precedent to demonstrate the utilization of a <kbd>@Qualifier</kbd> annotation.</p>
<p class="mce-root"/>
<p>The content of the<strong> </strong><kbd>bean.xml</kbd><span> </span><span>configuration file is as follows:</span></p>
<pre><span>&lt;?</span><span>xml version </span><span>= "1.0" </span><span>encoding </span><span>= "UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns</span><span>="http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>xsi</span><span>="http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xmlns:</span><span>context</span><span>="http://www.springframework.org/schema/context"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation</span><span>="http://www.springframework.org/schema/beans<br/></span><span>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br/></span><span>   http://www.springframework.org/schema/context<br/></span><span>   http://www.springframework.org/schema/context/spring-context.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;</span><span>context</span><span>:annotation-config/&gt;  </span><span>&lt;!--after this tag, you have to write the beans--&gt;<br/></span><span><br/></span><span>    &lt;!-- Definition for Fighters bean without constructor-arg  --&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="fighters" </span><span>class</span><span>="qualifierAnnotation.Fighters"</span><span>/&gt;<br/></span><span><br/></span><span>    &lt;!--fighter 1--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="fighter1" </span><span>class</span><span>="qualifierAnnotation.UsersForQualifier"</span><span>&gt;<br/></span><span>        &lt;property </span><span>name</span><span>="name" </span><span>value</span><span>="Naruto Uzumaki"</span><span>/&gt;<br/></span><span>        &lt;property </span><span>name</span><span>="village" </span><span>value</span><span>="Konohagakure"</span><span>/&gt;<br/></span><span>    &lt;/bean&gt;<br/></span><span><br/></span><span> </span><span>&lt;!--fighter 2--&gt;<br/></span><span>    </span><span>&lt;bean </span><span>id</span><span>="fighter2" </span><span>class</span><span>="qualifierAnnotation.UsersForQualifier"</span><span>&gt;<br/></span><span>        &lt;property </span><span>name</span><span>="name" </span><span>value</span><span>="Gaara"</span><span>/&gt;<br/></span><span>        &lt;property </span><span>name</span><span>="village" </span><span>value</span><span>="Sunagakure"</span><span>/&gt;<br/></span><span>    &lt;/bean&gt;<br/></span><span>&lt;/beans&gt;</span></pre>
<p>Here's the content of <kbd>AnnotationBasedQualifierApp.kt</kbd>:</p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>val </span>context = ClassPathXmlApplicationContext(<span>"qualifierAnnotation/beans_for_qualifier.xml"</span>)<br/>    <span>val </span>fighters = context.getBean(<span>"fighters"</span>) <span>as </span>Fighters<br/>    fighters.getName()<br/>    fighters.getVillage()<br/>}</pre>
<p><span>Now, add another class. Here's </span>the content for <kbd>UsersForQualifier.kt</kbd>:</p>
<pre><span>class </span>UsersForQualifier{<br/>    <span>private var </span><span>village</span>: String? = <span>null<br/></span><span>    private var </span><span>name</span>: String? = <span>null<br/></span><span><br/></span><span>    fun </span><span>setVillage</span>(village: String?) {<br/>        <span>this</span>.<span>village </span>= village<br/>    }<br/><br/>    <span>fun </span><span>getVillage</span>(): String? {<br/>        <span>return </span><span>village<br/></span><span>    </span>}<br/><br/>    <span>fun </span><span>setName</span>(name: String) {<br/>        <span>this</span>.<span>name </span>= name<br/>    }<br/><br/>    <span>fun </span><span>getName</span>(): String? {<br/>        <span>return </span><span>name<br/></span><span>    </span>}<br/>}</pre>
<p>Finally, add the <kbd>Fighters.kt</kbd> class. Here's the content of<strong><span> </span></strong><span>this class:</span></p>
<pre><span>class </span>Fighters {<br/>    <span>@Autowired<br/></span><strong><span>    @Qualifier</span>(<span>"fighter1"</span>)</strong><br/>    <span>lateinit var </span><span>usersForQualifier</span>: UsersForQualifier<br/><br/>    <span>init </span>{<br/>        <span>println</span>(<span>"Fighters constructor."</span>)<br/>    }<br/><br/>    <span>fun </span><span>getName</span>() {<br/>        <span>println</span>(<span>"Name: " </span>+ <span>usersForQualifier</span>.getName())<br/>    }<br/><br/>    <span>fun </span><span>getVillage</span>() {<br/>        <span>println</span>(<span>"Village: " </span>+ <span>usersForQualifier</span>.getVillage())<br/>    }<br/>}</pre>
<p>If you <span>run</span><span> </span><span>the output, it will be as follows: </span></p>
<pre>Fighters constructor.<br/>Name: Naruto Uzumaki<br/>Village: Konohagakure</pre>
<p>Modify the qualifier value like so:</p>
<pre><strong><span> @Qualifier</span>(<span>"fighter2"</span>)</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>It will create the following output: </p>
<pre>Fighters constructor.<br/>Name: Gaara<br/>Village: Sunagakure</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code-based configuration</h1>
                </header>
            
            <article>
                
<p>We saw how to design Spring beans by utilizing the XML configuration file. <span><span>If you are used to XML configuration, you can ignore this topic</span></span>.</p>
<p class="mce-root">The code-based configuration alternative empowers you to compose the majority of your Spring configuration without XML. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @Configuration and @Bean annotations</h1>
                </header>
            
            <article>
                
<p>The use of the <kbd>@Configuration</kbd> annotation on a class, implies that this class will be utilized by the Spring IoC container and will be considered a source of bean definitions.</p>
<p>The use of a <kbd>@Bean</kbd> annotation on a function means the function will return an object that's enrolled as a bean in the Spring application context.</p>
<p>Here's a sample code of <kbd>@Configuration</kbd> and <kbd>@Bean</kbd>:</p>
<pre><strong>@Configuration</strong><br/>open class CodeBasedConfiguration{<br/><strong>  @Bean</strong><br/>  open fun mainApp(): MainApp{<br/>      return MainApp()<br/>  }<br/>}</pre>
<p>The previous code will be equivalent to the following XML configuration:</p>
<pre>&lt;beans&gt;<br/>  <strong>&lt;bean id = "mainApp" class = "MainApp"/&gt;</strong><br/>&lt;/beans&gt;</pre>
<p>Here, the function name is commented on with the <kbd>@Bean</kbd> annotation, which creates and returns the bean definition. Your configuration class can have a presentation for in excess of one <kbd>@Bean</kbd>.</p>
<p>The content of <kbd>GreetingConfigurationConfBean.kt</kbd><strong> </strong>is as follows:</p>
<pre><strong>@Configuration</strong><br/>open class GreetingConfigurationConfBean{<br/><strong>  @Bean</strong><br/>  open fun greeting(): GreetingConfBean{<br/>      return GreetingConfBean()<br/>  }<br/>}</pre>
<p>The content of <kbd>GreetingConfBean.kt</kbd><strong> </strong>is as follows:</p>
<pre>class GreetingConfBean{<br/>    private var users: String? = null<br/>    fun setUsers(users: String) {<br/>        this.users = users<br/>    }<br/>    fun getUsers() {<br/>        println("Welcome, $users!!")<br/>    }<br/>}</pre>
<p>The content of <kbd>MainAppConfBean.kt</kbd><strong> </strong>is as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val applicationContext = AnnotationConfigApplicationContext(GreetingConfigurationConfBean::class.java)<br/><br/>    val greeting = applicationContext.getBean(GreetingConfBean::class.java)<br/><strong>    greeting.setUsers("Naruto Uzumaki")</strong><br/>    greeting.getUsers()<br/>}</pre>
<p>The result will be as follows:</p>
<pre class="mce-root">Welcome, Naruto Uzumaki!!</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection bean</h1>
                </header>
            
            <article>
                
<p>Annotate the <kbd>@Bean</kbd> annotation to inject dependencies. Here's the content of <kbd>GreetingConfigurationDIBean.kt</kbd><strong>:</strong></p>
<pre><strong>@Configuration</strong><br/>open class GreetingConfigurationDIBean{<br/>   <strong> @Bean</strong><br/>    open fun greeting(): GreetingDIBean {<br/>        return GreetingDIBean(getUserDetails())<br/>    }<br/><br/><strong>    @Bean</strong><br/>    open fun getUserDetails(): GreetingDetailsDIBean {<br/>        return GreetingDetailsDIBean()<br/>    }<br/>}</pre>
<p><span>When two </span><kbd>@Beans</kbd><span> are dependent on each other, the dependency is as simplistic as having one bean method call another.</span></p>
<p>The content of <kbd>GreetingDIBean.kt</kbd><strong> </strong>is as follows:</p>
<pre>class GreetingDIBean (private val userDetails: GreetingDetailsDIBean){<br/>    init {<br/>        println("Inside DependenciesInjectBean.GreetingDIBean constructor.")<br/>    }<br/><br/>    fun getGreeting() {<br/>        userDetails.getGreetingDetails()<br/>    }<br/>}</pre>
<p>The content of <kbd>GreetingDetailsDIBean.kt</kbd> is as follows:</p>
<pre>class GreetingDetailsDIBean{<br/>    init {<br/>        println("This class has all the details of the user")<br/>    }<br/><br/>    fun getGreetingDetails(){<br/>        println("Welcome, Naruto Uzumaki!!")<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The content of <kbd>MainApp.kt</kbd><strong> </strong>is as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val applicationContext = AnnotationConfigApplicationContext(GreetingConfigurationDIBean::class.java)<br/><br/>    val greeting = applicationContext.getBean(GreetingDIBean::class.java)<br/>    greeting.getGreeting()<br/>}</pre>
<p>The result will be the following:</p>
<pre class="mce-root">This class has all the details of the user<br/>Inside Greeting constructor.<br/>Welcome, Naruto Uzumaki!!</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @Import annotation</h1>
                </header>
            
            <article>
                
<p>Spring's <kbd>@Import</kbd> annotation <span>offers functions such as</span> <kbd>&lt;import/&gt;</kbd> an element in Spring XML. By utilizing the <kbd>@Import</kbd> annotation, you can import at least one <kbd>@Configuration</kbd> class. It can also import classes that contain no less than one <kbd>@Bean</kbd> function.  </p>
<p><span>The content of </span><kbd>Boo.kt</kbd><strong> </strong>is as follows:</p>
<pre><span>class </span>Foo{<br/>    <span>init </span>{<br/>        <span>println</span>(<span>"This is class Foo"</span>)<br/>    }<br/>}<br/><span>class </span>Boo{<br/>    <span>init </span>{<br/>        <span>println</span>(<span>"This is class Boo"</span>)<br/>    }<br/>}</pre>
<p><span>The content of</span> <kbd>ConfigBoo.kt</kbd><strong> </strong>is as follows:</p>
<pre><strong><span>@Configuration<br/></span></strong><span>class </span>ConfigFoo {<br/><strong>    <span>@Bean<br/></span></strong><span>    fun </span><span>foo</span>(): Foo{<br/>        <span>return </span>Foo()<br/>    }<br/>}<br/><br/><strong><span>@Configuration<br/></span><span>@Import</span>(ConfigFoo::<span>class</span>)</strong><br/><span>class </span>ConfigBoo {<br/><strong>    <span>@Bean<br/></span></strong><span>    fun </span><span>foo</span>(): Boo {<br/>        <span>return </span>Boo()<br/>    }<br/>}</pre>
<p>You don't need to specify both <kbd>ConfigFoo.class</kbd> and <kbd>ConfigBoo.class</kbd> when instantiating the context, so the following code isn't required when you initialize <kbd>AnnotationConfigApplicationContext</kbd>:</p>
<pre>val applicationContext = AnnotationConfigApplicationContext<strong>(ConfigBoo::class.java, ConfigFoo::class.java)</strong></pre>
<p><span>As bean definitions of <kbd>ConfigFoo</kbd> are already loaded by using the <kbd>@Import</kbd> annotation with the <kbd>ConfigBoo</kbd> bean, only <kbd>ConfigBoo</kbd> needs to be </span><span>explicitly </span><span>specified:</span></p>
<pre>val applicationContext = AnnotationConfigApplicationContext<strong>(ConfigBoo::class.java)</strong></pre>
<p>Here's the modified complete code of the <kbd>main</kbd> function <span>of </span> <kbd>MainAppImport.kt</kbd>:</p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>v</span><strong><span>al </span>applicationContext = AnnotationConfigApplicationContext(ConfigBoo::<span>c</span><span>lass</span>.<span>java</span>)</strong><br/><br/>    //both beans Boo and Foo will be available...<br/>    <span>val </span>boo: Boo = applicationContext.getBean(Boo::<span>class</span>.<span>java</span>)<br/>    <span>val </span>foo: Foo = applicationContext.getBean(Foo::<span>class</span>.<span>java</span>)<br/>}</pre>
<p>The result will be as follows:</p>
<pre>This is class Boo<br/>This is class Foo</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Life cycle callbacks</h1>
                </header>
            
            <article>
                
<p>A <kbd>@Bean</kbd> annotation supports determining discretionary introductions and obliteration callback functions. If you noticed <kbd>beans.xml</kbd> in the <kbd>XMLBasedSpringConfiguration</kbd> project, you can find the <kbd>init-method</kbd> and <kbd>destroy-method</kbd> attributes. Here's an example of how to initialize the <kbd>init-method</kbd> and <kbd>destroy-method</kbd> attributes:</p>
<pre><span>&lt;bean </span><span>id=</span><span>"userGreeting" </span><span>class=</span><span>"ktPackage.UserGreeting" </span><strong><span>init-method=</span><span>"afterPropertiesSet" </span><span>destroy-method=</span><span>"destroy"</span></strong><span>/&gt;</span></pre>
<p><span>Here's the </span>modified <span>code of </span><kbd><span>MainAppLifeCall</span>.kt</kbd>:</p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>val </span>applicationContext = AnnotationConfigApplicationContext(ConfigFoo::<span>class</span>.<span>java</span>)<br/><br/>    <span>val </span>foo: Foo = applicationContext.getBean(Foo::<span>class</span>.<span>java</span>)<br/>    applicationContext.registerShutdownHook()<br/>}</pre>
<p>The modified <span>code </span><span>of </span><kbd>Foo.kt</kbd><span> is as follows:</span></p>
<pre><span>class </span>Foo{<br/>    <span>fun </span><span>init</span>(){<br/>        <span>println</span>(<span>"Foo is initializing..."</span>)<br/>    }<br/><br/>    <span>fun </span><span>destroy</span>(){<br/>        <span>println</span>(<span>"Foo is destroying..."</span>)<br/>    }<br/>}</pre>
<p>Now create a configuration class for <kbd>Foo</kbd>. The modified code <span>of</span> <kbd>ConfigFoo.kt</kbd><span> is as follows:</span></p>
<pre><span>@Configuration<br/></span><span>open class </span>ConfigFoo {<br/>    <span>@Bean</span><strong>(<span>initMethod = </span><span>"init"</span><span>, </span><span>destroyMethod = </span><span>"destroy"</span>)</strong><br/>    <span>open fun </span><span>foo</span>(): Foo {<br/>        <span>return </span>Foo()<br/>    }<br/>}</pre>
<p>The output of this project will be as follows: </p>
<pre>Foo is initializing...<br/>Foo is destroying...</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a scope bean</h1>
                </header>
            
            <article>
                
<p>Create a <kbd>@Scope</kbd> bean to make a prototype scope with <kbd>@Configuration</kbd>. <kbd>@Configuration</kbd> represents the configure file of a SpringBoot project. Here's a piece of code that shows how to use the <kbd>@Scope</kbd> prototype <span>annotation:</span></p>
<pre class="prettyprint notranslate prettyprinted"><strong><span class="lit">@Configuration</span><span class="pln">
</span></strong><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> ConfigFoo</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   </span><span class="lit">@Bean</span><strong><span class="pln">
   </span><span class="lit">@Scope</span><span class="pun">(</span><span class="str">"prototype"</span><span class="pun">)</span><span class="pln">
   </span></strong><span class="kwd">public</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> foo</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Foo</span><span class="pun">();</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring MVC</h1>
                </header>
            
            <article>
                
<p>The Spring Web MVC framework uses the <strong>model-view-controller</strong> (<strong>MVC</strong>) architecture, which manages the web applications. This provides a ready component that can be used by developers to develop a robust and loosely-coupled web application. <span>With the presentation of Spring 3.0, the</span> <kbd>@Controller</kbd> <span>component additionally enables you to make peaceful web locales and applications through the</span> <kbd>@PathVariable</kbd> <span>annotation and different features.</span> The MVC pattern separates the different aspects, such as input, business, and UI logic of the application.</p>
<p>There are three parts to MVC:</p>
<ul>
<li>The <strong>model</strong> is at the core of MVC applications. This is where the primary logic and information objects that comprise the core usefulness of the application are produced.</li>
<li class="mce-root">The <strong>view</strong><strong> </strong>is the place the information given by the model is introduced to the client. A view regulates the visual (or other) interface components <span>–</span> it chooses, filters, and arranges data provided by the model.</li>
<li class="mce-root">The <strong>controller</strong> is in charge of preparing client requests, building a proper model, and passing it to the view for rendering.</li>
</ul>
<div>
<p>Here are some of the advantages of Spring MVC framework:</p>
<ul>
<li>Spring MVC helps to separate each role, such as the model object and controller.</li>
<li>When developing and deploying an application, it helps developers to use the lightweight servlet container.</li>
<li>It provides a robust and powerful configuration for the project.</li>
<li>You can develop a project very quickly and in <span>parallel.</span></li>
<li>Testing is very easy and you can inject test data using a setter function.</li>
</ul>
</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DispatcherServlet</h1>
                </header>
            
            <article>
                
<p><kbd>DispatcherServlet</kbd> is one of the core components of the Spring MVC. This works as a front-controller in an application. A front-controller means the Spring MVC receives all incoming requests and forwards these to the Spring MVC controller for processing. This is totally coordinated with the Spring IoC container and accordingly enables you to utilize each element of Spring.</p>
<p class="mce-root"><span><kbd>DispatcherServlet</kbd> handles all the HTTP requests and responses that are designed under </span>the Spring MVC. </p>
<p class="mce-root">Here's a diagram to <span>illustrate</span> <kbd>DispatcherServlet</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/94318afd-4eef-42b2-b829-cbb1af7802a9.png" style="width:39.75em;height:29.33em;"/></p>
<p>The succession of occasions relating to an approaching HTTP request to <kbd>DispatcherServlet</kbd> is as follows:</p>
<ol>
<li><span>The application (as a client) sends a request to <kbd>DispatcherServlet</kbd><em>.</em></span></li>
<li><span><span><kbd>DispatcherServlet</kbd><em> </em>asks the related <kbd>Handler Mapping</kbd> to call the <kbd>Controller</kbd>.</span></span></li>
</ol>
<p> </p>
<ol start="3">
<li>The <kbd>Controller</kbd> takes requests from <kbd>DispatcherServlet</kbd> and calls a relevant service function based on the <kbd>GET</kbd> or <kbd>POST</kbd> function. The service function sets the model data based on the business logic.</li>
<li class="mce-root"><span><kbd>ViewResolver</kbd> </span>selects the defined <kbd>View</kbd>.</li>
<li class="mce-root">The defined <kbd>View</kbd> is executed on the application.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a project</h1>
                </header>
            
            <article>
                
<p>Now, we'll learn about the MVC framework with Kotlin. Although this project is a web application and we need to utilize Maven for dependencies administration, we need to make a dynamic web application and then change it to a Maven venture <span>first</span><span>. The following screenshot demonstrates how to prepare our task skeleton structure:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/57358265-433c-4cec-8502-a571cb33f1c0.png"/></p>
<p>Now we're going to learn how to convert this project into a Maven project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting to a Maven project</h1>
                </header>
            
            <article>
                
<p>Now that the skeleton code for our Maven web-application venture is prepared, we can begin rolling out improvements to it, as well as making our Spring MVC HELLO WORLD application.</p>
<p class="mce-root">The created project is a non-Maven project. We need to convert the project into the Maven project.</p>
<p class="mce-root">To <span>convert this project into a Maven project</span>, open the existing project. In the project tool window, right-click your project and select <span class="packt_screen">Add Framework Support</span>.</p>
<p class="mce-root">In the dialog that opens, select <span class="packt_screen">Maven</span> from the options on the left and click <span class="packt_screen">OK</span>:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/8b68d747-7842-4054-936e-d1d30706ed50.png" style="width:20.17em;height:14.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring MVC dependencies to pom.xml</h1>
                </header>
            
            <article>
                
<p class="mce-root CDPAlignLeft CDPAlign">We have to include <kbd>spring-web</kbd> and <kbd>spring<strong>-</strong>webmvc</kbd> dependencies in <kbd>pom.xml</kbd>, as well as including a servlet-programming interface, JSP-programming interface, and JSTL dependencies. Here's part of the <kbd>pom.xml</kbd> file (the full version is on GitHub) of our project with the <kbd>Spring Core</kbd>, <kbd>Kotlin</kbd>, and <kbd>Web</kbd> dependencies:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;project </span><span>xmlns=</span><span>"http://maven.apache.org/POM/4.0.0"<br/></span><span>         </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>         </span><span>xsi</span><span>:schemaLocation=</span><span>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span>&gt;<br/></span><span>    &lt;modelVersion&gt;</span>4.0.0<span>&lt;/modelVersion&gt;<br/></span><span>     ----<br/>     ----<br/></span><span>    &lt;properties&gt;<br/></span><strong><span>       &lt;springframework.version&gt;</span>5.0.8.RELEASE<span>&lt;/springframework.version&gt;<br/></span><span>        &lt;kotlin.version&gt;</span>1.3.0<span>&lt;/kotlin.version&gt;<br/></span><span>        &lt;jstl.version&gt;</span>1.2</strong><span><strong>&lt;/jstl.version&gt;</strong><br/></span><span>    &lt;/properties&gt;<br/></span><span><br/></span><span>    &lt;dependencies&gt;<br/></span><span><strong>        &lt;!--Spring dependencies--&gt;</strong><br/>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.springframework<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>spring-core<span>&lt;/artifactId&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><span>        ----<br/></span><span>        ----<br/>        ----<br/><br/><strong>        &lt;!--We need to add the following Kotlin dependencies--&gt;</strong><br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.jetbrains.kotlin<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>kotlin-stdlib-jdk8<span>&lt;/artifactId&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><span>    &lt;/dependencies&gt;<br/></span><span>    <br/></span><span>    &lt;build&gt;<br/></span><span>    &lt;plugins&gt;<br/></span><span>        ----<br/>        ----</span><span><br/></span><span>    &lt;/plugins&gt;<br/></span><span>    &lt;/build&gt;<br/></span><span>&lt;/project&gt;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Spring configuration beans</h1>
                </header>
            
            <article>
                
<p>Go to the <kbd>/WebContent/WEB-INF/</kbd> directory and create an XML file called <kbd>spring-mvc-kotlin-servlet.xml</kbd>:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;beans </span><span>xmlns=</span><span>"http://www.springframework.org/schema/beans"<br/></span><span>       </span><span>xmlns:</span><span>mvc</span><span>=</span><span>"http://www.springframework.org/schema/mvc"<br/></span><span>       </span><span>xmlns:</span><span>context</span><span>=</span><span>"http://www.springframework.org/schema/context"<br/></span><span>       </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>       </span><span>xsi</span><span>:schemaLocation=</span><span>"<br/></span><span>        http://www.springframework.org/schema/beans<br/></span><span>        http://www.springframework.org/schema/beans/spring-beans.xsd<br/></span><span>        http://www.springframework.org/schema/mvc<br/></span><span>        http://www.springframework.org/schema/mvc/spring-mvc.xsd<br/></span><span>        http://www.springframework.org/schema/context<br/></span><span>        http://www.springframework.org/schema/context/spring-context.xsd"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;</span><span>mvc</span><span>:annotation-driven /&gt;<br/></span><strong><span>    &lt;</span><span>context</span><span>:component-scan<br/></span><span>            </span><span>base-package=</span><span>"mvckotlin" </span></strong><span><strong>/&gt;</strong><br/></span><span>    &lt;</span><span>mvc</span><span>:default-servlet-handler /&gt;<br/></span><span><br/></span><span>    &lt;bean </span><span>id=</span><span>"viewResolver"<br/></span><span>          </span><span>class=</span><span>"org.springframework.web.servlet.view.UrlBasedViewResolver"</span><span>&gt;<br/></span><span>        &lt;property </span><span>name=</span><span>"viewClass"<br/></span><span>                  </span><span>value=</span><span>"org.springframework.web.servlet.view.JstlView" </span><span>/&gt;<br/></span><span>        &lt;property </span><span>name=</span><span>"prefix" </span><span>value=</span><span>"/WEB-INF/jsp/" </span><span>/&gt;<br/></span><span>        &lt;property </span><span>name=</span><span>"suffix" </span><span>value=</span><span>".jsp" </span><span>/&gt;<br/></span><span>    &lt;/bean&gt;<br/></span><span>&lt;/beans&gt;</span></pre>
<p>In the <kbd>spring-mvc-kotlin-servlet.xml</kbd> configuration file, we mentioned a <kbd>&lt;context:component-scan&gt;</kbd><strong> </strong><span>tag.</span><span> All the components from the </span><kbd>mvckotlin</kbd><span> </span><span>package</span><span> </span><span>and all its child packages will now be loaded by the Spring:</span></p>
<ul>
<li class="mce-root">This will load our <kbd>MVCKotlinApp.class</kbd> and also assign a <kbd>viewResolver</kbd> bean.</li>
<li class="mce-root"><kbd>&lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;</kbd> will resolve the view and add a prefix string named <kbd>/WEB-INF/jsp/</kbd>.</li>
<li class="mce-root">Note that we have returned a <kbd>ModelAndView</kbd> object with the view name <kbd>welcome</kbd><strong> </strong><span>in our <kbd>MVCKotlinApp</kbd> class.</span></li>
<li class="mce-root">This will be resolved to the <kbd>/WEB-INF/jsp/greeting.jsp</kbd> path.</li>
<li>There's a <span><kbd>web.xml</kbd> </span>file under the <kbd>/WebContent/WEB-INF/</kbd><span> directory. If you don't find it, create it in the <kbd>/WebContent/WEB-INF/</kbd> directory. Here's a piece of code from <kbd>web.xml</kbd>:</span></li>
</ul>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;web-app </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>         </span><span>xmlns=</span><span>"http://xmlns.jcp.org/xml/ns/javaee"<br/></span><span>         </span><span>xsi</span><span>:schemaLocation=</span><span>"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"<br/></span><span>         </span><span>version=</span><span>"4.0"</span><span>&gt;<br/></span><span>    &lt;display-name&gt;</span>spring-mvc-kotlin<span>&lt;/display-name&gt;<br/></span><span>    &lt;welcome-file-list&gt;<br/></span><span>        &lt;welcome-file&gt;</span>index.jsp<span>&lt;/welcome-file&gt;<br/></span><span>        &lt;welcome-file&gt;</span>default.jsp<span>&lt;/welcome-file&gt;<br/></span><span>        &lt;welcome-file&gt;</span>default.html<span>&lt;/welcome-file&gt;<br/></span><span>        &lt;welcome-file&gt;</span>index.html<span>&lt;/welcome-file&gt;<br/></span><span><br/></span><span>    &lt;/welcome-file-list&gt;<br/></span><span>    &lt;servlet&gt;<br/></span><strong><span> &lt;servlet-name&gt;</span>spring-mvc-kotlin<span>&lt;/servlet-name&gt;<br/></span></strong><span>        &lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span>&lt;/servlet-class&gt;<br/></span><span>        &lt;load-on-startup&gt;</span>1<span>&lt;/load-on-startup&gt;<br/></span><span>    &lt;/servlet&gt;<br/></span><span>    &lt;servlet-mapping&gt;<br/></span><strong><span>        &lt;servlet-name&gt;</span>spring-mvc-kotlin<span>&lt;/servlet-name&gt;<br/></span></strong><span>        &lt;url-pattern&gt;</span>/index.jsp<span>&lt;/url-pattern&gt;<br/></span><span>        &lt;url-pattern&gt;</span>/greeting.jsp<span>&lt;/url-pattern&gt;<br/></span><span>    &lt;/servlet-mapping&gt;<br/></span><span>&lt;/web-app&gt;</span></pre>
<p><kbd>web.xml</kbd><span> </span>will map <kbd>DispatcherServlet</kbd> with the <kbd>/greeting.jsp</kbd> URL pattern. Furthermore, note that we have mentioned <kbd>index.jsp</kbd> as a greeting file.</p>
<p class="mce-root">After initialization, <kbd>DispatcherServlet</kbd> will look for a file named <kbd>[servlet-name]-servlet.xml</kbd> in the <kbd>WEB-INF</kbd> folder. The value of the servlet XML file prefix name, and value of the <kbd>&lt;servlet-name&gt;</kbd> tag in <kbd>web.xml</kbd>, have to be the same. In our example, <span>the name of the servlet</span> is <kbd>spring-mvc-kotlin-servlet.xml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a controller class</h1>
                </header>
            
            <article>
                
<p>Go to <kbd>src</kbd> | <kbd>main</kbd> <span><span>|</span></span> <kbd>java</kbd> in the project and create the package name that we mentioned in <kbd>spring-mvc-kotlin-servlet.xml</kbd><em>.</em> Assume that our package name is <kbd>mvckotlin</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9c0ad46a-d8c1-43c5-81d7-8176714cc961.png" style="width:68.75em;height:34.00em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Create a controller <kbd>.kt</kbd> file. We call this <kbd>MVCKotlinAppController.kt</kbd>:</p>
<pre><strong><span>@Controller<br/></span></strong><span>class </span>MVCKotlinAppController {<br/>   <strong> <span>@RequestMapping</span>(<span>"/greeting"</span>)</strong><br/>    <span>fun </span><span>greetingMessage</span>(): ModelAndView {<br/>        <span>val </span>message =<br/>            <span>"&lt;div style='text-align:center;'&gt;" </span>+<br/>                <span>"&lt;h3&gt;Welcome to Learn Spring for Android Application Development&lt;/h3&gt;" </span>+<br/>            <span>"&lt;/div&gt;"<br/></span><span>        </span><span>return </span>ModelAndView(<span>"greeting"</span><span>, </span><span>"message"</span><span>, </span>message)<br/>    }<br/>}</pre>
<p class="mce-root">We have a class named <kbd>MVCKotlinAppController.kt</kbd> and annotated this with <kbd>@Controller</kbd>, which means that this class is a controller class. After initializing the project, Spring starts to search the bundle from here.</p>
<p class="mce-root">The <kbd>@RequestMapping("/greeting")</kbd> annotation will map a web request and <kbd>/greeting</kbd> will create a base URI. </p>
<p class="mce-root">We have created a function named <kbd>greetingMessage()</kbd> that will return a <kbd>ModelAndView</kbd> object. Here we just create a sample <kbd>HTML</kbd> code for greeting. If we go to <kbd>http://localhost:8080/greeting</kbd>, this will return a view based on <kbd>greetingMessage()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The view </h1>
                </header>
            
            <article>
                
<p>Create a new file named <kbd>/WebContent/index.jsp</kbd>,<strong> </strong>with the following content:</p>
<pre><span>&lt;%@ </span><span>page </span><span>contentType="</span><span>text/html;charset=UTF-8</span><span>" language="</span><span>kotlin</span><span>" %&gt;</span><br/><span>&lt;html&gt;<br/></span><span>&lt;head&gt;<br/></span><span>    &lt;title&gt;</span>Spring MVC Kotlin<span>&lt;/title&gt;<br/></span><span>&lt;/head&gt;<br/></span><span>&lt;body&gt;<br/></span><span>&lt;br&gt;<br/></span><span>&lt;div </span><span>style=</span><span>"</span><span>text-align</span>: <span>center"</span><span>&gt;<br/></span><span>    &lt;h2&gt;<br/></span><span>        </span>Hey You..!! This is your 1st Spring MCV Tutorial..<span>&lt;br&gt; &lt;br&gt;<br/></span><span>    &lt;/h2&gt;<br/></span><span>    &lt;h3&gt;<br/></span><span>        &lt;a </span><span>href=</span><span>"greeting.html"</span><span>&gt;</span>Click here to See Welcome Message... <span>&lt;/a&gt;</span>(to<br/>        check Spring MVC Controller... @RequestMapping("/greeting"))<br/>    <span>&lt;/h3&gt;<br/></span><span>&lt;/div&gt;<br/></span><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>
<p>Then create another file named <kbd>/WebContent/WEB-INF/jsp/greeting.jsp</kbd>, with the following content:</p>
<pre><span>&lt;html&gt;<br/></span><span>&lt;head&gt;<br/></span><span>    &lt;title&gt;</span>Spring MVC Kotlin<span>&lt;/title&gt;<br/></span><span>&lt;/head&gt;<br/></span><span>&lt;body&gt;<br/></span><span>${</span><span>message</span><span>}</span><span><br/></span><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IntelliJ Ultimate</h1>
                </header>
            
            <article>
                
<p>To run the project, you need to set up the run configuration. Follow these steps to do so:</p>
<ol>
<li>Click the <span class="packt_screen">Run...</span><strong> </strong>button from the toolbar and then add Maven with the <strong><kbd>clean</kbd> <kbd>install</kbd></strong> comment:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3b1fb350-9e38-46e9-9c1d-7cd2c7268015.png" style="width:73.67em;height:15.67em;"/></p>
<ol start="2">
<li>Add <kbd>TomCat Server</kbd> --&gt; <kbd>Local</kbd> and add the <kbd>SpringMVCKotlin:war</kbd> build from <span class="packt_screen">Deployment</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><strong><img src="assets/ed512f7c-261c-4335-a2e9-cc8b690efe21.png" style="width:70.42em;height:14.58em;"/></strong></p>
<ol start="3">
<li>Click the <span class="packt_screen">RUN</span> button on the menu bar to start the project.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Eclipse</h1>
                </header>
            
            <article>
                
<p>Here are the steps to build the project:</p>
<ol>
<li>To run the project, right-click on <span class="packt_screen">Project</span> | <span class="packt_screen">Run As</span> | <span class="packt_screen">Maven Build...</span>.</li>
<li>Add Goals—<strong>clean install<em>.</em></strong></li>
<li>Click <span class="packt_screen">Apply</span> and <span class="packt_screen">Run</span>.</li>
</ol>
<p>If there are no errors, you'll see the following <strong>BUILD SUCCESS</strong> message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cbde584e-8221-4b7d-b140-a2df0c96df39.png" style="width:55.58em;height:18.42em;"/></p>
<p>Visit  <kbd>http://localhost:8080/SpringMVCKotlin/</kbd>, where you'll see the following output of the demo code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca36df6f-c34e-4aea-a135-1c0cee098fef.png" style="width:59.08em;height:22.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SpringBoot </h1>
                </header>
            
            <article>
                
<p><strong>SpringBoot</strong> is a Spring Framework module that has some features to help developers create a production-class application. SpringBoot is a combination of two words—<span><strong>BOOT</strong></span><span> </span><span>is from bootstrap, while </span><strong>SPRING</strong> <span>is a framework used to build Java enterprise applications. This is a large framework</span> that's also supported by numerous other frameworks.<span> SpringBoot is similar in that it lets you bootstrap a spring application from scratch, which is how it gets the name</span> SpringBoot<span>. According to <kbd>spring.io</kbd>, here's the definition of SpringBoot—"</span><span>Spring Boot makes it easy to create stand-alone, production-grade, Spring-based applications that you can just run."</span><span> This means that it helps you to create a runnable project without the help of others. In addition, we showed a </span><strong>production-grade</strong> project <span>here,</span><span> </span><span>which </span><span>is a ready-product application. SpringBoot minimizes the pain of setting up an application.</span></p>
<p>The features of SpringBoot are as follows:</p>
<ul>
<li>It helps to create a standalone Spring application.</li>
<li>It comes with Tomcat, Jetty, or Undertow, and so there's no need to worry about setting up the server environment.</li>
<li>With the use of SpringBoot, you don't need to deploy WAR files.</li>
<li>Third-party frameworks can be imported automatically with their configurations.</li>
<li>XML configuration isn't required if you use SpringBoot.</li>
</ul>
<div class="packt_infobox">SpringBoot doesn't produce code or make changes to your files. Instead, when you start up your application, SpringBoot dynamically wires up beans and settings, and applies them to your application context.</div>
<div>Let's create a SpringBoot project to learn about its dependencies and features.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a project</h1>
                </header>
            
            <article>
                
<p>To create a Spring Boot project, let's generate a sample project from <a href="https://start.spring.io/">https://start.spring.io/</a>. Here, you can add your required dependencies, such as <kbd>Web</kbd>, <kbd>Thymeleaf</kbd>, <kbd>JPA</kbd> , and <kbd>DevTools</kbd>. This can be done as follows:</p>
<ol>
<li>In the drop-down menus at the top, select<span> </span><strong>Maven Project</strong><span> </span>with<span> </span><strong>Kotlin</strong><span> </span>and Spring Boot<span> </span><strong>2.1.1 (SNAPSHOT)</strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d65f510d-7aba-49c6-ae62-5dc840d50fc0.png" style="width:76.83em;height:29.75em;"/></p>
<ol start="2">
<li>Give the name of <strong>Group</strong>, <strong>Artifact</strong>, <strong>Package Name</strong>, and add <strong>Dependencies</strong>. Then hit <span class="packt_screen">Generate Project</span>.</li>
<li>Download and unzip the project.</li>
<li>Import the downloaded project into your IDE.</li>
</ol>
<p>After following these steps, you're ready to use and modify the project. Let's see what's inside this project. You'll find a controller file under <kbd>src/main/kotlin/{packageName}/AppController.kt</kbd>.</p>
<p>Here's a piece of code from the <kbd>controller</kbd> file:</p>
<pre><strong>@RestController</strong><br/>class HtmlController {<br/><strong>    @GetMapping("/")</strong><br/>    fun blog(model: Model): String {<br/>        model["title"] = "Greeting"<br/>        return "index"<br/>    }<br/>}</pre>
<p class="mce-root">Create a class named <kbd>HtmlController.kt</kbd> and annotate it with the <kbd>@RestController</kbd> annotation to make it a controller class in which we'll deal with web requests. <kbd>@RestController</kbd> is the combination of <kbd>@Controller</kbd> and <kbd>@ResponseBody</kbd>.</p>
<p class="mce-root">Create a function named <kbd>blog(model: Model)</kbd> and annotate it with <kbd>@GetMappingmaps("/")</kbd>. This will return <kbd>index.xml</kbd> as output. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an application class</h1>
                </header>
            
            <article>
                
<p>Under <strong><kbd>src/main/kotlin/{packageName}</kbd></strong>,<strong> </strong><span>create an application class named <kbd>SpringBootKotlinApplication.kt</kbd>:</span></p>
<pre><strong><span>@SpringBootApplication<br/></span></strong><span>class SpringBootKotlinApplication</span><br/><br/><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>   <strong><span>runApplication</span>&lt;SpringBootKotlinApplication&gt;(*args)</strong><br/>}</pre>
<p class="mce-root"><kbd>@SpringBootApplication</kbd> is utilized to empower the following three features:</p>
<ul>
<li class="mce-root"><kbd>@Configuration</kbd> enables Java-based configuration.</li>
<li class="mce-root"><kbd>@EnableAutoConfiguration</kbd> enables the auto-configuration feature of SpringBoot.</li>
<li class="mce-root"><kbd>@ComponentScan</kbd> enables component scanning.</li>
</ul>
<p>The <kbd>main()</kbd> function utilizes SpringBoot's <kbd>SpringApplication.run()</kbd> method to dispatch an application. This web application is 100% unadulterated Kotlin and there's no need to arrange any pipes or foundations here.</p>
<p class="CDPAlignLeft CDPAlign">Similarly, there's a <kbd>CommandLineRunner</kbd> function set apart as <kbd>@Bean</kbd> and this keeps running on startup. It recovers every one of the beans that were made either by your application or were naturally added by SpringBoot. It then sorts and prints these out.</p>
<p>In the code of the <kbd>SpringBootKotlinApplication</kbd> class, in contrast with Java, you can see the absence of semicolons, the absence of sections in an empty class (you can add a few, in case you have to proclaim beans by means of a <kbd>@Bean</kbd> annotation), and the utilization of a <kbd>runApplication</kbd> top-level function. <kbd>runApplication&lt;SpringBootKotlinApplication&gt;(*args)</kbd> is Kotlin's informal option in contrast to <kbd>SpringApplication.run(SpringBootKotlinApplication::class.java, *args)</kbd>, and this can be utilized to customize the application.</p>
<p>Now create an HTML file in the <span>folder</span> underneath <kbd>src/main/resources/templates/</kbd>. </p>
<p>The content of <kbd>index.html</kbd> is as follows:</p>
<pre><span>&lt;!DOCTYPE </span><span>html</span><span>&gt;<br/></span><span>&lt;html </span><span>lang=</span><span>"en"</span><span>&gt;<br/></span><span>&lt;head&gt;<br/></span><span>    &lt;meta </span><span>charset=</span><span>"UTF-8"</span><span>/&gt;<br/></span><span>    &lt;title&gt;</span>Spring Boot Kotlin<span>&lt;/title&gt;<br/></span><span>&lt;/head&gt;<br/></span><span>&lt;body&gt;<br/></span><span>   &lt;p&gt;</span>Welcome, Naruto. This project is based on Spring Boot in Kotlin<span>&lt;/p&gt;<br/></span><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>
<p>Start the web application by running the <kbd>main</kbd> function of <kbd>SpringBootKotlinApplication.kt</kbd>. If everything is fine, you'll see this<span> </span><span>in the</span><span> </span><span>logcat</span><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8497d12c-2632-4b56-8b74-7036ee7c725a.png"/></p>
<p>Next, go to <kbd>http://localhost:8080/</kbd>. Here, you should see a web page with a SpringBoot Kotlin application headline:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea5af8b3-1f45-47d1-9f6b-42ac4b9572fe.png"/></p>
<p>We've covered the basics of SpringBoot. Later, we'll go into this in more depth with more dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored Spring and its modules, dependencies, and use of functions. We attempted to cover all the essential information that will be required for the rest of this book. We looked at the steady and solid architecture of Spring Framework with Core, Information Access, Web, AOP, Instrumentation, and Test. Furthermore, we figured out<span> the l</span>ife <span>cycle of a bean</span> and how to design beans in three different ways. We found out about the depth of bean configurations, and we learned about the use of beans in XML, annotation, and code. Now we know how to inject the dependencies into the tasks.</p>
<p>We explored two noteworthy frameworks: Spring MVC and SpringBoot. We'll now be able to make an MVC-based venture with its dependencies and modules. In addition, we learned out about the use of SpringBoot and <span><span>created </span></span>a web application that uses Boot, allowing us to make a web page without an HTML file. We also explored the contrasts between Spring MVC and SpringBoot. You can now create a Spring project in the Kotlin language. </p>
<p>In the next chapter, we'll learn about the required Android and Spring modules to build a client application on the Android platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is Spring Framework?</li>
<li class="mce-root">What is dependency injection?</li>
<li class="mce-root">What is aspect-oriented programming?</li>
<li class="mce-root">What is the Spring IoC container?</li>
<li class="mce-root">What is a Spring bean?</li>
<li class="mce-root">What is a controller in Spring MVC?</li>
<li class="mce-root">What is <kbd>DispatcherServlet</kbd>?</li>
<li class="mce-root"><span>What is </span><kbd>ContextLoaderListener</kbd>?</li>
<li>What is the boilerplate code?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Learning Spring Application Development</em> (<a href="https://www.packtpub.com/application-development/learning-spring-application-development">https://www.packtpub.com/application-development/learning-spring-application-development</a>)</li>
<li><em>Spring MVC: Beginner's Guide - Second Edition</em> (<a href="https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition">https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition</a>)</li>
<li><em>Spring: Microservices with Spring Boot</em> (<a href="https://www.packtpub.com/application-development/spring-microservices-spring-boot">https://www.packtpub.com/application-development/spring-microservices-spring-boot</a>)</li>
</ul>


            </article>

            
        </section>
    </body></html>