["```swift\n messageSubscriber = viewModel.$message\n            .sink { [weak self] message in\n                self?.label.text = message\n            }\n```", "```swift\n URLSession.shared.dataTaskPublisher(for: url)\n```", "```swift\n NotificationCenter.default.publisher(for:\n  Notification.Name(\"DataValueChanged\"))\n```", "```swift\n let timerPublisher = Timer.publish(every: 1.0, on: .main,\n  in: .default)\n    .autoconnect()\n```", "```swift\n extension UserDefaults {\n@objc dynamic var test: Int { return integer(forKey:\n  \"myProperty\") }\n}\nlet userDefaultsPublisher = UserDefaults.standard\n  .publisher(for: \\. myProperty)\n```", "```swift\n import Combine\nimport Foundation\nlet subscriber = Timer.publish(every: 1.0, on: .main, in:\n  .default)\n    .autoconnect()\n    .sink( receiveValue: { value in\n        print(\"Received value: \\(value)\")\n    })\nDispatchQueue.main.asyncAfter(deadline: .now() + 5) {\n    subscriber.cancel()\n}\n```", "```swift\n import Combine\nimport Foundation\nclass DateContainer {\n    var date: Date\n    init() { date = Date() }\n}\nlet container = DateContainer()\nlet cancellable = Timer.publish(every: 1.0, on: .main, in:\n  .default)\n    .autoconnect()\n    .assign(to: \\.date, on: container)\nDispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n    cancellable.cancel()\n}\n```", "```swift\n .sink( receiveValue: { value in\n        container.date = value\n    })\n```", "```swift\n let numbersPublisher = Array(1...20).publisher\nlet subscription = numbersPublisher\n    .filter { $0 % 2 == 0 }\n    .map { \"The number is \\($0)\" }\n    .sink(receiveValue: { print($0) })\n```", "```swift\n class CustomNumberPublisher: Publisher {\n    typealias <st c=\"10923\">Output</st> = Int\n    typealias <st c=\"10946\">Failure</st> = Never\n    private let numbers: [Int]\n    init(numbers: [Int]) {\n        self.numbers = numbers\n    }\n    func receive<S: Subscriber>(subscriber: S) where\n      S.Input == Output, S.Failure == Failure {\n        for number in numbers {\n            _ = subscriber.receive(number)\n        }\n        subscriber.receive(completion: .finished)\n    }\n}\n```", "```swift\n let subscriber = CustomNumberPublisher(numbers: [1, 2, 3,\n  4, 5])\n    .sink { value in\n        print(value)\n}\n```", "```swift\n import Combine\nlet subject = PassthroughSubject<Int, Never>()\nlet subscriber = subject.sink { value in\n    print(\"Received value: \\(value)\")\n}\nsubject.send(1)\nsubject.send(2)\nsubject.send(3)\n```", "```swift\n subject.send(1)\nsubject.send(2)\nsubject.send(completion: .finished)\nsubject.send(3)\n```", "```swift\n import Combine\nlet subject = CurrentValueSubject<String, Never>(\"Initial\n  Value\")\nlet currentValue = subject.value\nprint(\"Current value: \\(currentValue)\")\nlet subscriber = subject.sink { value in\n    print(\"Received value: \\(value)\")\n}\nsubject.send(\"New Value\")\n```", "```swift\n Current value: Initial Value\nReceived value: Initial Value\nReceived value: New Value\n```", "```swift\n let subject1 = PassthroughSubject<Int, Never>()\nlet subject2 = PassthroughSubject<Int, Never>()\nlet subscriber = subject1\n    .merge(with: subject2)\n    .sink { value in\n        print(\"Transformed value: \\(value)\")\n    }\nsubject1.send(1)\nsubject1.send(2)\nsubject2.send(3)\nsubject2.send(4)\n```", "```swift\n Transformed value: 1\nTransformed value: 2\nTransformed value: 3\nTransformed value: 4\n```", "```swift\n class CustomNumberSubscriber: Subscriber {\n    typealias Input = Int\n    typealias Failure = Never\n    func receive(subscription: Subscription) {\n        subscription.request(.unlimited)\n    }\n    func receive(_ input: Int) -> Subscribers.Demand {\n        print(\"Received: \\(input)\")\n        return .unlimited\n    }\n    func receive(completion: Subscribers.Completion<Never>)\n    {\n        print(\"Received completion: \\(completion)\")\n    }\n}\n```", "```swift\n subscription.request(.unlimited)\n```", "```swift\n subscription.request(.max(3))\n```", "```swift\n subscription.request(.none)\n```", "```swift\n _ = subscriber.receive(number)\n```", "```swift\n func receive(subscription: Subscription) {\n        subscription.request(.max(2))\n    }\n    func receive(_ input: Int) -> Subscribers.Demand {\n        print(\"Received: \\(input)\")\n        return .max(3)\n    }\n```", "```swift\n func receive(completion: Subscribers.Completion<Never>) {\n    switch completion {\n    case .finished:\n        print(\"Subscription completed successfully.\")\n    case .failure(let error):\n        print(\"Subscription failed with error: \\(error)\")\n    }\n}\n```", "```swift\n func receive<S: Subscriber>(subscriber: S) where\n      S.Input == Output, S.Failure == Failure {\n        for number in numbers {\n            guard subscriber.receive(number) != .none else\n            {\n                subscriber.receive(completion: .finished)\n                return\n            }\n        }\n        subscriber.receive(completion: .finished)\n    }\n```", "```swift\n let cancellable = (1...10).publisher\n    .filter{ $0 % 2 == 0 }\n    .sink { value in\n        print(value)\n    }\n```", "```swift\n let cancellable = [1,2,2,3,3,3,4,5].publisher <st c=\"24251\">.removeDuplicates()</st> .sink { value in\n    print(value)\n}\n```", "```swift\n 1\n2\n3\n4\n5\n```", "```swift\n extension Publisher {\nâ€¦\npublic func filter(_ isIncluded: @escaping (Self.Output) ->\n  Bool) -> Publishers.Filter<Self>\n}\n```", "```swift\n extension Publisher where Output == Int {\n    func multiply(by factor: Int) -> Publishers.Map<Self,\n      Int> {\n        return self.map { value in\n            return value * factor\n        }\n    }\n}\n```", "```swift\n let cancellable = [1, 2, 3, 4, 5].publisher\n    .multiply(by: 2)\n    .sink { value in\n        print(\"Received value: \\(value)\")\n    }\n```", "```swift\n Received value: 2\nReceived value: 4\nReceived value: 6\nReceived value: 8\nReceived value: 10\n```", "```swift\n extension Publisher where Output == Int {\n    func multiply(by factor: Int) -> AnyPublisher<Int,\n      Failure> {\n        return self.map { value in\n            return value * factor\n        }\n        .eraseToAnyPublisher()\n    }\n}\n```", "```swift\n import Combine\nlet publisher1 = PassthroughSubject<Int, Never>()\nlet publisher2 = PassthroughSubject<Int, Never>()\nlet cancellable = publisher1\n    .zip(publisher2)\n    .sink { value in\n    print(\"Zipped value: \\(value)\")\n}\npublisher1.send(1)  // no output\npublisher2.send(10) // output is (1,10)\npublisher1.send(2)  // no output\npublisher2.send(20) // output is (2,20)\n```", "```swift\n let publisher1 = PassthroughSubject<Int, Never>()\nlet publisher2 = PassthroughSubject<Int, Never>()\nlet cancellable = publisher1\n    .combineLatest(publisher2)\n    .sink { value in\n    print(\"Combined value: \\(value)\")\n}\npublisher1.send(1)  // no output\npublisher2.send(10) // output will be 1,10\npublisher1.send(2) // output will be 2,10\npublisher2.send(20) // output will be 2,20\n```", "```swift\n class MyViewModel {\n    struct Item: Codable {\n        let title: String\n        let description: String\n    }\n    var dataPublisher: AnyPublisher<[Item], Error> {\n        return URLSession.shared.dataTaskPublisher(for:\n          URL(string: \"https://api.example.com/data\")!)\n            .map { $0.data }\n            .decode(type: [Item].self, decoder:\n              JSONDecoder())\n            .eraseToAnyPublisher()\n    }\n}\n```", "```swift\n viewModel.dataPublisher\n            .sink(receiveCompletion: { completion in\n            }, receiveValue: { [weak self] data in\n                self?.updateTableView(with: data)\n            })\n            .store(in: &cancellables)\n```", "```swift\n func searchLocalDatabase(query: String) -> AnyPublisher<[SearchResult], Never> {\n    return Just([\n        SearchResult(id: 1, title: \"Local Result 1\"),\n        SearchResult(id: 2, title: \"Local Result 2\")\n    ])\n    .delay(for: .seconds(1), scheduler: DispatchQueue.main)\n    .eraseToAnyPublisher()\n}\nfunc searchServer(query: String) ->\n  AnyPublisher<[SearchResult], Never> {\n    return Future { promise in\n        DispatchQueue.global().asyncAfter(deadline: .now()\n          + 2) {\n            promise(.success([\n                SearchResult(id: 3, title: \"Server Result\n                  1\"),\n                SearchResult(id: 4, title: \"Server Result\n                  2\")\n            ]))\n        }\n    }\n    .eraseToAnyPublisher()\n}\nvar cancellables = Set<AnyCancellable>()\nlet query = \"example\"\nvar totalResults = [SearchResult]()\nsearchLocalDatabase(query: query)\n    .merge(with: searchServer(query: query))\n    .sink(receiveCompletion: { _ in }, receiveValue: {\n      results in\n        totalResults.append(contentsOf: results)\n        print(\"Search results: \\(totalResults)\")\n    })\n    .store(in: &cancellables)\n```", "```swift\n struct FormView: View {\n    @ObservedObject var viewModel = FormViewModel()\n    var body: some View {\n        VStack {\n            TextField(\"Username\", text:\n              $viewModel.username)\n              .padding()\n             .textFieldStyle(RoundedBorderTextFieldStyle())\n            SecureField(\"Password\", text:\n              $viewModel.password)\n              .padding()\n             .textFieldStyle(RoundedBorderTextFieldStyle())\n            Button(\"Login\") {\n                if viewModel.isFormValid {\n                    print(\"Login successful!\")\n                } else {\n                    print(\"Please fill in all fields.\")\n                }\n            }\n            .padding()\n            .disabled(!viewModel.isFormValid)\n        }\n        .padding()\n    }\n}\n```", "```swift\n class FormViewModel: ObservableObject {\n    @Published var username: String = \"\"\n    @Published var password: String = \"\"\n    @Published var isFormValid: Bool = false\n    private var cancellables = Set<AnyCancellable>()\n    init() {\n        Publishers.combineLatest($username, $password)\n            .map { username, password in\n                !username.isEmpty && !password.isEmpty\n            }\n            .assign(to: \\.isFormValid, on: self)\n            .store(in: &cancellables)\n    }\n}\n```", "```swift\n Publishers.combineLatest($username, $password)\n            .map { username, password in\n                let isUsernameValid = !username.isEmpty &&\n                  username.count >= 6\n                let isPasswordValid = !password.isEmpty &&\n                  password.count >= 8 && password.contains(\n                    where: { $0.isNumber })\n                return isUsernameValid && isPasswordValid\n            }\n            .assign(to: \\.isFormValid, on: self)\n            .store(in: &cancellables)\n```"]