- en: Chapter 8. Behavioral Patterns – Visitor, Interpreter, and Memento
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。行为模式 – 访问者、解释器和备忘录
- en: 'In this chapter, we will complete our discovery trip of the 23 Gang of Four
    patterns. Now, let''s have a look at the three last design patterns of the behavioral
    patterns category. They are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成对23个设计模式的探索之旅。现在，让我们看看行为模式类别的最后三个设计模式。它们如下：
- en: The visitor pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式
- en: The interpreter pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器模式
- en: The memento pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The visitor pattern
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者模式
- en: In this section, we will talk about the visitor pattern, which allows us to
    separate data and their associated treatments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论访问者模式，该模式允许我们分离数据和它们相关的处理。
- en: Roles
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The visitor pattern allows us to externalize and centralize the actions that
    must be executed on object; these objects cannot have any links between them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式允许我们将必须在对象上执行的操作外部化和集中化；这些对象之间不能有任何链接。
- en: These actions will not be implemented in the class of the objects but in external
    classes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作将在外部类中实现，而不是在对象的类中实现。
- en: So, this allows us to add any action in an external class, even a concrete visitor
    that implements **IVisitor**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这允许我们在外部类中添加任何操作，甚至是一个实现**IVisitor**的具体访问者。
- en: 'This pattern can be used when:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要使用此模式时：
- en: We need to add functionalities to a group of classes without weighing down these
    classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在不需要增加这些类负担的情况下向一组类添加功能。
- en: A group of classes have a fixed structure and we need to add some functionalities
    to them without modifying their interface
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组类具有固定的结构，我们需要在不修改它们接口的情况下向它们添加一些功能。
- en: The visitor pattern must be applied and used when you need to perform operations
    on objects of a collection that do not share a common base class or conform to
    a common protocol.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在没有共享公共基类或符合公共协议的对象集合上执行操作时，必须应用和使用访问者模式。
- en: Design
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following diagram shows us how objects and treatments are separated. Treatments
    are implemented in the `ConcreteVisitor` classes. The objects are implemented
    in the `ConcreteElement` classes, as shown in the following figure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了对象和处理是如何分离的。处理在`ConcreteVisitor`类中实现。对象在`ConcreteElement`类中实现，如下所示：
- en: '![Design](img/4852_08_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_08_01.jpg)'
- en: Participants
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The following are the visitor pattern participants:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的是访问者模式参与者：
- en: '`Visitor`: This interface introduces the signature of the methods that realize
    a functionality in a group of classes. There is one method per class that receives
    an instance of this class as an argument.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Visitor`：这个接口引入了在一系列类中实现功能的方法签名。每个类都有一个方法，该方法接收这个类的实例作为参数。'
- en: '`ConcreteVisitors`: This implements methods that realize the functionality
    that correspond to the classes. This functionality is distributed in different
    elements.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteVisitors`：这实现了与类对应的功能性方法。这些功能分布在不同的元素中。'
- en: '`Element`: This is an abstract class of the concrete elements class. It introduces
    the `accept(visitor)` method.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Element`：这是具体元素类的抽象类。它引入了`accept(visitor)`方法。'
- en: '`ConcreteElements`: This implements the `accept()` method, which consists of
    calling the visitor through the method that corresponds to the class.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteElements`：这实现了`accept()`方法，该方法包括通过对应于类的的方法调用访问者。'
- en: Collaboration
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: A client that uses a visitor needs to create an instance of a visitor in the
    class of its choice and then pass it as an argument to the accept method of a
    group of elements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问者的客户端需要在其选择的类中创建访问者实例，然后将它作为参数传递给一组元素的`accept`方法。
- en: The element then calls the the visitor method that corresponds to its class.
    A reference to itself is sent back to the visitor that allows it to access its
    internal structure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 元素随后调用与其类对应的访问者方法。将对其自身的引用发送回访问者，允许它访问其内部结构。
- en: Illustration
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: 'We are a car seller having three brands: DS, Renault, and Citroen, and each
    of them has a price.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是一家汽车销售商，拥有DS、雷诺和雪铁龙三个品牌，每个品牌都有一个价格。
- en: We want to be able to modify the price without modifying our car concrete classes.
    For this, we will introduce our visitor pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在不修改我们的汽车具体类的情况下修改价格。为此，我们将引入我们的访问者模式。
- en: Implementation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: For this last chapter, we will use Playground. Now, open the `VisitorPattern.playground`
    file and let's have a look at how this works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一章，我们将使用Playground。现在，打开`VisitorPattern.playground`文件，让我们看看它是如何工作的。
- en: 'Here, we will use a technique called **Double Dispatch** that will allow us
    to perform the appropriate actions depending on the type of the object . This
    technique also help us to avoid making some type casting to perform the appropriated
    operation. (see the following URL to get more information: [https://en.wikipedia.org/wiki/Double_dispatch
    if you need more informations about this technique](https://en.wikipedia.org/wiki/Double_dispatch
    if you need more informations about this technique))'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用一种称为**双重分派**的技术，这将允许我们根据对象的类型执行适当的操作。这项技术还可以帮助我们避免进行一些类型转换以执行适当的操作。（有关此技术的更多信息，请参阅以下网址：[https://en.wikipedia.org/wiki/Double_dispatch
    如果您需要更多关于此技术的信息](https://en.wikipedia.org/wiki/Double_dispatch 如果您需要更多关于此技术的信息)）
- en: 'First, we define our visitor protocol. The visitor has three visit methods
    having a `ConcreteElement` as an argument to accept each car type, as shown:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义我们的访问者协议。访问者有三个具有`ConcreteElement`作为参数的`visit`方法，以接受每种汽车类型，如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we define our `Car` protocol. A car can accept a concrete `CarVisitor`
    object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的`Car`协议。一辆车可以接受一个具体的`CarVisitor`对象：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can easily implement our three concrete cars. Each of them has a default
    price and also the `accept` method having a concrete `Visitor` object as an argument:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松实现我们的三个具体车型。每个车型都有一个默认价格，还有一个接受具有具体`Visitor`对象的`accept`方法：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `accept` method defined by the `Car` protocol and implemented by the classes
    is the key to the double dispatch technique. By sending `self` as argument to
    the `visitor.visit` method, where visitor is our concrete visitor implementation
    of `CarVisitor`, Swift will choose the version of the `visit` method with the
    most specific type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由`Car`协议定义并由类实现的`accept`方法是双重分派技术的关键。通过将`self`作为参数传递给`visitor.visit`方法，其中`visitor`是我们对`CarVisitor`的具体实现，Swift将选择具有最具体类型的`visit`方法版本。
- en: Lastly, we must implement our concrete visitor, our visitor is in charge of
    modifying the price of the `Element` class. The `Element` class modification depends
    on the type of object passed in the argument.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须实现我们的具体访问者，我们的访问者负责修改`Element`类的价格。`Element`类的修改取决于传递给参数的对象类型。
- en: 'The DS car will see its price modified by 20 percent and the price of Renault
    and Citroen cars modified by 10 percent:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DS汽车的价格将增加20%，雷诺和雪铁龙汽车的价格将增加10%：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The client will be simulated with the following code. We will first instantiate
    our three car objects and add them in a `Car` array. Then we will define a new
    variable `price`, which is an array containing our three new prices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将通过以下代码进行模拟。我们首先实例化我们的三个汽车对象并将它们添加到`Car`数组中。然后，我们将定义一个新的变量`price`，它是一个包含我们三个新价格的数组。
- en: For this, we will use the `map` function that is an extension of the array type.
    It allows us to execute a treatment on each element of the array. Here we can
    (for each element) instantiate a `PriceVisitor` object and pass it in the `accept`
    method of the current `car` object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用`map`函数，它是数组类型的一个扩展。它允许我们对数组的每个元素执行处理。在这里，我们可以（对于每个元素）实例化一个`PriceVisitor`对象，并将其传递给当前`car`对象的`accept`方法。
- en: Then we return the new `visitor.price`, which is the new price of the current
    car object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们返回新的`visitor.price`，这是当前汽车对象的新价格。
- en: 'Like I said in the *Roles* section of this pattern, the visitor pattern is
    used when an array manages a heterogeneous collection of objects that does not
    share a common base class or conforms to a common protocol. By applying the pattern,
    all three `Cars` classes can share and conform to the same protocol and allow
    us to manage the following array:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在此模式的*角色*部分所说，访问者模式用于当数组管理一个不共享公共基类或符合公共协议的异构对象集合时。通过应用此模式，所有三个`Cars`类都可以共享并符合相同的协议，使我们能够管理以下数组：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we can calculate new prices by applying the appropriate visitor calculation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过应用适当的访问者计算来计算新的价格：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To show the result, check the right part of the following screenshot. **23200**,
    **15300** and **17100** are the new prices of our cars:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示结果，请检查以下截图的右侧部分。**23200**、**15300**和**17100**是我们汽车的新价格：
- en: '![Implementation](img/4852_08_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_08_02.jpg)'
- en: The interpreter pattern
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器模式
- en: The interpreter pattern is not really used, but it can be really useful. Usually,
    this pattern is described in terms of formal grammar but the area where it can
    be applied, can be extended.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式实际上并没有被使用，但它确实非常有用。通常，这种模式是用形式语法来描述的，但可以应用此模式的领域可以扩展。
- en: 'You can refer to the following for more information: Lecture de chiffre Romain
    ([http://www.oodesign.com/interpreter-pattern.html](http://www.oodesign.com/interpreter-pattern.html))
    and [https://en.wikipedia.org/wiki/Roman_numerals](https://en.wikipedia.org/wiki/Roman_numerals).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下内容获取更多信息：罗马数字解读（[http://www.oodesign.com/interpreter-pattern.html](http://www.oodesign.com/interpreter-pattern.html)）和[https://en.wikipedia.org/wiki/Roman_numerals](https://en.wikipedia.org/wiki/Roman_numerals)。
- en: Roles
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The interpreter pattern defines an object representation of a language grammar
    in order to evaluate some expression written in this language by interpreting
    them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式定义了一种语言语法的对象表示，以便通过解释来评估用此语言编写的某些表达式。
- en: 'This pattern can be used to interpret some expressions that are represented
    as a hierarchical tree. It may be applied when:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式可以用来解释一些以分层树表示的表达式。它可能适用于以下情况：
- en: Grammar of expression is simple
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式语法很简单
- en: Evaluation doesn't need to be quick
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估不需要很快
- en: 'Some examples where this pattern can be used are:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用此模式的一些示例包括：
- en: In rule engines
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在规则引擎中
- en: To add some functionality to the composite pattern
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向组合模式添加一些功能
- en: Design
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: The implementation of this pattern is seen in the use of the composite pattern
    applied to represent a grammar (refer to the *The composite pattern* in [Chapter
    3](ch03.html "Chapter 3. Structural Patterns – Composite and Flyweight"), *Structural
    Patterns – Composite and Flyweight*). The difference is that the interpreter pattern
    defines the behavior while the composite defines only the structure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的实现体现在将组合模式应用于表示语法（参考第3章中的*组合模式*，*结构型模式 – 组合和享元*）。区别在于解释器模式定义了行为，而组合模式只定义了结构。
- en: 'The UML class diagram of the pattern is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的UML类图如下：
- en: '![Design](img/4852_08_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_08_03.jpg)'
- en: Participants
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'Participants to this pattern are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的参与者如下：
- en: '`AbstractExpression`: This defines the `interpret()` method that is common
    to all the nodes in the abstract syntax tree.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractExpression`: 这定义了抽象语法树中所有节点共有的`interpret()`方法。'
- en: '`TerminalExpression`: This implements the interpret method associated with
    terminal symbols of the grammar. Each terminal symbol of the grammar requires
    a concrete class.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TerminalExpression`: 这实现了与语法终止符号相关的解释方法。语法的每个终止符号都需要一个具体的类。'
- en: '`NonTerminalExpression`: This implements the interpret method and can also
    contain other `AbstractExpression` instances.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NonTerminalExpression`: 这实现了解释方法，也可以包含其他`AbstractExpression`实例。'
- en: '`Context`: This contains information that is global to the interpreter. For
    example, the actual values of variables.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context`: 这包含对解释器全局的信息。例如，变量的实际值。'
- en: '`Client`: This builds an abstract syntax tree that is assembled from instances
    of `NonTerminalExpression` and `TerminalExpression`. It will be our demo usage
    of the pattern.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`: 这将构建一个由`NonTerminalExpression`和`TerminalExpression`实例组成的抽象语法树。这是我们演示该模式的使用。'
- en: Collaboration
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The client builds the abstract syntax tree, initializes the context of the interpreter,
    and then invokes the interpret method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端构建抽象语法树，初始化解释器的上下文，然后调用解释方法。
- en: The interpret method at the `TerminalExpression` and `NonTerminalExpression`
    node uses the context to store and access the state of the interpreter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TerminalExpression`和`NonTerminalExpression`节点上的解释方法使用上下文来存储和访问解释器的状态。
- en: Illustration
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: We want to create a roman number converter; you know the ones that interpret
    that XIV means 14 in decimals. The main purpose of our example is to write a roman
    number and our converter will tell us the decimal value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个罗马数字转换器；您知道那些将XIV解读为十进制中的14的转换器。我们示例的主要目的是编写一个罗马数字，我们的转换器将告诉我们它的十进制值。
- en: Implementation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Open the `InterpreterPattern.xcodeproj` file and see how we have implemented
    the pattern.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`InterpreterPattern.xcodeproj`文件，看看我们是如何实现该模式的。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this pattern, all the code has been added to the `main.swift` class so that
    it can be easily exported into Playground if you want to see the live execution
    of the code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此模式，所有代码都已添加到`main.swift`类中，以便您可以轻松将其导出到Playground中，如果您想看到代码的实时执行。
- en: Before starting to understand the code, have a look at the following link to
    understand how roman numbers work and how they are written.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始理解代码之前，请查看以下链接了解罗马数字是如何工作以及它们是如何书写的。
- en: You can see some rules about the roman numerals and also a roman numeral chart
    at [http://4thgradecrocs.weebly.com/roman-numerals.html](http://4thgradecrocs.weebly.com/roman-numerals.html)
    and how the roman system works can be seen at [https://en.wikipedia.org/wiki/Roman_numerals](https://en.wikipedia.org/wiki/Roman_numerals).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://4thgradecrocs.weebly.com/roman-numerals.html](http://4thgradecrocs.weebly.com/roman-numerals.html)看到一些关于罗马数字的规则，以及罗马数字表，同时也可以了解罗马数字系统是如何工作的，详情请见[https://en.wikipedia.org/wiki/Roman_numerals](https://en.wikipedia.org/wiki/Roman_numerals)。
- en: 'For the pattern, we will use one string extension that lets us do a substring
    easily just by passing the number of characters we want to ignore in the argument:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模式，我们将使用一个字符串扩展，它允许我们通过传递要忽略的字符数来轻松地执行子字符串操作：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The expression to be interpreted is a string that is put in the context:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释的表达式是一个字符串，它被放入上下文中：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class will help us to work while we apply the pattern; it consists of the
    remaining unparsed roman numeral strings and also the result of the numerals that
    are already parsed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将帮助我们应用模式时进行工作；它包括剩余未解析的罗马数字字符串以及已解析的数字的结果。
- en: The context is passed to one of four sub-interpreters based on the type of interpreting
    (thousand, hundred, ten, and one). In this example, only `TerminalExpressions`
    are used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据解释的类型（千位、百位、十位和个位），上下文被传递给四个子解释器之一。在这个例子中，只使用了`TerminalExpressions`。
- en: 'Next, we will define our `AbstractExpression` class. This class must implement
    the `interpret()` method and define the methods that will be overridden in the
    subclasses:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的`AbstractExpression`类。这个类必须实现`interpret()`方法并定义将在子类中重写的方法：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Expression` class consists of the `interpret` method, which receives the
    context. Based on the current object, it uses specific values for thousand, hundred,
    ten, one, and also a specific multiplier.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expression`类由接收上下文的`interpret`方法组成。根据当前对象，它使用特定的千位、百位、十位、个位和特定的乘数值。'
- en: The `one()`, `four()`, `five()`, `nine()`, and `multiplier()` methods of the
    `Expression` class are abstract. They will be implemented in our Concrete `TerminalExpressions`
    class
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expression`类的`one()`、`four()`、`five()`、`nine()`和`multiplier()`方法是抽象的。它们将在我们的具体`TerminalExpressions`类中实现。'
- en: 'We can now implement our four `TerminalExpression` classes. Each of them override
    the `one()`, `four()`, `five()`, `nine()` and the `multiplier()` methods. These
    methods will then be interpreted depending on if we are in a thousand, hundred,
    ten or one expressions. Indeed, these classes are used to define each specific
    expression. Usually, these classes implement the `interpret` method, but here
    it is already defined in the base expression class and each of the `TerminalExpression`
    class defines its behavior by implementing the abstract methods: `one()`, `four()`,
    `five()`, `nine()`, and `multiplier()`. This is a template method (refer to the
    *The template method* section in [Chapter 5](ch05.html "Chapter 5. Behavioral
    Patterns – Strategy, State, and Template Method"), *Behavioral Patterns – Strategy,
    State, and Template Method*):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实现我们的四个`TerminalExpression`类。每个类都重写了`one()`、`four()`、`five()`、`nine()`和`multiplier()`方法。这些方法将根据我们是否处于千位、百位、十位或个位表达式来解释。实际上，这些类用于定义每个特定的表达式。通常，这些类实现`interpret`方法，但在这里它已经在基表达式类中定义，每个`TerminalExpression`类通过实现抽象方法：`one()`、`four()`、`five()`、`nine()`和`multiplier()`来定义其行为。这是一个模板方法（请参阅第5章中的*模板方法*部分[Chapter
    5](ch05.html "第5章。行为模式 – 策略、状态和模板方法")，*行为模式 – 策略、状态和模板方法*）：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The pattern is now written; we only have to test it. Before writing our test
    code, we will create a helper `RomanToDecimalConverter()` class having a `calculate()`
    method that returns the result of the conversion:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模式现在已经编写好了；我们只需要测试它。在编写测试代码之前，我们将创建一个辅助的`RomanToDecimalConverter()`类，它有一个`calculate()`方法，该方法返回转换的结果：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class is responsible to build the syntax tree representing our specific
    value; the roman number, in the language defined by the grammar.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类负责构建表示我们特定值的语法树；罗马数字，在由语法定义的语言中。
- en: 'Note that we can only add our terminal expressions to the array in a specific
    order: from thousand to one expression, as we will parse the roman string from
    left to right.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只能以特定的顺序将我们的终端表达式添加到数组中：从千位到个位表达式，因为我们将从左到右解析罗马数字字符串。
- en: We call the interpret method after the syntax tree is build. We return the `context.output`
    value once all expressions of the pattern are executed, which corresponds to the
    decimal result.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建语法树之后，我们调用`interpret`方法。一旦执行了模式的全部表达式，我们返回`context.output`值，这对应于十进制结果。
- en: 'We will add a new method to our `RomanToDecimalConverter` before writing our
    test code. This will validate that the roman number that we are trying to convert
    is correct: otherwise, a message will be displayed informing us that our number
    is not a roman number. The added code is highlighted in the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试代码之前，我们将向`RomanToDecimalConverter`类添加一个新方法。这将验证我们试图转换的罗马数字是否正确：如果不正确，将显示一条消息，告知我们的数字不是罗马数字。以下代码中添加的代码被突出显示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We first define a new `enum` function that we call `FormatError` of type `ErrorType`.
    We will use this to throw an exception when the format of the roman number is
    incorrect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的`enum`函数，我们称之为`FormatError`，其类型为`ErrorType`。我们将使用它来抛出异常，当罗马数字的格式不正确时。
- en: Then we have a static string `pattern` in the `RomanToDecimalConverter` class
    that contains our regular expression and also an instance constant called `validation`
    that will handle the validation process through an `NSPredicate` object. The purpose
    of this object is to define the logical conditions needed to constrain a search
    either for a fetch or for an in-memory filtering.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`RomanToDecimalConverter`类中有一个静态字符串`pattern`，其中包含我们的正则表达式，还有一个实例常量`validation`，它将通过`NSPredicate`对象处理验证过程。该对象的目的在于定义约束搜索所需的逻辑条件，无论是用于检索还是内存过滤。
- en: In the `calculate` method, we had a `guard` statement that executed the `validate`
    function, if the `validate` function returns `false` (meaning the number is incorrect),
    a `FormatError.RomanNumberFormatError` exception is raised; otherwise, we will
    continue the operation and calculate the decimal value using the pattern. Note
    the addition of the `throws` keyword just before the return type of the method.
    It means that this method can throw errors.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calculate`方法中，我们有一个`guard`语句，它执行`validate`函数，如果`validate`函数返回`false`（表示数字不正确），则抛出`FormatError.RomanNumberFormatError`异常；否则，我们将继续操作并使用模式计算十进制值。注意方法返回类型之前添加的`throws`关键字。这意味着此方法可以抛出错误。
- en: The `validate()` method calls the `evaluateWithObject` method of the `NSPredicate`
    instance by passing the roman number in an argument. This method returns `true`
    if the format is correct, otherwise it will return `false`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate()`方法通过传递罗马数字作为参数调用`NSPredicate`实例的`evaluateWithObject`方法。如果格式正确，该方法返回`true`，否则返回`false`。'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The regex expression used in this code comes from the following URL and is
    very well explained at: [http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression](http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中使用的正则表达式来自以下URL，并且在该网站上解释得非常详细：[http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression](http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression)
- en: 'For more information about NSPredicate, you can refer to this site: [https://realm.io/news/nspredicate-cheatsheet/](https://realm.io/news/nspredicate-cheatsheet/)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`NSPredicate`的更多信息，您可以参考此网站：[https://realm.io/news/nspredicate-cheatsheet/](https://realm.io/news/nspredicate-cheatsheet/)
- en: 'Now we can write our test code like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像以下这样编写测试代码：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We initialize an array with some roman numbers and then initialize our `RomanToDecimalConverter`
    converter object and loop over all elements to make the calculations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化一个包含一些罗马数字的数组，然后初始化我们的`RomanToDecimalConverter`转换器对象，并遍历所有元素进行计算。
- en: 'We are using the following statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用以下声明：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The decimal will return `nil` if an exception is raised. So, the next three
    lines help us to print an appropriate message when a roman number doesn't have
    the correct format.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出异常，十进制将返回`nil`。因此，接下来的三行代码帮助我们打印出适当的消息，当罗马数字格式不正确时。
- en: 'With the three values of our array and after building and running the project,
    you''ll obtain the following result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和运行项目后，使用数组的三个值，您将获得以下结果：
- en: '![Implementation](img/4852_08_04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_08_04.jpg)'
- en: The preceding result given by the program inform us that **MCCMXXVIII** has
    a wrong roman number format and the two others numbers are well converted with
    the 14 decimal value for the first roman number and 1928 for the second roman
    number.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 程序给出的先前结果告诉我们，**MCCMXXVIII**有一个错误的罗马数字格式，而其他两个数字都很好地转换成了第一个罗马数字的14十进制值和第二个罗马数字的1928。
- en: You can try running the code using the roman numeral chart given at the beginning
    of this section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用本节开头提供的罗马数字表运行代码。
- en: You can see that this pattern is really interesting. You have already seen that
    the composite and template method patterns have also been used to build and implement
    our interpreter pattern with our use case.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个模式真的很有趣。你已经看到组合模式和模板方法模式也被用来构建和实现我们的解释器模式，使用我们的用例。
- en: The memento pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The memento pattern will be the last pattern that we will discover together.
    You will see that this pattern is really interesting to work with and has many
    uses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式将是我们将要一起发现的最后一个模式。你会发现这个模式与工作非常有趣，并且有很多用途。
- en: Roles
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The role of the memento pattern is to capture an object's internal state and
    save it externally so that it can be restored later without breaking the encapsulation
    of this object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式的作用是捕获对象的内部状态并将其外部保存，以便以后可以恢复，而不会破坏该对象的封装。
- en: Design
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The generic UML class diagram is defined as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通用UML类图定义为以下：
- en: '![Design](img/4852_08_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_08_05.jpg)'
- en: Participants
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The following are the participants of the memento pattern:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下备忘录模式的参与者：
- en: '`Memento`: This is the class for the objects that saved the internal states
    of origin objects (or part of this state), such as the introduction of the fact
    that the saving of a state can be made independent of the object itself. The memento
    has two interfaces:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Memento`：这是保存原始对象内部状态（或该状态的一部分）的对象的类，例如，保存状态的实现可以独立于对象本身。备忘录有两个接口：'
- en: A complete interface for `Originator` objects that permit access to everything
    that needs to be saved or restored
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的`Originator`对象接口，允许访问需要保存或恢复的所有内容
- en: A narrow interface to the caretaker that can keep and pass on the memento references,
    but no more
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个窄接口的看护者，可以保持和传递备忘录引用，但不再有更多
- en: '`Originator`: This is the object class that creates memento to save their internal
    states and that they can restore from memento.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Originator`：这是创建备忘录以保存其内部状态并可以从备忘录中恢复的对象类。'
- en: '`caretaker`: This is responsible to manage the list of mementos and doesn''t
    provide access to the internal state of the origin objects. This is also the class
    that the client code needs to access.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`caretaker`：这负责管理备忘录列表，不提供对原始对象内部状态的访问。这也是客户端代码需要访问的类。'
- en: '`CreateMemento`: This method is used to save the state of the originator. It
    creates a `Memento` object by saving the state variable into the `Memento` object
    and returns it. This is used to record the state of `Originator`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateMemento`：这个方法用于保存原始对象的状态。它通过将状态变量保存到`Memento`对象中并返回它来创建一个`Memento`对象。这用于记录`Originator`的状态。'
- en: '`SetMemento`: This class stores the historical information of the `Originator`
    objects. The information is stored in its state variable.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetMemento`：这个类存储了`Originator`对象的历史信息。信息存储在其状态变量中。'
- en: Collaboration
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: An instance of `Caretaker` asks for a memento of the `originator` object by
    calling the `createMemento` method and saves it. In case of cancellation and going
    back to the saved state in the memento, you can send it to the `originator` object
    using the `setMemento` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Caretaker`实例通过调用`createMemento`方法请求`originator`对象的备忘录并将其保存。在取消操作并返回备忘录中保存的状态时，你可以使用`setMemento`方法将其发送给`originator`对象。'
- en: Illustration
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: You have developed a platform game where each time your hero passes a level,
    a checkpoint is stored. This allows the player to reload from any level that he
    has already crossed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你开发了一个平台游戏，每次你的英雄通过一个关卡时，都会存储一个检查点。这允许玩家从他已经通过的任何关卡重新加载。
- en: The data that needs to be stored when saving the checkpoint are the level numbers,
    the current weapon, and the number of points.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 保存检查点时需要存储的数据是关卡编号、当前武器和得分数量。
- en: Implementation
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: To simplify our code, we will use an OS X command line project, where we will
    write all our code in the `main.swift` file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的代码，我们将使用一个OS X命令行项目，其中我们将在`main.swift`文件中编写所有代码。
- en: Open the `MementoPattern.xcodeproj` file in Xcode and let's see how we have
    organized our code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中打开`MementoPattern.xcodeproj`文件，让我们看看我们是如何组织我们的代码的。
- en: 'Firstly, we define our `GameState` structure: data that needs to be saved are
    `level`, `weapon`, and `points`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义我们的`GameState`结构：需要保存的数据是`level`、`weapon`和`points`：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we define our `Originator` with the `createMemento` and `setMemento` methods:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义我们的`Originator`，带有`createMemento`和`setMemento`方法：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we implement our `GameState Memento`: it contains all the information
    that `CheckPoint` needs to restore the state.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现我们的`GameState Memento`：它包含`CheckPoint`恢复状态所需的所有信息。
- en: 'First, we define three variables that will help us to store states:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义三个变量，这将帮助我们存储状态：
- en: '`entries` is a list of `GameState`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entries`是一个`GameState`列表。'
- en: '`nextId` contains the next index of the `entries` array'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextId`包含`entries`数组的下一个索引'
- en: '`totalPoints` is a variable that has the total points of each entry'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalPoints`是一个变量，它包含每个条目的总分数。'
- en: We have a constructor where we can pass a `CheckPoint` object as an argument.
    States of the checkpoint are assigned to the memento internal variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个构造函数，我们可以传递一个`CheckPoint`对象作为参数。检查点的状态被分配给备忘录内部变量。
- en: 'The `apply()` method receives a checkpoint object in the argument. Then, we
    assign the current memento values to the checkpoint properties in order to restore
    the checkpoint state:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`方法接收一个检查点对象作为参数。然后，我们将当前备忘录的值分配给检查点的属性，以便恢复检查点状态：'
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now save and restore a memento. The next thing to be done is to create
    our originator: the `CheckPoint` object. While playing the game, an entry will
    be added to the checkpoint entries list.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存和恢复一个备忘录。接下来要做的事情是创建我们的发起者：`CheckPoint`对象。在玩游戏的过程中，一个条目将被添加到检查点条目列表中。
- en: 'Just like in the `Memento` object, we will define three variables. The difference
    being that we initialize them in this object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`Memento`对象中一样，我们将定义三个变量。不同之处在于我们在这个对象中初始化它们：
- en: '`Entries`: This is an array that will contain all entries.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entries`：这是一个将包含所有条目的数组。'
- en: '`totalPoints`: This is an integer initialized to `0` and it will contain the
    total of each level points.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalPoints`：这是一个初始化为`0`的整数，它将包含每个级别的总分数。'
- en: '`nextId`: This is an integer that starts from `0`. It contains the value of
    the next index in the `entries` array.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextId`：这是一个从`0`开始的整数。它包含`entries`数组中的下一个索引值。'
- en: 'We have four methods:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个方法：
- en: '`addGameStateEntry`: This method is used to add a new entry to our entries
    list. This will be called by the client every time a level of our game is complete.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addGameStateEntry`：此方法用于向我们的条目列表中添加一个新的条目。这将在客户端每次完成游戏的一个级别时被调用。'
- en: '`createMemento`: This method creates and return a memento object. The checkpoint
    itself is sent as an argument of the method.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createMemento`：此方法创建并返回一个备忘录对象。检查点本身作为方法的参数传递。'
- en: '`setMemento`: This method allows us to restore a `Memento` object.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMemento`：此方法允许我们恢复一个`Memento`对象。'
- en: '`printCheckPoint`: This method is here to easily see what the current state
    of the `CheckPoint` object is.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printCheckPoint`：此方法用于轻松查看`CheckPoint`对象的当前状态。'
- en: 'The `CheckPoint` class has the following implementation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckPoint`类有以下实现：'
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You have probably seen the following statement:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了以下语句：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is how we can easily sort our array by index value. Then we can use the
    `map` function, only to be able to execute the print statement on each entry of
    the array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何轻松按索引值排序我们的数组。然后我们可以使用`map`函数，只是为了能够在数组的每个条目上执行打印语句。
- en: 'You can see more information about closures to the following URL at: [https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下URL中找到更多关于闭包的信息：[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)
- en: 'Our pattern is now in place, let''s have a look at how to use it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式现在已经就绪，让我们看看如何使用它：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After initializing a checkpoint object, we add two entries to the checkpoint.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化检查点对象后，我们在检查点中添加两个条目。
- en: 'After calling the `printCheckPoint` method of the `checkpoint` object: we obtain
    the following result:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`checkpoint`对象的`printCheckPoint`方法后：我们得到以下结果：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `printCheckPoint` method iterates over all the entries of the checkpoint
    object and displays the state of each one and the total points of the entries.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`printCheckPoint` 方法遍历检查点对象的所有条目并显示每个条目的状态和总分。'
- en: At this moment, we have still not created a `Memento` object, so we cannot restore
    a previous state.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们还没有创建`Memento`对象，因此无法恢复到之前的状态。
- en: 'To create a memento, we only have to call the `createMemento` method of the
    `Originator` object (in our case the `checkPoint` object):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个备忘录，我们只需调用`Originator`对象（在我们的例子中是`checkPoint`对象）的`createMemento`方法：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method returns a memento object that we assign to our memento constant,
    so that we can restore when needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个备忘录对象，我们将其分配给我们的备忘录常量，以便在需要时恢复。
- en: 'We continue the game and pass two others levels successfully and print the
    current checkpoint state once more:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续游戏并成功通过两个其他关卡，然后再次打印当前的检查点状态：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `CheckPoint` now contains four entries in its array.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckPoint`现在在其数组中包含四个条目。'
- en: 'We want to restore our checkpoint state to the last saved state. To proceed,
    we only need to call the `setMemento()`method of the checkpoint object with the
    memento object we previously have created and make a call to the `printCheckPoint`
    method to display the result, as shown:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将检查点状态恢复到最后一次保存的状态。为了继续，我们只需调用检查点对象的`setMemento()`方法，并使用我们之前创建的备忘录对象，然后调用`printCheckPoint`方法以显示结果，如下所示：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result of the `printCheckPoint` call is the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`printCheckPoint` 调用的结果是以下内容：'
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see that the checkpoint object has been restored to its previous state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到检查点对象已经恢复到其之前的状态。
- en: With this simple example, you should now have a good pattern to use and easily
    manage cancellation and restoration of an object.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的例子，你现在应该有一个很好的模式来使用和轻松管理对象的取消和恢复。
- en: The memento pattern is a pattern that is extensively used in scientific computing
    to save the state of long-running computations. As seen here, it may be used to
    save the state of play over a matter of hours or days. In the graphics toolkit,
    it may be used to preserve the state of a display while the objects are being
    moved around.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式是一种在科学计算中被广泛使用的模式，用于保存长时间运行的计算状态。正如这里所看到的，它可以用来保存数小时或数天的游戏状态。在图形工具包中，它可以用来在对象移动时保存显示状态。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Use this pattern when:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下使用此模式：
- en: An object's state must be saved to be restored later
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的状态必须保存以便稍后恢复
- en: It's undesirable to expose the state directly
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接暴露状态是不理想的
- en: Comparing the three patterns
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较三种模式
- en: 'Though they seem dissimilar, there are several ways in which we can compare
    these three patterns:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们看起来不同，但我们有几种方法可以比较这三个模式：
- en: '**Reusability**: All three patterns aim to relieve the developer of implementing
    a common code repeatedly. Indeed, once the visitor has been implemented, they
    can be reused with different types of objects without any changes. To facilitate
    the reuse, you must limit the number of states the visitor needs to be aware of.
    The interpreter pattern is designed to parse an input where the structure is data
    driven. The `Caretaker` and memento classes of the `Memento` pattern are independent
    of the data, only the originator should be changed.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：所有三种模式都旨在减轻开发者重复实现通用代码的负担。实际上，一旦实现了访问者，它们可以与不同类型的对象一起重用，而无需任何更改。为了促进重用，你必须限制访问者需要了解的状态数量。解释器模式旨在解析一个输入，其中结构是数据驱动的。《Memento》模式的`Caretaker`和备忘录类与数据无关，只有`Originator`应该改变。'
- en: '**Working with structure**: These patterns are intended to work with structures.
    Visitor and interpreter require the developer to write traversing codes whereas
    the memento pattern moves the structure as a whole, relying on the serialization
    to do the traversing.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与结构一起工作**：这些模式旨在与结构一起使用。访问者和解释器模式要求开发者编写遍历代码，而备忘录模式将整个结构移动，依赖于序列化来进行遍历。'
- en: '**Objects as argument**: In the memento and visitor patterns, objects are passed
    around as a part of their structure, while in the interpreter pattern it relies
    on a context that is basically the evolving state of the input that is being interpreted
    to output.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为参数的对象**：在备忘录和访问者模式中，对象作为其结构的一部分被传递，而在解释器模式中，它依赖于一个上下文，基本上是正在被解释以输出到输出的输入的演变状态。'
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter concludes the discovery of the eight behavioral patterns, as described
    by the gang of four. Moreover, this chapter concludes the book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了由四人帮描述的八个行为模式，并且本章也标志着本书的结束。
- en: I wanted the book to be really easy to follow without adding complexity in the
    sample provided. This book is intended to be a reference for anyone who wants
    to implement design patterns with Swift.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能够非常易于跟随，而不会在提供的示例中增加复杂性。本书旨在成为任何想要使用Swift实现设计模式的人的参考。
- en: There are some points that we have not covered, such as multi-concurrency access,
    Swift 2 special coding with closure, and so on. I think that these points don't
    occur in a learning book. The main purpose of the book is to easily find the appropriate
    pattern when needed and have an easy illustration to follow.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有些我们没有涉及到的点，比如多并发访问、使用闭包的Swift 2特殊编码等等。我认为这些点在教材中并不常见。本书的主要目的是在需要时能够轻松找到合适的模式，并且有一个易于理解的示例来跟随。
- en: Well, you now have all the necessary information to structure your code in a
    scalable way. This will help you to structure your code properly, increase the
    performance of your code, and reduce maintenance costs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你现在已经拥有了所有必要的知识来以可扩展的方式组织你的代码。这将帮助你正确地组织代码，提高代码的性能，并降低维护成本。
- en: I really thank you to have followed the book. Now, it's up to you to put this
    knowledge into practice.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的非常感谢你一直跟随这本书。现在，将所学知识付诸实践就取决于你了。
