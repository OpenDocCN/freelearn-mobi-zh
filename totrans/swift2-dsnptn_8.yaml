- en: Chapter 8. Behavioral Patterns – Visitor, Interpreter, and Memento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will complete our discovery trip of the 23 Gang of Four
    patterns. Now, let''s have a look at the three last design patterns of the behavioral
    patterns category. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memento pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visitor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will talk about the visitor pattern, which allows us to
    separate data and their associated treatments.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The visitor pattern allows us to externalize and centralize the actions that
    must be executed on object; these objects cannot have any links between them.
  prefs: []
  type: TYPE_NORMAL
- en: These actions will not be implemented in the class of the objects but in external
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: So, this allows us to add any action in an external class, even a concrete visitor
    that implements **IVisitor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to add functionalities to a group of classes without weighing down these
    classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A group of classes have a fixed structure and we need to add some functionalities
    to them without modifying their interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visitor pattern must be applied and used when you need to perform operations
    on objects of a collection that do not share a common base class or conform to
    a common protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows us how objects and treatments are separated. Treatments
    are implemented in the `ConcreteVisitor` classes. The objects are implemented
    in the `ConcreteElement` classes, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the visitor pattern participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Visitor`: This interface introduces the signature of the methods that realize
    a functionality in a group of classes. There is one method per class that receives
    an instance of this class as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteVisitors`: This implements methods that realize the functionality
    that correspond to the classes. This functionality is distributed in different
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Element`: This is an abstract class of the concrete elements class. It introduces
    the `accept(visitor)` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteElements`: This implements the `accept()` method, which consists of
    calling the visitor through the method that corresponds to the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A client that uses a visitor needs to create an instance of a visitor in the
    class of its choice and then pass it as an argument to the accept method of a
    group of elements.
  prefs: []
  type: TYPE_NORMAL
- en: The element then calls the the visitor method that corresponds to its class.
    A reference to itself is sent back to the visitor that allows it to access its
    internal structure.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are a car seller having three brands: DS, Renault, and Citroen, and each
    of them has a price.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to modify the price without modifying our car concrete classes.
    For this, we will introduce our visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this last chapter, we will use Playground. Now, open the `VisitorPattern.playground`
    file and let's have a look at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will use a technique called **Double Dispatch** that will allow us
    to perform the appropriate actions depending on the type of the object . This
    technique also help us to avoid making some type casting to perform the appropriated
    operation. (see the following URL to get more information: [https://en.wikipedia.org/wiki/Double_dispatch
    if you need more informations about this technique](https://en.wikipedia.org/wiki/Double_dispatch
    if you need more informations about this technique))'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define our visitor protocol. The visitor has three visit methods
    having a `ConcreteElement` as an argument to accept each car type, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define our `Car` protocol. A car can accept a concrete `CarVisitor`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily implement our three concrete cars. Each of them has a default
    price and also the `accept` method having a concrete `Visitor` object as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `accept` method defined by the `Car` protocol and implemented by the classes
    is the key to the double dispatch technique. By sending `self` as argument to
    the `visitor.visit` method, where visitor is our concrete visitor implementation
    of `CarVisitor`, Swift will choose the version of the `visit` method with the
    most specific type.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we must implement our concrete visitor, our visitor is in charge of
    modifying the price of the `Element` class. The `Element` class modification depends
    on the type of object passed in the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DS car will see its price modified by 20 percent and the price of Renault
    and Citroen cars modified by 10 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The client will be simulated with the following code. We will first instantiate
    our three car objects and add them in a `Car` array. Then we will define a new
    variable `price`, which is an array containing our three new prices.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will use the `map` function that is an extension of the array type.
    It allows us to execute a treatment on each element of the array. Here we can
    (for each element) instantiate a `PriceVisitor` object and pass it in the `accept`
    method of the current `car` object.
  prefs: []
  type: TYPE_NORMAL
- en: Then we return the new `visitor.price`, which is the new price of the current
    car object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like I said in the *Roles* section of this pattern, the visitor pattern is
    used when an array manages a heterogeneous collection of objects that does not
    share a common base class or conforms to a common protocol. By applying the pattern,
    all three `Cars` classes can share and conform to the same protocol and allow
    us to manage the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can calculate new prices by applying the appropriate visitor calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the result, check the right part of the following screenshot. **23200**,
    **15300** and **17100** are the new prices of our cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The interpreter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interpreter pattern is not really used, but it can be really useful. Usually,
    this pattern is described in terms of formal grammar but the area where it can
    be applied, can be extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to the following for more information: Lecture de chiffre Romain
    ([http://www.oodesign.com/interpreter-pattern.html](http://www.oodesign.com/interpreter-pattern.html))
    and [https://en.wikipedia.org/wiki/Roman_numerals](https://en.wikipedia.org/wiki/Roman_numerals).'
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interpreter pattern defines an object representation of a language grammar
    in order to evaluate some expression written in this language by interpreting
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used to interpret some expressions that are represented
    as a hierarchical tree. It may be applied when:'
  prefs: []
  type: TYPE_NORMAL
- en: Grammar of expression is simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation doesn't need to be quick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples where this pattern can be used are:'
  prefs: []
  type: TYPE_NORMAL
- en: In rule engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add some functionality to the composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of this pattern is seen in the use of the composite pattern
    applied to represent a grammar (refer to the *The composite pattern* in [Chapter
    3](ch03.html "Chapter 3. Structural Patterns – Composite and Flyweight"), *Structural
    Patterns – Composite and Flyweight*). The difference is that the interpreter pattern
    defines the behavior while the composite defines only the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UML class diagram of the pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Participants to this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractExpression`: This defines the `interpret()` method that is common
    to all the nodes in the abstract syntax tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TerminalExpression`: This implements the interpret method associated with
    terminal symbols of the grammar. Each terminal symbol of the grammar requires
    a concrete class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NonTerminalExpression`: This implements the interpret method and can also
    contain other `AbstractExpression` instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context`: This contains information that is global to the interpreter. For
    example, the actual values of variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: This builds an abstract syntax tree that is assembled from instances
    of `NonTerminalExpression` and `TerminalExpression`. It will be our demo usage
    of the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client builds the abstract syntax tree, initializes the context of the interpreter,
    and then invokes the interpret method.
  prefs: []
  type: TYPE_NORMAL
- en: The interpret method at the `TerminalExpression` and `NonTerminalExpression`
    node uses the context to store and access the state of the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to create a roman number converter; you know the ones that interpret
    that XIV means 14 in decimals. The main purpose of our example is to write a roman
    number and our converter will tell us the decimal value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `InterpreterPattern.xcodeproj` file and see how we have implemented
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this pattern, all the code has been added to the `main.swift` class so that
    it can be easily exported into Playground if you want to see the live execution
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to understand the code, have a look at the following link to
    understand how roman numbers work and how they are written.
  prefs: []
  type: TYPE_NORMAL
- en: You can see some rules about the roman numerals and also a roman numeral chart
    at [http://4thgradecrocs.weebly.com/roman-numerals.html](http://4thgradecrocs.weebly.com/roman-numerals.html)
    and how the roman system works can be seen at [https://en.wikipedia.org/wiki/Roman_numerals](https://en.wikipedia.org/wiki/Roman_numerals).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the pattern, we will use one string extension that lets us do a substring
    easily just by passing the number of characters we want to ignore in the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression to be interpreted is a string that is put in the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This class will help us to work while we apply the pattern; it consists of the
    remaining unparsed roman numeral strings and also the result of the numerals that
    are already parsed.
  prefs: []
  type: TYPE_NORMAL
- en: The context is passed to one of four sub-interpreters based on the type of interpreting
    (thousand, hundred, ten, and one). In this example, only `TerminalExpressions`
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define our `AbstractExpression` class. This class must implement
    the `interpret()` method and define the methods that will be overridden in the
    subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Expression` class consists of the `interpret` method, which receives the
    context. Based on the current object, it uses specific values for thousand, hundred,
    ten, one, and also a specific multiplier.
  prefs: []
  type: TYPE_NORMAL
- en: The `one()`, `four()`, `five()`, `nine()`, and `multiplier()` methods of the
    `Expression` class are abstract. They will be implemented in our Concrete `TerminalExpressions`
    class
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now implement our four `TerminalExpression` classes. Each of them override
    the `one()`, `four()`, `five()`, `nine()` and the `multiplier()` methods. These
    methods will then be interpreted depending on if we are in a thousand, hundred,
    ten or one expressions. Indeed, these classes are used to define each specific
    expression. Usually, these classes implement the `interpret` method, but here
    it is already defined in the base expression class and each of the `TerminalExpression`
    class defines its behavior by implementing the abstract methods: `one()`, `four()`,
    `five()`, `nine()`, and `multiplier()`. This is a template method (refer to the
    *The template method* section in [Chapter 5](ch05.html "Chapter 5. Behavioral
    Patterns – Strategy, State, and Template Method"), *Behavioral Patterns – Strategy,
    State, and Template Method*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern is now written; we only have to test it. Before writing our test
    code, we will create a helper `RomanToDecimalConverter()` class having a `calculate()`
    method that returns the result of the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This class is responsible to build the syntax tree representing our specific
    value; the roman number, in the language defined by the grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can only add our terminal expressions to the array in a specific
    order: from thousand to one expression, as we will parse the roman string from
    left to right.'
  prefs: []
  type: TYPE_NORMAL
- en: We call the interpret method after the syntax tree is build. We return the `context.output`
    value once all expressions of the pattern are executed, which corresponds to the
    decimal result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a new method to our `RomanToDecimalConverter` before writing our
    test code. This will validate that the roman number that we are trying to convert
    is correct: otherwise, a message will be displayed informing us that our number
    is not a roman number. The added code is highlighted in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We first define a new `enum` function that we call `FormatError` of type `ErrorType`.
    We will use this to throw an exception when the format of the roman number is
    incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have a static string `pattern` in the `RomanToDecimalConverter` class
    that contains our regular expression and also an instance constant called `validation`
    that will handle the validation process through an `NSPredicate` object. The purpose
    of this object is to define the logical conditions needed to constrain a search
    either for a fetch or for an in-memory filtering.
  prefs: []
  type: TYPE_NORMAL
- en: In the `calculate` method, we had a `guard` statement that executed the `validate`
    function, if the `validate` function returns `false` (meaning the number is incorrect),
    a `FormatError.RomanNumberFormatError` exception is raised; otherwise, we will
    continue the operation and calculate the decimal value using the pattern. Note
    the addition of the `throws` keyword just before the return type of the method.
    It means that this method can throw errors.
  prefs: []
  type: TYPE_NORMAL
- en: The `validate()` method calls the `evaluateWithObject` method of the `NSPredicate`
    instance by passing the roman number in an argument. This method returns `true`
    if the format is correct, otherwise it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The regex expression used in this code comes from the following URL and is
    very well explained at: [http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression](http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about NSPredicate, you can refer to this site: [https://realm.io/news/nspredicate-cheatsheet/](https://realm.io/news/nspredicate-cheatsheet/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write our test code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We initialize an array with some roman numbers and then initialize our `RomanToDecimalConverter`
    converter object and loop over all elements to make the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The decimal will return `nil` if an exception is raised. So, the next three
    lines help us to print an appropriate message when a roman number doesn't have
    the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the three values of our array and after building and running the project,
    you''ll obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding result given by the program inform us that **MCCMXXVIII** has
    a wrong roman number format and the two others numbers are well converted with
    the 14 decimal value for the first roman number and 1928 for the second roman
    number.
  prefs: []
  type: TYPE_NORMAL
- en: You can try running the code using the roman numeral chart given at the beginning
    of this section.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this pattern is really interesting. You have already seen that
    the composite and template method patterns have also been used to build and implement
    our interpreter pattern with our use case.
  prefs: []
  type: TYPE_NORMAL
- en: The memento pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The memento pattern will be the last pattern that we will discover together.
    You will see that this pattern is really interesting to work with and has many
    uses.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The role of the memento pattern is to capture an object's internal state and
    save it externally so that it can be restored later without breaking the encapsulation
    of this object.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generic UML class diagram is defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the participants of the memento pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Memento`: This is the class for the objects that saved the internal states
    of origin objects (or part of this state), such as the introduction of the fact
    that the saving of a state can be made independent of the object itself. The memento
    has two interfaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete interface for `Originator` objects that permit access to everything
    that needs to be saved or restored
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A narrow interface to the caretaker that can keep and pass on the memento references,
    but no more
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Originator`: This is the object class that creates memento to save their internal
    states and that they can restore from memento.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`caretaker`: This is responsible to manage the list of mementos and doesn''t
    provide access to the internal state of the origin objects. This is also the class
    that the client code needs to access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateMemento`: This method is used to save the state of the originator. It
    creates a `Memento` object by saving the state variable into the `Memento` object
    and returns it. This is used to record the state of `Originator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetMemento`: This class stores the historical information of the `Originator`
    objects. The information is stored in its state variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance of `Caretaker` asks for a memento of the `originator` object by
    calling the `createMemento` method and saves it. In case of cancellation and going
    back to the saved state in the memento, you can send it to the `originator` object
    using the `setMemento` method.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have developed a platform game where each time your hero passes a level,
    a checkpoint is stored. This allows the player to reload from any level that he
    has already crossed.
  prefs: []
  type: TYPE_NORMAL
- en: The data that needs to be stored when saving the checkpoint are the level numbers,
    the current weapon, and the number of points.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simplify our code, we will use an OS X command line project, where we will
    write all our code in the `main.swift` file.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MementoPattern.xcodeproj` file in Xcode and let's see how we have
    organized our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we define our `GameState` structure: data that needs to be saved are
    `level`, `weapon`, and `points`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define our `Originator` with the `createMemento` and `setMemento` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement our `GameState Memento`: it contains all the information
    that `CheckPoint` needs to restore the state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define three variables that will help us to store states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entries` is a list of `GameState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nextId` contains the next index of the `entries` array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalPoints` is a variable that has the total points of each entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a constructor where we can pass a `CheckPoint` object as an argument.
    States of the checkpoint are assigned to the memento internal variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apply()` method receives a checkpoint object in the argument. Then, we
    assign the current memento values to the checkpoint properties in order to restore
    the checkpoint state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now save and restore a memento. The next thing to be done is to create
    our originator: the `CheckPoint` object. While playing the game, an entry will
    be added to the checkpoint entries list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the `Memento` object, we will define three variables. The difference
    being that we initialize them in this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entries`: This is an array that will contain all entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalPoints`: This is an integer initialized to `0` and it will contain the
    total of each level points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nextId`: This is an integer that starts from `0`. It contains the value of
    the next index in the `entries` array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addGameStateEntry`: This method is used to add a new entry to our entries
    list. This will be called by the client every time a level of our game is complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createMemento`: This method creates and return a memento object. The checkpoint
    itself is sent as an argument of the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setMemento`: This method allows us to restore a `Memento` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printCheckPoint`: This method is here to easily see what the current state
    of the `CheckPoint` object is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CheckPoint` class has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You have probably seen the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is how we can easily sort our array by index value. Then we can use the
    `map` function, only to be able to execute the print statement on each entry of
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see more information about closures to the following URL at: [https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our pattern is now in place, let''s have a look at how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After initializing a checkpoint object, we add two entries to the checkpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'After calling the `printCheckPoint` method of the `checkpoint` object: we obtain
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `printCheckPoint` method iterates over all the entries of the checkpoint
    object and displays the state of each one and the total points of the entries.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, we have still not created a `Memento` object, so we cannot restore
    a previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a memento, we only have to call the `createMemento` method of the
    `Originator` object (in our case the `checkPoint` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This method returns a memento object that we assign to our memento constant,
    so that we can restore when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue the game and pass two others levels successfully and print the
    current checkpoint state once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `CheckPoint` now contains four entries in its array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to restore our checkpoint state to the last saved state. To proceed,
    we only need to call the `setMemento()`method of the checkpoint object with the
    memento object we previously have created and make a call to the `printCheckPoint`
    method to display the result, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `printCheckPoint` call is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the checkpoint object has been restored to its previous state.
  prefs: []
  type: TYPE_NORMAL
- en: With this simple example, you should now have a good pattern to use and easily
    manage cancellation and restoration of an object.
  prefs: []
  type: TYPE_NORMAL
- en: The memento pattern is a pattern that is extensively used in scientific computing
    to save the state of long-running computations. As seen here, it may be used to
    save the state of play over a matter of hours or days. In the graphics toolkit,
    it may be used to preserve the state of a display while the objects are being
    moved around.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use this pattern when:'
  prefs: []
  type: TYPE_NORMAL
- en: An object's state must be saved to be restored later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's undesirable to expose the state directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the three patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though they seem dissimilar, there are several ways in which we can compare
    these three patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusability**: All three patterns aim to relieve the developer of implementing
    a common code repeatedly. Indeed, once the visitor has been implemented, they
    can be reused with different types of objects without any changes. To facilitate
    the reuse, you must limit the number of states the visitor needs to be aware of.
    The interpreter pattern is designed to parse an input where the structure is data
    driven. The `Caretaker` and memento classes of the `Memento` pattern are independent
    of the data, only the originator should be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with structure**: These patterns are intended to work with structures.
    Visitor and interpreter require the developer to write traversing codes whereas
    the memento pattern moves the structure as a whole, relying on the serialization
    to do the traversing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects as argument**: In the memento and visitor patterns, objects are passed
    around as a part of their structure, while in the interpreter pattern it relies
    on a context that is basically the evolving state of the input that is being interpreted
    to output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concludes the discovery of the eight behavioral patterns, as described
    by the gang of four. Moreover, this chapter concludes the book.
  prefs: []
  type: TYPE_NORMAL
- en: I wanted the book to be really easy to follow without adding complexity in the
    sample provided. This book is intended to be a reference for anyone who wants
    to implement design patterns with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: There are some points that we have not covered, such as multi-concurrency access,
    Swift 2 special coding with closure, and so on. I think that these points don't
    occur in a learning book. The main purpose of the book is to easily find the appropriate
    pattern when needed and have an easy illustration to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Well, you now have all the necessary information to structure your code in a
    scalable way. This will help you to structure your code properly, increase the
    performance of your code, and reduce maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: I really thank you to have followed the book. Now, it's up to you to put this
    knowledge into practice.
  prefs: []
  type: TYPE_NORMAL
