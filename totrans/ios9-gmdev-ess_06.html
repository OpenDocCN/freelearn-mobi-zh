<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. GameplayKit</h1></div></div></div><p class="calibre8">For many years, video game development has relied on the tenets of <strong class="calibre9">object-oriented design</strong> (<strong class="calibre9">OOD</strong>). Of the <a id="id284" class="calibre1"/>core features in OOD, the concepts of inheritance and polymorphism have been the most useful in this branch of software engineering. It makes sense to think of entities in our games as homogenous groups of objects; objects that we then write rules for in how they interact with each other. For example, thanks to inheritance, all objects in our game can be given the class name of <code class="email">GameObject</code>; they have functions we'll use throughout the game and then we can branch them off into child classes, such as <code class="email">Player</code> or <code class="email">Enemy</code>. We can then continue that thought process as we come up with more specific types of entities, be they objects such as <code class="email">Player</code>, different enemies, <strong class="calibre9">non-player characters</strong> (<strong class="calibre9">NPCs</strong>), or whatever makes sense for the <a id="id285" class="calibre1"/>game we are making. Calling a function on those objects, such as <code class="email">Shoot()</code> or <code class="email">Health()</code>, could be unique for each child of the parent class and thus we make use of polymorphism in OOD.</p><p class="calibre8">However, as mentioned in the previous chapter, although inheritance-based structuring is great for most software applications (including simple games), the unique needs and pairings of video game rules and entities cause inheritance-based structuring to break one of the rules of OOP. That rule is the reusability of our code. The solution to that problem is to separate the game objects and the game's rules into what's known as component-based structuring. Building games with this mentality can allow us to build unique objects, actions, and rules with the ability to not only shift them around throughout our single game project, but also to use them in other projects, cutting the overly customized structuring in which building a game via inheritance-based structuring can cause.</p><p class="calibre8">Apple's solution to this issue is the GameplayKit framework. GameplayKit is a completely independent framework that can be used with both SpriteKit or SceneKit games, as well as games written in low-level APIs, such as OpenGL and Metal. First announced for iOS 9 and Xcode 7 at <em class="calibre10">WWDC15</em>, GameplayKit takes the common methodologies and concepts used in game development for years and allows us to work on those aspects independently of what is being drawn on the screen. This framework doesn't handle what's drawn on the screen and is, thus, made specifically for the Model portion of MVC.</p><p class="calibre8">There are several game development concepts handled by GameplayKit, which we shall review in this chapter. These concepts are <strong class="calibre9">entities and components</strong>, <strong class="calibre9">state machines</strong>, <strong class="calibre9">agents</strong>, <strong class="calibre9">goals</strong>, <strong class="calibre9">behaviors</strong>, pathfinding, MinMaxAI, random sources, and rule systems.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec41" class="calibre1"/>Entities and components</h1></div></div></div><p class="calibre8">We can think of <a id="id286" class="calibre1"/>entities as the objects in our game. They can be the player, an enemy character, an NPC, level decorations and backgrounds, or even the UI used to inform the player of their lives, power, and other stats. The entity is thought of as a container of <a id="id287" class="calibre1"/>components. Components are behaviors that dictate the appearance and actions of an entity. One might ask, "how is this any different from objects and functions?" The short answer is that objects and functions in inheritance-based design describe more of what our game objects are, while working with component-based structuring focuses more on what they do. As we deal with the classes and functionality of the GameplayKit framework, we will be able to get a better handle on this. In this framework, we'll see that entities and components are handled with the <code class="email">GKEntity</code> and <code class="email">GKComponent</code> classes, respectively.</p><div><h3 class="title2"><a id="note34" class="calibre1"/>Note</h3><p class="calibre8">If you are still a bit confused about component-based structuring, check back in our previous chapter where we went into this in a bit more detail. You can also visit the developer page <a id="id288" class="calibre1"/>about this design methodology here: <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/EntityComponent.html">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/EntityComponent.html</a>.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec52" class="calibre1"/>Using GKEntity and GKComponent objects in our games</h2></div></div></div><p class="calibre8">Anyone <a id="id289" class="calibre1"/>familiar with Java or C# will understand the <a id="id290" class="calibre1"/>concept of an <em class="calibre10">abstract</em> class. The <code class="email">GKComponent</code> class is essentially an abstract class. Quoting from the speakers at WWDC: think of components as "little black boxes of functionality." Objects of the class <code class="email">GKEntity</code> are like our generic <code class="email">GameObject</code> class mentioned before. However, unlike the objects we've dealt with before, we typically don't add too much in the way of custom functionality to them (otherwise, we'd be leaning towards inheritance-based structuring).</p><p class="calibre8">We first create a game object and subclass it as a member of the <code class="email">GKEntity</code> type. For this example, let's just call our object class <code class="email">GameEntity</code>. Also, don't forget to import the GameplayKit API:</p><div><pre class="programlisting">import GameplayKit
class GameEntity : GKEntity</pre></div><pre>WWDC15</em> conference, in both Objective-C and Swift, showing how we'd create entities, components, and component systems in our projects:</pre><div><pre class="programlisting">//Objective-C
/* Make our archer */
GKEntity *archer = [GKEntity entity];
/* Archers can move, shoot, be targeted */
[archer addComponent: [MoveComponent component]];
[archer addComponent: [ShootComponent component]];
[archer addComponent: [TargetComponent component]];
/* Create MoveComponentSystem */
GKComponentSystem *moveSystem =
          [GKComponentSystem systemWithComponentClass:MoveComponent.class];
/* Add archer's MoveComponent to the system */
[moveSystem addComponent: [archer componentForClass:MoveComponent.class]];

//Swift
/* Make our archer */
let archer = GKEntity()
/* Archers can move, shoot, be targeted */
let moveComponent = MoveComponent()
let shootComponent = ShootComponent()
let targetComponent = TargetComponent()

archer.addComponent(moveComponent)
archer.addComponent(shootComponent)
archer.addComponent(targetComponent)

/* Create MoveComponentSystem */
let moveComponentSystem = GKComponentSystem(componentClass: MoveComponent.self)

/* Add archer's MoveComponent to the system */   moveComponentSystem.addComponent(archer.componentForClass(MoveComponent.self)!)</pre></div><p class="calibre8">What this code does is create our <code class="email">GKEntity</code> objects; in this case, the tower game example's archer <a id="id295" class="calibre1"/>character. Next it adds predefined <code class="email">GKComponent</code> objects via the <code class="email">addComponent(_:)</code> function. We also create a <code class="email">GKComponentSystem</code> object named <code class="email">moveComponentSystem</code> that will be used to update only movement <a id="id296" class="calibre1"/>type components. The archer's own <code class="email">moveComponent</code> class is added to this system with <code class="email">moveComponentSystem.addComponent(_:)</code>. Make a note of how the parameters passed through this object in addition to its initialization are class types of the component types denoted by the <code class="email">.class</code> or <code class="email">.self</code> properties, depending on which language we are writing our code in.</p><div><h3 class="title2"><a id="note35" class="calibre1"/>Note</h3><p class="calibre8">As of this publication, the <code class="email">componentForClass()</code> function might not be fully functional for the Swift programming language. So if the Swift implementation isn't working as expected for this and other GameplayKit object initializations, the Objective-C version of this code will need to be used and linked to your project via an Objective-C–Swift bridging file. This will more than likely be ironed out in future updates to Swift as Apple continues to move away from Objective-C <a id="id297" class="calibre1"/>as the main language of the platform. For more <a id="id298" class="calibre1"/>information on how to make this bridging file, check out this link: <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html</a>.</p></div><p class="calibre8">Apple provides us with a project named <code class="email">Maze</code> that uses these classes as well as some other concepts we'll be going over shortly.</p><p class="calibre8">Here's a link to the <a id="id299" class="calibre1"/>project that could help to give you an even better idea of entities and <a id="id300" class="calibre1"/>components:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/sample-code/wwdc/2015/downloads/Maze.zip">https://developer.apple.com/sample-code/wwdc/2015/downloads/Maze.zip</a>
</p><p class="calibre8">Before we go over more specific code use related to <code class="email">GKEntity</code> and <code class="email">GKComponent</code> objects, we'll look <a id="id301" class="calibre1"/>into a game development concept that is best coupled <a id="id302" class="calibre1"/>with these objects, which is the concept of <strong class="calibre9">state machines</strong>.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec42" class="calibre1"/>State machines</h1></div></div></div><p class="calibre8">A video game, more <a id="id303" class="calibre1"/>than any other type of application, bases much of its logic on whether the game or entities in that game are currently in one of a number of different states. </p><p class="calibre8">This could be checking whether the game is in the <em class="calibre10">intro</em> scene, running in the main gameplay mode, the player has died, the player is idle, a boss enemy has appeared, the game is over, the stage is over, the boss is low on health, and much more.</p><div><img src="img/00062.jpeg" alt="State machines" class="calibre11"/><div><p class="calibre15">An example of state machines for either AI or character animations</p></div></div><p class="calibre12"> </p><p class="calibre8">In the past, it has always been common practice for game developers to write their own custom state machine logic from scratch and then use the update/render cycle to check on these various states. Typically this would be done in a custom class or simply in a custom-made enum object that will shift through various states, such as <code class="email">.GameOver</code>, <code class="email">.MainGame</code>, <code class="email">.LowHealth</code>, and so on. These states could also describe the status of an individual entity in our <a id="id304" class="calibre1"/>game and dictate which animation cycle to run. For example, the player could be charging their attack and we'd want to use that state of the player to animate the charging animation. Objects in the game scene might check back on such states via switch statements to make sure that they are not doing any action that wouldn't make sense based on the context of the state. It wasn't too long before multiplatform game engines made this a part of the workflow, particularly in the animation handlers. These objects that let us inform the game and entities in the game of the various states are known as state machines. GameplayKit allows us to work with this concept in conjunction with its component/entity functionality. The framework provides the abstract class <code class="email">GKState</code> for us to subclass from for our game's states, and the class <code class="email">GKStateMachine</code> to utilize for placing these state objects into a designated state machine. An object of the type <code class="email">GKStateMachine</code> can only be in one state at a time, so it gives us a better way to use and reuse these states, as opposed to the old boilerplate/switch statement methodology.</p><p class="calibre8">The previous diagram is from <em class="calibre10">WWDC15</em> and uses an example of what a PacMan-like ghost character's, or any other game character's, animation and AI state machines would look like. Also note that not all paths could lead to each other. For example, the ghost can switch back and forth between chasing and fleeing, but can neither be defeated while chasing nor could it respawn unless it was previously in the defeated state. These are known as state transitions or edges in a state machine.</p><p class="calibre8">By default, all edges are <a id="id305" class="calibre1"/>valid and we override the <code class="email">isValidNextState(_:)</code> function in our <code class="email">GKState</code> objects/components to tell the state machine if we are allowed to move between certain states.</p><p class="calibre8">Here's how this is done <a id="id306" class="calibre1"/>in the DemoBots sample program's <code class="email">TaskBotAgentControlledState</code> class. DemoBots is the iOS 9 SpriteKit demo mentioned in <a class="calibre1" title="Chapter 3. SpriteKit and 2D Game Design" href="part0033_split_000.html#VF2I1-d06b23b4a4554b3182353558917969c2">Chapter 3</a>, <em class="calibre10">SpriteKit and 2D Game Design</em>:</p><div><pre class="programlisting">override func isValidNextState(stateClass: AnyClass) -&gt; Bool {
        switch stateClass {
            case is FlyingBotPreAttackState.Type, is GroundBotRotateToAttackState.Type, is TaskBotZappedState.Type:
                return true
            default:
                return false
        }
    }</pre></div><pre>GKState</code> objects to them:</pre><div><pre class="programlisting">/* Make some states - Chase, Flee, Defeated, Respawn */
let chase = ChaseState()
let flee  = FleeState()
let defeated = DefeatedState()
let respawn  = RespawnState()
/* Create a state machine */
let stateMachine = GKStateMachine(states: [chase,flee,defeated,respawn])
/* Enter our initial state - Chase */
stateMachine.enterState(chase.classForCoder)</pre></div><p class="calibre8">In the preceding code, we see the states created from the premade classes of <code class="email">GKState</code> (chase, flee, defeated, and respawn). The <code class="email">stateMachine</code> object, at initialization, receives a parameter of an array of <code class="email">GKState</code> objects, as shown in: <code class="email">let stateMachine = GKStateMachine(states: [chase,flee,defeated,respawn])</code>. Then, in this example, we start that state machine at the state <code class="email">chase</code>. This, of course, will be different based on the logic of your own game's components. <code class="email">GKStateMachine</code> objects can also return the <code class="email">currentState()</code> function; thus, we can guide various entities and components in our game based on the current pulse of the game's objects.</p><p class="calibre8">Find out more on <a id="id309" class="calibre1"/><code class="email">GKState</code> and <code class="email">GKStateMachine</code> in the following full <a id="id310" class="calibre1"/>documentation:</p><div><ul class="itemizedlist"><li class="listitem"><a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKState_Class/">https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKState_Class/</a></li><li class="listitem"><a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKStateMachine_Class/index.html#//apple_ref/occ/instm/GKStateMachine/canEnterState">https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKStateMachine_Class/index.html#//apple_ref/occ/instm/GKStateMachine/canEnterState</a></li></ul></div><p class="calibre8">Next we go over <a id="id311" class="calibre1"/>agents, goals, and behaviors.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec53" class="calibre1"/>Agents, goals, and behaviors</h2></div></div></div><p class="calibre8">When we make entities in our games, particularly those that are not the player, we want them to perform various actions. These actions are dictated by <strong class="calibre9">artificial intelligence</strong> (<strong class="calibre9">AI</strong>) that we give them, <a id="id312" class="calibre1"/>and are based on various states of the game, the player, the environment, or the player themselves. We can have a group of enemies follow a certain path, track the player, or automatically move smoothly around obstacles using our game's physical world. The framework allows us to make our game entities be what's known <a id="id313" class="calibre1"/>as <strong class="calibre9">agents</strong>. Agents are entities that can have goals and behaviors attached to them.</p><p class="calibre8">Agents in GameplayKit, which utilize the <code class="email">GKAgent</code> class, can have <code class="email">GKComponent</code> objects that automatically set various behaviors and are based on the weight of their goals. The weight of a goal is usually a float from <code class="email">0</code> to <code class="email">1</code>. The higher the goal's weight value is compared with other goals, the greater the chance that the agent will perform those behaviors. For example, if an enemy character is low on health, we'd probably want their <code class="email">Heal</code> goal to have a higher goal weight. The enemy will behave in a fashion that shows the urgency of that current low health situation by healing more often and thus giving the player a more challenging and intelligent opponent. In other words, agents, goals, and behaviors are a stackable and malleable AI system.</p><p class="calibre8">Here's an overview of <a id="id314" class="calibre1"/>this functionality in GameplayKit:</p><div><img src="img/00064.jpeg" alt="Agents, goals, and behaviors" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">A behavior, via the <code class="email">GKBehavior</code> class, is made of an array of <code class="email">GKGoal</code> objects that are each given a certain weight. For <a id="id315" class="calibre1"/>example, we could have a <code class="email">GKBehavior</code> class for an NPC in a racing game named <code class="email">RacingBehavior</code>. That behavior would be a combination of two goals, such as <code class="email">FollowPath</code> and <code class="email">AvoidAgents</code>. Together those goals would make a character in our game that will automatically move away from other NPCs while staying on the current track for the stage we are in. </p><p class="calibre8">Here's a visual representation of these classes:</p><div><img src="img/00065.jpeg" alt="Agents, goals, and behaviors" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">A <code class="email">GKAgent</code> object, as we can see in the preceding image, has a number of physics-based properties, such as <code class="email">mass</code>, <code class="email">radius</code>, <code class="email">maxSpeed</code>, and more. Like other GameplayKit objects, it utilizes the <code class="email">updateWithDeltaTime()</code> function to sync with the render/game loop updates of either <code class="email">GKComponentSystem</code> or <code class="email">GKEntity</code>. Are you starting to see a pattern here with these objects? In a way, we can also think of a <code class="email">GKAgent</code> object being similar to a SpriteKit or a SceneKit node since they work on our game's physics. However, whether we made our game with SpriteKit, SceneKit, or our own custom render components, such as in OpenGL or Metal, we need to <a id="id316" class="calibre1"/>link up these classes to what's displayed on the screen with the special <code class="email">GKAgentDelegate</code> class. Here's a diagram of that class and its functions:</p><div><img src="img/00066.jpeg" alt="Agents, goals, and behaviors" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The <code class="email">agentWillUpdate()</code> function is what we use to tell the agent what to do just before the game's <code class="email">update()</code> function, and the <code class="email">agentDidUpdate()</code> function is what we use to tell the agent what to do on screen after the <code class="email">update()</code> function. This can be, in the case of a <code class="email">Follow GKGoal</code> object, having a reference to the player's position on the screen before the update takes place. Here's the example of this from <em class="calibre10">WWDC15</em>, but written in Swift as opposed to the Objective-C example that was given:</p><div><pre class="programlisting">func agentWillUpdate(agent:GKAgent)
{
   /* Position the agent to match our sprite */
    agent.position = self.position
    agent.rotation = self.zRotation
}
func agentDidUpdate(agent:GKAgent)
{
   /* Position the sprite to match our agent */
    self.position = agent.position
    self.zRotation = agent.zRotation
}</pre></div><pre>TaskBotBehavior.swift</code> class, which is a child of <code class="email">GKBehavior</code>:</pre><div><pre class="programlisting">//(1)
let separationGoal = GKGoal(toSeparateFromAgents: agentsToFlockWith, maxDistance: 
GameplayConfiguration.Flocking.separationRadius, maxAngle: GameplayConfiguration.Flocking.separationAngle)
//(2)
behavior.setWeight(GameplayConfiguration.Flocking.separationWeight, forGoal: separationGoal)</pre></div><p class="calibre8">In line <code class="email">(1),</code> the <code class="email">toSeparateFromAgents</code> parameter of <code class="email">GKGoal</code> lets us pass a reference for the <code class="email">GKAgent</code> objects we wish to keep a certain distance from.</p><p class="calibre8">In line <code class="email">(2)</code>, the <code class="email">behavior.setWeight()</code> function passes the predetermined float <code class="email">GameplayConfiguration.Flocking.separationWeight</code> as the weight for this very goal. The higher the weight, the more priority is put on that goal.</p><p class="calibre8">You'll notice from the full documentation of <code class="email">GKGoal</code> linked to later that much of the <code class="email">GKGoal</code> class deals with the attraction or repulsion agents have to each other. Combining different characteristics <a id="id317" class="calibre1"/>of this basic functionality lets us create unique goals that <a id="id318" class="calibre1"/><code class="email">GKAgent</code> parameters get, as shown here: <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKGoal_Class/index.html">https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKGoal_Class/index.html</a>.</p><p class="calibre8">To backtrack a bit, here is a more basic way we can create these objects, as shown at the conference both in Objective-C and Swift.</p><div><pre class="programlisting">//Objective-C
/* Make some goals, we want to seek the enemy, avoid obstacles, target speed */
GKGoal *seek = [GKGoal goalToSeekAgent:enemyAgent];
GKGoal *avoid = [GKGoal goalToAvoidObstacles:obstacles];
GKGoal *targetSpeed = [GKGoal goalToReachTargetSpeed:50.0f];
/* Combine goals into behavior */
GKBehavior *behavior = [GKBehavior behaviorWithGoals:@[seek,avoid,targetSpeed]
  andWeights:@[@1.0,@5.0,@0.5]];
/* Make an agent - add the behavior to it */
GKAgent2D *agent = [[GKAgent2D* alloc] init];
agent.behavior = behavior;

//Swift
/* Make some goals, we want to seek the enemy, avoid obstacles, target speed */
let seek  = GKGoal(toSeekAgent: enemyAgent)
let avoid = GKGoal(toAvoidObstacles: obstacles, maxPredictionTime: 0.5)
let targetSpeed = GKGoal(toReachTargetSpeed: 50.0)
/* Combine goals into behavior */
let behavior = GKBehavior(goals: [seek, avoid, targetSpeed], andWeights: [1.0, 5.0, 0.5])
/* Make an agent - add the behavior to it */
let agent = GKAgent2D()
agent.behavior = behavior</pre></div><p class="calibre8">We see in the preceding code that when we create goals we assign agents to them that we are either seeking or avoiding. Goals on agents can have a target speed, as seen with the <code class="email">toReachTargetSpeed:</code> parameter, and these can all be bundled up into the current behavior with set weights given to them.</p><p class="calibre8">Here's more <a id="id319" class="calibre1"/>documentation on <code class="email">GKGoal</code>, <code class="email">GKAgent</code>, <code class="email">GKAgentDelegate</code>, and <code class="email">GKBehavior</code>:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Agent.html">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Agent.html</a>
</p><p class="calibre8">One other thing to note is that the obstacles array reference passed here is part of the <code class="email">GKObstacle</code> class. This class references objects on the scene that we tell agents to usually avoid when moving across the screen, and are part of our next topic, <strong class="calibre9">Pathfinding</strong>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec54" class="calibre1"/>Pathfinding</h2></div></div></div><p class="calibre8">Navigation is an <a id="id320" class="calibre1"/>integral part of most games. We could have an overworld scene in our game showing the various levels traversed or yet to be visited, with branching pathways to each point, or we could have a 3D action platformer with a spell that points out a logical path to our next quest or battle location. We can also see pathfinding in top-down isometric games. For instance, the player could be fighting off a hoard of enemies all locked on the player's location on the screen. Good pathfinding AI would not only tell the enemies to move toward their goal, but to dynamically avoid any impassable objects in their way and detour to a better route automatically . In our talk on agents, goals, and behaviors, we somewhat covered that. Behaviors, which <code class="email">GKAgent</code> objects adhere to, sync with various game physics and thus create smooth AI movements to change with other agents/objects in the scene. However, it would be great to also be able to inform these components where they can and can't traverse in a scene, and that's where pathfinding comes in.</p><div><img src="img/00067.jpeg" alt="Pathfinding" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The preceding diagram shows what Pathfinding is and is an in-game visual given to us by Apple during the <em class="calibre10">WWDC15</em> conference. It can be broken down as follows:</p><div><ul class="itemizedlist"><li class="listitem">Pathfinding involves nodes with transversal paths to and from those nodes in what's known as a <a id="id321" class="calibre1"/><strong class="calibre9">navigation graph</strong>.</li><li class="listitem">These nodes can be single directional or bidirectional and, most importantly, there can be a path calculated with this graph that represents the best path a <code class="email">GKAgent</code> can take.</li><li class="listitem">The squares shown in the earlier scene represent <code class="email">GKObstacle</code> objects that are placed in the scene (be it by code or visually in the Xcode editor's tools).</li></ul></div><p class="calibre8">Here's the full <a id="id322" class="calibre1"/>documentation for the <code class="email">GKObstacle</code> class:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKObstacle_Class/index.html">https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKObstacle_Class/index.html</a>
</p><p class="calibre8">Like other GameplayKit features, we use various abstract classes to child from for setting up the navigation graph and <a id="id323" class="calibre1"/>overall Pathfinding functionality; those classes are <code class="email">GKGraph</code>, <code class="email">GKGridGraph</code>, <code class="email">GKGridGraphNode</code>, and <code class="email">GKObstacleGraph</code>.</p><div><img src="img/00068.jpeg" alt="Pathfinding" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">It's not too foreboding when we see the preceding diagram of classes and go through them one by one. The main, and most common, class used id the <code class="email">GKGraph</code> class. This is where we can attach to it one of two different graph specification types: <code class="email">GKGridGraph</code> or <code class="email">GKObstacleGraph</code>. <code class="email">GKGraph</code> lets us add and remove nodes, connect them, and find the optimal path between nodes. Of the two specification types, <code class="email">GKGridGraph</code> has a simpler functionality that is meant for easy, 2D-based navigation graph creation, whereas <code class="email">GKObstacleGraph</code> lets us set up a navigation graph using <code class="email">GKObstacle</code> objects. Nodes are automatically created around those obstacles based on their shape, and these classes do much of the footwork needed to calculate the paths our agents need to take from the start to the finish of their set path(s). If we want to add even more functionality to our nodes, say if we want customized movement based on terrain type in addition to shape, then we could use the nodes of <code class="email">GridGraphNode</code>. </p><p class="calibre8">The <code class="email">costToNode()</code> function, for example, can be used to indicate that though this path would be the optimal path on a flat, even and similar type plane, it would cost more to traverse. For example, if there's quicksand in our game, the player could traverse it, so it wouldn't make sense to make an impassable <code class="email">GKObstacle</code> object over the quicksand. Instead we would say that the path across that terrain between the two nodes costs more. This will make our game's navigation smarter and will handle such custom parameters.</p><div><h3 class="title2"><a id="note36" class="calibre1"/>Note</h3><p class="calibre8">The <code class="email">costToNode()</code> function is actually an example of best practice. We can choose to not use it, but, if we are not careful, our game's pathfinding AI could end up rather unintuitive. This would not only make a poor experience for the player, but end up adding more time from debugging faulty AI actions later on.</p></div><p class="calibre8">Let's look at some code samples to get a better understanding of these classes and how to work with them. Do <a id="id324" class="calibre1"/>note that the code as of <em class="calibre10">WWDC15</em> is in Objective-C.</p><div><pre class="programlisting">/* Make an obstacle - a simple square */
vector_float2 points[] = {{400,400}, {500,400}, {500,500}, {400,500}};
GKPolygonObstacle *obstacle = [[GKPolygonObstacle alloc] initWithPoints:points count:4];
/* Make an obstacle graph */
GKObstacleGraph *graph = [GKObstacleGraph graphWithObstacles:@[obstacle] bufferRadius:10.0f];
/* Make nodes for hero position and destination */
GKGraphNode2D *startNode = [GKGraphNode2D nodeWithPoint:hero.position];
GKGraphNode2D *endNode = [GKGraphNode2D nodeWithPoint:goalPosition];
/* Connect start and end node to graph */
[graph connectNodeUsingObstacles:startNode];
[graph connectNodeUsingObstacles:endNode];
/* Find path from start to end */
NSArray *path = [graph findPathFromNode:startNode toNode:endNode];</pre></div><pre>GKObstacleGraph</code> by first manually creating 2D vector points in the points array and initializing the <code class="email">GKObstacleGraph</code> object and graph with those points. Next, the two <code class="email">GKGraphNode2D</code> objects are created to represent the start and end nodes for a hero character in the game. Then, finally, the optimal path for that hero character is created and stored into the array automatically; that is, a path using the graph's <code class="email">findpathFromNode:</code> and <code class="email">toNode:</code> parameters using the <code class="email">startNode</code> and <code class="email">endNode</code> objects, respectively. This path object can then be used in our hero's movement component or may be a map visual component to move to or indicate to the player the correct path needed to traverse the game stage's obstacles.</pre><p class="calibre8">The following code sample is how the DemoBots project worked with the navigation in Swift, using what's known as a lazy stored property.</p><p class="calibre8">More information on the Swift keyword, <code class="email">lazy</code>, can be found here:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html</a>
</p><p class="calibre8">Swift example from DemoBots:</p><div><pre class="programlisting">lazy var graph: GKObstacleGraph = GKObstacleGraph(obstacles: self.polygonObstacles, bufferRadius: GameplayConfiguration.TaskBot.pathfindingGraphBufferRadius)

lazy var obstacleSpriteNodes: [SKSpriteNode] = self["world/obstacles/*"] as! [SKSpriteNode]
/*the above line casts the obstacles in our project's "world/obstacles/" folder path as an implicitly unwrapped array of SKSpriteNodes
*/

lazy var polygonObstacles: [GKPolygonObstacle] = SKNode.obstaclesFromNodePhysicsBodies(self.obstacleSpriteNodes)</pre></div><p class="calibre8">In short, <code class="email">lazy</code> variables are quick array initializations in which their values are not known at first and are <a id="id325" class="calibre1"/>controlled by outside sources. In the case of DemoBots, these are obstacles that are created automatically from the bounds of SpriteKit nodes, which is done by the SpriteKit node function <code class="email">obstaclesFromNodePhysicsBodies()</code>. This example, just shows how much time can be saved when using the provided frameworks. In the first example and more so in past game development, much of this logic would have to be manually done via terribly complex boilerplate code logic.</p><p class="calibre8">For more information on <a id="id326" class="calibre1"/>Pathfinding with GameplayKit, check out the examples and documentation found here:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Pathfinding.html">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Pathfinding.html</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec55" class="calibre1"/>MinMaxAI</h2></div></div></div><p class="calibre8">So far, we've <a id="id327" class="calibre1"/>created AI that's great for the components and objects that are active in a scene with their movement, behaviors, and navigation, but what about AI that can understand the game's rules like the player? A good example of this is a game of chess or various other board/tile-like games. It'd be great to control how much the computer can make progress in the game with various levels of difficulty for the player. We can also want to let the game decide for us what the next best move is. Something like this is common in three-match type games, such as <strong class="calibre9">Bejeweled<sup class="calibre19">®</sup></strong> or <strong class="calibre9">CandyCrush<sup class="calibre19">®</sup>,</strong> in which you are looking at grid and the game gives you a hint. This type of logic is where <strong class="calibre9">MinMaxAI</strong> comes in.</p><div><img src="img/00069.jpeg" alt="MinMaxAI" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">MinMaxAI works by taking an inventory of all of the available moves for our game and placing them into a decision tree. Based on the parameters we give the AI, we can tell it how to choose these decision branches, typically in terms of game difficulty. This is done by taking in the players, a list of all their possible moves as well as their scores, and plugging them into a <code class="email">Game Model</code> protocol that then uses MinMaxAl to determine the best move. The Tic-Tac-Toe example from <em class="calibre10">WWDC15</em> is shown in the preceding diagram. Note how some branches would lead to more losses than draws or wins for the computer AI. A harder difficulty level would make the computer <em class="calibre10">player</em> choose the paths that more likely lead to a win for it, or, in the case of those three-match games, give the player a suggestion for the next best move.</p><p class="calibre8">Of course, as one might have guessed, this type of logic is best for turn-based or tile-based games. MinMaxAI <a id="id328" class="calibre1"/>can work in any game, but that game, or at least the implementation of MinMaxAI, will only work if there's a set base of moves and future moves for it to take into its <code class="email">Game Model</code> protocol. An action platformer, unless given some choice of features, wouldn't be able to use MinMaxAI, for example. What's great about this functionality in GameplayKit is that it doesn't need to know the details of your game's rules; it just needs the ability to look into future possible moves.</p><div><img src="img/00070.jpeg" alt="MinMaxAI" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The class diagram shows the classes and functions used when dealing with MinMaxAI. We see <code class="email">GKGameModel</code>, which is actually a protocol for a game state. The <code class="email">GKState</code> objects that adhere to this protocol need to provide a list of players, the active player, the player's score, and the player's list of moves, the latter via the <code class="email">gameModelUpdatesForPlayer()</code> function. We then tell the <code class="email">GKGameModel</code> object what to do as it moves on to the next game move with the <code class="email">applyGameModelUpdate()</code> function. <code class="email">GKGameModelUpdate</code> is essentially an abstract of a game's move and is used by the <code class="email">GKMinMaxStrategist</code> class to build a decision tree, which is thus applied to <code class="email">GKGameModel</code> to change that state in the <code class="email">setGameModel()</code> function.</p><p class="calibre8">The <code class="email">GKGameModelPlayer</code> class is a protocol for a player of the game who makes a move, as stated previously, with <code class="email">GKGameModelUpdate</code>. The <code class="email">playerId</code> property is a unique number you can set, which <a id="id329" class="calibre1"/>is used to differentiate the players in our game's logic and deal with their own set of moves. This allows the flexibility to have both a hinting structure for the player (or players in a multiplayer game) in addition to also having the computer player have an AI for its own moves. The <code class="email">playerID</code> property is required to adhere to this protocol as we wouldn't know the player we are referencing without it.</p><p class="calibre8">The <code class="email">GKMinMaxStrategist</code> class is the actual AI itself that is tied to the <code class="email">gameModel</code> property we created with the prior protocols. The <code class="email">maxLookAheadDepth</code> property is how many moves ahead the AI will look, the more the better and then it returns the best move via the <code class="email">bestMoveForPlayer()</code> function. We can use the <code class="email">randomMoveForPlayer()</code> function to add a bit of randomness to the next move choices; this could be used particularly for the computer's own AI to maybe purposely cause it to make mistakes by choosing a less optimal move.</p><p class="calibre8">A quick Objective-C snippet showing how to do this in code is given in the following code. Don't worry about the syntax if you are only familiar with the Swift language we've provided in this book; just get an idea on the basics for setting up these objects.</p><div><pre class="programlisting">/* ChessGameModel implements GKGameModel */
ChessGameModel *chessGameModel = [ChessGameModel new];
GKMinmaxStrategist *minmax = [GKMinmaxStrategist new];
minmax.gameModel = chessGameModel;
minmax.maxLookAheadDepth = 6;
/* Find the best move for the active player */
ChessGameUpdate *chessGameUpdate =
            [minmax bestMoveForPlayer:chessGameModel.activePlayer];
/* Apply update to the game model */
[chessGameModel applyGameModelUpdate:chessGameUpdate];</pre></div><p class="calibre8">This is also, like many of the code snippets in this chapter, taken from the <em class="calibre10">WWDC15</em> conference. It uses a chess game as an example. The intricate details of setting up a chess game model are a bit complex, so simply take note of how in this code a <code class="email">ChessGameModel</code> object (which is a child of the abstract <code class="email">GKGameModel</code> class) is first created. Then, we create an object of the <code class="email">GKMinMaxStrategist</code> class named <code class="email">minmax</code>, set its game model, set its <a id="id330" class="calibre1"/><code class="email">maxLookAheadDepth</code> property to <code class="email">6</code>, and pass the game's move and the current active player to the <code class="email">minMax</code> object. Finally, we update the game's model with the <code class="email">applyGameModelUpdate()</code> function. It's also done in Objective-C at the time of this publication, but check out the <code class="email">FourInaRow</code> demo found here: <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/samplecode/FourInARow/Introduction/Intro.html">https://developer.apple.com/library/prerelease/ios/samplecode/FourInARow/Introduction/Intro.html</a>.</p><p class="calibre8">This project will let us <a id="id331" class="calibre1"/>see a more complete implementation of this AI.</p><p class="calibre8">For even more on MinMaxAI, check out the following documentation link:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Minmax.html">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Minmax.html</a>.</p><p class="calibre8">Next we will talk about adding <em class="calibre10">controlled</em> randomness to our games with GameplayKit's random sources.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec56" class="calibre1"/>Random sources</h2></div></div></div><p class="calibre8">Randomness in <a id="id332" class="calibre1"/>games has been a staple of AI, player moves, level design, and game <em class="calibre10">replayability</em> since the early days of game development. The <code class="email">rand()</code> function in various programming languages, in addition to a range of numbers to scale that randomness, has typically been used to give our applications some less predictable outcomes. However, games sometimes need to have what we like to call <em class="calibre10">controlled</em> randomness. When debugging a game, we don't want to ever run into a problem where a shipped product has an untested state. Sometimes, when using past conventions of randomness, we can run into a situation where the only time some rare events happen may be after a game is out and in the hands of thousands, if not millions, of players who add to the testing pool that we didn't have in the developing phase. Therefore, we may want to control the distribution of randomness. In a typical random selection of outcomes, we get a bell curve of results where the average or middle-ranged outcomes will occur more often than fringe outcomes. This is fine in some games, but rather undesirable in others. Another bit about the <code class="email">rand()</code> function is that its randomness can vary based on other factors, such as the system it's on, the current date and time, and other uncontrollable factors. What we need, then, is platform-independent determinism and customizable distribution. With GameplayKit's random sources, we can accomplish that.</p><div><img src="img/00071.jpeg" alt="Random sources" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We see a number of the different classes we can use in the preceding image. The base class is <code class="email">GKRandomSource</code>, which actually uses the ARC4 type algorithm by default (via its <code class="email">GKARC4RandomSource</code> subclass). ARC4 is a quick/low overhead and has the typical randomness that we use in many instances. It's different from the <code class="email">arc4Random()</code> C call in which instances of <code class="email">GKARC4RandomSource</code> are independent from each other. <code class="email">GKRandomSource</code> can also become a subclass to either the Linear Congruential or the Mersenne Twister algorithms. Their benefits and disadvantages are shown in the diagram. </p><p class="calibre8">It's not recommended that these objects are used for cryptography, so it's best to use other the encryption / hashing frameworks that Apple recommends (<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html">https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html</a>).</p><p class="calibre8">The remaining classes give us control of the random number/outcome distribution methodologies. The <code class="email">GKRandDistribution</code> objects let us use helper methods that, for example, give us the ability to create x-sided die pieces in addition to letting us set its lowest and highest range values. The <code class="email">GKGaussianDistribution</code> and <code class="email">GKShuffledDistribution</code> classes also let us use those helper functions, but <code class="email">GKGaussianDistribution</code> is used when we want to have a bell-curve type randomization where the middle values happen more often than the fringe values. Its mean and deviation properties give us controls on that bell curve and if we maybe want more occurrences of fringe values. <code class="email">GKShuffledDistribution</code>, as we can tell from its name, is great for creating an even and complete range distribution, for shuffling decks of cards, or making sure that every value occurs evenly. This class's <code class="email">uniformDistance</code> property is a float between the values of <code class="email">0.0</code> and <code class="email">1.0</code>. At <code class="email">0.0</code>, all shuffling is completely random; at <code class="email">1.0</code>, the distribution of all values is even.</p><p class="calibre8">Adding random sources <a id="id333" class="calibre1"/>to our games is very simple. Here's some code examples using these classes:</p><div><pre class="programlisting">/* Create a six-sided die with its own random source */
let d6 = GKRandomDistribution.d6()
/* Get die value between 1 and 6 */
let choice = d6.nextInt()
/* Create a custom 256-sided die with its own random source */
let d256 = GKRandomDistribution.die(lowest:1, highest:256)
/* Get die value between 1 and 256 */
let choice = d256.nextInt()
/* Create a twenty-sided die with a bell curve bias */
let d20 = GKGaussianDistribution.d20()
/* Get die value between 1 and 20 that is most likely to be around 11 */
let choice = d20.nextInt()
/* Create a twenty-sided die with no clustered values — fair random */
let d20 = GKShuffledDistribution.d20()
/* Get die value between 1 and 20 */
let choice = d20.nextInt()
/* Get another die value that is not the same as 'choice' */
let secondChoice = d20.nextInt()

/* Make a deck of cards */
var deck = [Ace, King, Queen, Jack, Ten]
/* Shuffle them */
deck = GKRandomSource.sharedRandom().shuffle(deck)
/* possible result - [Jack, King, Ten, Queen, Ace] */
/* Get a random card from the deck */
let card = deck[0]</pre></div><p class="calibre8">As we can see, these are very quick, simple lines of code that all use the various random source classes. Most are simple property calls, so that when we create our objects in Swift, as seen in the preceding code, it just needs one or two lines of code to utilize these class types and their various randomization functionalities. Combining this to the goal weight of, say, a wander or track AI behavior, and we get some diverse and moderately controlled randomness for the objects and characters in our games.</p><p class="calibre8">To read up more on <a id="id334" class="calibre1"/>random sources/randomization in this framework, see the documentation link here:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec57" class="calibre1"/>Rule systems</h2></div></div></div><p class="calibre8">Last, but not least, we come to <a id="id335" class="calibre1"/>GameplayKit's rule systems. This aspect of the framework <a id="id336" class="calibre1"/>uses what's known as <strong class="calibre9">fuzzy logic</strong> or approximations, mainly in the context of transitions between game states. This isn't something all too new to game development. Anyone familiar with linear interpolation will be right at home as this is practically the same concept. Unlike the typical use of linear interpolation, which tends to revolve around transitions between physical actions, GameplayKit's rule systems perform these approximate transitions between various game states. Think of the objects/entities in our games as nouns, the components and actions as verbs, and these rules as the interactions between these verbs and nouns. As we've seen throughout this chapter, this would very much describe game states. So why add an extra layer to this logic? Well, let's look at this example from the GameplayKit <a id="id337" class="calibre1"/>announcement. This is where transitions between game states and/or entity-component actions could use this fuzzy logic:</p><div><pre class="programlisting">if (car.distance &lt; 5) {
  car.slowDown()
}
else if (car.distance &gt;= 5) {
  car.speedUp()
}</pre></div><p class="calibre8">This pseudo code could represent a car NPC in our game. Maybe a city building game, where there are various car <code class="email">GKAgent</code> objects that have this code as part of their behavior. This seems sound until we get to values at or near <code class="email">5</code>. What we might notice in our game are a bunch of NPC cars accelerating and braking in a jerky motion. To solve this, we make the transitions between braking and accelerating not be so finite, but instead transition in approximation.</p><div><img src="img/00072.jpeg" alt="Rule systems" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The preceding image is a better illustration of this, with the original logic on the left and fuzzy logic on the right. This creates a smooth transition between actions or states where rule systems come into play; here are the classes we use to implement this type of logic:</p><div><img src="img/00073.jpeg" alt="Rule systems" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We use the <code class="email">GKRuleSystem</code> and <code class="email">GKRule</code> class instances to utilize rule systems. <code class="email">GKRule</code> represents a specific decision to be made based on an external state, and <code class="email">GKRuleSystem</code> evaluates a set of rules against state data to determine a set of facts. We can assert facts or retract them, and we can grade the <em class="calibre10">fuzziness</em> factor between these rules.</p><p class="calibre8">Let's take a look at this in <a id="id338" class="calibre1"/>code to get a better feel for it:</p><div><pre class="programlisting">/* Make a rule system */
GKRuleSystem* sys = [[GKRuleSystem alloc] init];
/* Getting distance and asserting facts */
float distance = sys.state[@"distance"];
[sys assertFact:@"close" grade:1.0f - distance / kBrakingDistance];
[sys assertFact:@"far" grade:distance / kBrakingDistance];
/* Grade our facts - farness and closeness */
float farness = [sys gradeForFact@"far"];
float closeness = [sys gradeForFact@"close"];
/* Derive Fuzzy acceleration */
float fuzzyAcceleration = farness - closeness;
[car applyAcceleration:fuzzyAcceleration withDeltaTime:seconds];</pre></div><p class="calibre8">First, the <code class="email">sys</code> object of <code class="email">GKRuleSystem</code> is created, and we grab the <code class="email">distance</code> state value and save that to the <code class="email">distance</code> variable. We then assert/add a rule named <code class="email">close</code> that happens if <code class="email">1.0f - distance / kBrakingDistance</code>. The next finite rule we add is <code class="email">far</code>, which is defined as <code class="email">distance</code> / <code class="email">kBrakingDistance</code>, or basically any distance greater than <code class="email">1 - distance / kBrakingDistance</code>. We create new fuzzy values of <code class="email">close</code> and <code class="email">far</code>, named <code class="email">farness</code> and <code class="email">closeness</code>, that are based on the <code class="email">gradeForFact</code> property of <code class="email">GKRuleSystem</code>. Then, from this, we get our <code class="email">fuzzyAcceleration</code> value from the difference between <code class="email">farness</code> and <code class="email">closeness</code> and apply that acceleration to our car. This is checked during the update render cycle automatically and keeps the logic transitions smooth, removing jerky movements between the different states.</p><p class="calibre8">This simple example code from <em class="calibre10">WWDC15</em> is in Objective-C, but we can see more examples (some in Swift) in <a id="id339" class="calibre1"/>the full documentation page as follows:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html</a>
</p><p class="calibre8">We can also see some of this implemented in the demo projects we linked to previously.</p><p class="calibre8">With these classes, we can <a id="id340" class="calibre1"/>create a number of complex rule systems that transition in a more fluid fashion.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec43" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter has gone into a great deal of this deep and independent game-centric framework. We have first reviewed the basic concepts of entities and components, and how GameplayKit takes advantage of the component-based structuring. We then moved on to a staple of game development, the concept of state machines, and how GameplayKit utilizes them. Then, we have reviewed ways by which we can automatically control components and entities in our games with agents, goals, and behaviors, as well as Pathfinding's navigation graphs that add to this automation. We have learned that MinMaxAI lets us hint future moves to the player or give the computer a smart way of challenging us in various turn-based games. Finally, we have seen how random sources add controllable variety to outcomes in our games, whereas Rule systems can keep transitions of various states from being too finite. There's much more to GameplayKit than we could show here, so it's highly recommended that you read through some of the documentation links provided earlier to get an even better feel for what this framework has to offer. In the next chapter, we move on to the Metal API as well as some other tricks and tips that aid best in making the most out of your game and keeping your games at that all too crucial 60 fps.</p></div></body></html>