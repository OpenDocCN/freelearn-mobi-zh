<html><head></head><body>
  <div id="_idContainer060">
    <h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-159" class="chapterTitle">Classes, Structures, and Protocols</h1>
    <p class="normal">The first programming language that I learned was BASIC. It was a good language to begin programming with, but once I traded in my Commodore Vic-20 for a PCjr (yes, I had a PCjr and I really enjoyed it), I realized that there were other, more advanced languages out there, and I spent a lot of time learning Pascal and C. It wasn't until I started college that I heard the term <strong class="keyword">object-oriented programming language</strong>. At that time, object-oriented programming languages were so new that there were no real courses on them, but I was able to experiment a little with C++. After I graduated, I left object-oriented programming behind, and it really wasn't until several years later, when I started to experiment with C++ again, that I really discovered the power and flexibility of object-oriented programming. In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bullet">What are classes and structures?</li>
      <li class="bullet">How to add properties and property observers to classes and structures</li>
      <li class="bullet">How to add methods to classes and structures</li>
      <li class="bullet">How to add initializers to classes and structures</li>
      <li class="bullet">How and when to use access controls</li>
      <li class="bullet">How to create a class hierarchy</li>
      <li class="bullet">How to extend a class</li>
    </ul>
    <h1 id="_idParaDest-160" class="title">What are classes and structures?</h1>
    <p class="normal">In Swift, classes <a id="_idIndexMarker344"/>and structures are very similar. If we really want to master Swift, it is very important to not <a id="_idIndexMarker345"/>only understand what makes classes and structures so similar, but to also understand what sets them apart, because they are the building blocks of our applications. Apple describes them as follows:</p>
    <blockquote class="packt_quote">Classes and structures are general-purpose, flexible constructs that become the building blocks of your program's code. You define properties and methods to add functionality to your classes and structures by using the already familiar syntax of constants, variables, and functions.</blockquote>
    <p class="normal">Let's begin by<a id="_idIndexMarker346"/> taking a quick look at some of the similarities between classes and <a id="_idIndexMarker347"/>structures.</p>
    <h2 id="_idParaDest-161" class="title">Similarities between classes and structures</h2>
    <p class="normal">In Swift, classes and <a id="_idIndexMarker348"/>structures are more similar than they are in other languages, such as Objective-C. The following is a list of some of the features that<a id="_idIndexMarker349"/> classes and structures share:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Properties</strong>: These are used to store information in our classes and structures</li>
      <li class="bullet"><strong class="keyword">Methods</strong>: These provide functionality for our classes and structures</li>
      <li class="bullet"><strong class="keyword">Initializers</strong>: These are used when initializing instances of our classes and structures</li>
      <li class="bullet"><strong class="keyword">Subscripts</strong>: These provide access to values using the subscript syntax</li>
      <li class="bullet"><strong class="keyword">Extensions</strong>: These help extend both classes and structures</li>
    </ul>
    <p class="normal">Now, let's take a quick look at some of the differences between classes and structures.</p>
    <h2 id="_idParaDest-162" class="title">Differences between classes and structures</h2>
    <p class="normal">While classes and structures are<a id="_idIndexMarker350"/> very similar, there are also several very important differences. The following is a list of some of the differences between classes<a id="_idIndexMarker351"/> and structures in Swift:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Type</strong>: A structure is a value type, while a class is a reference type </li>
      <li class="bullet"><strong class="keyword">Inheritance</strong>: A structure cannot inherit from other types, while a class can </li>
      <li class="bullet"><strong class="keyword">Deinitializers</strong>: Structures cannot have custom deinitializers, while a class can</li>
    </ul>
    <p class="normal">Throughout this chapter, we will be emphasizing the differences between classes and structures to help us understand when to use each. Before we really dive into classes and structures, let's look at the difference between value types (structures) and reference types (classes). To fully understand when to use classes and structures and how to properly use them, it is important to understand the difference between value and reference types.</p>
    <h1 id="_idParaDest-163" class="title">Value versus reference types</h1>
    <p class="normal">Structures are value<a id="_idIndexMarker352"/> types. When we pass instances of a structure within our application, we pass a copy of the structure and not the original structure. Classes are reference types; therefore, when we pass an instance of a class within our application, a reference to the original instance is passed. It is very important to understand this difference. We will give a very high-level view here and will provide additional details in <em class="chapterRef">Chapter 18</em>,<em class="italic"> Memory Management</em>. When we pass structures within our application, we are passing copies of the structures and not the original structures. Since the function gets its own copy of the structure, it can change it as needed without affecting the original instance of the structure. When we pass an instance of a class within our application, we are passing a reference to the original instance of the class. Since we're passing the instance of the class to the function, the function is getting a reference to the original instance; therefore, any changes made within the function will remain once the function exits. To illustrate the difference between value and reference types, let's look at a real-world object: a book. If we have a friend who wants to read <em class="italic">Mastering Swift 5.3</em>, we could either buy them their own copy or share ours. If we bought our friend their own copy of the book, any notes they made within the book would remain in their copy of the book and would not be reflected in our copy. This is how passing by value works with structures and variables. Any changes that are made to the structure or variable within the function are not reflected in the original instance of the structure or variable. If we share our copy of the book, any notes they made within the book would stay in the book when they return it to us. This is how passing by reference works. Any changes that are made to the instance of the class remain when the function exits.</p>
    <h1 id="_idParaDest-164" class="title">Creating a class or structure</h1>
    <p class="normal">We use the same syntax to define <a id="_idIndexMarker353"/>classes and structures. The only difference is that we<a id="_idIndexMarker354"/> define a class using the <code class="Code-In-Text--PACKT-">class</code> keyword and a structure using the <code class="Code-In-Text--PACKT-">struct</code> keyword. </p>
    <p class="normal">Let's look at the syntax that's used to create both classes and structures:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass</span><span class="hljs-class"> </span>{
<span class="hljs-comment">    // MyClass definition</span>
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MyStruct</span><span class="hljs-class"> </span>{
<span class="hljs-comment">    // MyStruct definition</span>
}
</code></pre>
    <p class="normal">In the preceding code, we define a new class named <code class="Code-In-Text--PACKT-">MyClass</code> and a new structure named <code class="Code-In-Text--PACKT-">MyStruct</code>. This effectively creates two new Swift types, named <code class="Code-In-Text--PACKT-">MyClass</code> and <code class="Code-In-Text--PACKT-">MyStruct</code>. When we name a new type, we want to use the standard naming convention set by Swift, where the name is in camel case, with the first letter being uppercase. This is also<a id="_idIndexMarker355"/> known as <code class="Code-In-Text--PACKT-">PascalCase</code>. Any method or property defined within the class <a id="_idIndexMarker356"/>or structure should also be named using camel case, with the first letter being uppercase. Empty classes and structures are not that useful, so let's look at how we can add properties to our classes and structures.</p>
    <h1 id="_idParaDest-165" class="title">Properties</h1>
    <p class="normal">Properties associate values with a class or a structure. There are two types of properties:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Stored properties</strong>: These will store variable or constant values as part of an instance of a class or structure. Stored <a id="_idIndexMarker357"/>properties can<a id="_idIndexMarker358"/> also have property observers that can monitor the property for changes and respond with custom actions when the value of the property changes.</li>
      <li class="bullet"><strong class="keyword">Computed properties</strong>: These do<a id="_idIndexMarker359"/> not store a value themselves but instead retrieve and possibly set other properties. The value<a id="_idIndexMarker360"/> returned by a computed property can also be calculated when it is requested.</li>
    </ul>
    <h2 id="_idParaDest-166" class="title">Stored properties</h2>
    <p class="normal">A stored property is a variable or constant that is<a id="_idIndexMarker361"/> stored as part of an instance of a class or structure. These are defined with the <code class="Code-In-Text--PACKT-">var</code> and <code class="Code-In-Text--PACKT-">let</code> keywords, just like normal variables and constants. In the following code, we will create a structure named <code class="Code-In-Text--PACKT-">MyStruct</code> and a class named <code class="Code-In-Text--PACKT-">MyClass</code>. The structure and the class both contain two stored properties, <code class="Code-In-Text--PACKT-">c</code> and <code class="Code-In-Text--PACKT-">v</code>. The stored property, <code class="Code-In-Text--PACKT-">c</code>, is a constant because it is defined with the <code class="Code-In-Text--PACKT-">let</code> keyword, and <code class="Code-In-Text--PACKT-">v</code> is a variable because it is defined with the <code class="Code-In-Text--PACKT-">var</code> keyword. Let's look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MyStruct</span>
{ 
    <span class="hljs-keyword">let</span> <span class="hljs-built_i">c</span> = <span class="hljs-number">5</span>
    <span class="hljs-keyword">var</span> v = <span class="hljs-string">""</span>
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass</span><span class="hljs-class"> </span>
{ 
    <span class="hljs-keyword">let</span> <span class="hljs-built_i">c</span> = <span class="hljs-number">5</span> 
    <span class="hljs-keyword">var</span> v = <span class="hljs-string">""</span>
}
</code></pre>
    <p class="normal">As we can see from the preceding example, the syntax to define a stored property is the same for both classes and structures. Let's look at how we would create an instance of both the structure and class. The following code creates an instance of the <code class="Code-In-Text--PACKT-">MyStruct</code> structure, named <code class="Code-In-Text--PACKT-">myStruct</code>, and an instance of the <code class="Code-In-Text--PACKT-">MyClass</code> class, named <code class="Code-In-Text--PACKT-">myClass</code>:</p>
    <p class="normal">One of the<a id="_idIndexMarker362"/> differences between structures and classes is that, by default, a structure creates an initializer that lets us populate the stored properties when we create an instance of the structure. Therefore, we could also create an instance of <code class="Code-In-Text--PACKT-">MyStruct</code> like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myStruct = <span class="hljs-type">MyStruct</span>(v: <span class="hljs-string">"Hello"</span>)
</code></pre>
    <p class="normal">In the preceding example, the initializer is used to set the <code class="Code-In-Text--PACKT-">v</code> variable, and the <code class="Code-In-Text--PACKT-">c</code> constant will still contain the number <code class="Code-In-Text--PACKT-">5</code>, which is defined in the structures. If we did not give the constant an initial value, as shown in the following example, the default initializer would be used to set the constant as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MyStruct</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">let</span> <span class="hljs-built_i">c</span>: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">var</span> v = <span class="hljs-string">""</span>
}
</code></pre>
    <p class="normal">The following example shows how the initializer for this new structure would work:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myStruct = <span class="hljs-type">MyStruct</span>(<span class="hljs-built_i">c</span>: <span class="hljs-number">10</span>, v: <span class="hljs-string">"Hello"</span>)
</code></pre>
    <p class="normal">This allows us to define a constant where we set the value when we initialize the class or structure at runtime, rather than hardcoding the value of the constant within the type. The order in which the parameters appear in the initializer is the order in which we defined them. In the previous example, we defined the <code class="Code-In-Text--PACKT-">c</code> constant first, therefore, it is the first parameter in the initializer. We defined the <code class="Code-In-Text--PACKT-">v</code> parameter next, therefore, it is the second parameter in the initializer. </p>
    <p class="normal">Starting in Swift 5.1 with SE-0242, the initializer for structures has been enhanced so that default values can be added to any parameter, making the parameter optional in the initializer. Let's create a new structure that illustrates this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MyStruct</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">var</span> b = <span class="hljs-string">"Hello"</span>
    <span class="hljs-keyword">var</span> <span class="hljs-built_i">c</span> = <span class="hljs-string">"Jon"</span>
}
</code></pre>
    <p class="normal">In this code, we define three parameters, a, b, and c, where both the b and c parameters have default values. We are now able to initialize the <code class="Code-In-Text--PACKT-">MyStruct</code> structure in any of the following ways:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> myStruct1 = <span class="hljs-type">MyStruct</span>(a: <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> myString2 = <span class="hljs-type">MyStruct</span>(a: <span class="hljs-number">3</span>, b: <span class="hljs-string">"Bonjour"</span>)
<span class="hljs-keyword">let</span> myString3 = <span class="hljs-type">MyStruct</span>(a: <span class="hljs-number">4</span>, b: <span class="hljs-string">"Bonjour"</span>, <span class="hljs-built_i">c</span>: <span class="hljs-string">"Kara"</span>)
</code></pre>
    <p class="normal">We are able to leave the c parameter or the b and c parameters undefined within the initializer because we set default values when we defined the parameters. One thing to note is the following code will throw an error:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> myString3 = <span class="hljs-type">MyStruct</span>(b: "<span class="hljs-type">Hello</span>", <span class="hljs-built_i">c</span>: <span class="hljs-string">"Kara"</span>)
</code></pre>
    <p class="normal">When we defined the<a id="_idIndexMarker363"/> parameters within the structure, we defined parameter a first, followed by b, and then c, which means the order within the initializer is also a followed by b, and then c. When we make multiple parameters that are optional, we cannot leave off one of the parameters but still include others that come after it, therefore we cannot leave off parameter a and still include parameters <code class="Code-In-Text--PACKT-">b</code> and c.</p>
    <p class="normal">To set or read a stored property, we use the standard dot syntax. Let's look at how we would set and read stored properties in Swift:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> x = myClass.<span class="hljs-built_i">c</span>
myClass.v = <span class="hljs-string">"Howdy"</span>
</code></pre>
    <p class="normal">In the first line of code, we read the <code class="Code-In-Text--PACKT-">c</code> property and store it into a variable named <code class="Code-In-Text--PACKT-">x</code>. In the second line of code, we set the <code class="Code-In-Text--PACKT-">v</code> property to the <code class="Code-In-Text--PACKT-">Howdy</code> string. Before we move on to computed properties, let's create both a structure and a class that will represent an employee. We will be using and expanding these throughout this chapter to show how classes and structures are similar, and how they differ:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">EmployeeStruct</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span> 
     <span class="hljs-keyword">var</span> salaryYear = <span class="hljs-number">0.0</span>
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EmployeeClass</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> salaryYear = <span class="hljs-number">0.0</span>
}
</code></pre>
    <p class="normal">The employee structure is named <code class="Code-In-Text--PACKT-">EmployeeStruct</code>, and the employee class is named <code class="Code-In-Text--PACKT-">EmployeeClass</code>. Both the class and structure have three stored properties: <code class="Code-In-Text--PACKT-">firstName</code>, <code class="Code-In-Text--PACKT-">lastName</code>, and <code class="Code-In-Text--PACKT-">salaryYear</code>. Within the structure and class, we can access these properties by using the <a id="_idIndexMarker364"/>name of the property and the <code class="Code-In-Text--PACKT-">self</code> keyword. Every instance of a structure or class has a property named <code class="Code-In-Text--PACKT-">self</code>. This property refers to the instance itself; therefore, we can use it to access the properties within the instance. The following examples show how we can access the properties with the <code class="Code-In-Text--PACKT-">self</code> keyword within the instance of the structure or class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">self</span>.firstName = <span class="hljs-string">"Jon"</span> <span class="hljs-keyword">self</span>.lastName = <span class="hljs-string">"Hoffman"</span>
</code></pre>
    <h2 id="_idParaDest-167" class="title">Computed properties</h2>
    <p class="normal">Computed properties are <a id="_idIndexMarker365"/>properties that do not have backend variables, which are used to store the values associated with the property but are hidden from the external code. The values of a computed property are usually computed when code requests it. You can think of a computed property as a function disguised as a property. Let's look at how we would define a read-only computed property:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> salaryWeek: <span class="hljs-type">Double</span> { 
    <span class="hljs-keyword">get</span>{
        <span class="hljs-keyword">self</span>.salaryYear/<span class="hljs-number">52</span>
    }
}
</code></pre>
    <p class="normal">To create a read-only computed property, we begin by defining it as if it were a normal variable with the <code class="Code-In-Text--PACKT-">var</code> keyword, followed by the variable name, a colon, and the variable type. What comes next is different; we add a curly bracket at the end of the declaration and then define a getter method, which is called when the value of our computed property is requested. In this example, the getter method divides the current value of the <code class="Code-In-Text--PACKT-">salaryYear</code> property by 52 to get the employee's weekly salary.</p>
    <p class="normal">We can simplify the definition of the read-only computed property by removing the <code class="Code-In-Text--PACKT-">get</code> keyword, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> salaryWeek: <span class="hljs-type">Double</span> { 
    <span class="hljs-keyword">self</span>.salaryYear/<span class="hljs-number">52</span>
}
</code></pre>
    <p class="normal">Computed properties are not limited to being read-only; we can also write to them. To enable the <code class="Code-In-Text--PACKT-">salaryWeek</code> property to be writeable, we will add a setter method. The following example shows<a id="_idIndexMarker366"/> how we add a setter method that will set the <code class="Code-In-Text--PACKT-">salaryYear</code> property, based on the value being passed into the <code class="Code-In-Text--PACKT-">salaryWeek</code> property:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> salaryWeek: <span class="hljs-type">Double</span> { 
    <span class="hljs-keyword">get</span> {
        <span class="hljs-keyword">self</span>.salaryYear/<span class="hljs-number">52</span>
    }
    <span class="hljs-keyword">set</span>(newSalaryWeek){
        <span class="hljs-keyword">self</span>.salaryYear = newSalaryWeek*<span class="hljs-number">52</span>
    }
}
</code></pre>
    <p class="normal">We can simplify the setter definition by not defining a name for the new value. In this case, the value will be assigned to a default variable named <code class="Code-In-Text--PACKT-">newValue</code>, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> salaryWeek: <span class="hljs-type">Double</span> { 
    <span class="hljs-keyword">get</span> {
        <span class="hljs-keyword">self</span>.salaryYear/<span class="hljs-number">52</span>
    }
    <span class="hljs-keyword">set</span>{
        <span class="hljs-keyword">self</span>.salaryYear = newValue*<span class="hljs-number">52</span>
    }
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">salaryWeek</code> computed property, as written in the preceding examples, could be added to either the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class or the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure without any modifications. Let's see how we can do this by adding the <code class="Code-In-Text--PACKT-">salaryWeek</code> property to our <code class="Code-In-Text--PACKT-">EmployeeClass</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EmployeeClass</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> salaryYear = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">var</span> salaryWeek: <span class="hljs-type">Double</span> { 
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">self</span>.salaryYear/<span class="hljs-number">52</span>
        }
        <span class="hljs-keyword">set</span>(newSalaryWeek) {
            <span class="hljs-keyword">self</span>.salaryYear = newSalaryWeek*<span class="hljs-number">52</span>
        }
    }
}
</code></pre>
    <p class="normal">Now, let's look at how we can add the <code class="Code-In-Text--PACKT-">salaryWeek</code> computed property to the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">EmployeeStruct</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span> 
     <span class="hljs-keyword">var</span> salaryYear = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">var</span> salaryWeek: <span class="hljs-type">Double</span> { 
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">self</span>.salaryYear/<span class="hljs-number">52</span>
        }
        <span class="hljs-keyword">set</span>(newSalaryWeek) {
            <span class="hljs-keyword">self</span>.salaryYear = newSalaryWeek*<span class="hljs-number">52</span>
        }
    }
}
</code></pre>
    <p class="normal">As we can see, the class and structure definitions are the same so far, except for the initial <code class="Code-In-Text--PACKT-">class</code> or <code class="Code-In-Text--PACKT-">struct</code> keywords that are used to define them. We read and write to a computed property exactly as we would to a stored property. Code that is external to the class or structure should not be aware that the property is a computed property. Let's see this in action by<a id="_idIndexMarker367"/> creating an instance of the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> f = <span class="hljs-type">EmployeeStruct</span>(firstName: <span class="hljs-string">"Jon"</span>, lastName: <span class="hljs-string">"Hoffman"</span>, salaryYear: <span class="hljs-number">39_000</span>)
<span class="hljs-built_i">print</span>(f.salaryWeek) <span class="hljs-comment">//prints 750.00 to the console f.salaryWeek = 1000</span>
<span class="hljs-built_i">print</span>(f.salaryWeek) <span class="hljs-comment">//prints 1000.00 to the console</span>
<span class="hljs-built_i">print</span>(f.salaryYear) <span class="hljs-comment">//prints 52000.00 to the console</span>
</code></pre>
    <p class="normal">The preceding example starts off by creating an instance of the <code class="Code-In-Text--PACKT-">EmployStruct</code> structure with the <code class="Code-In-Text--PACKT-">salaryYear</code> value being set to 39,000. Next, we print the value of the <code class="Code-In-Text--PACKT-">salaryWeek</code> property to the console. This value is currently 750.00. We then set the <code class="Code-In-Text--PACKT-">salaryWeek</code> property to 1,000.00 and print out both the <code class="Code-In-Text--PACKT-">salaryWeek</code> and <code class="Code-In-Text--PACKT-">salaryYear</code> properties to the console. The values of the <code class="Code-In-Text--PACKT-">salaryWeek</code> and <code class="Code-In-Text--PACKT-">salaryYear</code> properties are now 1,000.00 and 52,000, respectively. As we can see, in this example, setting either the <code class="Code-In-Text--PACKT-">salaryWeek</code> or <code class="Code-In-Text--PACKT-">salaryYear</code> properties changes the values returned by both. Computed properties can be very<a id="_idIndexMarker368"/> useful for offering different views of the same data. For example, if we had a value that represented the length of something, we could store the length in centimeters and then use computed properties that calculate the values for meters, millimeters, and kilometers. Now, let's look at property observers.</p>
    <h2 id="_idParaDest-168" class="title">Property observers</h2>
    <p class="normal">Property observers are<a id="_idIndexMarker369"/> called every time the value of the property is set. We can add property observers to any non-lazy stored property. We can also add property observers to any inherited stored or computed property by overriding the property in the subclass, which we will look at in the <em class="italic">Overriding properties </em>section. There are two property observers that we can set in Swift: <code class="Code-In-Text--PACKT-">willSet</code> and <code class="Code-In-Text--PACKT-">didSet</code>. The <code class="Code-In-Text--PACKT-">willSet</code> observer is called right before the property is set, and the <code class="Code-In-Text--PACKT-">didSet</code> observer is called right after the property is set. One thing to note about property observers is that they are not called when the value is set during initialization. Let's look at how we can add a property observer to the salary property of our <code class="Code-In-Text--PACKT-">EmployeeClass</code> class and <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> salaryYear: <span class="hljs-type">Double</span> = <span class="hljs-number">0.0</span> { 
    <span class="hljs-keyword">willSet</span>(newSalary) {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"About to set salaryYear to \(newSalary)"</span>)
    }
    <span class="hljs-keyword">didSet</span> {
        <span class="hljs-keyword">if</span> salaryWeek &gt; oldValue { 
            <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(firstName) got a raise."</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(firstName) did not get a raise."</span>)
        }
    }
}
</code></pre>
    <p class="normal">When we add a property observer to a stored property, we need to include the type of the value being stored within the definition of the property. In the preceding example, we did not need to define our <code class="Code-In-Text--PACKT-">salaryYear</code> property as a <code class="Code-In-Text--PACKT-">Double</code> type; however, when we add property observers, the definition is required. After the property definition, we define the <code class="Code-In-Text--PACKT-">willSet</code> observer, which simply prints out the new value that the <code class="Code-In-Text--PACKT-">salaryYear</code> property will be set to. We also define a <code class="Code-In-Text--PACKT-">didSet</code> observer, which will check whether the new value is greater than the old value, and if so, it will print out that the employee got a raise; otherwise, it will print <a id="_idIndexMarker370"/>out that the employee did not get a raise. As with the getter method with computed properties, we do not need to define the name for the new value of the <code class="Code-In-Text--PACKT-">willSet</code> observer. If we do not define a name, the new value is put in a constant named <code class="Code-In-Text--PACKT-">newValue</code>. The following example shows how we can rewrite the previous <code class="Code-In-Text--PACKT-">willSet</code> observer without defining a name for the new value:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">willSet</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"About to set salaryYear to \(newValue)"</span>)
}
</code></pre>
    <p class="normal">As we have seen, properties are mainly used to store information associated with a class or structure. Methods are mainly used to add the business logic to a class or structure. Let's look at how we can add methods to a class or structure.</p>
    <h1 id="_idParaDest-169" class="title">Methods</h1>
    <p class="normal">Methods are functions that are<a id="_idIndexMarker371"/> associated with an instance of a class or structure. A method, like a function, will encapsulate the code for a specific task or functionality that is associated with the class or structure. Let's look at how we can define methods for classes and structures. The following code will return the full name of the employee by using the <code class="Code-In-Text--PACKT-">firstName</code> and <code class="Code-In-Text--PACKT-">lastName</code> properties:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">fullName</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> { 
    firstName + <span class="hljs-string">" "</span> + lastName
}
</code></pre>
    <p class="normal">We define this method exactly as we would define any function. A method is simply a function that is associated with a specific class or structure, and everything that we learned about functions in the previous chapters applies to methods. The <code class="Code-In-Text--PACKT-">fullName() </code>function can be added directly to the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class or <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure without any modification. To access a method, we use the same dot syntax we used to access properties. </p>
    <p class="normal">The following code shows how we access the <code class="Code-In-Text--PACKT-">fullName()</code> method of a class and a structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> e = <span class="hljs-type">EmployeeClass</span>()
<span class="hljs-keyword">var</span> f = <span class="hljs-type">EmployeeStruct</span>(firstName: <span class="hljs-string">"Jon"</span>, lastName: <span class="hljs-string">"Hoffman"</span>, salaryYear: <span class="hljs-number">50000</span>)
e.firstName = <span class="hljs-string">"Jon"</span>
e.lastName = <span class="hljs-string">"Hoffman"</span>
e.salaryYear = <span class="hljs-number">50000.00</span>
<span class="hljs-built_i">print</span>(e.fullName()) <span class="hljs-comment">//Jon Hoffman is printed to the console</span>
<span class="hljs-built_i">print</span>(f.fullName()) <span class="hljs-comment">//Jon Hoffman is printed to the console</span>
</code></pre>
    <p class="normal">In the preceding example, we initialize an instance of both the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class and the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure. We populate the structure and class with the same information and then use the <code class="Code-In-Text--PACKT-">fullName()</code> method to print the full name of the employee to the <a id="_idIndexMarker372"/>console. In both cases, <code class="Code-In-Text--PACKT-">Jon Hoffman</code> is printed to the console. There is a difference in how we define methods for classes and structures that need to update property values. Let's look at how we define a method that gives an employee a raise within the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">giveRaise</span><span class="hljs-params">(amount: Double)</span> { 
    salaryYear += amount
}
</code></pre>
    <p class="normal">If we add the preceding code to our <code class="Code-In-Text--PACKT-">EmployeeClass</code>, it works as expected, and when we call the method with an amount, the employee gets a raise. However, if we try to add this method as it is written to the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure, we receive a <code class="Code-In-Text--PACKT-">mark</code> method and a <code class="Code-In-Text--PACKT-">mutating to make self mutable</code> error. By default, we are not allowed to update property values within a method of a structure. If we want to modify a property, we can mutate the behavior for that method by adding the <code class="Code-In-Text--PACKT-">mutating</code> keyword before the <code class="Code-In-Text--PACKT-">func</code> keyword of the method declaration. Therefore, the following code would be the correct way to define the <code class="Code-In-Text--PACKT-">giveRaise(amount:)</code> method for the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">giveRase</span><span class="hljs-params">(amount: Double)</span> { 
    <span class="hljs-keyword">self</span>.salaryYear += amount
}
</code></pre>
    <p class="normal">In the preceding examples, we use the <code class="Code-In-Text--PACKT-">self</code> property to refer to the current instance of the type within the instance itself, so when we write <code class="Code-In-Text--PACKT-">self.salaryYear</code>, we ask for the value of the <code class="Code-In-Text--PACKT-">salaryYear</code> property for the current instance of the type.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">self</code> property should only be used when necessary. We are using it in these examples to illustrate what it is and how to use it.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">self</code> property is mainly used to distinguish between local and instance variables that have the same name. Let's look at an example that illustrates this. We can add this function to either the <code class="Code-In-Text--PACKT-">EmployeeClass</code> or <code class="Code-In-Text--PACKT-">EmployeeStruct</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">isEqualFirstName</span><span class="hljs-params">(firstName: String)</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">self</span>.firstName == firstName
}
</code></pre>
    <p class="normal">In the preceding example, the<a id="_idIndexMarker373"/> method accepts an argument named <code class="Code-In-Text--PACKT-">firstName</code>. There is also a property within the type that has the same name. We use the <code class="Code-In-Text--PACKT-">self</code> property to specify that we want the instance property with the <code class="Code-In-Text--PACKT-">firstName</code> name, and not the local variable with this name. Other than the <code class="Code-In-Text--PACKT-">mutating</code> keyword being required for methods that change the value of the structure's properties, methods can be defined and used exactly as functions are defined and used. Therefore, everything we learned about functions in <em class="chapterRef">Chapter 6</em>, <em class="italic">Functions</em>, can be applied to methods. There are times when we want to initialize properties or perform some business logic when a class or structure is first initialized. For this, we will use an initializer.</p>
    <h2 id="_idParaDest-170" class="title">Custom initializers</h2>
    <p class="normal">Initializers are called when we initialize a new instance of a type (class or structure). Initialization is the process of preparing an instance for use. The initialization process can include setting initial values for stored properties, verifying that external resources are available, or setting up the UI properly. Initializers are generally <a id="_idIndexMarker374"/>used to ensure that the instance of the class or structure is properly initialized prior to first use. Initializers are special methods that are used to create a new instance of a type. We define an initializer similarly to defining other methods, but we must use the <code class="Code-In-Text--PACKT-">init</code> keyword as the name of the initializer to tell the compiler that this method is an initializer. In its simplest form, the initializer does not accept any arguments. Let's look at the syntax that's used to write a simple initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">init</span>() {
    <span class="hljs-comment">//Perform initialization here</span>
}
</code></pre>
    <p class="normal">This format works for both classes and structures. By default, all classes and structures have an empty default initializer that can be overridden. We used these default initializers when we initialized the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class and <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure in the previous section. Structures also have an additional default initializer, which we saw with the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure, which accepts a value for each stored property and initializes them with those values. Let's look at how we add custom initializers to the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class and the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure. In the following code, we create three custom initializers that will work for both the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class and the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">init</span>() {
    firstName =<span class="hljs-string">""</span> 
    lastName = <span class="hljs-string">""</span> 
    salaryYear = <span class="hljs-number">0.0</span>
}
<span class="hljs-keyword">init</span>(firstName: <span class="hljs-type">String</span>, lastName: <span class="hljs-type">String</span>) { 
    <span class="hljs-keyword">self</span>.firstName = firstName
    <span class="hljs-keyword">self</span>.lastName = lastName 
    salaryYear = <span class="hljs-number">0.0</span>
}
<span class="hljs-keyword">init</span>(firstName: <span class="hljs-type">String</span>, lastName: <span class="hljs-type">String</span>, salaryYear: <span class="hljs-type">Double</span>) { 
    <span class="hljs-keyword">self</span>.firstName = firstName
    <span class="hljs-keyword">self</span>.lastName = lastName
    <span class="hljs-keyword">self</span>.salaryYear = salaryYear
}
</code></pre>
    <p class="normal">The first initializer, <code class="Code-In-Text--PACKT-">init()</code>, will set all of the stored properties to their default values. The second initializer, <code class="Code-In-Text--PACKT-">init(firstName: String, lastName: String)</code>, will populate the <code class="Code-In-Text--PACKT-">firstName</code> and <code class="Code-In-Text--PACKT-">lastName</code> properties with the values of the arguments. The third initializer, <code class="Code-In-Text--PACKT-">init(firstName: String, lastName: String, salaryYear: Double)</code>, will populate all the properties<a id="_idIndexMarker375"/> with the values of the arguments. In the previous example, we can see that in Swift, an initializer does not have an explicit return value, but it does return an instance of the type. This means that we do not define a return type for the initializer or have a return statement within the initializer. Let's look at how we could use these initializers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> g = <span class="hljs-type">EmployeeClass</span>()
<span class="hljs-keyword">var</span> h = <span class="hljs-type">EmployeeStruct</span>(firstName: <span class="hljs-string">"Me"</span>, lastName: <span class="hljs-string">"Moe"</span>)
<span class="hljs-keyword">var</span> i = <span class="hljs-type">EmployeeClass</span>(firstName: <span class="hljs-string">"Me"</span>, lastName: <span class="hljs-string">"Moe"</span>, salaryYear: <span class="hljs-number">45_000</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">g</code> instance of <code class="Code-In-Text--PACKT-">EmployeeClass</code> uses the <code class="Code-In-Text--PACKT-">init()</code> initializer to create an instance of the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class; therefore, all the properties of this instance contain their default values. The <code class="Code-In-Text--PACKT-">h</code> instance <a id="_idIndexMarker376"/>of <code class="Code-In-Text--PACKT-">EmployeeStruct</code> uses the <code class="Code-In-Text--PACKT-">init(firstName: String, lastName: String)</code> initializer to create an instance of the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure; therefore, the <code class="Code-In-Text--PACKT-">firstName</code> property is set to <code class="Code-In-Text--PACKT-">Me</code> and the <code class="Code-In-Text--PACKT-">lastName</code> property is set to <code class="Code-In-Text--PACKT-">Moe</code>, which are the two arguments passed into the initializer. The <code class="Code-In-Text--PACKT-">salaryYear</code> property is still set to the default value of <code class="Code-In-Text--PACKT-">0.0</code>. The <code class="Code-In-Text--PACKT-">i</code> instance of <code class="Code-In-Text--PACKT-">EmployeeClass</code> uses the <code class="Code-In-Text--PACKT-">init(firstName: String, lastName: String, salaryYear: Double0)</code> initializer to create an instance of the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class; therefore, the <code class="Code-In-Text--PACKT-">firstName</code> property is set to <code class="Code-In-Text--PACKT-">Me</code>, the <code class="Code-In-Text--PACKT-">lastName</code> property is set to <code class="Code-In-Text--PACKT-">Moe</code>, and the <code class="Code-In-Text--PACKT-">salaryYear</code> property is set to <code class="Code-In-Text--PACKT-">45_000</code>. Since all the initializers are identified with the <code class="Code-In-Text--PACKT-">init</code> keyword, the parameters and<a id="_idIndexMarker377"/> parameter types are used to identify which initializer to use. A class, unlike a structure, can have a deinitializer. A deinitializer is called just before an instance of the class is destroyed and removed from memory. In <em class="chapterRef">Chapter 18</em>, <em class="italic">Memory Management</em>, we will show examples of the deinitializer and see when it is called. Let's look at internal and external parameter names with initializers.</p>
    <h2 id="_idParaDest-171" class="title">Internal and external parameter names</h2>
    <p class="normal">Just like functions, the <a id="_idIndexMarker378"/>parameters associated with an initializer can have separate internal and external names. If we do not supply external parameter names for our parameters, Swift will automatically generate them for us. In the previous examples, we did not include external parameter names in the definition of the initializers, so Swift created them for us using the internal parameter name as the external parameter name. If we wanted to supply our own parameter names, we would do so by putting the external parameter name before the internal parameter name, exactly as we do with any normal function. Let's look at how we can define our own external parameter names by redefining one of the initializers within our <code class="Code-In-Text--PACKT-">EmployeeClass</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">init</span>(employeeWithFirstName firstName: <span class="hljs-type">String</span>, lastName lastName: <span class="hljs-type">String</span>, andSalary salaryYear: <span class="hljs-type">Double</span>) {
    <span class="hljs-keyword">self</span>.firstName = firstName
    <span class="hljs-keyword">self</span>.lastName = lastName
    <span class="hljs-keyword">self</span>.salaryYear = salaryYear
}
</code></pre>
    <p class="normal">In the preceding example, we created the <code class="Code-In-Text--PACKT-">init(employeeWithFirstName firstName: String, lastName lastName: String, andSalary salaryYear: Double)</code> initializer. This initializer will create an instance of the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class and populate the instance properties with the value of the arguments. In this example, each of the parameters has both external and internal property names. Let's look at how we would use this initializer, with the external property names:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> i = <span class="hljs-type">EmployeeClass</span>(withFirstName: <span class="hljs-string">"Me"</span>, lastName: <span class="hljs-string">"Moe"</span>, andSalary: <span class="hljs-number">45000</span>)
</code></pre>
    <p class="normal">Notice that we are now using the external parameter names as defined in the initializer. Using external parameter names can help make our code more readable and help differentiate between<a id="_idIndexMarker379"/> different initializers. So, what will happen if our initializer fails? For example, what if our class relies on a specific resource, such as a web service that is not currently available? This is where failable initializers come in.</p>
    <h2 id="_idParaDest-172" class="title">Failable initializers</h2>
    <p class="normal">A failable initializer is an initializer that <a id="_idIndexMarker380"/>may fail to initialize the resources needed for a class or a structure, thereby rendering the instance unusable. When using a failable initializer, the result of the initializer is an optional type, containing either a valid instance of the type or nil. An initializer can be made failable by adding a question mark (<code class="Code-In-Text--PACKT-">?</code>) after the <code class="Code-In-Text--PACKT-">init</code> keyword. Let's look at how we can create a failable initializer that will not allow a new employee to be initialized with a salary of less than $20,000 a year:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">init</span>?(firstName: <span class="hljs-type">String</span>, lastName: <span class="hljs-type">String</span>, salaryYear: <span class="hljs-type">Double</span>) { 
    <span class="hljs-keyword">self</span>.firstName = firstName
    <span class="hljs-keyword">self</span>.lastName = lastName
    <span class="hljs-keyword">self</span>.salaryYear = salaryYear
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.salaryYear &lt; <span class="hljs-number">20_000</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
}
</code></pre>
    <p class="normal">In the previous examples, we did not include a <code class="Code-In-Text--PACKT-">return</code> statement within the initializer because Swift does not need to return the initialized instance; however, in a failable initializer, if the initialization fails, it must return nil. If the initializer successfully initializes the instance, we do not need to return anything. Therefore, in our example, if the yearly salary that is passed in is less than $20,000 a year, we return <code class="Code-In-Text--PACKT-">nil</code>, indicating that the initialization failed, otherwise nothing will be returned. Let's look at how we would use a failable initializer to create an instance of a class or structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> f = <span class="hljs-type">EmployeeClass</span>(firstName: <span class="hljs-string">"Jon"</span>, lastName: <span class="hljs-string">"Hoffman"</span>, salaryYear: <span class="hljs-number">29_000</span>) {
    <span class="hljs-built_i">print</span>(f.fullName())
} <span class="hljs-keyword">else</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Failed to initialize"</span>)
}
</code></pre>
    <p class="normal">In the previous example, we initialize the instance of the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class with a yearly salary of greater than $20,000; therefore, the instance gets initialized correctly and the full name of <code class="Code-In-Text--PACKT-">Jon Hoffman</code> is printed to the console. Now, let's try to initialize an instance of the <code class="Code-In-Text--PACKT-">EmployeeClass</code> class with a yearly salary of less than $20,000 to see how it fails:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> f = <span class="hljs-type">EmployeeClass</span>(firstName: <span class="hljs-string">"Jon"</span>, lastName: <span class="hljs-string">"Hoffman"</span>, salaryYear: <span class="hljs-number">19_000</span>) {
    <span class="hljs-built_i">print</span>(f.fullName())
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Failed to initialize"</span>)
}
</code></pre>
    <p class="normal">In the preceding example, the yearly <a id="_idIndexMarker381"/>salary that we are attempting to initialize for our employee is less than $20,000, therefore the initialization fails and a <code class="Code-In-Text--PACKT-">Failed to initialize</code> message<em class="italic"> </em>is printed to the console. </p>
    <p class="normal">There are times when we want to restrict access to certain parts of our code. For this, we use access controls.</p>
    <h1 id="_idParaDest-173" class="title">Access controls</h1>
    <p class="normal">Access controls enable us to hide implementation details and only expose the interfaces we want to expose. This <a id="_idIndexMarker382"/>feature is handled with access controls. We can assign specific access levels to both classes and structures. We can also assign specific access levels to properties, methods, and initializers that belong to our classes and structures. In Swift, there are five access levels:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Open</strong>: This is the most<a id="_idIndexMarker383"/> visible access control level. It allows us to use the property, method, class, and so on anywhere we want to import the module. Basically, anything can use an item that has an access-control level of open. Anything that is marked open can be subclassed or overridden by any item within the module they are defined in and any module that imports the module it is defined in. This level is primarily used by frameworks to expose the framework's public API. The open-access control is only available to classes and members of a class.</li>
      <li class="bullet"><strong class="keyword">Public</strong>: This access level allows<a id="_idIndexMarker384"/> us to use the property, method, class, and so on anywhere we want to import the module. Basically, anything can use an item that has an access-control level of public. Anything that is marked public can be subclassed or overridden only by any item within the module they are defined in. This level is primarily used by frameworks to expose the framework's public API.</li>
      <li class="bullet"><strong class="keyword">Internal</strong>: This is the<a id="_idIndexMarker385"/> default access level. This access level allows us to use the property, method, class, and so on in the module the item is defined in. If this level is used in a framework, it lets other parts of the framework use the item but code outside the framework will be unable to access it.</li>
      <li class="bullet"><strong class="keyword">Fileprivate</strong>: This access control<a id="_idIndexMarker386"/> allows access to the properties and methods from any code within the same source file that the item is defined in.</li>
      <li class="bullet"><strong class="keyword">Private</strong>: This is the least <a id="_idIndexMarker387"/>visible access-control level. It only allows us to use the property, method, class, and so on, within extensions of the declaration defined in the source file that defines it.</li>
    </ul>
    <p class="normal">When we are developing frameworks, the access controls really become useful. We will need to mark the public-facing interfaces as public or open so that other modules, such as applications that import<a id="_idIndexMarker388"/> the framework, can use them. We will then use the internal and private access-control levels to mark the interfaces that we want to use internally to the framework and the source file, respectively. To define access levels, we place the name of the level before the definition of the entity. The following code shows examples of how we can add access levels to several entities:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">EmployeeStruct</span><span class="hljs-class"> </span>{}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EmployeeClass</span><span class="hljs-class"> </span>{} 
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EmployeeClass2</span><span class="hljs-class"> </span>{} 
<span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">"Jon"</span> 
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">"Hoffman"</span> 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> salaryYear = <span class="hljs-number">0.0</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">fullName</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> {} 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">giveRaise</span><span class="hljs-params">(amount: Double)</span> {}
</code></pre>
    <p class="normal">There are some limitations with access controls, but these limitations are there to ensure that access levels in Swift follow a simple guiding principle: no entity can be defined in terms of another entity that has a lower (more restrictive) access level. This means that we cannot assign a higher (less restrictive) access level to an entity when it relies on another entity that has a lower (more restrictive) access level. The following examples demonstrate this principle:</p>
    <ul>
      <li class="bullet">We cannot mark a method as being public when one of the arguments or the return type has an access level of private, because external code would not have access to the private type</li>
      <li class="bullet">We cannot set the access level of a method or property to public when the class or structure has an access level of private, because external code would not be able to access the <a id="_idIndexMarker389"/>constructor when the class is private</li>
    </ul>
    <p class="normal">Now let's look at a new feature in Swift 5.2, key-path expressions as functions.</p>
    <h1 id="_idParaDest-174" class="title">Key-path expressions as functions</h1>
    <p class="normal">SE-0249 in Swift 5.2 introduced a<a id="_idIndexMarker390"/> great shortcut which enables us to easily access the properties of objects in a particular collection. What this <a id="_idIndexMarker391"/>means is if we iterate over a collection using the <code class="Code-In-Text--PACKT-">map</code> algorithm, we are able to use key-path expressions <code class="Code-In-Text--PACKT-">(\Root.value</code>) to access the properties of the items in the collection. Let's look at an example using the employee structure we created earlier. We will start by creating three employees and adding them to an array:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> employee1 = <span class="hljs-type">EmployeeStruct</span>(firstName: <span class="hljs-string">"Jon"</span>, lastName: <span class="hljs-string">"Hoffman"</span>, salaryYear: <span class="hljs-number">90000</span>)
<span class="hljs-keyword">let</span> employee2 = <span class="hljs-type">EmployeeStruct</span>(firstName: <span class="hljs-string">"Kailey"</span>, lastName: <span class="hljs-string">"Hoffman"</span>, salaryYear: <span class="hljs-number">32000</span>)
<span class="hljs-keyword">let</span> employee3 = <span class="hljs-type">EmployeeStruct</span>(firstName: <span class="hljs-string">"Kara"</span>, lastName: <span class="hljs-string">"Hoffman"</span>, salaryYear: <span class="hljs-number">28000</span>)
<span class="hljs-keyword">let</span> employeeCollection = [employee1, employee2, employee3]
</code></pre>
    <p class="normal">Now that we have an array of employees, let's retrieve all of the first names of our employees. We could loop through our array and pull out the names one by one, but if we combine the map algorithm that we saw in <em class="chapterRef">Chapter 5</em>,<em class="italic"> Using Swift Collections</em>, with this new feature, we could retrieve all first names like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> firstNames = employeeCollection.<span class="hljs-built_i">map</span>(\.firstName)
</code></pre>
    <p class="normal">With this code, the firstName array will contain the first name for each employee in our employeeCollection array.</p>
    <p class="normal">Let's look at another new feature with Swift 5.2, calling a type as a function.</p>
    <h1 id="_idParaDest-175" class="title">Calling a type as a function</h1>
    <p class="normal">With SE-0253 in Swift 5.2, we are<a id="_idIndexMarker392"/> able to call a type as a function. To explain it a little better, instances of types that have a method whose name is <code class="Code-In-Text--PACKT-">callAsFunction</code> can be called as if they were a function. Let's look at an example of this. We will start off by creating a <code class="Code-In-Text--PACKT-">Dice</code> type that can be used to create an instance of any size dice:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Dice</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> highValue: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">var</span> lowValue: <span class="hljs-type">Int</span>
    
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">callAsFunction</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Int</span> {
        <span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: lowValue...highValue)
    }
}
</code></pre>
    <p class="normal">Notice the method within the function called callAsFunction(). This function generates a random number using the <code class="Code-In-Text--PACKT-">lowValue</code> and <code class="Code-In-Text--PACKT-">highValue</code> properties. Since we named this method <code class="Code-In-Text--PACKT-">callAsFunction</code>, we are able to call it using the instance's name as if it were a function. Let's see how this works by creating a six-sided dice and generating a random value:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> d6 = <span class="hljs-type">Dice</span>(highValue: <span class="hljs-number">6</span>, lowValue: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> roll = d6()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">roll</code> variable will contain a<a id="_idIndexMarker393"/> random value generated from the <code class="Code-In-Text--PACKT-">callAsFunction()</code> method. This enables us to simplify how we call certain functions. In the previous example, we are able to generate the roll of the dice by simply calling <code class="Code-In-Text--PACKT-">d6()</code> rather than calling the instance with a function name like <code class="Code-In-Text--PACKT-">d6.generateRoll()</code>. </p>
    <p class="normal">Now let's look at what inheritance is.</p>
    <h1 id="_idParaDest-176" class="title">Inheritance</h1>
    <p class="normal">The concept of inheritance is a<a id="_idIndexMarker394"/> basic object-oriented development concept. Inheritance allows a class to be defined as having a certain set of characteristics, and then other classes can be derived from that class. The derived class inherits all of the features of the class it is inheriting from (unless the derived class overrides those characteristics) and then usually adds additional characteristics of its own.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Inheritance is one of the fundamental differences that separates classes from structures. Classes can be derived from a parent or superclass, but a structure cannot.</p>
    </div>
    <p class="normal">With inheritance, we can create <a id="_idIndexMarker395"/>what is known as a class hierarchy. In a class hierarchy, the class at the top of the hierarchy is known as the base class, and the derived classes are known as <a id="_idIndexMarker396"/>subclasses. We are not limited to only creating subclasses from a base class, we can also create subclasses from other subclasses. The class that a subclass is derived from is known as the parent or superclass. In Swift, a class can<a id="_idIndexMarker397"/> have only one parent class. This is known as single inheritance.</p>
    <p class="normal">Subclasses can call and access the properties, methods, and subscripts of their superclass. They can also override the properties, methods, and subscripts of their superclass.</p>
    <p class="normal">Subclasses can <a id="_idIndexMarker398"/>add property observers to properties that they inherit from a superclass so that they can be notified when the values of the properties change. Let's look at an example that illustrates how inheritance works in Swift. We will start off by defining a base class named <code class="Code-In-Text--PACKT-">Plant</code>. The <code class="Code-In-Text--PACKT-">Plant</code> class will have two properties: <code class="Code-In-Text--PACKT-">height</code> and <code class="Code-In-Text--PACKT-">age</code>. It will also have one method: <code class="Code-In-Text--PACKT-">growHeight()</code>. The <code class="Code-In-Text--PACKT-">height</code> property will represent the height of the plant, the <code class="Code-In-Text--PACKT-">age</code> property will represent the age of the plant, and the <code class="Code-In-Text--PACKT-">growHeight()</code> method will be used to increase the height of the plant. Here is how we would define the <code class="Code-In-Text--PACKT-">Plant</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Plant</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> height = <span class="hljs-number">0.0</span> 
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span>
<span class="hljs-keyword">    func</span><span class="hljs-function"> </span><span class="hljs-title">growHeight</span><span class="hljs-params">(inches: Double)</span> { 
        height += inches;
    }
}
</code></pre>
    <p class="normal">Now that we have our <code class="Code-In-Text--PACKT-">Plant</code> base class, let's see how we would define a subclass of it. We will name this subclass <code class="Code-In-Text--PACKT-">Tree</code>. The <code class="Code-In-Text--PACKT-">Tree</code> class will inherit the <code class="Code-In-Text--PACKT-">age</code> and <code class="Code-In-Text--PACKT-">height</code> properties of the <code class="Code-In-Text--PACKT-">Plant</code> class and add one more property, named <code class="Code-In-Text--PACKT-">limbs</code>. It will also inherit the <code class="Code-In-Text--PACKT-">growHeight()</code> method of the <code class="Code-In-Text--PACKT-">Plant</code> class and add two more methods: <code class="Code-In-Text--PACKT-">limbGrow()</code>, where new limbs are grown, and <code class="Code-In-Text--PACKT-">limbFall()</code>, where limbs fall off the tree. Let's have a look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Tree</span><span class="hljs-class">: </span><span class="hljs-title">Plant</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> limbs = <span class="hljs-number">0</span> 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">limbGrow</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">self</span>.limbs += <span class="hljs-number">1</span>
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">limbFall</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">self</span>.limbs -= <span class="hljs-number">1</span>
    }
}
</code></pre>
    <p class="normal">We indicate that a class has a superclass by adding a colon and the name of the superclass to the end of the class definition. In this example, we indicated that the <code class="Code-In-Text--PACKT-">Tree</code> class has a superclass named <code class="Code-In-Text--PACKT-">Plant</code>. Now, let's look at how we could use the <code class="Code-In-Text--PACKT-">Tree</code> class that inherited the <code class="Code-In-Text--PACKT-">age</code> and <code class="Code-In-Text--PACKT-">height</code> properties from the <code class="Code-In-Text--PACKT-">Plant</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> tree = <span class="hljs-type">Tree</span>() 
tree.age = <span class="hljs-number">5</span>
tree.height = <span class="hljs-number">4</span> 
tree.limbGrow() 
tree.limbGrow() 
</code></pre>
    <p class="normal">The preceding example begins by <a id="_idIndexMarker399"/>creating an instance of the <code class="Code-In-Text--PACKT-">Tree</code> class. We then set the <code class="Code-In-Text--PACKT-">Age</code> and <code class="Code-In-Text--PACKT-">height</code> properties to <code class="Code-In-Text--PACKT-">5</code> and <code class="Code-In-Text--PACKT-">4</code>, respectively, and added two limbs to the tree by calling the <code class="Code-In-Text--PACKT-">limbGrow()</code> method twice. We now have a base class named <code class="Code-In-Text--PACKT-">Plant</code> that has a subclass named <code class="Code-In-Text--PACKT-">Tree</code>. This means that the super (or parent) class of <code class="Code-In-Text--PACKT-">Tree</code> is the <code class="Code-In-Text--PACKT-">Plant</code> class. This also means that one of the subclasses (or child classes) of <code class="Code-In-Text--PACKT-">Plant</code> is named <code class="Code-In-Text--PACKT-">Tree</code>. There are, however, lots of different kinds of trees in the world. Let's create two subclasses from the <code class="Code-In-Text--PACKT-">Tree</code> class. These subclasses will be the <code class="Code-In-Text--PACKT-">PineTree</code> class and the <code class="Code-In-Text--PACKT-">OakTree</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PineTree</span><span class="hljs-class">: </span><span class="hljs-title">Tree</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> needles = <span class="hljs-number">0</span>
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">OakTree</span><span class="hljs-class">: </span><span class="hljs-title">Tree</span>{ 
    <span class="hljs-keyword">var</span> leaves = <span class="hljs-number">0</span>
}
</code></pre>
    <p class="normal">The class hierarchy now looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B16683_08_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.1: Inheritance class hierarchy</p>
    <p class="normal">It is important to <a id="_idIndexMarker400"/>keep in mind that, in Swift, a class can have multiple subclasses; however, a class can have only one superclass. There are times when a subclass needs to<a id="_idIndexMarker401"/> provide its own implementation of a method or property that it inherited from its superclass. This is known as <strong class="keyword">overriding</strong>.</p>
    <h2 id="_idParaDest-177" class="title">Overriding methods and properties</h2>
    <p class="normal">To override<a id="_idIndexMarker402"/> a method, property, or subscript, we need to prefix the definition with the <code class="Code-In-Text--PACKT-">override</code> keyword. This tells<a id="_idIndexMarker403"/> the compiler that we intend to override something in the superclass, and that we did not make a duplicate definition by mistake. The <code class="Code-In-Text--PACKT-">override</code> keyword prompts the Swift compiler to verify that the superclass (or one of its parents) has a matching declaration that can be overridden. If it cannot find a matching declaration in one of the superclasses, an error will be thrown.</p>
    <h2 id="_idParaDest-178" class="title">Overriding methods</h2>
    <p class="normal">Let's look at how we can<a id="_idIndexMarker404"/> override a method. We will start by adding a <code class="Code-In-Text--PACKT-">getDetails()</code> method to the <code class="Code-In-Text--PACKT-">Plant</code> class that we will then override in the child classes. The following code shows the code for the new <code class="Code-In-Text--PACKT-">Plant</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Plant</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> height = <span class="hljs-number">0.0</span> 
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">growHeight</span><span class="hljs-params">(inches: Double)</span> { 
        <span class="hljs-keyword">self</span>.height += inches;
}
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getDetails</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> { 
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Plant Details"</span>
    }
}
</code></pre>
    <p class="normal">Now, let's see how we can override the <code class="Code-In-Text--PACKT-">getDetails()</code> method in the <code class="Code-In-Text--PACKT-">Tree</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Tree</span><span class="hljs-class">: </span><span class="hljs-title">Plant</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> limbs = <span class="hljs-number">0</span> 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">limbGrow</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">self</span>.limbs += <span class="hljs-number">1</span>
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">limbFall</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">self</span>.limbs -= <span class="hljs-number">1</span>
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getDetails</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> { 
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Tree Details"</span>
    }
}
</code></pre>
    <p class="normal">The thing to note here is that we do not use the <code class="Code-In-Text--PACKT-">override</code> keyword in the <code class="Code-In-Text--PACKT-">Plant</code> class because it is the first class to implement this method; however, we do include it in the <code class="Code-In-Text--PACKT-">Tree</code> class since we are overriding the <code class="Code-In-Text--PACKT-">getDetails()</code> method from the <code class="Code-In-Text--PACKT-">Plant</code> class. Now, let's see what happens if we call the <code class="Code-In-Text--PACKT-">getDetails()</code> method from an instance of the <code class="Code-In-Text--PACKT-">Plant</code> and <code class="Code-In-Text--PACKT-">Tree</code> classes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> plant = <span class="hljs-type">Plant</span>() 
<span class="hljs-keyword">var</span> tree = <span class="hljs-type">Tree</span>()
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Plant: \(plant.getDetails())"</span>) 
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Tree: \(tree.getDetails())"</span>)
</code></pre>
    <p class="normal">The previous example will print the following two lines to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Plant: Plant Details
Tree: Tree Details
</code></pre>
    <p class="normal">As we can see, the <code class="Code-In-Text--PACKT-">getDetails()</code> method in the <code class="Code-In-Text--PACKT-">Tree</code> subclass overrides the <code class="Code-In-Text--PACKT-">getDetails()</code> of its parent <code class="Code-In-Text--PACKT-">Plant</code> class. Inside the <code class="Code-In-Text--PACKT-">Tree</code> class, we can still call the <code class="Code-In-Text--PACKT-">getDetails()</code> method (or any overridden method, property, or subscript) of its superclass by using<a id="_idIndexMarker405"/> the <code class="Code-In-Text--PACKT-">super</code> prefix. We will begin by replacing the <code class="Code-In-Text--PACKT-">getDetails()</code> method in the <code class="Code-In-Text--PACKT-">Plant</code> class with the following method, which will generate a string that contains the values of the <code class="Code-In-Text--PACKT-">height</code> and <code class="Code-In-Text--PACKT-">age</code> properties:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getDetails</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Height:\(height) age:\(age)"</span>
}
</code></pre>
    <p class="normal">Now, we will replace the <code class="Code-In-Text--PACKT-">getDetails()</code> method for the <code class="Code-In-Text--PACKT-">Tree</code> class with the following method, which will call the <code class="Code-In-Text--PACKT-">getDetails()</code> method of the superclass:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getDetails</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> { 
    <span class="hljs-keyword">let</span> details = <span class="hljs-keyword">super</span>.getDetails() 
    <span class="hljs-keyword">return</span> <span class="hljs-string">"\(details) limbs:\(limbs)"</span>
}
</code></pre>
    <p class="normal">In the preceding example, we begin by calling the <code class="Code-In-Text--PACKT-">getDetails()</code> method of the superclass (the <code class="Code-In-Text--PACKT-">Plant</code> class in this case) to get a string that contains the tree's height and age. We then build a new string object that combines the results of the <code class="Code-In-Text--PACKT-">getDetails()</code> method and a new string that contains the number of limbs from the <code class="Code-In-Text--PACKT-">Tree</code> class. This new string is then returned. Let's look at what happens if we call this new method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> tree = <span class="hljs-type">Tree</span>()
tree.age = <span class="hljs-number">5</span>
tree.height = <span class="hljs-number">4</span>
tree.limbGrow()
tree.limbGrow()
<span class="hljs-built_i">print</span>(tree.getDetails())
</code></pre>
    <p class="normal">If we run the preceding code, the following line will be printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Height: 4.0
age: 5
limbs: 2
</code></pre>
    <p class="normal">As we can see, the string that is returned contains the <code class="Code-In-Text--PACKT-">height</code> and <code class="Code-In-Text--PACKT-">age</code> information from the <code class="Code-In-Text--PACKT-">Plant</code> class and the <code class="Code-In-Text--PACKT-">limbs</code> information from the <code class="Code-In-Text--PACKT-">Tree</code> class.</p>
    <h2 id="_idParaDest-179" class="title">Overriding properties</h2>
    <p class="normal">We can provide custom<a id="_idIndexMarker406"/> getters and setters to override any inherited property. When we override a property, we must provide the name and the type of property we are overriding so that the compiler can verify that one of the classes in the class hierarchy has a matching property to override. Let's see how we can override a property by adding the following property to our <code class="Code-In-Text--PACKT-">Plant</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Base class is Plant."</span>
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">description</code> property is a basic read-only property. This property returns the <code class="Code-In-Text--PACKT-">Base class is Plant</code> string. Now, let's override this property by adding the following property to the <code class="Code-In-Text--PACKT-">Tree</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"\(super.description) I am a Tree class."</span>
}
</code></pre>
    <p class="normal">The same <code class="Code-In-Text--PACKT-">override</code> keyword is used when overriding both properties and methods. This keyword tells the compiler that we want to override a property so that the compiler can verify that another class in the class hierarchy contains a matching property to override. We then implement the property as we would any other property. Calling the <code class="Code-In-Text--PACKT-">description</code> property for an instance of the <code class="Code-In-Text--PACKT-">Tree</code> class will result in the <code class="Code-In-Text--PACKT-">Base class is Plant. I am a Tree class</code> string being returned. There are times when we want to prevent a subclass from overriding the properties and methods. There are also times when we want to prevent an entire class from being subclassed. Let's see how we can do this.</p>
    <h2 id="_idParaDest-180" class="title">Preventing overrides</h2>
    <p class="normal">To prevent overrides <a id="_idIndexMarker407"/>or subclassing, we can use the <code class="Code-In-Text--PACKT-">final</code> keyword. To use the <code class="Code-In-Text--PACKT-">final</code> keyword, we add it before the item's definition. Examples are <code class="Code-In-Text--PACKT-">final func</code>, <code class="Code-In-Text--PACKT-">final var</code>, and <code class="Code-In-Text--PACKT-">final class</code>. Any attempt to override an item marked with this keyword will result in a compile-time error.</p>
    <h1 id="_idParaDest-181" class="title">Protocols</h1>
    <p class="normal">There are times when <a id="_idIndexMarker408"/>we would like to describe the implementations (methods, properties, and other requirements) of a type without actually providing any implementation. For this, we can use protocols. Protocols define a blueprint of methods, properties, and other requirements for a class or a structure. A class or a structure can then provide an implementation that conforms to those requirements. The class or structure that provides the implementation is said to conform to the protocol. Protocols are very important to the Swift language. The entire Swift standard library is based on them, and we will be looking at protocols and how to use them in <em class="chapterRef">Chapter 9</em>, <em class="italic">Protocols and Protocol Extensions</em>, and <em class="chapterRef">Chapter 10</em>, <em class="italic">Protocol Oriented Design</em>.</p>
    <h2 id="_idParaDest-182" class="title">Protocol syntax</h2>
    <p class="normal">The syntax to define a<a id="_idIndexMarker409"/> protocol is very similar to how we define a class or a structure. The following example shows the syntax that's used to define a protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">MyProtocol</span><span class="hljs-class"> </span>{
<span class="hljs-comment">    //protocol definition here</span>
}
</code></pre>
    <p class="normal">We state that a class or structure conforms to a protocol by placing the name of the protocol after the type's name, separated by a colon. Here is an example of how we would state that a structure conforms to the <code class="Code-In-Text--PACKT-">MyProtocol</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MyStruct</span><span class="hljs-class">: </span><span class="hljs-title">MyProtocol</span><span class="hljs-class"> </span>{
<span class="hljs-comment">    // Structure implementation here</span>
}
</code></pre>
    <p class="normal">A type can conform to multiple protocols. We list the protocols that the type conforms to by separating them with commas. The following example shows how we would state that our structure conforms to multiple protocols:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MyStruct</span><span class="hljs-class">: </span><span class="hljs-title">MyProtocol</span><span class="hljs-class">, </span><span class="hljs-title">AnotherProtocol</span><span class="hljs-class">, </span><span class="hljs-title">ThirdProtocol</span><span class="hljs-class"> </span>{
<span class="hljs-comment">    // Structure implementation here</span>
}
</code></pre>
    <p class="normal">If we need a class to both inherit from a superclass and implement a protocol, we would list the superclass first, followed by the protocols. The following example illustrates this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass</span><span class="hljs-class">: </span><span class="hljs-title">MySuperClass</span><span class="hljs-class">, </span><span class="hljs-title">MyProtocol</span><span class="hljs-class">, </span><span class="hljs-title">MyProtocol2</span><span class="hljs-class"> </span>{
<span class="hljs-comment">    // Class implementation here</span>
}
</code></pre>
    <h2 id="_idParaDest-183" class="title">Property requirements</h2>
    <p class="normal">A protocol can require that the <a id="_idIndexMarker410"/>conforming type provides certain properties with a specified name and type. The protocol does not say whether the property should be a stored or computed property because the implementation details are left up to the conforming type. When defining a property within a protocol, we must specify whether the property is a read-only or read-write property by using the <code class="Code-In-Text--PACKT-">get</code> and <code class="Code-In-Text--PACKT-">set</code> keywords. Let's look at how we would define properties within a protocol by creating a protocol named <code class="Code-In-Text--PACKT-">FullName</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">FullName</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> firstName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">var</span> lastName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">FullName</code> protocol defines two properties, which any type that conforms to the protocol must implement. These are the <code class="Code-In-Text--PACKT-">firstName</code> and <code class="Code-In-Text--PACKT-">lastName</code> properties, and both are read-write properties. If we wanted to specify that the property is read-only, we would define it with only the <code class="Code-In-Text--PACKT-">get</code> keyword, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> readOnly: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
</code></pre>
    <p class="normal">Let's see how we can create a <code class="Code-In-Text--PACKT-">Scientist</code> class that conforms to this protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Scientist</span><span class="hljs-class">: </span><span class="hljs-title">FullName</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName = ""
    <span class="hljs-keyword">var</span> lastName = ""
}
</code></pre>
    <p class="normal">If we had forgotten to include either of the required properties, we would have received an error message letting us know the property we forgot. We also need to make sure that the type of the property is the same. For example, if we change the definition of the <code class="Code-In-Text--PACKT-">lastName</code> property in the <code class="Code-In-Text--PACKT-">Scientist</code> class to <code class="Code-In-Text--PACKT-">var lastName = 42</code>, we will also receive an error message because the protocol specifies that we must have a <code class="Code-In-Text--PACKT-">lastName</code> property of the string type.</p>
    <h2 id="_idParaDest-184" class="title">Method requirements</h2>
    <p class="normal">A protocol can require that the<a id="_idIndexMarker411"/> conforming class or structure provides certain methods. We define a method within a protocol exactly as we do within a class or structure, except without the method body. Let's add a <code class="Code-In-Text--PACKT-">fullName()</code> method to our <code class="Code-In-Text--PACKT-">FullName</code> protocol and <code class="Code-In-Text--PACKT-">Scientist</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">FullName</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> firstName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">var</span> lastName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">fullName</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span>
}
</code></pre>
    <p class="normal">Now, we need to add a <code class="Code-In-Text--PACKT-">fullName()</code> method to our <code class="Code-In-Text--PACKT-">Scientist</code> class so that it will conform to the protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Scientist</span><span class="hljs-class">: </span><span class="hljs-title">FullName</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> field = <span class="hljs-string">""</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">fullName</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"\(firstName) \(lastName) studies \(field)"</span>
    }
}
</code></pre>
    <p class="normal">Structures can conform to Swift protocols exactly as classes do. In fact, the majority of the Swift standard library<a id="_idIndexMarker412"/> are structures that implement the various protocols that make up the standard library. The following example shows how we can create a <code class="Code-In-Text--PACKT-">FootballPlayer</code> structure that also conforms to the <code class="Code-In-Text--PACKT-">FullName</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">FootballPlayer</span><span class="hljs-class">: </span><span class="hljs-title">FullName</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span> 
    <span class="hljs-keyword">var</span> number = <span class="hljs-number">0</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">fullName</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"\(firstName) \(lastName) has the number \(number)"</span>
    }
}
</code></pre>
    <p class="normal">When a class or structure conforms to a Swift protocol, we can be sure that it has implemented the required properties and methods. This can be very useful when we want to ensure that certain properties or methods are implemented over various classes, as our preceding examples show. Protocols are also very useful when we want to decouple our code from requiring specific types. The following code shows how we would decouple our code using the <code class="Code-In-Text--PACKT-">FullName</code> protocol, the <code class="Code-In-Text--PACKT-">Scientist</code> class, and the <code class="Code-In-Text--PACKT-">FootballPlayer</code> structure that we have already built:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> scientist = <span class="hljs-type">Scientist</span>() 
scientist.firstName = <span class="hljs-string">"Kara"</span> 
scientist.lastName = <span class="hljs-string">"Hoffman"</span> 
scientist.field = <span class="hljs-string">"Physics"</span>
<span class="hljs-keyword">var</span> player = <span class="hljs-type">FootballPlayer</span>()
player.firstName = <span class="hljs-string">"Dan"</span>
player.lastName = <span class="hljs-string">"Marino"</span>
player.number = <span class="hljs-number">13</span>
<span class="hljs-keyword">var</span> person: <span class="hljs-type">FullName</span>
person = scientist
<span class="hljs-built_i">print</span>(person.fullName()) 
person = player 
<span class="hljs-built_i">print</span>(person.fullName())
</code></pre>
    <p class="normal">In the preceding code, we<a id="_idIndexMarker413"/> begin by creating an instance of the <code class="Code-In-Text--PACKT-">Scientist</code> class and the <code class="Code-In-Text--PACKT-">FootballPlayer</code> structure. We then create a <code class="Code-In-Text--PACKT-">person</code> variable that is of the <code class="Code-In-Text--PACKT-">FullName (protocol)</code> type and set it to the <code class="Code-In-Text--PACKT-">scientist</code> instance that we just created. We then call the <code class="Code-In-Text--PACKT-">fullName()</code> method to retrieve our description. This will print out the <code class="Code-In-Text--PACKT-">Kara Hoffman studies Physics</code> message to the console. We then set the <code class="Code-In-Text--PACKT-">person</code> variable equal to the <code class="Code-In-Text--PACKT-">player</code> instance and call the <code class="Code-In-Text--PACKT-">fullName()</code> method again. This will print out the <code class="Code-In-Text--PACKT-">Dan Marino has the number 13</code> message to the console. As we can see, the <code class="Code-In-Text--PACKT-">person</code> variable does not care what the actual implementation type is. Since we defined the <code class="Code-In-Text--PACKT-">person</code> variable to be of the <code class="Code-In-Text--PACKT-">FullName</code> type, we can set the variable<a id="_idIndexMarker414"/> to an instance of any type that conforms to the <code class="Code-In-Text--PACKT-">FullName</code> protocol. This is called polymorphism. We will cover polymorphism and protocols more in <em class="chapterRef">Chapter 9</em>, <em class="italic">Protocols and Protocol Extensions</em>, and <em class="chapterRef">Chapter 10</em>, <em class="italic">Protocol Oriented Design</em>.</p>
    <h1 id="_idParaDest-185" class="title">Extensions</h1>
    <p class="normal">With extensions, we can add<a id="_idIndexMarker415"/> new properties, methods, initializers, and subscripts, or make an existing type conform to a protocol without modifying the source code for the type. One thing to note is that extensions cannot override the existing functionality. To define an extension, we use the <code class="Code-In-Text--PACKT-">extension</code> keyword, followed by the type that we are extending.</p>
    <p class="normal">The following example shows how we would create an extension that extends the <code class="Code-In-Text--PACKT-">string</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">extension</span><span class="hljs-class"> </span><span class="hljs-title">String</span><span class="hljs-class"> </span>{
<span class="hljs-comment">    //add new functionality here</span>
}
</code></pre>
    <p class="normal">Let's see how extensions <a id="_idIndexMarker416"/>work by adding a <code class="Code-In-Text--PACKT-">reverse()</code> method and a <code class="Code-In-Text--PACKT-">firstLetter</code> property to Swift's standard <code class="Code-In-Text--PACKT-">string</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">extension</span><span class="hljs-class"> </span><span class="hljs-title">String</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> firstLetter: <span class="hljs-type">Character?</span> { 
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.first
        }
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">reverse</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">var</span> <span class="hljs-built_i">reverse</span> = <span class="hljs-string">""</span>
        <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-built_i">reverse</span> = <span class="hljs-string">"\(letter)"</span> + <span class="hljs-built_i">reverse</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_i">reverse</span>
    }
}
</code></pre>
    <p class="normal">When we extend an existing type, we define properties, methods, initializers, subscripts, and protocols in exactly the same way as we would normally define them in a standard class or structure. In the string extension example, we can see that we define the <code class="Code-In-Text--PACKT-">reverse()</code> method and the <code class="Code-In-Text--PACKT-">firstLetter</code> property exactly as we would define them in a normal type. We can then use these methods exactly as we would use any other method, as the following example shows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myString = <span class="hljs-string">"Learning Swift is fun"</span> 
<span class="hljs-built_i">print</span>(myString.<span class="hljs-built_i">reverse</span>()) 
<span class="hljs-built_i">print</span>(myString.firstLetter!)
</code></pre>
    <p class="normal">Swift 4 did add the <code class="Code-In-Text--PACKT-">reversed()</code> method to the string type, which should be preferred over the one we created here. This example just illustrates how to use extensions. Extensions are very useful for adding extra functionality to an existing type from external frameworks, even for Apple's frameworks, as demonstrated in this example. It is preferred to use extensions to add extra functionality to types from external frameworks rather <a id="_idIndexMarker417"/>than subclassing, because it allows us to continue to use the type throughout our code rather than changing the type to the subclass. Before we finish this chapter, let's take another look at optional chaining now that we have an understanding of classes and structures.</p>
    <h1 id="_idParaDest-186" class="title">Property wrappers</h1>
    <p class="normal">Property wrappers<a id="_idIndexMarker418"/> were introduced in Swift 5.1 with SE-0258 and they enable property values to be wrapped using a custom type. In order to perform this wrapping, we must create a custom attribute and a type that will handle the attribute. To see an example of this, let's say that we want to trim all of the whitespace characters from the beginning and the ending of our string values. We could do this by using the getter and setter methods of our properties to trim the whitespace characters; however, we would have to put this logic in for each property that we wanted to trim. With property wrappers, we would do this much more easily. We will start off by creating our custom type that will be used as a wrapper; we will name it Trimmed:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@propertyWrapper</span>
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Trimmed</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> str: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">get</span> { str }
        <span class="hljs-keyword">set</span> { str = newValue.trimmingCharacters(<span class="hljs-keyword">in</span>: .whitespacesAndNewlines) }
    }
    <span class="hljs-keyword">init</span>(wrappedValue: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.wrappedValue = wrappedValue
    }
}
</code></pre>
    <p class="normal">The previous code starts off by using the @propertyWrapper attribute to define that this type can be used as a property wrapper. Any type that is defined as a property wrapper must have a non-static property named wrappedValue, which we define as a <code class="Code-In-Text--PACKT-">String</code> type within our Trimmed type. Finally, we create an initializer that is used to set the wrappedValue property.</p>
    <p class="normal">If we look back at the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure that we created earlier in the chapter, we defined two <code class="Code-In-Text--PACKT-">String</code> properties like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span>
<span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span>
</code></pre>
    <p class="normal">If we wanted to trim all of the<a id="_idIndexMarker419"/> whitespaces from the beginning and ending of these properties, all we would need to do now is to add an @Trimmed attribute to them like this:</p>
    <pre class="programlisting code"><code class="hljs-code">@<span class="hljs-type">Trimmed</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">""</span>
@<span class="hljs-type">Trimmed</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">""</span>
</code></pre>
    <p class="normal">Now if we created new instances of the <code class="Code-In-Text--PACKT-">EmployeeStruct</code> structure like this (notice the spaces in the initializer):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> employee1 = <span class="hljs-type">EmployeeStruct</span>(firstName: " <span class="hljs-type">Jon</span> <span class="hljs-string">", lastName: "</span> <span class="hljs-type">Hoffman</span> <span class="hljs-string">")</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">firstName</code> and <code class="Code-In-Text--PACKT-">lastName</code> properties will contain the values with the whitespace characters automatically removed.</p>
    <h1 id="_idParaDest-187" class="title">Optional chaining</h1>
    <p class="normal">Optional binding allows<a id="_idIndexMarker420"/> us to unwrap one optional at a time, but what would happen if we had optional types embedded within other optional types? This would force us to have optional binding statements embedded within other optional binding statements. There is a better way to handle this: by using optional chaining. Before we look at optional chaining, let's see how this would work with optional binding. We will start off by defining three types that we will be using for our examples in this section:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Collar</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> color: <span class="hljs-type">String</span>
    <span class="hljs-keyword">init</span>(color: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.color = color
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Pet</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> collar: <span class="hljs-type">Collar?</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Person</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> pet: <span class="hljs-type">Pet?</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
    }
}
</code></pre>
    <p class="normal">In this example, we begin by defining a <code class="Code-In-Text--PACKT-">Collar</code> class, which has one property defined. This property is named <code class="Code-In-Text--PACKT-">color</code>, which is of the string type. We can see that the <code class="Code-In-Text--PACKT-">color</code> property is not an optional; therefore, we can safely assume that it will always have a valid value. Next, we define a <code class="Code-In-Text--PACKT-">Pet</code> class that has two properties defined. These properties are named <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">collar</code>. The <code class="Code-In-Text--PACKT-">name</code> property is of the string type and the <code class="Code-In-Text--PACKT-">collar</code> property is an optional that <a id="_idIndexMarker421"/>may contain an instance of the <code class="Code-In-Text--PACKT-">Collar</code> type or may contain no value. Finally, we define a <code class="Code-In-Text--PACKT-">Person</code> class, which also has two properties. These properties are named <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">pet</code>. The <code class="Code-In-Text--PACKT-">name</code> property is of the string type and the <code class="Code-In-Text--PACKT-">pet</code> property is an optional that may contain an instance of the <code class="Code-In-Text--PACKT-">Pet</code> type or may contain no value. For the examples that follow, let's use the following code to initialize the classes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> jon = <span class="hljs-type">Person</span>(name: <span class="hljs-string">"Jon"</span>)
<span class="hljs-keyword">var</span> buddy = <span class="hljs-type">Pet</span>(name: <span class="hljs-string">"Buddy"</span>)
jon.pet = buddy
<span class="hljs-keyword">var</span> collar = <span class="hljs-type">Collar</span>(color: <span class="hljs-string">"red"</span>)
buddy.collar = collar
</code></pre>
    <p class="normal">Now, let's say that we want to get the color of the collar for a person's pet; however, the person may not have a pet (the <code class="Code-In-Text--PACKT-">pet</code> property may be <code class="Code-In-Text--PACKT-">nil</code>) or the pet may not have a collar (the <code class="Code-In-Text--PACKT-">collar</code> property may be <code class="Code-In-Text--PACKT-">nil</code>). We could use optional binding to drill down through each layer, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> tmpPet = jon.pet, let tmpCollar = tmpPet.collar { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"The color of the collar is \(tmpCollar.color)"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Cannot retrieve color"</span>)
}
</code></pre>
    <p class="normal">While this example is perfectly valid and would print out a <code class="Code-In-Text--PACKT-">The color of the collar is red</code> message, the code is rather messy and hard to follow because we have multiple optional binding statements on the same line, where the second optional binding statement is dependent on the first one. Optional chaining allows us to drill down through multiple optional type layers of properties, methods, and subscripts in one line of code. These layers <a id="_idIndexMarker422"/>can be chained together and if any layer returns <code class="Code-In-Text--PACKT-">nil</code>, the entire chain gracefully fails and returns <code class="Code-In-Text--PACKT-">nil</code>. If none of the values returns <code class="Code-In-Text--PACKT-">nil</code>, the last value of the chain is returned. Since the results of optional chaining may be a <code class="Code-In-Text--PACKT-">nil</code> value, the results are always returned as an optional type, even if the final value we are retrieving is a non-optional type. To specify optional chaining, we place a question mark (<code class="Code-In-Text--PACKT-">?</code>) after each of the optional values within the chain. The following example shows how to use optional chaining to make the preceding example much cleaner and easier to read:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> color = jon.pet?.collar?.color { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"The color of the collar is \(color)"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Cannot retrieve color"</span>)
}
</code></pre>
    <p class="normal">In this example, we put a question mark after the <code class="Code-In-Text--PACKT-">pet</code> and <code class="Code-In-Text--PACKT-">collar</code> properties to signify that they are of the optional type and that, if either value is <code class="Code-In-Text--PACKT-">nil</code>, the whole chain will return <code class="Code-In-Text--PACKT-">nil</code>. This code would also print out the <code class="Code-In-Text--PACKT-">The color of the collar is red</code> message; however, it is much easier to read than the preceding example because it clearly shows us what optionals we are dependent on.</p>
    <h1 id="_idParaDest-188" class="title">Summary</h1>
    <p class="normal">In this chapter, we took an in-depth look at classes and structures. We saw what makes them so similar and also what makes them so different. In the upcoming chapters, it will be important to remember that classes are reference types while structures are value types. We also looked at protocols and extensions. As this chapter ends, we end the introduction to the Swift programming language. At this point, we have enough knowledge of the Swift language to begin writing our own applications; however, there is still much to learn. In the following chapters, we will look in more depth at some of the concepts that we've already discussed, such as protocols and subscripts. We will also see how we can use protocol-oriented programming techniques to write easy-to-manage code. Finally, we will have chapters that will help us write better code, such as a sample Swift style guide, and a chapter on design patterns.</p>
  </div>
</body></html>