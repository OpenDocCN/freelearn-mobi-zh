- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Unity Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a game is a wonderful experience and a lot of hard work, but when designing
    projects, you have to rely on your experience and gut feelings in order to make
    it as awesome as possible. Often, in the game industry, we will use playtesting
    – a process where select people play a game and give feedback, and then we use
    the feedback we receive to improve the project.
  prefs: []
  type: TYPE_NORMAL
- en: This playtesting is most often done in person; however, by creating games for
    mobile, a lot of people will be playing your game after release, and most of them
    will have an internet connection. With this combination of people playing the
    game and also being online, we can send data about how the game is being played
    to ourselves. This will still allow us to do playtesting with a large variety
    of people. Being able to look at our data will allow us to check whether the choices
    that are made to change the game are the right ones, and we will be able to make
    adjustments to our games on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: This data could be about something as simple as where players tend to die in
    the game or things such as how often they come back to play, the daily average
    time they spend playing, the number of users we have at a time, how long people
    play the game before stopping, and what choices they made. Over the course of
    this chapter, we will learn how to become able to learn what our users are doing
    through the use of Unity’s Gaming Services platform and built-in Analytics system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover a number of topics. The chapter itself is a simple
    step-by-step process from beginning to end. Here is an outline of our tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Unity Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Funnel Analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweaking properties with Remote Config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the *Unity Editor system requirements* section. To deploy your project, you
    will need an Android or iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we activated the Analytics option from Unity Gaming Services in order
    to use Unity’s Ads system in [*Chapter 7*](B18868_07.xhtml#_idTextAnchor232) *Advertising
    Using Unity Ads*, we didn’t really dig deep into the system itself. Let’s finish
    the setup for that now using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we need to install the Unity Analytics package in our project. We
    can do so by returning to the Unity Editor and opening the package manager, by
    going to **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is a bug with the version of Unity this book was written for, with the
    Analytics package not showing up by default; instead, Unity shows the legacy Analytics
    Library package. However, it is possible to add the new package by clicking on
    the `com.unity.services.analytics`. If all goes well, you should be able to see
    that the Analytics package has been installed correctly by checking the **Package**
    **Manager** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1: Analytics attached](img/B18868_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Analytics attached'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to initialize the SDK and ensure that consent is given by our
    users to log events that they cause to happen. To do this, we will need to write
    some code.
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Scripts` folder and create a new C# script, naming it `AnalyticsManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on the newly added script to open it with the code editor of your
    choice, and use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and return to the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the minimum amount of code that is required for us to be able to initialize
    the SDK, as well as for us to be able to send events to Unity Gaming Services.
  prefs: []
  type: TYPE_NORMAL
- en: Note that several keywords here haven’t been utilized previously. For instance,
    our `Start` function has `async` before the return type. Likewise, there’s also
    `await` before two function calls. Here, we’re utilizing something called asynchronous
    programming. The `await` keyword allows us to wait for the `async` method until
    it returns a value. So, the main application thread stops there until it receives
    a return value. If we did not use the `await` keyword, the next function would
    be called immediately afterward, and since we need the result to be figured out
    before we can continue, that’s why we’re utilizing it. The `async` keyword enables
    the `await` keyword. So, any method using `await` must be marked `async`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more info on `async` and `await`, check out the official MSDN docs at [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, note that we have a `try` and `catch` block. When we use `try`
    and then a block of code, we are noting that there is a possibility that the code
    that we are putting inside of there has a chance of failure. For example, it’s
    possible that there could be an exception that is thrown. If an exception of type
    `ConsentCheckException` is caught during the execution of the `try` block, it
    means something went wrong with the consent check.
  prefs: []
  type: TYPE_NORMAL
- en: If that were to happen normally, Unity would throw an error to the console.
    The code within the `catch` block handles this exceptional situation. The `catch`
    block is where, instead of throwing an error to the console and causing issues
    in the game, this is a way for us to attempt to remedy the situation instead.
    In our case, we would want to handle how we would run our game without using Unity
    Services, which would likely mean that we just wouldn’t log events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more info on `try` and `catch`, check out the official MSDN docs at [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just having this code doesn’t do anything. We have to actually run
    it. So to do that, we’re going to need to add the script to an object. And for
    ease of use, we’re going to create a new object to attach this to.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Unity Editor, create an empty game object by going to `Analytics
    Manager`, reset its position, and then add the Analytics Manager script to that
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2: The Analytics Manager setup](img/B18868_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The Analytics Manager setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as **Analytics** is enabled, the Editor sends an App Start event to
    the Analytics service when we press the **Play** button to start the game:'
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about this is that we can ensure that this feature works correctly
    without having to export our game. However, this message is not shown to us by
    default. We can enable logging to the Editor console to allow us some extra visibility
    while we are experimenting by enabling a scripting define symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Go to `UNITY_ANALYTICS_EVENT_LOGS`. Once completed, hit the **Apply** button
    and wait for it to finish compiling scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, your scripting define symbols disappear on the Android
    platform, switching to the PC settings and putting the value in first seems to
    correct the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the project and run the game. If all goes well, you should see the events
    appear in the **Console** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3: The console receiving our default events](img/B18868_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The console receiving our default events'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this working, we can go check to see if the events are happening
    via the game side.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the top bar of Unity go to **Services** | **General Settings**. From there
    go to **Analytics – Gaming Services** and then click on **Go to Dashboard**. Once
    there click on the **Event Browser** button, you should see the most recent 100
    events that Unity has received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4: The Event Browser page](img/B18868_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: The Event Browser page'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Unity Analytics set up, let’s start creating our own custom
    events to track!
  prefs: []
  type: TYPE_NORMAL
- en: Tracking custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity Analytics does a number of different things automatically to make it easy
    to work with. However, as a game designer, you may often want to check whether
    certain aspects of a game are being used or whether players are reaching certain
    pieces of content. To keep track of this, we can make use of the **custom** **events**
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Custom events are pieces of data that users send to the cloud as they play a
    game. Each custom event can have its own parameters, which will allow us to filter
    the data that we send when it is generated. We will discuss how you can send information
    over the cloud through the use of code.
  prefs: []
  type: TYPE_NORMAL
- en: Sending basic CustomEvents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first kind of event we are going to send is just an event name. This can
    be used for something such as tracking the number of times people access a certain
    place or checking whether something invalid appears to be happening. To make it
    easy to trigger and track for testing purposes, we will cause an event to happen
    each time a game is paused. Let’s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PauseScreenBehaviour` script and add the following `using` statement
    to the top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This namespace contains all of the functions used by Unity’s Analytics system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SetPauseMenu` function to include the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will call the `AnalyticsService.Instance.CustomData` function when
    `pauseMenu` has been turned on. The first parameter of `AnalyticsService.Instance.CustomData`
    is a string, which is the name that you wish the event to have. This name will
    be used within Unity Analytics. Events are automatically sent every 60 seconds
    if there’s an internet connection available. However, if you want to immediately
    upload all recorded events to the server, there’s also the `AnalyticsService.Instance.Flush`
    function, which will immediately upload the events when called.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and then return to the Unity Editor. Once there, play the game
    and then pause it. As you can see, the event was sent over the cloud successfully!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 10.5: Paused events uploaded succes\uFEFFsfully](img/B18868_10_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Paused events uploaded successfully'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, Unity Analytics used to accept any event that you were to send it.
    However, with this new system, you have to actually define the event in the dashboard
    ahead of time, or it will ignore the information. So, we are going to need to
    go to the dashboard and define this event as well before we start seeing it trigger
    in the Event Manager.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, it can take quite some time before information shows up
    on the Unity dashboard, but it’s a good idea at this point to see where this information
    can be received later on.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Dashboard**, go to **Analytics**, and then select **Event Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the place where you can see the custom events and parameters that have
    been received from the game.
  prefs: []
  type: TYPE_NORMAL
- en: From there, select **Add New**, and then select **Custom Event**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6: Adding a new custom event](img/B18868_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Adding a new custom event'
  prefs: []
  type: TYPE_NORMAL
- en: Name the custom event `gamePaused`, spelled exactly the same as we’ve done here,
    for the string that we’ve been passing into the `CustomData` function in the `SetPauseMenu`
    function. We’ll also add an event description of the event for our future reference.
    Afterward, click on the **Create** button, and the event should be ready for us
    to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 10.7: \uFEFFSetting Custom Event Details](img/B18868_10_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Setting Custom Event Details'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, scroll down to the event and double check that the **Enabled** option
    is turned on; otherwise, the events will only show up in the **Invalid Events**
    area of the event browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8: Enabling the event](img/B18868_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Enabling the event'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the Unity Editor and play your game again, triggering the `gamePaused`
    event so that it will show up correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait 15 minutes or so, go back to the event browser, and hit the `gamePaused`
    event there! To make it easier to see, you can also click on the `gamePaused`,
    and then hit the **Apply** button to isolate the event browser to only show those
    events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, it may take some time before the events are updated in the event browser,
    but they should show up eventually.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Our simple custom events in the event browser](img/B18868_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Our simple custom events in the event browser'
  prefs: []
  type: TYPE_NORMAL
- en: Next, click on the **Data** **Explorer** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `gamePaused` event is called.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you have just created the event, it may take up to 12 hours for the information
    to be received. Go ahead and check back later if that’s the case. In the past,
    I’ve had to wait up to even 48 hours for the data, so do not be alarmed if it
    takes a while for it to show up, although I have not had this issue with the newest
    iteration of Unity Gaming Services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **+** button to the left of **Add Event** to add a custom event
    to this graph. Then, select the **Add Event** dropdown and then **gamePaused**.
    Since we have just made the event, we won’t see it on previous dates in Analytics,
    but we can see it a little easier if we click on the **Column Chart** button to
    change how the data is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.10: Add Event](img/B18868_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Add Event'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we scroll down, we can see that `gamePaused` event has been called!
  prefs: []
  type: TYPE_NORMAL
- en: Sending custom events with properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One additional thing that we may want to track is how far players get before
    they lose. Let’s take a look at how to do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Dashboard, first, go to the Event Manager. Click on `gameOver`, and then
    fill in the **Event description** field with something like Records when the players
    causes a game over event to occur. Afterward, click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From there, you’ll be brought to a page for the event. Click on the **Assign
    Parameter** button, and from there, under the **Parameter** dropdown, select **Add**
    **New Parameter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11: Add New Parameter](img/B18868_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Add New Parameter'
  prefs: []
  type: TYPE_NORMAL
- en: For the parameter name, type in `score`, and then fill in a description for
    the parameter. For the parameter type, select **Float**, and then click the **Create**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12: Adding a custom parameter](img/B18868_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Adding a custom parameter'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new event called `gameOver` and a custom parameter, which we will call
    `score` and will be a float. Then, click on the `score`, and then click **Assign**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13: Assigning the score parameter](img/B18868_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Assigning the score parameter'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on the `gameOver` event will be saved when it occurs. Unity will
    ask whether you’re sure you want to enable the event; click on the **Enable**
    button to ensure that it will happen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14: Enabling the event](img/B18868_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Enabling the event'
  prefs: []
  type: TYPE_NORMAL
- en: Now, return to the Unity Editor. First, we will need to open up the `ObstacleBehaviour`
    script to modify what happens when the game ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To utilize Unity Analytics with parameters, at the top of the file, we will
    add the following `using` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The top option is obvious, but we are also adding `System.Collections.Generic`
    in order to get access to the `Dictionary` class, which we will use in the next
    piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will update the `OnCollisionEnter` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve done a number of things within this script. To start off with, we have
    rewritten our check that the player uses the component as a variable now, so we
    don’t have to call `GetComponent` again for the same thing. Aside from that, the
    main addition is the calling of the `AnalyticsService.Instance.CustomData` function
    with a second parameter. The second parameter (which is optional) is a dictionary,
    which we haven’t discussed yet.
  prefs: []
  type: TYPE_NORMAL
- en: A `string` class as the key type so that you can refer to some other data type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on dictionaries, check out [http://csharp.net-informations.com/collection/dictionary.htm](http://csharp.net-informations.com/collection/dictionary.htm).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve wrapped this code in a `try` and `catch` block because if `AnalyticsService.Instance`
    is called and it is `null`, the code written by Unity will throw an exception.
    This will cause the game to break and no longer work. The game currently works
    fine if we start the game from the title screen, but if we start the game from
    the gameplay scene, it will no longer work correctly due to Analytics not being
    initialized. This time, instead of doing nothing like the previous example, I
    added a line to actually print out the message that the error gives us as a warning.
    It’s always a good idea to have our code be as robust as possible, so that’s why
    we added this check.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and return to the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game and lose it. Note in the `gameOver`event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 10.15: A Game Over event being disp\uFEFFatched](img/B18868_10_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: A Game Over event being dispatched'
  prefs: []
  type: TYPE_NORMAL
- en: You can also dive into the dashboard to see the information as well, but Unity
    says it may take up to 6 hours before it becomes visible, although I usually see
    it within 15 minutes or so. You will see the messages instantly in the **Console**
    window, but they don’t populate in Analytics until the backend calculations have
    been processed at Unity’s end, due to all of the events it receives.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve waited, go to the `gameOver` events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To be able to see the value of the `score` parameter we created on the far
    right, click on the button that looks like **<>** to access the JSON event content
    for the particular event. Note that we can see the value of our score here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.16: The score value in the event content](img/B18868_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: The score value in the event content'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we now know how to access events!
  prefs: []
  type: TYPE_NORMAL
- en: This information is formatted in the manner of a JSON file. `Dictionary` class
    that we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: One of the limitations of the event browser is the fact that we are only able
    to see the most recent 100 events. As our project becomes more and more popular,
    it is likely that we’re going to have more and more events. With that in mind,
    we will likely want to have some way to be able to interpret that information.
    One of the ways that we can use do this is through the SQL Data Explorer. This
    allows us to access all the events that are created, but we have to utilize **Structured
    Query Language** (**SQL**), which is a domain-specific language that was created
    to manage data held within a database.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **SQL Data Explorer** button to open the menu. Note that the **Query**
    field contains some default text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17: SQL Data Explorer](img/B18868_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: SQL Data Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Hit the **Run** button to see the default result and how it works. Once the
    query finishes, you’ll be able to create a chart using the data it interpreted
    from this query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get a feel for how this can work with chart data, under **Chart Setup**,
    set **X-axis column** to **EVENT_DATE** and **Y-axis 1 column** to **COUNT(DISTINCT
    USER_ID)**, and then click the **Apply** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.18: Chart Setup](img/B18868_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.18: Chart Setup'
  prefs: []
  type: TYPE_NORMAL
- en: This will allow you to create a chart in a similar manner to what we saw earlier
    with the Data Explorer, but this gives us more fine-tuned control if we want to
    use the power of SQL.
  prefs: []
  type: TYPE_NORMAL
- en: There are entire books out there about SQL for those that are interested in
    exploring it further, but in our case, we want to extract the score values from
    our custom events. Therefore, instead of a chart, we want to create a table so
    that, in addition to writing some custom queries, we can also see how to export
    the data as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Query** field, replace the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code is going to go through every single event and check whether the name
    of the event is `gameOver`. If so, it will isolate the `score` property from it.
    This will allow us to create a list of all of the `score` properties from the
    entire project.
  prefs: []
  type: TYPE_NORMAL
- en: Hit the **Run** button and wait for it to execute. Once done, you’ll see the
    **Share** button on the top has turned blue and you can press it. Once selected,
    click on the **Export as CSV** **file** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CSV** stands for **comma-separated values**. This is a file type that uses
    commas to separate each of the different values that are designated within the
    file, but if you open the file with Google Sheets or Excel, the program will be
    able to parse the file to resemble a nice table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19: The table of score values in Microsoft Excel](img/B18868_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: The table of score values in Microsoft Excel'
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a way to see all the various different score values that our players
    have achieved as they played the game. This can help us see whether people are
    doing well or really poorly, and allow us to cater the game however we’d like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a snippet like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would make it so that instead of the first event just showing
    6.5199995, we would have each of the slots consist of the entirety of the JSON
    data that we discussed earlier – in this case, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By adding `:score::FLOAT`, we get the `score` variable from the JSON data and
    tell the computer to interpret it as a floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: For those that are interested in exploring SQL more, I suggest checking out
    the Unity Gaming Service’s example cookbook at [https://github.com/Unity-Technologies/UGS-SQL-Cookbook](https://github.com/Unity-Technologies/UGS-SQL-Cookbook),
    which contains a collection of common SQL queries and best practices for use with
    Unity Analytics.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is just a simple example, so I would suggest that you create
    custom events for whenever a user reaches an important milestone – for example,
    when they level up or when they make an **In-App** **Purchase** (**IAP**).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to create different types of events, let’s see how we can
    actually track events and learn more about what our players are doing, utilizing
    the Funnel Analyzer tool.
  prefs: []
  type: TYPE_NORMAL
- en: Working with funnels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the many things we’d like to know about our players is how they are actually
    playing a game – for instance, are users skipping our tutorial? To keep track
    of how players proceed through a series of events, we have funnels. Funnels help
    us to identify where player drop-off happens in our game.
  prefs: []
  type: TYPE_NORMAL
- en: If you happen to see a large number of people not getting to a certain step,
    you can assume that something that happened in the preceding step causes people
    to stop playing our game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how funnels work as well as why you’d want to use them,
    check out [https://data36.com/funnel-analysis/](https://data36.com/funnel-analysis/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Funnels are based on the concept of custom events, which we used in the *Sending
    custom events with properties* section of this chapter. We can use the Funnels
    tool (previously known as the Funnel Analyzer) to look at the data sent via these
    funnels, which we can then use to make educated decisions on what changes should
    be made to the game. Follow the steps given here to add the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the dashboard, go to **Analytics** and select **Funnels**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.20: The Funnels page](img/B18868_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: The Funnels page'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, there are no funnels set up, so we should create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **+ New Funnel** button and fill in the details, as shown in the
    following screenshot. Then, scroll all the way down and click on the **Apply**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.21: Funnels setup](img/B18868_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.21: Funnels setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve played the game already, you can see the results from the events
    that have already triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22: The event trigger results](img/B18868_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.22: The event trigger results'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we have played the game and lost, so we currently have a 100% completion
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll up to the top page and click on the **Save Funnel** button. Give the
    funnel a name, describe what it is you’re creating, and then hit the **Save**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 10.23: The\uFEFF funnel setup](img/B18868_10_23.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.23: The funnel setup'
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to select that funnel, and it will provide information on
    all the times it has been called.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts used here can easily be expanded upon in other ways as well, such
    as keeping track of how often users watch ads or make purchases in the game and
    what causes them to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Funnels are great when a game is working correctly, but if the game crashes,
    it’s also possible to get analytics from that as well from Unity Cloud Diagnostics.
    For information on that as well as how to set it up, check out [https://docs.unity.com/cloud-diagnostics/en/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting](https://docs.unity.com/cloud-diagnostics/en/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a number of ways that we can make use of Unity’s
    Analytics tool to make our games better, from how to understand what our players
    are doing to learning how to adjust our game based on that feedback, without users
    having to download an entirely new copy of our game.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we learned how to set up the Unity Analytics section of the Unity
    Editor, and then we saw how we can make use of code to create events to be sent
    to the cloud for us to look at. With the given data, we learned how we could make
    use of funnels and the Funnel Analyzer to learn more about our players.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to create events, let’s see one of the other main
    benefits of utilizing Unity Gaming Services – being able to change projects using
    the Remote Config feature, which we will learn more about in the next chapter.
  prefs: []
  type: TYPE_NORMAL
