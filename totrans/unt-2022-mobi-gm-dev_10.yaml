- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Using Unity Analytics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity分析
- en: Making a game is a wonderful experience and a lot of hard work, but when designing
    projects, you have to rely on your experience and gut feelings in order to make
    it as awesome as possible. Often, in the game industry, we will use playtesting
    – a process where select people play a game and give feedback, and then we use
    the feedback we receive to improve the project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏是一次美妙的体验，也是大量的辛勤工作，但在设计项目时，您必须依靠您的经验和直觉来使其尽可能出色。在游戏行业中，我们通常会使用测试游戏——一个选择的人玩游戏并给出反馈的过程，然后我们使用收到的反馈来改进项目。
- en: This playtesting is most often done in person; however, by creating games for
    mobile, a lot of people will be playing your game after release, and most of them
    will have an internet connection. With this combination of people playing the
    game and also being online, we can send data about how the game is being played
    to ourselves. This will still allow us to do playtesting with a large variety
    of people. Being able to look at our data will allow us to check whether the choices
    that are made to change the game are the right ones, and we will be able to make
    adjustments to our games on the fly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试游戏通常是在现场进行的；然而，通过为移动设备创建游戏，发布后会有很多人玩游戏，并且他们中的大多数都有互联网连接。有了这种玩游戏和在线的组合，我们可以将有关游戏如何被玩的数据发送给我们自己。这仍然允许我们进行针对大量不同人群的测试游戏。能够查看我们的数据将使我们能够检查做出改变游戏的选择是否正确，并且我们能够即时调整我们的游戏。
- en: This data could be about something as simple as where players tend to die in
    the game or things such as how often they come back to play, the daily average
    time they spend playing, the number of users we have at a time, how long people
    play the game before stopping, and what choices they made. Over the course of
    this chapter, we will learn how to become able to learn what our users are doing
    through the use of Unity’s Gaming Services platform and built-in Analytics system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可能关于玩家在游戏中倾向于在哪里死亡这样简单的事情，或者像他们多久回来玩一次、每天平均玩游戏的时间、同时有多少用户、人们在停止游戏前玩了多久以及他们做出的选择这样的事情。在本章的整个过程中，我们将学习如何通过使用Unity的Gaming
    Services平台和内置分析系统来了解用户的行为。
- en: 'This chapter will cover a number of topics. The chapter itself is a simple
    step-by-step process from beginning to end. Here is an outline of our tasks:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖多个主题。本章本身是一个从开始到结束的简单步骤过程。以下是我们的任务概述：
- en: Setting up Unity Analytics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Unity分析
- en: Tracking custom events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪自定义事件
- en: Working with the Funnel Analyzer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用漏斗分析器
- en: Tweaking properties with Remote Config
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程配置调整属性
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the *Unity Editor system requirements* section. To deploy your project, you
    will need an Android or iOS device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Unity 2022.1.0b16和Unity Hub 3.3.1，但步骤应该在未来编辑器的版本中只需进行最小改动即可。如果您想下载本书中使用的确切版本，并且有新版本发布，您可以访问Unity的下载存档[https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive)。您还可以在*Unity编辑器系统要求*部分找到Unity的系统要求[https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)。要部署您的项目，您需要一个Android或iOS设备。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中提供的代码文件[https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter10)。
- en: Setting up Analytics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置分析
- en: 'Although we activated the Analytics option from Unity Gaming Services in order
    to use Unity’s Ads system in [*Chapter 7*](B18868_07.xhtml#_idTextAnchor232) *Advertising
    Using Unity Ads*, we didn’t really dig deep into the system itself. Let’s finish
    the setup for that now using the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已从 Unity 游戏服务中激活了 Analytics 选项，以便在 [*第 7 章*](B18868_07.xhtml#_idTextAnchor232)
    *使用 Unity Ads 进行广告* 中使用 Unity 的广告系统，但我们并没有真正深入到该系统本身。现在让我们按照以下步骤完成该设置的设置：
- en: To start, we need to install the Unity Analytics package in our project. We
    can do so by returning to the Unity Editor and opening the package manager, by
    going to **Window** | **Package Manager**.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的项目中安装 Unity Analytics 包。我们可以通过返回 Unity 编辑器并打开包管理器来实现，方法是转到 **窗口**
    | **包管理器**。
- en: 'There is a bug with the version of Unity this book was written for, with the
    Analytics package not showing up by default; instead, Unity shows the legacy Analytics
    Library package. However, it is possible to add the new package by clicking on
    the `com.unity.services.analytics`. If all goes well, you should be able to see
    that the Analytics package has been installed correctly by checking the **Package**
    **Manager** window:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这本书所使用的 Unity 版本存在一个错误，Analytics 包默认不会显示；相反，Unity 会显示遗留的 Analytics 库包。然而，可以通过点击
    `com.unity.services.analytics` 来添加新包。如果一切顺利，你应该能够通过检查 **包** **管理器** 窗口来确认 Analytics
    包已正确安装：
- en: '![Figure 10.1: Analytics attached](img/B18868_10_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：附加了 Analytics](img/B18868_10_01.jpg)'
- en: 'Figure 10.1: Analytics attached'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：附加了 Analytics
- en: The next step is to initialize the SDK and ensure that consent is given by our
    users to log events that they cause to happen. To do this, we will need to write
    some code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是初始化 SDK 并确保我们的用户同意记录他们引起的事件。为此，我们需要编写一些代码。
- en: From the `Assets/Scripts` folder and create a new C# script, naming it `AnalyticsManager`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Scripts` 文件夹创建一个新的 C# 脚本，命名为 `AnalyticsManager`。
- en: 'Double-click on the newly added script to open it with the code editor of your
    choice, and use the following code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新添加的脚本，使用您选择的代码编辑器打开它，并使用以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the script and return to the Unity Editor.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到 Unity 编辑器。
- en: This is the minimum amount of code that is required for us to be able to initialize
    the SDK, as well as for us to be able to send events to Unity Gaming Services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是初始化 SDK 以及向 Unity 游戏服务发送事件所需的最少代码量。
- en: Note that several keywords here haven’t been utilized previously. For instance,
    our `Start` function has `async` before the return type. Likewise, there’s also
    `await` before two function calls. Here, we’re utilizing something called asynchronous
    programming. The `await` keyword allows us to wait for the `async` method until
    it returns a value. So, the main application thread stops there until it receives
    a return value. If we did not use the `await` keyword, the next function would
    be called immediately afterward, and since we need the result to be figured out
    before we can continue, that’s why we’re utilizing it. The `async` keyword enables
    the `await` keyword. So, any method using `await` must be marked `async`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有几个关键词之前尚未使用过。例如，我们的 `Start` 函数在返回类型前有 `async`。同样，在两个函数调用之前也有 `await`。在这里，我们正在使用一种称为异步编程的东西。`await`
    关键字允许我们在 `async` 方法返回值之前等待。因此，主应用程序线程在那里停止，直到它收到返回值。如果我们没有使用 `await` 关键字，下一个函数将立即调用，由于我们需要在继续之前计算出结果，这就是为什么我们使用它的原因。`async`
    关键字启用了 `await` 关键字。因此，任何使用 `await` 的方法都必须标记为 `async`。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more info on `async` and `await`, check out the official MSDN docs at [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `async` 和 `await` 的更多信息，请查看官方 MSDN 文档，网址为 [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)。
- en: In addition, note that we have a `try` and `catch` block. When we use `try`
    and then a block of code, we are noting that there is a possibility that the code
    that we are putting inside of there has a chance of failure. For example, it’s
    possible that there could be an exception that is thrown. If an exception of type
    `ConsentCheckException` is caught during the execution of the `try` block, it
    means something went wrong with the consent check.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们有一个`try`和`catch`块。当我们使用`try`然后是一段代码块时，我们是在指出我们放在那里的代码有可能失败。例如，可能抛出一个异常。如果在执行`try`块期间捕获到类型为`ConsentCheckException`的异常，这意味着同意检查出了问题。
- en: If that were to happen normally, Unity would throw an error to the console.
    The code within the `catch` block handles this exceptional situation. The `catch`
    block is where, instead of throwing an error to the console and causing issues
    in the game, this is a way for us to attempt to remedy the situation instead.
    In our case, we would want to handle how we would run our game without using Unity
    Services, which would likely mean that we just wouldn’t log events.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种情况正常发生，Unity会向控制台抛出错误。`catch`块中的代码处理这种异常情况。`catch`块是，而不是向控制台抛出错误并导致游戏中的问题，这是我们尝试解决问题的方法。在我们的情况下，我们希望处理不使用Unity服务运行游戏的方式，这可能会意味着我们根本不会记录事件。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more info on `try` and `catch`, check out the official MSDN docs at [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`try`和`catch`的信息，请查看官方MSDN文档：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch)。
- en: Of course, just having this code doesn’t do anything. We have to actually run
    it. So to do that, we’re going to need to add the script to an object. And for
    ease of use, we’re going to create a new object to attach this to.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅有这段代码是没有用的。我们必须实际运行它。所以为了做到这一点，我们需要将脚本添加到一个对象上。为了方便使用，我们将创建一个新的对象来附加这个脚本。
- en: Back in the Unity Editor, create an empty game object by going to `Analytics
    Manager`, reset its position, and then add the Analytics Manager script to that
    object.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，通过转到`Analytics Manager`创建一个空的游戏对象，重置其位置，然后将Analytics Manager脚本添加到该对象上。
- en: '![Figure 10.2: The Analytics Manager setup](img/B18868_10_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：Analytics Manager设置](img/B18868_10_02.jpg)'
- en: 'Figure 10.2: The Analytics Manager setup'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：Analytics Manager设置
- en: 'As long as **Analytics** is enabled, the Editor sends an App Start event to
    the Analytics service when we press the **Play** button to start the game:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只要**Analytics**被启用，当我们按下**播放**按钮开始游戏时，编辑器就会向Analytics服务发送App Start事件：
- en: The nice thing about this is that we can ensure that this feature works correctly
    without having to export our game. However, this message is not shown to us by
    default. We can enable logging to the Editor console to allow us some extra visibility
    while we are experimenting by enabling a scripting define symbol.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个好处在于我们可以确保这个功能能够正确工作，而无需导出我们的游戏。然而，这个消息默认情况下不会显示给我们。我们可以启用编辑器控制台日志记录，通过启用脚本定义符号来允许我们在实验时获得额外的可见性。
- en: Go to `UNITY_ANALYTICS_EVENT_LOGS`. Once completed, hit the **Apply** button
    and wait for it to finish compiling scripts.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`UNITY_ANALYTICS_EVENT_LOGS`。完成后，点击**应用**按钮并等待它完成编译脚本。
- en: Tip
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If, for some reason, your scripting define symbols disappear on the Android
    platform, switching to the PC settings and putting the value in first seems to
    correct the issue.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，你的脚本定义符号在Android平台上消失了，切换到PC设置并将值放入其中似乎可以纠正这个问题。
- en: 'Save the project and run the game. If all goes well, you should see the events
    appear in the **Console** window:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目并运行游戏。如果一切顺利，你应该会在**控制台**窗口中看到事件出现：
- en: '![Figure 10.3: The console receiving our default events](img/B18868_10_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：控制台接收我们的默认事件](img/B18868_10_03.jpg)'
- en: 'Figure 10.3: The console receiving our default events'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：控制台接收我们的默认事件
- en: Now that we have this working, we can go check to see if the events are happening
    via the game side.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使这个功能工作，我们可以检查游戏侧是否发生了事件。
- en: 'From the top bar of Unity go to **Services** | **General Settings**. From there
    go to **Analytics – Gaming Services** and then click on **Go to Dashboard**. Once
    there click on the **Event Browser** button, you should see the most recent 100
    events that Unity has received:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Unity 的顶部栏进入 **服务** | **常规设置**。从那里进入 **分析 – 游戏服务**，然后点击 **转到仪表板**。一旦进入，点击
    **事件浏览器** 按钮，你应该能看到 Unity 收到的最新 100 个事件：
- en: '![Figure 10.4: The Event Browser page](img/B18868_10_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：事件浏览器页面](img/B18868_10_04.jpg)'
- en: 'Figure 10.4: The Event Browser page'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：事件浏览器页面
- en: Now that we have Unity Analytics set up, let’s start creating our own custom
    events to track!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 Unity Analytics，让我们开始创建自己的自定义事件以进行跟踪！
- en: Tracking custom events
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪自定义事件
- en: Unity Analytics does a number of different things automatically to make it easy
    to work with. However, as a game designer, you may often want to check whether
    certain aspects of a game are being used or whether players are reaching certain
    pieces of content. To keep track of this, we can make use of the **custom** **events**
    system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Analytics 自动执行多项不同操作以简化使用。然而，作为一名游戏设计师，你可能经常想要检查游戏的一些方面是否被使用，或者玩家是否到达了某些内容。为了跟踪这些信息，我们可以利用**自定义**
    **事件**系统。
- en: Custom events are pieces of data that users send to the cloud as they play a
    game. Each custom event can have its own parameters, which will allow us to filter
    the data that we send when it is generated. We will discuss how you can send information
    over the cloud through the use of code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事件是用户在玩游戏时发送到云端的片段数据。每个自定义事件都可以有自己的参数，这将允许我们在数据生成时过滤发送的数据。我们将讨论如何通过代码使用云传输信息。
- en: Sending basic CustomEvents
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送基本的自定义事件
- en: 'The first kind of event we are going to send is just an event name. This can
    be used for something such as tracking the number of times people access a certain
    place or checking whether something invalid appears to be happening. To make it
    easy to trigger and track for testing purposes, we will cause an event to happen
    each time a game is paused. Let’s look at the steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要发送的第一种事件只是一个事件名称。这可以用于跟踪人们访问某个地方的次数，或者检查是否出现了无效的情况。为了便于触发和测试跟踪，我们将使每次游戏暂停时发生一个事件。让我们看看步骤：
- en: 'Open the `PauseScreenBehaviour` script and add the following `using` statement
    to the top of the script:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PauseScreenBehaviour` 脚本，并在脚本顶部添加以下 `using` 语句：
- en: '[PRE1]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This namespace contains all of the functions used by Unity’s Analytics system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此命名空间包含 Unity 分析系统使用的所有函数。
- en: 'Update the `SetPauseMenu` function to include the following highlighted code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `SetPauseMenu` 函数以包含以下突出显示的代码：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code will call the `AnalyticsService.Instance.CustomData` function when
    `pauseMenu` has been turned on. The first parameter of `AnalyticsService.Instance.CustomData`
    is a string, which is the name that you wish the event to have. This name will
    be used within Unity Analytics. Events are automatically sent every 60 seconds
    if there’s an internet connection available. However, if you want to immediately
    upload all recorded events to the server, there’s also the `AnalyticsService.Instance.Flush`
    function, which will immediately upload the events when called.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `pauseMenu` 被激活时，此代码将调用 `AnalyticsService.Instance.CustomData` 函数。`AnalyticsService.Instance.CustomData`
    的第一个参数是一个字符串，这是你希望事件拥有的名称。这个名称将在 Unity Analytics 中使用。如果可用网络连接，事件会自动每 60 秒发送一次。然而，如果你想立即上传所有记录的事件到服务器，也有
    `AnalyticsService.Instance.Flush` 函数，它会在调用时立即上传事件。
- en: Save the script and then return to the Unity Editor. Once there, play the game
    and then pause it. As you can see, the event was sent over the cloud successfully!
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，然后返回到 Unity 编辑器。一旦进入，开始玩游戏然后暂停。正如你所见，事件已成功通过云端发送！
- en: "![Figure 10.5: Paused events uploaded succes\uFEFFsfully](img/B18868_10_05.jpg)"
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5：暂停事件成功上传](img/B18868_10_05.jpg)'
- en: 'Figure 10.5: Paused events uploaded successfully'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：暂停事件成功上传
- en: Previously, Unity Analytics used to accept any event that you were to send it.
    However, with this new system, you have to actually define the event in the dashboard
    ahead of time, or it will ignore the information. So, we are going to need to
    go to the dashboard and define this event as well before we start seeing it trigger
    in the Event Manager.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，Unity Analytics 会接受你发送的任何事件。但是，使用这个新系统，你必须提前在仪表板上定义事件，否则它将忽略这些信息。因此，在我们开始在事件管理器中看到事件触发之前，我们需要去仪表板定义这个事件。
- en: As mentioned before, it can take quite some time before information shows up
    on the Unity dashboard, but it’s a good idea at this point to see where this information
    can be received later on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，信息在Unity仪表板上显示可能需要一些时间，但在这个时候查看这些信息将来可以在哪里接收是个好主意。
- en: From the **Dashboard**, go to **Analytics**, and then select **Event Manager**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**仪表板**进入**分析**，然后选择**事件管理器**。
- en: This is the place where you can see the custom events and parameters that have
    been received from the game.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以看到从游戏中接收到的自定义事件和参数的地方。
- en: From there, select **Add New**, and then select **Custom Event**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，选择**添加新项**，然后选择**自定义事件**。
- en: '![Figure 10.6: Adding a new custom event](img/B18868_10_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：添加新的自定义事件](img/B18868_10_06.jpg)'
- en: 'Figure 10.6: Adding a new custom event'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：添加新的自定义事件
- en: Name the custom event `gamePaused`, spelled exactly the same as we’ve done here,
    for the string that we’ve been passing into the `CustomData` function in the `SetPauseMenu`
    function. We’ll also add an event description of the event for our future reference.
    Afterward, click on the **Create** button, and the event should be ready for us
    to work with.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义事件命名为`gamePaused`，与我们在这里做的完全一样，用于传递到`SetPauseMenu`函数中的`CustomData`函数的字符串。我们还将为事件添加一个事件描述，供我们未来参考。之后，点击**创建**按钮，事件应该就准备好供我们使用了。
- en: "![Figure 10.7: \uFEFFSetting Custom Event Details](img/B18868_10_07.jpg)"
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7：设置自定义事件详细信息](img/B18868_10_07.jpg)'
- en: 'Figure 10.7: Setting Custom Event Details'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：设置自定义事件详细信息
- en: Lastly, scroll down to the event and double check that the **Enabled** option
    is turned on; otherwise, the events will only show up in the **Invalid Events**
    area of the event browser.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向下滚动到事件，并再次确认**启用**选项是开启的；否则，事件将只显示在事件浏览器的**无效事件**区域。
- en: '![Figure 10.8: Enabling the event](img/B18868_10_08.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8：启用事件](img/B18868_10_08.jpg)'
- en: 'Figure 10.8: Enabling the event'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：启用事件
- en: Go back to the Unity Editor and play your game again, triggering the `gamePaused`
    event so that it will show up correctly.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity编辑器并再次播放你的游戏，触发`gamePaused`事件，以确保它正确显示。
- en: Wait 15 minutes or so, go back to the event browser, and hit the `gamePaused`
    event there! To make it easier to see, you can also click on the `gamePaused`,
    and then hit the **Apply** button to isolate the event browser to only show those
    events.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待大约15分钟，返回事件浏览器，并点击那里的`gamePaused`事件！为了更容易看到，你还可以点击`gamePaused`，然后点击**应用**按钮，以便仅将事件浏览器隔离出来以显示这些事件。
- en: If not, it may take some time before the events are updated in the event browser,
    but they should show up eventually.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，事件浏览器中的事件更新可能需要一些时间，但它们最终会显示出来。
- en: '![Figure 10.9: Our simple custom events in the event browser](img/B18868_10_09.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9：事件浏览器中的简单自定义事件](img/B18868_10_09.jpg)'
- en: 'Figure 10.9: Our simple custom events in the event browser'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：事件浏览器中的简单自定义事件
- en: Next, click on the **Data** **Explorer** option.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**数据****探索器**选项。
- en: In the `gamePaused` event is called.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gamePaused`事件被调用时。
- en: Tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have just created the event, it may take up to 12 hours for the information
    to be received. Go ahead and check back later if that’s the case. In the past,
    I’ve had to wait up to even 48 hours for the data, so do not be alarmed if it
    takes a while for it to show up, although I have not had this issue with the newest
    iteration of Unity Gaming Services.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚刚创建了事件，可能需要长达12小时才能接收到信息。如果那样的话，稍后再检查。过去，我不得不等待长达48小时才能得到数据，所以如果它需要一段时间才显示出来，请不要担心，尽管我在Unity游戏服务的最新版本中还没有遇到这个问题。
- en: 'Click on the **+** button to the left of **Add Event** to add a custom event
    to this graph. Then, select the **Add Event** dropdown and then **gamePaused**.
    Since we have just made the event, we won’t see it on previous dates in Analytics,
    but we can see it a little easier if we click on the **Column Chart** button to
    change how the data is displayed:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加事件**左侧的**+**按钮，将自定义事件添加到这个图表中。然后，选择**添加事件**下拉菜单，然后选择**gamePaused**。由于我们刚刚创建了事件，我们不会在分析中的先前日期看到它，但如果我们点击**柱状图**按钮来更改数据的显示方式，我们可以更容易地看到它：
- en: '![Figure 10.10: Add Event](img/B18868_10_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10：添加事件](img/B18868_10_10.jpg)'
- en: 'Figure 10.10: Add Event'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：添加事件
- en: Now, when we scroll down, we can see that `gamePaused` event has been called!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们向下滚动时，我们可以看到`gamePaused`事件已经被调用了！
- en: Sending custom events with properties
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送带属性的定制事件
- en: 'One additional thing that we may want to track is how far players get before
    they lose. Let’s take a look at how to do that now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能想要跟踪的是玩家在失败前能走多远。现在让我们看看如何做到这一点：
- en: In the Dashboard, first, go to the Event Manager. Click on `gameOver`, and then
    fill in the **Event description** field with something like Records when the players
    causes a game over event to occur. Afterward, click on the **Create** button.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仪表板上，首先，转到事件管理器。点击`gameOver`，然后在**事件描述**字段中填写类似“记录玩家触发游戏结束事件时”的内容。之后，点击**创建**按钮。
- en: From there, you’ll be brought to a page for the event. Click on the **Assign
    Parameter** button, and from there, under the **Parameter** dropdown, select **Add**
    **New Parameter**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，你将被带到事件页面。点击**分配参数**按钮，然后从**参数**下拉菜单中选择**添加****新参数**。
- en: '![Figure 10.11: Add New Parameter](img/B18868_10_11.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11：添加新参数](img/B18868_10_11.jpg)'
- en: 'Figure 10.11: Add New Parameter'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：添加新参数
- en: For the parameter name, type in `score`, and then fill in a description for
    the parameter. For the parameter type, select **Float**, and then click the **Create**
    button.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于参数名称，输入`score`，然后为参数填写一个描述。对于参数类型，选择**Float**，然后点击**创建**按钮。
- en: '![Figure 10.12: Adding a custom parameter](img/B18868_10_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12：添加自定义参数](img/B18868_10_12.jpg)'
- en: 'Figure 10.12: Adding a custom parameter'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：添加自定义参数
- en: Create a new event called `gameOver` and a custom parameter, which we will call
    `score` and will be a float. Then, click on the `score`, and then click **Assign**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`gameOver`的新事件和一个自定义参数，我们将称之为`score`，它将是一个浮点数。然后点击`score`，然后点击**分配**。
- en: '![Figure 10.13: Assigning the score parameter](img/B18868_10_13.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13：分配分数参数](img/B18868_10_13.jpg)'
- en: 'Figure 10.13: Assigning the score parameter'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：分配分数参数
- en: Finally, click on the `gameOver` event will be saved when it occurs. Unity will
    ask whether you’re sure you want to enable the event; click on the **Enable**
    button to ensure that it will happen.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击`gameOver`事件将在发生时被保存。Unity将询问你是否确定要启用此事件；点击**启用**按钮以确保它会发生。
- en: '![Figure 10.14: Enabling the event](img/B18868_10_14.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14：启用事件](img/B18868_10_14.jpg)'
- en: 'Figure 10.14: Enabling the event'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：启用事件
- en: Now, return to the Unity Editor. First, we will need to open up the `ObstacleBehaviour`
    script to modify what happens when the game ends.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回Unity编辑器。首先，我们需要打开`ObstacleBehaviour`脚本以修改游戏结束时发生的行为。
- en: 'To utilize Unity Analytics with parameters, at the top of the file, we will
    add the following `using` declarations:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用参数利用Unity Analytics，在文件顶部添加以下`using`声明：
- en: '[PRE3]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The top option is obvious, but we are also adding `System.Collections.Generic`
    in order to get access to the `Dictionary` class, which we will use in the next
    piece of code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部选项很明显，但我们还添加了`System.Collections.Generic`以便访问`Dictionary`类，我们将在下一部分代码中使用它。
- en: 'Next, we will update the `OnCollisionEnter` function to the following:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`OnCollisionEnter`函数到以下内容：
- en: '[PRE4]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve done a number of things within this script. To start off with, we have
    rewritten our check that the player uses the component as a variable now, so we
    don’t have to call `GetComponent` again for the same thing. Aside from that, the
    main addition is the calling of the `AnalyticsService.Instance.CustomData` function
    with a second parameter. The second parameter (which is optional) is a dictionary,
    which we haven’t discussed yet.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中我们做了很多事情。首先，我们重写了检查玩家使用组件作为变量的代码，这样我们就不必再次调用`GetComponent`了。除此之外，主要新增的是调用`AnalyticsService.Instance.CustomData`函数时带有第二个参数。第二个参数（这是可选的）是一个字典，我们还没有讨论过。
- en: A `string` class as the key type so that you can refer to some other data type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`string`类作为键类型，以便你可以引用其他数据类型。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on dictionaries, check out [http://csharp.net-informations.com/collection/dictionary.htm](http://csharp.net-informations.com/collection/dictionary.htm).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字典的更多信息，请查看[http://csharp.net-informations.com/collection/dictionary.htm](http://csharp.net-informations.com/collection/dictionary.htm)。
- en: We’ve wrapped this code in a `try` and `catch` block because if `AnalyticsService.Instance`
    is called and it is `null`, the code written by Unity will throw an exception.
    This will cause the game to break and no longer work. The game currently works
    fine if we start the game from the title screen, but if we start the game from
    the gameplay scene, it will no longer work correctly due to Analytics not being
    initialized. This time, instead of doing nothing like the previous example, I
    added a line to actually print out the message that the error gives us as a warning.
    It’s always a good idea to have our code be as robust as possible, so that’s why
    we added this check.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此代码包裹在`try`和`catch`块中，因为如果调用`AnalyticsService.Instance`并且它是`null`，Unity编写的代码将抛出异常。这将导致游戏崩溃并停止工作。如果从标题屏幕开始游戏，游戏目前运行良好，但如果从游戏场景开始游戏，它将不再正确工作，因为Analytics尚未初始化。这次，与上一个示例不同，我添加了一行来实际打印出错误给出的消息作为警告。让我们的代码尽可能健壮总是一个好主意，这就是为什么我们添加了这个检查。
- en: Save the script and return to the Unity Editor.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到Unity编辑器。
- en: 'Play the game and lose it. Note in the `gameOver`event:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并输掉。注意在`gameOver`事件中：
- en: "![Figure 10.15: A Game Over event being disp\uFEFFatched](img/B18868_10_15.jpg)"
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15：正在派发游戏结束事件](img/B18868_10_15.jpg)'
- en: 'Figure 10.15: A Game Over event being dispatched'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：正在派发游戏结束事件
- en: You can also dive into the dashboard to see the information as well, but Unity
    says it may take up to 6 hours before it becomes visible, although I usually see
    it within 15 minutes or so. You will see the messages instantly in the **Console**
    window, but they don’t populate in Analytics until the backend calculations have
    been processed at Unity’s end, due to all of the events it receives.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以进入仪表板查看信息，但Unity表示可能需要6小时才能变得可见，尽管我通常在15分钟左右就能看到。你将立即在**控制台**窗口中看到消息，但由于它接收到的所有事件，它们在Analytics中不会立即填充，直到Unity端的后端计算完成。
- en: After you’ve waited, go to the `gameOver` events.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在等待之后，转到`gameOver`事件。
- en: 'To be able to see the value of the `score` parameter we created on the far
    right, click on the button that looks like **<>** to access the JSON event content
    for the particular event. Note that we can see the value of our score here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够看到我们在最右侧创建的`score`参数的值，点击看起来像**<>**的按钮来访问特定事件的JSON事件内容。请注意，我们可以在这里看到我们的分数值：
- en: '![Figure 10.16: The score value in the event content](img/B18868_10_16.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16：事件内容中的分数值](img/B18868_10_16.jpg)'
- en: 'Figure 10.16: The score value in the event content'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：事件内容中的分数值
- en: And with that, we now know how to access events!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在知道如何访问事件了！
- en: This information is formatted in the manner of a JSON file. `Dictionary` class
    that we used previously.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息以JSON文件的方式格式化。我们之前使用的`Dictionary`类。
- en: One of the limitations of the event browser is the fact that we are only able
    to see the most recent 100 events. As our project becomes more and more popular,
    it is likely that we’re going to have more and more events. With that in mind,
    we will likely want to have some way to be able to interpret that information.
    One of the ways that we can use do this is through the SQL Data Explorer. This
    allows us to access all the events that are created, but we have to utilize **Structured
    Query Language** (**SQL**), which is a domain-specific language that was created
    to manage data held within a database.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 事件浏览器的局限性之一是我们只能看到最近的100个事件。随着我们的项目越来越受欢迎，我们可能会遇到越来越多的活动。考虑到这一点，我们可能需要一种方法来解释这些信息。我们可以用来实现这一目标的方法之一是通过SQL数据探索器。这使我们能够访问创建的所有事件，但我们必须利用**结构化查询语言**（**SQL**），这是一种为管理数据库中存储的数据而创建的特定领域语言。
- en: Click on the **SQL Data Explorer** button to open the menu. Note that the **Query**
    field contains some default text.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**SQL数据探索器**按钮打开菜单。请注意，**查询**字段包含一些默认文本。
- en: '![Figure 10.17: SQL Data Explorer](img/B18868_10_17.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17：SQL数据探索器](img/B18868_10_17.jpg)'
- en: 'Figure 10.17: SQL Data Explorer'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17：SQL数据探索器
- en: Hit the **Run** button to see the default result and how it works. Once the
    query finishes, you’ll be able to create a chart using the data it interpreted
    from this query.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮以查看默认结果及其工作方式。一旦查询完成，你将能够使用从该查询中解释的数据创建图表。
- en: To get a feel for how this can work with chart data, under **Chart Setup**,
    set **X-axis column** to **EVENT_DATE** and **Y-axis 1 column** to **COUNT(DISTINCT
    USER_ID)**, and then click the **Apply** button.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **图表设置** 下，将 **X 轴列** 设置为 **EVENT_DATE**，将 **Y 轴 1 列** 设置为 **COUNT(DISTINCT
    USER_ID)**，然后点击 **应用** 按钮。
- en: '![Figure 10.18: Chart Setup](img/B18868_10_18.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18：图表设置](img/B18868_10_18.jpg)'
- en: 'Figure 10.18: Chart Setup'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18：图表设置
- en: This will allow you to create a chart in a similar manner to what we saw earlier
    with the Data Explorer, but this gives us more fine-tuned control if we want to
    use the power of SQL.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您以类似于我们在数据探索器中看到的方式创建图表，但如果我们要使用 SQL 的强大功能，这将给我们提供更精细的控制。
- en: There are entire books out there about SQL for those that are interested in
    exploring it further, but in our case, we want to extract the score values from
    our custom events. Therefore, instead of a chart, we want to create a table so
    that, in addition to writing some custom queries, we can also see how to export
    the data as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对进一步探索 SQL 感兴趣的人来说，市面上有关于 SQL 的整本书，但在这个案例中，我们想要从我们的自定义事件中提取分数值。因此，我们不想创建图表，而是想创建一个表格，这样我们除了编写一些自定义查询外，还可以看到如何导出数据。
- en: 'In the **Query** field, replace the code with the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **查询** 字段中，将代码替换为以下内容：
- en: '[PRE5]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is going to go through every single event and check whether the name
    of the event is `gameOver`. If so, it will isolate the `score` property from it.
    This will allow us to create a list of all of the `score` properties from the
    entire project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将遍历每个事件并检查事件名称是否为 `gameOver`。如果是，它将从中隔离 `score` 属性。这将允许我们创建整个项目中所有 `score`
    属性的列表。
- en: Hit the **Run** button and wait for it to execute. Once done, you’ll see the
    **Share** button on the top has turned blue and you can press it. Once selected,
    click on the **Export as CSV** **file** option.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **运行** 按钮并等待其执行。一旦完成，您将看到顶部的 **共享** 按钮变为蓝色，您可以按下它。一旦选择，点击 **导出为 CSV 文件**
    选项。
- en: '**CSV** stands for **comma-separated values**. This is a file type that uses
    commas to separate each of the different values that are designated within the
    file, but if you open the file with Google Sheets or Excel, the program will be
    able to parse the file to resemble a nice table.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSV** 代表 **逗号分隔值**。这是一种使用逗号分隔文件中指定值的文件类型，但如果您使用 Google Sheets 或 Excel 打开文件，程序将能够解析文件以类似于漂亮的表格的形式。'
- en: '![Figure 10.19: The table of score values in Microsoft Excel](img/B18868_10_19.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19：Microsoft Excel 中的分数值表](img/B18868_10_19.jpg)'
- en: 'Figure 10.19: The table of score values in Microsoft Excel'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19：Microsoft Excel 中的分数值表
- en: This gives us a way to see all the various different score values that our players
    have achieved as they played the game. This can help us see whether people are
    doing well or really poorly, and allow us to cater the game however we’d like.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种查看玩家在玩游戏过程中所达到的所有不同分数值的方法。这可以帮助我们看到人们是否表现良好或真的很差，并允许我们根据需要调整游戏。
- en: 'Use a snippet like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下类似的片段：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code would make it so that instead of the first event just showing
    6.5199995, we would have each of the slots consist of the entirety of the JSON
    data that we discussed earlier – in this case, the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将确保，而不是第一个事件只显示 6.5199995，我们会有每个槽位都包含我们之前讨论过的全部 JSON 数据——在这种情况下，以下内容：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By adding `:score::FLOAT`, we get the `score` variable from the JSON data and
    tell the computer to interpret it as a floating-point value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `:score::FLOAT`，我们从 JSON 数据中获取 `score` 变量，并告诉计算机将其解释为浮点值。
- en: For those that are interested in exploring SQL more, I suggest checking out
    the Unity Gaming Service’s example cookbook at [https://github.com/Unity-Technologies/UGS-SQL-Cookbook](https://github.com/Unity-Technologies/UGS-SQL-Cookbook),
    which contains a collection of common SQL queries and best practices for use with
    Unity Analytics.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对探索 SQL 更感兴趣的人，我建议查看 Unity 游戏服务的示例食谱 [https://github.com/Unity-Technologies/UGS-SQL-Cookbook](https://github.com/Unity-Technologies/UGS-SQL-Cookbook)，其中包含了一组常见的
    SQL 查询和与 Unity 分析一起使用的最佳实践。
- en: This, of course, is just a simple example, so I would suggest that you create
    custom events for whenever a user reaches an important milestone – for example,
    when they level up or when they make an **In-App** **Purchase** (**IAP**).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简单的例子，所以我建议您为用户达到重要里程碑时创建自定义事件——例如，当用户升级或进行 **内购**（**IAP**）时。
- en: Now that we know how to create different types of events, let’s see how we can
    actually track events and learn more about what our players are doing, utilizing
    the Funnel Analyzer tool.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建不同类型的事件，让我们看看我们如何实际上跟踪事件并利用漏斗分析器工具了解更多关于玩家在做什么。
- en: Working with funnels
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与漏斗一起工作
- en: One of the many things we’d like to know about our players is how they are actually
    playing a game – for instance, are users skipping our tutorial? To keep track
    of how players proceed through a series of events, we have funnels. Funnels help
    us to identify where player drop-off happens in our game.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想了解关于玩家们的许多事情之一是他们在实际玩游戏的方式——例如，用户是否跳过了我们的教程？为了跟踪玩家如何通过一系列事件，我们使用了漏斗。漏斗帮助我们确定玩家在游戏中的流失点。
- en: If you happen to see a large number of people not getting to a certain step,
    you can assume that something that happened in the preceding step causes people
    to stop playing our game.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到很多人没有到达某个步骤，你可以假设在前面步骤中发生的事情导致人们停止玩我们的游戏。
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on how funnels work as well as why you’d want to use them,
    check out [https://data36.com/funnel-analysis/](https://data36.com/funnel-analysis/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于漏斗如何工作以及为什么你想使用它们的信息，请查看[https://data36.com/funnel-analysis/](https://data36.com/funnel-analysis/)。
- en: 'Funnels are based on the concept of custom events, which we used in the *Sending
    custom events with properties* section of this chapter. We can use the Funnels
    tool (previously known as the Funnel Analyzer) to look at the data sent via these
    funnels, which we can then use to make educated decisions on what changes should
    be made to the game. Follow the steps given here to add the tool:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 漏斗基于自定义事件的概念，我们在本章的*使用属性发送自定义事件*部分使用了它。我们可以使用漏斗工具（之前称为漏斗分析器）来查看通过这些漏斗发送的数据，然后我们可以使用这些数据来做出明智的决定，关于应该对游戏做出哪些更改。按照以下步骤添加工具：
- en: 'From the dashboard, go to **Analytics** and select **Funnels**:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从仪表板转到**分析**并选择**漏斗**：
- en: '![Figure 10.20: The Funnels page](img/B18868_10_20.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20：漏斗页面](img/B18868_10_20.jpg)'
- en: 'Figure 10.20: The Funnels page'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20：漏斗页面
- en: Right now, there are no funnels set up, so we should create one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，还没有设置漏斗，因此我们应该创建一个。
- en: 'Click on the **+ New Funnel** button and fill in the details, as shown in the
    following screenshot. Then, scroll all the way down and click on the **Apply**
    button:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+ 新建漏斗**按钮并填写以下截图中的详细信息。然后，滚动到最底部并点击**应用**按钮：
- en: '![Figure 10.21: Funnels setup](img/B18868_10_21.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21：漏斗设置](img/B18868_10_21.jpg)'
- en: 'Figure 10.21: Funnels setup'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21：漏斗设置
- en: 'If you’ve played the game already, you can see the results from the events
    that have already triggered:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经玩过游戏，你可以看到已经触发的事件的结果：
- en: '![Figure 10.22: The event trigger results](img/B18868_10_22.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22：事件触发结果](img/B18868_10_22.jpg)'
- en: 'Figure 10.22: The event trigger results'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22：事件触发结果
- en: In our case, we have played the game and lost, so we currently have a 100% completion
    rate.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们已经玩游戏并失败了，所以我们目前有100%的完成率。
- en: Scroll up to the top page and click on the **Save Funnel** button. Give the
    funnel a name, describe what it is you’re creating, and then hit the **Save**
    button.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到顶部页面并点击**保存漏斗**按钮。给漏斗起一个名字，描述你正在创建的内容，然后点击**保存**按钮。
- en: "![Figure 10.23: The\uFEFF funnel setup](img/B18868_10_23.jpg)"
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23：漏斗设置](img/B18868_10_23.jpg)'
- en: 'Figure 10.23: The funnel setup'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23：漏斗设置
- en: You should be able to select that funnel, and it will provide information on
    all the times it has been called.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够选择该漏斗，并且它将提供有关它被调用的所有时间的信息。
- en: The concepts used here can easily be expanded upon in other ways as well, such
    as keeping track of how often users watch ads or make purchases in the game and
    what causes them to do so.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的概念也可以很容易地以其他方式扩展，例如跟踪用户观看广告或进行游戏内购买的频率以及是什么原因导致他们这样做。
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Funnels are great when a game is working correctly, but if the game crashes,
    it’s also possible to get analytics from that as well from Unity Cloud Diagnostics.
    For information on that as well as how to set it up, check out [https://docs.unity.com/cloud-diagnostics/en/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting](https://docs.unity.com/cloud-diagnostics/en/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏运行正常时，漏斗分析非常出色，但如果游戏崩溃，也可以从Unity Cloud Diagnostics中获取相关的分析信息。有关该信息以及如何设置的信息，请参阅[https://docs.unity.com/cloud-diagnostics/en/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting](https://docs.unity.com/cloud-diagnostics/en/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting)。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a number of ways that we can make use of Unity’s
    Analytics tool to make our games better, from how to understand what our players
    are doing to learning how to adjust our game based on that feedback, without users
    having to download an entirely new copy of our game.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多种利用Unity的Analytics工具来提升游戏的方法，从理解玩家行为到根据这些反馈调整游戏，而无需用户下载我们游戏的新版本。
- en: Specifically, we learned how to set up the Unity Analytics section of the Unity
    Editor, and then we saw how we can make use of code to create events to be sent
    to the cloud for us to look at. With the given data, we learned how we could make
    use of funnels and the Funnel Analyzer to learn more about our players.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们学习了如何设置Unity编辑器中的Unity Analytics部分，然后我们看到了如何利用代码创建事件并将其发送到云端供我们查看。有了这些数据，我们学习了如何利用漏斗和漏斗分析器来更深入地了解我们的玩家。
- en: Now that we have seen how to create events, let’s see one of the other main
    benefits of utilizing Unity Gaming Services – being able to change projects using
    the Remote Config feature, which we will learn more about in the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建事件，接下来让我们看看利用Unity Gaming Services的另一个主要好处——使用远程配置功能更改项目，我们将在下一章中了解更多相关信息。
