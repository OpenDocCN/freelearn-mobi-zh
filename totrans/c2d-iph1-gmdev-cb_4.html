<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Physics</h1></div></div></div><p>In this chapter, we will cover the following points:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Box2D setup and debug drawing</li><li class="listitem" style="list-style-type: disc">Creating collision response routines</li><li class="listitem" style="list-style-type: disc">Using different shapes</li><li class="listitem" style="list-style-type: disc">Dragging and collision filtering</li><li class="listitem" style="list-style-type: disc">Manipulating physical properties</li><li class="listitem" style="list-style-type: disc">Applying impulses</li><li class="listitem" style="list-style-type: disc">Applying forces</li><li class="listitem" style="list-style-type: disc">Asynchronous body destruction</li><li class="listitem" style="list-style-type: disc">Using joints</li><li class="listitem" style="list-style-type: disc">Creating a vehicle</li><li class="listitem" style="list-style-type: disc">Character movement</li><li class="listitem" style="list-style-type: disc">Simulating bullets</li><li class="listitem" style="list-style-type: disc">Simulating and rendering a rope</li><li class="listitem" style="list-style-type: disc">Creating a top-down isometric game engine</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Introduction</h1></div></div></div><p>For years, physics engines have been used in video games to add a sense of realism to the action onscreen. In many games, physics plays a crucial role within the gameplay. Cocos2d comes bundled with two popular 2D physics engines:<strong> Box2D</strong> and<strong> Chipmunk</strong>. In this chapter, we will explain the most common uses of physics in games using Box2D as our engine of choice. Most of the recipes here can be easily modified to use Chipmunk or any other similar physics engine.<a id="id172" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Box2D setup and debug drawing</h1></div></div></div><p>In our first physics recipe, we will explore the basics of creating a Box2D project and setting up a Box2D world. The example creates a scene that allows the user to create realistic 2D blocks.<a id="id173" class="indexterm"/>
</p><div><img src="img/4002_04_01.jpg" alt="Box2D setup and debug drawing"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec01"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec02"/>How to do it...</h2></div></div></div><p>The first thing we need to do is create a Box2D project using the built-in Box2D project template:<a id="id174" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Go to<strong> File</strong> |<strong> New Project</strong>.</li><li class="listitem"> Under<strong> User Templates</strong> click on<strong> Cocos2d</strong>.</li><li class="listitem"> Now, right click on<strong> Cocos2d Box2d Application</strong>.<div><img src="img/4002_04_02.jpg" alt="How to do it..."/></div></li><li class="listitem"> Click<strong> Choose</strong>, name your project, and hit<strong> Save</strong>.</li></ol></div><p>Now, execute the following code:<a id="id175" class="indexterm"/>
</p><div><pre class="programlisting">#import "Box2D.h"
#import "GLES-Render.h"
//32 pixels = 1 meter
#define PTM_RATIO 32
@implementation Ch4_BasicSetup
-(CCLayer*) runRecipe {
[super runRecipe];
/* Box2D Initialization */
//Set gravity
b2Vec2 gravity;
gravity.Set(0.0f, -10.0f);
//Initialize world
bool doSleep = YES;
world = new b2World(gravity, doSleep);
world-&gt;SetContinuousPhysics(YES);
//Initialize debug drawing
m_debugDraw = new GLESDebugDraw( PTM_RATIO );
world-&gt;SetDebugDraw(m_debugDraw);
uint32 flags = 0;
flags += b2DebugDraw::e_shapeBit;
m_debugDraw-&gt;SetFlags(flags);
//Create level boundaries
[self addLevelBoundaries];
//Add batch node for block creation
CCSpriteBatchNode *batch = [CCSpriteBatchNode batchNodeWithFile:@"blocks.png" capacity:150];
[self addChild:batch z:0 tag:0];
//Add a new block
CGSize screenSize = [CCDirector sharedDirector].winSize;
[self addNewSpriteWithCoords:ccp(screenSize.width/2, screenSize.height/2)];
//Schedule step method
Box2D setupsteps[self schedule:@selector(step:)];
return self;
}
/* Adds a polygonal box around the screen */
-(void) addLevelBoundaries {
CGSize screenSize = [CCDirector sharedDirector].winSize;
//Create the body
b2BodyDef groundBodyDef;
groundBodyDef.position.Set(0, 0);
b2Body *body = world-&gt;CreateBody(&amp;groundBodyDef);
//Create a polygon shape
b2PolygonShape groundBox;
//Add four fixtures each with a single edge
groundBox.SetAsEdge(b2Vec2(0,0), b2Vec2(screenSize.width/PTM_RATIO,0));
body-&gt;CreateFixture(&amp;groundBox,0);
groundBox.SetAsEdge(b2Vec2(0,screenSize.height/PTM_RATIO), b2Vec2(screenSize.width/PTM_RATIO,screenSize.height/PTM_RATIO));
body-&gt;CreateFixture(&amp;groundBox,0);
groundBox.SetAsEdge(b2Vec2(0,screenSize.height/PTM_RATIO), b2Vec2(0,0));
body-&gt;CreateFixture(&amp;groundBox,0);
groundBox.SetAsEdge(b2Vec2(screenSize.width/PTM_RATIO,screenSize.height/PTM_RATIO), b2Vec2(screenSize.width/PTM_RATIO,0));
body-&gt;CreateFixture(&amp;groundBox,0);
}
/* Adds a textured block */
-(void) addNewSpriteWithCoords:(CGPoint)p {
CCSpriteBatchNode *batch = (CCSpriteBatchNode*) [self getChildByTag:0];
//Add randomly textured block
int idx = (CCRANDOM_0_1() &gt; .5 ? 0:1);
int idy = (CCRANDOM_0_1() &gt; .5 ? 0:1);
CCSprite *sprite = [CCSprite spriteWithBatchNode:batch rect:CGRectMake(32 * idx,32 * idy,32,32)];
[batch addChild:sprite];
sprite.position = ccp( p.x, p.y);
//Define body definition and create body
b2BodyDef bodyDef;
bodyDef.type = b2_dynamicBody;
bodyDef.position.Set(p.x/PTM_RATIO, p.y/PTM_RATIO);
bodyDef.userData = sprite;
b2Body *body = world-&gt;CreateBody(&amp;bodyDef);
//Define another box shape for our dynamic body.
b2PolygonShape dynamicBox;
dynamicBox.SetAsBox(.5f, .5f);//These are mid points for our 1m box
//Define the dynamic body fixture.
b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;dynamicBox;
fixtureDef.density = 1.0f;
fixtureDef.friction = 0.3f;
body-&gt;CreateFixture(&amp;fixtureDef);
}
/* Draw debug data */
-(void) draw {
//Disable textures
glDisable(GL_TEXTURE_2D);
glDisableClientState(GL_COLOR_ARRAY);
glDisableClientState(GL_TEXTURE_COORD_ARRAY);
//Draw debug data
world-&gt;DrawDebugData();
Box2D setupsteps//Re-enable textures
glEnable(GL_TEXTURE_2D);
glEnableClientState(GL_COLOR_ARRAY);
glEnableClientState(GL_TEXTURE_COORD_ARRAY);
}
/* Update graphical positions using physical positions */
-(void) step: (ccTime) dt {
//Set velocity and position iterations
int32 velocityIterations = 8;
int32 positionIterations = 3;
//Steo the Box2D world
world-&gt;Step(dt, velocityIterations, positionIterations);
//Update sprite position and rotation to fit physical bodies
for (b2Body* b = world-&gt;GetBodyList(); b; b = b-&gt;GetNext()) {
if (b-&gt;GetUserData() != NULL) {
CCSprite *obj = (CCSprite*)b-&gt;GetUserData();
obj.position = CGPointMake( b-&gt;GetPosition().x * PTM_RATIO, b-&gt;GetPosition().y * PTM_RATIO);
obj.rotation = -1 * CC_RADIANS_TO_DEGREES(b-&gt;GetAngle());
}
}
}
/* Tap to add a block */
- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
for( UITouch *touch in touches ) {
CGPoint location = [touch locationInView: [touch view]];
location = [[CCDirector sharedDirector] convertToGL: location];
[self addNewSpriteWithCoords: location];
}
}
@end
<a id="id178" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec03"/>How it works...</h2></div></div></div><p>The Box2D sample project is a simple way to understand what a physics system looks like.<a id="id179" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initialization:<p>Upon initialization of the <code class="literal">b2World</code> object, we set a few things including gravity, object <strong>sleeping</strong>, and continuous physics. Sleeping allows bodies that are at rest to take up less system resources. Gravity is typically set to a negative number in the Y direction but can be reset at any time using the following method on <code class="literal">b2World</code>:
<a id="id180" class="indexterm"/>
</p><div><pre class="programlisting">void SetGravity(const b2Vec2&amp; gravity);
</pre></div><p>In addition to storing a pointer to the main b2World instance, we also usually store a pointer to an instance of <code class="literal">GLESDebugDraw</code>.
</p></li><li class="listitem" style="list-style-type: disc">Debug drawing:<p>Debug drawing is handled by the <code class="literal">GLESDebugDraw</code> class as defined in <code class="literal">GLES-Render.h</code>. Debug drawing encompasses drawing five different elements onscreen. These include <strong>shapes, joint</strong> connections, <strong>AABB</strong>s (axis-aligned bounding boxes), <strong>broad-phase</strong> pairs, and a <strong>center of mass</strong> bit.
<a id="id181" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Visual to physical drawing ratio:<p>We define the constant <code class="literal">PTM_RATIO</code> at 32, to allow consistent conversion between the physical world and the visual world. <strong>PTM</strong> stands for <strong>pixel to meter</strong>. Box2D measures bodies in meters and is built and optimized to work with bodies between the sizes of 0.1 to 10.0 meters. Setting this ratio to 32 is a common convention for optimal shapes to appear between 3.2 to 320 pixels on screen. Optimization aside, there is no upper or lower limit to Box2D body size.
<a id="id182" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Level boundaries:<p>In this and many future examples, we add a level boundary roughly encompassing the entire screen. This is handled with the creation of a <code class="literal">b2Body</code> object with four <strong>fixtures</strong>. Each fixture has a <code class="literal">b2Polygon</code> shape that defines a single <strong>edge</strong>. Creating an edge typically involves the following:
<a id="id183" class="indexterm"/>
</p><div><pre class="programlisting">b2BodyDef bodyDef;
bodyDef.position.Set(0, 0);
b2Body *body = world-&gt;CreateBody(&amp;bodyDef);
b2PolygonShape poly;
poly.SetAsEdge(b2Vec2(0,0), b2Vec2(480/PTM_RATIO,0));
body-&gt;CreateFixture(&amp;poly,0);
<a id="id184" class="indexterm"/>
</pre></div><p>Because these edges have no corresponding visual components (they are invisible), we do not need to set the <code class="literal">bodyDef.userData</code> pointer.
</p></li><li class="listitem" style="list-style-type: disc">Creating the blocks:<a id="id185" class="indexterm"/><p>Blocks are created much in the same way that the level boundaries are created. Instead of calling <code class="literal">SetAsEdge</code>, we call <code class="literal">SetAsBox</code> to create a box-shaped polygon. We then set the <code class="literal">density</code> and <code class="literal">friction</code> attributes of the <strong>fixture</strong>. We also set <code class="literal">bodyDef.userData</code> to point to the <code class="literal">CCSprite</code> we created. This links the visual and the physical, and allows our <code class="literal">step:</code> method to reposition sprites as necessary.
<a id="id186" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Scheduling the world step:<p>Finally, we schedule our <code class="literal">step</code> method. In this method, we run one discrete <code class="literal">b2World</code> step using the following code:
<a id="id187" class="indexterm"/>
</p><div><pre class="programlisting">int32 velocityIterations = 8;
int32 positionIterations = 3;
world-&gt;Step(dt, velocityIterations, positionIterations);
</pre></div><p>The Box2D <code class="literal">world Step</code> method moves the physics engine forward one step. The Box2D constraint solver runs in two phases: the velocity phase and position phase. These determine how fast the bodies move and where they are in the game world. Setting these variables higher results in a more accurate simulation at the cost of speed. Setting <code class="literal">velocityIterations</code> to 8 and <code class="literal">positionIterations</code> to 3 is the suggested baseline in the Box2D manual. Using the dt variable syncs the logical timing of the application with the physical timing. If a game step takes an inordinate amount of time, the physics system will move forward quickly to compensate. This is referred to as a <strong>variable time step</strong>. An alternative to this would be a <strong>fixed time step</strong> set to 1/60th of a second. In addition to the physical step, we also reposition and re-orientate all <code class="literal">CCSprites</code> according to their respective <code class="literal">b2Body</code> positions and rotations:
<a id="id188" class="indexterm"/>
</p><div><pre class="programlisting">for (b2Body* b = world-&gt;GetBodyList(); b; b = b-&gt;GetNext()) {
if (b-&gt;GetUserData() != NULL) {
CCSprite *obj = (CCSprite*)b-&gt;GetUserData();
obj.position = CGPointMake( b-&gt;GetPosition().x * PTM_RATIO, b-&gt;GetPosition().y * PTM_RATIO);
obj.rotation = -1 * CC_RADIANS_TO_DEGREES(b-&gt;GetAngle());
}
}
</pre></div><p>Taken together, these pieces of code sync the physical world with the visual.
<a id="id189" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Creating collision response routines</h1></div></div></div><p>To make efficient and organized use of Box2D, we must create a few wrapper classes to encapsulate specific functionality. In this recipe, we will use these classes to add collision response routines to our simple falling block demo from the previous recipe.<a id="id190" class="indexterm"/>
</p><div><img src="img/4002_04_03.jpg" alt="Creating collision response routines"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec04"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also, note that some code has been omitted for brevity.<a id="id191" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec05"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id192" class="indexterm"/>
</p><div><pre class="programlisting">/* GameObject.h */
@interface GameObject : CCNode {
@public
GameArea2D *gameArea; b2Body *body; b2BodyDef *bodyDef;
b2FixtureDef *fixtureDef; b2PolygonShape *polygonShape;
b2CircleShape *circleShape; CCSprite *sprite;
int typeTag; bool markedForDestruction;
}
/* GameSensor.h */
@interface GameSensor : GameObject {}
@property (readonly) int type;
@end
/* GameMisc.h */
@interface GameMisc : GameObject {
@public
float life;
}
@property (readonly) int type;
@property (readwrite, assign) float life;
@end
collision response routinescreating/* BasicContactListener.h */
class basicContactListener : public b2ContactListener
{
public:
void BeginContact(b2Contact* contact);
};
void basicContactListener::BeginContact(b2Contact* contact)
{
b2Body *bodyA = contact-&gt;GetFixtureA()-&gt;GetBody();
b2Body *bodyB = contact-&gt;GetFixtureB()-&gt;GetBody();
//Handle collision using your custom routine
if(bodyA and bodyB){
GameObject *objA = (GameObject*)bodyA-&gt;GetUserData();
GameObject *objB = (GameObject*)bodyB-&gt;GetUserData();
GameArea2D *gameArea = (GameArea2D*)objA.gameArea;
[gameArea handleCollisionWithObjA:objA withObjB:objB];
}
}
/* GameArea2D.h */
@implementation GameArea2D
-(CCLayer*) runRecipe {
/* CODE OMITTED */
//Add contact filter and contact listener
world-&gt;SetContactListener(new basicContactListener);
/* CODE OMITTED */
//Add button to hide/show debug drawing
CCMenuItemFont* swapDebugDrawMIF = [CCMenuItemFont itemFromString:@"Debug Draw" target:self selector:@selector(swapDebugDraw)];
CCMenu *swapDebugDrawMenu = [CCMenu menuWithItems:swapDebugDrawMIF, nil];
swapDebugDrawMenu.position = ccp( 260 , 20 );
[self addChild:swapDebugDrawMenu z:5];
//Schedule our every tick method call
[self schedule:@selector(step:)];
return self;
}
/* This is called from 'basicContactListener'. It will need to be overridden. */
-(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB {
/** ABSTRACT **/
}
/* Destroy the world upon exit */
- (void) dealloc {
delete world; world = NULL;
delete m_debugDraw;
[super dealloc];
}
/* Debug information is drawn over everything */
-(void) initDebugDraw {
DebugDrawNode * ddn = [DebugDrawNode createWithWorld:world];
[ddn setPosition:ccp(0,0)];
[gameNode addChild:ddn z:100000];
}
/* When we show debug draw we add a number of flags to show specific information */
-(void) showDebugDraw {
debugDraw = YES;
uint32 flags = 0;
flags += b2DebugDraw::e_shapeBit;
flags += b2DebugDraw::e_jointBit;
flags += b2DebugDraw::e_aabbBit;
flags += b2DebugDraw::e_pairBit;
flags += b2DebugDraw::e_centerOfMassBit;
m_debugDraw-&gt;SetFlags(flags);
collision response routinescreating}
@end
@implementation Ch4_CollisionResponse
-(CCLayer*) runRecipe {
/* CODE OMITTED */
//Create circular GameSensor object
GameSensor *gameObjSensor = [[GameSensor alloc] init];
gameObjSensor.gameArea = self;
//Create the body definition
gameObjSensor.bodyDef-&gt;type = b2_staticBody;
gameObjSensor.bodyDef-&gt;position.Set(240/PTM_RATIO,160/PTM_RATIO);
gameObjSensor.bodyDef-&gt;userData = gameObjSensor;
//Create the body
gameObjSensor.body = world-&gt;CreateBody(gameObjSensor.bodyDef);
//Create the shape and fixture
gameObjSensor.circleShape = new b2CircleShape();
gameObjSensor.circleShape-&gt;m_radius = 1.0f;
//Create the fixture definition
gameObjSensor.fixtureDef-&gt;shape = gameObjSensor.circleShape;
gameObjSensor.fixtureDef-&gt;isSensor = YES;
//Create the fixture
gameObjSensor.body-&gt;CreateFixture(gameObjSensor.fixtureDef);
//Create level boundaries
[self addLevelBoundaries];
//Add block batch sprite
CCSpriteBatchNode *batch = [CCSpriteBatchNode batchNodeWithFile:@"blocks.png" capacity:150];
[gameNode addChild:batch z:0 tag:0];
return self;
collision response routinescreating}
/* Our base collision handling routine */
-(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB {
//SENSOR to MISC collision
if(objA.type == GO_TYPE_SENSOR &amp;&amp; objB.type == GO_TYPE_MISC){
[self handleCollisionWithSensor:(GameSensor*)objA withMisc:(GameMisc*)objB];
}else if(objA.type == GO_TYPE_MISC &amp;&amp; objB.type == GO_TYPE_SENSOR){
[self handleCollisionWithSensor:(GameSensor*)objB withMisc:(GameMisc*)objA];
}
//MISC to MISC collision
else if(objA.type == GO_TYPE_MISC &amp;&amp; objB.type == GO_TYPE_MISC){
[self handleCollisionWithMisc:(GameMisc*)objA withMisc:(GameMisc*)objB];
}
}
/* Handling collision between specific types of objects */
-(void) handleCollisionWithSensor:(GameSensor*)sensor withMisc:(GameMisc*)misc {
[message setString:@"Box collided with sensor"];
[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:0.5f],
[CCCallFunc actionWithTarget:self selector:@selector(resetMessage)], nil]];
}
-(void) handleCollisionWithMisc:(GameMisc*)a withMisc:(GameMisc*)b {
[message setString:@"Box collided with another box"];
[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:0.5f],
[CCCallFunc actionWithTarget:self selector:@selector(resetMessage)], nil]];
}
/* Adding a new block */
-(void) addNewObjectWithCoords:(CGPoint)p {
/* CODE OMITTED */
}
- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
for( UITouch *touch in touches ) {
CGPoint location = [touch locationInView: [touch view]];
location = [[CCDirector sharedDirector] convertToGL: location];
[self addNewObjectWithCoords: location];
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec06"/>How it works...</h2></div></div></div><p>This recipe lays the groundwork for the rest of this chapter. Here, we see the same block creation recipe from before except now a message is printed on the screen when either blocks collide with each other or they collide with a<strong> sensor.</strong>
<a id="id196" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GameObject:</code><a id="id197" class="indexterm"/><p>The <code class="literal">GameObject</code> class encapsulates Box2D data structures to help ease the process of Box2D object creation. It also includes a pointer back to its parent <code class="literal">GameArea</code> object as well as some other information we will use later. <code class="literal">GameObject</code> is intended to be an abstract base class that should be extended for specific uses.
<a id="id198" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Sensors:<a id="id199" class="indexterm"/><p>A <strong>fixture</strong> attached to a <code class="literal">b2Body</code> can be set to 'sensor mode'. This allows collision response routines to run without the body actually existing in the world physically. No physical collision response will occur. We've encapsulated this functionality in the <code class="literal">GameSensor</code> class. An object of this class can be differentiated from other objects by checking its type property.
<a id="id200" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">GameMisc:</code><a id="id201" class="indexterm"/><p>The <code class="literal">GameMisc</code> class exists as an example of a typical extension of <code class="literal">GameObject</code>. The only added functionality in <code class="literal">GameMisc</code> is the life variable that we will use in later recipes.
<a id="id202" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">GameArea2D:</code><a id="id203" class="indexterm"/><p>The <code class="literal">GameArea2D</code> class is where the action happens. Here, we encapsulate most of the functionality outlined in the previous recipe. In addition to that, we have an instance of <code class="literal">DebugDrawNode</code> and an instance of <code class="literal">CCNode</code> entitled <code class="literal">gameNode</code>. These allow us to draw our debug information and our game information separately from the main scene. This feature will come in handy as recipes become more complex.
</p></li><li class="listitem" style="list-style-type: disc">Contact listeners:<p>The class <code class="literal">b2ContactListener</code> is commonly overridden to allow for custom collision response handling. We extend <code class="literal">b2ContentListener</code> to create the <code class="literal">basicContentListener</code> class. There are four methods that can be extended to detect collision at a number of different intervals:
<a id="id204" class="indexterm"/>
</p><div><pre class="programlisting">void BeginContact(b2Contact* contact);
void EndContact(b2Contact* contact);
void PreSolve(b2Contact* contact, const b2Manifold* oldManifold);
void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse);
</pre></div><p>The methods <code class="literal">BeginContact</code> and <code class="literal">EndContact</code> are fairly self-explanatory. The former is called when two fixtures begin to touch, the latter when they cease to touch. The <code class="literal">PreSolve</code> and <code class="literal">PostSolve</code> methods are called before and after the contact solver routine runs. We will use this functionality in a later recipe. For this recipe, we are only concerned with <code class="literal">BeginContact</code>. In this method, we retrieve two <code class="literal">GameObject</code> instances from <code class="literal">body-&gt;GetUserData()</code> and we pass them to the following method in the corresponding <code class="literal">GameArea</code> instance:
<a id="id205" class="indexterm"/>
</p><div><pre class="programlisting">-(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB;
</pre></div><p>That method checks object types and finally displays different messages onscreen.
<a id="id206" class="indexterm"/>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec07"/>There's More...</h2></div></div></div><p>In this example, blocks are colliding with a static sensor. The sensor does not move because its body<code class="literal"> type</code> attribute is set to<code class="literal"> b2_staticBody</code>. Static bodies never move and they do not collide with each other. Each block has its<code class="literal"> type</code> attribute set to<code class="literal"> b2_dynamicBody</code>. Dynamic bodies move freely and collide with all other bodies.
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Using different shapes</h1></div></div></div><p>The primary attribute a Box2D body has is its shape. Box2D uses two classes,<code class="literal"> b2PolygonShape</code> and<code class="literal"> b2CircleShape</code>, to represent any possible shape. In this recipe, we will create a number of different shapes.<a id="id207" class="indexterm"/>
</p><div><img src="img/4002_04_04.jpg" alt="Using different shapes"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec08"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec09"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id208" class="indexterm"/>
</p><div><pre class="programlisting">@implementation Ch4_DifferentShapes
/* Here add an object randomly chosen from a rectangle, square, circle, convex polygon and multi-fixture concave polygon. */
-(void) addNewObjectWithCoords:(CGPoint)p
{
//Initialize the object
GameMisc *obj = [[GameMisc alloc] init];
obj.gameArea = self;
obj.bodyDef-&gt;type = b2_dynamicBody;
obj.bodyDef-&gt;position.Set(p.x/PTM_RATIO, p.y/PTM_RATIO);
obj.bodyDef-&gt;userData = obj;
obj.body = world-&gt;CreateBody(obj.bodyDef);
obj.fixtureDef-&gt;density = 1.0f;
obj.fixtureDef-&gt;friction = 0.3f;
obj.fixtureDef-&gt;restitution = 0.2f;
//Pick a random shape, size and texture
int num = arc4random()%5;
if(num == 0){
/* Create square object */
/* CODE OMITTED */
//Create shape, add to fixture def and finally create the fixture
obj.polygonShape = new b2PolygonShape();
obj.polygonShape-&gt;SetAsBox(shapeSize/PTM_RATIO, shapeSize/PTM_RATIO);
obj.fixtureDef-&gt;shape = obj.polygonShape;
obj.body-&gt;CreateFixture(obj.fixtureDef);
}else if(num == 1){
/* Create circle object */
/* CODE OMITTED */
//Create shape, add to fixture def and finally create the fixture
obj.circleShape = new b2CircleShape();
obj.circleShape-&gt;m_radius = shapeSize/PTM_RATIO;
obj.fixtureDef-&gt;shape = obj.circleShape;
obj.fixtureDef-&gt;restitution = 0.9f;
obj.body-&gt;CreateFixture(obj.fixtureDef);
}else if(num == 2){
/* Create rectangle object */
/* CODE OMITTED */
//Create shape, add to fixture def and finally create the fixture
obj.polygonShape = new b2PolygonShape();
obj.polygonShape-&gt;SetAsBox(shapeSize.x/PTM_RATIO, shapeSize.y/PTM_RATIO);
obj.fixtureDef-&gt;shape = obj.polygonShape;
obj.body-&gt;CreateFixture(obj.fixtureDef);
}else if(num == 3){
/* Create convex polygon object */
/* CODE OMITTED */
shapes, Box2Dcreating//Create shape, add to fixture def and finally create the fixture
obj.polygonShape = new b2PolygonShape();
obj.polygonShape-&gt;Set(vertices, numVerts);
obj.fixtureDef-&gt;shape = obj.polygonShape;
obj.body-&gt;CreateFixture(obj.fixtureDef);
}else if(num == 4){
/* Create concave multi-fixture polygon */
/* CODE OMITTED */
//Create two opposite rectangles
for(int i=0; i&lt;2; i++){
CGPoint shapeSize;
if(i == 0){ shapeSize = ccp(2.0f, 0.4f);
}else{ shapeSize = ccp(0.4f, 2.0f); }
CGPoint vertexArr[] = { ccp(0,0), ccp(shapeSize.x,0), ccp(shapeSize.x,shapeSize.y), ccp(0,shapeSize.y) };
int32 numVerts = 4;
b2Vec2 vertices[4];
NSMutableArray *vertexArray = [[[NSMutableArray alloc] init] autorelease];
shapes, Box2Dcreating//Set vertices
for(int i=0; i&lt;numVerts; i++){
vertices[i].Set(vertexArr[i].x, vertexArr[i].y);
[vertexArray addObject:[NSValue valueWithCGPoint:ccp(vertexArr[i].x *PTM_RATIO, vertexArr[i].y*PTM_RATIO)]];
}
//Create textured polygon
ccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST, GL_REPEAT,GL_REPEAT};
CCSprite *sprite = [TexturedPolygon createWithFile:@"box2.png" withVertices:vertexArray];
[sprite.texture setTexParameters:&amp;params];
[sprite setPosition:ccp(0,0)];
[sprite setColor:color];
[obj.sprite addChild:sprite];
//Create shape, set shape and create fixture
obj.polygonShape = new b2PolygonShape();
obj.polygonShape-&gt;Set(vertices, numVerts);
obj.fixtureDef-&gt;shape = obj.polygonShape;
obj.body-&gt;CreateFixture(obj.fixtureDef);
}
}
//Set a random color
[obj.sprite setColor:ccc3(arc4random()%255, arc4random()%255, arc4random()%255)];
}
- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
for( UITouch *touch in touches ) {
CGPoint location = [touch locationInView: [touch view]];
location = [[CCDirector sharedDirector] convertToGL: location];
[self addNewObjectWithCoords: location];
}
}
@end
<a id="id211" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec10"/>How it works...</h2></div></div></div><p>In this recipe, we randomly create objects with five different shapes: square, circle, rectangle, an oddly shaped convex polygon, and a simple concave polygon.<a id="id212" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rectangles:<p>Rectangles are created using the <code class="literal">b2PolygonShape</code> method <code class="literal">SetAsBox</code> just like in the first two recipes. In this example, we have a simple textured square as well as a rectangular column image.
<a id="id213" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Circles:<p>Circles are a special case in Box2D and they've been given a special class in <code class="literal">b2CircleShape</code>. After initialization, we simply set the <code class="literal">m_radius</code> variable of the circle shape. In this example, we also give the circle shaped objects a high <code class="literal">restitution</code> value to make them bounce. We will cover this in more depth in another recipe.
<a id="id214" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Convex polygons:<a id="id215" class="indexterm"/><p>Individual polygons must be <strong>convex</strong>. This means that every angle inside the polygon is less than 180 degrees. For this example, we've created an oddly shaped convex polygon with 8 vertices. We are using <code class="literal">TexturedPolygon</code> to accurately draw this polygon. For more information about the <code class="literal">TexturedPolygon</code> class, please refer to Chapter 1, Graphics.
<a id="id216" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Concave polygons:<a id="id217" class="indexterm"/><p><strong>Concave</strong> polygons can be represented by creating multiple convex polygons and linking them to one body using multiple fixtures. In this example, we link two simple convex polygons together by creating two fixtures on the same body. We reverse our width and height values to create a simple L-shaped object. With this technique, you can create arbitrarily complex shapes.
<a id="id218" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Extensibility of<code class="literal"> GameObject:</code><p>The <code class="literal">GameObject</code> class is primarily designed for single fixture bodies. It contains one <code class="literal">CCSprite</code> object, one <code class="literal">b2FixtureDef</code>, and so on. However, as you can see in the concave polygon example, you can create multiple <code class="literal">CCSprite</code> objects and link them to the main <code class="literal">GameObject</code> sprite. You can also reuse the Box2D object pointers within the <code class="literal">GameObject</code> instance to easily create multiple fixtures and shapes.
<a id="id219" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Dragging and collision filtering</h1></div></div></div><p>In a previous recipe, we handled user input to allow the user to drag an object. In this example, we see a bowl filled with pieces of fruit that can be dragged across the screen. A piece of fruit does not collide with another piece of fruit.<a id="id220" class="indexterm"/>
</p><div><img src="img/4002_04_05.jpg" alt="Dragging and collision filtering"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec12"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id221" class="indexterm"/>
</p><div><pre class="programlisting">enum { //Collision bits for filtering
CB_GROUND = 1&lt;&lt;0,
CB_FRUIT = 1&lt;&lt;2,
CB_BOWL = 1&lt;&lt;4
};
@implementation Ch4_DraggingAndFiltering
-(CCLayer*) runRecipe {
[super runRecipe];
[message setString:@"Pick up the fruit."];
//Create level boundaries
[self addLevelBoundaries];
dragging featureusing//Add fruit bowl
[self addFruitBasket];
//Initialization of any variables
fruitGrabbed = NO;
return self;
}
/* Add basket and fruit objects */
-(void) addFruitBasket {
/* Add the basket */
/* CODE OMITTED */
//Add physical parts
b2BodyDef bowlBodyDef;
bowlBodyDef.position.Set(0, 0);
bowlBodyDef.type = b2_staticBody;
b2Body *body = world-&gt;CreateBody(&amp;bowlBodyDef);
b2PolygonShape bowlShape;
b2FixtureDef bowlFixtureDef;
bowlFixtureDef.restitution = 0.5f;
bowlFixtureDef.filter.categoryBits = CB_BOWL;
bowlFixtureDef.filter.maskBits = CB_FRUIT;
//Rim left
bowlShape.SetAsEdge(b2Vec2(120.0f/PTM_RATIO,120.0f/PTM_RATIO), b2Vec2(180.0f/PTM_RATIO,0.0f/PTM_RATIO));
bowlFixtureDef.shape = &amp;bowlShape;
body-&gt;CreateFixture(&amp;bowlFixtureDef);
/* CODE OMITTED */
dragging featureusing/* Add fruit */
fruitObjects = [[[NSMutableArray alloc] init] autorelease];
[self addFruit:@"fruit_banana.png" position:ccp(210,200) shapeType:@"rect"];
[self addFruit:@"fruit_apple.png" position:ccp(230,200) shapeType:@"circle"];
[self addFruit:@"fruit_grapes.png" position:ccp(250,200) shapeType:@"rect"];
[self addFruit:@"fruit_orange.png" position:ccp(270,200) shapeType:@"circle"];
}
/* Add a fruit object with circle physical properties */
-(void) addFruit:(NSString*)spriteFrame position:(CGPoint)p shapeType:(NSString*)s {
//Create GameMisc object
GameMisc *fruit = [[GameMisc alloc] init];
fruit.gameArea = self;
//Define body def and create body
fruit.bodyDef-&gt;type = b2_dynamicBody;
fruit.bodyDef-&gt;position.Set(p.x/PTM_RATIO, p.y/PTM_RATIO);
fruit.bodyDef-&gt;userData = fruit;
fruit.body = world-&gt;CreateBody(fruit.bodyDef);
//Create fixture def
fruit.fixtureDef-&gt;density = 1.0f;
fruit.fixtureDef-&gt;friction = 0.3f;
fruit.fixtureDef-&gt;restitution = 0.4f;
fruit.fixtureDef-&gt;filter.categoryBits = CB_FRUIT;
fruit.fixtureDef-&gt;filter.maskBits = CB_GROUND | CB_BOWL; //Fruit does not collide with other fruit
//Create sprite
fruit.sprite = [CCSprite spriteWithSpriteFrameName:spriteFrame];
fruit.sprite.position = ccp(p.x,p.y);
if([s isEqualToString:@"circle"]){
/* Set fixture shape and sprite scale */
float textureSize = 160;
float shapeSize = 40;
dragging featureusingfruit.sprite.scale = shapeSize / textureSize * 2;
[gameNode addChild:fruit.sprite z:2];
fruit.circleShape = new b2CircleShape();
fruit.circleShape-&gt;m_radius = shapeSize/PTM_RATIO;
fruit.fixtureDef-&gt;shape = fruit.circleShape;
}else if([s isEqualToString:@"rect"]){
/* Set fixture shape and sprite scale */
CGPoint textureSize = ccp(300,100);
CGPoint shapeSize = ccp(60,20);
fruit.sprite.scaleX = shapeSize.x / textureSize.x * 2;
fruit.sprite.scaleY = shapeSize.y / textureSize.y * 2;
[gameNode addChild:fruit.sprite z:2];
fruit.polygonShape = new b2PolygonShape();
fruit.polygonShape-&gt;SetAsBox(shapeSize.x/PTM_RATIO, shapeSize.y/PTM_RATIO);
fruit.fixtureDef-&gt;shape = fruit.polygonShape;
}
//Finally create the fixture
fruit.body-&gt;CreateFixture(fruit.fixtureDef);
//Add object to container
[fruitObjects addObject:fruit];
grabbedFruit = fruit;
}
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
/* Grab the nearest fruit */
//We first grab a fruit.
dragging featureusing//Then, if another fruit is closer we grab that until we finally have the closest one.
float grabbedDistance = distanceBetweenPoints(point, ccp(grabbedFruit.body-&gt;GetPosition().x*PTM_RATIO, grabbedFruit.body-&gt;GetPosition().y*PTM_RATIO));
for(int i=0; i&lt;fruitObjects.count; i++){
GameMisc *fruit = [fruitObjects objectAtIndex:i];
float thisDistance = distanceBetweenPoints(ccp(fruit.body-&gt;GetPosition().x*PTM_RATIO, fruit.body-&gt;GetPosition().y*PTM_RATIO), point);
if(thisDistance &lt; grabbedDistance){
grabbedFruit = fruit;
grabbedDistance = thisDistance;
}
}
//Set the fruit to 'grabbed'
fruitGrabbed = YES;
//Immediately move the fruit
[self ccTouchesMoved:touches withEvent:event];
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
/* Reposition the grabbed fruit */
grabbedFruit.body-&gt;SetTransform(b2Vec2(point.x/PTM_RATIO, point.y/PTM_RATIO), grabbedFruit.body-&gt;GetAngle());
b2Vec2 moveDistance = b2Vec2( (point.x/PTM_RATIO - grabbedFruit.sprite.position.x/PTM_RATIO), (point.y/PTM_RATIO - grabbedFruit.sprite.position.y/PTM_RATIO) );
lastFruitVelocity = b2Vec2(moveDistance.x*20, moveDistance.y*20);
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* Release the fruit */
fruitGrabbed = NO;
dragging featureusinggrabbedFruit.body-&gt;SetLinearVelocity(lastFruitVelocity);
}
-(void) step: (ccTime) dt {
[super step:dt];
/* Suspend the fruit in mid-air while it is grabbed */
if(fruitGrabbed){
grabbedFruit.body-&gt;SetLinearVelocity(b2Vec2_zero);
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>How it works...</h2></div></div></div><p>In this example, we create a realistic 'grabbing' effect. We achieve this by repositioning the nearest Box2D body with the<code class="literal"> SetTransform</code> method:<a id="id227" class="indexterm"/>
</p><div><pre class="programlisting">grabbedFruit.body-&gt;SetTransform(b2Vec2(point.x/PTM_RATIO, point.y/PTM_RATIO), grabbedFruit.body-&gt;GetAngle());
</pre></div><p>We then store the previous distance the object was moved, to determine a final velocity and then to allow the object to be 'thrown' when the user lets go. We apply this velocity using the<code class="literal"> SetLinearVelocity</code> method:<a id="id228" class="indexterm"/>
</p><div><pre class="programlisting">grabbedFruit.body-&gt;SetLinearVelocity(lastFruitVelocity);
</pre></div><p>To suspend fruit in the air while the user has a finger on the screen, we set the object's velocity to<code class="literal"> b2Vec2_zero</code> while it is grabbed.
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collision filtering:<a id="id229" class="indexterm"/><p>In this example, we don't allow a fruit to collide with other fruits so that they can sit nicely in the bowl. We achieve this by setting the <code class="literal">filter</code> property on the fruit's fixture. Specifically, we set the <code class="literal">categoryBits</code> and <code class="literal">maskBits</code>:
<a id="id230" class="indexterm"/>
</p><div><pre class="programlisting">enum {
CB_GROUND = 1&lt;&lt;0,
CB_FRUIT = 1&lt;&lt;2,
CB_BOWL = 1&lt;&lt;4
};
fruit.fixtureDef-&gt;filter.categoryBits = CB_FRUIT;
fruit.fixtureDef-&gt;filter.maskBits = CB_GROUND | CB_BOWL;
</pre></div><p>The <code class="literal">categoryBits</code> variable indicates what kind of object this is. The <code class="literal">maskBits</code> variable indicates what kind of objects this should collide with. Both of these properties use <strong>bits</strong> and <strong>Boolean logic</strong> to specify how the object should interact. For example, | means "or". So, we are saying that the <code class="literal">CB_FRUIT</code> category can collide with <code class="literal">CB_GROUND</code> or <code class="literal">CB_BOWL</code> categories. Alternatively, filters can be set using <strong>filter groups</strong>. Also note that, if you do not specify the fixture's <code class="literal">filter</code> variable on object then it will not collide with an object that has a set filter. For more information about filtering, please refer to the Box2D manual at: <a class="ulink" href="http://www.box2d.org/manual.html">http://www.box2d.org/manual.html</a>.
<a id="id231" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Manipulating physical properties</h1></div></div></div><p>Box2D allows the user to set physical properties on bodies to create a wide array of effects. In this example, we see a block of ice pushing a box down a slope. We also see a number of bouncing balls.<a id="id232" class="indexterm"/>
<a id="id233" class="indexterm"/>
</p><div><img src="img/4002_04_06.jpg" alt="Manipulating physical properties"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe.<a id="id234" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec15"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">@implementation Ch4_PhysicalProperties
-(CCLayer*) runRecipe {
[super runRecipe];
[message setString:@"Friction and restitution"];
//Variable initialization
movableObjects = [[[NSMutableArray alloc] init] autorelease];
objectGrabbed = NO;
//Create level boundaries
[self addLevelBoundaries];
/* Add a crate, a block of ice, bouncing balls and a ledge */
//Crate with 0.4f friction
[self addBlockWithSpriteFile:@"crate2.png" friction:0.4f textureSize:64.0f shapeSize:20.0f position:ccp(130,250)];
//Ice block with 0.0f friction
[self addBlockWithSpriteFile:@"ice_block.png" friction:0.0f textureSize:70.0f shapeSize:20.0f position:ccp(10,250)];
//Ball with size 5.0f and restitution 0.9f
[self addBallWithShapeSize:5.0f restitution:0.9f position:ccp(450,200) color:ccc3(255,0,0)];
//Ball with size 10.0f and restitution 0.8f
[self addBallWithShapeSize:10.0f restitution:0.8f position:ccp(400,200) color:ccc3(255,128,0)];
//Ball with size 15.0f and restitution 0.7f
[self addBallWithShapeSize:15.0f restitution:0.7f position:ccp(350,200) color:ccc3(255,255,0)];
//Ball with size 20.0f and restitution 0.6f
[self addBallWithShapeSize:20.0f restitution:0.6f position:ccp(300,200) color:ccc3(0,255,0)];
//Add brick ledge
[self addLedge];
return self;
}
/* Add a block with a certain texture, size, position and friction */
-(void) addBlockWithSpriteFile:(NSString*)file friction:(float)friction textureSize:(float)textureSize shapeSize:(float)shapeSize position:(CGPoint)p {
/* CODE OMITTED */
}
/* Add a ball with a certain size, position, color and restitution */
-(void) addBallWithShapeSize:(float)shapeSize restitution:(float)restitution position:(CGPoint)p color:(ccColor3B)color {
/* CODE OMITTED */
}
/* Add a brick textured ledge polygon to show the blocks sliding down */
-(void) addLedge {
GameMisc *obj = [[GameMisc alloc] init];
obj.gameArea = self;
physical propertiesmanipulatingobj.bodyDef-&gt;position.Set(0,100/PTM_RATIO);
obj.body = world-&gt;CreateBody(obj.bodyDef);
obj.fixtureDef-&gt;density = 1.0f;
obj.fixtureDef-&gt;friction = 0.3f;
obj.fixtureDef-&gt;restitution = 0.2f;
float polygonSize = 4;
CGPoint vertexArr[] = { ccp(0,0.8f), ccp(2,0.5f), ccp(2,0.7f), ccp(0,1) };
int32 numVerts = 4;
b2Vec2 vertices[4];
NSMutableArray *vertexArray = [[[NSMutableArray alloc] init] autorelease];
for(int i=0; i&lt;numVerts; i++){
vertices[i].Set(vertexArr[i].x*polygonSize, vertexArr[i].y*polygonSize);
[vertexArray addObject:[NSValue valueWithCGPoint:ccp(vertexArr[i].x*PTM_RATIO*polygonSize,
vertexArr[i].y*PTM_RATIO*polygonSize)]];
}
ccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};
obj.sprite = [TexturedPolygon createWithFile:@"bricks2.png" withVertices:vertexArray];
[obj.sprite.texture setTexParameters:&amp;params];
[obj.sprite setPosition:ccp(0,100)];
[gameNode addChild:obj.sprite z:1];
obj.polygonShape = new b2PolygonShape();
obj.polygonShape-&gt;Set(vertices, numVerts);
obj.fixtureDef-&gt;shape = obj.polygonShape;
obj.body-&gt;CreateFixture(obj.fixtureDef);
}
@end
<a id="id236" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec16"/>How it works...</h2></div></div></div><p>In this example, we see multiple objects each with different physical properties.<a id="id237" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Density:<p>Body <strong>density</strong> determines how much force is required to move an object around. Two objects with different sizes and the same density will have different masses. The larger object will naturally take a larger force to move.
<a id="id238" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Friction:<p><strong>Friction</strong> determines how difficult an object is to move against another object. Physics nerds may point out the difference between static and kinetic friction. Box2D amalgamates them into one variable while assuming a constant static to kinetic ratio. In our example, the block of ice has absolutely no friction. This means that it will slide around on any surface. This allows the block to slowly push the crate down the ramp until it finally falls on the bouncing balls.
<a id="id239" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Restitution:<p>The term <strong>restitution</strong> is interchangeable with elasticity. This measures the 'bounciness' of an object. An object with a restitution of <code class="literal">1.0f</code> will theoretically bounce forever. In our example, we see four balls each with a different restitution. This causes them to bounce at different rates. To see these differences in action, quickly grab the block of ice before it pushes the crate over the edge of the ledge.
<a id="id240" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec07"/>Applying impulses</h1></div></div></div><p>In Box2D, bodies can be moved around using<strong> impulses</strong> and<strong> forces</strong>. In this recipe, we will use impulses to accurately shoot a basketball into a basketball net.<a id="id241" class="indexterm"/>
</p><div><img src="img/4002_04_07.jpg" alt="Applying impulses"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe.<a id="id242" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">enum { //Object type tags
TYPE_OBJ_BASKETBALL = 0,
TYPE_OBJ_SHOOTER = 1,
TYPE_OBJ_NET_SENSOR = 2
};
@implementation Ch4_Impulses
-(CCLayer*) runRecipe {
[super runRecipe];
[message setString:@"Shoot the ball in the hoop."];
//Create level boundaries
[self addLevelBoundaries];
//Add level background
CCSprite *bg = [CCSprite spriteWithFile:@"bball_bg.png"];
bg.position = ccp(240,160);
[gameNode addChild:bg z:0];
//Add basketball
[self addBasketball];
//Add basketball net
[self addBasketballNet];
//Add shooter
[self addShooter];
return self;
impulsesapplying}
/* Add a basketball net with a sensor */
-(void) addBasketballNet {
/* CODE OMITTED */
//Add net sensor
GameSensor *gameObjSensor = [[GameSensor alloc] init];
gameObjSensor.typeTag = TYPE_OBJ_NET_SENSOR;
gameObjSensor.gameArea = self;
gameObjSensor.bodyDef-&gt;type = b2_staticBody;
gameObjSensor.bodyDef-&gt;position.Set(0,0);
gameObjSensor.bodyDef-&gt;userData = gameObjSensor;
gameObjSensor.body = world-&gt;CreateBody(gameObjSensor.bodyDef);
gameObjSensor.polygonShape = new b2PolygonShape();
gameObjSensor.polygonShape-&gt;SetAsEdge(b2Vec2(370.0f/PTM_RATIO,200.0f/PTM_RATIO), b2Vec2(380.0f/PTM_RATIO,200.0f/PTM_RATIO));
gameObjSensor.fixtureDef-&gt;shape = gameObjSensor.polygonShape;
gameObjSensor.fixtureDef-&gt;isSensor = YES;
gameObjSensor.body-&gt;CreateFixture(gameObjSensor.fixtureDef);
}
/* Add a basketball */
-(void) addBasketball {
/* CODE OMITTED */
}
/* Add a shooter with reverse karate chop action! */
-(void) addShooter {
/* CODE OMITTED */
impulsesapplying}
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
/* Apply an impulse when the user touches the screen */
CGPoint vect = ccp(point.x - basketball.body-&gt;GetPosition().x*PTM_RATIO, point.y - basketball.body-&gt;GetPosition().y*PTM_RATIO);
basketball.body-&gt;ApplyLinearImpulse(b2Vec2(vect.x/20, vect.y/20) , basketball.body-&gt;GetPosition() );
}
/* Main collision handling routine */
-(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB {
//SENSOR to MISC collision
if(objA.type == GO_TYPE_SENSOR &amp;&amp; objB.type == GO_TYPE_MISC){
[self handleCollisionWithSensor:(GameSensor*)objA withMisc:(GameMisc*)objB];
}else if(objA.type == GO_TYPE_MISC &amp;&amp; objB.type == GO_TYPE_SENSOR){
[self handleCollisionWithSensor:(GameSensor*)objB withMisc:(GameMisc*)objA];
}
}
/* SENSOR to MISC collision */
-(void) handleCollisionWithSensor:(GameSensor*)sensor withMisc:(GameMisc*)misc {
if(misc.typeTag == TYPE_OBJ_BASKETBALL &amp;&amp; sensor.typeTag == TYPE_OBJ_NET_SENSOR){
//Animate the net when the shooter makes a basket
/* CODE OMITTED */
}else if(misc.typeTag == TYPE_OBJ_BASKETBALL &amp;&amp; sensor.typeTag == TYPE_OBJ_SHOOTER){
//Animate the shooter's arm and apply an impulse when he touches the ball */
impulsesapplying/* CODE OMITTED */
basketball.body-&gt;SetLinearVelocity(b2Vec2(0,0));
basketball.body-&gt;ApplyLinearImpulse(b2Vec2(3.5f, 7) , basketball.body-&gt;GetPosition() );
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>How it works...</h2></div></div></div><p>In this scene, we see a basketball player shooting the ball into a basket. When he comes in contact with the ball he shoots it into the net.<a id="id246" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Impulses:<p>When the basketball touches the basketball player, we reset the ball's velocity and then we apply a precise impulse to accurately shoot the ball into the net:
</p><div><pre class="programlisting">basketball.body-&gt;SetLinearVelocity(b2Vec2(0,0));
basketball.body-&gt;ApplyLinearImpulse(b2Vec2(3.5f, 7) , basketball.body-&gt;GetPosition() );
</pre></div><p>Applying an impulse, immediately changes the <strong>momentum</strong> of the body. Instead of applying a force over time, an impulse applies instantaneous force to immediately redirect an object. Impulses also wake up a sleeping body if necessary.
<a id="id247" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">GameObject</code> typeTag:<a id="id248" class="indexterm"/><p>Instances of the <code class="literal">GameObject</code> class have heretofore been identified with the <code class="literal">type</code> property as specified by the extending class. For more granular object identification, you can use the <code class="literal">typeTag</code> enumeration. This allows us to tag objects to perform a number of tasks. In this example, we use <code class="literal">typeTag</code> during collision response to properly animate the basketball player as well as the basketball net.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Applying forces</h1></div></div></div><p>Unlike impulses, forces must be applied over time to significantly move a body in the physical world. In this recipe, we see a simulation of our solar system.<a id="id249" class="indexterm"/>
</p><div><img src="img/4002_04_08.jpg" alt="Applying forces"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe.<a id="id250" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">@implementation Ch4_Forces
-(CCLayer*) runRecipe {
[super runRecipe];
//Set our gravity to 0
world-&gt;SetGravity(b2Vec2(0,0));
//Level background
CCSprite *bg = [CCSprite spriteWithFile:@"solar_system_bg.png"];
bg.position = ccp(240,160);
[gameNode addChild:bg z:0];
//Add Planets
planets = [[[NSMutableDictionary alloc] init] autorelease];
[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"solar_system.plist"];
forcesapplying[self addPlanetWithSpriteFrameName:@"sun.png" position:ccp(240,160)];
[self addPlanetWithSpriteFrameName:@"mercury.png" position:ccp(210,160)];
[self addPlanetWithSpriteFrameName:@"venus.png" position:ccp(195,160)];
[self addPlanetWithSpriteFrameName:@"earth.png" position:ccp(170,160)];
[self addPlanetWithSpriteFrameName:@"mars.png" position:ccp(150,160)];
[self addPlanetWithSpriteFrameName:@"jupiter.png" position:ccp(120,160)];
[self addPlanetWithSpriteFrameName:@"saturn.png" position:ccp(90,160)];
[self addPlanetWithSpriteFrameName:@"uranus.png" position:ccp(60,160)];
[self addPlanetWithSpriteFrameName:@"neptune.png" position:ccp(30,160)];
//Apply initial impulses to planets
[[planets objectForKey:@"mercury.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,0.075f), [[planets objectForKey:@"mercury.png"] body]-&gt;GetPosition());
[[planets objectForKey:@"venus.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,0.25f), [[planets objectForKey:@"venus.png"] body]-&gt;GetPosition());
[[planets objectForKey:@"earth.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,0.45f), [[planets objectForKey:@"earth.png"] body]-&gt;GetPosition());
[[planets objectForKey:@"mars.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,0.175f), [[planets objectForKey:@"mars.png"] body]-&gt;GetPosition());
[[planets objectForKey:@"jupiter.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,1.3f), [[planets objectForKey:@"jupiter.png"] body]-&gt;GetPosition());
[[planets objectForKey:@"saturn.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,4.5f), [[planets objectForKey:@"saturn.png"] body]-&gt;GetPosition());
[[planets objectForKey:@"uranus.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,0.6f), [[planets objectForKey:@"uranus.png"] body]-&gt;GetPosition());
[[planets objectForKey:@"neptune.png"] body]-&gt;ApplyLinearImpulse(b2Vec2(0,0.8f), [[planets objectForKey:@"neptune.png"] body]-&gt;GetPosition());
//Fast forward about 16 seconds to create realistic orbits from the start
for(int i=0; i&lt;1000; i++){
[self step:0.016666667f];
forcesapplying}
return self;
}
/* Every tick applies a force on each planet according to how large it is and how far it is from the sun. This simulates heavenly rotation. */
-(void) step:(ccTime)dt {
[super step:dt];
GameMisc *sun = [planets objectForKey:@"sun.png"];
for(id key in planets){
GameMisc *planet = [planets objectForKey:key];
if(![key isEqualToString:@"sun.png"]){
CGPoint vect = ccp(sun.body-&gt;GetPosition().x - planet.body-&gt;GetPosition().x, sun.body-&gt;GetPosition().y - planet.body-&gt;GetPosition().y);
float planetSize = pow([planet.sprite contentSize].width,2);
float dist = distanceBetweenPoints(ccp(sun.body-&gt;GetPosition().x, sun.body-&gt;GetPosition().y),
ccp(planet.body-&gt;GetPosition().x, planet.body-&gt;GetPosition().y));
float mod = dist/planetSize*2000;
planet.body-&gt;ApplyForce(b2Vec2(vect.x/mod, vect.y/mod) , planet.body-&gt;GetPosition() );
}
}
}
/* Add a planet with a spriteFrame and a position. We determine the shape size from the texture size. */
-(void) addPlanetWithSpriteFrameName:(NSString*)frameName position:(CGPoint)p {
/* CODE OMITTED */
}
@end
<a id="id253" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>How it works...</h2></div></div></div><p>In this scene, we see eight planets orbiting the sun. They orbit at roughly the same speed.<a id="id254" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Forces:<p>Each planet is having a constant force applied to it in the direction of the sun:
</p><div><pre class="programlisting">planet.body-&gt;ApplyForce(b2Vec2(vect.x/mod, vect.y/mod) , planet.body-&gt;GetPosition() );
</pre></div><p>This, combined with its initial momentum applied by an impulse, creates an orbit around the sun. The forces applied take into account planet size and distance from the sun in a way similar to how real gravity works.
</p></li><li class="listitem" style="list-style-type: disc">Torque:<p>When applying a force or an impulse, you must specify the point on the object where the force or impulse is applied. If this is not the exact center of mass, then a <strong>torque</strong> will also be applied to the object. This will change the angular velocity of the body and will make it spin.
<a id="id255" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Gravity:<p>As you can see in this example, setting gravity to <code class="literal">b2Vec2(0.0f, 0.0f)</code> creates a top-down physical simulation.
<a id="id256" class="indexterm"/>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>See also...</h2></div></div></div><p>Setting gravity to<code class="literal"> b2Vec2(0.0f, 0.0f)</code> creates a top-down simulation. We will use this technique in later recipes, including<em> Creating a top-down isometric game engine</em> found later in this chapter.
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec09"/>Asynchronous body destruction</h1></div></div></div><p>So far, we have learned how to create bodies, how to reposition them, and how to apply forces and impulses to move them around onscreen. In this example, we will see how to destroy a body during the physics simulation. This is naturally a very tricky process that can create bugs and cause game crashes if you're not careful.<a id="id257" class="indexterm"/>
</p><div><img src="img/4002_04_09.jpg" alt="Asynchronous body destruction"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also note that some of the following code has been omitted for brevity.
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id258" class="indexterm"/>
</p><div><pre class="programlisting">@interface GameObjectCallback : NSObject {
@public
GameObject *gameObject;
NSString *callback;
}
@end
@interface QueuedAction : NSObject {
@public
GameObject* gameObject;
CCAction* action;
}
@end
@interface GameArea2D : Recipe {
NSMutableArray *bodiesToDestroy;
NSMutableArray *postDestructionCallbacks;
NSMutableArray *bodiesToCreate;
NSMutableArray *queuedActions;
}
@implementation GameArea2D
-(void) step: (ccTime) dt {
//Process body destruction/creation
[self destroyBodies];
[self createBodies];
[self runQueuedActions];
}
asynchronous body destructionsteps/* Mark a body for destruction */
-(void) markBodyForDestruction:(GameObject*)obj {
[bodiesToDestroy addObject:[NSValue valueWithPointer:obj]];
}
/* Destroy queued bodies */
-(void) destroyBodies {
for(NSValue *value in bodiesToDestroy){
GameObject *obj = (GameObject*)[value pointerValue];
if(obj &amp;&amp; obj.body &amp;&amp; !obj.markedForDestruction){
obj.body-&gt;SetTransform(b2Vec2(0,0),0);
world-&gt;DestroyBody(obj.body);
obj.markedForDestruction = YES;
}
}
[bodiesToDestroy removeAllObjects];
//Call all game object callbacks
for(NSValue *value in postDestructionCallbacks){
GameObjectCallback *goc = (GameObjectCallback*)value;
[goc.gameObject runAction:[CCCallFunc actionWithTarget:goc.gameObject selector:NSSelectorFromString(goc.callback)]];
}
[postDestructionCallbacks removeAllObjects];
}
/* Mark a body for creation */
-(void) markBodyForCreation:(GameObject*)obj {
[bodiesToCreate addObject:[NSValue valueWithPointer:obj]];
}
asynchronous body destructionsteps/* Create all queued bodies */
-(void) createBodies {
for(NSValue *value in bodiesToCreate){
GameObject *obj = (GameObject*)[value pointerValue];
obj.body = world-&gt;CreateBody(obj.bodyDef);
obj.body-&gt;CreateFixture(obj.fixtureDef);
}
[bodiesToCreate removeAllObjects];
}
/* Run any queued actions after creation/destruction */
-(void) runQueuedActions {
for(NSValue *value in queuedActions){
QueuedAction *qa = (QueuedAction*)[value pointerValue];
GameObject *gameObject = (GameObject*)qa.gameObject;
CCAction *action = (CCAction*)qa.action;
[gameObject runAction:action];
}
[queuedActions removeAllObjects];
}
@end
@implementation Ch4_AsyncBodyDestruction
-(CCLayer*) runRecipe {
[super runRecipe];
[message setString:@"Tap to throw a grenade."];
//Create level boundaries
[self addLevelBoundaries];
asynchronous body destructionsteps//Add gunman
[self addGunman];
//Initialize explosion animation
[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"explosion5.plist"];
//Initialize grenade container
grenades = [[[NSMutableArray alloc] init] autorelease];
return self;
}
-(void) step:(ccTime)delta {
[super step:delta];
//Grenade life cycle
for(id obj in grenades){
GameMisc *grenade = (GameMisc*)obj;
grenade.life -= delta;
//If a grenade is out of life we mark it for destruction, do cleanup and finally animate an explosion
if(grenade.life &lt; 0){
[self markBodyForDestruction:grenade];
[grenades removeObject:obj];
[self explosionAt:grenade.sprite.position];
[gameNode removeChild:grenade.sprite cleanup:NO];
}
}
//Explosion life cycle
for(id obj in explosions){
GameMisc *explosion = (GameMisc*)explosion;
explosion.life -= delta;
if(explosion.life &lt; 0){
[explosions removeObject:explosion];
[gameNode removeChild:explosion.sprite cleanup:YES];
}
}
}
asynchronous body destructionsteps/* Callback for throwing the arm. This involves animating the arm and creating a grenade */
-(void) throwGrenade {
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
//Animate the arm
CCAnimation *animation = [[CCAnimation alloc] initWithName:@"gunmanStandRightArmEmpty" delay:1.0f];
[animation addFrame:[cache spriteFrameByName:@"gunman_stand_right_arm_empty.png"]];
[gunmanArm runAction:[CCRepeatForever actionWithAction:[CCAnimate actionWithAnimation:animation]]];
//Create and launch a grenade
GameMisc *grenade = [[GameMisc alloc] init];
grenade.life = 5.0f;
grenade.gameArea = self;
CGPoint grenadePosition = ccp(65,150);
grenade.bodyDef-&gt;type = b2_dynamicBody;
grenade.bodyDef-&gt;position.Set(grenadePosition.x/PTM_RATIO, grenadePosition.y/PTM_RATIO);
grenade.body = world-&gt;CreateBody(grenade.bodyDef);
grenade.body-&gt;SetTransform(b2Vec2(grenadePosition.x/PTM_RATIO, grenadePosition.y/PTM_RATIO),PI/2);
CGPoint textureSize = ccp(16,16);
CGPoint shapeSize = ccp(7,7);
grenade.sprite = [CCSprite spriteWithSpriteFrameName:@"gunman_grenade.png"];
grenade.sprite.position = ccp(grenadePosition.x,grenadePosition.y);
grenade.sprite.scaleX = shapeSize.x / textureSize.x * 2;
grenade.sprite.scaleY = shapeSize.y / textureSize.y * 2;
[gameNode addChild:grenade.sprite z:1];
grenade.circleShape = new b2CircleShape();
grenade.circleShape-&gt;m_radius = shapeSize.x/PTM_RATIO;
grenade.fixtureDef-&gt;shape = grenade.circleShape;
grenade.body-&gt;CreateFixture(grenade.fixtureDef);
[grenades addObject:grenade];
grenade.body-&gt;ApplyLinearImpulse(b2Vec2(1.0f,2.0f) , grenade.body-&gt;GetPosition() );
grenade.body-&gt;SetAngularVelocity(PI);
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>How it works...</h2></div></div></div><p>In this recipe, we have the ability to throw grenades that explode after five seconds. The explosion launches any other objects in the immediate area.<a id="id263" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Destroying a<code class="literal"> b2Body:</code><a id="id264" class="indexterm"/><p>Box2D does not allow bodies to be destroyed during a <code class="literal">world-&gt;Step(dt, velocityIterations, positionIterations)</code> call. Because of this, collision response routines and timed callbacks cannot synchronously initiate body destruction. To solve this problem, we have created a simple asynchronous system that can queue up bodies for destruction and creation. This system uses the following methods:
</p><div><pre class="programlisting">-(void) markBodyForDestruction:(GameObject*)obj;
-(void) destroyBodies;
-(void) markBodyForCreation:(GameObject*)obj;
-(void) createBodies;
-(void) runQueuedActions;
<a id="id265" class="indexterm"/>
</pre></div><p>Bodies are created and destroyed after each physics step has completed.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">GameObjectCallback</code> and<code class="literal"> QueuedAction:</code><p>The <code class="literal">GameObjectCallback</code> and <code class="literal">QueuedAction</code> helper classes allow us to queue up method callbacks and <code class="literal">CCAction</code> instances to use after object creation/deletion. This can help maintain a logical order of operations when the game is running.
<a id="id266" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">GameObject</code> life:<p>In the class <code class="literal">GameMisc</code>, we added a <code class="literal">life</code> value. In this recipe, we get to put it to use. Each grenade's <code class="literal">life</code> ticks away until it explodes. The explosion created is also a <code class="literal">GameMisc</code> object with a set amount of <code class="literal">life</code> corresponding to its animation duration. Life can also be used for actors and breakable objects.
<a id="id267" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Using joints</h1></div></div></div><p>The last major feature of Box2D we have yet to investigate is<strong> joints</strong>. Joints allow us to link objects to create simple machines like pulleys, levers, and simple motors. In this recipe, we will learn how to create a simple seesaw using a joint.<a id="id268" class="indexterm"/>
</p><div><img src="img/4002_04_10.jpg" alt="Using joints"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also note that some of the following code has been omitted for brevity.<a id="id269" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">@implementation Ch4_Joints
-(CCLayer*) runRecipe {
[super runRecipe];
[message setString:@"Drop the weight on the see-saw"];
//Initialization
movableObjects = [[[NSMutableArray alloc] init] autorelease];
objectGrabbed = NO;
//Create level boundaries
[self addLevelBoundaries];
//Add objects
[self addSeeSaw];
[self addBoxWithPosition:ccp(130,120) file:@"crate2.png" density:1.0f];
[self addBoxWithPosition:ccp(160,120) file:@"crate2.png" density:1.0f];
[self addBoxWithPosition:ccp(145,150) file:@"crate2.png" density:1.0f];
[self addBoxWithPosition:ccp(270,100) file:@"weight.png" density:15.0f];
return self;
}
/* Create a complex see-saw object */
-(void) addSeeSaw {
/* The triangle is the static base of the see-saw */
CGPoint trianglePosition = ccp(240,50);
GameMisc *triangle = [[GameMisc alloc] init];
triangle.gameArea = self;
triangle.bodyDef-&gt;type = b2_staticBody;
triangle.bodyDef-&gt;position.Set(trianglePosition.x/PTM_RATIO, trianglePosition.y/PTM_RATIO);
triangle.body = world-&gt;CreateBody(triangle.bodyDef);
jointsusing//Our triangle polygon
float polygonSize = 2.0f;
CGPoint vertexArr[] = { ccp(0,0), ccp(1,0), ccp(0.5f,1) };
int32 numVerts = 3;
b2Vec2 vertices[3];
NSMutableArray *vertexArray = [[[NSMutableArray alloc] init] autorelease];
for(int i=0; i&lt;numVerts; i++){
vertices[i].Set(vertexArr[i].x*polygonSize, vertexArr[i].y*polygonSize);
[vertexArray addObject:[NSValue valueWithCGPoint:ccp(vertexArr[i].x*PTM_RATIO*polygonSize,
vertexArr[i].y*PTM_RATIO*polygonSize)]];
}
ccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};
triangle.sprite = [TexturedPolygon createWithFile:@"box.png" withVertices:vertexArray];
[triangle.sprite.texture setTexParameters:&amp;params];
[triangle.sprite setPosition:ccp(trianglePosition.x,trianglePosition.y)];
[gameNode addChild:triangle.sprite z:1];
triangle.polygonShape = new b2PolygonShape();
triangle.polygonShape-&gt;Set(vertices, numVerts);
triangle.fixtureDef-&gt;shape = triangle.polygonShape;
triangle.body-&gt;CreateFixture(triangle.fixtureDef);
/* The plank is the dynamic part of the see-saw */
CGPoint plankPosition = ccp(270,80);
GameMisc *plank = [[GameMisc alloc] init];
plank.gameArea = self;
plank.bodyDef-&gt;type = b2_dynamicBody;
plank.bodyDef-&gt;position.Set(plankPosition.x/PTM_RATIO, plankPosition.y/PTM_RATIO);
plank.body = world-&gt;CreateBody(plank.bodyDef);
jointsusingplank.body-&gt;SetTransform(b2Vec2(plankPosition.x/PTM_RATIO, plankPosition.y/PTM_RATIO),PI/2);
CGPoint textureSize = ccp(54,215);
CGPoint shapeSize = ccp(12,180);
plank.sprite = [CCSprite spriteWithFile:@"column2.png"];
plank.sprite.position = ccp(plankPosition.x,plankPosition.y);
plank.sprite.scaleX = shapeSize.x / textureSize.x * 2;
plank.sprite.scaleY = shapeSize.y / textureSize.y * 2;
[gameNode addChild:plank.sprite z:1];
plank.polygonShape = new b2PolygonShape();
plank.polygonShape-&gt;SetAsBox(shapeSize.x/PTM_RATIO, shapeSize.y/PTM_RATIO);
plank.fixtureDef-&gt;shape = plank.polygonShape;
plank.body-&gt;CreateFixture(plank.fixtureDef);
/* We initialize a revolute joint linking the plank to the triangle */
b2RevoluteJointDef rjd;
b2RevoluteJoint* joint;
rjd.Initialize(plank.body, triangle.body, b2Vec2(trianglePosition.x/PTM_RATIO + polygonSize/2, trianglePosition.y/PTM_RATIO + polygonSize/2));
joint = (b2RevoluteJoint*)world-&gt;CreateJoint(&amp;rjd);
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>How it works...</h2></div></div></div><p>By dropping the heavy weight object on one side, we can launch the lighter boxes up into the air from the other side. This is achieved using a simple joint.<a id="id272" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Joint types:<p>All joints link two Box2D bodies. Each joint is represented by a class that derives from <code class="literal">b2Joint</code>. These include <code class="literal">b2PulleyJoint, b2WeldJoint, b2RopeJoint,</code> and more. A comprehensive overview of all Box2D joint types is beyond the scope of this book. Please refer to the Box2D testbed for example code for each joint as well as the Box2D manual page at <a class="ulink" href="http://www.box2d.org/manual.html">http://www.box2d.org/manual.html</a>.
<a id="id273" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Revolute joints:<a id="id274" class="indexterm"/><p>In this example, we are using a <code class="literal">b2RevoluteJoint</code> to force two bodies to share a common anchor point:
</p><div><pre class="programlisting">b2RevoluteJointDef rjd;
b2RevoluteJoint* joint;
rjd.Initialize(plank.body, triangle.body, b2Vec2(trianglePosition.x/PTM_RATIO + polygonSize/2, trianglePosition.y/PTM_RATIO + polygonSize/2));
joint = (b2RevoluteJoint*)world-&gt;CreateJoint(&amp;rjd);
</pre></div><p>By pinning the dynamic <code class="literal">plank</code> body to the static <code class="literal">triangle</code> body, in this example, we have constrained the movement of the <code class="literal">plank</code> on the X and Y axes. Now that it can't move, it can only rotate. This creates a realistic seesaw effect.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec11"/>Creating a vehicle</h1></div></div></div><p>Combining two or more joints can create some interesting effects. In this example, we will create a car that can be driven around a level.<a id="id275" class="indexterm"/>
</p><div><img src="img/4002_04_11.jpg" alt="Creating a vehicle"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also note that some of the following code has been omitted for brevity.<a id="id276" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id277" class="indexterm"/>
</p><div><pre class="programlisting">@implementation Ch4_Vehicles
-(CCLayer*) runRecipe {
[super runRecipe];
[message setString:@"Press and hold to drive car."];
//Initialization
pressedLeft = NO;
pressedRight = NO;
//Create level
[self createLevel];
//Add taxi
[self addTaxi];
return self;
}
-(void) createLevel {
/* Create a sine wave road for our car */
b2BodyDef groundBodyDef;
groundBodyDef.position.Set(0, 0);
b2Body *body = world-&gt;CreateBody(&amp;groundBodyDef);
vehiclecreatingb2PolygonShape groundBox;
b2FixtureDef groundFixtureDef;
groundFixtureDef.restitution = 0.0f;
groundFixtureDef.friction = 10.0f; //The road has a lot of friction
groundFixtureDef.filter.categoryBits = CB_GROUND;
groundFixtureDef.filter.maskBits = CB_CAR | CB_WHEEL;
groundBox.SetAsEdge(b2Vec2(-960/PTM_RATIO,0), b2Vec2(-960/PTM_RATIO,200/PTM_RATIO));
groundFixtureDef.shape = &amp;groundBox;
body-&gt;CreateFixture(&amp;groundFixtureDef);
groundBox.SetAsEdge(b2Vec2(960/PTM_RATIO,0), b2Vec2(960/PTM_RATIO,200/PTM_RATIO));
groundFixtureDef.shape = &amp;groundBox;
body-&gt;CreateFixture(&amp;groundFixtureDef);
float32 x1; float32 y1;
for(int u = -1; u &lt; 2; u++){
//Add Edge Shapes
x1 = -15.0f;
y1 = 2.0f * cosf(x1 / 10.0f * b2_pi);
for (int32 i = 0; i &lt; 60; ++i)
{
float32 x2 = x1 + 0.5f;
float32 y2 = 2.0f * cosf(x2 / 10.0f * b2_pi);
b2PolygonShape shape;
shape.SetAsEdge(b2Vec2(x1 + u*960/PTM_RATIO, y1), b2Vec2(x2 + u*960/PTM_RATIO, y2));
body-&gt;CreateFixture(&amp;shape, 0.0f);
vehiclecreatingx1 = x2;
y1 = y2;
}
//Add corresponding graphics
CCSprite *bg = [CCSprite spriteWithFile:@"road_bg.png"];
bg.position = ccp(u*960,70);
[gameNode addChild:bg z:0];
CCSprite *fg = [CCSprite spriteWithFile:@"road_fg.png"];
fg.position = ccp(u*960,70);
[gameNode addChild:fg z:2];
}
/* Add two bricks walls so you can't drive off the course */
[self addBrickWallSpriteAtPosition:ccp(970,60)];
[self addBrickWallSpriteAtPosition:ccp(-970,60)];
}
-(void) addTaxi {
// NOTE: In b2Settings.h we increased the b2_maxPolygonVertices definition:
// #define b2_maxPolygonVertices 16
[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"taxi.plist"];
CGPoint taxiPosition = ccp(-960,80);
float taxiScale = 0.2f;
taxi = [[GameMisc alloc] init];
taxi.gameArea = self;
taxi.bodyDef-&gt;type = b2_dynamicBody;
taxi.bodyDef-&gt;position.Set(taxiPosition.x/PTM_RATIO, taxiPosition.y/PTM_RATIO);
taxi.body = world-&gt;CreateBody(taxi.bodyDef);
taxi.fixtureDef-&gt;filter.categoryBits = CB_CAR;
taxi.fixtureDef-&gt;filter.maskBits = CB_GROUND;
taxi.fixtureDef-&gt;density = 0.5f;
taxi.fixtureDef-&gt;friction = 0.25f;
taxi.fixtureDef-&gt;restitution = 0.0f;
//Polygon
/* CODE OMITTED */
vehiclecreating//Wheels
CGPoint wheelPosition[] = { ccp(taxiPosition.x + 16, taxiPosition.y), ccp(taxiPosition.x + 43, taxiPosition.y) };
for(int i=0; i&lt;2; i++){
GameMisc *wheel = [[GameMisc alloc] init];
if(i == 0){
wheel1 = wheel;
}else{
wheel2 = wheel;
}
wheel.gameArea = self;
wheel.bodyDef-&gt;type = b2_dynamicBody;
wheel.bodyDef-&gt;position.Set(wheelPosition[i].x/PTM_RATIO, wheelPosition[i].y/PTM_RATIO);
wheel.body = world-&gt;CreateBody(wheel.bodyDef);
wheel.body-&gt;SetTransform(b2Vec2(wheelPosition[i].x/PTM_RATIO, wheelPosition[i].y/PTM_RATIO),PI/2);
wheel.fixtureDef-&gt;filter.categoryBits = CB_WHEEL;
wheel.fixtureDef-&gt;filter.maskBits = CB_GROUND;
wheel.fixtureDef-&gt;density = 10.0f;
wheel.fixtureDef-&gt;friction = 10.0f;
wheel.fixtureDef-&gt;restitution = 0.0f;
CGPoint textureSize = ccp(52,51);
CGPoint shapeSize = ccp(9,9);
wheel.sprite = [CCSprite spriteWithSpriteFrameName:@"taxi_wheel.png"];
wheel.sprite.position = ccp(wheelPosition[i].x,wheelPosition[i].y);
wheel.sprite.scaleX = shapeSize.x / textureSize.x * 2;
wheel.sprite.scaleY = shapeSize.y / textureSize.y * 2;
[gameNode addChild:wheel.sprite z:1];
wheel.circleShape = new b2CircleShape();
wheel.circleShape-&gt;m_radius = shapeSize.x/PTM_RATIO;
wheel.fixtureDef-&gt;shape = wheel.circleShape;
wheel.body-&gt;CreateFixture(wheel.fixtureDef);
wheel.body-&gt;SetAngularDamping(1.0f);
//Add Joint to connect wheel to the taxi
vehiclecreatingb2RevoluteJointDef rjd;
b2RevoluteJoint* joint;
rjd.Initialize(wheel.body, taxi.body, b2Vec2(wheelPosition[i].x/PTM_RATIO, wheelPosition[i].y/PTM_RATIO));
joint = (b2RevoluteJoint*)world-&gt;CreateJoint(&amp;rjd);
}
}
-(void) step: (ccTime) dt {
[super step:dt];
gameNode.position = ccp(-taxi.sprite.position.x + 240, -taxi.sprite.position.y + 160);
//Front wheel drive
//We apply some counter-torque to steady the car
if(pressedRight){
wheel2-&gt;body-&gt;ApplyTorque(-20.0f);
taxi-&gt;body-&gt;ApplyTorque(5.0f);
}else if(pressedLeft){
wheel1-&gt;body-&gt;ApplyTorque(20.0f);
taxi-&gt;body-&gt;ApplyTorque(-5.0f);
}
}
@end
<a id="id282" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>How it works...</h2></div></div></div><p>By pressing on either side of the screen, we can see the car drive forward or backward until it inevitably meets a brick wall at either end of the level.<a id="id283" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The car:<p>To create a simple car in Box2D, all you have to do is attach two circles to a polygon using revolute joints. Each circle, or 'wheel', has high density and friction to help it pull the car along the road. It also has a low restitution to limit bouncing. When placed on an uneven surface the car will then roll forward or backward. Also, for the sake of simplicity the actual chasis of the car is a convex polygon.
</p></li><li class="listitem" style="list-style-type: disc">Driving the car:<p>To drive the car around, we apply torque to the front wheel while applying some counter-torque to the car itself:
<a id="id284" class="indexterm"/>
</p><div><pre class="programlisting">wheel2-&gt;body-&gt;ApplyTorque(-20.0f);
taxi-&gt;body-&gt;ApplyTorque(5.0f);
</pre></div><p>The counter-torque acts in the same way that a spoiler does to keep the car balanced.
</p></li><li class="listitem" style="list-style-type: disc">Creating the curved road:<p>The road in this recipe is a good example of a curved surface in Box2D. We created this using many small <strong>edge</strong> fixtures to construct a hi-poly curve.
<a id="id285" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">The camera:<p>In this recipe, we finally put <code class="literal">gameNode</code> to use. By repositioning this node, we effectively reposition the camera separately from the <strong>HUD</strong>:
<a id="id286" class="indexterm"/>
</p><div><pre class="programlisting">gameNode.position = ccp(-taxi.sprite.position.x + 240, -taxi.sprite.position.y + 160);
</pre></div><p>We'll discuss camera usage in depth in another recipe.
<a id="id287" class="indexterm"/>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>There's More...</h2></div></div></div><p>The vehicle in this example is far from perfect. Try using<strong> revolute joints</strong> to extend the wheels out from under the car and to add some shock absorption.<a id="id288" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">b2_maxPolygonVertices:</code><a id="id289" class="indexterm"/><p>Because our car has more than eight vertices, we must override the b2_maxPolygonVertices definition. This is located in the file b2Settings.h. The new definition looks like this:
</p><div><pre class="programlisting">#define b2_maxPolygonVertices 16
</pre></div></li><li class="listitem" style="list-style-type: disc">This allows us to define polygons with up to 16 vertices.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec12"/>Character movement</h1></div></div></div><p>Moving a character around a level can be trickier than you might expect. In this recipe, we will lay out the basics of 2D side scrolling character movement.<a id="id290" class="indexterm"/>
</p><div><img src="img/4002_04_12.jpg" alt="Character movement"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also note that some of the following code has been omitted for brevity.
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id291" class="indexterm"/>
</p><div><pre class="programlisting">@implementation SideScrollerRecipe
-(void) step:(ccTime)delta {
[super step:delta];
//Apply gunman running direction
if(dPad.direction == DPAD_LEFT || dPad.direction == DPAD_UP_LEFT || dPad.direction == DPAD_DOWN_LEFT){
gunmanDirection = DPAD_LEFT;
gunman.body-&gt;ApplyForce(b2Vec2(-35.0f,0), gunman.body-&gt;GetPosition());
((CCSprite*)[gunman.sprite getChildByTag:0]).flipX = YES;
}else if(dPad.direction == DPAD_RIGHT || dPad.direction == DPAD_UP_RIGHT || dPad.direction == DPAD_DOWN_RIGHT){
gunmanDirection = DPAD_RIGHT;
gunman.body-&gt;ApplyForce(b2Vec2(35.0f,0), gunman.body-&gt;GetPosition());
((CCSprite*)[gunman.sprite getChildByTag:0]).flipX = NO;
}
//Decrement jump counter
jumpCounter -= delta;
//Did the gunman just hit the ground?
if(!onGround){
if((gunman.body-&gt;GetLinearVelocity().y - lastYVelocity) &gt; 2 &amp;&amp; lastYVelocity &lt; -2){
gunman.body-&gt;SetLinearVelocity(b2Vec2(gunman.body-&gt;GetLinearVelocity().x,0));
onGround = YES;
}else if(gunman.body-&gt;GetLinearVelocity().y == 0 &amp;&amp; lastYVelocity == 0){
gunman.body-&gt;SetLinearVelocity(b2Vec2(gunman.body-&gt;GetLinearVelocity().x,0));
onGround = YES;
}
}
//Did he just fall off the ground without jumping?
if(onGround){
if(gunman.body-&gt;GetLinearVelocity().y &lt; -2.0f &amp;&amp; lastYVelocity &lt; -2.0f &amp;&amp; (gunman.body-&gt;GetLinearVelocity().y &lt; lastYVelocity)){
onGround = NO;
charactermoving}
}
//Store last velocity
lastYVelocity = gunman.body-&gt;GetLinearVelocity().y;
//Keep him upright on the ground
if(onGround){
gunman.body-&gt;SetTransform(gunman.body-&gt;GetPosition(),0);
}
//Animate gunman if his speed changed significantly
float speed = gunman.body-&gt;GetLinearVelocity().x;
if(speed &lt; 0){ speed *= -1; }
if(speed &gt; lastXSpeed*2){
[[gunman.sprite getChildByTag:0] stopAllActions];
[self animateGunman];
}
//Keep the gunman in the level
b2Vec2 gunmanPos = gunman.body-&gt;GetPosition();
if(gunmanPos.x &gt; 530/PTM_RATIO || gunmanPos.x &lt; (-50/PTM_RATIO) || gunmanPos.y &lt; -100/PTM_RATIO){
gunman.body-&gt;SetTransform(b2Vec2(2,10), gunman.body-&gt;GetAngle());
}
//Process input for the A button
for(id b in buttons){
GameButton *button = (GameButton*)b;
if(button.pressed &amp;&amp; [button.name isEqualToString:@"A"]){
[self processJump];
}else{
jumpCounter = -10.0f;
}
}
}
/* Initialize gunman */
-(void) initGunman {
gunman = [[GameMisc alloc] init];
/* CODE OMITTED */
gunman.body-&gt;SetLinearDamping(2.0f);
}
/* Process jump */
-(void) processJump {
if(onGround &amp;&amp; jumpCounter &lt; 0){
//Start a jump. Starting requires you to not be moving on the Y.
jumpCounter = 0.4f;
gunman.body-&gt;ApplyLinearImpulse(b2Vec2(0,20.0f), gunman.body-&gt;GetPosition());
onGround = NO;
}else if(jumpCounter &gt; 0){
//Continue a jump
gunman.body-&gt;ApplyForce(b2Vec2(0,65.0f), gunman.body-&gt;GetPosition());
}
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>How it works...</h2></div></div></div><p>In this recipe, we can make the 'gunman' run and jump around the level. The animation routine used here is based on the one used in a previous recipe.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Moving left and right:<a id="id293" class="indexterm"/><p>Using the directional pad, we can move the gunman to the left or right. This involves applying a force to the body on the X-axis:
</p><div><pre class="programlisting">gunman.body-&gt;ApplyForce(b2Vec2(35.0f,0), gunman.body-&gt;GetPosition());
</pre></div><p>The gunman's animation speed is then based on his X movement speed.
</p></li><li class="listitem" style="list-style-type: disc">Damping:<p>To slow the gunman down both in the air and on the ground, we set a <strong>linear damping</strong> value on the body:
<a id="id294" class="indexterm"/>
</p><div><pre class="programlisting">gunman.body-&gt;SetLinearDamping(2.0f);
</pre></div><p>This gradually decreases the gunman's speed in all directions. This has the dual effect of creating air resistance and also slowing him down when he's not actively running.
</p></li><li class="listitem" style="list-style-type: disc">Jumping:<p>To create a comfortable Mario-esque jump, we need to apply a handful of techniques and store a few variables. Jumping should only happen when the gunman is standing on an object. The user should be able to hold down the jump button for a higher jump, that is, until a certain point. To achieve all this we use the following variables:
<a id="id295" class="indexterm"/>
</p><div><pre class="programlisting">float lastYVelocity;
float jumpCounter;
bool onGround;
</pre></div><p>The variable <code class="literal">lastYVelocity</code> is used to determine whether or not the gunman recently hit the ground or if he just ran off the ground (as opposed to jumping off the ground). Subtle changes in Y velocity can tell us these things. The variable <code class="literal">jumpCounter</code> is used to limit jumping height. The counter is constantly being decremented. The time it resets to when you initially jump is the maximum amount of time the gunman is thrust upward. This time can be modified to allow certain actors to jump higher or lower. Jumping is first an initial impulse then a constant upward thrusting force. When the user lets go of the jump button, we reset <code class="literal">jumpCounter</code> and the gunman begins to fall.
<a id="id296" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec13"/>Simulating bullets</h1></div></div></div><p>Bullets and other fast moving objects are a fundamental part of many video games. In this recipe, we will see how to properly implement bullet physics.<a id="id297" class="indexterm"/>
<a id="id298" class="indexterm"/>
</p><div><img src="img/4002_04_13.jpg" alt="Simulating bullets"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also note that some of the following code has been omitted for brevity.<a id="id299" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id300" class="indexterm"/>
</p><div><pre class="programlisting">@implementation Ch4_Bullets
/* Fire the gun */
-(void) fireGun {
//Fire 10 bullets per second
if(fireCount &gt; 0){
return;
}
fireCount = 0.2f;
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
//Fire bullet in the correct direction
float gunAngle = -gunman.body-&gt;GetAngle() + PI/2;
if(gunmanDirection == DPAD_LEFT){ gunAngle += PI; }
CGPoint bulletVector = ccp( sin(gunAngle), cos(gunAngle) );
//Create bullet and shell casing
bulletssimulatingfor(int i=0; i&lt;2; i++){
//Create bullet or casing object
//NOTE: It might be more efficient to re-use a group of bullet objects instead of creating new bullets each time
GameMisc *bullet = [[GameMisc alloc] init];
bullet.gameArea = self;
bullet.typeTag = TYPE_OBJ_BULLET;
if(i == 1){
bullet.typeTag = TYPE_OBJ_SHELL;
}
bullet.life = 2.0f;
if(i == 1){
bullet.life = 5.0f;
}
//Calculate bullet/casing position as being slightly ahead of the gunman
CGPoint bulletPosition = ccp( gunman.sprite.position.x + bulletVector.x*10, gunman.sprite.position.y + bulletVector.y*10 );
if(i == 1){
bulletPosition = ccp( gunman.sprite.position.x, gunman.sprite.position.y );
}
//Create body using body definition
bullet.bodyDef-&gt;type = b2_dynamicBody;
if(i == 0){
bullet.bodyDef-&gt;bullet = YES;
}
bullet.bodyDef-&gt;position.Set(bulletPosition.x/PTM_RATIO, bulletPosition.y/PTM_RATIO);
bullet.body = world-&gt;CreateBody(bullet.bodyDef);
//Set the angle of the bullet/casing in the direction of the firing gun
bullet.body-&gt;SetTransform(bullet.body-&gt;GetPosition(), gunAngle);
CGPoint textureSize = ccp(17,17);
CGPoint shapeSize = ccp(2,2);
//Create the bullet sprite
bulletssimulatingbullet.sprite = [CCSprite spriteWithFile:@"bullet.png"];
bullet.sprite.position = ccp(bulletPosition.x,bulletPosition.y);
bullet.sprite.scaleX = shapeSize.x / textureSize.x * 2.25f;
bullet.sprite.scaleY = shapeSize.y / textureSize.y * 2.25f;
//If this is a shell casing make it a golden color
if(i == 1){ bullet.sprite.color = ccc3(255,200,0); }
//Add object
[gameNode addChild:bullet.sprite z:1];
//Set bullet shape
bullet.polygonShape = new b2PolygonShape();
bullet.polygonShape-&gt;SetAsBox(shapeSize.x/PTM_RATIO/2, shapeSize.y/PTM_RATIO);
bullet.fixtureDef-&gt;shape = bullet.polygonShape;
//Create fixture and configure collision
bullet.fixtureDef-&gt;density = 20.0f;
bullet.fixtureDef-&gt;friction = 1.0f;
bullet.fixtureDef-&gt;restitution = 0.0f;
if(i == 0){
bullet.fixtureDef-&gt;filter.categoryBits = CB_BULLET;
bullet.fixtureDef-&gt;filter.maskBits = CB_OTHER;
}else{
bullet.fixtureDef-&gt;filter.categoryBits = CB_SHELL;
bullet.fixtureDef-&gt;filter.maskBits = CB_OTHER | CB_SHELL;
}
bullet.body-&gt;CreateFixture(bullet.fixtureDef);
//Add this bullet to our container
[bullets addObject:bullet];
//If this is a bullet, fire it. If its a shell, eject it.
if(i == 0){
//Fire the bullet by applying an impulse
bullet.body-&gt;ApplyLinearImpulse(b2Vec2(bulletVector.x*50, bulletVector.y*50), bullet.body-&gt;GetPosition());
}else{
//Eject the shell
float radians = vectorToRadians(bulletVector);
radians += 1.85f * PI;
CGPoint shellVector = radiansToVector(radians);
if(shellVector.x &gt; 0){ shellVector.y *= -1; }
bullet.body-&gt;ApplyLinearImpulse(b2Vec2(shellVector.x, shellVector.y), bullet.body-&gt;GetPosition());
}
}
}
-(void) handleCollisionWithMisc:(GameMisc*)a withMisc:(GameMisc*)b {
//If a bullet touches something we set life to 0 and process the impact on that object
if(a.typeTag == TYPE_OBJ_BULLET &amp;&amp; b.typeTag == TYPE_OBJ_BOX &amp;&amp; a.life &gt; 0){
a.life = 0;
[self bulletImpactAt:a.sprite.position onObject:b];
[message setString:@"Bullet hit"];
}else if(b.typeTag == TYPE_OBJ_BULLET &amp;&amp; a.typeTag == TYPE_OBJ_BOX &amp;&amp; b.life &gt; 0){
b.life = 0;
[self bulletImpactAt:b.sprite.position onObject:a];
[message setString:@"Bullet hit"];
}
//Reset our message
[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:5.0f],
[CCCallFunc actionWithTarget:self selector:@selector(resetMessage)], nil]];
}
/* Process the bullet impact */
-(void) bulletImpactAt:(CGPoint)p onObject:(GameMisc*)obj {
//Here we use some trigonometry to determine exactly where the bullet impacted on the box.
float dist = distanceBetweenPoints(p, obj.sprite.position); //Hypotenuse
float xDist = obj.sprite.position.x - p.x; //Opposite side
float yDist = obj.sprite.position.y - p.y; //Adjacent side
bulletssimulatingfloat xAngle = asin(xDist/dist);
float yAngle = acos(yDist/dist);
float objSize = [obj.sprite contentSize].width/2 * obj.sprite.scale;
float newXDist = xDist - sin(xAngle) * objSize;
float newYDist = yDist - cos(yAngle) * objSize;
p = ccp( p.x + newXDist, p.y + newYDist );
//Animate bullet impact
float delay = 0.035f;
float duration = 8 * delay;
GameMisc *blastmark = [[GameMisc alloc] init];
blastmark.sprite = [CCSprite spriteWithSpriteFrameName:@"blastmark_0000.png"];
blastmark.life = duration;
blastmark.sprite.position = p;
blastmark.sprite.scale = 0.2f;
blastmark.sprite.opacity = 100;
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
CCAnimation *animation = [[CCAnimation alloc] initWithName:@"blastmark" delay:delay];
for(int i=0; i&lt;8; i+=1){
[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@"blastmark_000%i.png",i]]];
}
[blastmark.sprite stopAllActions];
[blastmark.sprite runAction:
[CCSpawn actions:
[CCFadeOut actionWithDuration:duration],
[CCAnimate actionWithAnimation:animation],
nil
]
];
[gameNode addChild:blastmark.sprite z:5];
[explosions addObject:blastmark];
//Decrement the box life
obj.life -= 1.0f;
}
@end
<a id="id304" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>How it works...</h2></div></div></div><p>Pressing the<strong> B</strong> button animates a muzzle flash, fires a bullet object, and ejects a used bullet casing. The muzzle flash is merely an animation but the bullets and bullet casings are physical objects.
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting the bullet flag:<a id="id305" class="indexterm"/><p>In the recipe, we set the bullet body's flag to identify it as a fast moving projectile:
</p><div><pre class="programlisting">bullet.bodyDef-&gt;bullet = YES;
</pre></div><p>Setting this flag allows the bullet to properly collide with other dynamic bodies. When two dynamic bodies collide, Box2D only performs collision detection for each discrete physics step. This means that during each cycle all dynamic physical bodies have discrete positions. Because of this, when a body moves fast enough, there is a chance that it could move through a body that it is supposed to collide with. Specifying this fast moving body as a bullet allows Box2D to perform continuous collision detection to allow this object to collide with other dynamic objects at any speed.
</p></li><li class="listitem" style="list-style-type: disc">Animating a bullet impact:<a id="id306" class="indexterm"/><p>In our example, we used some trigonometry to determine where the bullet landed on the periphery of the 2D box object. For more complex shapes, you can retrieve the contact normals from the Box2D solver. This will help identify exactly where two bodies have collided. For more information about <strong>contact normals</strong>, please consult the Box2D documentation.
<a id="id307" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec14"/>Simulating and rendering a rope</h1></div></div></div><p>A recent addition to the Box2D library is the<code class="literal"> b2RopeJoint.</code> In this recipe, we will see how to implement this physically and visually.<a id="id308" class="indexterm"/>
</p><div><img src="img/4002_04_14.jpg" alt="Simulating and rendering a rope"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also note that some of the following code has been omitted for brevity.<a id="id309" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">#import "VRope.h"
@implementation Ch4_Rope
-(CCLayer*) runRecipe {
[super runRecipe];
[message setString:@"Press B to fire a rope."];
//Initialization
onRope = NO;
ropeUseTimer = 0;
//Move gunman to left
gunman.body-&gt;SetTransform(b2Vec2(2,10), gunman.body-&gt;GetAngle());
//Create buttons
[self createButtonWithPosition:ccp(340,75) withUpFrame:@"b_button_up.png" withDownFrame:@"b_button_down.png" withName:@"B"];
[self createButtonWithPosition:ccp(420,75) withUpFrame:@"a_button_up.png" withDownFrame:@"a_button_down.png" withName:@"A"];
//Create ground
/* CODE OMITTED */
//Add invisible rope anchor
[self addRopeAnchor];
ropesimulatingreturn self;
}
-(void) step:(ccTime)delta {
[super step:delta];
//Process button input
for(id b in buttons){
GameButton *button = (GameButton*)b;
if(button.pressed &amp;&amp; [button.name isEqualToString:@"B"]){
if(!onRope){
[self useRope];
}else{
[self releaseRope];
}
}
if(button.pressed &amp;&amp; [button.name isEqualToString:@"A"]){
if(onRope){
[self releaseRope];
}else{
[self processJump];
}
}else if(!button.pressed &amp;&amp; [button.name isEqualToString:@"A"]){
jumpCounter = -10.0f;
}
}
//Update all ropes
for(id v in vRopes){
VRope *rope = (VRope*)v;
[rope update:delta];
[rope updateSprites];
}
//Decrement our use timer
ropesimulatingropeUseTimer -= delta;
}
-(void) addRopeAnchor {
//Add rope anchor body
b2BodyDef anchorBodyDef;
anchorBodyDef.position.Set(240/PTM_RATIO,350/PTM_RATIO); //center body on screen
anchorBody = world-&gt;CreateBody(&amp;anchorBodyDef);
//Add rope spritesheet to layer
ropeSpriteSheet = [CCSpriteBatchNode batchNodeWithFile:@"rope.png" ];
[self addChild:ropeSpriteSheet];
//Init array that will hold references to all our ropes
vRopes = [[[NSMutableArray alloc] init] autorelease];
}
-(void) useRope {
if(ropeUseTimer &gt; 0){
return;
}else{
ropeUseTimer = 0.2f;
}
//The rope joint goes from the anchor to the gunman
b2RopeJointDef jd;
jd.bodyA = anchorBody;
jd.bodyB = gunman.body;
jd.localAnchorA = b2Vec2(0,0);
jd.localAnchorB = b2Vec2(0,0);
jd.maxLength= (gunman.body-&gt;GetPosition() - anchorBody-&gt;GetPosition()).Length();
ropesimulating//Create VRope with two b2bodies and pointer to spritesheet
VRope *newRope = [[VRope alloc] init:anchorBody body2:gunman.body spriteSheet:ropeSpriteSheet];
//Create joint
newRope.joint = world-&gt;CreateJoint(&amp;jd);
[vRopes addObject:newRope];
//Keep track of 'onRope' state
onRope = !onRope;
}
-(void) releaseRope {
if(ropeUseTimer &gt; 0){
return;
}else{
ropeUseTimer = 0.2f;
}
//Jump off the rope
[self processJump];
//Destroy the rope
for(id v in vRopes){
VRope *rope = (VRope*)v;
world-&gt;DestroyJoint(rope.joint);
[rope removeSprites];
[rope release];
}
[vRopes removeAllObjects];
//Keep track of 'onRope' state
onRope = !onRope;
}
@end
<a id="id313" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>How it works...</h2></div></div></div><p>Pressing<strong> B</strong> fires a rope into the level directly above the gap in the middle. This allows the gunman to swing across the gap.
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using a rope joint:<a id="id314" class="indexterm"/><p>The rope joint is initialized in a way similar to that of other joints. It connects two bodies at two specific local points:
</p><div><pre class="programlisting">b2RopeJointDef jd;
jd.bodyA = anchorBody;
jd.bodyB = gunman.body;
jd.localAnchorA = b2Vec2(0,0);
jd.localAnchorB = b2Vec2(0,0);
</pre></div><p>We then set the maximum rope length and create the joint:
</p><div><pre class="programlisting">jd.maxLength= (gunman.body-&gt;GetPosition() - anchorBody-&gt;GetPosition()).Length();
newRope.joint = world-&gt;CreateJoint(&amp;jd);
</pre></div><p>This allows the user to swing on a circular arc around the anchor point.
</p></li><li class="listitem" style="list-style-type: disc">Using<code class="literal"> VRope:</code><p>The <code class="literal">VRope</code> class allows us to visualize the rope. An instance of <code class="literal">VRope</code> stores the two connected bodies and the connecting joint to then create a realistic depiction of a rope in each frame:
<a id="id315" class="indexterm"/>
</p><div><pre class="programlisting">//Update all ropes
for(id v in vRopes){
VRope *rope = (VRope*)v;
[rope update:delta];
[rope updateSprites];
}
</pre></div><p>From the original Pitfall arcade game to the newer Worms games, ropes have been used in games for years. They connect the player to the world in a way that is more dynamic than just running and jumping around.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec15"/>Creating a top-down isometric game engine</h1></div></div></div><p>By making some modifications to Box2D we can turn a 2D world into a 2.5D world. We will see this 2.5D<strong> sandbox</strong> in action in this recipe.<a id="id316" class="indexterm"/>
</p><div><img src="img/4002_04_15.jpg" alt="Creating a top-down isometric game engine"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection02</em> for full working code of this recipe. Also note that a large amount of code from this recipe has been omitted for brevity.
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id317" class="indexterm"/>
</p><div><pre class="programlisting">@interface GameIsoObject : GameObject {
@public
float yModifier; //This is typically half the height of the object. It allows us to change the sprite y.
float actualImageSize; //This is the actual size of the image (48x48, 96x96, etc)
float inGameSize; //This is how large the object in the game is.
float zModifier; //Changes the depth testing for this object.
CCSprite *spriteShadow;
Vector3D *bounceCoefficient; //x, y, z, lower is bouncier for Z
Vector3D *rollCoefficient;
}
@end
/* IsometricContactListener.h */
class isometricContactListener : public b2ContactListener
{
public:
void BeginContact(b2Contact* contact);
void EndContact(b2Contact* contact);
void PreSolve(b2Contact* contact, const b2Manifold* oldManifold);
};
top-down isometric game enginecreatingvoid isometricContactListener::BeginContact(b2Contact* contact)
{
b2Body *bodyA = contact-&gt;GetFixtureA()-&gt;GetBody();
b2Body *bodyB = contact-&gt;GetFixtureB()-&gt;GetBody();
if(bodyA and bodyB){
float lowerZSize;
if(bodyA-&gt;GetZPosition() &lt; bodyB-&gt;GetZPosition()){ lowerZSize = bodyA-&gt;GetZSize(); }
else{ lowerZSize = bodyB-&gt;GetZSize(); }
//Check for Z Miss and disable collision if neccessary
if( absoluteValue(bodyA-&gt;GetZPosition() - bodyB-&gt;GetZPosition()) &gt; lowerZSize ) { //If distance is greater than the height of the bottom one
contact-&gt;SetEnabled(false);
if(bodyA-&gt;GetHandleZMiss() || bodyB-&gt;GetHandleZMiss()){
GameObject *gameObjectA = (GameObject*)bodyA-&gt;GetUserData();
GameObject *gameObjectB = (GameObject*)bodyB-&gt;GetUserData();
[gameObjectA-&gt;gameArea handleZMissWithObjA:gameObjectA withObjB:gameObjectB];
bodyA-&gt;SetHandleZMiss(false);
bodyB-&gt;SetHandleZMiss(false);
}
//If no Z Miss handle collision
}else {
GameObject *gameObjectA = (GameObject*)bodyA-&gt;GetUserData();
GameObject *gameObjectB = (GameObject*)bodyB-&gt;GetUserData();
[gameObjectA-&gt;gameArea handleCollisionWithObjA:gameObjectA withObjB:gameObjectB];
top-down isometric game enginecreating}
}
}
/* END IsometricContactListener.h */
@implementation Ch4_TopDownIsometric
-(CCLayer*) runRecipe {
[super runRecipe];
//Iso debug drawing
m_debugDraw = new IsoGLESDebugDraw( PTM_RATIO, PERSPECTIVE_RATIO, gameAreaSize );
world-&gt;SetDebugDraw(m_debugDraw);
//Special isometric gravity, contact filter and contact listener
world-&gt;SetGravity(b2Vec2(0,0));
world-&gt;SetContactListener(new isometricContactListener);
return self;
}
/* We override all physical calculations here */
-(void) step: (ccTime) delta {
//Update Physics
int32 velocityIterations = 8;
int32 positionIterations = 3;
world-&gt;Step(delta, velocityIterations, positionIterations);
float deltaMod = delta/0.01666666667f;
for (b2Body* b = world-&gt;GetBodyList(); b; b = b-&gt;GetNext()) {
//Z Miss handling allows us to know when an object passes over or under another object
b-&gt;SetHandleZMiss(YES);
if (b-&gt;GetUserData() != NULL) {
//Synchronize the sprites position and rotation with the corresponding body
top-down isometric game enginecreatingGameIsoObject *gameObject = (GameIsoObject*)b-&gt;GetUserData();
if(gameObject.sprite) {
if(gameObject.bodyDef-&gt;type == b2_dynamicBody){
//Process Z velocity and position
gameObject.body-&gt;SetZVelocity( gameObject.body-&gt;GetZVelocity() - GRAVITY*deltaMod );
gameObject.body-&gt;SetZPosition( gameObject.body-&gt;GetZPosition() + gameObject.body-&gt;GetZVelocity()*deltaMod );
//Process object bouncing and rolling
if(gameObject.body-&gt;GetZPosition() &lt; (-0.01f)){
gameObject.body-&gt;SetZPosition(0.01f);
gameObject.body-&gt;SetZVelocity( gameObject.body-&gt;GetZVelocity() * -1 );
b2Vec2 worldVector = gameObject.body-&gt;GetLinearVelocityFromLocalPoint(b2Vec2(0,0));
if(absoluteValue(gameObject.body-&gt;GetZVelocity()) &gt; 1.0f){
[self handleCollisionWithGroundWithObj:gameObject];
gameObject.body-&gt;ApplyLinearImpulse( b2Vec2( gameObject.bounceCoefficient.x*worldVector.x*-1, gameObject.bounceCoefficient.y*worldVector.y*-1 ), gameObject.body-&gt;GetPosition() );
gameObject.body-&gt;SetZVelocity( gameObject.body-&gt;GetZVelocity() * (1-gameObject.bounceCoefficient.z) );
}else{
gameObject.body-&gt;ApplyLinearImpulse( b2Vec2( gameObject.rollCoefficient.x*worldVector.x*-1, gameObject.rollCoefficient.y*worldVector.y*-1 ), gameObject.body-&gt;GetPosition() );
gameObject.body-&gt;SetZVelocity( gameObject.body-&gt;GetZVelocity() * (1-gameObject.rollCoefficient.z) );
}
}
//Change sprite positions based on body positions
gameObject.sprite.position = CGPointMake( convertPositionX(gameAreaSize, b-&gt;GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b-&gt;GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO) + gameObject.yModifier + gameObject.body-&gt;GetZPosition() * zHeightModifier * PERSPECTIVE_RATIO);
gameObject.spriteShadow.position = CGPointMake( convertPositionX(gameAreaSize, b-&gt;GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b-&gt;GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO));
//Modify sprite scale based on Z (height)
[gameObject.sprite setScale:( gameObject.body-&gt;GetZPosition()*scaleHeightMultiplier + gameObject-&gt;inGameSize/gameObject-&gt;actualImageSize )];
gameObject.spriteShadow.scale = gameObject.body-&gt;GetZPosition()/100;
if(gameObject.spriteShadow.scale &gt; 1){ gameObject.spriteShadow.scale = 1; }
//Sprite depth testing based on Y (depth)
[self setZOrderByBodyPosition:gameObject];
}else if(gameObject.bodyDef-&gt;type == b2_staticBody){
//Static bodies are only positioned and depth tested
gameObject.sprite.position = CGPointMake( convertPositionX(gameAreaSize, b-&gt;GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b-&gt;GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO) + gameObject.yModifier + gameObject.body-&gt;GetZPosition() * zHeightModifier * PERSPECTIVE_RATIO);
[self setZOrderByBodyPosition:gameObject];
gameObject.spriteShadow.position = CGPointMake( convertPositionX(gameAreaSize, b-&gt;GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b-&gt;GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO));
}
}
}
}
//Process body creation/destruction
[self destroyBodies];
[self createBodies];
[self runQueuedActions];
//Follow gunman with camera
gameNode.position = ccp((-gunman.spriteShadow.position.x)*cameraZoom + 240, (-gunman.spriteShadow.position.y)*cameraZoom + 160);
}
top-down isometric game enginecreating/* Fire a bouncy ball */
-(void) fireBall {
if(fireCount &lt; 0){
GameIsoObject *ball = [self addBallAtPoint:ccp(gunman.body-&gt;GetPosition().x*PTM_RATIO + lastPressedVector.x*20.0f, gunman.body-&gt;GetPosition().y*PTM_RATIO*PERSPECTIVE_RATIO + lastPressedVector.y*20.0f)];
ball.body-&gt;ApplyLinearImpulse(b2Vec2(lastPressedVector.x*1.75f, lastPressedVector.y*1.75f), ball.body-&gt;GetPosition());
ball.body-&gt;SetZVelocity( gunman.body-&gt;GetZVelocity()*5.0f + 10.0f );
ball.body-&gt;SetZPosition( gunman.body-&gt;GetZPosition() + 40.0f);
fireCount = 10;
}else{
fireCount--;
}
}
/* Process a jump */
-(void) processJump {
//You can only jump if you are standing or running. You also need to be on the ground.
if(gunman.body-&gt;GetZPosition() &gt; 1.0f){
return;
}
//Make him jump
[[gunman.sprite getChildByTag:0] stopAllActions];
gunman.body-&gt;SetZVelocity(7.5f);
}
/* Convert a body position to a world position */
-(CGPoint) getWorldPosition:(GameIsoObject*)g {
return CGPointMake(g.body-&gt;GetPosition().x * PTM_RATIO, g.body-&gt;GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO);
}
/* A camera bound limiting routine */
- (bool) checkCameraBoundsWithFailPosition:(CGPoint*)failPosition {
CGSize screenSize = [CCDirector sharedDirector].winSize;
bool passed = true;
top-down isometric game enginecreatingfloat fsx = (gameAreaSize.x/2)*cameraZoom;
float fsy = (gameAreaSize.y/2)*cameraZoom;
float ssx = screenSize.width;
float ssy = screenSize.height;
if( [gameNode position].y &lt; -(fsy - ssy) ) {
(*failPosition).y = -(fsy - ssy);
passed = false;
}else if( [gameNode position].y &gt; fsy) {
(*failPosition).y = fsy;
passed = false;
}else{ //Passed
(*failPosition).y = [gameNode position].y;
}
if( [gameNode position].x &lt; -(fsx - ssx) ) {
(*failPosition).x = -(fsx - ssx);
passed = false;
}else if( [gameNode position].x &gt; fsx) {
(*failPosition).x = fsx;
passed = false;
}else { //Passed
(*failPosition).x = [gameNode position].x;
}
return passed;
}
/* Depth testing */
-(void) setZOrderByBodyPosition:(GameIsoObject*)g {
float fixedPositionY = gameAreaSize.y - (g.body-&gt;GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO) + g.zModifier;
[g.sprite.parent reorderChild:g.sprite z:fixedPositionY];
}
/* Add a tree object */
-(void) addTreeAtPoint:(CGPoint)treePosition {
GameIsoObject *tree = [[GameIsoObject alloc] init];
/* CODE OMITTED */
}
/* Add a ball with a random size at a position */
-(GameIsoObject*) addBallAtPoint:(CGPoint)ballPosition {
GameIsoObject *ball = [[GameIsoObject alloc] init];
//Bounce and roll coefficients determine how high the ball boucnes and how fast the ball rolls
ball.bounceCoefficient = [Vector3D x:0.05f y:0.05f z:0.1f*scaleMod];
top-down isometric game enginecreatingball.rollCoefficient = [Vector3D x:0.0005f y:0.0005f z:0.5f];
/* CODE OMITTED */
return ball;
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>How it works...</h2></div></div></div><p>In this recipe, we control the gunman as he runs around in a pseudo-3D world. Pressing<strong> B</strong> makes him fire colorful bouncing balls into the air. Pressing<strong> A</strong> makes him jump. Much like in a previous recipe, the user can pinch to zoom in or out.<a id="id324" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Box2D modifications:<a id="id325" class="indexterm"/><p>To create a somewhat realistic 3D effect, we need to store some more data inside the <code class="literal">b2Body</code> class. By searching for the string "Isometric Additions" in the RecipeCollection02 project, you will find four sets of additions to the <code class="literal">b2Body</code> class. These changes add the following variables:
<a id="id326" class="indexterm"/>
</p><div><pre class="programlisting">float32 m_zPosition;
float32 m_zSize;
float32 m_zVelocity;
bool m_handleZMiss;
</pre></div><p>The position, size, and velocity variables allow us to perform some basic physical calculations on the Z plane. The <code class="literal">m_handleZMiss</code> variable tells us whether or not to send a message to a callback method when an object passes over or under another object on the Z plane.
<a id="id327" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">The<code class="literal"> GameIsoObject</code> class:<a id="id328" class="indexterm"/><p>This new class adds some new variables that we can use in our engine. Particularly, <code class="literal">yModifier</code> and <code class="literal">zModifier</code> are simple values to help with sprite positioning and depth testing, respectively. The variables <code class="literal">actualImageSize </code>and <code class="literal">inGameSize</code> help to determine baseline image scaling.
</p></li><li class="listitem" style="list-style-type: disc">The<code class="literal"> isometricContactListener</code> class:<a id="id329" class="indexterm"/><p>Here, we use our contact listener to check collision in the third or 'Z' dimension. If two collide on the X and Y but miss on the Z, then we disable physical collision response:
</p><div><pre class="programlisting">contact-&gt;SetEnabled(false);
</pre></div><p>We also call the following function on the corresponding gameArea instance:
</p><div><pre class="programlisting">-(void) handleZMissWithObjA:(GameObject*)objA withObjB:(GameObject*)objB;
</pre></div><p>This is useful, for instance, when you want to determine if someone jumped over a fence or if a ball went over a wall in a sports video game.
</p></li><li class="listitem" style="list-style-type: disc">Physics on the Z plane:<p>This recipe overrides the normal <code class="literal">step</code> routine for its own custom routine. Here, we handle Z physics. This involves assuming an arbitrary, static ground at Z=0. Bodies are subjected to a <code class="literal">GRAVITY</code> constant that decreases Z velocity relative to the amount of time passing with each step. This ensures that physics on the Z-axis stays in sync with Box2D physics.
<a id="id330" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Bouncing and rolling:<p>Each <code class="literal">GameIsoObject</code> has a <code class="literal">bounceCoefficient</code> and a <code class="literal">rollCoefficient</code>. These <code class="literal">Vector3D</code> instances determine the restitution and friction of bodies on all three planes:
<a id="id331" class="indexterm"/>
</p><div><pre class="programlisting">ball.bounceCoefficient = [Vector3D x:0.05f y:0.05f z:0.1f*scaleMod];
ball.rollCoefficient = [Vector3D x:0.0005f y:0.0005f z:0.5f];
</pre></div><p>This, combined with Box2D damping, restitution, and friction variables allows for a lot of customization.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">PERSPECTIVE_RATIO</code> and depth testing:<a id="id332" class="indexterm"/><p>This isometric setup assumes a perspective ratio of <code class="literal">0.5f</code>. This means that, for every <code class="literal">1.0f</code> of distance on the Y we only see 0.5f of distance on the screen. In simpler terms, you could consider this the equivalent of having the camera looking down at the ground at a 45-degree angle. This acts as a mathematical reference for our forced perspective. So, when converting from the physical to the visual (or vice versa) we use <code class="literal">PTM_RATIO</code> on the X and Y axes and <code class="literal">PERSPECTIVE_RATIO</code> on only the Y-axis. In our step routine, we also apply depth testing. For this, we simply use Y body positions to determine object depth. All sprites are continually reordered.
<a id="id333" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Shadows and image scaling on the Z-axis:<p>To further sell the visual trick of isometric perspective, we add shadow under every object using the spriteShadow variable. This shadow stays at height Z=0 at all times. We have it increase in size when an object goes further up into the air. Also, objects at higher altitudes are scaled up slightly. This is why we need a baseline scale for our GameIsoObject sprites. When these two effects are combined, they give a stronger impression of 3D space. Also, as you can see with trees and walls, shadows can be finely drawn (trees) or procedurally generated (walls).
<a id="id334" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Camera limiting and zooming:<p>In the following method, we limit camera movement past the edges of the <code class="literal">gameArea</code>:
<a id="id335" class="indexterm"/>
</p><div><pre class="programlisting">- (bool) checkCameraBoundsWithFailPosition:(CGPoint*)failPosition;
</pre></div><p>This method is then combined with pinch zooming to allow the user to zoom in and out to further survey the gameplay area. If you are planning to make use of this in-game zoom feature I highly recommend using mipmapping to smooth out shrunken textures.
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>There's More...</h2></div></div></div><p>The physics simulation on the Z plane previously provided is very simple. For example, this example does not allow for variable height terrain or proper physical collision response on the Z-axis. Unfortunately, a more complex simulation would be outside the scope of this book.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Side-scrolling with depth:<p>This technique can be easily modified to create a side-scrolling isometric scene as opposed to a top-down isometric scene. Examples of this include Streets of Rage and NBA Jam for the Sega Genesis console. The gameplay angle would be foreshortened to <code class="literal">0.25f</code> or lower. Also, the custom-made Z-axis should represent depth as opposed to height since most physical interactions occur on the width
<a id="id336" class="indexterm"/>
</p></li></ul></div></div></div></body></html>