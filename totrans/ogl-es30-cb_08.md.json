["```java\n    ifndef USE_FREETYPE\n    USE_FREETYPE := 2.4.2\n    endif\n    ifeq ($(USE_FREETYPE),2.4.2)\n\n    LOCAL_PATH:= $(call my-dir)\n    include $(CLEAR_VARS)\n\n    LOCAL_SRC_FILES:= \\\n    src/base/ftbbox.c src/base/ftbitmap.c \\\n    src/base/ftfstype.c src/base/ftglyph.c \\\n    src/base/ftlcdfil.c src/base/ftstroke.c\\\n    src/base/fttype1.c src/base/ftxf86.c \\\n    src/base/ftbase.c src/base/ftsystem.c \\\n    src/base/ftinit.c src/base/ftgasp.c \\\n    src/raster/raster.c src/sfnt/sfnt.c \\\n    src/smooth/smooth.c src/autofit/autofit.c \\ src/truetype/truetype.c src/cff/cff.c \\ src/psnames/psnames.c src/pshinter/pshinter.c\n\n    LOCAL_C_INCLUDES += $(LOCAL_PATH)/builds $(LOCAL_PATH)/include\n\n    LOCAL_CFLAGS+=-W –Wall -fPIC –DPIC -O2\n    LOCAL_CFLAGS+=\"-DDARWIN_NO_CARBON\" \"-DFT2_BUILD_LIBRARY\"\n\n    LOCAL_MODULE:= libGLPift2\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```java\n    FONT_PATH= $(FRAMEWORK_DIR)/Font\n    $(MY_CUR_LOCAL_PATH)/../../../../GLPIFramework/Font/FreeType/Android.mk\n    LOCAL_C_INCLUDES += $(FONT_PATH)/FreeType/include\n    LOCAL_SRC_FILES += $(SCENE_DIR)/FontGenerator.cpp \\\n                       $(SCENE_DIR)/Font.cpp \\\n                       $(SCENE_DIR)/FontSample.cpp \\\n                       $(SCENE_DIR)/SimpleTexture.cpp\n    LOCAL_SHARED_LIBRARIES += GLPift2\n    ```", "```java\n    public class GLESNativeLib {\n    static {\n    System.loadLibrary(\"GLPift2\");\n       . . . . . . Other code\n    }\n    ```", "```java\n    ../../../../GLPIFramework/Font/FreeType/Include\n    ```", "```java\n    FT2_BUILD_LIBRARY=1 DARWIN_NO_CARBON\n    ```", "```java\n    struct Glyph {\n    FT_Glyph_Metrics metric; // Glyph metric\n       float advanceHorizontal; // Horizontal advance\n       float advanceVertical;   // Horizontal advance\n       float texCoordX, texCoordY; // Atlas Texture Coords\n       float atlasX, atlasY;    // Position in texture Altas\n    };\n\n    class FontGenerator {\n      public:\n       FontGenerator ();     // Constructor\n       ~FontGenerator ();    // Destructor\n       bool errorState ();     // Error check flag\n       bool loadFont(const char* filename, int resolution);\n\n       GLuint         atlasTex;     // Texture atlas handle  \n       std::map<unsigned long, Glyph>  glyphs; // Glyph map\n       float          texDimension;\n       float          squareSize;   // Glyph square size\n       LanguageType   languageType; // Current language\n       FT_Face        fontFace;     // typeface information\n\n    private:\n       bool readFont (const FT_Face& fontFace,\n       int resolution, int glyphMargin);\n\n       bool getCorrectResolution(const FT_Face& fontFace,\n       int resolution, int& newResolution, int& newMargin);\n\n       void generateTexFromGlyph (FT_GlyphSlot glyph, GLubyte*\n       texture, int atlasX, int atlasY, int texSize,\n       int resolution, int marginSize, bool drawBorder);\n\n       void setPixel (GLubyte* texture, int offset,\n       int size, int x, int y, GLubyte val);\n\n       bool                errorStatus;\n       FT_Library          library;  // FreeType lib handle\n    };\n    ```", "```java\n    FontGenerator::FontGenerator () : errorStatus(false),\n     atlasTex(0), texDimension(0), squareSize(0)  {\n        if (FT_Init_FreeType(&library)){\n     errorStatus = true;return;\n     }\n    }\n    ```", "```java\n    bool FontGenerator::loadFont(char* file,int resolution){\n        // Generate the face object, return on error\n        if(FT_New_Face(library,filename,0 &fontFace))\n       { \n       return false;\n       }\n\n       // Check if current resolution is supported?\n       int calculatedResoution; int calculatedMargin;\n       if( getCorrectResolution(fontFace, resolution,\n       calculatedResoution, calculatedMargin)){\n       return readFont(fontFace, calculatedResoution,calculatedMargin);\n       }\n       return true;\n    }\n    ```", "```java\n       bool FontGenerator::getCorrectResolution(const FT_Face&\n       fontFace, int resolution, int&\n       newResolution, int& newGlyphMargin){\n\n       int glyphMargin = 0;\n       GLint MaxTextureSize;\n       glGetIntegerv(GL_MAX_TEXTURE_SIZE, &MaxTextureSize);\n\n       while(resolution>0){\n       glyphMargin = (int)ceil(resolution*0.1f);       \n      const long numGlyphs = fontFace->num_glyphs;    \n      const int squareSize = resolution + glyphMargin;\n\n      const int numGlyphsPerRow = (int)ceilf(sqrt((double)numGlyphs));\n      const int texSize         = (numGlyphsPerRow)*squareSize;\n      int realTexSize           = GLUtils::nextPowerOf2(texSize);\n\n      if(realTexSize<=MaxTextureSize )\n      {    break; }\n\n      resolution  = resolution - 5; // Decrease 5 units.\n      }\n\n      if(resolution > 0){\n      newResolution   = resolution;\n      newGlyphMargin  = glyphMargin;\n      return true;\n      }\n      else{\n      return false;\n      }\n    }\n    ```", "```java\n    bool FontGenerator::readFont (const FT_Face& fontFace,\n    int resolution, int glyphMargin) {\n      FT_Set_Pixel_Sizes(fontFace, resolution, resolution);\n      const int numGlyphs = fontFace->num_glyphs;\n      . . . .\n    }\n    ```", "```java\n      // Inside FontGenerator::readFont() function\n      squareSize = resolution + glyphMargin;\n\n      // Texture size for all glyphs in power of 2\n      const int numGlyphsPerRow = ceilf(sqrt(numGlyphs));     \n       const int texSize = numGlyphsPerRow*squareSize;\n       int realTexSize  = GLUtils::nextPowerOf2(texSize);\n\n       // Two channel texture (luminance and alpha)\n       GLubyte* textureData = NULL;\n       textureData = new GLubyte[realTexSize*realTexSize*2];\n\n       // if there exist an old atlas delete it. \n       if (atlasTex){ \n       glDeleteTextures(1,&atlasTex); \n       atlasTex=0; \n    }\n\n       glGenTextures(1, &atlasTex);\n       glBindTexture(GL_TEXTURE_2D, atlasTex);\n       glTexParameteri\n       (GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n       glTexParameteri\n       (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n       GLUtils::checkForOpenGLError(__FILE__, __LINE__);\n    ```", "```java\n       // Inside FontGenerator::readFont() function\n       int texAtlasX  = 0;      int texAtlasY  = 0;\n       FT_UInt gindex = 0;   FT_ULong charcode = 0;\n\n       for (FT_ULong charcode=FT_Get_First_Char(fontFace,\n       &gindex); gindex != 0;charcode=FT_Get_Next_Char\n       (fontFace, charcode, &gindex)) {\n\n       if(FT_Load_Glyph(fontFace,gindex,FT_LOAD_DEFAULT)){\n       LOGE(\"Error loading glyph with index %i and charcode %i. Skipping.\", gindex, charcode);\n       continue;\n       }\n       // Many lines skipped.\n       }\n    ```", "```java\n       // Inside FontGenerator::readFont() function\n       // This is part of the glyph loading loop.\n       FT_GlyphSlot glyph = fontFace->glyph;\n       FT_Render_Glyph(glyph, FT_RENDER_MODE_NORMAL);\n\n       // Calculate glyph information\n       Glyph glyphInfo;\n       glyphInfo.metric     = glyph->metrics;\n\n       // Get texture offset in the image\n       glyphInfo.atlasX=texAtlasX*squareSize/realTexSize;\n       glyphInfo.atlasY=texAtlasY*squareSize/realTexSize;\n\n       // Advance stored as fractional pixel format\n       // (=1/64 pixel), as per FreeType specs\n       glyphInfo.advanceHorizontal=glyph->advance.x/64.0f;\n       glyphInfo.advanceVertical=glyph->advance.y/64.0f;\n       glyphs[charcode] = glyphInfo;\n    ```", "```java\n       // Inside FontGenerator::readFont()\n    {    \n       . . . . .     \n       // Copy the bits to the texture atlas\n       generateTexFromGlyph(glyph, textureData, texAtlasX,\n       texAtlasY, realTexSize, resolution, glyphMargin, false);\n\n       texAtlasX++;\n       if (texAtlasX >= numGlyphsPerRow){\n       texAtlasX=0; \n       texAtlasY++; \n       }\n\n       // set texture atlas to OpenGL ES tex object\n       glTexImage2D (GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA,\n       realTexSize, realTexSize, 0, GL_LUMINANCE_ALPHA,\n       GL_UNSIGNED_BYTE, textureData);\n\n       // Delete local texture atlas \n       delete[] textureData; \n       GLUtils::checkForOpenGLError(__FILE__, __LINE__);\n       texDimension = (squareSize)/(float)realTexSize;\n       return true;\n    }\n    ```", "```java\n       void FontGenerator::generateTexFromGlyph (FT_GlyphSlot\n       glyph, GLubyte* texture, int atlasX, int atlasY, int\n       texSize,int resolution,int marginSize,bool drawBorder){\n\n       int squareSize = resolution + marginSize;\n       baseOffset=atlasX*squareSize+atlasY*squareSize*texSize;\n\n       if (drawBorder) {\n       for (int w=0; w<squareSize; w++)\n       { setPixel(texture,baseOffset,texSize, w, 0, 255); }\n\n       for (int h=1; h<squareSize; h++){\n       for (int w=0; w<squareSize; w++){\n       setPixel(texture,baseOffset,texSize,w,h,\n       (w==0||w==squareSize-1)?255:\n       (h==squareSize-1)?255:0);\n                                       }\n                                       }\n       }\n\n       const int gr = glyph->bitmap.rows;\n       const int gw = glyph->bitmap.width;\n       for (int h=0; h<gr; h++) {\n       for (int w=0; w<gw; w++) {\n       setPixel(texture, baseOffset+marginSize, texSize,\n       w, marginSize+h, glyph->bitmap.buffer[w+h*gw]);\n       }\n       }\n    }\n    ```", "```java\n       class Font : public Model, public FontGenerator {\n       public:\n       Font(const char* ttfFile, int Size, Renderer* parent,\n       LanguageType Language= English);\n       ~Font();\n       void Render();\n       void InitModel();\n       void printText (const char* str, GLfloat Red = 1.0f,\n       GLfloat Green = 1.0f, GLfloat Blue = 1.0f,\n       GLfloat Alpha = 1.0f);\n       private:\n       void drawGlyph (const Glyph& gi);\n       char MVP, TEX, FRAG_COLOR;\n    };\n    ```", "```java\n    #version 300 es\n    layout(location = 0) in vec3  VertexPosition;\n    layout(location = 1) in vec2  VertexTexCoord;\n    out vec2 TexCoord;\n    uniform mat4 ModelViewProjectMatrix;\n\n    void main( void ) {\n      TexCoord      = VertexTexCoord;\n      gl_Position   =ModelViewProjectMatrix  *\n                      vec4(VertexPosition,1.0);\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n\n    in vec2 TexCoord;\n    uniform sampler2D FontTexture;\n    uniform vec4 TextColor;\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        vec4 texcol = texture(FontTexture, TexCoord);\n        outColor    = vec4(vec3(TextColor.rgb), texcol.a);\n    }\n    ```", "```java\n    void Font::InitModel() {\n        . . . . . // Other code . . . .\n      program->VertexShader  = ShaderManager::ShaderInit\n                 (VERTEX_SHADER_PRG, GL_VERTEX_SHADER);\n      program->FragmentShader   = ShaderManager::ShaderInit\n                 (FRAGMENT_SHADER_PRG, GL_FRAGMENT_SHADER);\n      . . . . . // Other code . . . .\n\n      MVP = ProgramManagerObj->ProgramGetUniformLocation\n                 (program,\"ModelViewProjectMatrix\");\n      TEX = ProgramManagerObj->ProgramGetUniformLocation\n                 (program, (char*) \"Tex1\");\n      FRAG_COLOR = ProgramManagerObj->ProgramGetUniformLocation\n                 (program, (char*)\"TextColor\");\n    }\n    ```", "```java\n    void Font::drawGlyph(const Glyph& gi) {\n        glUseProgram(program->ProgramID);\n\n       // Using the glyph metrics to get the glyph info.\n        float xmargin = flot(gi.metric.width)/(2.0*64.0);\n       float ymargin =float(gi.metric.horiBearingY)/(2.0*64.0);\n\n        // Calculate texture coord for glyph rendering\n        float texCoords[8] = {\n            gi.atlasX, gi.atlasY,\n            gi.atlasX + texDimension, gi.atlasY,\n            gi.atlasX, gi.atlasY + texDimension,\n            gi.atlasX + texDimension, gi.atlasY + texDimension\n        };\n\n        // 1x1 glyph Quad.\n        float quad[12]   = {\n            {-0.5f, 0.5f,  0.0f},{ 0.5f, 0.5f,  0.0f},\n            {-0.5f, -0.5f, 0.0f},{0.5f, -0.5f, 0.0f }};\n\n       for (int i = 0; i<12;){\n           quad[i] *= squareSize/2.0;\n           quad[i+1] *= squareSize/2.0;\n           quad[i+2] *= 0.0;\n           i += 3;\n       }\n\n        // Initialize the texture with texture unit 0\n        glUniform1i(TEX, 0);\n        TransformObj->TransformPushMatrix();\n        TransformObj->TransformTranslate(-xmargin, ymargin,\n                                                   0.0f );\n        glUniformMatrix4fv(MVP, 1, GL_FALSE, (float*)\n        TransformObj->TransformGetModelViewProjectionMatrix());\n        TransformObj->TransformPopMatrix();\n\n        // Send the vertex and texture info to shader\n        glEnableVertexAttribArray(VERTEX_POSITION);\n        glEnableVertexAttribArray(TEX_COORD);\n        glVertexAttribPointer(VERTEX_POSITION, 3, GL_FLOAT,\n             GL_FALSE, 0, quad);\n        glVertexAttribPointer(TEX_COORD, 2, GL_FLOAT,\n             GL_FALSE, 0, texCoords);\n        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n    }\n    ```", "```java\n    void Font::printText(char* str, GLfloat Red,\n          GLfloat Green, GLfloat Blue, GLfloat Alpha) {\n         // Initialize OpenGL ES States\n         glDisable(GL_CULL_FACE);\n         glDisable(GL_DEPTH_TEST);\n         glEnable(GL_BLEND);\n         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n         // Use font program\n        glUseProgram(program->ProgramID);\n\n         // Activate Texture unit 0 and assign the altas\n         glActiveTexture (GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, atlasTex);\n\n        TransformObj->TransformPushMatrix();\n        GLfloat color[4] = {Red, Green, Blue, Alpha};\n        glUniform4fv(FRAG_COLOR, 1, color);\n\n        for (const char* c = str; *c != '\\0'; c++) {\n            const Glyph& gi = glyphs[((unsigned long) *c)];\n            TransformObj->TransformTranslate\n              (gi.advanceHorizontal/ 2.0, 0.0, 0.0);\n            drawGlyph(gi);\n        }\n        TransformObj->TransformPopMatrix();\n        return;\n    }\n    ```", "```java\n    void FontSample::Render(){\n        Font* English = dynamic_cast<Font*>\n                    (RendererHandler->getModel(FontEnglish));\n        static float angle = 0.0;\n        TransformObj->TransformPushMatrix();\n        TransformObj->TransformTranslate(-0.50, 0.0, 0.0);\n        TransformObj->TransformRotate(angle++, 1.0, 0.0, 0.0);\n        English->printText((char*)\"Hello World !!!\",1,1,0,1);\n        TransformObj->TransformPopMatrix();\n    }\n    ```", "```java\n    void Renderer::createModels(){\n        clearModels();\n        char fname[500]= {\"\"};\n      #ifdef __APPLE__\n        GLUtils::extractPath( getenv(\"FILESYSTEM\"), fname);\n      #else\n        strcpy( fname, \"/sdcard/GLPIFramework/Font/\");\n      #endif\n        addModel(new Font(strcat(fname,\"ACUTATR.TTF\"),\n           50, this, English) );\n        addModel( new FontSample(this) );\n    }\n    ```", "```java\nvoid Font::animateText(const char* str, GLfloat Red, GLfloat Green,\n  GLfloat Blue, GLfloat Alpha,float radius,float rotation){\n    // Same code as printText, reuse it\n    int num_segments = strlen(str); int index = 0;\n    float theta = 0;\n    for (const char* c = str; *c != '\\0'; c++) {\n        TransformObj->TransformPushMatrix();\n        TransformObj->TransformRotate(rot , 0.0, 1.0, 0.0);\n\n         // position of character on the locus\n        theta = 2.0f * PI_VAL * (index++)/num_segments;\n        TransformObj->TransformPushMatrix();\n        TransformObj->TransformTranslate\n             (radius*cosf(theta), 0.0, radius * sinf(theta));\n        const Glyph& gi = glyphs[((unsigned long) *c)];\n        TransformObj->TransformRotate(-rot , 0.0, 1.0, 0.0);\n\n       // Draw Glyph\n       drawGlyph(gi);\n        TransformObj->TransformPopMatrix();\n        TransformObj->TransformPopMatrix();\n    }\n    TransformObj->TransformPopMatrix();\n}\n```", "```java\n    LOCAL_SRC_FILES:= \\\n       src/hb-blob.cc src/hb-buffer-serialize.cc \\\n    src/hb-buffer.cc src/hb-common.cc \\\n    src/hb-fallback-shape.cc src/hb-font.cc \\\n       src/hb-ft.cc src/hb-ot-tag.cc src/hb-set.cc \\\n    src/hb-shape.cc src/hb-shape-plan.cc \\\n    src/hb-shaper.cc src/hb-tt-font.cc \\\n       src/hb-unicode.cc src/hb-warning.cc \\\n    src/hb-ot-layout.cc src/hb-ot-map.cc \\\n    src/hb-ot-shape.cc src/hb-ot-shape-complex-arabic.cc\\\n       src/hb-ot-shape-complex-default.cc \\\n       src/hb-ot-shape-complex-indic.cc \\\n       src/hb-ot-shape-complex-indic-table.cc \\\n       src/hb-ot-shape-complex-myanmar.cc \\\n       src/hb-ot-shape-complex-sea.cc \\\n       src/hb-ot-shape-complex-thai.cc \\\n       src/hb-ot-shape-normalize.cc \\\n       src/hb-ot-shape-fallback.cc \\\n\n    LOCAL_CPP_EXTENSION := .cc\n\n    LOCAL_C_INCLUDES += $(LOCAL_PATH)/src external/icu4c/common \\\n                 $(LOCAL_PATH)/src $(LOCAL_PATH)/../freetype/include\n\n    LOCAL_CFLAGS := -DHAVE_OT\n    LOCAL_MODULE:= GLPiharfbuzz\n    LOCAL_STATIC_LIBRARIES := GLPift2\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```java\n    public class GLESNativeLib {\n    static {\n     System.loadLibrary(\"GLPiharfbuzz\");\n        . . . . . . Other code\n    }\n    ```", "```java\n    FONT_PATH= $(FRAMEWORK_DIR)/Font\n    include $(MY_CUR_LOCAL_PATH)/../../../../GLPIFramework/Font/harfbuzz-ng/Android.mk\n\n    LOCAL_C_INCLUDES += $(FONT_PATH)/FreeType/include\n    LOCAL_C_INCLUDES += $(FONT_PATH)/harfbuzz-ng/src\n\n    LOCAL_SRC_FILES += $(SCENE_DIR)/FontGenerator.cpp \\\n                       $(SCENE_DIR)/FontShaping.cpp \\\n                       $(SCENE_DIR)/Font.cpp \\\n                       $(SCENE_DIR)/FontSample.cpp \\\n                       $(SCENE_DIR)/SimpleTexture.cpp\n    LOCAL_SHARED_LIBRARIES += GLPiharfbuzz\n    ```", "```java\n    ../../../../GLPIFramework/Font/harfbuzz-ng/src/\n    ```", "```java\n    class FontShaping : public FontGenerator{\n     public:\n        FontShaping(){ font = NULL; buffer = NULL; }\n        ~FontShaping(){}\n        void setDirectionAndScript\n             (hb_buffer_t *&buffer, LanguageType languageType);\n        bool produceShape(const char* string, vector<FT_UInt >&);\n\n     private:\n        hb_font_t  *font;\n        hb_buffer_t  *buffer;\n    };\n    ```", "```java\n    bool FontShaping::produceShape(const char* str, std::vector< FT_UInt >& codePoints){\n        FT_UInt glyph_index = 0;\n        hb_glyph_info_t *glyph_info;\n        FT_Face     ft_face = fontFace; //handle to face object\n        if (!ft_face)\n            { return false; }\n\n        int num_chars = (int)strlen(str);\n        if (!font) { font=hb_ft_font_create(ft_face, NULL); }\n\n        /* Create a buffer for harfbuzz to use */\n        if (buffer){ hb_buffer_destroy(buffer); buffer=NULL; }\n\n        buffer = hb_buffer_create();\n\n        // The languageType is an enum containing enum of\n        // different supported languages\n       setDirectionAndScript(buffer, languageType);\n\n        /* Layout the text */\n        hb_buffer_add_utf8(buffer, str, num_chars, 0, num_chars);\n        hb_shape(font, buffer, NULL, 0);\n\n        glyph_count = hb_buffer_get_length(buffer);\n        glyph_info  = hb_buffer_get_glyph_infos(buffer, 0);\n        for (int i = 0; i < glyph_count; i++) {\n            glyph_index = glyph_info[i].codepoint;\n            codePoints.push_back(glyph_index);\n        }\n\n        if (buffer) {hb_buffer_destroy(buffer); buffer=NULL;}\n        if (codePoints.size() <=0 ) { return false; }\n        return true;\n    }\n    ```", "```java\n    void FontShaping::setDirectionAndScript\n    (hb_buffer_t *&buffer, LanguageType languageType){\n        switch( languageType ){\n            case Thai:{\n                hb_buffer_set_direction(buffer, HB_DIRECTION_LTR);\n                hb_buffer_set_script(buffer, HB_SCRIPT_THAI);\n            }break;\n\n            case Punjabi:{\n                hb_buffer_set_direction(buffer, \n                                      HB_DIRECTION_LTR);\n                hb_buffer_set_script(buffer, \n                                      HB_SCRIPT_GURMUKHI);\n            }break;\n\n            case Arabic:{\n                hb_buffer_set_direction(buffer, \n                                      HB_DIRECTION_RTL);\n                hb_buffer_set_script(buffer, HB_SCRIPT_ARABIC);\n            }break;\n\n            case Tamil:{\n                hb_buffer_set_direction(buffer,\n                                      HB_DIRECTION_LTR);\n                hb_buffer_set_script(buffer, HB_SCRIPT_TAMIL);\n            }break;\n\n            default:{\n                hb_buffer_set_direction(buffer,\n                                      HB_DIRECTION_LTR);\n                hb_buffer_set_script(buffer, HB_SCRIPT_COMMON);\n            }break;\n        }\n    }\n    ```", "```java\n    for (FT_ULong charcode=FT_Get_First_Char(fontFace, &gindex);\n           gindex != 0; charcode=FT_Get_Next_Char\n          (fontFace, charcode, &gindex)) { . . }\n    ```", "```java\n    for(int myc = 0; myc < numGlyphs; myc++) {  . . . }\n    ```", "```java\n        for (const char* c = str; *c != '\\0'; c++) {\n            const Glyph& gi = glyphs[((unsigned long) *c)];\n            TransformObj->TransformTranslate\n                 (gi.advanceHorizontal / 2.0, 0.0, 0.0);\n            drawGlyph(gi);\n        }\n    ```", "```java\n        std::vector< FT_UInt > codePointsPtr;\n      int glyph_count = 0;\n      if ( !produceShape(str, codePointsPtr, glyph_count) ){\n         LOGI(\"Error in producing font shape\");return;}\n\n      glyph_count = (int) codePointsPtr.size();\n      FT_UInt glyph_index = 0;\n      for (int i = 0; i < glyph_count; i++) {\n          glyph_index = codePointsPtr.at(i);\n          const Glyph& gi = glyphs[glyph_index];\n          TransformObj->TransformTranslate\n              (gi.advanceHorizontal / 2.0, 0.0, 0.0);\n          drawGlyph(gi);\n      }\n    ```", "```java\n    void Renderer::createModels(){\n       clearModels();\n       . . . . // Other code . . .\n       addModel( new Font(strcat(fname,\"ae_Nagham.ttf\"),\n             50, this, Arabic) );\n       addModel( new Font(strcat(fname,\"Roboto-Black.ttf\"),\n             50, this, English) );\n       addModel( new Font(strcat(fname,\"DroidSansThai.ttf\"),\n             50, this, Thai) );\n       addModel( new Font(strcat(fname,\"Uni Ila.Sundaram-03.ttf\"),\n            50, this, Tamil) );\n       addModel(new Font(strcat(fname,\"AnmolUni.ttf\"),\n            50, this, Punjabi) );\n        addModel( new FontSample(this) );\n    }\n    ```", "```java\n    void Cube::GetScreenCoordinates(){\n        // Get Screen Coordinates for cube vertices\n        int   viewport_matrix[4];\n        float screenCoord[3];\n        glGetIntegerv( GL_VIEWPORT, viewport_matrix );\n        screenCoordinateVector.clear(); // Clear vector\n\n        for(int i=0; i<sizeof(cubeVerts)/(sizeof(GLfloat)*3);i++){\n            GLfloat x = cubeVerts[i][0]; // Vertex X coordinate\n            GLfloat y = cubeVerts[i][1]; // Vertex Y coordinate\n            GLfloat z = cubeVerts[i][2]; // Vertex Z coordinate\n\n            int success = TransformObj->TransformProject\n                   (x, y, z,\n                   TransformObj->TransformGetModelViewMatrix(),\n                   TransformObj->TransformGetProjectionMatrix(),\n                   viewport_matrix, &screenCoord[0],\n                   &screenCoord[1], &screenCoord[2]);\n\n           if (!success)\n              {memset(screenCoord,0,sizeof(float)*3);continue;}\n            int screenX  = screenCoord[0];\n            int screenY  = viewport_matrix[3] - screenCoord[1];\n            screenCoordinateVector.push_back\n                         (glm::vec2(screenX,screenY));\n        }\n    }\n    ```", "```java\n    void Cube::Render(){\n\n      . . . . Other Rendering Code . . . .\n       glVertexAttribPointer(attribVertex, 3, GL_FLOAT,\n                GL_FALSE, 0, vertexBuffer);\n       glDrawArrays(GL_LINE_LOOP, 0, 36);\n       GetScreenCoordinates();\n    }\n    ```", "```java\n    void FontSample::HeadUpDisplay(int width, int height){\n        TransformObj->TransformSetMatrixMode( PROJECTION_MATRIX );\n\n        TransformObj->TransformLoadIdentity();\n        // Left ,Right ,Bottom , Top, Near, Far\n        TransformObj->TransformOrtho(0, width, 0, height,-1,1);\n\n        TransformObj->TransformSetMatrixMode( VIEW_MATRIX );\n        TransformObj->TransformLoadIdentity();\n\n        TransformObj->TransformSetMatrixMode( MODEL_MATRIX );\n        TransformObj->TransformLoadIdentity();\n    }\n    ```", "```java\n    void FontSample::Render(){\n        int viewport_matrix[4];\n        glGetIntegerv( GL_VIEWPORT, viewport_matrix );\n        HeadUpDisplay(viewport_matrix[2], viewport_matrix[3]);\n\n        Font* English = dynamic_cast<Font*>\n                       (RendererHandler->getModel(FontEnglish));\n        Cube* cubeObject = dynamic_cast<Cube*>\n                        (RendererHandler->getModel(CubeType));\n        std::vector<glm::vec2>* vertexVector =\n                       cubeObject->getScreenCoordinateVertices();\n\n        char buffer[500];\n        for(int i = 0; i<vertexVector->size(); i++) {\n            TransformObj->TransformPushMatrix();\n            TransformObj->TransformTranslate\n            (vertexVector->at(i).x, vertexVector->at(i).y, 0.0);\n            TransformObj->TransformScale(2.0, 2.0, 2.0);\n            memset(buffer, 0, 500);\n            sprintf(buffer, \"Vertex pos: %d,%d\", (int)\n            vertexVector->at(i).x, (int)vertexVector->at(i).y);\n            English->printText(buffer, 1.0, 1.0, 1.0, 1.0f );\n            TransformObj->TransformPopMatrix();\n        }\n    }\n    ```", "```java\nTransformObj->TransformSetMatrixMode( PROJECTION_MATRIX );\nTransformObj->TransformLoadIdentity();\n// Left, Right, Bottom, Top, Near, Far\nTransformObj->TransformOrtho(0, width, 0, height,-1,1);\n```"]