<html><head></head><body>
<div id="_idContainer116">
<h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-109"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.2.1"> Animating a Bouquet of Flowers</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to the next project. </span><span class="koboSpan" id="kobo.3.2">Here, we will create a bouquet of flowers, animate the flower petals so they open and close, and then add a smoke/vapor effect to make it look like the flower is breathing by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">blur</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.5.1"> modifier.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">Behind the flowers, we will place a winter backdrop, and make it snow too by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.7.1">CAEmitter</span></strong><span class="koboSpan" id="kobo.8.1"> class. </span><span class="koboSpan" id="kobo.8.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.9.1">CAEmitter</span></strong><span class="koboSpan" id="kobo.10.1"> class is a UIKit class that was built for animation, but to be able to access it, we will need to use a SwiftUI bridging protocol called </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.14.1"> protocol will let us bridge the two frameworks, UIKit </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">and SwiftUI.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Accompanying this, we will include two labels – </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">Breathe In</span></strong><span class="koboSpan" id="kobo.18.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">Breathe Out</span></strong><span class="koboSpan" id="kobo.20.1"> – so that you can breathe along with the flowers, similar to a </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">meditation app.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">So, in this chapter, we will cover the following topics: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Adding the variables and a </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">winter background</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Animating the </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">text labels</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">blur</span></strong><span class="koboSpan" id="kobo.29.1"> modifier to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">vapor effect</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Animating the flower petals in </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">an arc</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Adding the flower bouquet and the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">animated breath</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Creating falling snow in </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the scene</span></span></li>
</ul>
<h1 id="_idParaDest-110"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.37.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.38.1">You can download the resources and finished project from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">Chapter 8</span></strong></span><span class="koboSpan" id="kobo.40.1"> folder on </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.44.1">Adding the variables and a winter background</span></h1>
<p><span class="koboSpan" id="kobo.45.1">Let’s get started and </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.46.1">create a new SwiftUI project – I have called it </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">Breathing Flower</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Next, go ahead and </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.50.1">download the assets for this project. </span><span class="koboSpan" id="kobo.50.2">The images are </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">bouquet</span></strong><span class="koboSpan" id="kobo.52.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">petal</span></strong><span class="koboSpan" id="kobo.54.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">smoke</span></strong><span class="koboSpan" id="kobo.56.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">snow</span></strong><span class="koboSpan" id="kobo.58.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">winterNight</span></strong><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">After you download them, drop the images into the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">Assets catalog.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">We now have the pictures we need loaded into the project. </span><span class="koboSpan" id="kobo.62.2">So, let’s start in </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">ContentView</span></strong><span class="koboSpan" id="kobo.64.1"> and add the variables we need to make this flower </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">come alive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
import SwiftUI
struct ContentView: View {
    @State private var petal = false
    @State private var breatheInLabel = true
    @State private var breatheOutLabel = false
    @State private var offsetBreath = false
    @State private var diffuseBreath = false
    @State private var breatheTheBouquet = false</span></pre>
<p><span class="koboSpan" id="kobo.67.1">You should be familiar with the process of creating animating variables by now. </span><span class="koboSpan" id="kobo.67.2">Here, we made a variety of variables, including </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">Petal</span></strong><span class="koboSpan" id="kobo.70.1">: To track the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">petal’s movements</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">breatheInLabel</span></strong><span class="koboSpan" id="kobo.73.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">breatheOutLabel</span></strong><span class="koboSpan" id="kobo.75.1">: To track the </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">Breathe In</span></strong><span class="koboSpan" id="kobo.77.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">Breathe </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.79.1">Out</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.80.1"> labels</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">offsetBreath</span></strong><span class="koboSpan" id="kobo.82.1">: To move the breath from inside the flower to outside </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">the flower</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">diffuseBreath</span></strong><span class="koboSpan" id="kobo.85.1">: To track the transformation of the smoke from a still image to an animation </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">breatheTheBouquet</span></strong><span class="koboSpan" id="kobo.87.1">: To keep track of the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">bouquet animation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.89.1">Before we put these variables</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.90.1"> to use, let’s head</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.91.1"> into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">body</span></strong><span class="koboSpan" id="kobo.93.1"> property and add a winter image to the scene. </span><span class="koboSpan" id="kobo.93.2">First, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">ZStack</span></strong><span class="koboSpan" id="kobo.95.1"> in order to hold all of the views that we will </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">be adding:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.97.1">
var body: some View {
    ZStack {
        //MARK: - ADD A WINTER BACKGROUND - AND THE SNOW
        Image("winterNight").resizable()
          .aspectRatio(contentMode: .fill)
                            .frame(width: 400, height: 900)
       }
      }</span></pre>
<p><span class="koboSpan" id="kobo.98.1">This is familiar code to us now. </span><span class="koboSpan" id="kobo.98.2">Here, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Image</span></strong><span class="koboSpan" id="kobo.100.1"> initializer and passing in the background image called </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">winterNight</span></strong><span class="koboSpan" id="kobo.102.1">, which is in the assets catalog. </span><span class="koboSpan" id="kobo.102.2">Then, we are resizing the image and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">aspectRatio</span></strong><span class="koboSpan" id="kobo.104.1"> option of </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">fill</span></strong><span class="koboSpan" id="kobo.106.1"> to take up the whole screen, before finally giving it some dimensions with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">frame</span></strong><span class="koboSpan" id="kobo.108.1"> modifier. </span><span class="koboSpan" id="kobo.108.2">This is what the scene </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">looks like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.110.1"><img alt="Figure 8.1: The winterNight background " src="image/B18674_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.111.1">Figure 8.1: The winterNight background</span></p>
<p><span class="koboSpan" id="kobo.112.1">Now that we</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.113.1"> have added the background to the</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.114.1"> scene, our next goal is to add some labels: </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">Breathe In</span></strong><span class="koboSpan" id="kobo.116.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">Breathe Out</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">What we want to achieve here is to make the two labels grow and shrink at the same time as the flower petals open and close, so these labels will have the same duration and delay as the flower petals in the project, perfectly </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">in sync.</span></span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.120.1">Animating the text labels</span></h1>
<p><span class="koboSpan" id="kobo.121.1">Now, let’s add two labels that can act as a guide for the user to watch their breath. </span><span class="koboSpan" id="kobo.121.2">Still working in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">ZStack</span></strong><span class="koboSpan" id="kobo.123.1"> and moving </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.124.1">directly underneath the previous line of code, add another </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">ZStack</span></strong><span class="koboSpan" id="kobo.126.1">, and fill it with </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
//MARK: - ANIMATE TEXT LABELS SO THEY GROW AND SHRINK
  //a ZStack so we can offset the entire scene vertically
  ZStack {
     Group {
        Text("Breathe In")
             .font(Font.custom("papyrus", size: 35))
             .foregroundColor(Color(UIColor.green))
             .opacity(breatheInLabel ? </span><span class="koboSpan" id="kobo.128.2">0 : 1)
             .scaleEffect(breatheInLabel ? </span><span class="koboSpan" id="kobo.128.3">0 : 1)
             .offset(y: -160)
             .animation(Animation.easeInOut(duration: 
               2).delay(2).repeatForever(autoreverses: 
               true), value: breatheInLabel)
                 Text("Breathe Out")
             .font(Font.custom("papyrus", size: 35))
             .foregroundColor(Color(UIColor.orange))
             .opacity(breatheOutLabel ? </span><span class="koboSpan" id="kobo.128.4">0 : 1)
             .scaleEffect(breatheOutLabel ? </span><span class="koboSpan" id="kobo.128.5">0 : 1)
             .offset(y: -160)
             .animation(Animation.easeInOut(duration: 
               2).delay(2).repeatForever(autoreverses: 
               true),value: breatheOutLabel)
            }
         }</span></pre>
<p><span class="koboSpan" id="kobo.129.1">Let’s dissect this code a little bit and see what we’re doing. </span><span class="koboSpan" id="kobo.129.2">First, we’re adding a second </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">ZStack</span></strong><span class="koboSpan" id="kobo.131.1">, then a group, to help keep the </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">code organized.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Text</span></strong><span class="koboSpan" id="kobo.135.1"> initializer and type in whatever text we’d like to appear on the screen. </span><span class="koboSpan" id="kobo.135.2">In our case, we are typing in </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Breathe In</span></strong><span class="koboSpan" id="kobo.137.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">Breathe Out</span></strong><span class="koboSpan" id="kobo.139.1">, and just like that, we have text on the </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.140.1">screen. </span><span class="koboSpan" id="kobo.140.2">Then, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">font</span></strong><span class="koboSpan" id="kobo.142.1"> modifier, you can change the font to one of your choosing. </span><span class="koboSpan" id="kobo.142.2">Xcode comes with many built-in fonts, and I am using one </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">papyrus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.146.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.147.1">If you’d like to know the names of the fonts that you can use for iOS, you can go to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">website: </span></span><a href="https://developer.apple.com/fonts/system-fonts/"><span class="No-Break"><span class="koboSpan" id="kobo.149.1">https://developer.apple.com/fonts/system-fonts/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.150.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">As well as choosing the specific font type, we set the font </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">size</span></strong><span class="koboSpan" id="kobo.153.1"> parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">35</span></strong><span class="koboSpan" id="kobo.155.1">, and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">foregroundColor</span></strong><span class="koboSpan" id="kobo.157.1"> modifier to make the </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">Breathe In</span></strong><span class="koboSpan" id="kobo.159.1"> label green and the </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">Breathe Out</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.161.1">label orange.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Next, the opacity of the text labels is animated here by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">breatheIn</span></strong><span class="koboSpan" id="kobo.164.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">breatheOut</span></strong><span class="koboSpan" id="kobo.166.1"> variables. </span><span class="koboSpan" id="kobo.166.2">When those variables are </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">true</span></strong><span class="koboSpan" id="kobo.168.1">, their opacity will be set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">0</span></strong><span class="koboSpan" id="kobo.170.1">, which makes the label text invisible. </span><span class="koboSpan" id="kobo.170.2">But when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">breatheIn</span></strong><span class="koboSpan" id="kobo.172.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">breatheOut</span></strong><span class="koboSpan" id="kobo.174.1"> variables are </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">false</span></strong><span class="koboSpan" id="kobo.176.1">, the text will be set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">1</span></strong><span class="koboSpan" id="kobo.178.1">, and they will become </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">visible again.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">After that, we set the size of the two text labels by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">scaleEffect</span></strong><span class="koboSpan" id="kobo.182.1"> modifier. </span><span class="koboSpan" id="kobo.182.2">We’re using a ternary operator, which checks whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">breatheIn</span></strong><span class="koboSpan" id="kobo.184.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">breatheOut</span></strong><span class="koboSpan" id="kobo.186.1"> variables are </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">true</span></strong><span class="koboSpan" id="kobo.188.1"> or not; if so, then we will scale the labels down to </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">0</span></strong><span class="koboSpan" id="kobo.190.1">; otherwise, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">breatheIn</span></strong><span class="koboSpan" id="kobo.192.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">breatheOut</span></strong><span class="koboSpan" id="kobo.194.1"> variables are </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">true</span></strong><span class="koboSpan" id="kobo.196.1">, we will scale the text labels back up to full size, which is </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">35</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1"> points.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">The next line of code positions the label on the screen for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">y</span></strong><span class="koboSpan" id="kobo.201.1"> axis, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">offset</span></strong><span class="koboSpan" id="kobo.203.1"> modifier. </span><span class="koboSpan" id="kobo.203.2">Remember, the </span><em class="italic"><span class="koboSpan" id="kobo.204.1">y</span></em><span class="koboSpan" id="kobo.205.1"> axis position </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">views vertically.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Lastly, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">animation</span></strong><span class="koboSpan" id="kobo.209.1"> modifier. </span><span class="koboSpan" id="kobo.209.2">The animation will start as it usually does when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">breatheIn</span></strong><span class="koboSpan" id="kobo.211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">breatheOut</span></strong><span class="koboSpan" id="kobo.213.1"> variables become </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">true</span></strong><span class="koboSpan" id="kobo.215.1">. </span><span class="koboSpan" id="kobo.215.2">The animation will have a duration of 2 seconds, which means it will take 2 seconds to complete, and then it will have a delay of 2 seconds before </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">starting again.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">And that completes the animation of the </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">Breathe In</span></strong><span class="koboSpan" id="kobo.219.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">Breathe Out</span></strong><span class="koboSpan" id="kobo.221.1"> labels. </span><span class="koboSpan" id="kobo.221.2">To see this in action, let’s add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">onAppear</span></strong><span class="koboSpan" id="kobo.223.1"> modifier right after the closing brace of the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">first </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">ZStack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
   .onAppear {
                breatheInLabel.toggle()
                breatheOutLabel.toggle()
            }</span></pre>
<p><span class="koboSpan" id="kobo.228.1">As we’ve seen, </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">onAppear</span></strong><span class="koboSpan" id="kobo.230.1"> will run the code in its body when the view first appears – that is, when the user taps on the app</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.231.1"> to open it. </span><span class="koboSpan" id="kobo.231.2">The code we want to run is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">breatheIn</span></strong><span class="koboSpan" id="kobo.233.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">breatheOut</span></strong><span class="koboSpan" id="kobo.235.1"> variables; we want to toggle them to their opposite Boolean value to start </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">the animation.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">When you run this code in the previews or the simulator, you’ll see two labels, each with its own color, scaling up and scaling down, and at the same time, fading in </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">and out:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.239.1"><img alt="Figure 8.2: The Breathe In and Breathe Out labels added " src="image/B18674_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.240.1">Figure 8.2: The Breathe In and Breathe Out labels added</span></p>
<p><span class="koboSpan" id="kobo.241.1">That completes the labels. </span><span class="koboSpan" id="kobo.241.2">Now, let’s focus </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.242.1">our attention on making an image that looks like vapor to </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">represent breath.</span></span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.244.1">Using the blur modifier to create a vapor effect</span></h1>
<p><span class="koboSpan" id="kobo.245.1">In this part of</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.246.1"> the project, we will be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">blur</span></strong><span class="koboSpan" id="kobo.248.1"> modifier, which will apply a Gaussian blur to an image using a radius value that we specify. </span><span class="koboSpan" id="kobo.248.2">If you’re not familiar with what a Gaussian blur is, this is a technique that is widely used in image editing software (such as Photoshop) and works by reducing the noise and detail of an image to create a smooth blurring visual effect. </span></p>
<p><span class="koboSpan" id="kobo.249.1">We will use an image of smoke, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">breath</span></strong><span class="koboSpan" id="kobo.251.1"> (which is in the Assets catalog), and apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">blur</span></strong><span class="koboSpan" id="kobo.253.1"> modifier to it, which will create a vapor effect and make our flower look like </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">it’s breathing.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">There is very little code needed to achieve this effect. </span><span class="koboSpan" id="kobo.255.2">Coming out of the previous group we made, let’s make a new group and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
//MARK: - TAKE AN IMAGE AND CONVERT IT TO VAPOR (BREATH)
  USING THE BLUR MODIFIER
      Group {
          Image("breath").resizable().frame(width: 35,
            height: 125)
              .offset(y: offsetBreath ? </span><span class="koboSpan" id="kobo.257.2">90 : 0)
              .animation(Animation.easeInOut(duration:
                2).delay(2).repeatForever(autoreverses:
                true),value: offsetBreath)
              .blur(radius: diffuseBreath ? </span><span class="koboSpan" id="kobo.257.3">1 : 60)
              .offset(x: 0, y: diffuseBreath ? </span><span class="koboSpan" id="kobo.257.4">-50 : -100)
              .animation(Animation.easeInOut(duration:
                2).delay(2).repeatForever(autoreverses:
                true), value: showBreath)
      }.shadow(radius: showBreath ? </span><span class="koboSpan" id="kobo.257.5">20 : 0)
           </span></pre>
<p><span class="koboSpan" id="kobo.258.1">In the group, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Image</span></strong><span class="koboSpan" id="kobo.260.1"> initializer and pass in the image we want to use, </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">breath</span></strong><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">Then, we give it some dimensions, with a width of </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">35</span></strong><span class="koboSpan" id="kobo.264.1"> and a height of </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">125</span></strong><span class="koboSpan" id="kobo.266.1">. </span></p>
<p><span class="koboSpan" id="kobo.267.1">After that, the code offsets the</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.268.1"> image vertically on the </span><em class="italic"><span class="koboSpan" id="kobo.269.1">y</span></em><span class="koboSpan" id="kobo.270.1"> axis. </span><span class="koboSpan" id="kobo.270.2">Then, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">offsetBreath</span></strong><span class="koboSpan" id="kobo.272.1"> variable becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">true</span></strong><span class="koboSpan" id="kobo.274.1">, the image moves </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">90</span></strong><span class="koboSpan" id="kobo.276.1"> points up, so it’s coming out of the flower, and when </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">offsetBreath</span></strong><span class="koboSpan" id="kobo.278.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">false</span></strong><span class="koboSpan" id="kobo.280.1">, the image moves back down and is set back </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Next, we add the animation to the image and to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">offset</span></strong><span class="koboSpan" id="kobo.286.1"> modifier (yes, we can animate an </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">offset</span></strong><span class="koboSpan" id="kobo.288.1"> modifier too!). </span><span class="koboSpan" id="kobo.288.2">We are using the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">duration</span></strong><span class="koboSpan" id="kobo.290.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">delay</span></strong><span class="koboSpan" id="kobo.292.1"> values as the text labels (2 seconds, respectively) so that the labels and vapor animate </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">in sync.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">The next line is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">blur</span></strong><span class="koboSpan" id="kobo.296.1"> modifier – this is what creates the magic of turning the image into a puff of vapor. </span><span class="koboSpan" id="kobo.296.2">This modifier has a parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">radius</span></strong><span class="koboSpan" id="kobo.298.1">, which accepts any integer number; the smaller the number, the less Gaussian blur is applied to the image, whereas the larger the number, the more blurred the image becomes. </span><span class="koboSpan" id="kobo.298.2">The ternary operator oversees the setting of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">radius</span></strong><span class="koboSpan" id="kobo.300.1"> value to either </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">1</span></strong><span class="koboSpan" id="kobo.302.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">60</span></strong><span class="koboSpan" id="kobo.304.1">, so depending on whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">diffuseBreath</span></strong><span class="koboSpan" id="kobo.306.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">true</span></strong><span class="koboSpan" id="kobo.308.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">false</span></strong><span class="koboSpan" id="kobo.310.1">, we can control the amount of Gaussian blur on the image. </span><span class="koboSpan" id="kobo.310.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">diffuseBreath</span></strong><span class="koboSpan" id="kobo.312.1"> becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">true</span></strong><span class="koboSpan" id="kobo.314.1">, the image gets blurred by only </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">1</span></strong><span class="koboSpan" id="kobo.316.1"> point, but when </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">diffuseBreath</span></strong><span class="koboSpan" id="kobo.318.1"> becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">false</span></strong><span class="koboSpan" id="kobo.320.1">, the code will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">60</span></strong><span class="koboSpan" id="kobo.322.1"> points of Gaussian blur to </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the image.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">Let’s look at the next line of</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.325.1"> code – this is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">offset</span></strong><span class="koboSpan" id="kobo.327.1"> modifier and is responsible for positioning the blur. </span><span class="koboSpan" id="kobo.327.2">We want to offset the smoke so it moves from inside the flower to outside the flower. </span><span class="koboSpan" id="kobo.327.3">This is accomplished by checking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">diffuseBreath</span></strong><span class="koboSpan" id="kobo.329.1"> variable; when it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">true</span></strong><span class="koboSpan" id="kobo.331.1">, the vapor moves </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">50</span></strong><span class="koboSpan" id="kobo.333.1"> points up, and when it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">false</span></strong><span class="koboSpan" id="kobo.335.1">, the vapor moves </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">100</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.337.1">points down.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">After that, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">animation</span></strong><span class="koboSpan" id="kobo.340.1"> modifier will interpolate through all the Gaussian blur values, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">1</span></strong><span class="koboSpan" id="kobo.342.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">60</span></strong><span class="koboSpan" id="kobo.344.1">. </span><span class="koboSpan" id="kobo.344.2">In this interpolation (or looping, if you will), these values will act on the image very quickly, so fast that the non-moving still image of smoke will be transformed into an actual animation of smoke that will move up and disperse, as real </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">smoke does.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.346.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.347.1">You may also have noticed that we are using two </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">animation</span></strong><span class="koboSpan" id="kobo.349.1"> modifiers here. </span><span class="koboSpan" id="kobo.349.2">The reason for this is that the first one is placed right after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">offset</span></strong><span class="koboSpan" id="kobo.351.1"> modifier, so it is being used to animate the offset of the image up and down; any code we add </span><em class="italic"><span class="koboSpan" id="kobo.352.1">after</span></em><span class="koboSpan" id="kobo.353.1"> that </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">animation</span></strong><span class="koboSpan" id="kobo.355.1"> modifier will not be animated, hence the use of the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">animation</span></strong><span class="koboSpan" id="kobo.357.1"> modifier. </span><span class="koboSpan" id="kobo.357.2">The second one is used to animate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">blur</span></strong><span class="koboSpan" id="kobo.359.1"> modifier to make smoke and to animate the offset that moves the smoke. </span><span class="koboSpan" id="kobo.359.2">So remember, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">animation</span></strong><span class="koboSpan" id="kobo.361.1"> modifiers act on the views above them, but if we need to add more of them, we can just add them as needed to animate any subsequent views, as we have </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">done here.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Lastly, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">shadow</span></strong><span class="koboSpan" id="kobo.365.1"> modifier, which will add a subtle shadow of </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">20</span></strong><span class="koboSpan" id="kobo.367.1"> points around the moving breath when it exits </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">the flower.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">Now, to see the smoke</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.370.1"> transformation, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">offsetBreath</span></strong><span class="koboSpan" id="kobo.372.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">diffuseBreath</span></strong><span class="koboSpan" id="kobo.374.1"> variables to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">onAppear</span></strong><span class="koboSpan" id="kobo.376.1"> modifier, </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
   .onAppear {
                breatheInLabel.toggle()
                breatheOutLabel.toggle()
                offsetBreath.toggle()
                diffuseBreath.toggle()
            }</span></pre>
<p><span class="koboSpan" id="kobo.379.1">This is what we </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">can see:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.381.1"><img alt="Figure 8.3: The smoke in our animation " src="image/B18674_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.382.1">Figure 8.3: The smoke in our animation</span></p>
<p><span class="koboSpan" id="kobo.383.1">As the animation starts out, the image of smoke is only being blurred by </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">1</span></strong><span class="koboSpan" id="kobo.385.1"> point, but as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">offset</span></strong><span class="koboSpan" id="kobo.387.1"> modifier moves the image upward, the blurring increases all the way to </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">60</span></strong><span class="koboSpan" id="kobo.389.1"> points. </span><span class="koboSpan" id="kobo.389.2">At </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">60</span></strong><span class="koboSpan" id="kobo.391.1"> points, the once still image has now been transformed into smoke, mimicking a breath. </span></p>
<p><span class="koboSpan" id="kobo.392.1">As an aside, something</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.393.1"> interesting to check out later is that if you want to see the process of the smoke image turning into moving vapor at any time, then add this line of code beneath the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">shadow</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1"> modifier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
 .zIndex(1)</span></pre>
<p><span class="koboSpan" id="kobo.397.1">This will move the smoke image to the front of the scene, and you will see it being transformed into </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">moving vapor.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">With the vapor effect added, we can move on to the next step, which is adding the bouquet of flowers to </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">the image.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.401.1">Animating flower petals in an arc</span></h1>
<p><span class="koboSpan" id="kobo.402.1">We have a background, text labels, and </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.403.1">an inhaling and exhaling breath effect; now let’s add the petals to the scene. </span><span class="koboSpan" id="kobo.403.2">We can add the petal code in a separate file, so press </span><em class="italic"><span class="koboSpan" id="kobo.404.1">Command</span></em><span class="koboSpan" id="kobo.405.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.406.1">N</span></em><span class="koboSpan" id="kobo.407.1"> to bring up the </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">New File</span></strong><span class="koboSpan" id="kobo.409.1"> window, and create a new SwiftUIView file </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">PetalView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">The goal here is to make five petals move in an arc, so they open and close. </span><span class="koboSpan" id="kobo.413.2">We only need two variables for this, so this will be a very small file: we need one Boolean (</span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">Bool</span></strong><span class="koboSpan" id="kobo.415.1">) variable to track the animation, and another variable to hold the number of rotations we want for each petal. </span><span class="koboSpan" id="kobo.415.2">Let’s add </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">them now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
    @Binding var petal: Bool
    var degrees: Double = 0.0</span></pre>
<p><span class="koboSpan" id="kobo.418.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Binding</span></strong><span class="koboSpan" id="kobo.420.1"> variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">petal</span></strong><span class="koboSpan" id="kobo.422.1"> will handle the animation. </span><span class="koboSpan" id="kobo.422.2">We are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Binding</span></strong><span class="koboSpan" id="kobo.424.1"> wrapper because we are in a new struct, and we will need to use this variable in another struct, </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">ContentView</span></strong><span class="koboSpan" id="kobo.426.1">. </span><span class="koboSpan" id="kobo.426.2">When we prefix a variable with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">Binding</span></strong><span class="koboSpan" id="kobo.428.1"> wrapper, we can then use it (bind it) to another struct </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">or view.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Let’s now move into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">body</span></strong><span class="koboSpan" id="kobo.432.1"> property and create a petal. </span><span class="koboSpan" id="kobo.432.2">Add the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
struct PetalView: View {
  var body: some View {
      Image("petal").resizable().frame(width: 75, height:
        125)
          .rotationEffect(.degrees(petal ? </span><span class="koboSpan" id="kobo.434.2">degrees :
            degrees), anchor: .bottom)
          .animation(Animation.easeInOut(duration: 
            2).delay(2).repeatForever(autoreverses: true),
            value: petal)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.435.1">There are only three</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.436.1"> lines of code to look at: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.437.1">First, we add the petal image from the Assets Catalog to the scene and appropriately </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">size it.</span></span></li>
<li><span class="koboSpan" id="kobo.439.1">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">rotationEffect</span></strong><span class="koboSpan" id="kobo.441.1"> modifier to open and close the petal by choosing between two </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">degree</span></strong><span class="koboSpan" id="kobo.443.1"> values: one value for the petal opening and one for its closing. </span><span class="koboSpan" id="kobo.443.2">We also anchor the rotation point to the bottom of the petal, so the petals will open and close in </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">an arc.</span></span></li>
<li><span class="koboSpan" id="kobo.445.1">Then, we simply call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">animation</span></strong><span class="koboSpan" id="kobo.447.1"> modifier to add the animation. </span><span class="koboSpan" id="kobo.447.2">Again, we continue to keep </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">duration</span></strong><span class="koboSpan" id="kobo.449.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">delay</span></strong><span class="koboSpan" id="kobo.451.1"> at </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">2</span></strong><span class="koboSpan" id="kobo.453.1"> seconds and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">autoreverses</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.455.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.458.1">To see the petal image in the previews, let’s modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">previews</span></strong><span class="koboSpan" id="kobo.460.1"> struct to look </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
struct PetalView_Previews: PreviewProvider {
    static var previews: some View {
        PetalView(petal: .constant(true))
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.463.1">The only change in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">PetalView_Previews</span></strong><span class="koboSpan" id="kobo.465.1"> struct is that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">petal</span></strong><span class="koboSpan" id="kobo.467.1"> parameter and pass in the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">.constant(true)</span></strong><span class="koboSpan" id="kobo.469.1">. </span><span class="koboSpan" id="kobo.469.2">This turns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">petal</span></strong><span class="koboSpan" id="kobo.471.1"> variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">true</span></strong><span class="koboSpan" id="kobo.473.1">, enabling the previews to display the contents of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">PetalsView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1"> struct.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Let’s now</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.477.1"> move back into </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">ContentView</span></strong><span class="koboSpan" id="kobo.479.1">, and call this new </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">PetalView</span></strong><span class="koboSpan" id="kobo.481.1"> struct five times to display all </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">five petals:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
//MARK: - ANIMATE FLOWER PETALS IN AN ARC
    Group {
        PetalView(petal: $petal, degrees: petal ? </span><span class="koboSpan" id="kobo.483.2">-25 : -5)
        ///middle petal does not move
        Image("petal").resizable().frame(width: 75, height:
          125)
        PetalView(petal: $petal, degrees: petal ? </span><span class="koboSpan" id="kobo.483.3">25 : 5)
        PetalView(petal: $petal, degrees: petal ? </span><span class="koboSpan" id="kobo.483.4">-50 :
          -10)
        PetalView(petal: $petal, degrees: petal ? </span><span class="koboSpan" id="kobo.483.5">50 : 10)
    }</span></pre>
<p><span class="koboSpan" id="kobo.484.1">The code calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">PetalView</span></strong><span class="koboSpan" id="kobo.486.1"> four times to add four petals to the UI, and then the fifth petal (the middle one) is added by a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">Image</span></strong><span class="koboSpan" id="kobo.488.1"> initializer, as this petal will not be animated. </span><span class="koboSpan" id="kobo.488.2">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.490.1"><img alt="Figure 8.4: The petals  " src="image/B18674_08_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.491.1">Figure 8.4: The petals </span></p>
<p><span class="koboSpan" id="kobo.492.1">Notice the dollar sign syntax (</span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">$</span></strong><span class="koboSpan" id="kobo.494.1">) for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">petal</span></strong><span class="koboSpan" id="kobo.496.1"> parameter: that is how we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Binding</span></strong><span class="koboSpan" id="kobo.498.1"> variable in </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.499.1">another struct. </span><span class="koboSpan" id="kobo.499.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">degrees</span></strong><span class="koboSpan" id="kobo.501.1"> parameter, we have two values: again, one for when the petal is open, and one for when it is closed. </span><span class="koboSpan" id="kobo.501.2">When the binding </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">$petal</span></strong><span class="koboSpan" id="kobo.503.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">true</span></strong><span class="koboSpan" id="kobo.505.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">degrees</span></strong><span class="koboSpan" id="kobo.507.1"> value on the left is used, and when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">$petal</span></strong><span class="koboSpan" id="kobo.509.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">false</span></strong><span class="koboSpan" id="kobo.511.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">degrees</span></strong><span class="koboSpan" id="kobo.513.1"> value on the right will </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">be used.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">Again, the middle petal will not be animated, so we only need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">Image</span></strong><span class="koboSpan" id="kobo.517.1"> initializer and then set its size. </span><span class="koboSpan" id="kobo.517.2">The remaining petals use the same code; the only changes are the values for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">degrees</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.519.1"> parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">And that completes the petals. </span><span class="koboSpan" id="kobo.520.2">Let’s see how they animate by toggling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">petal</span></strong><span class="koboSpan" id="kobo.522.1"> variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">onAppear</span></strong><span class="koboSpan" id="kobo.524.1"> method, as we have done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">other variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
.onAppear {
            petal.toggle()
            breatheInLabel.toggle()
            breatheOutLabel.toggle()
            offsetBreath.toggle()
            diffuseBreath.toggle()
        }</span></pre>
<p><span class="koboSpan" id="kobo.527.1">The petals open and</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.528.1"> close as we have set them up – to a specific point, rotating in an arc, and then </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">closing again:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.530.1"><img alt="Figure 8.5: The petals animated " src="image/B18674_08_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.531.1">Figure 8.5: The petals animated</span></p>
<p><span class="koboSpan" id="kobo.532.1">There are three components left to add to </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">our project:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.534.1">A bouquet of flowers positioned directly over </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">the petals</span></span></li>
<li><span class="koboSpan" id="kobo.536.1">The moving breath surrounding the flowers </span></li>
<li><span class="koboSpan" id="kobo.537.1">Snow falling in </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">the background</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.539.1">In the next section, we</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.540.1"> will implement the first two points: adding the bouquet and the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">moving breath.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.542.1">Adding the flower bouquet and the animated breath</span></h1>
<p><span class="koboSpan" id="kobo.543.1">Adding the first </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.544.1">component, the bouquet, is relatively easy, as it is stuff we have already done; however, the second component, the moving breath, is a little tricky (but not to worry, we</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.545.1"> will go slow and everything will </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">be explained).</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">So, first up, the bouquet. </span><span class="koboSpan" id="kobo.547.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">ContentView</span></strong><span class="koboSpan" id="kobo.549.1">, after the petal group’s closing brace, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.551.1">
 //MARK: - ADD A BOUQUET OF FLOWERS AND MAKE THEM EXPAND 
   AND CONTRACT SO THEY APPEAR TO BE BREATHING 
    Group {
      Image("bouquet").resizable()
      .aspectRatio(contentMode: .fit)
            .frame(width: 300, height: 400)
            .rotationEffect(.degrees(37))
            .offset(x: -25, y: 90)
        ///breathe the bottom bouquet 1
            .scaleEffect(breathTheBouquet ? </span><span class="koboSpan" id="kobo.551.2">1.04 : 1,
              anchor: .center)
            .hueRotation(Angle(degrees: breatheTheBouquet ?
</span><span class="koboSpan" id="kobo.551.3">              50 : 360))
            .animation(Animation.easeInOut(duration: 
              2).delay(2).repeatForever(autoreverses: 
              true), value: breatheTheBouquet)
        
      Image("bouquet").resizable()
        .aspectRatio(contentMode: .fit)
            .frame(width: 300, height: 400)
            .rotationEffect(.degrees(32))
            .offset(x: -20, y: 95)
            .rotation3DEffect(.degrees(180), axis: (x: 0, 
              y: 1, z: 0))
        ///breathe the bottom bouquet 2
            .scaleEffect(breatheTheBouquet ? </span><span class="koboSpan" id="kobo.551.4">1.02 : 1, 
              anchor: .center)
            .hueRotation(Angle(degrees: breatheTheBouquet ? 
</span><span class="koboSpan" id="kobo.551.5">              -50 : 300))
            .animation(Animation.easeInOut(duration: 
              2).delay(2).repeatForever(autoreverses: 
              true), value: breatheTheBouquet)
    }</span></pre>
<p><span class="koboSpan" id="kobo.552.1">This looks like a lot of </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.553.1">code, but really, we are creating two bouquets using very similar code. </span><span class="koboSpan" id="kobo.553.2">The reason </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.554.1">why I’m using two bouquets and overlapping them is to create the illusion of a full bunch </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">of flowers.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">Let’s now look at the code. </span><span class="koboSpan" id="kobo.556.2">We start with the grouping organizational feature, and inside the group, we add the image for both bouquets. </span><span class="koboSpan" id="kobo.556.3">I’m setting the aspect ratio to </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">fit</span></strong><span class="koboSpan" id="kobo.558.1">, so the bouquet image keeps its proportional size, and framing the image with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">300</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.560.1">x </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">400</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">Next, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">rotation</span></strong><span class="koboSpan" id="kobo.565.1"> modifier on each bouquet, so we can rotate them to the proper angle we want in the scene; a </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">37</span></strong><span class="koboSpan" id="kobo.567.1">-degree rotation for the first bouquet looks good, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">32</span></strong><span class="koboSpan" id="kobo.569.1"> degrees for</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.570.1"> the second bouquet works better for that one. </span><span class="koboSpan" id="kobo.570.2">Then, each bouquet gets offset a</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.571.1"> little bit on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">x</span></strong><span class="koboSpan" id="kobo.573.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">y</span></strong><span class="koboSpan" id="kobo.575.1"> axes, so they’re neatly positioned directly over the breath. </span><span class="koboSpan" id="kobo.575.2">This location will help hide the breath, as we don’t want to see that until it animates up from </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">the bouquet.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">The next line scales the bouquets up a little. </span><span class="koboSpan" id="kobo.577.2">The reason for this is that we want to create the effect that the bouquets are breathing as well, along with the petals. </span><span class="koboSpan" id="kobo.577.3">The top bouquet gets scaled up to </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">1.04</span></strong><span class="koboSpan" id="kobo.579.1">, and the bottom bouquet gets scaled to </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">1.02</span></strong><span class="koboSpan" id="kobo.581.1">. </span><span class="koboSpan" id="kobo.581.2">Notice the top bouquet gets scaled up slightly more than the bottom bouquet: this is because we wanted to stagger the two bouquets a little. </span></p>
<p><span class="koboSpan" id="kobo.582.1">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">anchor</span></strong><span class="koboSpan" id="kobo.584.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">center</span></strong><span class="koboSpan" id="kobo.586.1">, so the two bouquets will expand and contract from </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">that point.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">The next line adds some hue rotation to the color of the bouquets so that they will change color along with the animation. </span><span class="koboSpan" id="kobo.588.2">We previously used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">hueRotation</span></strong><span class="koboSpan" id="kobo.590.1"> modifier in </span><a href="B18674_05.xhtml#_idTextAnchor073"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.591.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.592.1">, so that’s nothing new here, but we are using different values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">hueRotation</span></strong><span class="koboSpan" id="kobo.594.1"> to help make the bouquets more varied </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">in appearance.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">Also notice that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">rotation3DEffect</span></strong><span class="koboSpan" id="kobo.598.1"> modifier only on the bottom bouquet. </span><span class="koboSpan" id="kobo.598.2">This is because the bouquet image for the top and bottom are identical; they are simply one image that we’re using in two places, so by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">rotation3DEffect</span></strong><span class="koboSpan" id="kobo.600.1"> modifier here and passing in a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">1</span></strong><span class="koboSpan" id="kobo.602.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">y</span></strong><span class="koboSpan" id="kobo.604.1"> parameter, this will flip the bouquet image on the </span><em class="italic"><span class="koboSpan" id="kobo.605.1">y</span></em><span class="koboSpan" id="kobo.606.1"> axis to the bouquet’s opposite side. </span><span class="koboSpan" id="kobo.606.2">This helps give the overall look a more </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">symmetrical appearance.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Finally, we add the animation for both bouquets; this is the same animation as we’ve done for the previous views, with a 2-second duration and a 2-second delay, so all the animations are </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">in sync.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">Now, in order to see this animation in action, once again, we need to add the animating variable in charge of the bouquet to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">onAppear</span></strong><span class="koboSpan" id="kobo.612.1"> modifier. </span><span class="koboSpan" id="kobo.612.2">So, add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">onAppear</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.614.1"> modifier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.615.1">
}.onAppear {
            breatheInLabel.toggle()
            breatheOutLabel.toggle()
            offsetBreath.toggle()
            diffuseBreath.toggle()
            petal.toggle()
            breatheTheBouquet.toggle()
        }</span></pre>
<p><span class="koboSpan" id="kobo.616.1">Now, if we run the app, we</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.617.1"> will see the two bouquets expanding and contracting </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.618.1">slightly, along with the petals moving too. </span><span class="koboSpan" id="kobo.618.2">You will also see the bouquets’ colors changing, which is due to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">hueRotation</span></strong><span class="koboSpan" id="kobo.620.1"> modifier </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">we used.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.622.1"><img alt="Figure 8.6: The bouquet moving " src="image/B18674_08_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.623.1">Figure 8.6: The bouquet moving</span></p>
<p><span class="koboSpan" id="kobo.624.1">The bouquet expanding and contracting is a subtle look (it’s not pronounced like the petals opening and closing), which is the look we’re going for here; we just want to create a slight </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">expanding</span></span><span class="No-Break"><a id="_idIndexMarker452"/></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1"> effect.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">With that done and </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.628.1">our app already looking really good, we just need to add one more component to the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">project: snow.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.630.1">Creating falling snow in the scene</span></h1>
<p><span class="koboSpan" id="kobo.631.1">Making snow fall within </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.632.1">your app really makes it come alive: it gives a rather magical look to it and sets the right mood for our winter scene. </span><span class="koboSpan" id="kobo.632.2">To </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.633.1">do this, we need to utilize the power of UIKit and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.635.1"> protocol, along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">CAEmitter</span></strong><span class="koboSpan" id="kobo.637.1"> class. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.638.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.639.1">As you continue through the rest of this chapter, don’t worry if some of the UIKit classes and methods look different or unfamiliar to you as compared to the SwiftUI classes and methods we’ve been using. </span><span class="koboSpan" id="kobo.639.2">That’s because they </span><em class="italic"><span class="koboSpan" id="kobo.640.1">are</span></em><span class="koboSpan" id="kobo.641.1"> different, and that’s for a whole different book if you’d like to learn about UIKit. </span><span class="koboSpan" id="kobo.641.2">However, moving forward in this chapter, I will explain the different UIKit properties and methods used to make the snow for our animation, so you can get familiar with </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">the process.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.643.1">Adding the UIViewRepresentable protocol</span></h2>
<p><span class="koboSpan" id="kobo.644.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.646.1"> protocol is </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.647.1">what’s called a </span><strong class="bold"><span class="koboSpan" id="kobo.648.1">wrapper</span></strong><span class="koboSpan" id="kobo.649.1"> for UIKit. </span><span class="koboSpan" id="kobo.649.2">It allows SwiftUI to work with UIKit and use UIKits classes</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.650.1"> and methods. </span><span class="koboSpan" id="kobo.650.2">If you’ve ever coded with UIKit, you’ll know it’s quite different compared to SwiftUI. </span><span class="koboSpan" id="kobo.650.3">For one thing, it uses something called </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">Storyboards</span></strong><span class="koboSpan" id="kobo.652.1">, which are</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.653.1"> a different way to design your layout and organize your views by way of dragging and dropping objects from an object library, such as buttons and sliders and text, and connecting them together on a big storyboard in Xcode. </span><span class="koboSpan" id="kobo.653.2">The positioning of all those objects is completely different as well and </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.654.1">uses a system called </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">Auto Layout</span></strong><span class="koboSpan" id="kobo.656.1">, which is a system of methods and rules to keep your objects spaced apart and located on the screen, but it was very complicated and had a big learning curve. </span></p>
<p><span class="koboSpan" id="kobo.657.1">SwiftUI eliminates Storyboards and Auto Layout and is a complete departure from UIKit in how you design and build apps. </span><span class="koboSpan" id="kobo.657.2">It’s simpler and uses much less code to achieve the same results (as you probably already know). </span><span class="koboSpan" id="kobo.657.3">But, occasionally, we need to access some of the methods and classes that UIKit offers in order to do different things in our apps – for example, here, to make snow. </span><span class="koboSpan" id="kobo.657.4">That’s why we need the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">UIViewRepresentable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1"> protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.662.1"> protocol acts as a bridge between these two different frameworks, UIKit and SwiftUI, and lets us access the classes and methods we need. </span></p>
<p><span class="koboSpan" id="kobo.663.1">So, let’s create a new file to</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.664.1"> contain the snow code. </span><span class="koboSpan" id="kobo.664.2">Press </span><em class="italic"><span class="koboSpan" id="kobo.665.1">Command</span></em><span class="koboSpan" id="kobo.666.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.667.1">N</span></em><span class="koboSpan" id="kobo.668.1"> and create a SwiftUIView file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">SnowView</span></strong><span class="koboSpan" id="kobo.670.1">. </span><span class="koboSpan" id="kobo.670.2">Then, at the top of the struct, we will modify its heading to make it conform to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.672.1"> protocol. </span><span class="koboSpan" id="kobo.672.2">So, change the struct’s heading </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
//MARK: - CREATE SNOW FALLING ON THE SCENE
struct SnowView: UIViewRepresentable { 
         }</span></pre>
<p><span class="koboSpan" id="kobo.675.1">When we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.677.1"> protocol to the struct’s heading (right after the colon), this tells the system that we are now allowed to use the classes and methods from the UIKit framework. </span><span class="koboSpan" id="kobo.677.2">It also means we have to implement the required methods for this protocol. </span><span class="koboSpan" id="kobo.677.3">Some protocols only need you to declare them into a struct heading, as we have just done, but others also need you to implement some methods in order to satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">protocol requirements.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.679.1">Dealing with methods and errors</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.681.1"> requires that we add two methods to the struct: </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">makeUIView</span></strong><span class="koboSpan" id="kobo.683.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">updateView</span></strong><span class="koboSpan" id="kobo.685.1">. </span><span class="koboSpan" id="kobo.685.2">But</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.686.1"> because we haven’t added those methods yet, the change we just made will break our code and display an error: </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">SnowView does not conform to protocol UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.688.1">. </span><span class="koboSpan" id="kobo.688.2">That is true because, as mentioned, we need to implement two methods to satisfy </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">this protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">So, let’s add the first method now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">makeUIView</span></strong><span class="koboSpan" id="kobo.692.1">, by adding the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">SnowView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.694.1"> struct:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
func makeUIView(context: Context) -&gt; some UIView {
    }</span></pre>
<p><span class="koboSpan" id="kobo.696.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">makeUIView</span></strong><span class="koboSpan" id="kobo.698.1"> method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">UIView</span></strong><span class="koboSpan" id="kobo.700.1">, which will contain the snow, so we can use it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">ContentView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.702.1"> later.</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">The second method we </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.704.1">need to add is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">updateView</span></strong><span class="koboSpan" id="kobo.706.1">, which we can do directly under the </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">previous method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.708.1">
func updateUIView(_ uiView: UIViewType, context: Context) {
    }</span></pre>
<p><span class="koboSpan" id="kobo.709.1">This method is used when we want to update the view with new data. </span><span class="koboSpan" id="kobo.709.2">Since we don’t need to do any updating when the snow is made, we can leave this method empty. </span><span class="koboSpan" id="kobo.709.3">However, it’s a required method so it does have to be here in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">SnowView</span></strong><span class="koboSpan" id="kobo.711.1"> struct; otherwise, the code </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">won’t work.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">Now that we have the two required methods, the protocol should be satisfied. </span><span class="koboSpan" id="kobo.713.2">However, we still get an error: </span><strong class="bold"><span class="koboSpan" id="kobo.714.1">Function declares an opaque return type, but has no return statements in its body from which to infer an underlying type</span></strong><span class="koboSpan" id="kobo.715.1">. </span><span class="koboSpan" id="kobo.715.2">This error refers to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">makeUIView</span></strong><span class="koboSpan" id="kobo.717.1"> method and the fact that it has no return code in its body. </span><span class="koboSpan" id="kobo.717.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">makeUIView</span></strong><span class="koboSpan" id="kobo.719.1"> method needs to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">UIView</span></strong><span class="koboSpan" id="kobo.721.1"> (or simply, a view) in order for the error to go away. </span><span class="koboSpan" id="kobo.721.2">So, let’s fill out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">makeUIView</span></strong><span class="koboSpan" id="kobo.723.1"> method with the code that will return a view, which will, in turn, make </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">our snow.</span></span></p>
<p><span class="koboSpan" id="kobo.725.1">First, we need to set up the size of the view to fit the screen correctly. </span><span class="koboSpan" id="kobo.725.2">Remember, we are making a new view using UIKit’s classes and methods, so we have to tell it how big the screen dimensions should be for this view. </span><span class="koboSpan" id="kobo.725.3">Add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">makeUIView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.727.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.728.1">
    func makeUIView(context: Context) -&gt; some UIView {
    //configure the screen
            let screen = UIScreen.main.bounds
            let view = UIView(frame: CGRect(x: 0, y: 0, 
              width: screen.width, height: screen.height))
            view.layer.masksToBounds = true
        }</span></pre>
<p><span class="koboSpan" id="kobo.729.1">The first line of code creates a constant that will hold the bounds of the screen – that’s the rectangle of the screen from top to bottom and left </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">to right.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">The second line of code creates the view that we will need to return when we finish writing this method out. </span><span class="koboSpan" id="kobo.731.2">We’re setting the view to the size of the screen’s width and height so that when we </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.732.1">make the snow, we’re using the entire boundaries of the iPhone screen, not just a little portion </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">The next line of code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">masksToBounds</span></strong><span class="koboSpan" id="kobo.736.1"> Boolean property and sets it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">true</span></strong><span class="koboSpan" id="kobo.738.1">. </span><span class="koboSpan" id="kobo.738.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">masksToBounds</span></strong><span class="koboSpan" id="kobo.740.1"> property indicates to the system whether sublayers are clipped to the </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">layer’s bounds.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.742.1">Sublayers</span></strong><span class="koboSpan" id="kobo.743.1"> are layers or views that will </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.744.1">be added later in the code. </span><span class="koboSpan" id="kobo.744.2">Everything in code is made up of layers, code placed upon more code, placed upon even more code. </span><span class="koboSpan" id="kobo.744.3">You have seen that, when working with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">ZStack</span></strong><span class="koboSpan" id="kobo.746.1">, each view you place inside it gets stacked upon the </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">previous view.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">So with all this stacking up of views, there may be parts of a view that you may not want to show, and other parts of that same view you do want to show. </span><span class="koboSpan" id="kobo.748.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">maskToBounds</span></strong><span class="koboSpan" id="kobo.750.1"> property will clip any subviews to the bounds of the screen, which is helpful because we only want the snow to fall within the size of the screen; we don’t want any snow in any surrounding areas off the screen, only within the bounds of the screen, so we set this property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">true</span></strong><span class="koboSpan" id="kobo.752.1"> to clip off </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">any excess.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">Now, we need to return a view in order to silence this error. </span><span class="koboSpan" id="kobo.754.2">Remember, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">makeUIView</span></strong><span class="koboSpan" id="kobo.756.1"> method has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">return</span></strong><span class="koboSpan" id="kobo.758.1"> statement in its declaration, so add the following code at the end of our </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">previous code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.760.1">
func makeUIView(context: Context) -&gt; some UIView {
    //configure the screen
            let screen = UIScreen.main.bounds
            let view = UIView(frame: CGRect(x: 0, y: 0, 
              width: screen.width, height: screen.height))
            view.layer.masksToBounds = true
    
    return view
  }</span></pre>
<p><span class="koboSpan" id="kobo.761.1">Now, we have our screen size set up, we are returning a view, and we are error-free! </span><span class="koboSpan" id="kobo.761.2">The next task is to create </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.762.1">the snow, which we can do by using UIKit’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">CAEmitter</span></strong><span class="koboSpan" id="kobo.764.1"> class. </span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.765.1">Adding the CAEmitter class</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.766.1">CAEmitter</span></strong><span class="koboSpan" id="kobo.767.1"> (which stands for </span><strong class="bold"><span class="koboSpan" id="kobo.768.1">Core Animation Emitter</span></strong><span class="koboSpan" id="kobo.769.1">) is a class</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.770.1"> that has methods and properties that let us</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.771.1"> emit, animate, and</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.772.1"> render particle systems. </span></p>
<p><span class="koboSpan" id="kobo.773.1">So what’s a particle system? </span><span class="koboSpan" id="kobo.773.2">A particle system is just what it sounds like: a system that can produce hundreds or thousands of little particles on the iPhone screen, in any size that we want, moving at any speed that we set, and in any shape that we design. </span></p>
<p><span class="koboSpan" id="kobo.774.1">The particle shape that we want has already been designed because we will be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">snowflake</span></strong><span class="koboSpan" id="kobo.776.1"> image that we will drop into the assets catalog. </span><span class="koboSpan" id="kobo.776.2">However, we have to design how many snowflakes to make, how fast to make them move, how long to keep them on the screen, and the location on the screen from which they </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">are made.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">So, let’s go ahead and create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">emitter</span></strong><span class="koboSpan" id="kobo.780.1"> instance, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">CAEmitter</span></strong><span class="koboSpan" id="kobo.782.1"> class. </span><span class="koboSpan" id="kobo.782.2">Add the following code just underneath the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">masksToBounds</span></strong><span class="koboSpan" id="kobo.784.1"> line </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
   //configure the emitter
    let emitter = CAEmitterLayer()
    emitter.frame = CGRect(x: 200, y: -100, width: 
      view.frame.width, height: view.frame.height)</span></pre>
<p><span class="koboSpan" id="kobo.787.1">The first line creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">emitter</span></strong><span class="koboSpan" id="kobo.789.1"> instance using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">CAEmitter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.791.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.792.1">The next line sets the location and size of the emitter. </span><span class="koboSpan" id="kobo.792.2">Here, we are locating the emitter </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">200</span></strong><span class="koboSpan" id="kobo.794.1"> points along the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">x</span></strong><span class="koboSpan" id="kobo.796.1"> axis, which is about the middle of the iPhone screen, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">-100</span></strong><span class="koboSpan" id="kobo.798.1"> points along the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">y</span></strong><span class="koboSpan" id="kobo.800.1"> axis. </span><span class="koboSpan" id="kobo.800.2">This puts the emitter 100 points up and off from the iPhone screen. </span><span class="koboSpan" id="kobo.800.3">We put the emitter above the visible portion of the screen because we don’t want to see the snowflakes being created, we just want to see </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">them falling.</span></span></p>
<p><span class="koboSpan" id="kobo.802.1">As for the size of the emitter, we’re making it the exact size as the iPhone screen, which means using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">frame.width</span></strong><span class="koboSpan" id="kobo.804.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">frame.height</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.806.1"> values.</span></span></p>
<p><span class="koboSpan" id="kobo.807.1">Now that we’ve designed our emitter, let’s design the cell. </span><span class="koboSpan" id="kobo.807.2">To explain the difference between these two terms, think of the </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">emitter</span></strong><span class="koboSpan" id="kobo.809.1"> as a</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.810.1"> box that holds thousands of confetti particles, and each of</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.811.1"> those confetti </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.812.1">particles is a </span><strong class="bold"><span class="koboSpan" id="kobo.813.1">cell</span></strong><span class="koboSpan" id="kobo.814.1">. </span><span class="koboSpan" id="kobo.814.2">In our case, our cell will be a snowflake. </span></p>
<p><span class="koboSpan" id="kobo.815.1">To add our cell and make it move on screen, add the following code just under the </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">emitter code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.817.1">
        //configure the cell
        let cell = CAEmitterCell()
        cell.birthRate = 40
        cell.lifetime = 25
        cell.velocity = 60
        cell.scale = 0.025
        cell.emissionRange = CGFloat.pi
        cell.contents = UIImage(named: "snow")?.cgImage
        emitter.emitterCells = [cell]
        view.layer.addSublayer(emitter)</span></pre>
<p><span class="koboSpan" id="kobo.818.1">Here, we created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">cell</span></strong><span class="koboSpan" id="kobo.820.1"> instance using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">CAEmitterCell</span></strong><span class="koboSpan" id="kobo.822.1"> class and loaded it up with different properties. </span><span class="koboSpan" id="kobo.822.2">The following is a list of what these </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">properties do:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">birthRate</span></strong><span class="koboSpan" id="kobo.825.1">: How fast each cell or particle will be made. </span><span class="koboSpan" id="kobo.825.2">Using a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">40</span></strong><span class="koboSpan" id="kobo.827.1"> mimics a </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">gentle snowfall.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">lifetime</span></strong><span class="koboSpan" id="kobo.830.1">: How long to keep the cell on the screen before it’s removed. </span><span class="koboSpan" id="kobo.830.2">Using a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">25</span></strong><span class="koboSpan" id="kobo.832.1"> ensures that each snowflake stays on the screen long enough to make it to the bottom of </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">the screen.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">velocity</span></strong><span class="koboSpan" id="kobo.835.1">: How fast we want the cell to move on the screen. </span><span class="koboSpan" id="kobo.835.2">We’re using a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">60</span></strong><span class="koboSpan" id="kobo.837.1">, which is a speed that’s not too fast or too slow for </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">the snowflake.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">scale</span></strong><span class="koboSpan" id="kobo.840.1">: How big we want to make each cell. </span><span class="koboSpan" id="kobo.840.2">A value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">.025</span></strong><span class="koboSpan" id="kobo.842.1"> is a nice size for the snowflake, as it’s not too big or too small for </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">an iPhone.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">emissionRange</span></strong><span class="koboSpan" id="kobo.845.1">: How far we want to spread out the cells as they are being emitted. </span><span class="koboSpan" id="kobo.845.2">For this value, we are using a mathematical expression called Pi (often shown as the symbol π), which is defined as the circumference of a circle divided by the diameter of the same circle. </span><span class="koboSpan" id="kobo.845.3">Without getting too mathematical here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">CGFloat.pi</span></strong><span class="koboSpan" id="kobo.847.1"> value equals </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">180</span></strong><span class="koboSpan" id="kobo.849.1"> degrees – imagine a horizontal line drawn from the left to the right side of the phone screen; the value sets the snow to fall evenly from all areas of </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">that line.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">contents</span></strong><span class="koboSpan" id="kobo.852.1">: Sets the </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.853.1">contents of the cell to an image of our choice, which was set as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">snow</span></strong><span class="koboSpan" id="kobo.855.1"> image (make sure that you’ve added the image into the Assets Catalog so it can be accessed with this line </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">of code).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">emitterCells</span></strong><span class="koboSpan" id="kobo.858.1">: The cell particles that will become </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">the snow.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">addSublayer</span></strong><span class="koboSpan" id="kobo.861.1">: Adds a new layer to the scene. </span><span class="koboSpan" id="kobo.861.2">Remember that in SwiftUI, a layer is very similar to a view, and everything is a view in SwiftUI (buttons, text, colors, and more). </span><span class="koboSpan" id="kobo.861.3">In the UIKit world, a layer can also be thought of as a view – when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">addSublayer</span></strong><span class="koboSpan" id="kobo.863.1"> function is called, it will add whatever layer is in its parameter to </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">the scene.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.865.1">As always, these cell configuration values are completely arbitrary, so go ahead and experiment and make the snowflakes as big as you want, design them how you want, and make them move on the screen according to what you want them to do. </span><span class="koboSpan" id="kobo.865.2">There are no hard and fast rules when adding values into a cell; it’s all about experimenting and </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">having fun.</span></span></p>
<p><span class="koboSpan" id="kobo.867.1">And with that, we have completed the snow file. </span><span class="koboSpan" id="kobo.867.2">If you want to test the result, you can click </span><strong class="bold"><span class="koboSpan" id="kobo.868.1">Play</span></strong><span class="koboSpan" id="kobo.869.1">; however, as the default background of the preview is white, you won’t see our white snow. </span><span class="koboSpan" id="kobo.869.2">You can change this by swapping the background color, </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.871.1">
struct SnowView_Previews: PreviewProvider {
    static var previews: some View {
        SnowView()
            .background(Color.black)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.872.1">That will change the background color to black so you can see the snow; however, as we know, we will be using a winter background for the </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">final animation.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">So, to finish things off, we </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.875.1">need to call this </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">SnowView</span></strong><span class="koboSpan" id="kobo.877.1"> file inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">ContentView</span></strong><span class="koboSpan" id="kobo.879.1">. </span><span class="koboSpan" id="kobo.879.2">To do that, head back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">ContentView</span></strong><span class="koboSpan" id="kobo.881.1"> and add this final line of code right under the </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">background code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.883.1">
//MARK: - ADD A WINTER BACKGROUND - AND THE SNOW
  Image("winterNight").resizable().aspectRatio(contentMode: 
    .fill).frame(width: 400, height: 900)
  SnowView()</span></pre>
<p><span class="koboSpan" id="kobo.884.1">And that completes the project. </span><span class="koboSpan" id="kobo.884.2">You can now go ahead and </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">run it:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.886.1"><img alt="Figure 8.7: The finished project " src="image/B18674_08_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.887.1">Figure 8.7: The finished project</span></p>
<p><span class="koboSpan" id="kobo.888.1">The project has a</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.889.1"> breathing label animation, a breathing petal animation, a breathing bouquet animation, and a </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">snow animation.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.891.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.892.1">In this project, we created the illusion of a bouquet of flowers breathing by using a collection of coding modifiers: we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">blur</span></strong><span class="koboSpan" id="kobo.894.1"> to create the illusion of smoke, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">scale</span></strong><span class="koboSpan" id="kobo.896.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">rotationEffect</span></strong><span class="koboSpan" id="kobo.898.1"> to make the flowers expand and contract in an arc, and we also added labels on the screen. </span><span class="koboSpan" id="kobo.898.2">On top of this, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">UIViewRepresentable</span></strong><span class="koboSpan" id="kobo.900.1"> protocol and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">CAEmitter</span></strong><span class="koboSpan" id="kobo.902.1"> class, and incorporated particle systems to create </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">falling snow.</span></span></p>
<p><span class="koboSpan" id="kobo.904.1">Here are some extra thoughts on how to take this app further, or just practice adding some more features, to help stretch your skills with SwiftUI animations. </span><span class="koboSpan" id="kobo.904.2">How about adding some sound to the project? </span><span class="koboSpan" id="kobo.904.3">We did that in </span><a href="B18674_04.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.905.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.906.1"> with the Record Player project, and it’s very easy to do – you could add some guided voice narration that simply says “breathe in, breathe out” or some meditative music. </span></p>
<p><span class="koboSpan" id="kobo.907.1">Or how about adding a button or slider that will change the speed of the animation? </span><span class="koboSpan" id="kobo.907.2">Maybe you want to increase the petal opening and closing speed. </span><span class="koboSpan" id="kobo.907.3">If you’re not sure how to do that, keep following along in the book because, later, we will build a color game with a UI that uses buttons </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">and sliders.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">Let’s continue to the next chapter, where we will see how to animate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">stroke</span></strong><span class="koboSpan" id="kobo.911.1"> modifier so it creates a moving line around </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">any shape.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer117">
</div>
</div>
</body></html>