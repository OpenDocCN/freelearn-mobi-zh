<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor112"/>8</h1>
<h1 id="_idParaDest-109"><a id="_idTextAnchor113"/> Animating a Bouquet of Flowers</h1>
<p>Welcome to the next project. Here, we will create a bouquet of flowers, animate the flower petals so they open and close, and then add a smoke/vapor effect to make it look like the flower is breathing by using the <code>blur</code> modifier.</p>
<p>Behind the flowers, we will place a winter backdrop, and make it snow too by using the <code>CAEmitter</code> class. The <code>CAEmitter</code> class is a UIKit class that was built for animation, but to be able to access it, we will need to use a SwiftUI bridging protocol called <code>UIViewRepresentable</code>. The <code>UIViewRepresentable</code> protocol will let us bridge the two frameworks, UIKit and SwiftUI.</p>
<p>Accompanying this, we will include two labels – <strong class="bold">Breathe In</strong> and <strong class="bold">Breathe Out</strong> – so that you can breathe along with the flowers, similar to a meditation app.</p>
<p>So, in this chapter, we will cover the following topics: </p>
<ul>
<li>Adding the variables and a winter background</li>
<li>Animating the text labels</li>
<li>Using the <code>blur</code> modifier to create a vapor effect</li>
<li>Animating the flower petals in an arc</li>
<li>Adding the flower bouquet and the animated breath</li>
<li>Creating falling snow in the scene</li>
</ul>
<h1 id="_idParaDest-110"><a id="_idTextAnchor114"/>Technical requirements</h1>
<p>You can download the resources and finished project from the <code>Chapter 8</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor115"/>Adding the variables and a winter background</h1>
<p>Let’s get started and <a id="_idIndexMarker423"/>create a new SwiftUI project – I have called it <code>Breathing Flower</code>.</p>
<p>Next, go ahead and <a id="_idIndexMarker424"/>download the assets for this project. The images are <code>bouquet</code>, <code>petal</code>, <code>smoke</code>, <code>snow</code>, and <code>winterNight</code>. After you download them, drop the images into the Assets catalog.</p>
<p>We now have the pictures we need loaded into the project. So, let’s start in <code>ContentView</code> and add the variables we need to make this flower come alive:</p>
<pre class="source-code">
import SwiftUI
struct ContentView: View {
    @State private var petal = false
    @State private var breatheInLabel = true
    @State private var breatheOutLabel = false
    @State private var offsetBreath = false
    @State private var diffuseBreath = false
    @State private var breatheTheBouquet = false</pre>
<p>You should be familiar with the process of creating animating variables by now. Here, we made a variety of variables, including the following:</p>
<ul>
<li><code>Petal</code>: To track the petal’s movements</li>
<li><code>breatheInLabel</code> and <code>breatheOutLabel</code>: To track the <strong class="bold">Breathe In</strong> and <strong class="bold">Breathe </strong><strong class="bold">Out</strong> labels</li>
<li><code>offsetBreath</code>: To move the breath from inside the flower to outside the flower</li>
<li><code>diffuseBreath</code>: To track the transformation of the smoke from a still image to an animation </li>
<li><code>breatheTheBouquet</code>: To keep track of the bouquet animation</li>
</ul>
<p>Before we put these variables<a id="_idIndexMarker425"/> to use, let’s head<a id="_idIndexMarker426"/> into the <code>body</code> property and add a winter image to the scene. First, create a <code>ZStack</code> in order to hold all of the views that we will be adding:</p>
<pre class="source-code">
var body: some View {
    ZStack {
        //MARK: - ADD A WINTER BACKGROUND - AND THE SNOW
        Image("winterNight").resizable()
          .aspectRatio(contentMode: .fill)
                            .frame(width: 400, height: 900)
       }
      }</pre>
<p>This is familiar code to us now. Here, we are using the <code>Image</code> initializer and passing in the background image called <code>winterNight</code>, which is in the assets catalog. Then, we are resizing the image and using the <code>aspectRatio</code> option of <code>fill</code> to take up the whole screen, before finally giving it some dimensions with the <code>frame</code> modifier. This is what the scene looks like:</p>
<div><div><img alt="Figure 8.1: The winterNight background " src="img/B18674_08_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: The winterNight background</p>
<p>Now that we<a id="_idIndexMarker427"/> have added the background to the<a id="_idIndexMarker428"/> scene, our next goal is to add some labels: <strong class="bold">Breathe In</strong> and <strong class="bold">Breathe Out</strong>. What we want to achieve here is to make the two labels grow and shrink at the same time as the flower petals open and close, so these labels will have the same duration and delay as the flower petals in the project, perfectly in sync.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor116"/>Animating the text labels</h1>
<p>Now, let’s add two labels that can act as a guide for the user to watch their breath. Still working in the <code>ZStack</code> and moving <a id="_idIndexMarker429"/>directly underneath the previous line of code, add another <code>ZStack</code>, and fill it with the following:</p>
<pre class="source-code">
//MARK: - ANIMATE TEXT LABELS SO THEY GROW AND SHRINK
  //a ZStack so we can offset the entire scene vertically
  ZStack {
     Group {
        Text("Breathe In")
             .font(Font.custom("papyrus", size: 35))
             .foregroundColor(Color(UIColor.green))
             .opacity(breatheInLabel ? 0 : 1)
             .scaleEffect(breatheInLabel ? 0 : 1)
             .offset(y: -160)
             .animation(Animation.easeInOut(duration: 
               2).delay(2).repeatForever(autoreverses: 
               true), value: breatheInLabel)
                 Text("Breathe Out")
             .font(Font.custom("papyrus", size: 35))
             .foregroundColor(Color(UIColor.orange))
             .opacity(breatheOutLabel ? 0 : 1)
             .scaleEffect(breatheOutLabel ? 0 : 1)
             .offset(y: -160)
             .animation(Animation.easeInOut(duration: 
               2).delay(2).repeatForever(autoreverses: 
               true),value: breatheOutLabel)
            }
         }</pre>
<p>Let’s dissect this code a little bit and see what we’re doing. First, we’re adding a second <code>ZStack</code>, then a group, to help keep the code organized.</p>
<p>Next, we use the <code>Text</code> initializer and type in whatever text we’d like to appear on the screen. In our case, we are typing in <code>Breathe In</code> and <code>Breathe Out</code>, and just like that, we have text on the <a id="_idIndexMarker430"/>screen. Then, using the <code>font</code> modifier, you can change the font to one of your choosing. Xcode comes with many built-in fonts, and I am using one called <code>papyrus</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you’d like to know the names of the fonts that you can use for iOS, you can go to the following website: <a href="https://developer.apple.com/fonts/system-fonts/">https://developer.apple.com/fonts/system-fonts/</a>.</p>
<p>As well as choosing the specific font type, we set the font <code>size</code> parameter to <code>35</code>, and use the <code>foregroundColor</code> modifier to make the <strong class="bold">Breathe In</strong> label green and the <strong class="bold">Breathe Out</strong> label orange.</p>
<p>Next, the opacity of the text labels is animated here by using the <code>breatheIn</code> and <code>breatheOut</code> variables. When those variables are <code>true</code>, their opacity will be set to <code>0</code>, which makes the label text invisible. But when the <code>breatheIn</code> and <code>breatheOut</code> variables are <code>false</code>, the text will be set to <code>1</code>, and they will become visible again.</p>
<p>After that, we set the size of the two text labels by using the <code>scaleEffect</code> modifier. We’re using a ternary operator, which checks whether the <code>breatheIn</code> and <code>breatheOut</code> variables are <code>true</code> or not; if so, then we will scale the labels down to <code>0</code>; otherwise, when the <code>breatheIn</code> and <code>breatheOut</code> variables are <code>true</code>, we will scale the text labels back up to full size, which is <code>35</code> points.</p>
<p>The next line of code positions the label on the screen for the <code>y</code> axis, using the <code>offset</code> modifier. Remember, the <em class="italic">y</em> axis position views vertically.</p>
<p>Lastly, we add the <code>animation</code> modifier. The animation will start as it usually does when the <code>breatheIn</code> and <code>breatheOut</code> variables become <code>true</code>. The animation will have a duration of 2 seconds, which means it will take 2 seconds to complete, and then it will have a delay of 2 seconds before starting again.</p>
<p>And that completes the animation of the <code>onAppear</code> modifier right after the closing brace of the first <code>ZStack</code>:</p>
<pre class="source-code">
   .onAppear {
                breatheInLabel.toggle()
                breatheOutLabel.toggle()
            }</pre>
<p>As we’ve seen, <code>onAppear</code> will run the code in its body when the view first appears – that is, when the user taps on the app<a id="_idIndexMarker431"/> to open it. The code we want to run is the <code>breatheIn</code> and <code>breatheOut</code> variables; we want to toggle them to their opposite Boolean value to start the animation.</p>
<p>When you run this code in the previews or the simulator, you’ll see two labels, each with its own color, scaling up and scaling down, and at the same time, fading in and out:</p>
<div><div><img alt="Figure 8.2: The Breathe In and Breathe Out labels added " src="img/B18674_08_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: The Breathe In and Breathe Out labels added</p>
<p>That completes the labels. Now, let’s focus <a id="_idIndexMarker432"/>our attention on making an image that looks like vapor to represent breath.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor117"/>Using the blur modifier to create a vapor effect</h1>
<p>In this part of<a id="_idIndexMarker433"/> the project, we will be using the <code>blur</code> modifier, which will apply a Gaussian blur to an image using a radius value that we specify. If you’re not familiar with what a Gaussian blur is, this is a technique that is widely used in image editing software (such as Photoshop) and works by reducing the noise and detail of an image to create a smooth blurring visual effect. </p>
<p>We will use an image of smoke, called <code>breath</code> (which is in the Assets catalog), and apply the <code>blur</code> modifier to it, which will create a vapor effect and make our flower look like it’s breathing.</p>
<p>There is very little code needed to achieve this effect. Coming out of the previous group we made, let’s make a new group and add the following code:</p>
<pre class="source-code">
//MARK: - TAKE AN IMAGE AND CONVERT IT TO VAPOR (BREATH)
  USING THE BLUR MODIFIER
      Group {
          Image("breath").resizable().frame(width: 35,
            height: 125)
              .offset(y: offsetBreath ? 90 : 0)
              .animation(Animation.easeInOut(duration:
                2).delay(2).repeatForever(autoreverses:
                true),value: offsetBreath)
              .blur(radius: diffuseBreath ? 1 : 60)
              .offset(x: 0, y: diffuseBreath ? -50 : -100)
              .animation(Animation.easeInOut(duration:
                2).delay(2).repeatForever(autoreverses:
                true), value: showBreath)
      }.shadow(radius: showBreath ? 20 : 0)
           </pre>
<p>In the group, we use the <code>Image</code> initializer and pass in the image we want to use, <code>breath</code>. Then, we give it some dimensions, with a width of <code>35</code> and a height of <code>125</code>. </p>
<p>After that, the code offsets the<a id="_idIndexMarker434"/> image vertically on the <em class="italic">y</em> axis. Then, when the <code>offsetBreath</code> variable becomes <code>true</code>, the image moves <code>90</code> points up, so it’s coming out of the flower, and when <code>offsetBreath</code> is <code>false</code>, the image moves back down and is set back to <code>0</code>.</p>
<p>Next, we add the animation to the image and to the <code>offset</code> modifier (yes, we can animate an <code>offset</code> modifier too!). We are using the same <code>duration</code> and <code>delay</code> values as the text labels (2 seconds, respectively) so that the labels and vapor animate in sync.</p>
<p>The next line is the <code>blur</code> modifier – this is what creates the magic of turning the image into a puff of vapor. This modifier has a parameter called <code>radius</code>, which accepts any integer number; the smaller the number, the less Gaussian blur is applied to the image, whereas the larger the number, the more blurred the image becomes. The ternary operator oversees the setting of the <code>radius</code> value to either <code>1</code> or <code>60</code>, so depending on whether the <code>diffuseBreath</code> variable is <code>true</code> or <code>false</code>, we can control the amount of Gaussian blur on the image. When <code>diffuseBreath</code> becomes <code>true</code>, the image gets blurred by only <code>1</code> point, but when <code>diffuseBreath</code> becomes <code>false</code>, the code will add <code>60</code> points of Gaussian blur to the image.</p>
<p>Let’s look at the next line of<a id="_idIndexMarker435"/> code – this is the <code>offset</code> modifier and is responsible for positioning the blur. We want to offset the smoke so it moves from inside the flower to outside the flower. This is accomplished by checking the <code>diffuseBreath</code> variable; when it’s <code>true</code>, the vapor moves <code>50</code> points up, and when it’s <code>false</code>, the vapor moves <code>100</code> points down.</p>
<p>After that, the <code>animation</code> modifier will interpolate through all the Gaussian blur values, from <code>1</code> to <code>60</code>. In this interpolation (or looping, if you will), these values will act on the image very quickly, so fast that the non-moving still image of smoke will be transformed into an actual animation of smoke that will move up and disperse, as real smoke does.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may also have noticed that we are using two <code>animation</code> modifiers here. The reason for this is that the first one is placed right after the <code>offset</code> modifier, so it is being used to animate the offset of the image up and down; any code we add <em class="italic">after</em> that <code>animation</code> modifier will not be animated, hence the use of the second <code>animation</code> modifier. The second one is used to animate the <code>blur</code> modifier to make smoke and to animate the offset that moves the smoke. So remember, the <code>animation</code> modifiers act on the views above them, but if we need to add more of them, we can just add them as needed to animate any subsequent views, as we have done here.</p>
<p>Lastly, we add the <code>shadow</code> modifier, which will add a subtle shadow of <code>20</code> points around the moving breath when it exits the flower.</p>
<p>Now, to see the smoke<a id="_idIndexMarker436"/> transformation, add the <code>offsetBreath</code> and <code>diffuseBreath</code> variables to the <code>onAppear</code> modifier, like this:</p>
<pre class="source-code">
   .onAppear {
                breatheInLabel.toggle()
                breatheOutLabel.toggle()
                offsetBreath.toggle()
                diffuseBreath.toggle()
            }</pre>
<p>This is what we can see:</p>
<div><div><img alt="Figure 8.3: The smoke in our animation " src="img/B18674_08_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: The smoke in our animation</p>
<p>As the animation starts out, the image of smoke is only being blurred by <code>1</code> point, but as the <code>offset</code> modifier moves the image upward, the blurring increases all the way to <code>60</code> points. At <code>60</code> points, the once still image has now been transformed into smoke, mimicking a breath. </p>
<p>As an aside, something<a id="_idIndexMarker437"/> interesting to check out later is that if you want to see the process of the smoke image turning into moving vapor at any time, then add this line of code beneath the <code>shadow</code> modifier:</p>
<pre class="source-code">
 .zIndex(1)</pre>
<p>This will move the smoke image to the front of the scene, and you will see it being transformed into moving vapor.</p>
<p>With the vapor effect added, we can move on to the next step, which is adding the bouquet of flowers to the image.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor118"/>Animating flower petals in an arc</h1>
<p>We have a background, text labels, and <a id="_idIndexMarker438"/>an inhaling and exhaling breath effect; now let’s add the petals to the scene. We can add the petal code in a separate file, so press <em class="italic">Command</em> + <em class="italic">N</em> to bring up the <code>PetalView</code>.</p>
<p>The goal here is to make five petals move in an arc, so they open and close. We only need two variables for this, so this will be a very small file: we need one Boolean (<code>Bool</code>) variable to track the animation, and another variable to hold the number of rotations we want for each petal. Let’s add them now:</p>
<pre class="source-code">
    @Binding var petal: Bool
    var degrees: Double = 0.0</pre>
<p>The <code>Binding</code> variable called <code>petal</code> will handle the animation. We are using the <code>Binding</code> wrapper because we are in a new struct, and we will need to use this variable in another struct, <code>ContentView</code>. When we prefix a variable with the <code>Binding</code> wrapper, we can then use it (bind it) to another struct or view.</p>
<p>Let’s now move into the <code>body</code> property and create a petal. Add the following code:</p>
<pre class="source-code">
struct PetalView: View {
  var body: some View {
      Image("petal").resizable().frame(width: 75, height:
        125)
          .rotationEffect(.degrees(petal ? degrees :
            degrees), anchor: .bottom)
          .animation(Animation.easeInOut(duration: 
            2).delay(2).repeatForever(autoreverses: true),
            value: petal)
  }
}</pre>
<p>There are only three<a id="_idIndexMarker439"/> lines of code to look at: </p>
<ul>
<li>First, we add the petal image from the Assets Catalog to the scene and appropriately size it.</li>
<li>Next, we use the <code>rotationEffect</code> modifier to open and close the petal by choosing between two <code>degree</code> values: one value for the petal opening and one for its closing. We also anchor the rotation point to the bottom of the petal, so the petals will open and close in an arc.</li>
<li>Then, we simply call the <code>animation</code> modifier to add the animation. Again, we continue to keep <code>duration</code> and <code>delay</code> at <code>2</code> seconds and set <code>autoreverses</code> to <code>true</code>.</li>
</ul>
<p>To see the petal image in the previews, let’s modify the <code>previews</code> struct to look like this:</p>
<pre class="source-code">
struct PetalView_Previews: PreviewProvider {
    static var previews: some View {
        PetalView(petal: .constant(true))
    }
}</pre>
<p>The only change in the <code>PetalView_Previews</code> struct is that we use the <code>petal</code> parameter and pass in the value of <code>.constant(true)</code>. This turns the <code>petal</code> variable to <code>true</code>, enabling the previews to display the contents of the <code>PetalsView</code> struct.</p>
<p>Let’s now<a id="_idIndexMarker440"/> move back into <code>ContentView</code>, and call this new <code>PetalView</code> struct five times to display all five petals:</p>
<pre class="source-code">
//MARK: - ANIMATE FLOWER PETALS IN AN ARC
    Group {
        PetalView(petal: $petal, degrees: petal ? -25 : -5)
        ///middle petal does not move
        Image("petal").resizable().frame(width: 75, height:
          125)
        PetalView(petal: $petal, degrees: petal ? 25 : 5)
        PetalView(petal: $petal, degrees: petal ? -50 :
          -10)
        PetalView(petal: $petal, degrees: petal ? 50 : 10)
    }</pre>
<p>The code calls <code>PetalView</code> four times to add four petals to the UI, and then the fifth petal (the middle one) is added by a call to the <code>Image</code> initializer, as this petal will not be animated. The result is shown here:</p>
<div><div><img alt="Figure 8.4: The petals  " src="img/B18674_08_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4: The petals </p>
<p>Notice the dollar sign syntax (<code>$</code>) for the <code>petal</code> parameter: that is how we use the <code>Binding</code> variable in <a id="_idIndexMarker441"/>another struct. In the <code>degrees</code> parameter, we have two values: again, one for when the petal is open, and one for when it is closed. When the binding <code>$petal</code> property is <code>true</code>, the <code>degrees</code> value on the left is used, and when the <code>$petal</code> property is <code>false</code>, the <code>degrees</code> value on the right will be used.</p>
<p>Again, the middle petal will not be animated, so we only need to call the <code>Image</code> initializer and then set its size. The remaining petals use the same code; the only changes are the values for the <code>degrees</code> parameters.</p>
<p>And that completes the petals. Let’s see how they animate by toggling the <code>petal</code> variable in the <code>onAppear</code> method, as we have done with the other variables:</p>
<pre class="source-code">
.onAppear {
            petal.toggle()
            breatheInLabel.toggle()
            breatheOutLabel.toggle()
            offsetBreath.toggle()
            diffuseBreath.toggle()
        }</pre>
<p>The petals open and<a id="_idIndexMarker442"/> close as we have set them up – to a specific point, rotating in an arc, and then closing again:</p>
<div><div><img alt="Figure 8.5: The petals animated " src="img/B18674_08_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5: The petals animated</p>
<p>There are three components left to add to our project:</p>
<ul>
<li>A bouquet of flowers positioned directly over the petals</li>
<li>The moving breath surrounding the flowers </li>
<li>Snow falling in the background</li>
</ul>
<p>In the next section, we<a id="_idIndexMarker443"/> will implement the first two points: adding the bouquet and the moving breath.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor119"/>Adding the flower bouquet and the animated breath</h1>
<p>Adding the first <a id="_idIndexMarker444"/>component, the bouquet, is relatively easy, as it is stuff we have already done; however, the second component, the moving breath, is a little tricky (but not to worry, we<a id="_idIndexMarker445"/> will go slow and everything will be explained).</p>
<p>So, first up, the bouquet. In <code>ContentView</code>, after the petal group’s closing brace, add the following code:</p>
<pre class="source-code">
 //MARK: - ADD A BOUQUET OF FLOWERS AND MAKE THEM EXPAND 
   AND CONTRACT SO THEY APPEAR TO BE BREATHING 
    Group {
      Image("bouquet").resizable()
      .aspectRatio(contentMode: .fit)
            .frame(width: 300, height: 400)
            .rotationEffect(.degrees(37))
            .offset(x: -25, y: 90)
        ///breathe the bottom bouquet 1
            .scaleEffect(breathTheBouquet ? 1.04 : 1,
              anchor: .center)
            .hueRotation(Angle(degrees: breatheTheBouquet ?
              50 : 360))
            .animation(Animation.easeInOut(duration: 
              2).delay(2).repeatForever(autoreverses: 
              true), value: breatheTheBouquet)
        
      Image("bouquet").resizable()
        .aspectRatio(contentMode: .fit)
            .frame(width: 300, height: 400)
            .rotationEffect(.degrees(32))
            .offset(x: -20, y: 95)
            .rotation3DEffect(.degrees(180), axis: (x: 0, 
              y: 1, z: 0))
        ///breathe the bottom bouquet 2
            .scaleEffect(breatheTheBouquet ? 1.02 : 1, 
              anchor: .center)
            .hueRotation(Angle(degrees: breatheTheBouquet ? 
              -50 : 300))
            .animation(Animation.easeInOut(duration: 
              2).delay(2).repeatForever(autoreverses: 
              true), value: breatheTheBouquet)
    }</pre>
<p>This looks like a lot of <a id="_idIndexMarker446"/>code, but really, we are creating two bouquets using very similar code. The reason <a id="_idIndexMarker447"/>why I’m using two bouquets and overlapping them is to create the illusion of a full bunch of flowers.</p>
<p>Let’s now look at the code. We start with the grouping organizational feature, and inside the group, we add the image for both bouquets. I’m setting the aspect ratio to <code>fit</code>, so the bouquet image keeps its proportional size, and framing the image with a value of <code>300</code> x <code>400</code>.</p>
<p>Next, we call the <code>rotation</code> modifier on each bouquet, so we can rotate them to the proper angle we want in the scene; a <code>37</code>-degree rotation for the first bouquet looks good, whereas <code>32</code> degrees for<a id="_idIndexMarker448"/> the second bouquet works better for that one. Then, each bouquet gets offset a<a id="_idIndexMarker449"/> little bit on the <code>x</code> and <code>y</code> axes, so they’re neatly positioned directly over the breath. This location will help hide the breath, as we don’t want to see that until it animates up from the bouquet.</p>
<p>The next line scales the bouquets up a little. The reason for this is that we want to create the effect that the bouquets are breathing as well, along with the petals. The top bouquet gets scaled up to <code>1.04</code>, and the bottom bouquet gets scaled to <code>1.02</code>. Notice the top bouquet gets scaled up slightly more than the bottom bouquet: this is because we wanted to stagger the two bouquets a little. </p>
<p>Then, <code>anchor</code> is set to <code>center</code>, so the two bouquets will expand and contract from that point.</p>
<p>The next line adds some hue rotation to the color of the bouquets so that they will change color along with the animation. We previously used the <code>hueRotation</code> modifier in <a href="B18674_05.xhtml#_idTextAnchor073"><em class="italic">Chapter 5</em></a>, so that’s nothing new here, but we are using different values for <code>hueRotation</code> to help make the bouquets more varied in appearance.</p>
<p>Also notice that we use the <code>rotation3DEffect</code> modifier only on the bottom bouquet. This is because the bouquet image for the top and bottom are identical; they are simply one image that we’re using in two places, so by using the <code>rotation3DEffect</code> modifier here and passing in a value of <code>1</code> for the <code>y</code> parameter, this will flip the bouquet image on the <em class="italic">y</em> axis to the bouquet’s opposite side. This helps give the overall look a more symmetrical appearance.</p>
<p>Finally, we add the animation for both bouquets; this is the same animation as we’ve done for the previous views, with a 2-second duration and a 2-second delay, so all the animations are in sync.</p>
<p>Now, in order to see this animation in action, once again, we need to add the animating variable in charge of the bouquet to the <code>onAppear</code> modifier. So, add the following code to the <code>onAppear</code> modifier:</p>
<pre class="source-code">
}.onAppear {
            breatheInLabel.toggle()
            breatheOutLabel.toggle()
            offsetBreath.toggle()
            diffuseBreath.toggle()
            petal.toggle()
            breatheTheBouquet.toggle()
        }</pre>
<p>Now, if we run the app, we<a id="_idIndexMarker450"/> will see the two bouquets expanding and contracting <a id="_idIndexMarker451"/>slightly, along with the petals moving too. You will also see the bouquets’ colors changing, which is due to the <code>hueRotation</code> modifier we used.</p>
<div><div><img alt="Figure 8.6: The bouquet moving " src="img/B18674_08_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6: The bouquet moving</p>
<p>The bouquet expanding and contracting is a subtle look (it’s not pronounced like the petals opening and closing), which is the look we’re going for here; we just want to create a slight expanding<a id="_idIndexMarker452"/> effect.</p>
<p>With that done and <a id="_idIndexMarker453"/>our app already looking really good, we just need to add one more component to the project: snow.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor120"/>Creating falling snow in the scene</h1>
<p>Making snow fall within <a id="_idIndexMarker454"/>your app really makes it come alive: it gives a rather magical look to it and sets the right mood for our winter scene. To <a id="_idIndexMarker455"/>do this, we need to utilize the power of UIKit and the <code>UIViewRepresentable</code> protocol, along with the <code>CAEmitter</code> class. </p>
<p class="callout-heading">Note</p>
<p class="callout">As you continue through the rest of this chapter, don’t worry if some of the UIKit classes and methods look different or unfamiliar to you as compared to the SwiftUI classes and methods we’ve been using. That’s because they <em class="italic">are</em> different, and that’s for a whole different book if you’d like to learn about UIKit. However, moving forward in this chapter, I will explain the different UIKit properties and methods used to make the snow for our animation, so you can get familiar with the process.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Adding the UIViewRepresentable protocol</h2>
<p>The <code>UIViewRepresentable</code> protocol is <a id="_idIndexMarker456"/>what’s called a <strong class="bold">wrapper</strong> for UIKit. It allows SwiftUI to work with UIKit and use UIKits classes<a id="_idIndexMarker457"/> and methods. If you’ve ever coded with UIKit, you’ll know it’s quite different compared to SwiftUI. For one thing, it uses something called <strong class="bold">Storyboards</strong>, which are<a id="_idIndexMarker458"/> a different way to design your layout and organize your views by way of dragging and dropping objects from an object library, such as buttons and sliders and text, and connecting them together on a big storyboard in Xcode. The positioning of all those objects is completely different as well and <a id="_idIndexMarker459"/>uses a system called <strong class="bold">Auto Layout</strong>, which is a system of methods and rules to keep your objects spaced apart and located on the screen, but it was very complicated and had a big learning curve. </p>
<p>SwiftUI eliminates Storyboards and Auto Layout and is a complete departure from UIKit in how you design and build apps. It’s simpler and uses much less code to achieve the same results (as you probably already know). But, occasionally, we need to access some of the methods and classes that UIKit offers in order to do different things in our apps – for example, here, to make snow. That’s why we need the <code>UIViewRepresentable</code> protocol.</p>
<p>The <code>UIViewRepresentable</code> protocol acts as a bridge between these two different frameworks, UIKit and SwiftUI, and lets us access the classes and methods we need. </p>
<p>So, let’s create a new file to<a id="_idIndexMarker460"/> contain the snow code. Press <em class="italic">Command</em> + <em class="italic">N</em> and create a SwiftUIView file called <code>SnowView</code>. Then, at the top of the struct, we will modify its heading to make it conform to the <code>UIViewRepresentable</code> protocol. So, change the struct’s heading to this:</p>
<pre class="source-code">
//MARK: - CREATE SNOW FALLING ON THE SCENE
struct SnowView: UIViewRepresentable { 
         }</pre>
<p>When we add the <code>UIViewRepresentable</code> protocol to the struct’s heading (right after the colon), this tells the system that we are now allowed to use the classes and methods from the UIKit framework. It also means we have to implement the required methods for this protocol. Some protocols only need you to declare them into a struct heading, as we have just done, but others also need you to implement some methods in order to satisfy the protocol requirements.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Dealing with methods and errors</h2>
<p><code>UIViewRepresentable</code> requires that we add two methods to the struct: <code>makeUIView</code> and <code>updateView</code>. But<a id="_idIndexMarker461"/> because we haven’t added those methods yet, the change we just made will break our code and display an error: <strong class="bold">SnowView does not conform to protocol UIViewRepresentable</strong>. That is true because, as mentioned, we need to implement two methods to satisfy this protocol.</p>
<p>So, let’s add the first method now, <code>makeUIView</code>, by adding the following code to the <code>SnowView</code> struct:</p>
<pre class="source-code">
func makeUIView(context: Context) -&gt; some UIView {
    }</pre>
<p>The <code>makeUIView</code> method returns <code>UIView</code>, which will contain the snow, so we can use it in the <code>ContentView</code> later.</p>
<p>The second method we <a id="_idIndexMarker462"/>need to add is called <code>updateView</code>, which we can do directly under the previous method:</p>
<pre class="source-code">
func updateUIView(_ uiView: UIViewType, context: Context) {
    }</pre>
<p>This method is used when we want to update the view with new data. Since we don’t need to do any updating when the snow is made, we can leave this method empty. However, it’s a required method so it does have to be here in the <code>SnowView</code> struct; otherwise, the code won’t work.</p>
<p>Now that we have the two required methods, the protocol should be satisfied. However, we still get an error: <code>makeUIView</code> method and the fact that it has no return code in its body. The <code>makeUIView</code> method needs to return <code>UIView</code> (or simply, a view) in order for the error to go away. So, let’s fill out the <code>makeUIView</code> method with the code that will return a view, which will, in turn, make our snow.</p>
<p>First, we need to set up the size of the view to fit the screen correctly. Remember, we are making a new view using UIKit’s classes and methods, so we have to tell it how big the screen dimensions should be for this view. Add the following code to the <code>makeUIView</code> method:</p>
<pre class="source-code">
    func makeUIView(context: Context) -&gt; some UIView {
    //configure the screen
            let screen = UIScreen.main.bounds
            let view = UIView(frame: CGRect(x: 0, y: 0, 
              width: screen.width, height: screen.height))
            view.layer.masksToBounds = true
        }</pre>
<p>The first line of code creates a constant that will hold the bounds of the screen – that’s the rectangle of the screen from top to bottom and left to right.</p>
<p>The second line of code creates the view that we will need to return when we finish writing this method out. We’re setting the view to the size of the screen’s width and height so that when we <a id="_idIndexMarker463"/>make the snow, we’re using the entire boundaries of the iPhone screen, not just a little portion of it.</p>
<p>The next line of code uses the <code>masksToBounds</code> Boolean property and sets it to <code>true</code>. The <code>masksToBounds</code> property indicates to the system whether sublayers are clipped to the layer’s bounds.</p>
<p><code>ZStack</code>, each view you place inside it gets stacked upon the previous view.</p>
<p>So with all this stacking up of views, there may be parts of a view that you may not want to show, and other parts of that same view you do want to show. The <code>maskToBounds</code> property will clip any subviews to the bounds of the screen, which is helpful because we only want the snow to fall within the size of the screen; we don’t want any snow in any surrounding areas off the screen, only within the bounds of the screen, so we set this property to <code>true</code> to clip off any excess.</p>
<p>Now, we need to return a view in order to silence this error. Remember, the <code>makeUIView</code> method has a <code>return</code> statement in its declaration, so add the following code at the end of our previous code:</p>
<pre class="source-code">
func makeUIView(context: Context) -&gt; some UIView {
    //configure the screen
            let screen = UIScreen.main.bounds
            let view = UIView(frame: CGRect(x: 0, y: 0, 
              width: screen.width, height: screen.height))
            view.layer.masksToBounds = true
    
    return view
  }</pre>
<p>Now, we have our screen size set up, we are returning a view, and we are error-free! The next task is to create <a id="_idIndexMarker465"/>the snow, which we can do by using UIKit’s <code>CAEmitter</code> class. </p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>Adding the CAEmitter class</h2>
<p><strong class="bold">CAEmitter</strong> (which stands for <strong class="bold">Core Animation Emitter</strong>) is a class<a id="_idIndexMarker466"/> that has methods and properties that let us<a id="_idIndexMarker467"/> emit, animate, and<a id="_idIndexMarker468"/> render particle systems. </p>
<p>So what’s a particle system? A particle system is just what it sounds like: a system that can produce hundreds or thousands of little particles on the iPhone screen, in any size that we want, moving at any speed that we set, and in any shape that we design. </p>
<p>The particle shape that we want has already been designed because we will be using the <code>snowflake</code> image that we will drop into the assets catalog. However, we have to design how many snowflakes to make, how fast to make them move, how long to keep them on the screen, and the location on the screen from which they are made.</p>
<p>So, let’s go ahead and create an <code>emitter</code> instance, using the <code>CAEmitter</code> class. Add the following code just underneath the <code>masksToBounds</code> line of code:</p>
<pre class="source-code">
   //configure the emitter
    let emitter = CAEmitterLayer()
    emitter.frame = CGRect(x: 200, y: -100, width: 
      view.frame.width, height: view.frame.height)</pre>
<p>The first line creates the <code>emitter</code> instance using the <code>CAEmitter</code> class.</p>
<p>The next line sets the location and size of the emitter. Here, we are locating the emitter <code>200</code> points along the <code>x</code> axis, which is about the middle of the iPhone screen, and <code>-100</code> points along the <code>y</code> axis. This puts the emitter 100 points up and off from the iPhone screen. We put the emitter above the visible portion of the screen because we don’t want to see the snowflakes being created, we just want to see them falling.</p>
<p>As for the size of the emitter, we’re making it the exact size as the iPhone screen, which means using the <code>frame.width</code> and <code>frame.height</code> values.</p>
<p>Now that we’ve designed our emitter, let’s design the cell. To explain the difference between these two terms, think of the <strong class="bold">emitter</strong> as a<a id="_idIndexMarker469"/> box that holds thousands of confetti particles, and each of<a id="_idIndexMarker470"/> those confetti <a id="_idIndexMarker471"/>particles is a <strong class="bold">cell</strong>. In our case, our cell will be a snowflake. </p>
<p>To add our cell and make it move on screen, add the following code just under the emitter code:</p>
<pre class="source-code">
        //configure the cell
        let cell = CAEmitterCell()
        cell.birthRate = 40
        cell.lifetime = 25
        cell.velocity = 60
        cell.scale = 0.025
        cell.emissionRange = CGFloat.pi
        cell.contents = UIImage(named: "snow")?.cgImage
        emitter.emitterCells = [cell]
        view.layer.addSublayer(emitter)</pre>
<p>Here, we created the <code>cell</code> instance using the <code>CAEmitterCell</code> class and loaded it up with different properties. The following is a list of what these properties do:</p>
<ul>
<li><code>birthRate</code>: How fast each cell or particle will be made. Using a value of <code>40</code> mimics a gentle snowfall.</li>
<li><code>lifetime</code>: How long to keep the cell on the screen before it’s removed. Using a value of <code>25</code> ensures that each snowflake stays on the screen long enough to make it to the bottom of the screen.</li>
<li><code>velocity</code>: How fast we want the cell to move on the screen. We’re using a value of <code>60</code>, which is a speed that’s not too fast or too slow for the snowflake.</li>
<li><code>scale</code>: How big we want to make each cell. A value of <code>.025</code> is a nice size for the snowflake, as it’s not too big or too small for an iPhone.</li>
<li><code>emissionRange</code>: How far we want to spread out the cells as they are being emitted. For this value, we are using a mathematical expression called Pi (often shown as the symbol π), which is defined as the circumference of a circle divided by the diameter of the same circle. Without getting too mathematical here, the <code>CGFloat.pi</code> value equals <code>180</code> degrees – imagine a horizontal line drawn from the left to the right side of the phone screen; the value sets the snow to fall evenly from all areas of that line.</li>
<li><code>contents</code>: Sets the <a id="_idIndexMarker472"/>contents of the cell to an image of our choice, which was set as the <code>snow</code> image (make sure that you’ve added the image into the Assets Catalog so it can be accessed with this line of code).</li>
<li><code>emitterCells</code>: The cell particles that will become the snow.</li>
<li><code>addSublayer</code>: Adds a new layer to the scene. Remember that in SwiftUI, a layer is very similar to a view, and everything is a view in SwiftUI (buttons, text, colors, and more). In the UIKit world, a layer can also be thought of as a view – when the <code>addSublayer</code> function is called, it will add whatever layer is in its parameter to the scene.</li>
</ul>
<p>As always, these cell configuration values are completely arbitrary, so go ahead and experiment and make the snowflakes as big as you want, design them how you want, and make them move on the screen according to what you want them to do. There are no hard and fast rules when adding values into a cell; it’s all about experimenting and having fun.</p>
<p>And with that, we have completed the snow file. If you want to test the result, you can click <strong class="bold">Play</strong>; however, as the default background of the preview is white, you won’t see our white snow. You can change this by swapping the background color, like so:</p>
<pre class="source-code">
struct SnowView_Previews: PreviewProvider {
    static var previews: some View {
        SnowView()
            .background(Color.black)
    }
}</pre>
<p>That will change the background color to black so you can see the snow; however, as we know, we will be using a winter background for the final animation.</p>
<p>So, to finish things off, we <a id="_idIndexMarker473"/>need to call this <code>SnowView</code> file inside <code>ContentView</code>. To do that, head back to <code>ContentView</code> and add this final line of code right under the background code:</p>
<pre class="source-code">
//MARK: - ADD A WINTER BACKGROUND - AND THE SNOW
  Image("winterNight").resizable().aspectRatio(contentMode: 
    .fill).frame(width: 400, height: 900)
  SnowView()</pre>
<p>And that completes the project. You can now go ahead and run it:</p>
<div><div><img alt="Figure 8.7: The finished project " src="img/B18674_08_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7: The finished project</p>
<p>The project has a<a id="_idIndexMarker474"/> breathing label animation, a breathing petal animation, a breathing bouquet animation, and a snow animation.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor124"/>Summary</h1>
<p>In this project, we created the illusion of a bouquet of flowers breathing by using a collection of coding modifiers: we used <code>blur</code> to create the illusion of smoke, and <code>scale</code> and <code>rotationEffect</code> to make the flowers expand and contract in an arc, and we also added labels on the screen. On top of this, we used the <code>UIViewRepresentable</code> protocol and the <code>CAEmitter</code> class, and incorporated particle systems to create falling snow.</p>
<p>Here are some extra thoughts on how to take this app further, or just practice adding some more features, to help stretch your skills with SwiftUI animations. How about adding some sound to the project? We did that in <a href="B18674_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a> with the Record Player project, and it’s very easy to do – you could add some guided voice narration that simply says “breathe in, breathe out” or some meditative music. </p>
<p>Or how about adding a button or slider that will change the speed of the animation? Maybe you want to increase the petal opening and closing speed. If you’re not sure how to do that, keep following along in the book because, later, we will build a color game with a UI that uses buttons and sliders.</p>
<p>Let’s continue to the next chapter, where we will see how to animate a <code>stroke</code> modifier so it creates a moving line around any shape.</p>
</div>
<div><div></div>
</div>
</body></html>