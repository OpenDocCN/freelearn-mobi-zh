["```swift\n@implementation Ch1_DrawingSprites\n-(CCLayer*) runRecipe {\n/*** Draw a sprite using CCSprite ***/\nCCSprite *tree1 = [CCSprite spriteWithFile:@\"tree.png\"];\n//Position the sprite using the tree base as a guide (y anchor point = 0)\n[tree1 setPosition:ccp(20,20)];\ntree1.anchorPoint = ccp(0.5f,0);\n[tree1 setScale:1.5f];\n[self addChild:tree1 z:2 tag:TAG_TREE_SPRITE_1];\n/*** Load a set of spriteframes from a PLIST file and draw one by name ***/\n//Get the sprite frame cache singleton\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n//Load our scene sprites from a spritesheet\n[cache addSpriteFramesWithFile:@\"alice_scene_sheet.plist\"];\n//Specify the sprite frame and load it into a CCSprite\nCCSprite *alice = [CCSprite spriteWithSpriteFrameName:@\"alice.png\"];\n//Generate Mip Maps for the sprite\n[alice.texture generateMipmap];\nccTexParams texParams = { GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE };\n[alice.texture setTexParameters:&texParams];\n//Set other information.\n[alice setPosition:ccp(120,20)];\n[alice setScale:0.4f];\nalice.anchorPoint = ccp(0.5f,0);\n//Add Alice with a zOrder of 2 so she appears in front of other sprites\n[self addChild:alice z:2 tag:TAG_ALICE_SPRITE];\n//Make Alice grow and shrink.\n[alice runAction: [CCRepeatForever actionWithAction:\n[CCSequence actions:[CCScaleTo actionWithDuration:4.0f scale:0.7f], [CCScaleTo actionWithDuration:4.0f scale:0.1f], nil] ] ];\n/*** Draw a sprite CGImageRef ***/\nUIImage *uiImage = [UIImage imageNamed: @\"cheshire_cat.png\"];\nCGImageRef imageRef = [uiImage CGImage];\nCCSprite *cat = [CCSprite spriteWithCGImage:imageRef key:@\"cheshire_cat.png\"];\n[cat setPosition:ccp(250,180)];\n[cat setScale:0.4f];\n[self addChild:cat z:3 tag:TAG_CAT_SPRITE];\n/*** Draw a sprite using CCTexture2D ***/\nCCTexture2D *texture = [[CCTextureCache sharedTextureCache] addImage:@\"tree.png\"];\nCCSprite *tree2 = [CCSprite spriteWithTexture:texture];\n[tree2 setPosition:ccp(300,20)];\ntree2.anchorPoint = ccp(0.5f,0);\n[tree2 setScale:2.0f];\n[self addChild:tree2 z:2 tag:TAG_TREE_SPRITE_2];\n/*** Draw a sprite using CCSpriteFrameCache and CCTexture2D ***/\nCCSpriteFrame *frame = [CCSpriteFrame frameWithTexture:texture rect:tree2.textureRect];\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFrame:frame name:@\"tree.png\"];\nCCSprite *tree3 = [CCSprite spriteWithSpriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@\"tree.png\"]];\n[tree3 setPosition:ccp(400,20)];\ntree3.anchorPoint = ccp(0.5f,0);\n[tree3 setScale:1.25f];\n[self addChild:tree3 z:2 tag:TAG_TREE_SPRITE_3];\n/*** Draw sprites using CCBatchSpriteNode ***/\n//Clouds\nCCSpriteBatchNode *cloudBatch = [CCSpriteBatchNode batchNodeWithFile:@\"cloud_01.png\" capacity:10];\n[self addChild:cloudBatch z:1 tag:TAG_CLOUD_BATCH];\nfor(int x=0; x<10; x++){\nCCSprite *s = [CCSprite spriteWithBatchNode:cloudBatch rect:CGRectMake(0,0,64,64)];\n[s setOpacity:100];\n[cloudBatch addChild:s];\n[s setPosition:ccp(arc4random()%500-50, arc4random()%150+200)];\n}\n//Middleground Grass\nint capacity = 10;\nCCSpriteBatchNode *grassBatch1 = [CCSpriteBatchNode batchNodeWithFile:@\"grass_01.png\" capacity:capacity];\n[self addChild:grassBatch1 z:1 tag:TAG_GRASS_BATCH_1];\nfor(int x=0; x<capacity; x++){\nCCSprite *s = [CCSprite spriteWithBatchNode:grassBatch1 rect:CGRectMake(0,0,64,64)];\n[s setOpacity:255];\n[grassBatch1 addChild:s];\n[s setPosition:ccp(arc4random()%500-50, arc4random()%20+70)];\n}\n//Foreground Grass\nCCSpriteBatchNode *grassBatch2 = [CCSpriteBatchNode batchNodeWithFile:@\"grass_01.png\" capacity:10];\n[self addChild:grassBatch2 z:3 tag:TAG_GRASS_BATCH_2];\nfor(int x=0; x<30; x++){\nCCSprite *s = [CCSprite spriteWithBatchNode:grassBatch2 rect:CGRectMake(0,0,64,64)];\n[s setOpacity:255];\n[grassBatch2 addChild:s];\n[s setPosition:ccp(arc4random()%500-50, arc4random()%40-10)];\n}\n/*** Draw colored rectangles using a 1px x 1px white texture ***/\n//Draw the sky using blank.png\n[self drawColoredSpriteAt:ccp(240,190) withRect:CGRectMake(0,0,480,260) withColor:ccc3(150,200,200) withZ:0];\n//Draw the ground using blank.png\n[self drawColoredSpriteAt:ccp(240,30) withRect:CGRectMake(0,0,480,60) withColor:ccc3(80,50,25) withZ:0];\nreturn self;\n}\n-(void) drawColoredSpriteAt:(CGPoint)position withRect:(CGRect)rect withColor:(ccColor3B)color withZ:(float)z {\nCCSprite *sprite = [CCSprite spriteWithFile:@\"blank.png\"];\n[sprite setPosition:position];\n[sprite setTextureRect:rect];\n[sprite setColor:color];\n[self addChild:sprite];\n//Set Z Order\n[self reorderChild:sprite z:z];\n}\n@end\n\n```", "```swift\n    +(id)spriteWithFile:(NSString*)filename;\n\n    ```", "```swift\n    +(id)spriteWithSpriteFrameName:(NSString*)filename;\n\n    ```", "```swift\n    [alice.texture generateMipmap];\n    ccTexParams texParams = { GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE };\n    [alice.texture setTexParameters:&texParams];\n\n    ```", "```swift\n    CCSpriteBatchNode *cloudBatch = [CCSpriteBatchNode batchNodeWithFile:@\"cloud_01.png\" capacity:10];\n\n    ```", "```swift\n    CCSprite *s = [CCSprite spriteWithBatchNode:cloudBatch rect:CGRectMake(0,0,64,64)];\n    [cloudBatch addChild:s];\n\n    ```", "```swift\n    CCSprite *sprite = [CCSprite spriteWithFile:@\"blank.png\"];\n    [sprite setTextureRect:CGRectMake(0,0,480,320)];\n    [sprite setColor:ccc3(255,128,0)];\n\n    ```", "```swift\n#import \"CCGradientLayer.h\n@implementation Ch1_ColoringSprites\n-(CCLayer*) runRecipe {\n[self initButtons];\n//The Fade Scene Sprite\nCCSprite *fadeSprite = [CCSprite spriteWithFile:@\"blank.png\"];\n[fadeSprite setOpacity:0];\n[fadeSprite setPosition:ccp(240,160)];\n[fadeSprite setTextureRect:CGRectMake(0,0,480,320)];\n[self addChild:fadeSprite z:3 tag:TAG_FADE_SPRITE];\n//Add a gradient below the mountains\n//CCGradientDirectionT_B is an enum provided by CCGradientLayer\nCCGradientLayer *gradientLayer = [CCGradientLayer layerWithColor: ccc4(61,33,62,255) toColor:ccc4(65,89,54,255) withDirection:CCGradientDirectionT_B width:480 height:100];\n[gradientLayer setPosition:ccp(0,50)];\n[self addChild:gradientLayer z:0 tag:TAG_GROUND_GRADIENT];\n//Add a sinister red glow gradient behind the evil samurai\nCCGradientLayer *redGradient = [CCGradientLayer layerWithColor:ccc4(0,0,0,0) toColor:ccc4(255,0,0,100) withDirection:CCGradientDirectionT_B width:200 height:200];\n[redGradient setPosition:ccp(280,60)];\n[redGradient setRotation:-90];\n[self addChild:redGradient z:2 tag:TAG_RED_GRADIENT];\n// Make the swords glow\n[self glowAt:ccp(230,280) withScale:CGSizeMake(3.0f, 11.0f) withColor:ccc3(0,230,255) withRotation:45.0f withSprite:goodSamurai];\n[self glowAt:ccp(70,280) withScale:CGSizeMake(3.0f, 11.0f) withColor:ccc3(255,200,2) withRotation:-45.0f withSprite:evilSamurai];\nreturn self;\n}\n-(void) initButtons {\n[CCMenuItemFont setFontSize:16];\n//'Fade To Black' button\nCCMenuItemFont* fadeToBlack = [CCMenuItemFont itemFromString:@\"FADE TO BLACK\" target:self selector:@selector(fadeToBlackCallback:)];\nCCMenu *fadeToBlackMenu = [CCMenu menuWithItems:fadeToBlack, nil];\nfadeToBlackMenu.position = ccp( 180 , 20 );\n[self addChild:fadeToBlackMenu z:4 tag:TAG_FADE_TO_BLACK];\n}\n/* Fade the scene to black */\n-(void) fadeToBlackCallback:(id)sender {\nCCSprite *fadeSprite = [self getChildByTag:TAG_FADE_SPRITE];\n[fadeSprite stopAllActions];\n[fadeSprite setColor:ccc3(0,0,0)];\n[fadeSprite setOpacity:0.0f];\n[fadeSprite runAction:\n[CCSequence actions:[CCFadeIn actionWithDuration:2.0f], [CCFadeOut actionWithDuration:2.0f], nil] ];\n}\n/* Create a glow effect */\n-(void) glowAt:(CGPoint)position withScale:(CGSize)size withColor:(ccColor3B)color withRotation:(float)rotation withSprite:(CCSprite*)sprite {\nCCSprite *glowSprite = [CCSprite spriteWithFile:@\"fire.png\"];\n[glowSprite setColor:color];\n[glowSprite setPosition:position];\n[glowSprite setRotation:rotation];\n[glowSprite setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];\n[glowSprite runAction: [CCRepeatForever actionWithAction:\n[CCSequence actions:[CCScaleTo actionWithDuration:0.9f scaleX:size.width scaleY:size.height], [CCScaleTo actionWithDuration:0.9f scaleX:size.width*0.75f scaleY:size.height*0.75f], nil] ] ];\n[glowSprite runAction: [CCRepeatForever actionWithAction:\n[CCSequence actions:[CCFadeTo actionWithDuration:0.9f opacity:150], [CCFadeTo actionWithDuration:0.9f opacity:255], nil] ] ];\n[sprite addChild:glowSprite];\n}\n@end\n\n```", "```swift\n    -(void) setColor:(ccColor3B)color;\n\n    ```", "```swift\n    ccColor3B ccc3(const GLubyte r, const GLubyte g, const GLubyte b);\n\n    ```", "```swift\n    ccWHITE, ccYELLOW, ccBLUE, ccGREEN, ccRED,\n    ccMAGENTA, ccBLACK, ccORANGE, ccGRAY\n\n    ```", "```swift\n    [fadeSprite setColor:ccc3(255,255,255)];\n    [fadeSprite setOpacity:0.0f];\n    [fadeSprite runAction: [CCFadeIn actionWithDuration:2.0f] ];\n\n    ```", "```swift\n    CCGradientLayer *gradientLayer = [CCGradientLayer layerWithColor:ccc4(61,33,62,255) toColor:ccc4(65,89,54,255) withDirection:CCGradientDirectionT_B width:480 height:100];\n    [gradientLayer setPosition:ccp(0,50)];\n    [self addChild:gradientLayer z:0 tag:TAG_GROUND_GRADIENT];\n\n    ```", "```swift\n    CCSprite *glowSprite = [CCSprite spriteWithFile:@\"fire.png\"];\n    [glowSprite setColor:color];\n    [glowSprite setPosition:position];\n    [glowSprite setRotation:rotation];\n    [glowSprite setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];\n    [glowSprite runAction: [CCRepeatForever actionWithAction:\n    [CCSequence actions:[CCScaleTo actionWithDuration:0.9f scaleX:size.width scaleY:size.height], [CCScaleTo actionWithDuration:0.9f scaleX:size.width*0.75f scaleY:size.height*0.75f], nil] ] ];\n    [glowSprite runAction: [CCRepeatForever actionWithAction:\n    [CCSequence actions:[CCFadeTo actionWithDuration:0.9f opacity:150], [CCFadeTo actionWithDuration:0.9f opacity:255], nil] ] ];\n    [sprite addChild:glowSprite];\n\n    ```", "```swift\n//SimpleAnimObject.h\n@interface SimpleAnimObject : CCSprite {\nint animationType;\nCGPoint velocity;\n}\n@interface Ch1_AnimatingSprites {\nNSMutableArray *bats;\nCCAnimation *batFlyUp;\nCCAnimation *batGlideDown;\nCCSprite *lightningBolt;\nCCSprite *lightningGlow;\nint lightningRemoveCount;\n}\n-(CCLayer*) runRecipe {\n//Add our PLIST to the SpriteFrameCache\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@\"simple_bat.plist\"];\n//Add a lightning bolt\nlightningBolt = [CCSprite spriteWithFile:@\"lightning_bolt.png\"];\n[lightningBolt setPosition:ccp(240,160)];\n[lightningBolt setOpacity:64];\n[lightningBolt retain];\n//Add a sprite to make it light up other areas.\nlightningGlow = [CCSprite spriteWithFile:@\"lightning_glow.png\"];\n[lightningGlow setColor:ccc3(255,255,0)];\n[lightningGlow setPosition:ccp(240,160)];\n[lightningGlow setOpacity:100];\n[lightningGlow setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];\n[lightningBolt addChild:lightningGlow];\n//Set a counter for lightning duration randomization\nlightningRemoveCount = 0;\n//Bats Array Initialization\nbats = [[NSMutableArray alloc] init];\n//Add bats using a batch node.\nCCSpriteBatchNode *batch1 = [CCSpriteBatchNode batchNodeWithFile:@\"simple_bat.png\" capacity:10];\n[self addChild:batch1 z:2 tag:TAG_BATS];\n//Make them start flying up.\nfor(int x=0; x<10; x++){\n//Create SimpleAnimObject of bat\nSimpleAnimObject *bat = [SimpleAnimObject spriteWithBatchNode:batch1 rect:CGRectMake(0,0,48,48)];\n[batch1 addChild:bat];\n[bat setPosition:ccp(arc4random()%400+40, arc4random()%150+150)];\n//Make the bat fly up. Get the animation delay (flappingSpeed).\nfloat flappingSpeed = [self makeBatFlyUp:bat];\n//Base y velocity on flappingSpeed.\nbat.velocity = ccp((arc4random()%1000)/500 + 0.2f, 0.1f/flappingSpeed);\n//Add a pointer to this bat object to the NSMutableArray\n[bats addObject:[NSValue valueWithPointer:bat]];\n[bat retain];\n//Set the bat's direction based on x velocity.\nif(bat.velocity.x > 0){\nbat.flipX = YES;\n}\n}\n//Schedule physics updates\n[self schedule:@selector(step:)];\nreturn self;\n}\n-(float)makeBatFlyUp:(SimpleAnimObject*)bat {\nCCSpriteFrameCache * cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n//Randomize animation speed.\nfloat delay = (float)(arc4random()%5+5)/80;\nCCAnimation *animation = [[CCAnimation alloc] initWithName:@\"simply_bat_fly\" delay:delay];\n//Randomize animation frame order.\nint num = arc4random()%4+1;\nfor(int i=1; i<=4; i+=1){\n[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"simple_bat_0%i.png\",num]]];\nnum++;\nif(num > 4){ num = 1; }\n}\n//Stop any running animations and apply this one.\n[bat stopAllActions];\n[bat runAction:[CCRepeatForever actionWithAction: [CCAnimate actionWithAnimation:animation]]];\n//Keep track of which animation is running.\nbat.animationType = BAT_FLYING_UP;\nreturn delay; //We return how fast the bat is flapping.\n}\n-(void)makeBatGlideDown:(SimpleAnimObject*)bat {\nCCSpriteFrameCache * cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n//Apply a simple single frame gliding animation.\nCCAnimation *animation = [[CCAnimation alloc] initWithName:@\"simple_bat_glide\" delay:100.0f];\n[animation addFrame:[cache spriteFrameByName:@\"simple_bat_01.png\"]];\n//Stop any running animations and apply this one.\n[bat stopAllActions];\n[bat runAction:[CCRepeatForever actionWithAction: [CCAnimate actionWithAnimation:animation]]];\n//Keep track of which animation is running.\nbat.animationType = BAT_GLIDING_DOWN;\n}\n-(void)step:(ccTime)delta {\nCGSize s = [[CCDirector sharedDirector] winSize];\nfor(id key in bats){\n//Get SimpleAnimObject out of NSArray of NSValue objects.\nSimpleAnimObject *bat = [key pointerValue];\n//Make sure bats don't fly off the screen\nif(bat.position.x > s.width){\nbat.velocity = ccp(-bat.velocity.x, bat.velocity.y);\nbat.flipX = NO;\n}else if(bat.position.x < 0){\nbat.velocity = ccp(-bat.velocity.x, bat.velocity.y);\nbat.flipX = YES;\n}else if(bat.position.y > s.height){\nbat.velocity = ccp(bat.velocity.x, -bat.velocity.y);\n[self makeBatGlideDown:bat];\n}else if(bat.position.y < 0){\nbat.velocity = ccp(bat.velocity.x, -bat.velocity.y);\n[self makeBatFlyUp:bat];\n}\n//Randomly make them fly back up\nif(arc4random()%100 == 7){\nif(bat.animationType == BAT_GLIDING_DOWN){ [self makeBatFlyUp:bat]; bat.velocity = ccp(bat.velocity.x, -bat.velocity.y); }\nelse if(bat.animationType == BAT_FLYING_UP){ [self makeBatGlideDown:bat]; bat.velocity = ccp(bat.velocity.x, -bat.velocity.y); }\n}\n//Update bat position based on direction\nbat.position = ccp(bat.position.x + bat.velocity.x, bat.position.y + bat.velocity.y);\n}\n//Randomly make lightning strike\nif(arc4random()%70 == 7){\nif(lightningRemoveCount < 0){\n[self addChild:lightningBolt z:1 tag:TAG_LIGHTNING_BOLT];\nlightningRemoveCount = arc4random()%5+5;\n}\n}\n//Count down\nlightningRemoveCount -= 1;\n//Clean up any old lightning bolts\nif(lightningRemoveCount == 0){\n[self removeChildByTag:TAG_LIGHTNING_BOLT cleanup:NO];\n}\n}\n@end\n\n```", "```swift\n    @interface SimpleAnimObject : CCSprite {\n    int animationType;\n    CGPoint velocity;\n    }\n\n    ```", "```swift\n//Randomly make lightning strike\nif(arc4random()%70 == 7){\nif(lightningRemoveCount < 0){\n[self addChild:lightningBolt z:1 tag:TAG_LIGHTNING_BOLT];\nlightningRemoveCount = arc4random()%5+5;\n}\n}\n//Count down\nlightningRemoveCount -= 1;\n//Clean up any old lightning bolts\nif(lightningRemoveCount == 0){\n[self removeChildByTag:TAG_LIGHTNING_BOLT cleanup:NO];\n}\n\n```", "```swift\n/* Create a solid circle */\nvoid ccDrawSolidCircle( CGPoint center, float r, float a, NSUInteger segs, BOOL drawLineToCenter)\n{\n//Check to see if we need to draw a line to the center\nint additionalSegment = 1;\nif (drawLineToCenter)\nadditionalSegment++;\nconst float coef = 2.0f * (float)M_PI/segs;\nGLfloat *vertices = calloc( sizeof(GLfloat)*2*(segs+2), 1);\nif( ! vertices )\nreturn;\n//Calculate line segments\nfor(NSUInteger i=0;i<=segs;i++)\n{\nfloat rads = i*coef;\nGLfloat j = r * cosf(rads + a) + center.x;\nGLfloat k = r * sinf(rads + a) + center.y;\nvertices[i*2] = j * CC_CONTENT_SCALE_FACTOR();\nvertices[i*2+1] =k * CC_CONTENT_SCALE_FACTOR();\n}\nvertices[(segs+1)*2] = center.x * CC_CONTENT_SCALE_FACTOR();\nvertices[(segs+1)*2+1] = center.y * CC_CONTENT_SCALE_FACTOR();\n//Draw our solid polygon\nglDisable(GL_TEXTURE_2D);\nglDisableClientState(GL_TEXTURE_COORD_ARRAY);\nglDisableClientState(GL_COLOR_ARRAY);\nglVertexPointer(2, GL_FLOAT, 0, vertices);\nglDrawArrays(GL_TRIANGLE_FAN, 0, segs+additionalSegment);\nglEnableClientState(GL_COLOR_ARRAY);\nglEnableClientState(GL_TEXTURE_COORD_ARRAY);\nglEnable(GL_TEXTURE_2D);\n//Free up memory\nfree( vertices );\n}\n@implementation ShapeLayer\n-(void) draw {\n//Set line width.\nglLineWidth(4.0f);\n//Set point size\nglPointSize(16);\n//Enable line smoothing\nglEnable(GL_LINE_SMOOTH);\n//Draw a blue quadratic bezier curve\nglColor4ub(0, 0, 255, 255);\nccDrawQuadBezier(ccp(100,0), ccp(240,70), ccp(380,0), 10);\n//Draw a hollow purple circle\nglColor4ub(255, 0, 255, 255);\nccDrawCircle(ccp(240,160), 125.0f, 0.0f, 100, NO);\n//Draw a solid red lines\nglColor4ub(255, 0, 0, 255);\nccDrawLine(ccp(170,220), ccp(220,190));\nccDrawLine(ccp(260,190), ccp(310,220));\n//Draw a green point\nglColor4ub(0, 255, 0, 255);\nccDrawPoint(ccp(200,180));\nccDrawPoint(ccp(280,180));\n//Draw a turquoise solid circle\nglColor4ub(0, 128, 255, 50);\nccDrawSolidCircle(ccp(200,180), 25.0f, 0.0f, 20, NO);\nccDrawSolidCircle(ccp(280,180), 25.0f, 0.0f, 20, NO);\n//Draw a brown hollow circle\nglColor4ub(64,32, 0, 255);\nccDrawCircle(ccp(200,180), 25.0f, 0.0f, 100, NO);\nccDrawCircle(ccp(280,180), 25.0f, 0.0f, 100, NO);\n//Draw brown lines\nglColor4ub(64,32, 0, 255);\nccDrawLine(ccp(225,180), ccp(255,180));\nccDrawLine(ccp(305,180), ccp(370,160));\nccDrawLine(ccp(175,180), ccp(110,160));\n//Draw an orange polygon\nglColor4ub(255, 128, 0, 255);\nCGPoint vertices[5]={ ccp(230,150),ccp(240,160),ccp(250,150),ccp(245,140),ccp(235,140) };\nccDrawPoly(vertices, 5, YES);\n//Draw a yellow cubic bezier curve\nglColor4ub(255, 255, 0, 255);\nccDrawCubicBezier(ccp(170,90), ccp(220,150), ccp(260,50), ccp(320,100), 10);\n//Restore original values\nglLineWidth(1);\nglDisable(GL_LINE_SMOOTH);\nglColor4ub(255,255,255,255);\nglPointSize(1);\n}\n@end\n-(CCLayer*) runRecipe {\nShapeLayer *layer = [[ShapeLayer alloc] init];\n[layer setPosition:ccp(0,0)];\n[self addChild:layer z:2 tag:0];\nreturn self;\n}\n\n```", "```swift\n    -(void) draw;\n\n    ```", "```swift\n    glEnableClientState(GL_VERTEX_ARRAY);\n    glEnableClientState(GL_COLOR_ARRAY);\n    glEnableClientState(GL_TEXTURE_COORD_ARRAY);\n    glEnable(GL_TEXTURE_2D);\n\n    ```", "```swift\n    void ccDrawPoint( CGPoint point );\n    void ccDrawPoints( const CGPoint *points, NSUInteger numberOfPoints );\n    void ccDrawLine( CGPoint origin, CGPoint destination );\n    void ccDrawPoly( const CGPoint *vertices, NSUInteger numOfVertices, BOOL closePolygon );\n    void ccDrawCircle( CGPoint center, float radius, float angle, NSUInteger segments, BOOL drawLineToCenter);\n    void ccDrawQuadBezier(CGPoint origin, CGPoint control, CGPoint destination, NSUInteger segments);\n    void ccDrawCubicBezier(CGPoint origin, CGPoint control1, CGPoint control2, CGPoint destination, NSUInteger segments);\n\n    ```", "```swift\n    void ccDrawSolidCircle( CGPoint center, float r, float a, NSUInteger segs, BOOL drawLineToCenter);\n\n    ```", "```swift\n#import <MediaPlayer/MediaPlayer.h>\n@interface Ch1_PlayingVideoFiles {\nMPMoviePlayerController *moviePlayer;\n}\n@implementation Ch1_PlayingVideoFiles\n-(CCLayer*) runRecipe {\n//Load our video file\nNSURL *url = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"example_vid\" ofType:@\"mov\"]];\n//Create a MPMoviePlayerController object\nmoviePlayer = [[MPMoviePlayerController alloc] initWithContentURL:url];\n//Register to receive a notification when the movie has finished playing.\n[[NSNotificationCenter defaultCenter] addObserver:self\nselector:@selector(moviePlayBackDidFinish:)\nname:MPMoviePlayerPlaybackDidFinishNotification\nobject:moviePlayer];\n//Set the movie's control style and whether or not it should automatically play.\nif ([moviePlayer respondsToSelector:@selector(setFullscreen:animated:)]) {\n//Use the new 3.2 style API.\nmoviePlayer.controlStyle = MPMovieControlStyleNone;\nmoviePlayer.shouldAutoplay = YES;\nCGSize winSize = [[CCDirector sharedDirector] winSize];\nmoviePlayer.view.frame = CGRectMake(45, 50, winSize.width-90, winSize.height-100);\n[[[CCDirector sharedDirector] openGLView] addSubview:moviePlayer.view];\n} else {\n//Use the old 2.0 style API.\nmoviePlayer.movieControlMode = MPMovieControlModeHidden;\n[self playMovie];\n}\nreturn self;\n}\n-(void)moviePlayBackDidFinish:(NSNotification*)notification {\n//If playback is finished we stop the movie.\n[self stopMovie];\n}\n-(void)playMovie {\n//We do not play the movie if it is already playing.\nMPMoviePlaybackState state = moviePlayer.playbackState;\nif(state == MPMoviePlaybackStatePlaying) {\nNSLog(@\"Movie is already playing.\");\nreturn;\n}\n[moviePlayer play];\n}\n-(void)stopMovie {\n//We do not stop the movie if it is already stopped.\nMPMoviePlaybackState state = moviePlayer.playbackState;\nif(state == MPMoviePlaybackStateStopped) {\nNSLog(@\"Movie is already stopped.\");\nreturn;\n}\n//Since playback has finished we remove the observer.\n[[NSNotificationCenter defaultCenter] removeObserver:self\nname:MPMoviePlayerPlaybackDidFinishNotification\nobject:moviePlayer];\n//If the moviePlayer.view was added to the openGL view, it needs to be removed.\nif ([moviePlayer respondsToSelector:@selector(setFullscreen:animated:)]) {\n[moviePlayer.view removeFromSuperview];\n}\n}\n-(void)cleanRecipe {\n[super cleanRecipe];\n[self stopMovie];\n[moviePlayer release];\n}\n@end\n\n```", "```swift\nEAGLView *glView = [EAGLView viewWithFrame:[window bounds]\npixelFormat: kEAGLColorFormatRGB565\ndepthFormat:0\n];\n\n```", "```swift\nEAGLView *glView = [EAGLView viewWithFrame:[window bounds]\npixelFormat: kEAGLColorFormatRGBA8\ndepthFormat:0\n];\n\n```", "```swift\n//Custom particle effect\n@implementation ParticleWaterfall\n-(id)init {\nreturn [self initWithTotalParticles:400];\n}\n-(id)initWithTotalParticles:(int)p {\nif(self != [super initWithTotalParticles: p])\nreturn nil;\n//Angle\nangle = 270;\nangleVar = 12;\n//Emitter position\nself.position = ccp(160, 60);\nposVar = ccp(16, 4);\n//Life of particles\nlife = 2;\nlifeVar = 0.25f;\n//Speed of particles\nself.speed = 100;\nself.speedVar = 20;\nself.gravity = ccp(self.gravity.x, -5);\n//Size of particles\nstartSize = 35.0f;\nendSize = 100.0f;\n//Color of particles\nstartColor = ccc4(0.4f, 0.4f, 1.0f, 0.6f);\nstartColorVar = ccc4(0,0,0,0);\nendColor = ccc4(0.5f, 0.5f, 0.5f, 0);\nendColorVar = ccc4(0,0,0,0);\n//Additive\nself.blendAdditive = NO;\nreturn self;\n}\n@end\n@interface Ch1_GridParticleMotionEffects\n{\n//Variables for motion streak effect\nCCSprite *rocket;\nCCMotionStreak *streak;\nCGPoint rocketDirection;\n}\n@implementation Ch1_GridParticleMotionEffects\n-(CCLayer*) runRecipe {\nCGSize s = [[CCDirector sharedDirector] winSize];\n/*** Grid effect demo ***/\n//Create a CCSprite\nCCSprite *sprite = [CCSprite spriteWithFile:@\"colorable_sprite.png\"];\n[sprite setPosition:ccp(240,160)];\n[self addChild:sprite z:1 tag:TAG_SPRITE];\n//Create a grid effect\nCCAction *gridEffect = [CCShaky3D actionWithRange:5 shakeZ:YES grid:ccg(15,10) duration:10];\n//Run the effect\n[sprite runAction:gridEffect];\n/*** Particle effect demo ***/\n//Create a simple fire particle effect\nCCNode *fireEffect = [CCParticleFire node];\n[self addChild:fireEffect z:1 tag:TAG_FIRE_EFFECT];\n//Create a waterfall particle effect\nCCNode *waterfallEffect = [ParticleWaterfall node];\n[self addChild:waterfallEffect z:1 tag:TAG_WATERFALL_EFFECT];\n/*** Motion streak demo ***/\n//Set the rocket initially in a random direction.\nrocketDirection = ccp(arc4random()%4+1,arc4random()%4+1);\n//Add the rocket sprite.\nrocket = [CCSprite spriteWithFile:@\"rocket.png\"];\n[rocket setPosition:ccp(s.width/2, s.height/2)];\n[rocket setScale:0.5f];\n[self addChild:rocket];\n//Create the streak object and add it to the scene.\nstreak = [CCMotionStreak streakWithFade:1 minSeg:1 image:@\"streak.png\" width:32 length:32 color:ccc4(255,255,255,255)];\n[self addChild:streak];\nstreak.position = ccp(s.width/2, s.height/2);\n[self schedule:@selector(step:)];\nreturn self;\n}\n-(void)step:(ccTime)delta {\nCGSize s = [[CCDirector sharedDirector] winSize];\n//Make rocket bounce off walls\nif(rocket.position.x > s.width || rocket.position.x < 0){\nrocketDirection = ccp(-rocketDirection.x, rocketDirection.y);\n}\nelse if(rocket.position.y > s.height || rocket.position.y < 0){\nrocketDirection = ccp(rocketDirection.x, -rocketDirection.y);\n}\n//Slowly turn the rocket\nrocketDirection = ccp(rocketDirection.x, rocketDirection.y+0.05f);\n//Update rocket position based on direction\nrocket.position = ccp(rocket.position.x + rocketDirection.x, rocket.position.y + rocketDirection.y);\n[streak setPosition:rocket.position];\n//Set the rocket's rotation\n[rocket setRotation: radiansToDegrees(vectorToRadians(rocketDirection))];\n}\n@end\n\n```", "```swift\n    CCParticleExplosion, CCParticleFire, CCParticleFireworks, CCParticleFlower, CCParticleGalaxy, CCParticleMeteor, CCParticleRain, CCParticleSmoke, CCParticleSnow, CCParticleSpiral, CCParticleSun\n\n    ```", "```swift\nif( ! [director enableRetinaDisplay:YES] )\nCCLOG(@\"Retina Display Not supported\");\n\n```", "```swift\n-(CCLayer*) runRecipe {\n//Switch to Retina mode to see the difference\nCCSprite *sprite = [CCSprite spriteWithFile:@\"cocos2d_beginner.png\"];\n[sprite setPosition:ccp(240,160)];\n[sprite setScale:1.0f];\n[self addChild:sprite];\nreturn self;\n}\n\n```", "```swift\n@interface CCMoveByCustom : CCMoveBy\n{}\n-(void) update: (ccTime) t;\n@end\n@implementation CCMoveByCustom\n-(void) update: (ccTime) t {\n//Here we neglect to change something with a zero delta.\nif(delta.x == 0){\n[target_ setPosition:ccp( [(CCNode*)target_ position].x, (startPosition.y + delta.y*t ) )];\n}else if(delta.y == 0){\n[target_ setPosition:ccp( (startPosition.x + delta.x*t ), [(CCNode*)target_ position].y )];\n}else{\n[target_ setPosition:ccp( (startPosition.x + delta.x*t ), (startPosition.y + delta.y * t ) )];\n}\n}\n@end\n@implementation Ch1_EasingActions\n-(CCLayer*) runRecipe {\n/*** 1D Movement Ease Action ***/\n//Create the basic action to move by a certain X and Y vector\nCCActionInterval *action1D = [CCMoveBy actionWithDuration:2 position:ccp(200,200)];\n//Create a sprite to move\nCCSprite *spriteEase1D = [CCSprite spriteWithFile:@\"colorable_sprite.png\"];\n[spriteEase1D setPosition:ccp(150,50)];\n[self addChild:spriteEase1D z:1 tag:TAG_SPRITE_EASE_1D];\n//Create an 'eased' movement action with a CCEase class\nCCActionInterval *easeAction1D = [CCEaseInOut actionWithAction:action1D rate:2];\n//Run the action\n[spriteEase1D runAction:easeAction1D];\n/*** 2D Movement Ease Action ***/\n//Create two movement actions, one in each dimension\nCCActionInterval *action2DX = [CCMoveByCustom actionWithDuration:2 position:ccp(200,0)];\nCCActionInterval *action2DY = [CCMoveByCustom actionWithDuration:2 position:ccp(0,200)];\n//Create a sprite to move\nCCSprite *spriteEase2D = [CCSprite spriteWithFile:@\"colorable_sprite.png\"];\n[spriteEase2D setPosition:ccp(150,50)];\n[self addChild:spriteEase2D z:1 tag:TAG_SPRITE_EASE_2D];\n//Create two 'eased' movement actions, one on each dimension\nCCActionInterval *easeAction2DX = [CCEaseSineIn actionWithAction:action2DX];\nCCActionInterval *easeAction2DY = [CCEaseBounceIn actionWithAction:action2DY];\n//Run both actions\n[spriteEase2D runAction:easeAction2DX];\n[spriteEase2D runAction:easeAction2DY];\nreturn self;\n}\n@end\n\n```", "```swift\n#import \"Vector3D.h\"\n@interface Cube3D : CCSprite\n{\nVector3D *translation3D;\nVector3D *rotation3DAxis;\nGLfloat rotation3DAngle;\nbool drawTextured;\n}\n@property (readwrite, assign) Vector3D *translation3D;\n@property (readwrite, assign) Vector3D *rotation3DAxis;\n@property (readwrite, assign) GLfloat rotation3DAngle;\n@property (readwrite, assign) bool drawTextured;\n-(void) draw;\n@end\n@implementation Cube3D\n@synthesize translation3D,rotation3DAxis,rotation3DAngle,drawTextured;\n-(void) draw {\n//Vertices for each side of the cube\nconst GLfloat frontVertices[]={ -0.5f,-0.5f,0.5f, 0.5f,-0.5f,0.5f, -0.5f,0.5f,0.5f, 0.5f,0.5f,0.5f};\nconst GLfloat backVertices[] = { -0.5f,-0.5f,-0.5f, -0.5f,0.5f,-0.5f, 0.5f,-0.5f,-0.5f, 0.5f,0.5f,-0.5f };\nconst GLfloat leftVertices[] = { -0.5f,-0.5f,0.5f, -0.5f,0.5f,0.5f, -0.5f,-0.5f,-0.5f, -0.5f,0.5f,-0.5f };\nconst GLfloat rightVertices[] = { 0.5f,-0.5f,-0.5f, 0.5f,0.5f,-0.5f, 0.5f,-0.5f,0.5f, 0.5f,0.5f,0.5f };\nconst GLfloat topVertices[] = { -0.5f,0.5f,0.5f, 0.5f,0.5f,0.5f, -0.5f,0.5f,-0.5f, 0.5f,0.5f,-0.5f };\nconst GLfloat bottomVertices[] = {-0.5f,-0.5f,0.5f,-0.5f,-0.5f,-0.5f,0.5f,-0.5f,0.5f, 0.5f,-0.5f,-0.5f };\n//Coordinates for our texture to map it to a cube side\nconst GLfloat textureCoordinates[] = { 0,0, 1,0, 0,1, 1,1,};\n//We enable back face culling to properly set the depth buffer\nglEnable(GL_CULL_FACE);\nglCullFace(GL_BACK);\n//We are not using GL_COLOR_ARRAY\nglDisableClientState(GL_COLOR_ARRAY);\n//We disable GL_TEXTURE_COORD_ARRAY if not using a texture\nif(!drawTextured){\nglDisableClientState(GL_TEXTURE_COORD_ARRAY);\n}\n//Replace the current matrix with the identity matrix\nglLoadIdentity();\n//Translate and rotate\nglTranslatef(translation3D.x, translation3D.y, translation3D.z);\nglRotatef(rotation3DAngle, rotation3DAxis.x, rotation3DAxis.y, rotation3DAxis.z);\n//Bind our texture if neccessary\nif(drawTextured){\nglBindTexture(GL_TEXTURE_2D, texture_.name);\n}\n//Here we define our vertices, set our textures or colors and finally draw the cube sides\nglVertexPointer(3, GL_FLOAT, 0, frontVertices);\nif(drawTextured){ glTexCoordPointer(2, GL_FLOAT, 0, textureCoordinates); }\nelse{ glColor4f(1.0f, 0.0f, 0.0f, 1.0f); }\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\nglVertexPointer(3, GL_FLOAT, 0, backVertices);\nif(drawTextured){ glTexCoordPointer(2, GL_FLOAT, 0, textureCoordinates); }\nelse{ glColor4f(1.0f, 1.0f, 0.0f, 1.0f); }\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\nglVertexPointer(3, GL_FLOAT, 0, leftVertices);\nif(drawTextured){ glTexCoordPointer(2, GL_FLOAT, 0, textureCoordinates); }\nelse{ glColor4f(1.0f, 0.0f, 1.0f, 1.0f); }\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\nglVertexPointer(3, GL_FLOAT, 0, rightVertices);\nif(drawTextured){ glTexCoordPointer(2, GL_FLOAT, 0, textureCoordinates); }\nelse{ glColor4f(0.0f, 1.0f, 1.0f, 1.0f); }\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\nglVertexPointer(3, GL_FLOAT, 0, topVertices);\nif(drawTextured){ glTexCoordPointer(2, GL_FLOAT, 0, textureCoordinates); }\nelse{ glColor4f(0.0f, 1.0f, 0.0f, 1.0f); }\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\nglVertexPointer(3, GL_FLOAT, 0, bottomVertices);\nif(drawTextured){ glTexCoordPointer(2, GL_FLOAT, 0, textureCoordinates); }\nelse{ glColor4f(0.0f, 0.0f, 1.0f, 1.0f); }\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n//We re-enable the default render state\nglEnableClientState(GL_COLOR_ARRAY);\nglEnableClientState(GL_TEXTURE_COORD_ARRAY);\nglDisable(GL_CULL_FACE);\nglColor4f(1.0f, 1.0f, 1.0f, 1.0f);\n}\n@end\n@interface Ch1_3DCubes {\nCube3D *cube3d1;\nCube3D *cube3d2;\n}\n@implementation Ch1_3DCubes\n-(CCLayer*) runRecipe {\n//Load a textured cube and set initial variables\ncube3d1 = [Cube3D spriteWithFile:@\"crate.jpg\"];\ncube3d1.translation3D = [Vector3D x:2.0f y:0.0f z:-4.0f];\ncube3d1.rotation3DAxis = [Vector3D x:2.0f y:2.0f z:4.0f];\ncube3d1.rotation3DAngle = 0.0f;\ncube3d1.drawTextured = YES;\n[self addChild:cube3d1 z:3 tag:0];\n//Load a colored cube and set initial variables\ncube3d2 = [Cube3D spriteWithFile:@\"blank.png\"];\ncube3d2.translation3D = [Vector3D x:-2.0f y:0.0f z:-4.0f];\ncube3d2.rotation3DAxis = [Vector3D x:2.0f y:2.0f z:4.0f];\ncube3d2.rotation3DAngle = 0.0f;\ncube3d2.drawTextured = NO;\n[self addChild:cube3d2 z:1 tag:1];\n//Schedule cube rotation\n[self schedule:@selector(step:)];\nreturn self;\n}\n-(void) step:(ccTime)delta {\ncube3d1.rotation3DAngle += 0.5f;\ncube3d2.rotation3DAngle -= 0.5f;\n}\n@end\n\n```", "```swift\n#import \"Vector3D.h\"\n//Included for CPP polygon triangulation\n#import \"triangulate.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n@implementation TexturedPolygon\n@synthesize vertices, triangles;\n+(id) createWithFile:(NSString*)file withVertices:(NSArray*)verts {\n/*** Create a TexturedPolygon with vertices only. ***/\n/*** Perform polygon trianglulation to get triangles. ***/\n//Initialization\nTexturedPolygon *tp = [TexturedPolygon spriteWithFile:file];\ntp.vertices = [[NSMutableArray alloc] init];\ntp.triangles = [[NSMutableArray alloc] init];\n//Polygon Triangulation\nVector2dVector a;\nfor(int i=0; i<[verts count];i+=1){\n//Add polygon vertices\n[tp.vertices addObject:[verts objectAtIndex:i]];\n//Add polygon vertices to triangulation container\nCGPoint vert = [[verts objectAtIndex:i] CGPointValue];\na.push_back( Vector2d(vert.x, vert.y) );\n}\n//Run triangulation algorithm\nVector2dVector result;\nTriangulate::Process(a,result);\n//Gather all triangles from result container\nint tcount = result.size()/3;\nfor (int i=0; i<tcount; i++) {\nconst Vector2d &p1 = result[i*3+0];\nconst Vector2d &p2 = result[i*3+1];\nconst Vector2d &p3 = result[i*3+2];\n//Add triangle index\n[tp.triangles addObject: [tp getTriangleIndicesFromPoint1:ccp(p1.GetX(),p1.GetY()) point2:ccp(p2.GetX(),p2.GetY()) point3:ccp(p3.GetX(), p3.GetY())] ];\n}\n//Set texture coordinate information\n[tp setCoordInfo];\nreturn tp;\n}\n+(id) createWithFile:(NSString*)file withVertices:(NSArray*)verts withTriangles:(NSArray*)tris {\n/*** Create a TexturedPolygon with vertices and triangles given. ***/\n//Initialization\nTexturedPolygon *tp = [TexturedPolygon spriteWithFile:file];\ntp.vertices = [[NSMutableArray alloc] init];\ntp.triangles = [[NSMutableArray alloc] init];\n//Set polygon vertices\nfor(int i=0; i<[verts count];i+=1){\n[tp.vertices addObject:[verts objectAtIndex:i]];\n}\n//Set triangle indices\nfor(int i=0; i<[tris count];i+=1){\n[tp.triangles addObject:[tris objectAtIndex:i]];\n}\n//Set texture coordinate information\n[tp setCoordInfo];\nreturn tp;\n}\n-(Vector3D*) getTriangleIndicesFromPoint1:(CGPoint)p1 point2:(CGPoint)p2 point3:(CGPoint)p3 {\n/*** Convert three polygon vertices to triangle indices ***/\nVector3D* indices = [Vector3D x:-1 y:-1 z:-1];\nfor(int i=0; i< [vertices count]; i++){\nCGPoint vert = [[vertices objectAtIndex:i] CGPointValue];\nif(p1.x == vert.x and p1.y == vert.y){\nindices.x = i;\n}else if(p2.x == vert.x and p2.y == vert.y){\nindices.y = i;\n}else if(p3.x == vert.x and p3.y == vert.y){\nindices.z = i;\n}\n}\nreturn indices;\n}\n-(void) addAnimFrameWithFile:(NSString*)file toArray:(NSMutableArray*)arr {\n/*** For textured polygon animation ***/\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};\nCCTexture2D *frameTexture = [[CCTextureCache sharedTextureCache] addImage:file];\n[frameTexture setTexParameters:&params];\nCCSpriteFrame *frame = [CCSpriteFrame frameWithTexture:frameTexture rect:self.textureRect];\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFrame:frameTexture name:file];\n[arr addObject:frame];\n}\n-(void) setCoordInfo {\n/*** Set texture coordinates for each vertex ***/\nif(coords){ free(coords); }\ncoords = (ccV2F_T2F*)malloc(sizeof(ccV2F_T2F)*[vertices count]);\nfor(int i=0;i<[vertices count];i++) {\ncoords[i].vertices.x = [[vertices objectAtIndex:i] CGPointValue].x;\ncoords[i].vertices.y = [[vertices objectAtIndex:i] CGPointValue].y;\nfloat atlasWidth = texture_.pixelsWide;\nfloat atlasHeight = texture_.pixelsHigh;\ncoords[i].texCoords.u = (coords[i].vertices.x + rect_.origin.x)/ atlasWidth;\ncoords[i].texCoords.v = (contentSize_.height - coords[i].vertices.y + rect_.origin.y)/ atlasHeight ;\n}\n}\n-(void) dealloc\n{\n//Release texture coordinates if necessary\nif(coords) free(coords);\n[super dealloc];\n}\n-(void) draw\n{\n/*** This is where the magic happens. Texture and draw all triangles. ***/\nglDisableClientState(GL_COLOR_ARRAY);\nglColor4ub( color_.r, color_.g, color_.b, quad_.bl.colors.a);\nBOOL newBlend = NO;\nif( blendFunc_.src != CC_BLEND_SRC || blendFunc_.dst != CC_BLEND_DST ) {\nnewBlend = YES;\nglBlendFunc( blendFunc_.src, blendFunc_.dst );\n}\nglBindTexture(GL_TEXTURE_2D, texture_.name);\nunsigned int offset = (unsigned int)coords;\nunsigned int diff = offsetof( ccV2F_T2F, vertices);\nglVertexPointer(2, GL_FLOAT, sizeof(ccV2F_T2F), (void*) (offset + diff));\ndiff = offsetof( ccV2F_T2F, texCoords);\nglTexCoordPointer(2, GL_FLOAT, sizeof(ccV2F_T2F), (void*) (offset + diff));\nfor(int i=0;i<[triangles count];i++){\nVector3D *tri = [triangles objectAtIndex:i];\nshort indices[] = {tri.x, tri.y, tri.z};\nglDrawElements(GL_TRIANGLE_STRIP, 3, GL_UNSIGNED_SHORT, indices);\n}\nif(newBlend) { glBlendFunc(CC_BLEND_SRC, CC_BLEND_DST); }\nglColor4ub( 255, 255, 255, 255);\nglEnableClientState(GL_COLOR_ARRAY);\n}\n@end\n@implementation Ch1_RenderTexturedPolygon\n-(CCLayer*) runRecipe {\nCGSize s = [[CCDirector sharedDirector] winSize];\n//Set polygon vertices\nCGPoint vertexArr[] = { ccp(248,340), ccp(200,226), ccp(62,202), ccp(156,120), ccp(134,2), ccp(250,64), ccp(360,0), ccp(338,128), ccp(434,200), ccp(306,230) };\nint numVerts = 10;\nNSMutableArray *vertices = [[NSMutableArray alloc] init];\n//Add vertices to array\nfor(int i=0; i<numVerts; i++){\n[vertices addObject:[NSValue valueWithCGPoint:vertexArr[i]]];\n}\n//Note: Your texture size MUST be a product of 2 for this to work.\n//Set texture parameters to repeat\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};\n//Create textured polygon\nTexturedPolygon *texturedPoly = [TexturedPolygon createWithFile:@\"bricks.jpg\" withVertices:vertices];\n[texturedPoly.texture setTexParameters:&params];\ntexturedPoly.position = ccp(128,128);\n//Add textured polygon to scene\n[self addChild:texturedPoly z:1 tag:0];\nreturn self;\n}\n@end\n\n```", "```swift\n#import \"Vector3D.h\"\n#import \"TexturedPolygon.h\"\n@implementation Ch1_AnimateTexturedPolygon\n-(CCLayer*) runRecipe {\nCGSize s = [[CCDirector sharedDirector] winSize];\nccTexParams params = {GL_NEAREST, GL_NEAREST_MIPMAP_NEAREST, GL_REPEAT,GL_REPEAT};\n//Create grass animated textured polygon\nCGPoint grassVertexArr[] = { ccp(0,0), ccp(480,0), ccp(480,320), ccp(0,320) };\nint grassNumVerts = 4;\nNSMutableArray *grassVertices = [[NSMutableArray alloc] init];\nfor(int i=0; i<grassNumVerts; i++){\n[grassVertices addObject:[NSValue valueWithCGPoint:ccp(grassVertexArr[i].x*1, grassVertexArr[i].y*1)]];\n}\nTexturedPolygon *grassPoly = [TexturedPolygon createWithFile:@\"grass_tile_01.png\" withVertices:grassVertices];\n[grassPoly.texture setTexParameters:&params];\ngrassPoly.position = ccp(32,32);\n[self addChild:grassPoly z:1 tag:1];\n//Create swaying grass animation\nNSMutableArray *grassAnimFrames = [NSMutableArray array];\n//This is a two part animation with 'back' and 'forth' frames\nfor(int i=0; i<=6; i++){\n[grassPoly addAnimFrameWithFile:[NSString stringWithFormat:@\"grass_tile_0%d.png\",i] toArray:grassAnimFrames];\n}\nfor(int i=5; i>0; i--){\n[grassPoly addAnimFrameWithFile:[NSString stringWithFormat:@\"grass_tile_0%d.png\",i] toArray:grassAnimFrames];\n}\nCCAnimation *grassAnimation = [[CCAnimation alloc] initWithName:@\"grass_tile_anim\" delay:0.1f];\nfor(int i=0; i<[grassAnimFrames count]; i++){\n[grassAnimation addFrame:[grassAnimFrames objectAtIndex:i]];\n}\nCCActionInterval *grassAnimate = [CCSequence actions: [CCAnimate actionWithAnimation:grassAnimation restoreOriginalFrame:NO],\n[CCDelayTime actionWithDuration:0.0f], nil];\nCCActionInterval *grassRepeatAnimation = [CCRepeatForever actionWithAction:grassAnimate];\n[grassPoly runAction:grassRepeatAnimation];\nreturn self;\n}\n@end\n\n```", "```swift\n    @implementation Ch1_PaletteSwapping\n    -(CCLayer*) runRecipe {\n    //Create a nice looking background\n    CCSprite *bg = [CCSprite spriteWithFile:@\"baseball_bg_02.png\"];\n    [bg setPosition:ccp(240,160)];\n    bg.opacity = 100;\n    [self addChild:bg z:0 tag:0];\n    /*** Animate 4 different fielders with different color combinations ***/\n    //Set color arrays\n    ccColor3B colors1[] = {\n    ccc3(255,217,161), ccc3(225,225,225), ccc3(0,0,150), ccc3(255,255,255) };\n    ccColor3B colors2[] = {\n    ccc3(140,100,46), ccc3(150,150,150), ccc3(255,0,0), ccc3(255,255,255) };\n    ccColor3B colors3[] = {\n    ccc3(255,217,161), ccc3(115,170,115), ccc3(115,170,115), ccc3(255,255,255) };\n    ccColor3B colors4[] = {\n    ccc3(140,100,46), ccc3(50,50,50), ccc3(255,255,0), ccc3(255,255,255) };\n    //Animate fielders with colors\n    [self animateFielderWithColors:colors1 withPosition:ccp(150,70)];\n    [self animateFielderWithColors:colors2 withPosition:ccp(150,200)];\n    [self animateFielderWithColors:colors3 withPosition:ccp(300,200)];\n    [self animateFielderWithColors:colors4 withPosition:ccp(300,70)];\n    return self;\n    }\n    -(void) animateFielderWithColors:(ccColor3B[])colors withPosition:(CGPoint)pos {\n    //The names of our layers\n    NSString *layers[] = { @\"skin\", @\"uniform\", @\"trim\", @\"black_lines\" };\n    //Number of layers\n    int numLayers = 4;\n    for(int i=0; i<numLayers; i+=1){\n    NSString *layerName = layers[i];\n    ccColor3B color = colors[i];\n    //We need each plist, the first frame name and finally a name for the animation\n    NSString *plistName = [NSString stringWithFormat:@\"fielder_run_%@.plist\", layerName];\n    NSString *firstFrameName = [NSString stringWithFormat:@\"fielder_run_%@_01.png\", layerName];\n    NSString *animationName = [NSString stringWithFormat:@\"fielder_run_%@\", layerName];\n    //Add plist frames to the SpriteFrameCache\n    [[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:plistName];\n    //Get the first sprite frame\n    CCSpriteFrame *firstFrame = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:firstFrameName];\n    //Create our sprite\n    CCSprite *sprite = [CCSprite spriteWithSpriteFrame:firstFrame];\n    //Set color and position\n    sprite.position = pos;\n    sprite.color = color;\n    //Create the animation and add frames\n    CCAnimation *animation = [[CCAnimation alloc] initWithName:animationName delay:0.15f];\n    for(int i=1; i<=8; i+=1){\n    CCSpriteFrame *frame = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:[NSString stringWithFormat:@\"fielder_run_%@_0%i.png\",layerName,i]];\n    [animation addFrame:frame];\n    }\n    //Run the repeating animation\n    [sprite runAction:[CCRepeatForever actionWithAction: [CCAnimate actionWithAnimation:animation]]];\n    //Finally, add the sprite\n    [self addChild:sprite];\n    }\n    }\n    @end\n\n    ```", "```swift\n#import \"CCTexture2DMutable.h\"\n@implementation Ch1_MutablePaletteSwapping\n-(CCLayer*) runRecipe {\n//Create a nice looking background\nCCSprite *bg = [CCSprite spriteWithFile:@\"baseball_bg_01.png\"];\n[bg setPosition:ccp(240,160)];\nbg.opacity = 100;\n[self addChild:bg z:0 tag:0];\n/*** Animate 4 different fielders with different color combinations ***/\n//Set color arrays\nccColor4B colors1[] = { ccc4(255,217,161,255), ccc4(225,225,225,255), ccc4(0,0,150,255) };\nccColor4B colors2[] = { ccc4(140,100,46,255), ccc4(150,150,150,255), ccc4(255,0,0,255) };\nccColor4B colors3[] = { ccc4(255,217,161,255), ccc4(115,170,115,255), ccc4(115,170,115,255) };\nccColor4B colors4[] = { ccc4(140,100,46,255), ccc4(50,50,50,255), ccc4(255,255,0,255) };\n//Create texture copy to use as an immutable guide.\nCCTexture2DMutable* textureCopy = [[[CCTexture2DMutable alloc] initWithImage:[UIImage imageNamed:@\"fielder_run_sentinel_colors.png\"]] autorelease];\n//Create our sprites using mutable textures.\nCCSprite *sprite1 = [CCSprite spriteWithTexture:[[[CCTexture2DMutable alloc] initWithImage:[UIImage imageNamed:@\"fielder_run_sentinel_colors.png\"]] autorelease]];\nCCSprite *sprite2 = [CCSprite spriteWithTexture:[[[CCTexture2DMutable alloc] initWithImage:[UIImage imageNamed:@\"fielder_run_sentinel_colors.png\"]] autorelease]];\nCCSprite *sprite3 = [CCSprite spriteWithTexture:[[[CCTexture2DMutable alloc] initWithImage:[UIImage imageNamed:@\"fielder_run_sentinel_colors.png\"]] autorelease]];\nCCSprite *sprite4 = [CCSprite spriteWithTexture:[[[CCTexture2DMutable alloc] initWithImage:[UIImage imageNamed:@\"fielder_run_sentinel_colors.png\"]] autorelease]];\n//Set sprite positions\n[sprite1 setPosition:ccp(125,75)];\n[sprite2 setPosition:ccp(125,225)];\n[sprite3 setPosition:ccp(325,75)];\n[sprite4 setPosition:ccp(325,225)];\n//Swap colors in each sprite mutable texture and apply the changes.\n[self swapColor:ccc4(0,0,255,255) withColor:colors1[0] inTexture:sprite1.texture withCopy:textureCopy];\n[self swapColor:ccc4(0,255,0,255) withColor:colors1[1] inTexture:sprite1.texture withCopy:textureCopy];\n[self swapColor:ccc4(255,0,0,255) withColor:colors1[2] inTexture:sprite1.texture withCopy:textureCopy];\n[sprite1.texture apply];\n/* CODE OMITTED */\n//Finally, add the sprites to the scene.\n[self addChild:sprite1 z:0 tag:0];\n[self addChild:sprite2 z:0 tag:1];\n[self addChild:sprite3 z:0 tag:2];\n[self addChild:sprite4 z:0 tag:3];\nreturn self;\n}\n-(void) swapColor:(ccColor4B)color1 withColor:(ccColor4B)color2 inTexture:(CCTexture2DMutable*)texture withCopy:(CCTexture2DMutable*)copy {\n//Look through the texture, find all pixels of the specified color and change them.\n//We use a tolerance of 200 here.\nfor(int x=0; x<texture.pixelsWide; x++){\nfor(int y=0; y<texture.pixelsHigh; y++){\nif( [self isColor:[copy pixelAt:ccp(x,y)] equalTo:color1 withTolerance:200] ){\n[texture setPixelAt:ccp(x,y) rgba:color2];\n}\n}\n}\n}\n-(bool) isColor:(ccColor4B)color1 equalTo:(ccColor4B)color2 withTolerance:(int)tolerance {\n//If the colors are equal within a tolerance we change them.\nbool equal = YES;\nif( abs(color1.r - color2.r) + abs(color1.g - color2.g) +\nabs(color1.b - color2.b) + abs(color1.a - color2.a) > tolerance ){\nequal = NO;\n}\nreturn equal;\n}\n@end\n\n```", "```swift\n#import \"CCTexture2DMutable.h\"\n#import \"AWTextureFilter.h\"\n@implementation Ch1_UsingAWTextureFilter\n-(CCLayer*) runRecipe {\nCGSize winSize = [[CCDirector sharedDirector] winSize];\n//Pixel Format RGBA8888 is required for blur effects\n[CCTexture2D setDefaultAlphaPixelFormat:kCCTexture2DPixelFormat_RGBA8888];\n/*** Display a blurred texture ***/\n//Create the blur mutable texture\nCCTexture2DMutable *mutableBlurTexture = [[[CCTexture2DMutable alloc] initWithImage:[UIImage imageNamed:@\"cocos2d_beginner.png\"]] autorelease];\n//Apply blur to the mutable texture\n[AWTextureFilter blur:mutableBlurTexture radius:3];\n//Create a sprite to show the blur\nCCSprite *blurSprite = [CCSprite spriteWithTexture:mutableBlurTexture];\n[blurSprite setPosition:ccp(winSize.width/2+blur.contentSize.width/2+1, winSize.height/2)];\n//Add sprite to the scene\n[self addChild:blurSprite z:0 tag:0];\n/*** Display a selectively blurred texture ***/\n//Create the mutable texture to selectively blur\nCCTexture2DMutable *mutableSelectiveBlurTexture = [[[CCTexture2DMutable alloc] initWithImage:[UIImage imageNamed:@\"cocos2d_beginner.png\"]] autorelease];\n//Apply selective blur to the mutable texture\n[AWTextureFilter blur:mutableSelectiveBlurTexture radius:8 rect:CGRectMake(240-200, (winSize.height-160)-75, 150, 150)];\n//Create a sprite to show the selective blur\nCCSprite *selectiveBlurSprite = [CCSprite spriteWithTexture:mutableSelectiveBlurTexture];\n[selectiveBlurSprite setPosition:ccp(winSize.width/2, winSize.height/2)];\n//Add sprite to the scene\n[self addChild:selectiveBlurSprite z:0 tag:1];\n/*** Display dynamic font shadow effect ***/\n//Create a background so we can see the shadow\nCCLayerColor *background = [CCLayerColor layerWithColor:ccc4(200, 100, 100, 255) width:300 height:50];\n[background setIsRelativeAnchorPoint:YES];\n[background setAnchorPoint:ccp(0.5f, 0.5f)];\n[background setPosition:ccp(winSize.width/2, winSize.height/2)];\n//Create a sprite for the font label\nCCSprite* labelSprite = [CCSprite node];\n[labelSprite setPosition:ccp(winSize.width/2, winSize.height/2)];\n//Create a sprite for the shadow\nCCSprite* shadowSprite = [CCSprite node];\n[shadowSprite setPosition:ccp(winSize.width/2+1, winSize.height/2+1)];\n//Color it black\n[shadowSprite setColor:ccBLACK];\n//Add sprites to a node and the node to the scene\nCCNode* node = [[CCNode alloc] init];\n[node addChild:background z:-1];\n[node addChild:shadowSprite z:0];\n[node addChild:labelSprite z:1];\n[self addChild:node z:-1 tag:2];\n//Create a mutable texture with a string\nCCTexture2DMutable *shadowTexture = [[[CCTexture2DMutable alloc] initWithString:@\"Shadowed Text\" fontName:@\"Arial\" fontSize:28] autorelease];\n//Copy the mutable texture as non mutable texture\nCCTexture2D *labelTexture = [[shadowTexture copyMutable:NO] autorelease];\n//Set the label texture\n[labelSprite setTexture:labelTexture];\n[labelSprite setTextureRect:CGRectMake(0, 0, shadowTexture.contentSize.width, shadowTexture.contentSize.height)];\n//Apply blur to the shadow texture\n[AWTextureFilter blur:shadowTexture radius:4];\n//Set the shadow texture\n[shadowSprite setTexture:shadowTexture];\n[shadowSprite setTextureRect:CGRectMake(0, 0, shadowTexture.contentSize.width, shadowTexture.contentSize.height)];\nreturn self;\n}\n\n```", "```swift\n- (id) initWithString:(NSString*)string fontName:(NSString*)name fontSize:(CGFloat)size;\n\n```", "```swift\n#import \"Screenshot.h\"\n@implementation Ch1_TakingScreenshots\n-(CCLayer*) runRecipe {\nCCSprite* sprite = [CCSprite spriteWithTexture:[Screenshot takeAsTexture2D]];\n[sprite setPosition:ccp(240,160)];\n[sprite setScale:0.75f];\n[self addChild:sprite z:0 tag:0];\nreturn self;\n}\n\n```", "```swift\n@implementation Ch1_UsingCCParallaxNode\n-(CCLayer*) runRecipe {\n//Create four parallax sprites, one for each layer\nCCSprite* parallaxLayer01 = [CCSprite spriteWithFile:@\"parallax_layer_01.png\"];\nCCSprite* parallaxLayer02 = [CCSprite spriteWithFile:@\"parallax_layer_02.png\"];\nCCSprite* parallaxLayer03 = [CCSprite spriteWithFile:@\"parallax_layer_03.png\"];\nCCSprite* parallaxLayer04 = [CCSprite spriteWithFile:@\"parallax_layer_04.png\"];\n//Create a parallax node and add all four sprites\nCCParallaxNode* parallaxNode = [CCParallaxNode node];\n[parallaxNode setPosition:ccp(0,0)];\n[parallaxNode addChild:parallaxLayer01 z:1 parallaxRatio:ccp(0, 0) positionOffset:ccp(240,200)];\n[parallaxNode addChild:parallaxLayer02 z:2 parallaxRatio:ccp(1, 0) positionOffset:ccp(240,100)];\n[parallaxNode addChild:parallaxLayer03 z:3 parallaxRatio:ccp(2, 0) positionOffset:ccp(240,100)];\n[parallaxNode addChild:parallaxLayer04 z:4 parallaxRatio:ccp(3, 0) positionOffset:ccp(240,20)];\n[self addChild:parallaxNode z:0 tag:1];\n//Move the node to the left then the right\n//This creates the effect that we are moving to the right then the left\nCCMoveBy* moveRight = [CCMoveBy actionWithDuration:5.0f position:ccp(-80, 0)];\nCCMoveBy* moveLeft = [CCMoveBy actionWithDuration:2.5f position:ccp(80, 0)];\nCCSequence* sequence = [CCSequence actions:moveRight, moveLeft, nil];\nCCRepeatForever* repeat = [CCRepeatForever actionWithAction:sequence];\n[parallaxNode runAction:repeat];\nreturn self;\n}\n@end\n\n```", "```swift\nparallaxNodeChildXOffset = baseXOffset + ((int) (self.position.x / winSize.width)) * winSize.width;\n\n```", "```swift\n@interface Ch1_ColorMaskLighting : Recipe\n{\nSimpleAnimObject *burnSprite;\nSimpleAnimObject *lightSprite;\nSimpleAnimObject *monkSprite;\nCCRenderTexture *darknessLayer;\nNSMutableArray *bats;\nCCAnimation *batFlyUp;\nCCAnimation *batGlideDown;\n}\n@end\n@implementation Ch1_ColorMaskLighting\n-(CCLayer*) runRecipe {\n//Add our PLISTs to the SpriteFrameCache singleton\nCCSpriteFrameCache * cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[cache addSpriteFramesWithFile:@\"simple_bat.plist\"];\n[cache addSpriteFramesWithFile:@\"monk_lantern.plist\"];\n//Add cave background\nCCSprite *caveBg = [CCSprite spriteWithFile:@\"cave.png\"];\n[caveBg setPosition:ccp(240,160)];\n[self addChild: caveBg z:0 tag:TAG_CAVE_BG];\n//Set up the burn sprite that will \"knock out\" parts of the darkness layer depending on the alpha value of the pixels in the image.\nburnSprite = [SimpleAnimObject spriteWithFile:@\"fire.png\"];\nburnSprite.position = ccp(50,50);\nburnSprite.scale = 10.0f;\n[burnSprite setBlendFunc: (ccBlendFunc) { GL_ZERO, GL_ONE_MINUS_SRC_ALPHA }];\n[burnSprite retain];\nburnSprite.velocity = ccp(1,0);\n//Add a 'light' sprite which additively blends onto the scene. This represents the cone of light created by the monk's candle.\nlightSprite = [SimpleAnimObject spriteWithFile:@\"fire.png\"];\nlightSprite.position = ccp(50,50);\nlightSprite.scale = 10.0f;\n[lightSprite setColor:ccc3(100,100,50)];\n[lightSprite setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];\nlightSprite.velocity = ccp(1,0);\n[self addChild:lightSprite z:4 tag:TAG_LIGHT_SPRITE];\n//Add the monk\nmonkSprite = [[SimpleAnimObject alloc] init];\nmonkSprite.position = ccp(50,50);\nmonkSprite.velocity = ccp(1,0);\n[self addChild:monkSprite z:1 tag:TAG_MONK];\n//Animate the monk to simulate walking.\nCCAnimation *animation = [[CCAnimation alloc] initWithName:@\"monk_lantern_walk\" delay:0.1f];\nfor(int i=1; i<=5; i+=1){\n[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"monk_lantern_0%i.png\",i]]];\n}\nfor(int i=4; i>=2; i-=1){\n[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"monk_lantern_0%i.png\",i]]];\n}\n[monkSprite runAction:[CCRepeatForever actionWithAction: [CCAnimate actionWithAnimation:animation]]];\n//Add the 'darkness' layer. This simulates darkness in the cave.\ndarknessLayer = [CCRenderTexture renderTextureWithWidth:480 height:320];\ndarknessLayer.position = ccp(240,160);\n[self addChild:darknessLayer z:0 tag:TAG_DARKNESS_LAYER];\n//Schedule physics updates\n[self schedule:@selector(step:)];\nreturn self;\n}\n-(void)step:(ccTime)delta {\nCGSize s = [[CCDirector sharedDirector] winSize];\n//Clear the darkness layer for redrawing. Here we clear it to BLACK with 90% opacity.\n[darknessLayer clear:0.0f g:0.0f b:0.0f a:0.9f];\n//Begin the darkness layer drawing routine. This transforms to the proper location, among other things.\n[darknessLayer begin];\n//Limit drawing to the alpha channel.\nglColorMask(0.0f, 0.0f, 0.0f, 1.0f);\n//Draw the burn sprite only on the alpha channel.\n[burnSprite visit];\n//Reset glColorMask to allow drawing of colors.\nglColorMask(1.0f, 1.0f, 1.0f, 1.0f);\n//Finish transformation.\n[darknessLayer end];\n//Make the monk walk back and forth.\nif(monkSprite.position.x > 480){\nmonkSprite.flipX = YES;\nburnSprite.velocity = ccp(-1,0);\nlightSprite.velocity = ccp(-1,0);\nmonkSprite.velocity = ccp(-1,0);\n}else if(monkSprite.position.x < 0){\nmonkSprite.flipX = NO;\nburnSprite.velocity = ccp(1,0);\nlightSprite.velocity = ccp(1,0);\nmonkSprite.velocity = ccp(1,0);\n}\n//Update our SimpleAnimObjects\n[burnSprite update:delta];\n[lightSprite update:delta];\n[monkSprite update:delta];\n}\n@end\n\n```", "```swift\n[darknessLayer clear:0.0f g:0.0f b:0.0f a:0.9f];\n\n```"]