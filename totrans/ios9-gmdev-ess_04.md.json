["```swift\n//Update() Example\n//From main GameScene.swift\noverride func update(currentTime: CFTimeInterval) {\n        //Update player\n        if(player?.isPlayable==true){\n            player!.update(currentTime)\n        }\n    }\n```", "```swift\noverride func didSimulatePhysics() {\n\n    //run check on Player\n    let block: (SKNode!, UnsafeMutablePointer<ObjCBool>) ->\n\tVoid  = { node, stop in\n        /*checks if the node is the player and is moved/crushed to the left by a physics object.  This is done by comparing the node's position to a position that is, in this case, less than 26% off the left side of the screen; calculated by multiplying the screen's width by 0.26  */\n        if let playerNode = node as? Player{\n            if (playerNode.position.x < self.frame.size.width*0.26 && playerNode.isPlayable) {\n                playerNode.playerHitEdge()\n            }\n\n        }\n\n    }\n\n...more code\n```", "```swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        if let scene = GameScene(fileNamed:\"GameScene\") {\n            // Configure the view.\n            let skView = self.view as! SKView\n            skView.showsFPS = true\n            skView.showsNodeCount = true\n            /* Sprite Kit applies additional optimizations to improve rendering performance */\n            skView.ignoresSiblingOrder = true\n            /* Set the scale mode to scale to fit the window */\n            scene.scaleMode = .AspectFill\n            skView.presentScene(scene)\n        }\n    }\n```", "```swift\nenumerateChildNodesWithName(\"player\", usingBlock: block)\n```", "```swift\nplayerNode.name = \"player\"\n```", "```swift\n  override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    super.touchesBegan(touches, withEvent: event)\n    if let location = touches.first?.locationInNode(self) {\n        let touchedNode = self.nodeAtPoint(location)\n        if touchedNode.name == \"SceneChangeButton\" {\n            let transition = SKTransition.revealWithDirection(SKTransitionDirection.Up, duration: 1.0)\n\n            let scene = AnotherGameScene(size: self.scene!.size)\n            scene.scaleMode = SKSceneScaleMode.AspectFill\n            self.scene!.view!.presentScene(scene, transition: transition)\n        }\n    }\n}\n```", "```swift\n@IBAction func buttonPressed(button:UIButton)\n{\n    // Remove button from the view\n    button.removeFromSuperview()\n    if let scene = GameScene.unarchiveFromFile(\"GameScene\") as? GameScene {\n        // Configure the view.\n        let skView = self.view as SKView\n        skView.showsFPS = false\n        skView.showsNodeCount = false\n\n        //used for optimization of SKView\n        skView.ignoresSiblingOrder = true\n\n        scene.scaleMode = .AspectFill\n        skView.presentScene(scene)\n    }\n}\n```", "```swift\noverride func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent) {\n    /* Called when a touch begins */\n    let introNode = childNodeWithName(\"introNode\")\n\n    if (introNode != nil) {\n        let fadeAway = SKAction.fadeOutWithDuration(1.0)\n\n        introNode?.runAction(fadeAway, completion: {\n            let doors = SKTransition.doorwayWithDuration(1.0)\n            let gameScene = GameScene(fileNamed: \"GameScene\")\n            self.view?.presentScene(gameScene, transition: doors)\n        })\n    }\n}\n```", "```swift\nlet PlayerAtlas = SKTextureAtlas(named:\"Player.atlas\")\n\nlet textures = map(1...4) { number in       \n            PlayerAtlas.textureNamed(\"player_sprite_normal_\\(number)\")\n            } \n            let anim = SKAction.animateWithTextures(textures, timePerFrame: self.animationRefreshRate_)\n            let idleAnimation = SKAction.repeatActionForever(anim)\n            self.runAction(idleAnimation)\n```", "```swift\n\"player_sprite_normal_1\", \"player_sprite_normal_2\", \"player_sprite_normal_3\", \"player_sprite_normal_4\"\n```", "```swift\nSKTextureAtlas.preloadTextureAtlases([PIKIATLAS,BGATLAS,COLLECTABLESATLAS,HUDATLAS, OBSTACLESATLAS])\n{\n  //perform other tasks while loading TextureAtlases\n}\n```", "```swift\nclass Tile{\n    //Properties \n//(1)\n    let row : Int\n    let column : Int \n//(2)    \n    var isTileDown = false\n    var isFlagged = false\n    var isAMine = false\n//(3)\n    //Mines counter\n    var nearbyMines:Int = 0\n//(4)\n    init(row:Int, col: Int){\n        self.row = row\n        self.column = col  \n    }\n}\n```", "```swift\n//(1)\nimport UIKit\nclass MineTileButton : UIButton {\n//(2)\n    var tile:Tile\n    let tileSize:CGFloat\n//(3)\n    init(tileButton:Tile, size:CGFloat) {\n        self.tile = tileButton\n        self.tileSize = size\n\n        let x = CGFloat(self.tile.column) * tileSize\n        let y = CGFloat(self.tile.row) * tileSize\n        let tileBoundingFrame = CGRectMake(x, y, tileSize, tileSize)  \n        super.init(frame: tileBoundingFrame)\n    } \n//(4)\n    required init(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n//(5)\n    //button text;\n    //replace button with an SKSprite for better GUI interface?\n    func getTileLabelText() -> String {\n        if !self.tile.isAMine {\n            if self.tile.nearbyMines == 0 {\n                return \"0\"\n            }else {\n                return \"\\(self.tile.nearbyMines)\"\n            }\n        }\n//(6)\n        return \"ðŸ’¥\"\n    }\n}\n```", "```swift\nvar tiles:[[Tile]] = []\n```", "```swift\n        for row in 0 ..< boardSize_ {\n            var tilesRow:[Tile] = []\n            for col in 0 ..< boardSize_ {\n                let tile = Tile(row: row, col: col)\n                tilesRow.append(tile)\n            }\n            tiles.append(tilesRow)\n        }\n```", "```swift\nfor row in 0 ..< boardSize_ {\n            for column in 0 ..< boardSize_ {\n                self.createRandomMineTiles(tiles[row][column])\n                tiles[row][column].isTileDown = false  \n            }\n        }\n```", "```swift\nfor row in 0 ..< boardSize_ {\n            for column in 0 ..< boardSize_ {\n                self.calculateNearbyMines(tiles[row][column])\n            }\n        }\n```", "```swift\nlet nearbyTileOffsets =     \n   [(-1,-1), //bottom left corner from selected tile\n            (0,-1),  //directly below\n            (1,-1),  //bottom right corner\n            (-1,0),  //directly left\n            (1,0),   //directly right\n            (-1,1),  //top left corner\n            (0,1),   //directly above\n            (1,1)]  //top right corner\n```", "```swift\nfor (rowOffset,columnOffset) in nearbyTileOffsets {\n\n //optional since tiles in the corners/edges could have less than 8 surrounding tiles and thus could have a nil value\n            let ajacentTile:Tile? = getAjacentTileLocation(selectedTile.row+rowOffset, col: selectedTile.column+columnOffset)\n            //if validAjacentTile isn't nil, add the Tile object to the nearby Tile array\n            if let validAjacentTile = ajacentTile {\n                nearbyTiles.append(validAjacentTile)\n            }\n        }\n```", "```swift\nnumOfTappedTilesToWin_ = totalTiles_ - mineCount\n```", "```swift\noverride func didMoveToView(view: SKView){\n        self.backgroundColor = UIColor.whiteColor()\n        stageView_ = view\n        loadInstructions()\n    }\n```", "```swift\noverride func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n       /* Called when a touch begins */\n        for touch in touches {\n            //flag button Pressed\n            if CGRectContainsPoint(flagButton_.frame, touch.locationInNode(self)) {\n                flagButtonPressed()\n            }\n            //instructions removed when tapped\n            if CGRectContainsPoint(instructionsSprite_.frame, touch.locationInNode(self)) && currentGameState_ == .Instructions {\n                removeInstructions()\n            }\n        }\n    }\n```", "```swift\nfunc tileButtonTapped(sender: MineTileButton) {\n        //exit function if not playing the game\n        if (currentGameState_ != .MineTap && currentGameState_ != .FlagPlanting){\n            return\n        }\n        //reveals the underlying tile, only if the game is in the main state, aka MineTap\n        if (!sender.tile.isTileDown && currentGameState_ == .MineTap) {\n            sender.tile.isTileDown = true\n            sender.setTitle(\"\\(sender.getTileLabelText())\", forState: .Normal)\n            //sender.backgroundColor = UIColor.lightGrayColor() \n            //mine HIT!\n            if sender.tile.isAMine {\n                //sender.backgroundColor = UIColor.orangeColor()\n                self.mineHit()\n            }\n            //counts the moves; also used in calculating a win\n            moves_++\n        }\n        else if (!sender.tile.isTileDown && currentGameState_ == .FlagPlanting){  \n            self.flagPlant(sender)\n        } \n    }\n```"]