<html><head></head><body>
		<div id="_idContainer123">
			<h1 id="_idParaDest-92" class="chapter number"><a id="_idTextAnchor312"/><a id="_idTextAnchor313"/><a id="_idTextAnchor314"/><a id="_idTextAnchor315"/><a id="_idTextAnchor316"/>5</h1>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor317"/>Essential Libraries: Retrofit, Moshi, and Glide</h1>
			<p><a id="_idTextAnchor318"/>In this chapter, we will cover the steps needed to present app users with dynamic content fetched from remote servers. You will be introduced to the different libraries required to retrieve and handle this <span class="No-Break">dynamic data.</span></p>
			<p>By the end of this chapter, you will be able to fetch data from a network endpoint using Retrofit, parse JSON payloads into Kotlin data objects using Moshi, and load images into <strong class="source inline">ImageView</strong> <span class="No-Break">using Glide.</span></p>
			<p><a id="_idTextAnchor319"/>In the previous chapter, we learned how to implement navigation in our app. In this chapter, we will learn how to present dynamic content to the user as they navigate around <span class="No-Break">our app.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Introducing REST, API, JSON, <span class="No-Break">and XML</span></li>
				<li>Fetching data from a <span class="No-Break">network endpoint</span></li>
				<li>Parsing a <span class="No-Break">JSON response</span></li>
				<li>Loading images from a <span class="No-Break">remote URL</span></li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor320"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/Uqtjm"><span class="No-Break">https://packt.link/Uqtjm</span></a></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor321"/>Introducing REST, API, JSON, and XML</h1>
			<p>Data<a id="_idIndexMarker427"/> presented<a id="_idIndexMarker428"/> to <a id="_idIndexMarker429"/>users <a id="_idIndexMarker430"/>can come from different sources. It can be hardcoded into an app, but that comes with limitations. To change hardcoded data, we have to publish an update to our app. Some data, such as currency exchange rates, the real-time availability of assets, and the current weather, cannot be hardcoded by its nature. Other data may become outdated, such as the terms of use of <span class="No-Break">an app.</span></p>
			<p>In such cases, you usually fetch the relevant data from a server. One of the most common architectures for serving such data is <strong class="bold">representational state transfer</strong> (<strong class="bold">REST</strong>) architecture. REST architecture is defined by a set of six constraints: client-server architecture, statelessness, cacheability, a layered system, code on demand (optional), and a <span class="No-Break">uniform interface.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">To read more <a id="_idIndexMarker431"/>about REST, <span class="No-Break">visit </span><a href="https://packt.link/YsSRV"><span class="No-Break">https://packt.link/YsSRV</span></a><span class="No-Break">.</span></p>
			<p>When applied to a web service <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), we get a <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>)-based <a id="_idIndexMarker432"/>RESTful API. The HTTP protocol is the foundation of data communication for the World Wide Web, hosted on and accessible via the <strong class="bold">internet</strong>. It is <a id="_idIndexMarker433"/>the protocol used by servers all around the world to serve websites to users in the form of HTML documents, images, style sheets, and <span class="No-Break">so forth.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">An interesting article on this topic can be found <span class="No-Break">at </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview</span></a><span class="No-Break">.</span></p>
			<p>RESTful APIs<a id="_idIndexMarker434"/> rely<a id="_idIndexMarker435"/> on <a id="_idIndexMarker436"/>the <a id="_idIndexMarker437"/>standard HTTP methods – <strong class="source inline">GET</strong>, <strong class="source inline">POST</strong>, <strong class="source inline">PUT</strong>, <strong class="source inline">DELETE</strong>, and <strong class="source inline">PATCH</strong> – to fetch and transform data. These methods allow us to fetch, store, delete, and update data entities on <span class="No-Break">remote servers.</span></p>
			<p>We can rely on the built-in Java <strong class="source inline">HttpURLConnection</strong> class to execute these HTTP methods. Alternatively, we can use a library such as <strong class="source inline">OkHttp</strong>, which offers additional features such as gzipping (compressing and decompressing), redirects, retries, and both synchronous and asynchronous calls. Interestingly, from Android 4.4, <strong class="source inline">HttpURLConnection</strong> is just a wrapper around <strong class="source inline">OkHttp</strong>. If we choose <strong class="source inline">OkHttp</strong>, we might as well go<a id="_idIndexMarker438"/> for <strong class="bold">Retrofit</strong> (as we will in this chapter), the current industry standard. We can then benefit from its type-safety, which is better suited for handling <span class="No-Break">REST calls.</span></p>
			<p>Most commonly, data is represented by <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>). JSON is a text-based data transfer <a id="_idIndexMarker439"/>format. As the name implies, it was derived from JavaScript. However, it has since become one of the most popular standards for data transfer, and its most modern programming languages have libraries that encode or decode data to or <span class="No-Break">from JSON.</span></p>
			<p>A simple JSON payload may look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
{"employees":[
  {"name": "James", "email": "james.notmyemail@gmail.com"},
  {"name": "Lea", "email": "lea.dontemailme@gmail.com"}
]}</pre>
			<p>Another common data structure used by RESTful services is <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>), which<a id="_idIndexMarker440"/> encodes documents in a format that is human- and machine-readable. XML is considerably more verbose than JSON. The<a id="_idIndexMarker441"/> same data structure as the previous <a id="_idIndexMarker442"/>in XML<a id="_idIndexMarker443"/> would<a id="_idIndexMarker444"/> look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
&lt;employees&gt;
    &lt;employee&gt;
        &lt;name&gt;James&lt;/name&gt;
        &lt;email&gt;james.notmyemail@gmail.com&lt;/email&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
        &lt;name&gt;Lea&lt;/name&gt;
        &lt;email&gt;lea.dontemailme@gmail.com&lt;/email&gt;
    &lt;/employee&gt;
&lt;/employees&gt;</pre>
			<p>In this chapter, we will focus <span class="No-Break">on JSON.</span></p>
			<p>When obtaining a JSON payload, we essentially receive a string. To convert that string into a data object, we have a few options, the most popular ones being libraries such as <strong class="bold">GSON</strong>, <strong class="bold">Jackson</strong>, and <strong class="bold">Moshi</strong>, as well as the built-in <strong class="source inline">org.json</strong> package. For its <a id="_idIndexMarker445"/>lightweight <a id="_idIndexMarker446"/>nature, we<a id="_idIndexMarker447"/> will focus <span class="No-Break">on Moshi.</span></p>
			<p>Finally, we will look into loading images from the web. Doing so will allow us to provide up-to-date images and load the right images for the user’s device. It will also let us only load the images<a id="_idIndexMarker448"/> when <a id="_idIndexMarker449"/>we <a id="_idIndexMarker450"/>need <a id="_idIndexMarker451"/>them, thus keepi<a id="_idTextAnchor322"/><a id="_idTextAnchor323"/>ng our APK <span class="No-Break">size smaller.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor324"/>Fetching data from a network endpoint</h1>
			<p>For the <a id="_idIndexMarker452"/>purpose <a id="_idIndexMarker453"/>of this section, we will use The Cat API (<a href="https://thecatapi.com/">https://thecatapi.com/</a>). This RESTful API offers us vast data <span class="No-Break">about, well…cats.</span></p>
			<p>To get started, we will create a new project. We then have to grant our app internet access permission. This is done by adding the following code to your <strong class="source inline">AndroidManifest.xml</strong> file right before the <span class="No-Break"><strong class="source inline">Application</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="source code">
&lt;uses-permission
    android:name="android.permission.INTERNET" /&gt;</pre>
			<p>Next, we need to set up our app to include Retrofit. Retrofit is a type-safe library provided by Square, which is built on top of the <strong class="source inline">OkHttp</strong> HTTP client. Retrofit helps us generate <strong class="bold">Uniform Resource Locators</strong> (<strong class="bold">URLs</strong>), which are the addresses of the server<a id="_idIndexMarker454"/> endpoints we want to access. It also makes the decoding of JSON payloads easier by providing integration with several parsing libraries. Sending data to the server is also easier with Retrofit, as it helps with encoding <span class="No-Break">the requests.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">You can read more <a id="_idIndexMarker455"/>about Retrofit <span class="No-Break">here </span><a href="https://square.github.io/retrofit/"><span class="No-Break">https://square.github.io/retrofit/</span></a><span class="No-Break">.</span></p>
			<p>To add Retrofit to our project, we need to add the following code to the <strong class="source inline">dependencies</strong> block of the <strong class="source inline">build.gradle</strong> file of <span class="No-Break">our app:</span></p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:retrofit:(insert latest version)'</pre>
			<p class="callout heading">Note</p>
			<p class="callout">You can find the latest version <span class="No-Break">here </span><a href="https://github.com/square/retrofit"><span class="No-Break">https://github.com/square/retrofit</span></a><span class="No-Break">.</span></p>
			<p>With Retrofit included in our project, we can proceed to set <span class="No-Break">it up.</span></p>
			<p>First, to access an HTTP(S) endpoint, we start by defining the contract with that endpoint. A contract to access the <strong class="source inline">https://api.thecatapi.com/v1/images/search</strong> endpoint looks <span class="No-Break">like this:</span></p>
			<pre class="source code">
interface TheCatApiService {
    @GET("images/search")
    fun searchImages(
        @Query("limit") limit: Int,
        @Query("size") format: String
    ): Call&lt;String&gt;
}</pre>
			<p>There are <a id="_idIndexMarker456"/>a <a id="_idIndexMarker457"/>few things to note here. First, you will notice that the contract is implemented as an interface. This is how you define contracts for Retrofit. Next, you will notice that the name of the interface implies that this interface can, eventually, cover all calls made <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">TheCatAPIService</strong></span><span class="No-Break">.</span></p>
			<p>It is a bit unfortunate that Square chose <strong class="source inline">Service</strong> as the conventional suffix for these contracts, as the term service has a different meaning in the Android world, as you will see in <a href="B19411_08.xhtml#_idTextAnchor471"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Services, WorkManager, and Notifications</em>. Nevertheless, this is <span class="No-Break">the convention.</span></p>
			<p>To define our endpoint, we start by stating the method with which the call will be made using the appropriate annotation—in our case, <strong class="source inline">@GET</strong>. The parameter passed to the annotation is the path of the endpoint to access. You’ll notice that <strong class="source inline">https://api.thecatapi.com/v1/</strong> is stripped from <span class="No-Break">that path.</span></p>
			<p>That is because this is the common address for all of the endpoints of <strong class="source inline">TheCatAPI</strong>, and so it will be passed to our Retrofit instance at construction time instead. Next, we choose a meaningful name for our function—in this case, we'll call the image search endpoint, so <strong class="source inline">searchImages</strong> seems appropriate. The parameters of the <strong class="source inline">searchImages</strong> function define the values we can pass to the API when we make <span class="No-Break">the calls.</span></p>
			<p>There are different ways in which we can transfer data to the API. <strong class="source inline">@Query</strong> allows us to define values added to the query of our request URL (that’s the optional part of the URL that comes after the question mark). It takes a key-value pair (in our case, we have <strong class="source inline">limit</strong> and <strong class="source inline">size</strong>) and a data type. If the data type is not a string, the value of that type will be transformed into a string. Any value passed will be URL-encoded <span class="No-Break">for us.</span></p>
			<p>Another such way is using <strong class="source inline">@Path</strong>. This annotation can be used to replace a token in our path wrapped in curly brackets with a provided value. The <strong class="source inline">@Header</strong>, <strong class="source inline">@Headers</strong>, and <strong class="source inline">@HeaderMap</strong> annotations will allow us to add or remove HTTP headers from the request. <strong class="source inline">@Body</strong> can be used to pass content in the body of the <strong class="source inline">POST</strong> and <span class="No-Break"><strong class="source inline">PUT</strong></span><span class="No-Break"> requests.</span></p>
			<p>Lastly, we have <a id="_idIndexMarker458"/>a<a id="_idIndexMarker459"/> return type. To keep things simple at this stage, we will accept the response as a string. We wrapped our string in a <strong class="source inline">Call</strong> interface. <strong class="source inline">Call</strong> is Retrofit’s mechanism for executing network requests synchronously (via <strong class="source inline">execute()</strong>) or asynchronously (via <strong class="source inline">enqueue(Callback)</strong>). When using coroutines, we can make the function a <strong class="source inline">suspend</strong> function and omit the <strong class="source inline">Call</strong> wrapper (see <a href="B19411_14.xhtml#_idTextAnchor751"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><em class="italic">, Coroutines and Flow</em>, for more information <span class="No-Break">on coroutines).</span></p>
			<p>With our contract defined, we can get Retrofit to implement our <span class="No-Break">service interface:</span></p>
			<pre class="source code">
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.thecatapi.com/v1/").build()
val theCatApiService =
    retrofit.create(TheCatApiService::class.java)</pre>
			<p>If we try to run our app with this code, our app will crash with an <strong class="source inline">IllegalArgumentException</strong>. This is because Retrofit needs us to tell the app how to process the server response to a string. This processing is done with what Retrofit calls <strong class="bold">converters</strong>. To set a <strong class="source inline">ConverterFactory</strong> instance to our <strong class="source inline">retrofit</strong> instance, we <a id="_idIndexMarker460"/>need to add <span class="No-Break">the following:</span></p>
			<pre class="source code">
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.thecatapi.com/v1/")
<strong class="bold">    .addConverterFactory(ScalarsConverterFactory.create())</strong>
    .build()</pre>
			<p>For our project to recognize <strong class="source inline">ScalarsConverterFactory</strong>, we need to update our app’s <strong class="source inline">build.gradle</strong> file by adding <span class="No-Break">another dependency:</span></p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:converter-scalars:(insert latest version)'</pre>
			<p>Now, we can obtain a <strong class="source inline">Call</strong> instance by calling <strong class="source inline">val call = theCatApiService.searchImages(1, "full")</strong>. With the instance obtained in this fashion, we can execute an async request by <span class="No-Break">calling </span><span class="No-Break"><strong class="source inline">call.enqueue(Callback)</strong></span><span class="No-Break">.</span></p>
			<p>Our <strong class="source inline">Callback</strong> implementation will have two methods: <strong class="source inline">onFailure(Call, Throwable)</strong> and <strong class="source inline">onResponse(Call, Response)</strong>. Note that we are not guaranteed to have a successful response if <strong class="source inline">onResponse</strong> is called. <strong class="source inline">onResponse</strong> is called whenever we successfully receive <em class="italic">any</em> response from the server, and no unexpected <span class="No-Break">exception occurs.</span></p>
			<p>So, to confirm that the response is successful, we should check the <strong class="source inline">response.isSuccessful</strong> property. The <strong class="source inline">onFailure</strong> function will be called in the case of a network error or an unexpected exception somewhere along <span class="No-Break">the way.</span></p>
			<p>So, where <a id="_idIndexMarker461"/>should <a id="_idIndexMarker462"/>we implement the Retrofit code? In clean architecture, data is provided by repositories. Repositories, in turn, have data sources. One such data source can be a network data source. This is where we will implement our network calls. Our ViewModels will then request data from repositories via <span class="No-Break">use cases.</span></p>
			<p>In the <a id="_idIndexMarker463"/>case of <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>), the ViewModel is an abstraction of the view that exposes properties <span class="No-Break">and commands.</span></p>
			<p>For our implementation, we will simplify the process by instantiating Retrofit and the service in the Activity. This is not good practice. <em class="italic">Do not do this in a production app</em>. It does not scale<a id="_idIndexMarker464"/> well<a id="_idIndexMarker465"/> and is very difficult to test. Instead, adopt an architecture that decouples your views from your business logic and your data. See <a href="B19411_15.xhtml#_idTextAnchor789"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, <a id="_idTextAnchor325"/><a id="_idTextAnchor326"/><em class="italic">Architecture Patterns</em>, for <span class="No-Break">some ideas.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor327"/>Exercise 5.01 – reading data from an API</h2>
			<p>In the <a id="_idIndexMarker466"/>following chapters, we <a id="_idIndexMarker467"/>will develop an app for an imaginary secret agency with a worldwide network of agents saving the world from countless dangers. The secret agency in question is quite unique: it operates secret <span class="No-Break">cat agents.</span></p>
			<p>In this exercise, we will create an app that presents us with one random secret cat agent from The Cat API. Before you can present data from an API to your user, you first must fetch that data. Let’s start with <span class="No-Break">that here:</span></p>
			<ol>
				<li>Create a new <strong class="bold">Empty Activity</strong> project (<strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">New Project</strong> | <strong class="bold">Empty Activity</strong>). <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
				<li>Name your application <strong class="source inline">Cat </strong><span class="No-Break"><strong class="source inline">Agent Profile</strong></span><span class="No-Break">.</span></li>
				<li>Make sure your package name <span class="No-Break">is </span><span class="No-Break"><strong class="source inline">com.example.catagentprofile</strong></span><span class="No-Break">.</span></li>
				<li>Set <strong class="bold">Save location</strong> to where you want to save <span class="No-Break">your project.</span></li>
				<li>Leave everything else at its default values and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></li>
				<li>Make sure you are on<a id="_idTextAnchor328"/> the <strong class="bold">Android</strong> view in your <span class="No-Break"><strong class="bold">Project</strong></span><span class="No-Break"> pane:</span></li>
			</ol>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B19411_05_01.jpg" alt="Figure 5.1 – The Android view in the Project pane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The Android view in the Project pane</p>
			<ol>
				<li value="7">Open <a id="_idIndexMarker468"/>your <strong class="source inline">AndroidManifest.xml</strong> file. Add<a id="_idIndexMarker469"/> internet permissions to your app <span class="No-Break">like so:</span><pre class="source code">
&lt;manifest xmlns:android=
    "http://schemas.android.com/apk/res/android"
    package="com.example.catagentprofile"&gt;
<strong class="bold">    &lt;uses-permission</strong>
<strong class="bold">    android:name="android.permission.INTERNET" /&gt;</strong>
    &lt;application ...&gt; ... &lt;/application&gt;
&lt;/manifest&gt;</pre></li>
				<li>To add Retrofit and the scalars converter to your app, open the <strong class="source inline">build.gradle</strong> app module, (<strong class="source inline">Gradle Scripts</strong> | <strong class="source inline">build.gradle (Module: app)</strong>), and add the following lines anywhere inside the <span class="No-Break"><strong class="source inline">dependencies</strong></span><span class="No-Break"> block:</span><pre class="source code">
dependencies {
    ...
    implementation
        'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:
        converter-scalars:2.9.0'
    ...
}</pre></li>
			</ol>
			<p>Your <strong class="source inline">dependencies</strong> block should now look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib
        :$kotlin_version"
    ...
<strong class="bold">    implementation</strong>
<strong class="bold">        'com.squareup.retrofit2:retrofit:2.9.0'</strong>
<strong class="bold">    implementation 'com.squareup.retrofit2:</strong>
<strong class="bold">        converter-scalars:2.9.0'</strong>
    ...
}</pre>
			<p>Between <a id="_idIndexMarker470"/>the <a id="_idIndexMarker471"/>time of writing and when you carry out this exercise, some dependencies may have changed. You should still only add the lines in bold from the preceding code block. These will add Retrofit and support for reading server responses as <span class="No-Break">single strings.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">It is worth noting that Retrofit now requires, as a minimum, Android API 21 or <span class="No-Break">Java 8.</span></p>
			<ol>
				<li value="9">Click the <strong class="bold">Sync Project with Gradle Files</strong> button in <span class="No-Break">Android Studio.</span></li>
				<li>Open your <strong class="source inline">activity_main.xml</strong> file in the <span class="No-Break"><strong class="bold">Text</strong></span><span class="No-Break"> mode.</span></li>
				<li>To be able to use your label to present the latest server response, you need to assign an ID <span class="No-Break">to it:</span><pre class="source code">
&lt;TextView
<strong class="bold">    android:id="@+id/main_server_response"</strong>
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    ... /&gt;</pre></li>
				<li>In the <strong class="bold">Project</strong> pane on the left, right-click on your app package (<strong class="source inline">com.example.catagentprofile</strong>), then select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Package</strong></span><span class="No-Break">.</span></li>
				<li>Name your <span class="No-Break">package </span><span class="No-Break"><strong class="source inline">api</strong></span><span class="No-Break">.</span></li>
				<li>Now, right-click on the newly created package (<strong class="source inline">com.example.catagentprofile.api</strong>), then select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Kotlin File/Class</strong></span><span class="No-Break">.</span></li>
				<li>Name <a id="_idIndexMarker472"/>your <a id="_idIndexMarker473"/>new file <strong class="source inline">TheCatApiService</strong>. For <strong class="bold">Kind</strong>, <span class="No-Break">choose </span><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break">.</span></li>
				<li>Add the following to the <span class="No-Break"><strong class="source inline">interface</strong></span><span class="No-Break"> block:</span><pre class="source code">
interface TheCatApiService {
<strong class="bold">    @GET("images/search")</strong>
<strong class="bold">    fun searchImages(</strong>
<strong class="bold">        @Query("limit") limit: Int,</strong>
<strong class="bold">        @Query("size") format: String</strong>
<strong class="bold">    ) : Call&lt;String&gt;</strong>
}</pre></li>
			</ol>
			<p>This defines the image search endpoint. Make sure to import all the required <span class="No-Break">Retrofit dependencies.</span></p>
			<ol>
				<li value="17">Open your <span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break"> file.</span></li>
				<li>At the top of the <strong class="source inline">MainActivity</strong> class block, add <span class="No-Break">the following:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
<strong class="bold">    private val retrofit by lazy {</strong>
<strong class="bold">        Retrofit.Builder()</strong>
<strong class="bold">            .baseUrl("https://api.thecatapi.com/v1/")</strong>
<strong class="bold">            .addConverterFactory(</strong>
<strong class="bold">                ScalarsConverterFactory.create()</strong>
<strong class="bold">            ).build()</strong>
<strong class="bold">    }</strong>
<strong class="bold">    private val theCatApiService by lazy {</strong>
<strong class="bold">        retrofit.create(TheCatApiService::class.java)</strong>
<strong class="bold">    }</strong>
    ...
}</pre></li>
			</ol>
			<p>This will<a id="_idIndexMarker474"/> instantiate <a id="_idIndexMarker475"/>Retrofit and the API service. We use <strong class="source inline">lazy</strong> to make sure the instances are only created <span class="No-Break">when needed.</span></p>
			<ol>
				<li value="19">Add <strong class="source inline">serverResponseView</strong> as <span class="No-Break">a field:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
<strong class="bold">    private val serverResponseView: TextView by lazy {</strong>
<strong class="bold">        findViewById(R.id.main_server_response)</strong>
<strong class="bold">    }</strong></pre></li>
			</ol>
			<p>This will look up the view with the <strong class="source inline">main_server_response</strong> ID the first time <strong class="source inline">serverResponseView</strong> is accessed and then keep a reference <span class="No-Break">to it.</span></p>
			<ol>
				<li value="20">Now, add the <strong class="source inline">getCatImageResponse()</strong> function <a id="_idIndexMarker476"/>after<a id="_idIndexMarker477"/> the <span class="No-Break"><strong class="source inline">onCreate(Bundle?)</strong></span><span class="No-Break"> function:</span><pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
  ...
}
<strong class="bold">private fun getCatImageResponse() {</strong>
<strong class="bold">  val call = theCatApiService.searchImages(1,</strong>
<strong class="bold">    "full")</strong>
<strong class="bold">  call.enqueue(object : Callback&lt;String&gt; {</strong>
<strong class="bold">    override fun onFailure(call: Call&lt;String&gt;, t:</strong>
<strong class="bold">    Throwable) {</strong>
<strong class="bold">      Log.e("MainActivity", "Failed to get</strong>
<strong class="bold">      search results", t)</strong>
<strong class="bold">    }</strong>
<strong class="bold">    override fun onResponse(</strong>
<strong class="bold">      call: Call&lt;String&gt;, response: Response&lt;String&gt;</strong>
<strong class="bold">    ) {</strong>
<strong class="bold">      if (response.isSuccessful) {</strong>
<strong class="bold">        serverResponseView.text = response.body()</strong>
<strong class="bold">            } else {</strong>
<strong class="bold">        Log.e(</strong>
<strong class="bold">          "MainActivity",</strong>
<strong class="bold">          "Failed to get search results\n${</strong>
<strong class="bold">            response.errorBody()?.string().orEmpty()</strong>
<strong class="bold">          }"</strong>
<strong class="bold">        )</strong>
<strong class="bold">      }</strong>
<strong class="bold">    }</strong>
<strong class="bold">  })</strong>
}</pre></li>
			</ol>
			<p>This function will fire off the search request and handle the possible outcomes—a successful response, an error response, and any other <span class="No-Break">thrown exception.</span></p>
			<ol>
				<li value="21">Invoke<a id="_idIndexMarker478"/> a <a id="_idIndexMarker479"/>call to <strong class="source inline">getCatImageResponse()</strong> in <strong class="source inline">onCreate()</strong>. This will trigger the call as soon as the activity <span class="No-Break">is created:</span><pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
    ...
    getCatImageResponse()
}</pre></li>
				<li>Add the <span class="No-Break">missing imports.</span></li>
				<li>Run your app by clicking the <strong class="bold">Run ‘app’</strong> button or pressing <em class="italic">Ct<a id="_idTextAnchor329"/>rl</em> + <em class="italic">R</em>. On the emulator, it should look <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B19411_05_02.jpg" alt="Figure 5.2 – The app presenting the server response JSON"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The app presenting the server response JSON</p>
			<p>Because every time you run your app, a new call is made, and a random response is returned, your <a id="_idIndexMarker480"/>result <a id="_idIndexMarker481"/>will likely differ. However, whatever your result, if successful, it should be a JSON payload. Next, we will learn how to parse tha<a id="_idTextAnchor330"/><a id="_idTextAnchor331"/>t JSON payload and extract the data we want <span class="No-Break">from it.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor332"/>Parsing a JSON response</h1>
			<p>Now that we have<a id="_idIndexMarker482"/> successfully retrieved a JSON response from an API, it is time to learn how to use the data we have obtained. To do so, we need to parse the JSON payload. This is because the payload is a plain string representing the data object, and we are interested in the specific properties of that object. If you look closely at <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em>, you may notice that the JSON contains breed information, an image URL, and some other bits of information. However, for our code to use that information, first, we must <span class="No-Break">extract it.</span></p>
			<p>As mentioned in the introduction, multiple libraries exist that will parse a JSON payload for us. The most popular ones are Google’s GSON (see <a href="https://github.com/google/gson">https://github.com/google/gson</a>) and, more recently, Square’s Moshi<span class="superscript">  </span>(see <a href="https://github.com/square/moshi">https://github.com/square/moshi</a>). Moshi is very lightweight, which is why we have chosen to use it in <span class="No-Break">this chapter.</span></p>
			<p>What do JSON libraries do? Basically, they help us convert data classes into JSON strings (serialization) and vice versa (deserialization). This helps us communicate with servers that understand JSON strings while allowing us to use meaningful data structures in <span class="No-Break">our code.</span></p>
			<p>To use Moshi with Retrofit, we need to add the Moshi Retrofit converter to our project. This is done by adding the following line to the <strong class="source inline">dependencies</strong> block of our app’s <span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:converter-moshi:2.9.0'</pre>
			<p>Since we will no longer the responses as strings, we can go ahead and remove the scalars Retrofit converter. Next, we need to create a data class to map the server JSON response to. One convention is to suffix the names of API response data classes with <strong class="source inline">Data</strong>—so we’ll call our data class <strong class="source inline">ImageResultData</strong>. Another common suffix <span class="No-Break">is </span><span class="No-Break"><strong class="source inline">Entity</strong></span><span class="No-Break">.</span></p>
			<p>When we design our server response data classes, we need to take two factors into account: the structure of the JSON response and our data requirements. The first will affect our data types and field names, while the second will allow us to omit fields we do not currently need. JSON libraries ignore data in fields we have not defined in our <span class="No-Break">data classes.</span></p>
			<p>One more thing JSON libraries do for us is automatically map JSON data to fields if they happen to have the exact same name. While this is a nice feature, it carries risk. If we rely solely on it, our data classes (and the code accessing them) will be tightly coupled to the <span class="No-Break">API naming.</span></p>
			<p>Because not all APIs are designed well, you might end up with meaningless field names, such as <strong class="source inline">fn</strong> or <strong class="source inline">last</strong>, or inconsistent naming. Luckily, there is a solution to this problem. Moshi provides us with an <strong class="source inline">@Json</strong> annotation. It can be used to map a JSON field name to a meaningful <span class="No-Break">field name:</span></p>
			<pre class="source code">
data class UserData(
    @field:Json(name = "fn") val firstName: String,
    @field:Json(name = "last") val lastName: String
)</pre>
			<p>The <strong class="source inline">field:</strong> prefix is used to ensure the generated Java field is <span class="No-Break">annotated correctly.</span></p>
			<p>Some consider it better practice to include the annotation even when the API name is the same as the field name for the sake of consistency. We prefer the conciseness of direct conversion when the field name is clear enough. This approach can be challenged when obfuscating our code. If we do, we must either exclude our data classes or make sure to annotate <span class="No-Break">all fields.</span></p>
			<p>While we are not always lucky enough to have properly documented APIs, when we do, it is best to consult the documentation when designing our model. Our model would be a data class into which the JSON data from all calls we make will be decoded. The documentation for the image search endpoint of The Cat API can be found <span class="No-Break">at </span><a href="https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/"><span class="No-Break">https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/</span></a><span class="No-Break">.</span></p>
			<p>You will often<a id="_idIndexMarker483"/> find documentation is or inaccurate. If this happens to be the case, the best thing you can do is contact the owners of the API and request that they update the documentation. You may have to resort to experimenting with an endpoint, unfortunately. This is risky because undocumented fields or structures are not guaranteed to remain the same, so when possible, try and get the <span class="No-Break">documentation updated.</span></p>
			<p>Based on the response schema obtained from the preceding link, we can define our model <span class="No-Break">as follows:</span></p>
			<pre class="source code">
data class ImageResultData(
    @field:Json(name = "url") val imageUrl: String,
    val breeds: List&lt;CatBreedData&gt;
)
data class CatBreedData(
    val name: String,
    val temperament: String
)</pre>
			<p>Note that the response structure is that of a list of results. This means we need our responses mapped to <strong class="source inline">List&lt;ImageResultData&gt;</strong>, not simply <strong class="source inline">ImageResultData</strong>. Now, we need to update <strong class="source inline">TheCatApiService</strong>. Instead of <strong class="source inline">Call&lt;String&gt;</strong>, we can now <span class="No-Break">have </span><span class="No-Break"><strong class="source inline">Call&lt;List&lt;ImageResultData&gt;&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Next, we need to update the construction of our Retrofit instance. Instead of <strong class="source inline">ScalarsConverterFactory</strong>, we will now have <strong class="source inline">MoshiConverterFactory</strong>. Lastly, we need to update our callback <a id="_idIndexMarker484"/>since it should no longer handle string calls but <span class="No-Break"><strong class="source inline">List&lt;ImageResultData&gt;</strong></span><span class="No-Break"> instead:</span></p>
			<pre class="source code">
@GET("images/search")
fun searchImages(
    @Query("limit") limit: Int,
    @Quer<a id="_idTextAnchor333"/><a id="_idTextAnchor334"/>y("size") format: String
) : Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;</pre>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor335"/>Exercise 5.02 – extracting the image URL from the API response</h2>
			<p>So, we have <a id="_idIndexMarker485"/>a server response as a string. Now, we<a id="_idIndexMarker486"/> want to extract the image URL from that string and present only that URL on <span class="No-Break">the screen:</span></p>
			<ol>
				<li>Open the app’s <strong class="source inline">build.gradle</strong> file and replace the scalars converter implementation with a Moshi <span class="No-Break">converter one:</span><pre class="source code">
implementation 'com.squareup.retrofit2: retrofit:2.9.0'
<strong class="bold">implementation 'com.squareup.retrofit2: </strong>
<strong class="bold">converter-moshi:2.9.0'</strong>
testImplementation 'junit:junit:4.13.2'</pre></li>
				<li>Click the <strong class="bold">Sync Project with Gradle </strong><span class="No-Break"><strong class="bold">Files</strong></span><span class="No-Break"> button.</span></li>
				<li>Under your app package (<strong class="source inline">com.example.catagentprofile</strong>), create a <span class="No-Break"><strong class="source inline">model</strong></span><span class="No-Break"> package.</span></li>
				<li>Within the <strong class="source inline">com.example.catagentprofile.model</strong> package, create a new Kotlin file <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">CatBreedData</strong></span><span class="No-Break">.</span></li>
				<li>Populate the newly created file with <span class="No-Break">the following:</span><pre class="source code">
package com.example.catagentprofile.model
<strong class="bold">data class CatBreedData(</strong>
<strong class="bold">    val name: String,</strong>
<strong class="bold">    val temperament: String</strong>
)</pre></li>
				<li>Next, create <strong class="source inline">ImageResultData</strong> under<a id="_idIndexMarker487"/> the<a id="_idIndexMarker488"/> <span class="No-Break">same package.</span></li>
				<li>Set its contents to <span class="No-Break">the following:</span><pre class="source code">
package com.example.catagentprofile.model
import com.squareup.moshi.Json
<strong class="bold">data class ImageResultData(</strong>
<strong class="bold">    @field:Json(name = "url") val imageUrl: String,</strong>
<strong class="bold">    val breeds: List&lt;CatBreedData&gt;</strong>
)</pre></li>
				<li>Open the <strong class="source inline">TheCatApiService</strong> file and update the <strong class="source inline">searchImages</strong> <span class="No-Break">return type:</span><pre class="source code">
    @GET("images/search")
    fun searchImages(
        @Query("limit") limit: Int,
        @Query("size") format: String
    ) : Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;</pre></li>
				<li>Lastly, <span class="No-Break">open </span><span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break">.</span></li>
				<li>Update the Retrofit initialization block to use the Moshi converter to <span class="No-Break">deserialize JSON:</span><pre class="source code">
    private val retrofit by lazy {
        Retrofit.Builder()
        .baseUrl("https://api.thecatapi.com/v1/")
        .addConverterFactory(<strong class="bold">MoshiConverterFactor</strong>
<strong class="bold">        </strong>.create())
        .build()
    }</pre></li>
				<li>Update<a id="_idIndexMarker489"/> the <strong class="source inline">getCatImageResponse()</strong> function <a id="_idIndexMarker490"/>to handle the <strong class="source inline">List&lt;ImageResultData&gt;</strong> requests <span class="No-Break">and responses:</span><pre class="source code">
private fun getCatImageResponse() {
  val call = theCatApiService.searchImages(1, "full")
  call.enqueue(object : Callback&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt; {
    override fun onFailure(
      call: Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;,
      t: Throwable) {
      Log.e("MainActivity", "Failed to get search 
      results", t)
      }
      override fun onResponse(
        call: Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;,
        response: Response&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;
      ) {
        if (response.isSuccessful) {
<strong class="bold">          val imageResults = response.body()</strong>
<strong class="bold">          val firstImageUrl =</strong>
<strong class="bold">            imageResults?.firstOrNull()?</strong>
<strong class="bold">            .imageUrl ?: "No URL"</strong>
<strong class="bold">          serverResponseView.text =</strong>
<strong class="bold">            "Image URL: $firstImageUrl"</strong>
        } else {
          Log.e("MainActivity", "Failed to get search 
          results\n${response.errorBody()?.string().orEmpty()}"
        )
      }
    }
  })
}</pre></li>
				<li>Now, you<a id="_idIndexMarker491"/> need to check for a successful <a id="_idIndexMarker492"/>response and that there is at least one <strong class="source inline">ImageResultData</strong> instance. You can then read the <strong class="source inline">imageUrl</strong> property of that instance and present it to <span class="No-Break">the user.</span><a id="_idTextAnchor336"/></li>
				<li>Run your app. It should now look something like <span class="No-Break">the following:</span></li>
			</ol>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B19411_05_03.jpg" alt="Figure 5.3 – The app presenting the parsed image URL"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The app presenting the parsed image URL</p>
			<ol>
				<li value="14">Again, due to the random nature of the API responses, your URL will likely <span class="No-Break">be different.</span></li>
			</ol>
			<p>You have <a id="_idIndexMarker493"/>now <a id="_idIndexMarker494"/>successfully extracted a specific property from an API response. Next, we will le<a id="_idTextAnchor337"/><a id="_idTextAnchor338"/>arn how to load the image from the URL provided to us by <span class="No-Break">the API.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor339"/>Loading images from a remote URL</h1>
			<p>We just<a id="_idIndexMarker495"/> learned <a id="_idIndexMarker496"/>how to extract data from an API response. That data often includes URLs to images we want to present to the user. There is quite a bit of work involved in achieving that. First, you must fetch the image as a binary stream from the URL. Then, you need to transform that binary stream into an image (it could be a GIF, JPEG, or one of a few other <span class="No-Break">image formats).</span></p>
			<p>Then, you need to convert it into a bitmap instance, potentially resizing it to use less memory. You may also want to apply other transformations to it at that point. Then, you need to set it <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">ImageView</strong></span><span class="No-Break">.</span></p>
			<p>Sounds like a lot of work, doesn’t it? Well, luckily for us, there are a few libraries that do all of that (and more) for us. The most <a id="_idIndexMarker497"/>commonly <a id="_idIndexMarker498"/>used libraries are Square’s <strong class="bold">Picasso</strong> (see <a href="https://square.github.io/picasso/">https://square.github.io/picasso/</a>) and <strong class="bold">Glide</strong> by Bump<a id="_idIndexMarker499"/> Technologies<span class="superscript"> </span>(see <a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a>). Facebook’s <strong class="bold">Fresco</strong> (see <a href="https://frescolib.org/">https://frescolib.org/</a>) is somewhat less popular. A library that’s gained traction recently is <strong class="bold">Coil</strong> (<span class="No-Break">see </span><a href="https://coil-kt.github.io/coil/"><span class="No-Break">https://coil-kt.github.io/coil/</span></a><span class="No-Break">).</span></p>
			<p>We will proceed with Glide because it is consistently the fastest of the two popular options for loading images, whether from the internet or the cache. However, it’s worth noting that Picasso is more lightweight, so it is a trade-off, and both libraries are <span class="No-Break">quite useful.</span></p>
			<p>To include Glide<a id="_idIndexMarker500"/> in <a id="_idIndexMarker501"/>your project, add it to the <strong class="source inline">dependencies</strong> block of your app’s <span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
dependencies {
    <strong class="bold">implementation 'com.github.bumptech.glide:glide:4.14.2'</strong>
    ...
}</pre>
			<p>In fact, because we might change our minds at a later point, this is a great opportunity to abstract away the concrete library to have a simpler interface of our own. So, let’s start by defining our <span class="No-Break"><strong class="source inline">ImageLoader</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source code">
interface ImageLoader {
    fun loadImage(imageUrl: String, imageView: ImageView)
}</pre>
			<p>This is a naïve implementation. In a production implementation, you might want to add arguments (or multiple functions) to support options such as different cropping strategies or <span class="No-Break">loading states.</span></p>
			<p>Our implementation of the interface will rely on Glide, so it will look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
class GlideImageLoader(private val context: Context) : ImageLoader {
    override fun loadImage(imageUrl: String, imageView:
    ImageView) {
        Glide.with(context)
            .load(imageUrl).centerCrop().into(imageView)
    }
}</pre>
			<p>We prefix our class name with <strong class="source inline">Glide</strong> to differentiate it from other potential implementations. Constructing <strong class="source inline">GlideImageLoader</strong> with <strong class="source inline">context</strong> allows us to implement the clean <strong class="source inline">loadImage(String, ImageView)</strong> interface without having to worry about the context, which Glide requires for <span class="No-Break">image loading.</span></p>
			<p>In fact, Glide<a id="_idIndexMarker502"/> is<a id="_idIndexMarker503"/> smart about the Android context. That means we could have separate implementations for the <strong class="source inline">Activity</strong> and <strong class="source inline">Fragment</strong> scopes, and Glide would know when an image-loading request went beyond the <span class="No-Break">relevant scope.</span></p>
			<p>Since we haven’t yet added an <strong class="source inline">ImageView</strong> to our layout, let’s do <span class="No-Break">that now:</span></p>
			<pre class="source code">
&lt;TextView
    ...
    app:layout_constraintBottom<strong class="bold">_toTopOf="@+id/</strong>
<strong class="bold">    main_profile_image"</strong>
    ... /&gt;
<strong class="bold">&lt;ImageView</strong>
<strong class="bold">    android:id="@+id/main_profile_image"</strong>
<strong class="bold">    android:layout_width="150dp"</strong>
<strong class="bold">    android:layout_height="150dp"</strong>
<strong class="bold">    app:layout_constraintBottom_toBottomOf="parent"</strong>
<strong class="bold">    </strong><strong class="bold">app:layout_constraintEnd_toEndOf="parent"</strong>
<strong class="bold">    app:layout_constraintStart_toStartOf="parent"</strong>
<strong class="bold">    app:layout_constraintTop_toBottomOf="@+id/</strong>
<strong class="bold">    main_server_response" /&gt;</strong></pre>
			<p>This will add an <strong class="source inline">ImageView</strong> with an ID of <strong class="source inline">main_profile_image</strong> below <span class="No-Break">our </span><span class="No-Break"><strong class="source inline">TextView</strong></span><span class="No-Break">.</span></p>
			<p>We can now create an instance of <strong class="source inline">GlideImageLoader</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
private val imageLoader: ImageLoader by lazy {
    GlideImageLoader(this) }</pre>
			<p>In a production app, you would inject the dependency, rather than creating <span class="No-Break">it inline.</span></p>
			<p>Next, we tell our Glide loader to load the image and, once loaded, center-crop it inside the provided <strong class="source inline">ImageView</strong>. This means the image will be scaled up or down to fully fill the <strong class="source inline">ImageView</strong>, with any excess content cut off (cropped). Since we already obtained an image URL <a id="_idIndexMarker504"/>before, all <a id="_idIndexMarker505"/>we need to do is make <span class="No-Break">the call:</span></p>
			<pre class="source code">
val firstImageUrl = imageResults?.firstOrNull()?.imageUrl
    .orEmpty()
if (!firstImageUrl.isBlank()) {
    imageLoader.loadImage(firstImageUrl, profileImageView)
} else {
    Log.d("MainActivity", "Missing image URL")
}</pre>
			<p>We have to ensure the result contains a string that is not empty or made of spaces (<strong class="source inline">isBlank()</strong> in the preceding code block). Then, we can safely load the URL into <strong class="source inline">ImageView</strong>. And we’re done. I<a id="_idTextAnchor340"/>f we run our app now, we should see something like the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B19411_05_04.jpg" alt="Figure 5.4 – Server response image URL with the actual image"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Server response image URL with the actual image</p>
			<p>Remember <a id="_idIndexMarker506"/>that <a id="_idIndexMarker507"/>the API returns random results, so the actual image is likely to be different. If we’r<a id="_idTextAnchor341"/><a id="_idTextAnchor342"/>e lucky, we might even get an animated GIF, which we would then <span class="No-Break">see animated.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor343"/>Exercise 5.03 – loading the image from the obtained URL</h2>
			<p>In the previous<a id="_idIndexMarker508"/> exercise, we extracted the image URL from the API response. Now, we will use that URL to fetch an image from the web and display it in <span class="No-Break">our app:</span></p>
			<ol>
				<li>Open the app’s <strong class="source inline">build.gradle</strong> file and add the <span class="No-Break">Glide dependency:</span><pre class="source code">
dependencies {
    ...
<strong class="bold">    implementation 'com.github.bumptech.glide:</strong><strong class="bold">glide:4.14.2'</strong>
    ...
}</pre></li>
			</ol>
			<p>Synchronize your project with the <span class="No-Break">Gradle files.</span></p>
			<ol>
				<li value="2">On the left <strong class="bold">Project</strong> panel, right-click on your project package name (<strong class="source inline">com.example.catagentprofile</strong>) and select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Kotlin File/Class</strong></span><span class="No-Break">.</span></li>
				<li>Fill in <strong class="source inline">ImageLoader</strong> in the <strong class="bold">Name</strong> field. For <strong class="bold">Kind</strong>, <span class="No-Break">choose </span><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break">.</span></li>
				<li>Open the newly created <strong class="source inline">ImageLoader.kt</strong> file and update it <span class="No-Break">like so:</span><pre class="source code">
interface ImageLoader {
<strong class="bold">    fun loadImage(imageUrl: String, imageView: ImageView)</strong>
}</pre></li>
			</ol>
			<p>This will be <a id="_idIndexMarker509"/>your interface for any image loader in <span class="No-Break">the app.</span></p>
			<ol>
				<li value="5">Right-click on the project package name again and select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Kotlin File/Class</strong></span><span class="No-Break">.</span></li>
				<li>Name the new file <strong class="source inline">GlideImageLoader</strong> and select <strong class="bold">Class</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="bold">Kind</strong></span><span class="No-Break">.</span></li>
				<li>Update the newly <span class="No-Break">created file:</span><pre class="source code">
class GlideImageLoader(private val context: Context) : <strong class="bold">ImageLoader {</strong>
<strong class="bold">    override fun loadImage(imageUrl: String,</strong>
<strong class="bold">    imageView: ImageView) {</strong>
<strong class="bold">        Glide.with(context).load(imageUrl)</strong>
<strong class="bold">            .centerCrop().into(imageView)</strong>
    }
}</pre></li>
				<li>Open <strong class="source inline">activity_main.xml</strong> and<a id="_idIndexMarker510"/> update it <span class="No-Break">like so:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
...&gt;
    &lt;TextView
        android:id="@+id/main_server_response"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_to<strong class="bold">TopOf="@+id/</strong>
<strong class="bold">            main_profile_image"</strong>
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
<strong class="bold">    &lt;ImageView</strong>
<strong class="bold">        android:id="@+id/main_profile_image"</strong>
<strong class="bold">        android:layout_width="150dp"</strong>
<strong class="bold">        android:layout_height="150dp"</strong>
<strong class="bold">        app:layout_constraintBottom_toBottomOf="parent"</strong>
<strong class="bold">        app:layout_constraintEnd_toEndOf="parent"</strong>
<strong class="bold">        app:layout_constraintStart_toStartOf="parent"</strong>
<strong class="bold">        app:layout_constraintTop_toBottomOf=</strong>
<strong class="bold">            "@+id/main_server_response" /&gt;</strong>
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>This will add an <strong class="source inline">ImageView</strong> named <strong class="source inline">main_profile_image</strong> <span class="No-Break">below </span><span class="No-Break"><strong class="source inline">TextView</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="9">Open the <span class="No-Break"><strong class="source inline">MainActivity.kt</strong></span><span class="No-Break"> file.</span></li>
				<li>Add a field for your newly added <strong class="source inline">ImageView</strong> at the top of <span class="No-Break">your class:</span><pre class="source code">
private val serverResponseView: TextView by lazy {
    findViewById(R.id.main_server_response) }
<strong class="bold">private val profileImageView: ImageView by lazy {</strong>
<strong class="bold">    findViewById(R.id.main_profile_image) }</strong></pre></li>
				<li>Define <strong class="source inline">ImageLoader</strong> just <a id="_idIndexMarker511"/>above the <span class="No-Break"><strong class="source inline">onCreate(Bundle?)</strong></span><span class="No-Break"> function:</span><pre class="source code">
<strong class="bold">private val imageLoader: ImageLoader by lazy {</strong>
<strong class="bold">    GlideImageLoader(this) }</strong>
override fun onCreate(savedInstanceState: Bundle?) {</pre></li>
				<li>Update your <strong class="source inline">getCatImageResponse()</strong> function <span class="No-Break">like so:</span><pre class="source code">
private fun getCatImageResponse() {
  val call = theCatApiService.searchImages(1, "full")
  call.enqueue(object : Callback&lt;List&lt;ImageResultData&gt;&gt; {
    override fun onFailure(...) { ... }
    override fun onResponse(...) {
      if (response.isSuccessful) {
        val imageResults = response.body()
        val firstImageUrl = imageResults
          ?.firstOrNull()?.imageUrl.orEmpty()
<strong class="bold">        if (firstImageUrl.isNotBlank()) {</strong>
<strong class="bold">          imageLoader.loadImage(</strong>
<strong class="bold">            firstImageUrl, profileImageView)</strong>
<strong class="bold">        } else {</strong>
<strong class="bold">          Log.d("MainActivity", "Missing image URL")</strong>
<strong class="bold">        }</strong>
        serverResponseView.text =
          "Image URL: $firstImageUrl"
      } else {
        Log.e("MainActivity", "Failed to get search 
        results\n${response.errorBody()?.string().
        orEmpty()}"
        )
      }
    }
  })
}</pre></li>
				<li>Now, onc<a id="_idTextAnchor344"/>e <a id="_idIndexMarker512"/>you have a non-blank URL, it will be loaded <span class="No-Break">into </span><span class="No-Break"><strong class="source inline">profileImageView</strong></span><span class="No-Break">.</span></li>
				<li>Run <span class="No-Break">the app:</span></li>
			</ol>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B19411_05_05.jpg" alt="Figure 5.5 – Exercise outcome showing a random image and its source URL"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Exercise outcome showing a random image and its source URL</p>
			<p>The following are <span class="No-Break">bonus steps.</span></p>
			<ol>
				<li value="15">Update<a id="_idIndexMarker513"/> your layout <span class="No-Break">like so:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;
    &lt;TextView
        android:id="@+id/main_agent_breed_label"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="16dp"
        android:text="Agent breed:"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;TextView
        android:id="@+id/main_agent_breed_value"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:paddingTop="16dp"
        app:layout_constraintStart_toEndOf=
            "@+id/main_agent_breed_label"
        app:layout_constraintTop_toTopOf=
            "@+id/main_agent_breed_label" /&gt;
    &lt;ImageView
        android:id="@+id/main_profile_image"
        android:layout_width="150dp"
        android:layout_height="150dp"
        android:layout_margin="16dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@+id/main_agent_breed_label" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker514"/>add an <strong class="source inline">Agent breed</strong> label and tidy up the view layout. Now, your layout looks a bit more like a proper cat agent <span class="No-Break">profile app.</span></p>
			<ol>
				<li value="16">In <strong class="source inline">MainActivity.kt</strong>, locate the <span class="No-Break">following lines:</span><pre class="source code">
private val serverResponseView: TextView by lazy {
    findViewById(R.id.main_server_response) }</pre></li>
			</ol>
			<p>Replace the preceding lines with the following to look up the new <span class="No-Break">name field:</span></p>
			<pre class="source code">
private val agentBreedView: TextView by lazy {
    findViewById(R.id.main_agent_breed_value) }</pre>
			<ol>
				<li value="17">Update <strong class="source inline">getCatImageResponse()</strong> <span class="No-Break">like</span><span class="No-Break"><a id="_idIndexMarker515"/></span><span class="No-Break"> so:</span><pre class="source code">
private fun getCatImageResponse() {
  val call = theCatApiService.searchImages(1, "full")
  call.enqueue(object :
  Callback&lt;List&lt;ImageResultData&gt;&gt; {
    override fun onFailure(call:
      Call&lt;List&lt;ImageResultData&gt;&gt;, t: Throwable) {
      Log.e("MainActivity", "Failed to get search 
      results", t)
    }
    override fun onResponse(
      call: Call&lt;List&lt;ImageResultData&gt;&gt;,
      response: Response&lt;List&lt;ImageResultData&gt;&gt;
    ) {
      if (response.isSuccessful) {
        val imageResults = response.body()
        val firstImageUrl = imageResults
          ?.firstOrNull()?.imageUrl.orEmpty()
        if (!firstImageUrl.isBlank()) {
          imageLoader.loadImage(
          firstImageUrl, profileImageView)
        } else {
          Log.d("MainActivity", "Missing image URL")
        }
        agentBreedView.text = imageResults
          ?.firstOrNull()?.breeds?.firstOrNull()
          ?.name ?: "Unknown"
      } else {
        Log.e("MainActivity", "Failed to get search 
        results\n${response.errorBody()?.string().
        orEmpty()}")
      }
    }
  })
}</pre></li>
			</ol>
			<p>This is done to load <a id="_idIndexMarker516"/>the first breed returned from the API into <strong class="source inline">agentNameView</strong>, with a fallback <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">Unknown</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="18">At the time of writing, not many pictures in The Cat API have breed data. H<a id="_idTextAnchor345"/>owever, if you run your app enough times, you will end up seeing something <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B19411_05_06.jpg" alt="Figure 5.6 – Showing the cat agent image and breed"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Showing the cat agent image and breed</p>
			<p>In this chapter, we learned how to fetch data from a remote API. We then learned how to process that data and extract the information we needed from it. Lastly, we learned how to present an image on the screen when given an <span class="No-Break">image URL.</span></p>
			<p>In the following<a id="_idIndexMarker517"/> activity, we will apply our knowledge to develop an app that tells the u<a id="_idTextAnchor346"/><a id="_idTextAnchor347"/>ser the current weather in New York, presenting the user with a relevant <span class="No-Break">weather icon.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor348"/>Activity 5.01 – displaying the current weather</h2>
			<p>Let’s say we want to <a id="_idIndexMarker518"/>build an app that shows the current weather in New York. Furthermore, we also want to display an icon representing the <span class="No-Break">current weather.</span></p>
			<p>This activity aims to create an app that polls an API endpoint for the current weather in JSON format, transforms that data into a local model, and uses that model to present the current weather. It also extracts the URL to an icon representing the current weather and fetches that icon to be displayed on <span class="No-Break">the screen.</span></p>
			<p>We will use the free OpenWeatherMap API for the purpose of this activity. The documentation can be found at <a href="https://openweathermap.org/api">https://openweathermap.org/api</a>. To sign up for an API token, please go to <a href="https://home.openweathermap.org/users/sign_up">https://home.openweathermap.org/users/sign_up</a>. You can find your keys and generate new ones as needed <span class="No-Break">at </span><a href="https://home.openweathermap.org/api_keys"><span class="No-Break">https://home.openweathermap.org/api_keys</span></a><span class="No-Break">.</span></p>
			<p>The steps for this activity are <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Create a <span class="No-Break">new app.</span></li>
				<li>Grant internet permissions to the app in order to be able to make API and <span class="No-Break">image requests.</span></li>
				<li>Add Retrofit, the Moshi converter, and Glide to <span class="No-Break">the app.</span></li>
				<li>Update the app layout to support the presentation of the weather in a textual form (a short and long description) as well as a weather <span class="No-Break">icon image.</span></li>
				<li>Define the model. Create classes that will contain the <span class="No-Break">server response.</span></li>
				<li>Add the Retrofit service for the OpenWeatherMap <span class="No-Break">API,</span><span class="No-Break"><strong class="source inline"> </strong></span><a href="https://api.openweathermap.org/data/2.5/weather"><span class="No-Break">https://api.openweathermap.org/data/2.5/weather</span></a><span class="No-Break">.</span></li>
				<li>Create a Retrofit instance with a <span class="No-Break">Moshi converter.</span></li>
				<li>Call the <span class="No-Break">API service.</span></li>
				<li>Handle the successful <span class="No-Break">serve<a id="_idTextAnchor349"/>r response.</span></li>
				<li>Handle the different <span class="No-Break">failure scenarios.</span></li>
			</ol>
			<p>The<a id="_idIndexMarker519"/> expected output is <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B19411_05_07.jpg" alt="Figure 5.7 – The final we﻿﻿ather app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The final we<a id="_idTextAnchor350"/><a id="_idTextAnchor351"/>ather app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution for this activity can be found <span class="No-Break">at </span><a href="https://packt.link/By7eE"><span class="No-Break">https://packt.link/By7eE</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor352"/>Summary</h1>
			<p>In this chapter, we learned how to fetch data from an API using Retrofit. We then learned how to handle JSON responses, as well as plain text responses, using Moshi. We also saw how different error scenarios could <span class="No-Break">be handled.</span></p>
			<p>We later learned how to load images from URLs using Glide and how to present them to the user <span class="No-Break">via </span><span class="No-Break"><strong class="source inline">ImageView</strong></span><span class="No-Break">.</span></p>
			<p>There are quite a few popular libraries for fetching data from APIs and for loading images. We only covered some of the most popular ones. You might want to try out some of the other libraries to find out which ones fit your <span class="No-Break">purposes best.</span></p>
			<p>In the next chapter, we will be introduced to <strong class="source inline">RecyclerView</strong>, which is a powerful UI component that we can use to present our users with lists <span class="No-Break">of items.</span></p>
		</div>
		<div>
			<div id="_idContainer124" class="IMG---Figure">
			</div>
		</div>
	</body></html>