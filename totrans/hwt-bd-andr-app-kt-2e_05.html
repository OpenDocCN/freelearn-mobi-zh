<html><head></head><body>
		<div><h1 id="_idParaDest-92" class="chapter number"><a id="_idTextAnchor312"/><a id="_idTextAnchor313"/><a id="_idTextAnchor314"/><a id="_idTextAnchor315"/><a id="_idTextAnchor316"/>5</h1>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor317"/>Essential Libraries: Retrofit, Moshi, and Glide</h1>
			<p><a id="_idTextAnchor318"/>In this chapter, we will cover the steps needed to present app users with dynamic content fetched from remote servers. You will be introduced to the different libraries required to retrieve and handle this dynamic data.</p>
			<p>By the end of this chapter, you will be able to fetch data from a network endpoint using Retrofit, parse JSON payloads into Kotlin data objects using Moshi, and load images into <code>ImageView</code> using Glide.</p>
			<p><a id="_idTextAnchor319"/>In the previous chapter, we learned how to implement navigation in our app. In this chapter, we will learn how to present dynamic content to the user as they navigate around our app.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing REST, API, JSON, and XML</li>
				<li>Fetching data from a network endpoint</li>
				<li>Parsing a JSON response</li>
				<li>Loading images from a remote URL</li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor320"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/Uqtjm">https://packt.link/Uqtjm</a></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor321"/>Introducing REST, API, JSON, and XML</h1>
			<p>Data<a id="_idIndexMarker427"/> presented<a id="_idIndexMarker428"/> to <a id="_idIndexMarker429"/>users <a id="_idIndexMarker430"/>can come from different sources. It can be hardcoded into an app, but that comes with limitations. To change hardcoded data, we have to publish an update to our app. Some data, such as currency exchange rates, the real-time availability of assets, and the current weather, cannot be hardcoded by its nature. Other data may become outdated, such as the terms of use of an app.</p>
			<p>In such cases, you usually fetch the relevant data from a server. One of the most common architectures for serving such data is <strong class="bold">representational state transfer</strong> (<strong class="bold">REST</strong>) architecture. REST architecture is defined by a set of six constraints: client-server architecture, statelessness, cacheability, a layered system, code on demand (optional), and a uniform interface.</p>
			<p class="callout heading">Note</p>
			<p class="callout">To read more <a id="_idIndexMarker431"/>about REST, visit <a href="https://packt.link/YsSRV">https://packt.link/YsSRV</a>.</p>
			<p>When applied to a web service <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), we get a <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>)-based <a id="_idIndexMarker432"/>RESTful API. The HTTP protocol is the foundation of data communication for the World Wide Web, hosted on and accessible via the <strong class="bold">internet</strong>. It is <a id="_idIndexMarker433"/>the protocol used by servers all around the world to serve websites to users in the form of HTML documents, images, style sheets, and so forth.</p>
			<p class="callout heading">Note</p>
			<p class="callout">An interesting article on this topic can be found at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview</a>.</p>
			<p>RESTful APIs<a id="_idIndexMarker434"/> rely<a id="_idIndexMarker435"/> on <a id="_idIndexMarker436"/>the <a id="_idIndexMarker437"/>standard HTTP methods – <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>PATCH</code> – to fetch and transform data. These methods allow us to fetch, store, delete, and update data entities on remote servers.</p>
			<p>We can rely on the built-in Java <code>HttpURLConnection</code> class to execute these HTTP methods. Alternatively, we can use a library such as <code>OkHttp</code>, which offers additional features such as gzipping (compressing and decompressing), redirects, retries, and both synchronous and asynchronous calls. Interestingly, from Android 4.4, <code>HttpURLConnection</code> is just a wrapper around <code>OkHttp</code>. If we choose <code>OkHttp</code>, we might as well go<a id="_idIndexMarker438"/> for <strong class="bold">Retrofit</strong> (as we will in this chapter), the current industry standard. We can then benefit from its type-safety, which is better suited for handling REST calls.</p>
			<p>Most commonly, data is represented by <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>). JSON is a text-based data transfer <a id="_idIndexMarker439"/>format. As the name implies, it was derived from JavaScript. However, it has since become one of the most popular standards for data transfer, and its most modern programming languages have libraries that encode or decode data to or from JSON.</p>
			<p>A simple JSON payload may look something like this:</p>
			<pre class="source code">
{"employees":[
  {"name": "James", "email": "james.notmyemail@gmail.com"},
  {"name": "Lea", "email": "lea.dontemailme@gmail.com"}
]}</pre>
			<p>Another common data structure used by RESTful services is <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>), which<a id="_idIndexMarker440"/> encodes documents in a format that is human- and machine-readable. XML is considerably more verbose than JSON. The<a id="_idIndexMarker441"/> same data structure as the previous <a id="_idIndexMarker442"/>in XML<a id="_idIndexMarker443"/> would<a id="_idIndexMarker444"/> look something like this:</p>
			<pre class="source code">
&lt;employees&gt;
    &lt;employee&gt;
        &lt;name&gt;James&lt;/name&gt;
        &lt;email&gt;james.notmyemail@gmail.com&lt;/email&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
        &lt;name&gt;Lea&lt;/name&gt;
        &lt;email&gt;lea.dontemailme@gmail.com&lt;/email&gt;
    &lt;/employee&gt;
&lt;/employees&gt;</pre>
			<p>In this chapter, we will focus on JSON.</p>
			<p>When obtaining a JSON payload, we essentially receive a string. To convert that string into a data object, we have a few options, the most popular ones being libraries such as <code>org.json</code> package. For its <a id="_idIndexMarker445"/>lightweight <a id="_idIndexMarker446"/>nature, we<a id="_idIndexMarker447"/> will focus on Moshi.</p>
			<p>Finally, we will look into loading images from the web. Doing so will allow us to provide up-to-date images and load the right images for the user’s device. It will also let us only load the images<a id="_idIndexMarker448"/> when <a id="_idIndexMarker449"/>we <a id="_idIndexMarker450"/>need <a id="_idIndexMarker451"/>them, thus keepi<a id="_idTextAnchor322"/><a id="_idTextAnchor323"/>ng our APK size smaller.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor324"/>Fetching data from a network endpoint</h1>
			<p>For the <a id="_idIndexMarker452"/>purpose <a id="_idIndexMarker453"/>of this section, we will use The Cat API (<a href="https://thecatapi.com/">https://thecatapi.com/</a>). This RESTful API offers us vast data about, well…cats.</p>
			<p>To get started, we will create a new project. We then have to grant our app internet access permission. This is done by adding the following code to your <code>AndroidManifest.xml</code> file right before the <code>Application</code> tag:</p>
			<pre class="source code">
&lt;uses-permission
    android:name="android.permission.INTERNET" /&gt;</pre>
			<p>Next, we need to set up our app to include Retrofit. Retrofit is a type-safe library provided by Square, which is built on top of the <code>OkHttp</code> HTTP client. Retrofit helps us generate <strong class="bold">Uniform Resource Locators</strong> (<strong class="bold">URLs</strong>), which are the addresses of the server<a id="_idIndexMarker454"/> endpoints we want to access. It also makes the decoding of JSON payloads easier by providing integration with several parsing libraries. Sending data to the server is also easier with Retrofit, as it helps with encoding the requests.</p>
			<p class="callout heading">Note</p>
			<p class="callout">You can read more <a id="_idIndexMarker455"/>about Retrofit here <a href="https://square.github.io/retrofit/">https://square.github.io/retrofit/</a>.</p>
			<p>To add Retrofit to our project, we need to add the following code to the <code>dependencies</code> block of the <code>build.gradle</code> file of our app:</p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:retrofit:(insert latest version)'</pre>
			<p class="callout heading">Note</p>
			<p class="callout">You can find the latest version here <a href="https://github.com/square/retrofit">https://github.com/square/retrofit</a>.</p>
			<p>With Retrofit included in our project, we can proceed to set it up.</p>
			<p>First, to access an HTTP(S) endpoint, we start by defining the contract with that endpoint. A contract to access the <code>https://api.thecatapi.com/v1/images/search</code> endpoint looks like this:</p>
			<pre class="source code">
interface TheCatApiService {
    @GET("images/search")
    fun searchImages(
        @Query("limit") limit: Int,
        @Query("size") format: String
    ): Call&lt;String&gt;
}</pre>
			<p>There are <a id="_idIndexMarker456"/>a <a id="_idIndexMarker457"/>few things to note here. First, you will notice that the contract is implemented as an interface. This is how you define contracts for Retrofit. Next, you will notice that the name of the interface implies that this interface can, eventually, cover all calls made to <code>TheCatAPIService</code>.</p>
			<p>It is a bit unfortunate that Square chose <code>Service</code> as the conventional suffix for these contracts, as the term service has a different meaning in the Android world, as you will see in <a href="B19411_08.xhtml#_idTextAnchor471"><em class="italic">Chapter 8</em></a>, <em class="italic">Services, WorkManager, and Notifications</em>. Nevertheless, this is the convention.</p>
			<p>To define our endpoint, we start by stating the method with which the call will be made using the appropriate annotation—in our case, <code>@GET</code>. The parameter passed to the annotation is the path of the endpoint to access. You’ll notice that <code>https://api.thecatapi.com/v1/</code> is stripped from that path.</p>
			<p>That is because this is the common address for all of the endpoints of <code>TheCatAPI</code>, and so it will be passed to our Retrofit instance at construction time instead. Next, we choose a meaningful name for our function—in this case, we'll call the image search endpoint, so <code>searchImages</code> seems appropriate. The parameters of the <code>searchImages</code> function define the values we can pass to the API when we make the calls.</p>
			<p>There are different ways in which we can transfer data to the API. <code>@Query</code> allows us to define values added to the query of our request URL (that’s the optional part of the URL that comes after the question mark). It takes a key-value pair (in our case, we have <code>limit</code> and <code>size</code>) and a data type. If the data type is not a string, the value of that type will be transformed into a string. Any value passed will be URL-encoded for us.</p>
			<p>Another such way is using <code>@Path</code>. This annotation can be used to replace a token in our path wrapped in curly brackets with a provided value. The <code>@Header</code>, <code>@Headers</code>, and <code>@HeaderMap</code> annotations will allow us to add or remove HTTP headers from the request. <code>@Body</code> can be used to pass content in the body of the <code>POST</code> and <code>PUT</code> requests.</p>
			<p>Lastly, we have <a id="_idIndexMarker458"/>a<a id="_idIndexMarker459"/> return type. To keep things simple at this stage, we will accept the response as a string. We wrapped our string in a <code>Call</code> interface. <code>Call</code> is Retrofit’s mechanism for executing network requests synchronously (via <code>execute()</code>) or asynchronously (via <code>enqueue(Callback)</code>). When using coroutines, we can make the function a <code>suspend</code> function and omit the <code>Call</code> wrapper (see <a href="B19411_14.xhtml#_idTextAnchor751"><em class="italic">Chapter 14</em></a><em class="italic">, Coroutines and Flow</em>, for more information on coroutines).</p>
			<p>With our contract defined, we can get Retrofit to implement our service interface:</p>
			<pre class="source code">
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.thecatapi.com/v1/").build()
val theCatApiService =
    retrofit.create(TheCatApiService::class.java)</pre>
			<p>If we try to run our app with this code, our app will crash with an <code>IllegalArgumentException</code>. This is because Retrofit needs us to tell the app how to process the server response to a string. This processing is done with what Retrofit calls <code>ConverterFactory</code> instance to our <code>retrofit</code> instance, we <a id="_idIndexMarker460"/>need to add the following:</p>
			<pre class="source code">
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.thecatapi.com/v1/")
<strong class="bold">    .addConverterFactory(ScalarsConverterFactory.create())</strong>
    .build()</pre>
			<p>For our project to recognize <code>ScalarsConverterFactory</code>, we need to update our app’s <code>build.gradle</code> file by adding another dependency:</p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:converter-scalars:(insert latest version)'</pre>
			<p>Now, we can obtain a <code>Call</code> instance by calling <code>val call = theCatApiService.searchImages(1, "full")</code>. With the instance obtained in this fashion, we can execute an async request by calling <code>call.enqueue(Callback)</code>.</p>
			<p>Our <code>Callback</code> implementation will have two methods: <code>onFailure(Call, Throwable)</code> and <code>onResponse(Call, Response)</code>. Note that we are not guaranteed to have a successful response if <code>onResponse</code> is called. <code>onResponse</code> is called whenever we successfully receive <em class="italic">any</em> response from the server, and no unexpected exception occurs.</p>
			<p>So, to confirm that the response is successful, we should check the <code>response.isSuccessful</code> property. The <code>onFailure</code> function will be called in the case of a network error or an unexpected exception somewhere along the way.</p>
			<p>So, where <a id="_idIndexMarker461"/>should <a id="_idIndexMarker462"/>we implement the Retrofit code? In clean architecture, data is provided by repositories. Repositories, in turn, have data sources. One such data source can be a network data source. This is where we will implement our network calls. Our ViewModels will then request data from repositories via use cases.</p>
			<p>In the <a id="_idIndexMarker463"/>case of <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>), the ViewModel is an abstraction of the view that exposes properties and commands.</p>
			<p>For our implementation, we will simplify the process by instantiating Retrofit and the service in the Activity. This is not good practice. <em class="italic">Do not do this in a production app</em>. It does not scale<a id="_idIndexMarker464"/> well<a id="_idIndexMarker465"/> and is very difficult to test. Instead, adopt an architecture that decouples your views from your business logic and your data. See <a href="B19411_15.xhtml#_idTextAnchor789"><em class="italic">Chapter 15</em></a>, <a id="_idTextAnchor325"/><a id="_idTextAnchor326"/><em class="italic">Architecture Patterns</em>, for some ideas.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor327"/>Exercise 5.01 – reading data from an API</h2>
			<p>In the <a id="_idIndexMarker466"/>following chapters, we <a id="_idIndexMarker467"/>will develop an app for an imaginary secret agency with a worldwide network of agents saving the world from countless dangers. The secret agency in question is quite unique: it operates secret cat agents.</p>
			<p>In this exercise, we will create an app that presents us with one random secret cat agent from The Cat API. Before you can present data from an API to your user, you first must fetch that data. Let’s start with that here:</p>
			<ol>
				<li>Create a new <strong class="bold">Empty Activity</strong> project (<strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">New Project</strong> | <strong class="bold">Empty Activity</strong>). Click <strong class="bold">Next</strong>.</li>
				<li>Name your application <code>Cat </code><code>Agent Profile</code>.</li>
				<li>Make sure your package name is <code>com.example.catagentprofile</code>.</li>
				<li>Set <strong class="bold">Save location</strong> to where you want to save your project.</li>
				<li>Leave everything else at its default values and click <strong class="bold">Finish</strong>.</li>
				<li>Make sure you are on<a id="_idTextAnchor328"/> the <strong class="bold">Android</strong> view in your <strong class="bold">Project</strong> pane:</li>
			</ol>
			<div><div><img src="img/B19411_05_01.jpg" alt="Figure 5.1 – The Android view in the Project pane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The Android view in the Project pane</p>
			<ol>
				<li value="7">Open <a id="_idIndexMarker468"/>your <code>AndroidManifest.xml</code> file. Add<a id="_idIndexMarker469"/> internet permissions to your app like so:<pre class="source code">
&lt;manifest xmlns:android=
    "http://schemas.android.com/apk/res/android"
    package="com.example.catagentprofile"&gt;
<strong class="bold">    &lt;uses-permission</strong>
<strong class="bold">    android:name="android.permission.INTERNET" /&gt;</strong>
    &lt;application ...&gt; ... &lt;/application&gt;
&lt;/manifest&gt;</pre></li>
				<li>To add Retrofit and the scalars converter to your app, open the <code>build.gradle</code> app module, (<code>Gradle Scripts</code> | <code>build.gradle (Module: app)</code>), and add the following lines anywhere inside the <code>dependencies</code> block:<pre class="source code">
dependencies {
    ...
    implementation
        'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:
        converter-scalars:2.9.0'
    ...
}</pre></li>
			</ol>
			<p>Your <code>dependencies</code> block should now look something like this:</p>
			<pre class="source code">
dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib
        :$kotlin_version"
    ...
<strong class="bold">    implementation</strong>
<strong class="bold">        'com.squareup.retrofit2:retrofit:2.9.0'</strong>
<strong class="bold">    implementation 'com.squareup.retrofit2:</strong>
<strong class="bold">        converter-scalars:2.9.0'</strong>
    ...
}</pre>
			<p>Between <a id="_idIndexMarker470"/>the <a id="_idIndexMarker471"/>time of writing and when you carry out this exercise, some dependencies may have changed. You should still only add the lines in bold from the preceding code block. These will add Retrofit and support for reading server responses as single strings.</p>
			<p class="callout heading">Note</p>
			<p class="callout">It is worth noting that Retrofit now requires, as a minimum, Android API 21 or Java 8.</p>
			<ol>
				<li value="9">Click the <strong class="bold">Sync Project with Gradle Files</strong> button in Android Studio.</li>
				<li>Open your <code>activity_main.xml</code> file in the <strong class="bold">Text</strong> mode.</li>
				<li>To be able to use your label to present the latest server response, you need to assign an ID to it:<pre class="source code">
&lt;TextView
<strong class="bold">    android:id="@+id/main_server_response"</strong>
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    ... /&gt;</pre></li>
				<li>In the <code>com.example.catagentprofile</code>), then select <strong class="bold">New</strong> | <strong class="bold">Package</strong>.</li>
				<li>Name your package <code>api</code>.</li>
				<li>Now, right-click on the newly created package (<code>com.example.catagentprofile.api</code>), then select <strong class="bold">New</strong> | <strong class="bold">Kotlin File/Class</strong>.</li>
				<li>Name <a id="_idIndexMarker472"/>your <a id="_idIndexMarker473"/>new file <code>TheCatApiService</code>. For <strong class="bold">Kind</strong>, choose <strong class="bold">Interface</strong>.</li>
				<li>Add the following to the <code>interface</code> block:<pre class="source code">
interface TheCatApiService {
<strong class="bold">    @GET("images/search")</strong>
<strong class="bold">    fun searchImages(</strong>
<strong class="bold">        @Query("limit") limit: Int,</strong>
<strong class="bold">        @Query("size") format: String</strong>
<strong class="bold">    ) : Call&lt;String&gt;</strong>
}</pre></li>
			</ol>
			<p>This defines the image search endpoint. Make sure to import all the required Retrofit dependencies.</p>
			<ol>
				<li value="17">Open your <code>MainActivity</code> file.</li>
				<li>At the top of the <code>MainActivity</code> class block, add the following:<pre class="source code">
class MainActivity : AppCompatActivity() {
<strong class="bold">    private val retrofit by lazy {</strong>
<strong class="bold">        Retrofit.Builder()</strong>
<strong class="bold">            .baseUrl("https://api.thecatapi.com/v1/")</strong>
<strong class="bold">            .addConverterFactory(</strong>
<strong class="bold">                ScalarsConverterFactory.create()</strong>
<strong class="bold">            ).build()</strong>
<strong class="bold">    }</strong>
<strong class="bold">    private val theCatApiService by lazy {</strong>
<strong class="bold">        retrofit.create(TheCatApiService::class.java)</strong>
<strong class="bold">    }</strong>
    ...
}</pre></li>
			</ol>
			<p>This will<a id="_idIndexMarker474"/> instantiate <a id="_idIndexMarker475"/>Retrofit and the API service. We use <code>lazy</code> to make sure the instances are only created when needed.</p>
			<ol>
				<li value="19">Add <code>serverResponseView</code> as a field:<pre class="source code">
class MainActivity : AppCompatActivity() {
<strong class="bold">    private val serverResponseView: TextView by lazy {</strong>
<strong class="bold">        findViewById(R.id.main_server_response)</strong>
<strong class="bold">    }</strong></pre></li>
			</ol>
			<p>This will look up the view with the <code>main_server_response</code> ID the first time <code>serverResponseView</code> is accessed and then keep a reference to it.</p>
			<ol>
				<li value="20">Now, add the <code>getCatImageResponse()</code> function <a id="_idIndexMarker476"/>after<a id="_idIndexMarker477"/> the <code>onCreate(Bundle?)</code> function:<pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
  ...
}
<strong class="bold">private fun getCatImageResponse() {</strong>
<strong class="bold">  val call = theCatApiService.searchImages(1,</strong>
<strong class="bold">    "full")</strong>
<strong class="bold">  call.enqueue(object : Callback&lt;String&gt; {</strong>
<strong class="bold">    override fun onFailure(call: Call&lt;String&gt;, t:</strong>
<strong class="bold">    Throwable) {</strong>
<strong class="bold">      Log.e("MainActivity", "Failed to get</strong>
<strong class="bold">      search results", t)</strong>
<strong class="bold">    }</strong>
<strong class="bold">    override fun onResponse(</strong>
<strong class="bold">      call: Call&lt;String&gt;, response: Response&lt;String&gt;</strong>
<strong class="bold">    ) {</strong>
<strong class="bold">      if (response.isSuccessful) {</strong>
<strong class="bold">        serverResponseView.text = response.body()</strong>
<strong class="bold">            } else {</strong>
<strong class="bold">        Log.e(</strong>
<strong class="bold">          "MainActivity",</strong>
<strong class="bold">          "Failed to get search results\n${</strong>
<strong class="bold">            response.errorBody()?.string().orEmpty()</strong>
<strong class="bold">          }"</strong>
<strong class="bold">        )</strong>
<strong class="bold">      }</strong>
<strong class="bold">    }</strong>
<strong class="bold">  })</strong>
}</pre></li>
			</ol>
			<p>This function will fire off the search request and handle the possible outcomes—a successful response, an error response, and any other thrown exception.</p>
			<ol>
				<li value="21">Invoke<a id="_idIndexMarker478"/> a <a id="_idIndexMarker479"/>call to <code>getCatImageResponse()</code> in <code>onCreate()</code>. This will trigger the call as soon as the activity is created:<pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
    ...
    getCatImageResponse()
}</pre></li>
				<li>Add the missing imports.</li>
				<li>Run your app by clicking the <strong class="bold">Run ‘app’</strong> button or pressing <em class="italic">Ct<a id="_idTextAnchor329"/>rl</em> + <em class="italic">R</em>. On the emulator, it should look like this:</li>
			</ol>
			<div><div><img src="img/B19411_05_02.jpg" alt="Figure 5.2 – The app presenting the server response JSON"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The app presenting the server response JSON</p>
			<p>Because every time you run your app, a new call is made, and a random response is returned, your <a id="_idIndexMarker480"/>result <a id="_idIndexMarker481"/>will likely differ. However, whatever your result, if successful, it should be a JSON payload. Next, we will learn how to parse tha<a id="_idTextAnchor330"/><a id="_idTextAnchor331"/>t JSON payload and extract the data we want from it.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor332"/>Parsing a JSON response</h1>
			<p>Now that we have<a id="_idIndexMarker482"/> successfully retrieved a JSON response from an API, it is time to learn how to use the data we have obtained. To do so, we need to parse the JSON payload. This is because the payload is a plain string representing the data object, and we are interested in the specific properties of that object. If you look closely at <em class="italic">Figure 5</em><em class="italic">.2</em>, you may notice that the JSON contains breed information, an image URL, and some other bits of information. However, for our code to use that information, first, we must extract it.</p>
			<p>As mentioned in the introduction, multiple libraries exist that will parse a JSON payload for us. The most popular ones are Google’s GSON (see <a href="https://github.com/google/gson">https://github.com/google/gson</a>) and, more recently, Square’s Moshi  (see <a href="https://github.com/square/moshi">https://github.com/square/moshi</a>). Moshi is very lightweight, which is why we have chosen to use it in this chapter.</p>
			<p>What do JSON libraries do? Basically, they help us convert data classes into JSON strings (serialization) and vice versa (deserialization). This helps us communicate with servers that understand JSON strings while allowing us to use meaningful data structures in our code.</p>
			<p>To use Moshi with Retrofit, we need to add the Moshi Retrofit converter to our project. This is done by adding the following line to the <code>dependencies</code> block of our app’s <code>build.gradle</code> file:</p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:converter-moshi:2.9.0'</pre>
			<p>Since we will no longer the responses as strings, we can go ahead and remove the scalars Retrofit converter. Next, we need to create a data class to map the server JSON response to. One convention is to suffix the names of API response data classes with <code>Data</code>—so we’ll call our data class <code>ImageResultData</code>. Another common suffix is <code>Entity</code>.</p>
			<p>When we design our server response data classes, we need to take two factors into account: the structure of the JSON response and our data requirements. The first will affect our data types and field names, while the second will allow us to omit fields we do not currently need. JSON libraries ignore data in fields we have not defined in our data classes.</p>
			<p>One more thing JSON libraries do for us is automatically map JSON data to fields if they happen to have the exact same name. While this is a nice feature, it carries risk. If we rely solely on it, our data classes (and the code accessing them) will be tightly coupled to the API naming.</p>
			<p>Because not all APIs are designed well, you might end up with meaningless field names, such as <code>fn</code> or <code>last</code>, or inconsistent naming. Luckily, there is a solution to this problem. Moshi provides us with an <code>@Json</code> annotation. It can be used to map a JSON field name to a meaningful field name:</p>
			<pre class="source code">
data class UserData(
    @field:Json(name = "fn") val firstName: String,
    @field:Json(name = "last") val lastName: String
)</pre>
			<p>The <code>field:</code> prefix is used to ensure the generated Java field is annotated correctly.</p>
			<p>Some consider it better practice to include the annotation even when the API name is the same as the field name for the sake of consistency. We prefer the conciseness of direct conversion when the field name is clear enough. This approach can be challenged when obfuscating our code. If we do, we must either exclude our data classes or make sure to annotate all fields.</p>
			<p>While we are not always lucky enough to have properly documented APIs, when we do, it is best to consult the documentation when designing our model. Our model would be a data class into which the JSON data from all calls we make will be decoded. The documentation for the image search endpoint of The Cat API can be found at <a href="https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/">https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/</a>.</p>
			<p>You will often<a id="_idIndexMarker483"/> find documentation is or inaccurate. If this happens to be the case, the best thing you can do is contact the owners of the API and request that they update the documentation. You may have to resort to experimenting with an endpoint, unfortunately. This is risky because undocumented fields or structures are not guaranteed to remain the same, so when possible, try and get the documentation updated.</p>
			<p>Based on the response schema obtained from the preceding link, we can define our model as follows:</p>
			<pre class="source code">
data class ImageResultData(
    @field:Json(name = "url") val imageUrl: String,
    val breeds: List&lt;CatBreedData&gt;
)
data class CatBreedData(
    val name: String,
    val temperament: String
)</pre>
			<p>Note that the response structure is that of a list of results. This means we need our responses mapped to <code>List&lt;ImageResultData&gt;</code>, not simply <code>ImageResultData</code>. Now, we need to update <code>TheCatApiService</code>. Instead of <code>Call&lt;String&gt;</code>, we can now have <code>Call&lt;List&lt;ImageResultData&gt;&gt;</code>.</p>
			<p>Next, we need to update the construction of our Retrofit instance. Instead of <code>ScalarsConverterFactory</code>, we will now have <code>MoshiConverterFactory</code>. Lastly, we need to update our callback <a id="_idIndexMarker484"/>since it should no longer handle string calls but <code>List&lt;ImageResultData&gt;</code> instead:</p>
			<pre class="source code">
@GET("images/search")
fun searchImages(
    @Query("limit") limit: Int,
    @Quer<a id="_idTextAnchor333"/><a id="_idTextAnchor334"/>y("size") format: String
) : Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;</pre>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor335"/>Exercise 5.02 – extracting the image URL from the API response</h2>
			<p>So, we have <a id="_idIndexMarker485"/>a server response as a string. Now, we<a id="_idIndexMarker486"/> want to extract the image URL from that string and present only that URL on the screen:</p>
			<ol>
				<li>Open the app’s <code>build.gradle</code> file and replace the scalars converter implementation with a Moshi converter one:<pre class="source code">
implementation 'com.squareup.retrofit2: retrofit:2.9.0'
<strong class="bold">implementation 'com.squareup.retrofit2: </strong>
<strong class="bold">converter-moshi:2.9.0'</strong>
testImplementation 'junit:junit:4.13.2'</pre></li>
				<li>Click the <strong class="bold">Sync Project with Gradle </strong><strong class="bold">Files</strong> button.</li>
				<li>Under your app package (<code>com.example.catagentprofile</code>), create a <code>model</code> package.</li>
				<li>Within the <code>com.example.catagentprofile.model</code> package, create a new Kotlin file named <code>CatBreedData</code>.</li>
				<li>Populate the newly created file with the following:<pre class="source code">
package com.example.catagentprofile.model
<strong class="bold">data class CatBreedData(</strong>
<strong class="bold">    val name: String,</strong>
<strong class="bold">    val temperament: String</strong>
)</pre></li>
				<li>Next, create <code>ImageResultData</code> under<a id="_idIndexMarker487"/> the<a id="_idIndexMarker488"/> same package.</li>
				<li>Set its contents to the following:<pre class="source code">
package com.example.catagentprofile.model
import com.squareup.moshi.Json
<strong class="bold">data class ImageResultData(</strong>
<strong class="bold">    @field:Json(name = "url") val imageUrl: String,</strong>
<strong class="bold">    val breeds: List&lt;CatBreedData&gt;</strong>
)</pre></li>
				<li>Open the <code>TheCatApiService</code> file and update the <code>searchImages</code> return type:<pre class="source code">
    @GET("images/search")
    fun searchImages(
        @Query("limit") limit: Int,
        @Query("size") format: String
    ) : Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;</pre></li>
				<li>Lastly, open <code>MainActivity</code>.</li>
				<li>Update the Retrofit initialization block to use the Moshi converter to deserialize JSON:<pre class="source code">
    private val retrofit by lazy {
        Retrofit.Builder()
        .baseUrl("https://api.thecatapi.com/v1/")
        .addConverterFactory(<strong class="bold">MoshiConverterFactor</strong>
<strong class="bold">        </strong>.create())
        .build()
    }</pre></li>
				<li>Update<a id="_idIndexMarker489"/> the <code>getCatImageResponse()</code> function <a id="_idIndexMarker490"/>to handle the <code>List&lt;ImageResultData&gt;</code> requests and responses:<pre class="source code">
private fun getCatImageResponse() {
  val call = theCatApiService.searchImages(1, "full")
  call.enqueue(object : Callback&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt; {
    override fun onFailure(
      call: Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;,
      t: Throwable) {
      Log.e("MainActivity", "Failed to get search 
      results", t)
      }
      override fun onResponse(
        call: Call&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;,
        response: Response&lt;<strong class="bold">List&lt;ImageResultData&gt;</strong>&gt;
      ) {
        if (response.isSuccessful) {
<strong class="bold">          val imageResults = response.body()</strong>
<strong class="bold">          val firstImageUrl =</strong>
<strong class="bold">            imageResults?.firstOrNull()?</strong>
<strong class="bold">            .imageUrl ?: "No URL"</strong>
<strong class="bold">          serverResponseView.text =</strong>
<strong class="bold">            "Image URL: $firstImageUrl"</strong>
        } else {
          Log.e("MainActivity", "Failed to get search 
          results\n${response.errorBody()?.string().orEmpty()}"
        )
      }
    }
  })
}</pre></li>
				<li>Now, you<a id="_idIndexMarker491"/> need to check for a successful <a id="_idIndexMarker492"/>response and that there is at least one <code>ImageResultData</code> instance. You can then read the <code>imageUrl</code> property of that instance and present it to the user.<a id="_idTextAnchor336"/></li>
				<li>Run your app. It should now look something like the following:</li>
			</ol>
			<div><div><img src="img/B19411_05_03.jpg" alt="Figure 5.3 – The app presenting the parsed image URL"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The app presenting the parsed image URL</p>
			<ol>
				<li value="14">Again, due to the random nature of the API responses, your URL will likely be different.</li>
			</ol>
			<p>You have <a id="_idIndexMarker493"/>now <a id="_idIndexMarker494"/>successfully extracted a specific property from an API response. Next, we will le<a id="_idTextAnchor337"/><a id="_idTextAnchor338"/>arn how to load the image from the URL provided to us by the API.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor339"/>Loading images from a remote URL</h1>
			<p>We just<a id="_idIndexMarker495"/> learned <a id="_idIndexMarker496"/>how to extract data from an API response. That data often includes URLs to images we want to present to the user. There is quite a bit of work involved in achieving that. First, you must fetch the image as a binary stream from the URL. Then, you need to transform that binary stream into an image (it could be a GIF, JPEG, or one of a few other image formats).</p>
			<p>Then, you need to convert it into a bitmap instance, potentially resizing it to use less memory. You may also want to apply other transformations to it at that point. Then, you need to set it to <code>ImageView</code>.</p>
			<p>Sounds like a lot of work, doesn’t it? Well, luckily for us, there are a few libraries that do all of that (and more) for us. The most <a id="_idIndexMarker497"/>commonly <a id="_idIndexMarker498"/>used libraries are Square’s <strong class="bold">Picasso</strong> (see <a href="https://square.github.io/picasso/">https://square.github.io/picasso/</a>) and <strong class="bold">Glide</strong> by Bump<a id="_idIndexMarker499"/> Technologies (see <a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a>). Facebook’s <strong class="bold">Fresco</strong> (see <a href="https://frescolib.org/">https://frescolib.org/</a>) is somewhat less popular. A library that’s gained traction recently is <strong class="bold">Coil</strong> (see <a href="https://coil-kt.github.io/coil/">https://coil-kt.github.io/coil/</a>).</p>
			<p>We will proceed with Glide because it is consistently the fastest of the two popular options for loading images, whether from the internet or the cache. However, it’s worth noting that Picasso is more lightweight, so it is a trade-off, and both libraries are quite useful.</p>
			<p>To include Glide<a id="_idIndexMarker500"/> in <a id="_idIndexMarker501"/>your project, add it to the <code>dependencies</code> block of your app’s <code>build.gradle</code> file:</p>
			<pre class="source code">
dependencies {
    <strong class="bold">implementation 'com.github.bumptech.glide:glide:4.14.2'</strong>
    ...
}</pre>
			<p>In fact, because we might change our minds at a later point, this is a great opportunity to abstract away the concrete library to have a simpler interface of our own. So, let’s start by defining our <code>ImageLoader</code> interface:</p>
			<pre class="source code">
interface ImageLoader {
    fun loadImage(imageUrl: String, imageView: ImageView)
}</pre>
			<p>This is a naïve implementation. In a production implementation, you might want to add arguments (or multiple functions) to support options such as different cropping strategies or loading states.</p>
			<p>Our implementation of the interface will rely on Glide, so it will look something like this:</p>
			<pre class="source code">
class GlideImageLoader(private val context: Context) : ImageLoader {
    override fun loadImage(imageUrl: String, imageView:
    ImageView) {
        Glide.with(context)
            .load(imageUrl).centerCrop().into(imageView)
    }
}</pre>
			<p>We prefix our class name with <code>Glide</code> to differentiate it from other potential implementations. Constructing <code>GlideImageLoader</code> with <code>context</code> allows us to implement the clean <code>loadImage(String, ImageView)</code> interface without having to worry about the context, which Glide requires for image loading.</p>
			<p>In fact, Glide<a id="_idIndexMarker502"/> is<a id="_idIndexMarker503"/> smart about the Android context. That means we could have separate implementations for the <code>Activity</code> and <code>Fragment</code> scopes, and Glide would know when an image-loading request went beyond the relevant scope.</p>
			<p>Since we haven’t yet added an <code>ImageView</code> to our layout, let’s do that now:</p>
			<pre class="source code">
&lt;TextView
    ...
    app:layout_constraintBottom<strong class="bold">_toTopOf="@+id/</strong>
<strong class="bold">    main_profile_image"</strong>
    ... /&gt;
<strong class="bold">&lt;ImageView</strong>
<strong class="bold">    android:id="@+id/main_profile_image"</strong>
<strong class="bold">    android:layout_width="150dp"</strong>
<strong class="bold">    android:layout_height="150dp"</strong>
<strong class="bold">    app:layout_constraintBottom_toBottomOf="parent"</strong>
<strong class="bold">    </strong><strong class="bold">app:layout_constraintEnd_toEndOf="parent"</strong>
<strong class="bold">    app:layout_constraintStart_toStartOf="parent"</strong>
<strong class="bold">    app:layout_constraintTop_toBottomOf="@+id/</strong>
<strong class="bold">    main_server_response" /&gt;</strong></pre>
			<p>This will add an <code>ImageView</code> with an ID of <code>main_profile_image</code> below our <code>TextView</code>.</p>
			<p>We can now create an instance of <code>GlideImageLoader</code> in <code>MainActivity</code>:</p>
			<pre class="source code">
private val imageLoader: ImageLoader by lazy {
    GlideImageLoader(this) }</pre>
			<p>In a production app, you would inject the dependency, rather than creating it inline.</p>
			<p>Next, we tell our Glide loader to load the image and, once loaded, center-crop it inside the provided <code>ImageView</code>. This means the image will be scaled up or down to fully fill the <code>ImageView</code>, with any excess content cut off (cropped). Since we already obtained an image URL <a id="_idIndexMarker504"/>before, all <a id="_idIndexMarker505"/>we need to do is make the call:</p>
			<pre class="source code">
val firstImageUrl = imageResults?.firstOrNull()?.imageUrl
    .orEmpty()
if (!firstImageUrl.isBlank()) {
    imageLoader.loadImage(firstImageUrl, profileImageView)
} else {
    Log.d("MainActivity", "Missing image URL")
}</pre>
			<p>We have to ensure the result contains a string that is not empty or made of spaces (<code>isBlank()</code> in the preceding code block). Then, we can safely load the URL into <code>ImageView</code>. And we’re done. I<a id="_idTextAnchor340"/>f we run our app now, we should see something like the following screenshot:</p>
			<div><div><img src="img/B19411_05_04.jpg" alt="Figure 5.4 – Server response image URL with the actual image"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Server response image URL with the actual image</p>
			<p>Remember <a id="_idIndexMarker506"/>that <a id="_idIndexMarker507"/>the API returns random results, so the actual image is likely to be different. If we’r<a id="_idTextAnchor341"/><a id="_idTextAnchor342"/>e lucky, we might even get an animated GIF, which we would then see animated.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor343"/>Exercise 5.03 – loading the image from the obtained URL</h2>
			<p>In the previous<a id="_idIndexMarker508"/> exercise, we extracted the image URL from the API response. Now, we will use that URL to fetch an image from the web and display it in our app:</p>
			<ol>
				<li>Open the app’s <code>build.gradle</code> file and add the Glide dependency:<pre class="source code">
dependencies {
    ...
<strong class="bold">    implementation 'com.github.bumptech.glide:</strong><strong class="bold">glide:4.14.2'</strong>
    ...
}</pre></li>
			</ol>
			<p>Synchronize your project with the Gradle files.</p>
			<ol>
				<li value="2">On the left <code>com.example.catagentprofile</code>) and select <strong class="bold">New</strong> | <strong class="bold">Kotlin File/Class</strong>.</li>
				<li>Fill in <code>ImageLoader</code> in the <strong class="bold">Name</strong> field. For <strong class="bold">Kind</strong>, choose <strong class="bold">Interface</strong>.</li>
				<li>Open the newly created <code>ImageLoader.kt</code> file and update it like so:<pre class="source code">
interface ImageLoader {
<strong class="bold">    fun loadImage(imageUrl: String, imageView: ImageView)</strong>
}</pre></li>
			</ol>
			<p>This will be <a id="_idIndexMarker509"/>your interface for any image loader in the app.</p>
			<ol>
				<li value="5">Right-click on the project package name again and select <strong class="bold">New</strong> | <strong class="bold">Kotlin File/Class</strong>.</li>
				<li>Name the new file <code>GlideImageLoader</code> and select <strong class="bold">Class</strong> for <strong class="bold">Kind</strong>.</li>
				<li>Update the newly created file:<pre class="source code">
class GlideImageLoader(private val context: Context) : <strong class="bold">ImageLoader {</strong>
<strong class="bold">    override fun loadImage(imageUrl: String,</strong>
<strong class="bold">    imageView: ImageView) {</strong>
<strong class="bold">        Glide.with(context).load(imageUrl)</strong>
<strong class="bold">            .centerCrop().into(imageView)</strong>
    }
}</pre></li>
				<li>Open <code>activity_main.xml</code> and<a id="_idIndexMarker510"/> update it like so:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
...&gt;
    &lt;TextView
        android:id="@+id/main_server_response"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_to<strong class="bold">TopOf="@+id/</strong>
<strong class="bold">            main_profile_image"</strong>
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
<strong class="bold">    &lt;ImageView</strong>
<strong class="bold">        android:id="@+id/main_profile_image"</strong>
<strong class="bold">        android:layout_width="150dp"</strong>
<strong class="bold">        android:layout_height="150dp"</strong>
<strong class="bold">        app:layout_constraintBottom_toBottomOf="parent"</strong>
<strong class="bold">        app:layout_constraintEnd_toEndOf="parent"</strong>
<strong class="bold">        app:layout_constraintStart_toStartOf="parent"</strong>
<strong class="bold">        app:layout_constraintTop_toBottomOf=</strong>
<strong class="bold">            "@+id/main_server_response" /&gt;</strong>
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>This will add an <code>ImageView</code> named <code>main_profile_image</code> below <code>TextView</code>.</p>
			<ol>
				<li value="9">Open the <code>MainActivity.kt</code> file.</li>
				<li>Add a field for your newly added <code>ImageView</code> at the top of your class:<pre class="source code">
private val serverResponseView: TextView by lazy {
    findViewById(R.id.main_server_response) }
<strong class="bold">private val profileImageView: ImageView by lazy {</strong>
<strong class="bold">    findViewById(R.id.main_profile_image) }</strong></pre></li>
				<li>Define <code>ImageLoader</code> just <a id="_idIndexMarker511"/>above the <code>onCreate(Bundle?)</code> function:<pre class="source code">
<strong class="bold">private val imageLoader: ImageLoader by lazy {</strong>
<strong class="bold">    GlideImageLoader(this) }</strong>
override fun onCreate(savedInstanceState: Bundle?) {</pre></li>
				<li>Update your <code>getCatImageResponse()</code> function like so:<pre class="source code">
private fun getCatImageResponse() {
  val call = theCatApiService.searchImages(1, "full")
  call.enqueue(object : Callback&lt;List&lt;ImageResultData&gt;&gt; {
    override fun onFailure(...) { ... }
    override fun onResponse(...) {
      if (response.isSuccessful) {
        val imageResults = response.body()
        val firstImageUrl = imageResults
          ?.firstOrNull()?.imageUrl.orEmpty()
<strong class="bold">        if (firstImageUrl.isNotBlank()) {</strong>
<strong class="bold">          imageLoader.loadImage(</strong>
<strong class="bold">            firstImageUrl, profileImageView)</strong>
<strong class="bold">        } else {</strong>
<strong class="bold">          Log.d("MainActivity", "Missing image URL")</strong>
<strong class="bold">        }</strong>
        serverResponseView.text =
          "Image URL: $firstImageUrl"
      } else {
        Log.e("MainActivity", "Failed to get search 
        results\n${response.errorBody()?.string().
        orEmpty()}"
        )
      }
    }
  })
}</pre></li>
				<li>Now, onc<a id="_idTextAnchor344"/>e <a id="_idIndexMarker512"/>you have a non-blank URL, it will be loaded into <code>profileImageView</code>.</li>
				<li>Run the app:</li>
			</ol>
			<div><div><img src="img/B19411_05_05.jpg" alt="Figure 5.5 – Exercise outcome showing a random image and its source URL"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Exercise outcome showing a random image and its source URL</p>
			<p>The following are bonus steps.</p>
			<ol>
				<li value="15">Update<a id="_idIndexMarker513"/> your layout like so:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;
    &lt;TextView
        android:id="@+id/main_agent_breed_label"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="16dp"
        android:text="Agent breed:"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;TextView
        android:id="@+id/main_agent_breed_value"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:paddingTop="16dp"
        app:layout_constraintStart_toEndOf=
            "@+id/main_agent_breed_label"
        app:layout_constraintTop_toTopOf=
            "@+id/main_agent_breed_label" /&gt;
    &lt;ImageView
        android:id="@+id/main_profile_image"
        android:layout_width="150dp"
        android:layout_height="150dp"
        android:layout_margin="16dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@+id/main_agent_breed_label" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker514"/>add an <code>Agent breed</code> label and tidy up the view layout. Now, your layout looks a bit more like a proper cat agent profile app.</p>
			<ol>
				<li value="16">In <code>MainActivity.kt</code>, locate the following lines:<pre class="source code">
private val serverResponseView: TextView by lazy {
    findViewById(R.id.main_server_response) }</pre></li>
			</ol>
			<p>Replace the preceding lines with the following to look up the new name field:</p>
			<pre class="source code">
private val agentBreedView: TextView by lazy {
    findViewById(R.id.main_agent_breed_value) }</pre>
			<ol>
				<li value="17">Update <code>getCatImageResponse()</code> like<a id="_idIndexMarker515"/> so:<pre class="source code">
private fun getCatImageResponse() {
  val call = theCatApiService.searchImages(1, "full")
  call.enqueue(object :
  Callback&lt;List&lt;ImageResultData&gt;&gt; {
    override fun onFailure(call:
      Call&lt;List&lt;ImageResultData&gt;&gt;, t: Throwable) {
      Log.e("MainActivity", "Failed to get search 
      results", t)
    }
    override fun onResponse(
      call: Call&lt;List&lt;ImageResultData&gt;&gt;,
      response: Response&lt;List&lt;ImageResultData&gt;&gt;
    ) {
      if (response.isSuccessful) {
        val imageResults = response.body()
        val firstImageUrl = imageResults
          ?.firstOrNull()?.imageUrl.orEmpty()
        if (!firstImageUrl.isBlank()) {
          imageLoader.loadImage(
          firstImageUrl, profileImageView)
        } else {
          Log.d("MainActivity", "Missing image URL")
        }
        agentBreedView.text = imageResults
          ?.firstOrNull()?.breeds?.firstOrNull()
          ?.name ?: "Unknown"
      } else {
        Log.e("MainActivity", "Failed to get search 
        results\n${response.errorBody()?.string().
        orEmpty()}")
      }
    }
  })
}</pre></li>
			</ol>
			<p>This is done to load <a id="_idIndexMarker516"/>the first breed returned from the API into <code>agentNameView</code>, with a fallback to <code>Unknown</code>.</p>
			<ol>
				<li value="18">At the time of writing, not many pictures in The Cat API have breed data. H<a id="_idTextAnchor345"/>owever, if you run your app enough times, you will end up seeing something like this:</li>
			</ol>
			<div><div><img src="img/B19411_05_06.jpg" alt="Figure 5.6 – Showing the cat agent image and breed"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Showing the cat agent image and breed</p>
			<p>In this chapter, we learned how to fetch data from a remote API. We then learned how to process that data and extract the information we needed from it. Lastly, we learned how to present an image on the screen when given an image URL.</p>
			<p>In the following<a id="_idIndexMarker517"/> activity, we will apply our knowledge to develop an app that tells the u<a id="_idTextAnchor346"/><a id="_idTextAnchor347"/>ser the current weather in New York, presenting the user with a relevant weather icon.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor348"/>Activity 5.01 – displaying the current weather</h2>
			<p>Let’s say we want to <a id="_idIndexMarker518"/>build an app that shows the current weather in New York. Furthermore, we also want to display an icon representing the current weather.</p>
			<p>This activity aims to create an app that polls an API endpoint for the current weather in JSON format, transforms that data into a local model, and uses that model to present the current weather. It also extracts the URL to an icon representing the current weather and fetches that icon to be displayed on the screen.</p>
			<p>We will use the free OpenWeatherMap API for the purpose of this activity. The documentation can be found at <a href="https://openweathermap.org/api">https://openweathermap.org/api</a>. To sign up for an API token, please go to <a href="https://home.openweathermap.org/users/sign_up">https://home.openweathermap.org/users/sign_up</a>. You can find your keys and generate new ones as needed at <a href="https://home.openweathermap.org/api_keys">https://home.openweathermap.org/api_keys</a>.</p>
			<p>The steps for this activity are as follows:</p>
			<ol>
				<li>Create a new app.</li>
				<li>Grant internet permissions to the app in order to be able to make API and image requests.</li>
				<li>Add Retrofit, the Moshi converter, and Glide to the app.</li>
				<li>Update the app layout to support the presentation of the weather in a textual form (a short and long description) as well as a weather icon image.</li>
				<li>Define the model. Create classes that will contain the server response.</li>
				<li>Add the Retrofit service for the OpenWeatherMap API,<code> </code><a href="https://api.openweathermap.org/data/2.5/weather">https://api.openweathermap.org/data/2.5/weather</a>.</li>
				<li>Create a Retrofit instance with a Moshi converter.</li>
				<li>Call the API service.</li>
				<li>Handle the successful serve<a id="_idTextAnchor349"/>r response.</li>
				<li>Handle the different failure scenarios.</li>
			</ol>
			<p>The<a id="_idIndexMarker519"/> expected output is shown here:</p>
			<div><div><img src="img/B19411_05_07.jpg" alt="Figure 5.7 – The final we﻿﻿ather app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The final we<a id="_idTextAnchor350"/><a id="_idTextAnchor351"/>ather app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution for this activity can be found at <a href="https://packt.link/By7eE">https://packt.link/By7eE</a>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor352"/>Summary</h1>
			<p>In this chapter, we learned how to fetch data from an API using Retrofit. We then learned how to handle JSON responses, as well as plain text responses, using Moshi. We also saw how different error scenarios could be handled.</p>
			<p>We later learned how to load images from URLs using Glide and how to present them to the user via <code>ImageView</code>.</p>
			<p>There are quite a few popular libraries for fetching data from APIs and for loading images. We only covered some of the most popular ones. You might want to try out some of the other libraries to find out which ones fit your purposes best.</p>
			<p>In the next chapter, we will be introduced to <code>RecyclerView</code>, which is a powerful UI component that we can use to present our users with lists of items.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>