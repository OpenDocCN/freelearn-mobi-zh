- en: Chapter 6. Make Swift Work For You – Protocols and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 让 Swift 为你工作 – 协议和泛型
- en: As we learned in [Chapter 2](ch02.html "Chapter 2. Building Blocks – Variables,
    Collections, and Flow Control"), *Building Blocks – Variables, Collections, and
    Flow Control*, Swift is a strongly typed language, which means that every piece
    of data must have a type. Not only can we take advantage of this to reduce the
    clutter in our code, we can also leverage it to let the compiler catch bugs for
    us. The earlier we catch a bug, the better. Besides not writing them in the first
    place, the earliest place where we can catch a bug is when the compiler reports
    an error.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第 2 章](ch02.html "第 2 章. 构建块 – 变量、集合和流程控制")中学习的，*构建块 – 变量、集合和流程控制*，Swift
    是一种强类型语言，这意味着每份数据都必须有一个类型。我们不仅可以利用这一点来减少代码的混乱，还可以利用它让编译器为我们捕获错误。我们越早捕获错误，越好。除了最初不编写它们之外，我们最早可以捕获错误的地方是当编译器报告错误时。
- en: Two big tools that Swift provides to achieve this are called **protocols** and
    **generics**. Both of them use the type system to make our intentions clear to
    the compiler so that it can catch more bugs for us.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供的两个大工具，用于实现这一功能，被称为**协议**和**泛型**。它们都利用类型系统来使编译器清楚我们的意图，以便它能为我们捕获更多错误。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Protocols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议
- en: Generics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Extending existing generics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展现有的泛型
- en: Extending protocols
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展协议
- en: Putting protocols and generics to use
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议和泛型
- en: Protocols
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议
- en: The first tool we will look at is **protocols**. A protocol is essentially a
    contract that a type can sign, specifying that it will provide a certain interface
    to other components. This relationship is significantly looser than the relationship
    a subclass has with its superclass. A protocol does not provide any implementation
    to the types that implement them. Instead, a type can implement them in any way
    that they like.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个工具是**协议**。协议本质上是一种类型可以签署的合同，指定它将向其他组件提供一定的接口。这种关系比子类与其超类之间的关系要松散得多。协议不会为它们实现的类型提供任何实现。相反，一个类型可以以任何它们喜欢的方式实现它们。
- en: Let's take a look at how we define a protocol, in order to understand them better.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何定义一个协议，以便更好地理解它们。
- en: Defining a protocol
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个协议
- en: 'Let''s say we have some code that needs to interact with a collection of strings.
    We don''t actually care what order they are stored in and we only need to be able
    to add and enumerate elements inside the container. One option would be to simply
    use an array, but an array does way more than we need it to. What if we decide
    later that we would rather write and read the elements from the file system? Furthermore,
    what if we want to write a container that would intelligently start using the
    file system as it got really large? We can make our code flexible enough to do
    this in the future by defining a string container protocol, which is a loose contract
    that defines what we need it to do. This protocol might look similar to the following
    code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些需要与字符串集合交互的代码。我们实际上并不关心它们存储的顺序，我们只需要能够在容器内部添加和枚举元素。一个选项是简单地使用数组，但数组的功能远远超出了我们的需求。如果我们后来决定我们更愿意从文件系统中写入和读取元素呢？此外，如果我们想编写一个在变得非常大时智能地开始使用文件系统的容器呢？我们可以通过定义一个字符串容器协议来使我们的代码足够灵活，以便在未来做到这一点，这个协议是一个松散的合同，定义了我们希望它执行的操作。这个协议可能看起来类似于以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Predictably, a protocol is defined using the `protocol` keyword, similar to
    a class or a structure. It also allows you to specify computed properties and
    methods. You cannot declare a stored property because it is not possible to create
    an instance of a protocol directly. You can only create instances of types that
    implement the protocol. Also, you may notice that none of the computed properties
    or methods provide implementations. In a protocol, you only provide the interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 预计，协议是通过使用 `protocol` 关键字定义的，类似于类或结构体。它还允许你指定计算属性和方法。你不能声明存储属性，因为无法直接创建协议的实例。你只能创建实现协议的类型实例。此外，你可能注意到，计算属性或方法都没有提供实现。在协议中，你只提供接口。
- en: Since protocols cannot be initialized on their own, they are useless until we
    create a type that implements them. Let's take a look at how we can create a type
    that implements our `StringContainer` protocol.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于协议不能自行初始化，因此在我们创建实现它们的类型之前，它们是无用的。让我们看看我们如何创建一个实现我们的 `StringContainer` 协议的类型。
- en: Implementing a protocol
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个协议
- en: 'A type "signs the contract" of a protocol in the same way that a class inherits
    from another class except that structures and enumerations can also implement
    protocols:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类型“签署”协议的合同的方式与类从另一个类继承的方式相同，只是结构和枚举也可以实现协议：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, once a type has claimed to implement a specific protocol, the
    compiler will give an error if it has not fulfilled the contract by implementing
    everything defined in the protocol. To satisfy the compiler, we must now implement
    the `count` computed property, mutating function `addString:`, and function `enumerateStrings:`
    as they are defined. We will do this by internally holding our values in an array:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦一个类型声明实现了特定的协议，如果它没有通过实现协议中定义的所有内容来履行合同，编译器将会报错。为了满足编译器的要求，我们现在必须实现`count`计算属性、修改函数`addString:`和函数`enumerateStrings:`，正如它们在协议中定义的那样。我们将通过在内部使用数组来持有我们的值来完成这项工作：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `count` property will always just return the number of elements in our `strings`
    array. The `addString:` method can simply add the string to our array. Finally,
    our `enumerateString:` method just needs to loop through our array and call the
    handler with each element.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`属性将始终只返回我们的`strings`数组中的元素数量。`addString:`方法可以简单地添加字符串到我们的数组中。最后，我们的`enumerateString:`方法只需要遍历我们的数组，并对每个元素调用处理程序。'
- en: At this point, the compiler is satisfied that `StringBag` is fulfilling its
    contract with the `StringContainer` protocol.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，编译器已经满意地认为`StringBag`正在履行其与`StringContainer`协议的合同。
- en: 'Now, we can similarly create a class that implements the `StringContainer`
    protocol. This time, we will implement it using an internal dictionary instead
    of an array:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以类似地创建一个实现`StringContainer`协议的类。这一次，我们将使用内部字典而不是数组来实现它：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we can see that a class can both inherit from a superclass and implement
    a protocol. The superclass always has to come first in the list, but you can implement
    as many protocols as you want, separating each one with a comma. In fact, a structure
    and enumeration can also implement multiple protocols.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，一个类可以同时从超类继承并实现一个协议。超类始终必须排在列表的第一位，但你可以实现尽可能多的协议，每个协议之间用逗号分隔。实际上，结构和枚举也可以实现多个协议。
- en: With this implementation we are doing something slightly strange with the dictionary.
    We defined it to have no values; it is simply a collection of keys. This allows
    us to store our strings without any regard to the order they are in.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们对字典做了一些稍微奇怪的事情。我们定义它没有值；它只是一个键的集合。这允许我们存储字符串，而不考虑它们的顺序。
- en: 'Now, when we create instances, we can actually assign any instance of any type
    that implements our protocol to a variable that is defined to be our protocol,
    just like we can with superclasses:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建实例时，我们可以将任何实现我们的协议的类型的任何实例分配给定义为我们的协议的变量，就像我们可以用超类一样：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a variable is defined with our protocol as its type, we can only interact
    with it using the interface that the protocol defines. This is a great way to
    abstract implementation details and create more flexible code. By being less restrictive
    on the type that we want to use, we can easily change our code without affecting
    how we use it. Protocols provide the same benefit that superclasses do, but in
    an even more flexible and comprehensive way, because they can be implemented by
    all types and a type can implement an unlimited number of protocols. The only
    benefit that superclasses provide over protocols is that superclasses share their
    implementations with their children.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量使用我们的协议作为其类型被定义时，我们只能通过协议定义的接口与之交互。这是一种很好的抽象实现细节并创建更灵活代码的方法。通过对我们想要使用的类型施加较少的限制，我们可以轻松地更改我们的代码，而不会影响我们使用它的方式。协议提供了与超类相同的利益，但以一种更加灵活和全面的方式，因为它们可以被所有类型实现，并且一个类型可以实现无限数量的协议。超类相对于协议的唯一好处是，超类与其子类共享它们的实现。
- en: Using type aliases
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型别名
- en: 'Protocols can be made more flexible using a feature called **type aliases**.
    They act as a placeholder for a type that will be defined later when the protocol
    is being implemented. For example, instead of creating an interface that specifically
    includes strings, we can create an interface for a container that can hold any
    type of value, as shown:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个名为**类型别名**的功能来使协议更加灵活。它们作为稍后将在实现协议时定义的类型的一个占位符。例如，我们不需要创建一个专门包含字符串的接口，我们可以创建一个可以容纳任何类型值的容器接口，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, this protocol creates a type alias called `Element` using the
    keyword `typealias`. It does not actually specify a real type; it is just a placeholder
    for a type that will be defined later. Everywhere we have previously used a string,
    we simply refer to it as `Element`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，此协议使用关键字 `typealias` 创建了一个名为 `Element` 的类型别名。它实际上并没有指定一个真实类型；它只是为稍后定义的类型提供一个占位符。在我们之前使用字符串的所有地方，我们只需将其称为
    `Element`。
- en: 'Now, we can create another string bag that uses the new `Container` protocol
    with a type alias instead of the `StringContainer` protocol. To do this, we not
    only need to implement each of the methods, we also need to give a definition
    for the type alias, as shown:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建另一个使用新的 `Container` 协议和类型别名而不是 `StringContainer` 协议的字符串包。为此，我们不仅需要实现每个方法，还需要为类型别名提供一个定义，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code, we have specified that the `Element` type alias should be a
    string for this implementation using an equal sign (`=`). This code continues
    to use the type alias for all of the properties and methods, but you can also
    use string since they are in fact the same thing now.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们指定了 `Element` 类型别名应该为此实现是字符串，使用等号 (`=`)。此代码继续使用类型别名来表示所有属性和方法，但你也可以使用字符串，因为它们现在实际上是同一件事。
- en: 'Using the type alias actually makes it really easy for us to create another
    structure that can hold integers instead of strings:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型别名实际上使我们能够轻松地创建另一个可以存储整数而不是字符串的结构：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only difference between these two pieces of code is that the type alias
    has been defined to be an integer in the second case instead of a string. We could
    use copy and paste to create a container of virtually any type, but as usual,
    doing a lot of copy and paste is a sign that there is a better solution. Also,
    you may notice that our new `Container` protocol isn't actually that useful on
    its own because with our existing techniques, we can't treat a variable as just
    a `Container`. If we are going to interact with an instance that implements this
    protocol, we need to know what type it has assigned the type alias to.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两段代码之间的唯一区别在于，在第二种情况下，类型别名被定义为整数而不是字符串。我们可以使用复制和粘贴来创建几乎任何类型的容器，但像往常一样，大量复制和粘贴是更好的解决方案的迹象。此外，你可能注意到，我们新的
    `Container` 协议本身并不是特别有用，因为使用我们现有的技术，我们无法将一个变量视为一个 `Container`。如果我们将与实现此协议的实例交互，我们需要知道它将类型别名分配给了什么类型。
- en: Swift provides a tool called **generics** to solve both of these problems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了一个名为 **泛型** 的工具来解决这两个问题。
- en: Generics
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: A generic is very similar to a type alias. The difference is that the exact
    type of a generic is determined by the context in which it is being used, instead
    of being determined by the implementing types. This also means that a generic
    only has a single implementation that must support all possible types. Let's start
    by defining a generic function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型非常类似于类型别名。区别在于泛型的确切类型是由其使用的上下文决定的，而不是由实现类型决定的。这也意味着泛型只有一个实现，必须支持所有可能的类型。让我们先定义一个泛型函数。
- en: Generic function
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型函数
- en: 'In [Chapter 5](ch05.html "Chapter 5. A Modern Paradigm – Closures and Functional
    Programming"), *A Modern Paradigm – Closures and Functional Programming*, we created
    a function that helped us find the first number in an array of numbers that passes
    a test:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。现代范式 – 闭包和函数式编程") 中，*现代范式 – 闭包和函数式编程*，我们创建了一个函数，帮助我们找到通过测试的数组中的第一个数字：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would be great if we only ever dealt with arrays of `integers`, but clearly
    it would be helpful to be able to do this with other types. In fact, dare I say,
    all types? We achieve this very simply by making our function generic. A generic
    function is declared similar to a normal function, but you include a list of comma-separated
    placeholders inside angled brackets (`<>`) at the end of the function name, as
    shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只处理整数数组，这将非常棒，但显然能够用其他类型做这件事会更有帮助。事实上，我敢说，对所有类型都这样做会更好。我们通过使我们的函数泛型来实现这一点。泛型函数的声明方式与普通函数类似，但在函数名称的末尾包含一个逗号分隔的占位符列表，放在尖括号
    (`<>`) 内，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this function, we have declared a single placeholder called `ValueType`.
    Just like with type aliases, we can continue to use this type in our implementation.
    This will stand in for a single type that will be determined when we go to use
    the function. You can imagine inserting `String` or any other type into this code
    instead of `ValueType` and it would still work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们声明了一个名为`ValueType`的单个占位符。就像类型别名一样，我们可以在实现中继续使用这个类型。这将代表一个在我们要使用函数时确定的单个类型。你可以想象在这个代码中插入`String`或任何其他类型而不是`ValueType`，它仍然可以工作。
- en: 'We use this function similarly to any other function, as shown:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个函数的方式与任何其他函数类似，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we have used `firstInArray:passingTest:` with both an array of strings
    and an array of numbers. The compiler figures out what type to substitute in for
    the placeholder based on the variables we pass into the function. In the first
    case, `strings` is an array of `String`. It compares that to `[ValueType]` and
    assumes that we want to replace `ValueType` with `String`. The same thing happens
    with our `Int` array in the second case.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`firstInArray:passingTest:`，同时使用了字符串数组和数字数组。编译器根据我们传递给函数的变量来确定要替换占位符的类型。在第一种情况下，`strings`是一个`String`数组。它将这个与`[ValueType]`进行比较，并假设我们想要用`String`替换`ValueType`。在第二种情况下，我们的`Int`数组发生同样的情况。
- en: So what happens if the type we use in our closure doesn't match the type of
    array we pass in?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们闭包中使用的类型与我们传递的数组类型不匹配会发生什么？
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we get an error that the types don't match.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们得到了一个错误，类型不匹配。
- en: You may have noticed that we have actually used generic functions before. All
    of the built in functions we looked at in [Chapter 5](ch05.html "Chapter 5. A
    Modern Paradigm – Closures and Functional Programming"), *A Modern Paradigm –
    Closures and Functional Programming*, such as `map` and `filter` are generic;
    they can be used with any type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们实际上之前已经使用过泛型函数。我们在[第5章](ch05.html "第5章。现代范式 - 闭包和函数式编程")中查看的所有内置函数，如`map`和`filter`都是泛型的；它们可以与任何类型一起使用。
- en: We have even experienced generic types before. Arrays and dictionaries are also
    generic. The Swift team didn't have to write a new implementation of array and
    dictionary for every type that we might want to use inside the containers; they
    created them as generic types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至已经体验过泛型类型。数组和字典也是泛型的。Swift团队不需要为容器内可能使用的每个类型编写新的数组和字典实现；他们创建了泛型类型。
- en: Generic type
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'Similar to a generic function, a generic type is defined just like a normal
    type but it has a list of placeholders at the end of its name. Earlier in this
    chapter, we created our own containers for strings and `integers`. Let''s make
    a generic version of these containers, as shown:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与泛型函数类似，泛型类型就像一个普通类型一样定义，但它在名称的末尾有一个占位符列表。在本章早些时候，我们为字符串和`integers`创建了我们的容器。让我们创建这些容器的泛型版本，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This implementation looks similar to our type alias versions, but we are using
    the `ElementType` placeholder instead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现看起来与我们的类型别名版本相似，但我们使用的是`ElementType`占位符。
- en: 'While a generic function''s placeholders are determined when the function is
    called, a generic type''s placeholders are determined when initializing new instances:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然泛型函数的占位符是在函数调用时确定的，但泛型类型的占位符是在初始化新实例时确定的：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All future interactions with a generic instance must use the same types for
    its placeholders. This is actually one of the beauties of generics where the compiler
    does work for us. If we create an instance of one type and accidently try to use
    it as a different type, the compiler won''t let us. This protection does not exist
    in many other programming languages, including Apple''s previous language: Objective-C.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与一个通用实例的所有未来交互都必须使用相同的类型来为其占位符。这实际上是泛型之美之一，编译器为我们做了工作。如果我们创建了一个类型的实例，却意外地尝试将其用作不同类型，编译器不会允许我们这样做。这种保护在许多其他编程语言中都不存在，包括苹果之前使用的语言：Objective-C。
- en: 'One interesting case to consider is if we try to initialize a bag with an empty
    array:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个有趣的案例，如果我们尝试用一个空数组初始化一个包：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, we get an error that the compiler could not determine the type
    to assign to our generic placeholder. We can solve this by giving an explicit
    type to the generic we are assigning it to:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们得到了一个错误，编译器无法确定要分配给我们的泛型占位符的类型。我们可以通过给我们要分配的泛型一个显式类型来解决这个问题：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is great because not only can the compiler determine the generic placeholder
    types based on the variables we pass to them, it can also determine the type based
    on how we are using the result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太好了，因为编译器不仅可以根据我们传递给它们的变量来确定泛型占位符类型，还可以根据我们使用结果的方式来确定类型。
- en: 'We have already seen how to use generics in a powerful way. We solved the first
    problem we discussed in the type alias section about copying and pasting a bunch
    of implementations for different types. However, we have not yet figured out how
    to solve the second problem: how do we write a generic function to handle any
    type of our `Container` protocol? The answer is that we can use **type constraints**.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何以强大的方式使用泛型。我们解决了在类型别名部分讨论的第一个问题，即针对不同类型复制粘贴大量实现。然而，我们还没有弄清楚如何解决第二个问题：我们如何编写一个泛型函数来处理`Container`协议中的任何类型？答案是我们可以使用**类型约束**。
- en: Type constraints
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型约束
- en: Before we jump right into solving the problem, let's take a look at a simpler
    form of type constraints.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们直接跳入解决问题之前，让我们先看看类型约束的简单形式。
- en: Protocol constraints
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议约束
- en: 'Let''s say that we want to write a function that can determine the index of
    an instance within an array using an equality check. Our first attempt will probably
    look similar to the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一个函数，该函数可以使用相等性检查来确定实例在数组中的索引。我们的第一次尝试可能看起来像以下代码：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this attempt, we get an error that we cannot invoke the equality operator
    (`==`). This is because our implementation must work for any possible type that
    might be assigned to our placeholder. Not every type in Swift can be tested for
    equality. To fix this problem, we can use a type constraint to tell the compiler
    that we only want to allow our function to be called with types that support the
    equality operation. We add type constraints by requiring the placeholder to implement
    a protocol. In this case, Swift provides a protocol called `Equatable`, which
    we can use:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次尝试中，我们遇到了无法调用相等运算符（`==`）的错误。这是因为我们的实现必须适用于可能分配给我们的占位符的任何可能的类型。并不是Swift中的每个类型都可以进行相等性测试。为了解决这个问题，我们可以使用类型约束来告诉编译器，我们只想允许我们的函数以支持相等运算的类型调用。我们通过要求占位符实现一个协议来添加类型约束。在这种情况下，Swift提供了一个名为`Equatable`的协议，我们可以使用：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A type constraint looks similar to a type implementing a protocol using a colon
    (`:`) after a placeholder name. Now, the compiler is satisfied that every possible
    type can be compared using the equality operator. If we were to try to call this
    function with a type that is not equatable, the compiler would produce an error:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束看起来类似于在占位符名称后面使用冒号（`:`）来使用协议实现类型。现在，编译器已经满意，每个可能的类型都可以使用相等运算符进行比较。如果我们尝试用非可比较的类型调用这个函数，编译器会生成一个错误：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is another case where the compiler can save us from ourselves.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是编译器能帮助我们避免错误的一个例子。
- en: 'We can also add type constraints to our generic types. For example, if we tried
    to create a bag with our dictionary implementation without a constraint, we would
    get an error:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向我们的泛型类型添加类型约束。例如，如果我们尝试在没有约束的情况下使用我们的字典实现创建一个包，我们会得到一个错误：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is because the key of dictionaries has a constraint that it must be `Hashable`.
    Dictionary is defined as `struct Dictionary<Key : Hashable, Value>`. `Hashable`
    basically means that the type can be represented using an integer. In fact, we
    can look at exactly what it means if we write `Hashable` in Xcode and then click
    on it while holding down the *Command* Key. This brings us to the definition of
    `Hashable`, which has comments that explain that the hash value of two objects
    that are equal must be the same. This is important to the way that `Dictionary`
    is implemented. So, if we want to be able to store our elements as keys in a dictionary,
    we must also add the `Hashable` constraint:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '这是因为字典的键有一个约束，它必须是`Hashable`。字典定义为`struct Dictionary<Key : Hashable, Value>`。`Hashable`基本上意味着该类型可以用整数表示。实际上，如果我们把`Hashable`写在Xcode中，然后按住*Command*键点击它，就会带我们到`Hashable`的定义，其中包含注释解释两个相等对象的哈希值必须相同。这对`Dictionary`的实现方式很重要。因此，如果我们想能够在字典中将我们的元素作为键存储，我们必须也添加`Hashable`约束：'
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the compiler is happy and we can start to use our `Bag2` struct with any
    type that is `Hashable`. We are close to solving our `Container` problem, but
    we need a constraint on the type alias of `Container`, not `Container` itself.
    To do that, we can use a `where` clause.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器很高兴，我们可以开始使用我们的`Bag2`结构体与任何是`Hashable`类型的类型了。我们接近解决我们的`Container`问题，但我们需要对`Container`类型别名的类型进行约束，而不是对`Container`本身进行约束。为了做到这一点，我们可以使用一个`where`子句。
- en: Where clauses for protocols
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`where`子句用于协议'
- en: 'You can specify any number of `where` clauses you want after you have defined
    each placeholder type. They allow you to represent more complicated relationships.
    If we want to write a function that can check if our container contains a particular
    value, we can require that the element type is equatable:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了每个占位符类型之后，你可以指定任意数量的`where`子句。它们允许你表示更复杂的关系。如果我们想编写一个函数来检查我们的容器是否包含特定的值，我们可以要求元素类型是可比较的：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have specified a placeholder `C` that must implement the `Container`
    protocol; it must also have an `Element` type that is `Equatable`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了一个必须实现`Container`协议的占位符`C`；它还必须有一个是`Equatable`类型的`Element`类型。
- en: Sometimes we may also want to enforce a relationship between multiple placeholders.
    To do that, we can use an equality test inside the `where` clauses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能还想要在多个占位符之间强制建立关系。为了做到这一点，我们可以在`where`子句中使用等式测试。
- en: Where clauses for equality
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等式`where`子句
- en: 'If we want to write a function that can merge one container into another while
    still allowing the exact types to vary, we could write a function that would require
    that the containers hold the same value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想编写一个函数，可以将一个容器合并到另一个容器中，同时仍然允许确切的类型变化，我们可以编写一个函数，该函数要求容器持有相同的值：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we have specified two different placeholders: `C1` and `C2`. Both of
    them must implement the `Container` protocol and they must also contain the same
    `Element` type. This allows us to add elements from the second container into
    a copy of the first container that we return at the end.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了两个不同的占位符：`C1`和`C2`。它们都必须实现`Container`协议，并且它们还必须包含相同的`Element`类型。这允许我们将第二个容器的元素添加到我们最终返回的第一个容器的副本中。
- en: Now that we know how to create our own generic functions and types, let's take
    a look at how we can extend existing generics.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建自己的泛型函数和类型，让我们看看我们如何可以扩展现有的泛型。
- en: Extending generics
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展泛型
- en: The two main generics that we will probably want to extend are arrays and dictionaries.
    These are the two most prominent containers provided by Swift and are used in
    virtually every app. Extending a generic type is simple once you understand that
    an extension itself does not need to be generic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要扩展的两个主要泛型是数组和字典。这两个是最突出的容器，由Swift提供，几乎在每一个应用中都被使用。一旦你理解扩展本身不需要是泛型的，扩展泛型类型就很简单了。
- en: Adding methods to all forms of a generic
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向所有泛型形式添加方法
- en: 'Knowing that an array is declared as `struct Array<Element>`, your first instinct
    to extend an array might look something similar to this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 知道数组被声明为`struct Array<Element>`，你扩展数组的第一个直觉可能看起来像这样：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, as you can see, you would get an error. Instead, you can simply leave
    out the placeholder specification and still use the `Element` placeholder inside
    your implementations. Your other instinct might be to declare `Element` as a placeholder
    for your individual methods:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，你会得到一个错误。相反，你可以简单地省略占位符指定，仍然可以在你的实现中使用`Element`占位符。你的另一个直觉可能是将`Element`声明为你的单个方法的占位符：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is more dangerous because the compiler doesn''t detect an error. This
    is wrong because you are actually declaring a new placeholder `Element` to be
    used within the method. This new `Element` has nothing to do with the `Element`
    defined in `Array` itself. For example, you might get a confusing error if you
    tried to compare a parameter to the method to an element of the Array:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这更危险，因为编译器不会检测到错误。这是错误的，因为你实际上是在方法内部声明一个新的占位符`Element`。这个新的`Element`与在`Array`中定义的`Element`没有任何关系。例如，如果你尝试将一个参数与方法的元素与数组的元素进行比较，你可能会得到一个令人困惑的错误：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is because the `Element` defined in `Array` cannot be guaranteed to be
    the exact same type as the new `Element` defined in `addElement:`. You are free
    to declare additional placeholders in methods on generic types, but it is best
    to give them unique names so that they don't hide the type's version of the placeholder.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在 `Array` 中定义的 `Element` 不能保证与在 `addElement:` 中定义的新 `Element` 完全相同。你可以在泛型类型的方法中声明额外的占位符，但最好给它们唯一的名称，以免隐藏类型的占位符版本。
- en: 'Now that we understand this, let''s add an extension to the array that allows
    us to test if it contains an element passing a test:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了这一点，让我们添加一个扩展到数组中，允许我们测试它是否包含通过测试的元素：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we continue to use the placeholder `Element` within our extension.
    This allows us to call the passed in test closure for each element in the array.
    Now, what if we want to be able to add a method that will check if an element
    exists using the equality operator? The problem that we will run into is that
    array does not place a type constraint on `Element` requiring it to be `Equatable`.
    To do this, we can add an extra constraint to our extension.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在扩展中继续使用占位符 `Element`。这允许我们为数组中的每个元素调用传入的测试闭包。现在，如果我们想能够添加一个方法来检查元素是否存在，使用等号运算符，会发生什么问题？我们将遇到的问题是数组没有对
    `Element` 应用类型约束，要求它必须是 `Equatable`。为了做到这一点，我们可以在我们的扩展中添加一个额外的约束。
- en: Adding methods to only certain instances of a generic
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅向泛型类型的一定实例添加方法
- en: 'A constraint on an extension is written as a `where` clause, as shown:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的约束以 `where` 子句的形式编写，如下所示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here we add a constraint that guarantees that our element is equatable. This
    means that we will only be able to call this method on arrays that have equatable
    elements:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们添加了一个约束，保证我们的元素是可比较的。这意味着我们只能在这个方法上调用具有可比较元素的数组：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, Swift is protecting us from accidently trying to call this method on
    an array that it wouldn't work for.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Swift正在保护我们免受意外尝试在它不起作用的数组上调用此方法的风险。
- en: These are the building blocks that we have to play with generics. However, we
    actually have one more feature of protocols that we have not discussed, which
    works really well in combination with generics.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们必须与泛型一起使用的构建块。然而，我们实际上还有一个尚未讨论的协议特性，它与泛型结合得非常好。
- en: Extending protocols
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展协议
- en: 'We first discussed how we can extend existing types in [Chapter 3](ch03.html
    "Chapter 3. One Piece at a Time – Types, Scopes, and Projects"), *One Piece at
    a Time – Types, Scopes, and Projects*. In Swift 2, Apple added the ability to
    extend protocols. This has some fascinating implications, but before we dive into
    those, let''s take a look at an example of adding a method to the `Comparable`
    protocol:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在[第3章](ch03.html "第3章。一次一件——类型、作用域和项目") *一次一件——类型、作用域和项目* 中讨论了如何扩展现有类型。在Swift
    2中，苹果公司增加了扩展协议的能力。这有一些令人着迷的后果，但在我们深入探讨这些之前，让我们先看看如何向 `Comparable` 协议添加一个方法的示例：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This adds a method to all types that implement the Comparable. This means that
    it will now be available on any of the built-in types that are comparable and
    any of our own types that are comparable:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为所有实现 `Comparable` 的类型添加一个方法。这意味着它现在将可用于任何可比较的内置类型以及我们自己的任何可比较类型：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a really powerful tool. In fact, this is how the Swift team implemented
    many of the functional methods we saw in [Chapter 5](ch05.html "Chapter 5. A Modern
    Paradigm – Closures and Functional Programming"), *A Modern Paradigm – Closures
    and Functional Programming*. They did not have to implement the map method on
    arrays, dictionaries, or on any other sequence that should be mappable; instead,
    they implemented it directly on `SequenceType`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的工具。实际上，这就是Swift团队实现我们在[第5章](ch05.html "第5章。现代范式——闭包和函数式编程") *现代范式——闭包和函数式编程*
    中看到的许多功能方法的方式。他们不必在数组、字典或其他应可映射的序列上实现 map 方法；相反，他们直接在 `SequenceType` 上实现了它。
- en: This shows that similarly, protocol extensions can be used for inheritance,
    and it can also be applied to both classes and structures and types can also inherit
    this functionality from multiple different protocols because there is no limit
    to the number of protocols a type can implement. However, there are two major
    differences between the two.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明类似地，协议扩展可以用于继承，并且它也可以应用于类和结构体，类型也可以从多个不同的协议中继承这种功能，因为没有限制类型可以实现的协议数量。然而，两者之间有两个主要区别。
- en: 'First, types cannot inherit stored properties from protocols, because extensions
    cannot define them. Protocols can define read only properties but every instance
    will have to redeclare them as properties:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类型不能从协议继承存储属性，因为扩展不能定义它们。协议可以定义只读属性，但每个实例都必须重新声明它们作为属性：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Second, method overriding does not work in the same way with protocol extensions.
    With protocols, Swift does not intelligently figure out which version of a method
    to call based on the actual type of an instance. With class inheritance, Swift
    will call the version of a method that is most directly associated with the instance.
    Remember, when we called clean on an instance of our House subclass in [Chapter
    3](ch03.html "Chapter 3. One Piece at a Time – Types, Scopes, and Projects"),
    *One Piece at a Time – Types, Scopes, and Projects*, it calls the overriding version
    of clean, as shown:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，方法重写与协议扩展的工作方式不同。在协议中，Swift不会根据实例的实际类型智能地确定调用哪个版本的方法。在类继承中，Swift会调用与实例最直接关联的方法版本。记住，当我们调用[第三章](ch03.html
    "第三章. 一点一滴 – 类型、作用域和项目")中我们的`House`子类实例的`clean`方法时，*一点一滴 – 类型、作用域和项目*，它会调用重写的`clean`版本，如下所示：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, even though the building variable is defined as a `Building`, it is in
    fact a house; so Swift will call the house''s version of clean. The contrast with
    protocol extensions is that it will call the version of the method that is defined
    by the exact type the variable is declared as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，即使建筑变量被定义为`Building`类型，实际上它是一栋房子；因此Swift会调用房子的`clean`版本。与协议扩展的对比在于，它会调用变量声明为的确切类型的版本的方法：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we call clean on the house variable which is of type `House`, it calls
    the house version; however, when we cast the variable to a `Building` and then
    call it, it calls the building version.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用类型为`House`的`house`变量的`clean`方法时，它会调用房子的版本；然而，当我们将该变量转换为`Building`类型并调用它时，它会调用建筑的版本。
- en: All of this shows that it can be hard to choose between using structures and
    protocols or class inheritance. We will look at the last piece of that consideration
    in the next chapter on memory management, so we will be able to make a fully informed
    decision when moving forward.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都表明，在结构体、协议或类继承之间进行选择可能会很困难。我们将在下一章关于内存管理的章节中探讨这个考虑的最后一部分，这样我们就能在前进时做出完全明智的决定。
- en: Now that we have looked at the features available to us with generics and protocols,
    let's take this opportunity to explore some more advanced ways protocols and generics
    are used in Swift.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了泛型和协议为我们提供的功能，让我们抓住这个机会来探索在Swift中使用协议和泛型的一些更高级的方法。
- en: Putting protocols and generics to use
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将协议和泛型投入使用
- en: 'One cool part of Swift is generators and sequences. They provide an easy way
    to iterate over a list of values. Ultimately, they boil down to two different
    protocols: `GeneratorType` and `SequenceType`. If you implement the `SequenceType`
    protocol in your custom types, it allows you to use the for-in loop over an instance
    of your type. In this section, we will look at how we can do that.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的一个酷特性是生成器和序列。它们提供了一种轻松迭代值列表的方法。最终，它们归结为两个不同的协议：`GeneratorType`和`SequenceType`。如果你在你的自定义类型中实现了`SequenceType`协议，它允许你使用for-in循环遍历你的类型的实例。在本节中，我们将探讨我们如何做到这一点。
- en: Generators
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: The most critical part of this is the `GeneratorType` protocol. Essentially,
    a generator is an object that you can repeatedly ask for the next object in a
    series until there are no objects left. Most of the time you can simply use an
    array for this, but it is not always the best solution. For example, you can even
    make a generator that is infinite.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这中最关键的部分是`GeneratorType`协议。本质上，生成器是一个你可以反复询问序列中下一个对象的对象，直到没有对象为止。大多数时候你可以简单地使用数组来做这件事，但这并不总是最好的解决方案。例如，你甚至可以创建一个无限生成器。
- en: There is a famous infinite series of numbers called the Fibonacci sequence,
    where every number in the series is the sum of the two previous numbers. This
    is especially famous because it is found all over nature from the number of bees
    in a nest to the most pleasing aspect ratio of a rectangle to look at. Let's create
    an infinite generator that will produce this series.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个著名的斐波那契数列的无穷级数，其中序列中的每个数都是前两个数的和。这尤其著名，因为它在自然界中无处不在，从巢中的蜜蜂数量到矩形最令人愉悦的宽高比。让我们创建一个无限生成器，它将生成这个序列。
- en: We start by creating a structure that implements the `GeneratorType` protocol.
    The protocol is made up of two pieces. First, it has a type alias for the type
    of elements in the sequence and second, it has a mutating method called `next`
    that returns the next object in the sequence.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个实现`GeneratorType`协议的结构体。该协议由两部分组成。首先，它有一个类型别名，用于表示序列中的元素类型，其次，它有一个名为`next`的mutating方法，该方法返回序列中的下一个对象。
- en: 'The implementation looks similar to this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实现看起来像这样：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We defined a property called `values` that is a tuple representing the previous
    two values in the sequence. We update `values` and return the first element of
    the tuple each time `next` is called. This means that there will be no end to
    the sequence.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`values`的属性，它是一个表示序列中前两个值的元组。每次调用`next`时，我们都会更新`values`并返回元组的第一个元素。这意味着序列将没有尽头。
- en: 'We can use this generator on its own by instantiating it and then repeatedly
    calling next inside a while loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实例化它并在while循环中反复调用next来单独使用这个生成器：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We need to set up some sort of a condition so that the loop doesn't go on forever.
    In this case, we break out of the loop once the numbers get above 10\. However,
    this code is pretty ugly, so Swift also defines the protocol called `SequenceType`
    to clean it up.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置某种条件，以便循环不会无限进行。在这种情况下，一旦数字超过10，我们就跳出循环。然而，这段代码相当丑陋，所以Swift还定义了一个名为`SequenceType`的协议来清理它。
- en: Sequences
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列
- en: '`SequenceType` is another protocol that is defined as having a type alias for
    a `GeneratorType` and a method called `generate` that returns a new generator
    of that type. We could declare a simple sequence for our `FibonacciGenerator`,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequenceType`是另一个协议，它被定义为具有一个`GeneratorType`的类型别名和一个名为`generate`的方法，该方法返回该类型的新生成器。我们可以为我们的`FibonacciGenerator`声明一个简单的序列，如下所示：'
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Every for-in loop operates on the `SequenceType` protocol, so now we can use
    a for-in loop on our `FibonacciSequence`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个for-in循环都操作在`SequenceType`协议上，因此现在我们可以在`FibonacciSequence`上使用for-in循环：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is pretty cool; we can easily iterate over the Fibonacci sequence in a
    very readable way. It is much easier to understand the preceding code than it
    would be to understand a complicated while loop that has to calculate the next
    value of the sequence each time. Imagine all of the other type of sequences we
    can design such as prime numbers, random name generators, and so on.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常酷；我们可以轻松地以非常可读的方式迭代斐波那契数列。理解前面的代码比理解每次都要计算数列下一个值的复杂while循环要容易得多。想象一下我们可以设计的其他类型的序列，比如素数、随机姓名生成器等等。
- en: 'However, it is not always ideal to have to define two different types to create
    a single sequence. To fix this, we can use generics. Swift provides a generic
    type called `AnyGenerator` with a companion function called `anyGenerator:`. This
    function takes a closure and returns a generator that uses the closure as its
    next method. This means that we don''t have to explicitly create a generator ourselves;
    instead we can use `anyGenerator:` directly in a sequence:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，定义两种不同的类型来创建一个单一的序列并不总是理想的。为了解决这个问题，我们可以使用泛型。Swift提供了一个名为`AnyGenerator`的泛型类型，以及一个名为`anyGenerator:`的伴随函数。这个函数接受一个闭包，并返回一个使用闭包作为其next方法的生成器。这意味着我们不必显式地创建生成器；相反，我们可以在序列中直接使用`anyGenerator:`。
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this version of `FibonacciSequence`, we create a new generator every time
    generate is called that takes a closure that does the same thing that our original
    `FibonacciGenerator` was doing. We declare the `values` variable outside of the
    closure so that we can use it to store the state between calls to the closure.
    If your generator is simple and doesn't require a complicated state, using the
    `AnyGenerator` generic is a great way to go.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`FibonacciSequence`中，每次调用generate时，我们都会创建一个新的生成器，它接受一个闭包，执行与原始`FibonacciGenerator`相同的事情。我们在闭包外部声明`values`变量，以便我们可以使用它来在闭包调用之间存储状态。如果你的生成器很简单，不需要复杂的状态，使用`AnyGenerator`泛型是一个很好的选择。
- en: Now let's use this `FibonacciSequence` to solve the kind of math problem that
    computers are great at.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个`FibonacciSequence`来解决计算机擅长的数学问题。
- en: Product of Fibonacci numbers under 50
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 50以下斐波那契数的乘积
- en: What if we want to know what is the result of multiplying every number in the
    Fibonacci sequence under 50? We can try to use a calculator and painstakingly
    enter in all of the numbers, but it is much more efficient to do it in Swift.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道50以下斐波那契数中每个数的乘积是什么，我们可以尝试使用计算器并费力地输入所有数字，但使用Swift来做会更高效。
- en: 'Let''s start by creating a generic `SequenceType` that will take another sequence
    type and limit it to stop the sequence once it has reached a maximum number. We
    need to make sure that the type of the maximum value matches the type in the sequence
    and also that the element type is comparable. For that, we can use a where clause
    on the element type:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个通用的 `SequenceType` 开始，它将接受另一个序列类型并将其限制为达到最大数字时停止序列。我们需要确保最大值的类型与序列中的类型匹配，并且元素类型是可比较的。为此，我们可以在元素类型上使用
    where 子句：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that when we refer to the element type, we must go through the generator
    type.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们提到元素类型时，我们必须通过生成器类型进行。
- en: When our `SequenceLimiter` structure is created, it stores the original sequence.
    This is so that it can use the result of its `generate` method each time `generate`
    is called on this parent sequence. Each call to `generate` needs to start the
    sequence over again. It then creates an `AnyGenerator` with a closure that calls
    `next` on the locally initialized generator of the original sequence. If the value
    returned by the original generator is greater than or equal to the maximum value,
    we return `nil`, indicating that the sequence is over.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `SequenceLimiter` 结构被创建时，它会存储原始序列。这是为了让它每次在父序列上调用 `generate` 方法时都能使用 `generate`
    方法的返回结果。每次调用 `generate` 都需要重新开始序列。然后它创建一个 `AnyGenerator`，其中包含一个闭包，该闭包在原始序列的本地初始化生成器上调用
    `next`。如果原始生成器返回的值大于或等于最大值，我们返回 `nil`，表示序列已结束。
- en: 'We can even add an extension to `SequenceType` with a method that will create
    a limiter for us:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以向 `SequenceType` 添加一个扩展，其中包含一个为我们创建限制器的函数：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use `Self` as a placeholder representing the specific type of the instance
    the method is being called on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Self` 作为占位符，表示被调用方法的具体实例类型。
- en: 'Now, we can easily limit our Fibonacci sequence to only values under 50:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地将斐波那契序列限制在 50 以下：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last part we need to solve our problem is the ability to find the product
    of a sequence. We can do this with another extension. In this case, we are only
    going to support sequences that contain `Int`s so that we can ensure that the
    elements can be multiplied:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的最后一个问题是如何找到序列的乘积。我们可以通过另一个扩展来实现这一点。在这种情况下，我们只将支持包含 `Int` 的序列，这样我们就可以确保元素可以相乘：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This method takes advantage of the reduce function to start with the value
    one and multiply it by every value in the sequence. Now we can do our final calculation
    easily:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了 reduce 函数，从值一开始，乘以序列中的每个值。现在我们可以轻松地进行最终的计算：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Almost instantaneously, our program will return the result 2,227,680\. Now we
    can really understand why we call these devices computers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎瞬间，我们的程序就会返回结果 2,227,680。现在我们真正理解了为什么我们把这些设备称为计算机。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Protocols and generics are definitely complex, but we have seen that they can
    be used to effectively let the compiler protect us from ourselves. In this chapter,
    we have covered how protocols are like contracts for types to sign. We have also
    seen that protocols can be made more flexible using type aliases. Generics allow
    us to take full advantage of protocols with type aliases and also allow us to
    create powerful and flexible types that adapt to the contexts in which they are
    used. Finally, we looked at how we can use protocols and generics in the form
    of sequences and generators to solve a complex math problem in a very clean and
    understandable way, as an inspiration to solve other types of problems just as
    cleanly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和泛型确实很复杂，但我们已经看到它们可以有效地让编译器保护我们免受自己错误的影响。在本章中，我们介绍了协议如何像类型签订的合同。我们还看到，可以通过类型别名使协议更加灵活。泛型允许我们充分利用协议和类型别名，还可以创建强大且灵活的类型，这些类型可以适应它们被使用的上下文。最后，我们探讨了如何以序列和生成器形式使用协议和泛型，以非常干净和易于理解的方式解决一个复杂的数学问题，这可以作为解决其他类型问题的灵感。
- en: At this point we have covered all of the core features of the Swift language.
    We are now ready to look a little bit deeper at how data is actually stored while
    a program is run and how we can best manage the resources used by our programs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了 Swift 语言的所有核心功能。我们现在可以更深入地了解程序运行时数据的实际存储方式以及我们如何最好地管理程序使用的资源。
