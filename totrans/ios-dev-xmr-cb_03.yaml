- en: Chapter 3. User Interface – View Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a view with a view controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through different view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing controllers in tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using view controllers efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI flow design with storyboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwinding in storyboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed views and how to use them. In most cases of real world
    app scenarios, views alone are not enough. Apple provides another base class,
    the `UIViewController` class, which is responsible for managing views. A view
    controller can respond to device notifications, such as when the device rotates,
    or can provide different ways to display and dismiss multiple views or even other
    view controllers. There are a number of view controllers available for us to use.
    In this chapter, we will discuss the most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'These view controllers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UIViewController**: This is the base class of all view controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UINavigationController**: This is the view controller that provides various
    ways of navigating through different view controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UITabBarController**: This is a view controller that displays multiple view
    controllers in a tab-like interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad-specific view controllers**: These are the view controllers that only
    apply to the iPad device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, we will learn how to create our own custom view controllers, and
    we will create an app whose user interface will be created with storyboard files.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a view with a view controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UIViewController` class to manage
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPhone **Empty Project** in Xamarin Studio and name it `ViewControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to load a view with a view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project in the **Solution** pad and go to **Add** | **New
    File…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog that will appear, select **iPhone View Controller** from the **iOS**
    section. Name it `MainViewController` and click on the **New** button. Xamarin
    Studio will create a new XIB file and will automatically open the `MainViewController.cs`
    source file. This file contains a class that overrides the `UIViewController`
    class, and we can implement any code related to our view controller in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UILabel` on the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and connect an outlet for it inside the `MainViewController` class and
    name it `myLabel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the text `View in controller!` in the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the XIB document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Xamarin Studio, enter the following code in the `FinishedLaunching` method
    of the `AppDelegate` class, right after the window initialization line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we add a new `iPhone View Controller` file in a project, in this case
    `MainViewController`, Xamarin Studio basically creates and adds the following
    three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainViewController.xib`: This is the XIB file that contains the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainViewController.cs`: This is the C# source file that implements the class
    of our controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainViewController.designer.cs`: This is the autogenerated source file that
    reflects the changes we make to the controller in Interface Builder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that we do not need to add an outlet for the view as this is taken care
    of by Xamarin Studio. We initialize the controller through its class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we assign the controller to the `window.RootViewController` property,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our view controller is now the root view controller of our app's window, and
    it is the first one that will be shown when the app starts.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project we have just created only shows how we can add a controller with
    a view. Notice that we created the outlet for the label inside the `MainViewController`
    class, which acts as the file''s owner object in the XIB file. To provide some
    functionality for the `MainViewController` class, add the following method in
    the `MainViewController` class in the `MainViewController.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method overrides the `UIViewController.ViewDidLoad()` method, which is
    executed after the controller has loaded its view.
  prefs: []
  type: TYPE_NORMAL
- en: UIViewController methods to override
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `UIViewController` class contains a number of methods that allow us to
    manage the view controller''s life cycle. These methods are called by the system
    on the view controller, and we can override them to add our own implementation.
    Some of these methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewWillAppear`: This method is called when the controller''s view is about
    to appear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewDidAppear`: This method is called when the controller''s view has been
    displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewWillDisappear`: This method is called when the controller''s view is about
    to disappear, for example, when another controller will be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewDidDisappear`: This method is called when the view has disappeared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Navigating through different view controllers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating an iOS project with Xamarin Studio* and *Accessing the UI with
    Outlets* recipes from [Chapter 1](ch01.html "Chapter 1. Development Tools"), *Development
    Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through different view controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UINavigationController` class
    to navigate among multiple view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UINavigationController` class is a controller that provides hierarchical
    navigation functionality with multiple view controllers. Create a new iPhone **Empty
    Project** in Xamarin Studio and name it `NavigationControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create navigation among multiple view controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: Add three new iPhone view controllers in the project and name them `MainController`,
    `ViewController1`, and `ViewController2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `AppDelegate.cs` file and add the following code in the `FinishedLaunching`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `MainController.xib` in Interface Builder and add two buttons with their
    corresponding outlets. Set their titles to `First View` and `Second View`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `ViewDidLoad` method of the `MainController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a button in each of the `ViewController1` and `ViewController2` controllers
    in Interface Builder with the title `Pop to root`. Then, add the following code
    in both of these controllers'' `ViewDidLoad` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the buttons and see how the user interface navigates from one controller
    to another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UINavigationController` class preserves a stack of controllers. The `UIViewController`
    class has a property named `NavigationController`. In normal situations, this
    property returns null. However, if the controller is pushed into a navigation
    controller''s stack, it returns the instance of the navigation controller. In
    this case, all of our controllers'' `NavigationController` property will return
    the instance of our navigation controller. So this way, at any point in the hierarchy
    of controllers, access to the navigation controller is provided. To push a view
    controller to the navigation stack, we call the `UINavigationController.PushViewController(UIViewController,
    bool)` method, using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `MainController` class is the topmost or root controller in
    the navigation stack. A navigation controller must have at least one view controller
    that will act as its root controller. We can provide it upon initialization of
    the navigation controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To return to the root controller, we call the `PopToRootViewController(bool)`
    method inside the current controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The boolean parameters in both methods are used for animating the transition
    between the view controllers. Setting it to `false` will result in the controllers
    instantly snapping onto the screen, which in most cases does not provide a very
    good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this simple example, we provided backward navigation to the root controller
    with buttons. Notice that there is an arrow-shaped button at the top bar, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/8924OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This top bar is called the navigation bar and is of the `UINavigationBar` type.
    The arrow-shaped button is called the back button and is of the `UIBarButtonItem`
    type. The back button, when it exists, always navigates to the previous controller
    in the navigation stack. If the previous controller in the stack has its `Title`
    property set, the back button will display that title. If it does not have a title,
    the back button will be titled `Back`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing navigation bar buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change, add, and hide the buttons of the navigation bar, we can use the
    following methods of our currently displayed view controller''s `NavigationItem`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetLeftBarButtonItem`: This method adds a custom button on the left-hand side
    of the navigation bar, replacing the default back button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetRightBarButtonItem`: This method adds a custom button on the right-hand
    side of the navigation bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetHidesBackButton`: This method sets the visibility of the default back button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To remove or hide the custom buttons on the left or right-hand side of the navigation
    bar, call the appropriate methods passing null instead of a `UIBarButtonItem`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Modal view controllers* and *Using view controllers efficiently* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Animating views* recipe in [Chapter 11](ch11.html "Chapter 11. Graphics
    and Animation"), *Graphics and Animation*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing controllers in tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display multiple view controllers in a
    tabbed interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UITabBarController` class provides a way to display different view controllers
    on the same hierarchy level divided into a tab-like interface. Create a new iPhone
    **Empty Project** in Xamarin Studio and name it `TabControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to provide controllers in tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two iPhone view controllers to the project. Name them `MainController` and
    `SettingsController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `ViewDidLoad` method of `MainController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `ViewDidLoad` method of `SettingsController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `FinishedLaunching` method of the `AppDelegate`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app on the simulator. Click on each of the tabs at the bottom. The interface
    should be similar to the following screenshot when `MainController` is selected:![How
    to do it…](img/8924OT_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UITabBarController` class displays one tab for each of the controllers
    it manages. That tab is of the `UITabBarItem` type that can accept both text and
    images. We set the controllers it will display through its `SetViewControllers`
    property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have added the controllers, we can access its tab bar items through
    the `TabBar` property. In this case, we set the tab''s `Title` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each `UIViewController` contains a `TabController` property. Similar to the
    `NavigationController` property, when the controller is part of a tab controller,
    the property will return the instance of that tab controller.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The controller can accept as many controllers as we want but if we add six or
    more, four will be displayed with their tabs, while a fifth predefined **More**
    tab will represent all the remaining controllers. This is to keep the interface
    easily accessible to the user by keeping the tabs to a specific size suitable
    for human fingers. When we add more than six controllers in a tab bar controller
    interface, by default, the object provides an **Edit** button on top in the **More**
    tab that allows the user to rearrange the order of controllers. If we want to
    exclude some controllers from this functionality, we have to remove it from the
    `CustomizableViewControllers` array.
  prefs: []
  type: TYPE_NORMAL
- en: Useful UITabBarController properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some more useful properties of the `UITabBarController` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewControllers`: This is an array containing all the controllers that the
    tab controller holds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedIndex`: This is the zero-based index of the selected tab. Setting
    this property to the desired index programmatically selects the corresponding
    controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedViewController`: This is the currently selected controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining tab selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine when the user has selected a tab on a tab controller, we can subscribe
    to its `ViewControllerSelected` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using view controllers efficiently* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal view controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to display view controllers modally.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A modal view controller is any controller that is presented above other views
    or controllers. The concept is similar to displaying a Windows Form as a dialog,
    which takes control of the interface and does not allow access to other windows
    of the application unless it is dismissed. Create a new iPhone **Empty Project**
    in Xamarin Studio and name it `ModalControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two view controllers to the project and name them `MainController` and `ModalController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainController.xib` file in Interface Builder and add a button on
    its view with the title `Present`. Create and connect the appropriate outlet for
    the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainController` class, add the following code in the `ViewDidLoad`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `ModalController.xib` file. Add a button on its view with the title
    `Dismiss` and create the appropriate outlet for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its view background color to something other than white. Save the document
    and enter the following code in the `ViewDidLoad` method of `ModalController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add code to display the main controller in the `FinishedLaunching`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Click on the **Present** button and
    watch the modal controller present itself on top of the main controller. Click
    on the **Dismiss** button to hide it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each controller object has two methods that handle presenting and dismissing
    controllers modally. In our example, we call the `PresentViewControllerAsync(UIViewController,
    bool)` method to present a controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Its first parameter represents the controller we want to display modally, and
    the second parameter determines if we want the presentation to be animated. To
    dismiss the controller, we call its `DismissViewControllerAsync(bool)` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It accepts only one parameter that toggles the animation for the dismissal.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use `async`/`await` and the methods with the `Async` suffix
    to present and dismiss a controller modally. These methods are included in Xamarin.iOS
    for convenience. We can also use `PresentViewController` and `DismissViewController`;
    both accept another parameter of the `NSAction` type that represents the callback
    of the completion. However, no need to get into all that "trouble", right?
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define the transition style for a modal view controller presentation
    with the controller''s `ModalTransitionStyle` property. Enter the following line
    of code before presenting the modal controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The main controller will flip to present the modal controller, giving the impression
    it is attached behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a modal controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each controller that presents another controller modally provides access to
    its "child" controller through the `ModalController` property. If you need to
    access the modal controller through this property, make sure to do it before the
    `DismissViewControllerAsync` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: How many modal controllers?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In theory, we can present an unlimited number of modal controllers. Of course,
    there are two restrictions on this, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory is not unlimited**: View controllers consume memory, so the more view
    controllers we present, the worst performance we get.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad user experience**: Presenting many controllers modally might confuse
    the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, it is advised to not present more than one consecutive controller
    modally.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Navigating through different view controllers* and *Providing controllers
    in tabs* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a subclass of `UIViewController`
    and use it to derive view controllers that were created in Interface Builder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a custom view controller that will act as a base
    controller, providing common functionality among its inheritors. Create a new
    iPhone **Empty Project** in Xamarin Studio and name it `CustomControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project in the **Solution** pad and go to **Add** | **New
    File…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog that appears, navigate to **General** | **Empty Class**. Name
    the file `BaseController` and click on the **New** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `BaseController.cs` file that was just created and modify it to match
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add an iPhone view controller to the project and name it `DerivedController`.
    Change the class it inherits from `UIViewController` to `BaseController` in its
    class definition: `public partial class DerivedController : BaseController`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the derived controller to be the root view controller of the main window
    (in `AppDelegate.cs`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Click-and-drag the mouse pointer on
    the white surface and watch Xamarin Studio's application output pad displaying
    the current position of the pointer on the simulator's screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we have done here is that we have created a base controller class that
    can be used in multiple Xamarin.iOS projects. The functionality we have added
    to this controller is to respond to user touches. Any controller that inherits
    it will inherit the same functionality. The code we have added to create the `BaseController`
    class is fairly simple. To make this work, we have added the following constructor
    to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is the base constructor that will get called when we initialize the `DerivedController`
    class with the new keyword, `this.derivedController = new DerivedController();`,
    through our derived object's `DerivedController()` constructor. So, what this
    practically means is that we can normally use inheritance with controllers that
    are loaded from XIB files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also create base controllers from XIB files. However, if the XIB files
    contain outlets, we need to make sure to populate these outlets in our derived
    classes; otherwise, they will not be available in our derived controllers. For
    example, if we have an outlet for a button named `btnStart` in the base XIB file,
    we would have to create the following property in our derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `Outlet` attribute tells the runtime that the specific property is an outlet.
    Not only that, it also helps Xamarin Studio in creating the Xcode project when
    we are using the derived class in a XIB.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Loading a view with a view controller*, *Using view controllers efficiently*,
    and *UI flow design with storyboards recipes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding and customizing views* recipe in [Chapter 2](ch02.html "Chapter 2. User
    Interface – Views"), *User Interface – Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using view controllers efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iOS is very strict about memory usage. If an app uses too much memory, iOS will
    issue memory warnings. If we do not respond to these memory warnings accordingly
    by releasing resources that are not needed, it is very likely that iOS will terminate
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see what we can do to avoid this situation. Create a new project in Xamarin
    Studio and name it `EfficientControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a view controller to the project and name it `MainController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `DidReceiveMemoryWarning` method of the `MainController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the controller the root view controller of the app in `AppDelegate.cs`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With iOS Simulator window active, navigate to **Hardware** | **Simulate Memory
    Warning** on the menu bar, as shown in the following screenshot:![How to do it…](img/8924OT_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the **Application Output** pad in Xamarin Studio. You should see an output
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project does not provide any useful functionality. Its main purpose is
    to show how to get notified on memory warnings issued by iOS.
  prefs: []
  type: TYPE_NORMAL
- en: When a memory warning is issued, the `DidReceiveMemoryWarning` method will be
    called on all instantiated view controllers that are currently in memory. When
    this method is called, we should make sure we release the resources that are not
    currently required. This way, we are making more memory available to the system.
  prefs: []
  type: TYPE_NORMAL
- en: iOS Simulator provides the option of simulating memory warnings so that we can
    test how our app will behave when memory is low. On a real device, we cannot force
    the system to issue memory warnings on demand. Note that although we can practically
    simulate an unlimited number of memory warnings on the simulator, the app will
    never be terminated. On the other hand, on the device, the app will be terminated
    after two or three memory warnings (the actual number varies according to memory
    usage), so we need to take this into account.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'View controllers are not the only object that can receive memory warnings.
    We can capture memory warning notifications by overriding the `UIApplicationDelegate.ReceiveMemoryWarning(UIApplication)`
    method inside the `AppDelegate` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a custom view controller* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Interface Builder* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad view controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the controllers we have worked with so far can be used in both iPhone and
    iPad applications. There are, however, two controllers that are only available
    to the iPad. These are the `UISplitViewController` and `UIPopoverController` classes.
    In this recipe, we will create an iPad project that uses the `UISplitViewController`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPad **Empty Project** and name it `SplitControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two iPad view controllers to the project and name them `FirstController`
    and `SecondController`. Set the background colors of their views to different
    colors, for example, blue for `FirstController` and yellow for `SecondController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `SecondController.xib` in Interface Builder and add `UIToolbar` close to
    the top of its view. Connect the toolbar to an outlet named `myToolbar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the properties that represent the outlets are created as private
    by Xamarin Studio. Add the following property in the `SecondController` class
    to expose the toolbar outlet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following class to the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `FinishedLaunching` method of the `AppDelegate`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **First** button on the toolbar. `FirstController` should slide
    in from the side. The result is similar to the following screenshot:![How to do
    it…](img/8924OT_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UISplitViewController` class helps to take full advantage of the iPad's
    larger screen. It provides a way of displaying two different views simultaneously
    on the same screen area. It does this by displaying one controller in fullscreen
    in the portrait orientation and a secondary controller whenever is needed, in
    a smaller size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide access to both controllers in our project to the user, we have implemented
    a class that inherits from `UISplitViewControllerDelegate` and assigned it to
    our split controller inside the `FinishedLaunching` method. The `Delegate` object
    we created overrides two methods. In the first method, we assign a button to the
    toolbar, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WillHideViewController` method is executed whenever `UISplitViewController`
    changes orientation from landscape to portrait and its smaller controller is about
    to be hidden. So to display it, we provide a button on the fullscreen controller''s
    toolbar. When we click on that button, the other controller will slide in from
    the side. When the orientation changes from portrait to landscape, the smaller
    controller appears beside the larger controller automatically. So, we no longer
    need the button on the toolbar; hence, we override the `WillShowViewController`
    method to remove it. We do this by assigning an empty `UIBarButtonItem[]` array,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To rotate the simulator to (and from) the landscape orientation, press *Cmd*
    and the left arrow key (or the right arrow key) with the app running on iOS Simulator.
    The following screenshot shows iOS Simulator rotated in landscape orientation.
    No other action was taken to make both controllers appear at the same time, as
    the split controller handles this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/8924OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: iPad-specific controller usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although all other controllers are available to both the iPhone and iPad, an
    exception will occur if a `UISplitViewController` method is used in an app that
    runs on an iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adjusting UI orientation* recipe in [Chapter 9](ch09.html "Chapter 9. Interacting
    with Device Hardware"), *Interacting with Device Hardware*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI flow design with storyboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back when iOS 5 was released, Apple introduced **storyboards**. A storyboard
    is a new type of user interface file that accepts multiple view controllers, but
    it also holds information about how all these controllers relate to each other
    in the hierarchy of an application. Storyboards are very helpful when designing
    the screens of an application, as they are more efficient than loading different
    controllers from individual XIB files; they also keep a group of view controllers
    together in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPhone **Empty Project** in Xamarin Studio and name it `StoryboardApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xamarin Studio includes a number of project templates for storyboard applications.
    We will, however, use an empty iPhone project because it will help us to better
    comprehend how storyboards work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two new C# classes (not view controllers) to the project and name them `FirstController`
    and `SecondController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Derive both classes from `UIViewController` and decorate them with the `Register`
    attribute. Make sure that you pass a different name for each controller in the
    attribute, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `FirstController` class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `SecondController` class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `IntPtr` constructor of `UIViewController` in both classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add an `Empty iPhone Storyboard` file to the project and name it `MainStoryboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainStoryboard.storyboard` file that was created in Interface Builder.
    Just like opening XIBs, double-click on the file in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `UINavigationController` on the empty canvas. By default, Xcode adds a
    table view when adding navigation controllers. Select it and delete it by pressing
    the *Backspace* key; we only need the navigation controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two `UIViewController` objects to the canvas. By selecting each view controller
    individually, set their **Class** field in the **Identity Inspector** window to
    the classes we created in the preceding steps. The following screenshot shows
    the **Class** field of the first controller set to **FirstController**:![How to
    do it...](img/8924OT_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to connect the controllers. Just like adding an outlet, press *Ctrl*
    and drag from the navigation controller to `FirstController`. In the context menu
    that will appear when you release the button, select **root view**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UIButton` on `FirstController`. Press *Ctrl* and drag from the button to
    `SecondController`. Select **push** in the context menu that will appear. No need
    to connect the button to an outlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, add the following code in the `FinishedLaunching` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Clicking on the button will push the
    second controller into display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you see, we managed to create the user interface for the application with
    minimal code. Inside storyboard files, we need to connect each element with each
    other, according to how we want the screen hierarchy to appear. We first set `FirstController`
    as a root view controller to the navigation controller. Then, we assigned a relationship
    to the button with the `SecondController` class. So, when the button is clicked,
    the `SecondController` class will be pushed into the navigation controller's stack,
    just as if we were calling the `UINavigationController.PushViewController` method.
    This relationship is called **segue**. In a storyboard file, we can individually
    select segues and set their properties. For example, we can set an identifier
    string or change its behavior from **push** to **modal**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FinishedLaunching` method, we first instantiate a `UIStoryboard` instance
    through the static `UIStoryboard.FromName` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call the `InstantiateInitialViewController` method to get the initial
    controller of the storyboard, as follows. In this case, the initial controller
    is `UINavigationController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to cast the return value to the correct type of controller,
    as its return type is `NSObject`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also initiate segues programmatically. To do this, we first need to
    select the segue in Xcode and set an identifier for it through the **Attributes**
    inspector tab. Then, we can trigger it through code by calling the `PerformSegue`
    method of the `UIViewController` instance it belongs to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Passing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With storyboards, the system is instantiating the view controllers we need.
    We can have access to the view controller that will be displayed through a segue
    by overriding the `PrepareForSegue` method on the controller that is the owner,
    or source of the segue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is also a `UIStoryboardSegue` class which provides us
    with the necessary information.
  prefs: []
  type: TYPE_NORMAL
- en: The `PrepareForSegue` method is called after the involving view controllers
    have been instantiated and before the segue starts. So, by determining which segue
    triggered the preparation method through the `Identifier` property, we retrieve
    the controller that the segue will display through the `DestinationViewController`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PrepareForSegue` method will be called regardless if the segue was triggered
    programmatically through the `PerformSegue` method or was just set to a button
    in the storyboard file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Interface Builder* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwinding in storyboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very useful feature of storyboards is **unwinding**. Unwinding is a
    process similar to that of a segue, but instead of presenting the next view controller,
    it reverses to a previous view controller in a storyboard. The great thing about
    it is that it allows us to go back to any view controller, not just the one that
    is right before the current controller we are in. This recipe will show how to
    use unwinding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need the project `StoryboardApp` we created in the
    previous recipe. Open it in Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement unwinding:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class to the project and name it `ModalController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the class a custom view controller, similar to `FirstController` and `SecondController`
    in the project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method in the `FirstController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `MainStoryboard.storyboard` file in Xcode and add another `UIViewController`.
    Set this controller's **Class** to **ModalController**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **UIButton** to `SecondController` and set its title to `Show modal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* and drag from the button to `ModalController`. Set this segue to
    **modal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another button, this time on `ModalController`. Set its title to `Unwind
    to first`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* and drag from the button to the **Exit** item on the controller's
    dock, as shown in the following screenshot:![How to do it…](img/8924OT_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **unwindFromModalController** in the context menu that will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app on the simulator. Flow through the screens until you
    reach the modal controller and click on the **Unwind to first** button. The user
    interface will flow back to the first controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using unwinding or **unwind segues**, we can get back to any controller
    in the hierarchy. The basic requirement is to add a method decorated with the
    `Action` attribute to the controller you want to unwind to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The attribute will basically expose the method as an action to Xcode so that
    when the storyboard file is opened, we will be able to add the unwind segue. This
    is how the action **unwindFromModalController** appeared when we dragged to the
    **Exit** item. It doesn't matter if the action is inside another class Xcode is
    smart enough to search all classes in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Exit** item in the dock of every view controller is responsible for creating
    unwind segues. It represents the exit of a view controller, which is determined
    by how the controller was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can have access to the controller that initiated the unwind segue through
    the `UIStoryboardSegue` object that is passed to the unwind action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Where is the unwind segue in the storyboard?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we create unwind segues, there is no apparent change in Xcode''s appearance
    or an indication that we created something, like when we create segues. After
    creating the unwind, we can find it by expanding the document outline, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Where is the unwind segue in the storyboard?](img/8924OT_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Navigating through different view controllers* and *Modal view controllers*
    recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
