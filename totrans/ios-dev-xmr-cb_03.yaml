- en: Chapter 3. User Interface – View Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 用户界面 – 视图控制器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Loading a view with a view controller
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图控制器加载视图
- en: Navigating through different view controllers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的视图控制器之间导航
- en: Providing controllers in tabs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签页中提供控制器
- en: Modal view controllers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态视图控制器
- en: Creating a custom view controller
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义视图控制器
- en: Using view controllers efficiently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用视图控制器
- en: iPad view controllers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPad视图控制器
- en: UI flow design with storyboards
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用故事板进行UI流程设计
- en: Unwinding in storyboards
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在故事板中回滚
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have discussed views and how to use them. In most cases of real world
    app scenarios, views alone are not enough. Apple provides another base class,
    the `UIViewController` class, which is responsible for managing views. A view
    controller can respond to device notifications, such as when the device rotates,
    or can provide different ways to display and dismiss multiple views or even other
    view controllers. There are a number of view controllers available for us to use.
    In this chapter, we will discuss the most important ones.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了视图及其使用方法。在大多数现实世界的应用程序场景中，仅使用视图是不够的。Apple提供了一个另一个基类，即`UIViewController`类，它负责管理视图。视图控制器可以响应设备通知，例如当设备旋转时，或者可以提供不同的方式来显示和关闭多个视图，甚至其他视图控制器。有许多视图控制器可供我们使用。在本章中，我们将讨论其中最重要的。
- en: 'These view controllers are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图控制器如下：
- en: '**UIViewController**: This is the base class of all view controllers.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIViewController**：这是所有视图控制器的基类。'
- en: '**UINavigationController**: This is the view controller that provides various
    ways of navigating through different view controllers.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UINavigationController**：这是一个提供多种在不同视图控制器之间导航方式的视图控制器。'
- en: '**UITabBarController**: This is a view controller that displays multiple view
    controllers in a tab-like interface.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UITabBarController**：这是一个在类似标签的界面中显示多个视图控制器的视图控制器。'
- en: '**iPad-specific view controllers**: These are the view controllers that only
    apply to the iPad device.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对iPad的视图控制器**：这些是仅适用于iPad设备的视图控制器。'
- en: Furthermore, we will learn how to create our own custom view controllers, and
    we will create an app whose user interface will be created with storyboard files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将学习如何创建我们自己的自定义视图控制器，并且我们将创建一个用户界面使用故事板文件创建的应用程序。
- en: Loading a view with a view controller
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图控制器加载视图
- en: In this recipe, we will learn how to use the `UIViewController` class to manage
    views.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用`UIViewController`类来管理视图。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPhone **Empty Project** in Xamarin Studio and name it `ViewControllerApp`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的iPhone **空项目**，命名为`ViewControllerApp`。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to load a view with a view controller:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用视图控制器加载视图：
- en: Add a new file to the project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新文件。
- en: Right-click on the project in the **Solution** pad and go to **Add** | **New
    File…**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**解决方案**面板中的项目，然后转到**添加** | **新建文件…**。
- en: In the dialog that will appear, select **iPhone View Controller** from the **iOS**
    section. Name it `MainViewController` and click on the **New** button. Xamarin
    Studio will create a new XIB file and will automatically open the `MainViewController.cs`
    source file. This file contains a class that overrides the `UIViewController`
    class, and we can implement any code related to our view controller in it.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的对话框中，从**iOS**部分选择**iPhone 视图控制器**。命名为`MainViewController`并点击**新建**按钮。Xamarin
    Studio将创建一个新的XIB文件，并自动打开`MainViewController.cs`源文件。此文件包含一个覆盖`UIViewController`类的类，我们可以在其中实现与我们的视图控制器相关的任何代码。
- en: Open the `MainViewController.xib` file in Interface Builder.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`MainViewController.xib`文件。
- en: Add `UILabel` on the view.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加`UILabel`。
- en: Create and connect an outlet for it inside the `MainViewController` class and
    name it `myLabel`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainViewController`类中为其创建并连接一个输出，命名为`myLabel`。
- en: Enter the text `View in controller!` in the label.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签中输入文本`View in controller!`。
- en: Save the XIB document.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存XIB文档。
- en: 'In Xamarin Studio, enter the following code in the `FinishedLaunching` method
    of the `AppDelegate` class, right after the window initialization line:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中，在`AppDelegate`类的`FinishedLaunching`方法中，在窗口初始化行之后输入以下代码：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run the app on the simulator.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'When we add a new `iPhone View Controller` file in a project, in this case
    `MainViewController`, Xamarin Studio basically creates and adds the following
    three files:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在项目中添加一个新的 `iPhone 视图控制器` 文件时，在这种情况下是 `MainViewController`，Xamarin Studio基本上会创建并添加以下三个文件：
- en: '`MainViewController.xib`: This is the XIB file that contains the controller.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainViewController.xib`: 这是一个包含控制器的 XIB 文件。'
- en: '`MainViewController.cs`: This is the C# source file that implements the class
    of our controller.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainViewController.cs`: 这是一个实现我们控制器类的 C# 源文件。'
- en: '`MainViewController.designer.cs`: This is the autogenerated source file that
    reflects the changes we make to the controller in Interface Builder.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainViewController.designer.cs`: 这是一个自动生成的源文件，它反映了我们在 Interface Builder 中对控制器所做的更改。'
- en: 'Notice that we do not need to add an outlet for the view as this is taken care
    of by Xamarin Studio. We initialize the controller through its class, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为视图添加出口，因为这是由 Xamarin Studio 处理的。我们通过其类初始化控制器，如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we assign the controller to the `window.RootViewController` property,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将控制器分配给 `window.RootViewController` 属性，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our view controller is now the root view controller of our app's window, and
    it is the first one that will be shown when the app starts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点控制器现在是应用程序窗口的根视图控制器，并且是应用程序启动时首先显示的一个。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The project we have just created only shows how we can add a controller with
    a view. Notice that we created the outlet for the label inside the `MainViewController`
    class, which acts as the file''s owner object in the XIB file. To provide some
    functionality for the `MainViewController` class, add the following method in
    the `MainViewController` class in the `MainViewController.cs` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的项目仅展示了我们如何添加具有视图的控制器。注意，我们在 `MainViewController` 类内部创建了标签的出口，该类在 XIB
    文件中充当文件的所有者对象。为了为 `MainViewController` 类提供一些功能，在 `MainViewController.cs` 文件中的
    `MainViewController` 类中添加以下方法：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method overrides the `UIViewController.ViewDidLoad()` method, which is
    executed after the controller has loaded its view.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法重写了 `UIViewController.ViewDidLoad()` 方法，该方法在控制器加载其视图之后执行。
- en: UIViewController methods to override
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要重写的 UIViewController 方法
- en: 'The `UIViewController` class contains a number of methods that allow us to
    manage the view controller''s life cycle. These methods are called by the system
    on the view controller, and we can override them to add our own implementation.
    Some of these methods are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewController` 类包含许多方法，允许我们管理视图控制器的生命周期。这些方法由系统在视图控制器上调用，我们可以重写它们以添加自己的实现。以下是一些这些方法：'
- en: '`ViewWillAppear`: This method is called when the controller''s view is about
    to appear.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewWillAppear`: 当控制器的视图即将出现时，将调用此方法。'
- en: '`ViewDidAppear`: This method is called when the controller''s view has been
    displayed.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidAppear`: 当控制器的视图已被显示时，将调用此方法。'
- en: '`ViewWillDisappear`: This method is called when the controller''s view is about
    to disappear, for example, when another controller will be displayed.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewWillDisappear`: 当控制器的视图即将消失时，将调用此方法，例如，当另一个控制器将被显示时。'
- en: '`ViewDidDisappear`: This method is called when the view has disappeared.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidDisappear`: 当视图消失时，将调用此方法。'
- en: See also
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Navigating through different view controllers* recipe
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同的视图控制器之间导航* 的配方'
- en: The *Creating an iOS project with Xamarin Studio* and *Accessing the UI with
    Outlets* recipes from [Chapter 1](ch01.html "Chapter 1. Development Tools"), *Development
    Tools*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 [第 1 章](ch01.html "第 1 章。开发工具") 的 *使用 Xamarin Studio 创建 iOS 项目* 和 *使用出口访问
    UI* 配方，*开发工具*
- en: Navigating through different view controllers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同的视图控制器之间导航
- en: In this recipe, we will learn how to use the `UINavigationController` class
    to navigate among multiple view controllers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用 `UINavigationController` 类在多个视图控制器之间进行导航。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UINavigationController` class is a controller that provides hierarchical
    navigation functionality with multiple view controllers. Create a new iPhone **Empty
    Project** in Xamarin Studio and name it `NavigationControllerApp`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINavigationController` 类是一个提供具有多个视图控制器的分层导航功能的控制器。在 Xamarin Studio 中创建一个新的
    iPhone **空项目**，并将其命名为 `NavigationControllerApp`。'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to create navigation among multiple view controllers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在多个视图控制器之间创建导航：
- en: Add three new iPhone view controllers in the project and name them `MainController`,
    `ViewController1`, and `ViewController2`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加三个新的 iPhone 视图控制器，并分别命名为 `MainController`、`ViewController1` 和 `ViewController2`。
- en: 'Open the `AppDelegate.cs` file and add the following code in the `FinishedLaunching`
    method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AppDelegate.cs` 文件，并在 `FinishedLaunching` 方法中添加以下代码：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open `MainController.xib` in Interface Builder and add two buttons with their
    corresponding outlets. Set their titles to `First View` and `Second View`, respectively.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `MainController.xib` 并添加两个按钮及其相应的出口。分别设置它们的标题为 `First
    View` 和 `Second View`。
- en: 'Add the following code in the `ViewDidLoad` method of the `MainController`
    class:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类的 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a button in each of the `ViewController1` and `ViewController2` controllers
    in Interface Builder with the title `Pop to root`. Then, add the following code
    in both of these controllers'' `ViewDidLoad` methods:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中为 `ViewController1` 和 `ViewController2` 控制器各添加一个标题为 `Pop
    to root` 的按钮。然后，在这两个控制器的 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the app on the simulator.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行应用程序。
- en: Click on the buttons and see how the user interface navigates from one controller
    to another.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮并查看用户界面是如何从一个控制器导航到另一个控制器的。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UINavigationController` class preserves a stack of controllers. The `UIViewController`
    class has a property named `NavigationController`. In normal situations, this
    property returns null. However, if the controller is pushed into a navigation
    controller''s stack, it returns the instance of the navigation controller. In
    this case, all of our controllers'' `NavigationController` property will return
    the instance of our navigation controller. So this way, at any point in the hierarchy
    of controllers, access to the navigation controller is provided. To push a view
    controller to the navigation stack, we call the `UINavigationController.PushViewController(UIViewController,
    bool)` method, using the following line of code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINavigationController` 类保留了一个控制器栈。`UIViewController` 类有一个名为 `NavigationController`
    的属性。在正常情况下，这个属性返回 null。然而，如果控制器被推入导航控制器栈中，它将返回导航控制器的实例。在这种情况下，我们所有控制器的 `NavigationController`
    属性都将返回我们的导航控制器实例。因此，这样，在任何控制器层次结构中的任何一点，都可以访问导航控制器。要向导航栈中推入一个视图控制器，我们调用 `UINavigationController.PushViewController(UIViewController,
    bool)` 方法，使用以下代码行：'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that the `MainController` class is the topmost or root controller in
    the navigation stack. A navigation controller must have at least one view controller
    that will act as its root controller. We can provide it upon initialization of
    the navigation controller, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`MainController` 类是导航栈中最顶层或根控制器。导航控制器必须至少有一个视图控制器作为其根控制器。我们可以在初始化导航控制器时提供它，如下所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To return to the root controller, we call the `PopToRootViewController(bool)`
    method inside the current controller, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回根控制器，我们可以在当前控制器中调用 `PopToRootViewController(bool)` 方法，如下所示：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The boolean parameters in both methods are used for animating the transition
    between the view controllers. Setting it to `false` will result in the controllers
    instantly snapping onto the screen, which in most cases does not provide a very
    good user experience.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 两个方法中的布尔参数都用于在视图控制器之间动画过渡。将其设置为 `false` 将导致控制器瞬间固定在屏幕上，这在大多数情况下并不提供很好的用户体验。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this simple example, we provided backward navigation to the root controller
    with buttons. Notice that there is an arrow-shaped button at the top bar, as shown
    in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们通过按钮提供了返回根控制器的向后导航。注意，顶部栏中有一个箭头形状的按钮，如下面的截图所示：
- en: '![There''s more...](img/8924OT_03_01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/8924OT_03_01.jpg)'
- en: This top bar is called the navigation bar and is of the `UINavigationBar` type.
    The arrow-shaped button is called the back button and is of the `UIBarButtonItem`
    type. The back button, when it exists, always navigates to the previous controller
    in the navigation stack. If the previous controller in the stack has its `Title`
    property set, the back button will display that title. If it does not have a title,
    the back button will be titled `Back`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶部栏被称为导航栏，它是 `UINavigationBar` 类型。箭头形状的按钮被称为后退按钮，它是 `UIBarButtonItem` 类型。后退按钮，当它存在时，总是导航到导航栈中的上一个控制器。如果栈中的上一个控制器设置了
    `Title` 属性，后退按钮将显示该标题。如果没有标题，后退按钮将显示为 `Back`。
- en: Managing navigation bar buttons
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理导航栏按钮
- en: 'To change, add, and hide the buttons of the navigation bar, we can use the
    following methods of our currently displayed view controller''s `NavigationItem`
    property:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改、添加和隐藏导航栏按钮，我们可以使用我们当前显示的视图控制器的 `NavigationItem` 属性的以下方法：
- en: '`SetLeftBarButtonItem`: This method adds a custom button on the left-hand side
    of the navigation bar, replacing the default back button.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetLeftBarButtonItem`: 此方法在导航栏的左侧添加一个自定义按钮，替换默认的返回按钮。'
- en: '`SetRightBarButtonItem`: This method adds a custom button on the right-hand
    side of the navigation bar.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetRightBarButtonItem`: 此方法在导航栏的右侧添加一个自定义按钮。'
- en: '`SetHidesBackButton`: This method sets the visibility of the default back button.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetHidesBackButton`: 此方法设置默认返回按钮的可见性。'
- en: To remove or hide the custom buttons on the left or right-hand side of the navigation
    bar, call the appropriate methods passing null instead of a `UIBarButtonItem`
    object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除或隐藏导航栏左侧或右侧的自定义按钮，请调用适当的方法并传递 null 而不是 `UIBarButtonItem` 对象。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Modal view controllers* and *Using view controllers efficiently* recipes
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模式视图控制器* 和 *高效使用视图控制器* 的食谱'
- en: The *Animating views* recipe in [Chapter 11](ch11.html "Chapter 11. Graphics
    and Animation"), *Graphics and Animation*
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 11 章](ch11.html "第 11 章。图形和动画") 的 *动画视图* 食谱中，*图形和动画*
- en: Providing controllers in tabs
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在标签中提供控制器
- en: In this recipe, we will learn how to display multiple view controllers in a
    tabbed interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在标签界面中显示多个视图控制器。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UITabBarController` class provides a way to display different view controllers
    on the same hierarchy level divided into a tab-like interface. Create a new iPhone
    **Empty Project** in Xamarin Studio and name it `TabControllerApp`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITabBarController` 类提供了一种在相同层次结构级别上显示不同视图控制器的方法，这些控制器被划分为类似标签的界面。在 Xamarin
    Studio 中创建一个新的 iPhone **空项目** 并将其命名为 `TabControllerApp`。'
- en: How to do it…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Perform the following steps to provide controllers in tabs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在标签中提供控制器：
- en: Add two iPhone view controllers to the project. Name them `MainController` and
    `SettingsController`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个 iPhone 视图控制器添加到项目中。将它们命名为 `MainController` 和 `SettingsController`。
- en: 'Add the following code to the `ViewDidLoad` method of `MainController`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `MainController` 的 `ViewDidLoad` 方法中：
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code to the `ViewDidLoad` method of `SettingsController`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `SettingsController` 的 `ViewDidLoad` 方法中：
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following code to the `FinishedLaunching` method of the `AppDelegate`
    class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `AppDelegate` 类的 `FinishedLaunching` 方法中：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the app on the simulator. Click on each of the tabs at the bottom. The interface
    should be similar to the following screenshot when `MainController` is selected:![How
    to do it…](img/8924OT_03_02.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行应用程序。单击底部的每个标签。当选择 `MainController` 时，界面应类似于以下截图：![如何做到这一点…](img/8924OT_03_02.jpg)
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UITabBarController` class displays one tab for each of the controllers
    it manages. That tab is of the `UITabBarItem` type that can accept both text and
    images. We set the controllers it will display through its `SetViewControllers`
    property, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITabBarController` 类为它管理的每个控制器显示一个标签。该标签是 `UITabBarItem` 类型，可以接受文本和图像。我们通过其
    `SetViewControllers` 属性设置它将显示的控制器，如下所示：'
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we have added the controllers, we can access its tab bar items through
    the `TabBar` property. In this case, we set the tab''s `Title` attribute:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加了控制器之后，我们可以通过 `TabBar` 属性访问其标签栏项。在这种情况下，我们设置了标签的 `Title` 属性：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each `UIViewController` contains a `TabController` property. Similar to the
    `NavigationController` property, when the controller is part of a tab controller,
    the property will return the instance of that tab controller.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `UIViewController` 都包含一个 `TabController` 属性。类似于 `NavigationController` 属性，当控制器是标签控制器的一部分时，该属性将返回该标签控制器的实例。
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The controller can accept as many controllers as we want but if we add six or
    more, four will be displayed with their tabs, while a fifth predefined **More**
    tab will represent all the remaining controllers. This is to keep the interface
    easily accessible to the user by keeping the tabs to a specific size suitable
    for human fingers. When we add more than six controllers in a tab bar controller
    interface, by default, the object provides an **Edit** button on top in the **More**
    tab that allows the user to rearrange the order of controllers. If we want to
    exclude some controllers from this functionality, we have to remove it from the
    `CustomizableViewControllers` array.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器可以接受我们想要的任意数量的控制器，但如果添加六个或更多，则四个将带有标签显示，而第五个预定义的**More**标签将代表所有剩余的控制器。这是为了通过保持标签到特定大小，适合人类手指的大小，来保持界面易于用户访问。当我们向标签栏控制器界面添加超过六个控制器时，默认情况下，对象在**More**标签的顶部提供一个**Edit**按钮，允许用户重新排列控制器的顺序。如果我们想排除某些控制器从这个功能中，我们必须从`CustomizableViewControllers`数组中移除它。
- en: Useful UITabBarController properties
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用的`UITabBarController`属性
- en: 'Some more useful properties of the `UITabBarController` class are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITabBarController`类的其他一些有用属性如下：'
- en: '`ViewControllers`: This is an array containing all the controllers that the
    tab controller holds.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewControllers`：这是一个包含标签控制器所持有所有控制器的数组。'
- en: '`SelectedIndex`: This is the zero-based index of the selected tab. Setting
    this property to the desired index programmatically selects the corresponding
    controller.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedIndex`：这是选中标签的零基索引。通过程序设置此属性以选择相应的控制器。'
- en: '`SelectedViewController`: This is the currently selected controller.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedViewController`：这是当前选中的控制器。'
- en: Determining tab selection
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定标签选择
- en: 'To determine when the user has selected a tab on a tab controller, we can subscribe
    to its `ViewControllerSelected` event:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定用户是否在标签控制器上选择了一个标签，我们可以订阅其`ViewControllerSelected`事件：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using view controllers efficiently* recipe
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效使用视图控制器*的配方'
- en: Modal view controllers
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态视图控制器
- en: In this recipe, we will discuss how to display view controllers modally.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将讨论如何以模态方式显示视图控制器。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A modal view controller is any controller that is presented above other views
    or controllers. The concept is similar to displaying a Windows Form as a dialog,
    which takes control of the interface and does not allow access to other windows
    of the application unless it is dismissed. Create a new iPhone **Empty Project**
    in Xamarin Studio and name it `ModalControllerApp`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模态视图控制器是指呈现在其他视图或控制器之上的任何控制器。这个概念类似于显示Windows表单作为对话框，它控制界面并不允许访问应用程序的其他窗口，除非它被关闭。在Xamarin
    Studio中创建一个新的iPhone **Empty Project**，并将其命名为`ModalControllerApp`。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add two view controllers to the project and name them `MainController` and `ModalController`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个视图控制器添加到项目中，并分别命名为`MainController`和`ModalController`。
- en: Open the `MainController.xib` file in Interface Builder and add a button on
    its view with the title `Present`. Create and connect the appropriate outlet for
    the button.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`MainController.xib`文件，并在其视图中添加一个标题为`Present`的按钮。创建并连接按钮的适当出口。
- en: 'In the `MainController` class, add the following code in the `ViewDidLoad`
    method:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`类中，在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE16]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Open the `ModalController.xib` file. Add a button on its view with the title
    `Dismiss` and create the appropriate outlet for it.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ModalController.xib`文件。在其视图中添加一个标题为`Dismiss`的按钮，并为它创建适当的出口。
- en: 'Set its view background color to something other than white. Save the document
    and enter the following code in the `ViewDidLoad` method of `ModalController`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其视图背景颜色设置为除白色以外的颜色。保存文档，并在`ModalController`的`ViewDidLoad`方法中输入以下代码：
- en: '[PRE17]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, add code to display the main controller in the `FinishedLaunching`
    method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`FinishedLaunching`方法中添加代码以显示主控制器：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile and run the app on the simulator. Click on the **Present** button and
    watch the modal controller present itself on top of the main controller. Click
    on the **Dismiss** button to hide it.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击**Present**按钮，观察模态控制器如何在主控制器之上呈现。点击**Dismiss**按钮以隐藏它。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each controller object has two methods that handle presenting and dismissing
    controllers modally. In our example, we call the `PresentViewControllerAsync(UIViewController,
    bool)` method to present a controller, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器对象都有两个处理以模态方式呈现和消失控制器的方法。在我们的示例中，我们调用 `PresentViewControllerAsync(UIViewController,
    bool)` 方法来呈现控制器，如下所示：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Its first parameter represents the controller we want to display modally, and
    the second parameter determines if we want the presentation to be animated. To
    dismiss the controller, we call its `DismissViewControllerAsync(bool)` method,
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 其第一个参数表示我们想要以模态方式显示的控制器，第二个参数确定我们是否希望呈现具有动画效果。要消失控制器，我们调用其 `DismissViewControllerAsync(bool)`
    方法，如下所示：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It accepts only one parameter that toggles the animation for the dismissal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它只接受一个参数，用于切换消失动画。
- en: In this example, we use `async`/`await` and the methods with the `Async` suffix
    to present and dismiss a controller modally. These methods are included in Xamarin.iOS
    for convenience. We can also use `PresentViewController` and `DismissViewController`;
    both accept another parameter of the `NSAction` type that represents the callback
    of the completion. However, no need to get into all that "trouble", right?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `async`/`await` 和具有 `Async` 后缀的方法来以模态方式呈现和消失控制器。这些方法包含在 Xamarin.iOS
    中以方便使用。我们还可以使用 `PresentViewController` 和 `DismissViewController`；两者都接受另一个参数，该参数为
    `NSAction` 类型，表示完成回调。然而，我们真的需要陷入所有这些 "麻烦" 吗？
- en: There's more...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We can define the transition style for a modal view controller presentation
    with the controller''s `ModalTransitionStyle` property. Enter the following line
    of code before presenting the modal controller:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用控制器的 `ModalTransitionStyle` 属性定义模态视图控制器呈现的过渡样式。在呈现模态控制器之前，输入以下代码行：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main controller will flip to present the modal controller, giving the impression
    it is attached behind it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 主要控制器将翻转以呈现模态控制器，给人一种它附在其后面的印象。
- en: Accessing a modal controller
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问模态控制器
- en: Each controller that presents another controller modally provides access to
    its "child" controller through the `ModalController` property. If you need to
    access the modal controller through this property, make sure to do it before the
    `DismissViewControllerAsync` method is called.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以模态方式呈现另一个控制器的控制器都通过 `ModalController` 属性提供对其 "子" 控制器的访问。如果您需要通过此属性访问模态控制器，请确保在调用
    `DismissViewControllerAsync` 方法之前进行操作。
- en: How many modal controllers?
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有多少个模态控制器？
- en: 'In theory, we can present an unlimited number of modal controllers. Of course,
    there are two restrictions on this, which are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以呈现无限数量的模态控制器。当然，对此有两个限制，如下所述：
- en: '**Memory is not unlimited**: View controllers consume memory, so the more view
    controllers we present, the worst performance we get.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存不是无限的**：视图控制器会消耗内存，因此我们呈现的视图控制器越多，性能越差。'
- en: '**Bad user experience**: Presenting many controllers modally might confuse
    the user.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**糟糕的用户体验**：连续以模态方式呈现多个控制器可能会让用户感到困惑。'
- en: In general, it is advised to not present more than one consecutive controller
    modally.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议不要连续以模态方式呈现超过一个控制器。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Navigating through different view controllers* and *Providing controllers
    in tabs* recipes
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同视图控制器之间导航* 和 *在标签中提供控制器* 的食谱'
- en: Creating a custom view controller
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义视图控制器
- en: In this recipe, we will learn how to create a subclass of `UIViewController`
    and use it to derive view controllers that were created in Interface Builder.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何创建 `UIViewController` 的子类，并使用它来派生在 Interface Builder 中创建的视图控制器。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this recipe, we will create a custom view controller that will act as a base
    controller, providing common functionality among its inheritors. Create a new
    iPhone **Empty Project** in Xamarin Studio and name it `CustomControllerApp`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个自定义视图控制器，它将充当基控制器，为其继承者提供共同的功能。在 Xamarin Studio 中创建一个新的 iPhone
    **空项目**，并将其命名为 `CustomControllerApp`。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Right-click on the project in the **Solution** pad and go to **Add** | **New
    File…**.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **解决方案** 面板中的项目，然后转到 **添加** | **新建文件…**。
- en: In the dialog that appears, navigate to **General** | **Empty Class**. Name
    the file `BaseController` and click on the **New** button.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的对话框中，导航到 **常规** | **空类**。将文件命名为 `BaseController` 并点击 **新建** 按钮。
- en: 'Open the `BaseController.cs` file that was just created and modify it to match
    the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开刚刚创建的 `BaseController.cs` 文件，并将其修改为以下代码：
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, add an iPhone view controller to the project and name it `DerivedController`.
    Change the class it inherits from `UIViewController` to `BaseController` in its
    class definition: `public partial class DerivedController : BaseController`.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，向项目中添加一个 iPhone 视图控制器，并将其命名为 `DerivedController`。在其类定义中将继承自 `UIViewController`
    的类更改为 `BaseController`：`public partial class DerivedController : BaseController`。'
- en: 'Set the derived controller to be the root view controller of the main window
    (in `AppDelegate.cs`):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将派生控制器设置为主窗口的根视图控制器（在 `AppDelegate.cs` 中）：
- en: '[PRE23]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compile and run the app on the simulator. Click-and-drag the mouse pointer on
    the white surface and watch Xamarin Studio's application output pad displaying
    the current position of the pointer on the simulator's screen.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。点击并拖动鼠标指针在白色表面上，观察 Xamarin Studio 的应用输出垫显示模拟器屏幕上指针的当前位置。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'What we have done here is that we have created a base controller class that
    can be used in multiple Xamarin.iOS projects. The functionality we have added
    to this controller is to respond to user touches. Any controller that inherits
    it will inherit the same functionality. The code we have added to create the `BaseController`
    class is fairly simple. To make this work, we have added the following constructor
    to the class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是创建了一个可以用于多个 Xamarin.iOS 项目的基控制器类。我们添加到这个控制器中的功能是响应用户触摸。任何继承它的控制器都将继承相同的功能。我们添加到创建
    `BaseController` 类中的代码相当简单。为了使它工作，我们在类中添加了以下构造函数：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the base constructor that will get called when we initialize the `DerivedController`
    class with the new keyword, `this.derivedController = new DerivedController();`,
    through our derived object's `DerivedController()` constructor. So, what this
    practically means is that we can normally use inheritance with controllers that
    are loaded from XIB files.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当使用新关键字通过派生对象的 `DerivedController()` 构造函数初始化 `DerivedController` 类时将被调用的基构造函数，`this.derivedController
    = new DerivedController();`。所以，这实际上意味着我们可以通常使用继承与从 XIB 文件加载的控制器。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can also create base controllers from XIB files. However, if the XIB files
    contain outlets, we need to make sure to populate these outlets in our derived
    classes; otherwise, they will not be available in our derived controllers. For
    example, if we have an outlet for a button named `btnStart` in the base XIB file,
    we would have to create the following property in our derived class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从 XIB 文件中创建基控制器。然而，如果 XIB 文件包含出口，我们需要确保在我们的派生类中填充这些出口；否则，它们将不会在我们的派生控制器中可用。例如，如果我们有一个名为
    `btnStart` 的按钮出口在基 XIB 文件中，我们将在我们的派生类中创建以下属性：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Outlet` attribute tells the runtime that the specific property is an outlet.
    Not only that, it also helps Xamarin Studio in creating the Xcode project when
    we are using the derived class in a XIB.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Outlet` 属性告诉运行时特定属性是一个出口。不仅如此，它还有助于在我们在 XIB 中使用派生类时创建 Xcode 项目。'
- en: See also
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Loading a view with a view controller*, *Using view controllers efficiently*,
    and *UI flow design with storyboards recipes*
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用视图控制器加载视图*、*高效使用视图控制器* 和 *使用故事板进行 UI 流程设计* 菜单'
- en: The *Adding and customizing views* recipe in [Chapter 2](ch02.html "Chapter 2. User
    Interface – Views"), *User Interface – Views*
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。用户界面 – 视图") 的 *添加和自定义视图* 菜单，*用户界面 – 视图*
- en: Using view controllers efficiently
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用视图控制器
- en: iOS is very strict about memory usage. If an app uses too much memory, iOS will
    issue memory warnings. If we do not respond to these memory warnings accordingly
    by releasing resources that are not needed, it is very likely that iOS will terminate
    the app.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 对内存使用非常严格。如果一个应用使用了过多的内存，iOS 将会发出内存警告。如果我们不相应地通过释放不需要的资源来应对这些内存警告，iOS 很可能会终止该应用。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's see what we can do to avoid this situation. Create a new project in Xamarin
    Studio and name it `EfficientControllerApp`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以做些什么来避免这种情况。在 Xamarin Studio 中创建一个新的项目，并将其命名为 `EfficientControllerApp`。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此菜谱：
- en: Add a view controller to the project and name it `MainController`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个视图控制器，并将其命名为 `MainController`。
- en: 'Enter the following code in the `DidReceiveMemoryWarning` method of the `MainController`
    class:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类的 `DidReceiveMemoryWarning` 方法中输入以下代码：
- en: '[PRE26]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make the controller the root view controller of the app in `AppDelegate.cs`
    as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate.cs` 中将控制器设置为应用的根视图控制器，如下所示：
- en: '[PRE27]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compile and run the app on the simulator.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。
- en: With iOS Simulator window active, navigate to **Hardware** | **Simulate Memory
    Warning** on the menu bar, as shown in the following screenshot:![How to do it…](img/8924OT_03_03.jpg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 iOS 模拟器窗口处于活动状态时，在菜单栏上导航到 **硬件** | **模拟内存警告**，如图所示：![如何操作…](img/8924OT_03_03.jpg)
- en: 'Check the **Application Output** pad in Xamarin Studio. You should see an output
    similar to the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 Xamarin Studio 中的 **应用程序输出** 选项卡。你应该会看到以下类似的输出：
- en: '[PRE28]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This project does not provide any useful functionality. Its main purpose is
    to show how to get notified on memory warnings issued by iOS.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目不提供任何有用的功能。其主要目的是展示如何通知 iOS 发出的内存警告。
- en: When a memory warning is issued, the `DidReceiveMemoryWarning` method will be
    called on all instantiated view controllers that are currently in memory. When
    this method is called, we should make sure we release the resources that are not
    currently required. This way, we are making more memory available to the system.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出内存警告时，`DidReceiveMemoryWarning` 方法将在当前内存中所有实例化的视图控制器上被调用。当此方法被调用时，我们应该确保释放当前不需要的资源。这样，我们就可以为系统提供更多的内存。
- en: iOS Simulator provides the option of simulating memory warnings so that we can
    test how our app will behave when memory is low. On a real device, we cannot force
    the system to issue memory warnings on demand. Note that although we can practically
    simulate an unlimited number of memory warnings on the simulator, the app will
    never be terminated. On the other hand, on the device, the app will be terminated
    after two or three memory warnings (the actual number varies according to memory
    usage), so we need to take this into account.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 模拟器提供了模拟内存警告的选项，这样我们就可以测试当内存不足时我们的应用会如何表现。在真实设备上，我们无法强制系统按需发出内存警告。请注意，尽管我们实际上可以在模拟器上模拟无限数量的内存警告，但应用永远不会被终止。另一方面，在设备上，应用将在两个或三个内存警告之后（实际数量根据内存使用情况而变化）被终止，因此我们需要考虑这一点。
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'View controllers are not the only object that can receive memory warnings.
    We can capture memory warning notifications by overriding the `UIApplicationDelegate.ReceiveMemoryWarning(UIApplication)`
    method inside the `AppDelegate` class, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器并不是唯一可以接收内存警告的对象。我们可以在 `AppDelegate` 类内部通过重写 `UIApplicationDelegate.ReceiveMemoryWarning(UIApplication)`
    方法来捕获内存警告通知，如下所示：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating a custom view controller* recipe
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义视图控制器* 菜谱'
- en: The *Interface Builder* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。开发工具")中的 *Interface Builder* 菜谱，*开发工具*'
- en: iPad view controllers
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iPad 视图控制器
- en: All the controllers we have worked with so far can be used in both iPhone and
    iPad applications. There are, however, two controllers that are only available
    to the iPad. These are the `UISplitViewController` and `UIPopoverController` classes.
    In this recipe, we will create an iPad project that uses the `UISplitViewController`
    class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所使用的所有控制器都可以用于 iPhone 和 iPad 应用。然而，有两个控制器仅适用于 iPad。这些是 `UISplitViewController`
    和 `UIPopoverController` 类。在此菜谱中，我们将创建一个使用 `UISplitViewController` 类的 iPad 项目。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPad **Empty Project** and name it `SplitControllerApp`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 iPad **空项目**，并将其命名为 `SplitControllerApp`。
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此菜谱：
- en: Add two iPad view controllers to the project and name them `FirstController`
    and `SecondController`. Set the background colors of their views to different
    colors, for example, blue for `FirstController` and yellow for `SecondController`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加两个 iPad 视图控制器，并分别命名为 `FirstController` 和 `SecondController`。将它们视图的背景颜色设置为不同的颜色，例如，将
    `FirstController` 的背景颜色设置为蓝色，将 `SecondController` 的背景颜色设置为黄色。
- en: Open `SecondController.xib` in Interface Builder and add `UIToolbar` close to
    the top of its view. Connect the toolbar to an outlet named `myToolbar`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `SecondController.xib` 文件，并将 `UIToolbar` 添加到视图的顶部附近。将工具栏连接到名为
    `myToolbar` 的出口。
- en: 'By default, the properties that represent the outlets are created as private
    by Xamarin Studio. Add the following property in the `SecondController` class
    to expose the toolbar outlet:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Xamarin Studio 创建的表示出口的属性是私有的。在 `SecondController` 类中添加以下属性以公开工具栏出口：
- en: '[PRE30]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following class to the project:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下类添加到项目中：
- en: '[PRE31]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code in the `FinishedLaunching` method of the `AppDelegate`
    class:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类的 `FinishedLaunching` 方法中添加以下代码：
- en: '[PRE32]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compile and run the app on the simulator.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Click on the **First** button on the toolbar. `FirstController` should slide
    in from the side. The result is similar to the following screenshot:![How to do
    it…](img/8924OT_03_04.jpg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏上的 **第一个** 按钮。`FirstController` 应该从侧面滑入。结果类似于以下截图：![如何操作…](img/8924OT_03_04.jpg)
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UISplitViewController` class helps to take full advantage of the iPad's
    larger screen. It provides a way of displaying two different views simultaneously
    on the same screen area. It does this by displaying one controller in fullscreen
    in the portrait orientation and a secondary controller whenever is needed, in
    a smaller size.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`UISplitViewController` 类有助于充分利用 iPad 更大的屏幕。它提供了一种在同一屏幕区域内同时显示两个不同视图的方法。它是通过在纵向模式下全屏显示一个控制器，并在需要时以较小的尺寸显示一个次要控制器来实现的。'
- en: 'To provide access to both controllers in our project to the user, we have implemented
    a class that inherits from `UISplitViewControllerDelegate` and assigned it to
    our split controller inside the `FinishedLaunching` method. The `Delegate` object
    we created overrides two methods. In the first method, we assign a button to the
    toolbar, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够访问我们项目中的两个控制器，我们实现了一个继承自 `UISplitViewControllerDelegate` 的类，并在 `FinishedLaunching`
    方法中将它分配给我们的分割控制器。我们创建的 `Delegate` 对象覆盖了两个方法。在第一个方法中，我们按照以下方式将一个按钮分配给工具栏：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `WillHideViewController` method is executed whenever `UISplitViewController`
    changes orientation from landscape to portrait and its smaller controller is about
    to be hidden. So to display it, we provide a button on the fullscreen controller''s
    toolbar. When we click on that button, the other controller will slide in from
    the side. When the orientation changes from portrait to landscape, the smaller
    controller appears beside the larger controller automatically. So, we no longer
    need the button on the toolbar; hence, we override the `WillShowViewController`
    method to remove it. We do this by assigning an empty `UIBarButtonItem[]` array,
    as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `UISplitViewController` 从横向模式变为纵向模式，并且其较小的控制器即将被隐藏时，`WillHideViewController`
    方法会被执行。因此，为了显示它，我们在全屏控制器的工具栏上提供了一个按钮。当我们点击该按钮时，另一个控制器将从侧面滑入。当方向从纵向变为横向时，较小的控制器会自动出现在较大的控制器旁边。因此，我们不再需要在工具栏上放置按钮；因此，我们覆盖了
    `WillShowViewController` 方法来移除它。我们通过分配一个空的 `UIBarButtonItem[]` 数组来完成此操作，如下所示：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's more...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'To rotate the simulator to (and from) the landscape orientation, press *Cmd*
    and the left arrow key (or the right arrow key) with the app running on iOS Simulator.
    The following screenshot shows iOS Simulator rotated in landscape orientation.
    No other action was taken to make both controllers appear at the same time, as
    the split controller handles this for us:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模拟器旋转到（并从）横向模式，按住 *Cmd* 键和左箭头键（或右箭头键），同时让 iOS 模拟器上的应用运行。以下截图显示了已旋转到横向模式的 iOS
    模拟器。没有采取其他任何操作来同时显示两个控制器，因为分割控制器为我们处理了这一点：
- en: '![There''s more...](img/8924OT_03_05.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![更多...](img/8924OT_03_05.jpg)'
- en: iPad-specific controller usage
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iPad 特定的控制器使用
- en: Although all other controllers are available to both the iPhone and iPad, an
    exception will occur if a `UISplitViewController` method is used in an app that
    runs on an iPhone.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有其他控制器都对 iPhone 和 iPad 可用，但如果在运行在 iPhone 上的应用程序中使用 `UISplitViewController`
    方法，将会发生异常。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adjusting UI orientation* recipe in [Chapter 9](ch09.html "Chapter 9. Interacting
    with Device Hardware"), *Interacting with Device Hardware*
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 9 章](ch09.html "第 9 章。与设备硬件交互") 的 *调整 UI 方向* 菜谱中，*与设备硬件交互*
- en: UI flow design with storyboards
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 storyboards 进行 UI 流程设计
- en: Back when iOS 5 was released, Apple introduced **storyboards**. A storyboard
    is a new type of user interface file that accepts multiple view controllers, but
    it also holds information about how all these controllers relate to each other
    in the hierarchy of an application. Storyboards are very helpful when designing
    the screens of an application, as they are more efficient than loading different
    controllers from individual XIB files; they also keep a group of view controllers
    together in a single file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当 iOS 5 发布时，苹果引入了 **storyboards**。Storyboard 是一种新的用户界面文件类型，它接受多个视图控制器，但它还包含有关所有这些控制器如何在应用程序的层次结构中相互关联的信息。Storyboard
    在设计应用程序屏幕时非常有帮助，因为它们比从单个 XIB 文件加载不同的控制器更有效率；它们还把一组视图控制器保存在一个文件中。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPhone **Empty Project** in Xamarin Studio and name it `StoryboardApp`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 iPhone **空项目**，并将其命名为 `StoryboardApp`。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Xamarin Studio includes a number of project templates for storyboard applications.
    We will, however, use an empty iPhone project because it will help us to better
    comprehend how storyboards work.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio 包含许多用于故事板应用程序的项目模板。然而，我们将使用一个空 iPhone 项目，因为它将帮助我们更好地理解故事板的工作原理。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps to complete this recipe:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此菜谱的步骤如下：
- en: Add two new C# classes (not view controllers) to the project and name them `FirstController`
    and `SecondController`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加两个新的 C# 类（不是视图控制器），并将它们命名为 `FirstController` 和 `SecondController`。
- en: 'Derive both classes from `UIViewController` and decorate them with the `Register`
    attribute. Make sure that you pass a different name for each controller in the
    attribute, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `UIViewController` 派生这两个类，并用 `Register` 属性进行装饰。确保在属性中为每个控制器传递不同的名称，如下所示：
- en: 'The `FirstController` class:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstController` 类：'
- en: '[PRE35]'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `SecondController` class:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecondController` 类：'
- en: '[PRE36]'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the `IntPtr` constructor of `UIViewController` in both classes:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个类中添加 `UIViewController` 的 `IntPtr` 构造函数：
- en: '[PRE37]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add an `Empty iPhone Storyboard` file to the project and name it `MainStoryboard`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个 `Empty iPhone Storyboard` 文件，并将其命名为 `MainStoryboard`。
- en: Open the `MainStoryboard.storyboard` file that was created in Interface Builder.
    Just like opening XIBs, double-click on the file in Xamarin Studio.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开在 Interface Builder 中创建的 `MainStoryboard.storyboard` 文件。就像打开 XIBs 一样，在 Xamarin
    Studio 中双击该文件。
- en: Drag `UINavigationController` on the empty canvas. By default, Xcode adds a
    table view when adding navigation controllers. Select it and delete it by pressing
    the *Backspace* key; we only need the navigation controller.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空画布上拖动 `UINavigationController`。默认情况下，Xcode 在添加导航控制器时会添加一个表格视图。选择它并通过按 *Backspace*
    键删除它；我们只需要导航控制器。
- en: Add two `UIViewController` objects to the canvas. By selecting each view controller
    individually, set their **Class** field in the **Identity Inspector** window to
    the classes we created in the preceding steps. The following screenshot shows
    the **Class** field of the first controller set to **FirstController**:![How to
    do it...](img/8924OT_03_06.jpg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加两个 `UIViewController` 对象。通过单独选择每个视图控制器，在 **Identity Inspector** 窗口中设置它们的
    **Class** 字段为我们之前步骤中创建的类。以下截图显示了第一个控制器的 **Class** 字段设置为 **FirstController**：![如何操作...](img/8924OT_03_06.jpg)
- en: We now need to connect the controllers. Just like adding an outlet, press *Ctrl*
    and drag from the navigation controller to `FirstController`. In the context menu
    that will appear when you release the button, select **root view**.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要连接这两个控制器。就像添加一个出口一样，按 *Ctrl* 并从导航控制器拖动到 `FirstController`。在你释放按钮时出现的上下文菜单中，选择
    **根视图**。
- en: Add `UIButton` on `FirstController`. Press *Ctrl* and drag from the button to
    `SecondController`. Select **push** in the context menu that will appear. No need
    to connect the button to an outlet.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FirstController` 上添加 `UIButton`。按 *Ctrl* 并从按钮拖动到 `SecondController`。在出现的上下文菜单中选择
    **推送**。不需要将按钮连接到出口。
- en: 'Back in Xamarin Studio, add the following code in the `FinishedLaunching` method:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中，回到 `FinishedLaunching` 方法中添加以下代码：
- en: '[PRE38]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compile and run the app on the simulator. Clicking on the button will push the
    second controller into display.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击按钮会将第二个控制器推入显示。
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you see, we managed to create the user interface for the application with
    minimal code. Inside storyboard files, we need to connect each element with each
    other, according to how we want the screen hierarchy to appear. We first set `FirstController`
    as a root view controller to the navigation controller. Then, we assigned a relationship
    to the button with the `SecondController` class. So, when the button is clicked,
    the `SecondController` class will be pushed into the navigation controller's stack,
    just as if we were calling the `UINavigationController.PushViewController` method.
    This relationship is called **segue**. In a storyboard file, we can individually
    select segues and set their properties. For example, we can set an identifier
    string or change its behavior from **push** to **modal**.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们成功地用最少的代码创建了应用程序的用户界面。在storyboard文件中，我们需要根据我们想要的屏幕层次结构来连接每个元素。我们首先将`FirstController`设置为导航控制器的根视图控制器。然后，我们将`SecondController`类分配给按钮的关系。因此，当按钮被点击时，`SecondController`类将被推入导航控制器的堆栈中，就像我们调用`UINavigationController.PushViewController`方法一样。这种关系称为**segue**。在storyboard文件中，我们可以单独选择segues并设置它们的属性。例如，我们可以设置一个标识符字符串或将行为从**push**更改为**modal**。
- en: 'In the `FinishedLaunching` method, we first instantiate a `UIStoryboard` instance
    through the static `UIStoryboard.FromName` method, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FinishedLaunching`方法中，我们首先通过静态`UIStoryboard.FromName`方法实例化一个`UIStoryboard`实例，如下所示：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then call the `InstantiateInitialViewController` method to get the initial
    controller of the storyboard, as follows. In this case, the initial controller
    is `UINavigationController`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用`InstantiateInitialViewController`方法来获取storyboard的初始控制器，如下所示。在这种情况下，初始控制器是`UINavigationController`：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we need to cast the return value to the correct type of controller,
    as its return type is `NSObject`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要将返回值转换为正确的控制器类型，因为它的返回类型是`NSObject`。
- en: There's more...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We can also initiate segues programmatically. To do this, we first need to
    select the segue in Xcode and set an identifier for it through the **Attributes**
    inspector tab. Then, we can trigger it through code by calling the `PerformSegue`
    method of the `UIViewController` instance it belongs to, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过编程方式启动segues。为此，我们首先需要在Xcode中选择segue并为其在**属性**检查器标签中设置一个标识符。然后，我们可以通过调用属于它的`UIViewController`实例的`PerformSegue`方法来通过代码触发它，如下所示：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Passing data
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递数据
- en: 'With storyboards, the system is instantiating the view controllers we need.
    We can have access to the view controller that will be displayed through a segue
    by overriding the `PrepareForSegue` method on the controller that is the owner,
    or source of the segue, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用storyboards，系统正在实例化我们需要的视图控制器。我们可以通过覆盖拥有或源segue的控制器上的`PrepareForSegue`方法来访问将通过segue显示的视图控制器，如下所示：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, there is also a `UIStoryboardSegue` class which provides us
    with the necessary information.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，还有一个`UIStoryboardSegue`类为我们提供了必要的信息。
- en: The `PrepareForSegue` method is called after the involving view controllers
    have been instantiated and before the segue starts. So, by determining which segue
    triggered the preparation method through the `Identifier` property, we retrieve
    the controller that the segue will display through the `DestinationViewController`
    property.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrepareForSegue`方法在涉及视图控制器实例化之后和segue开始之前被调用。因此，通过通过`Identifier`属性确定哪个segue触发了准备方法，我们可以通过`DestinationViewController`属性检索segue将要显示的控制器。'
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `PrepareForSegue` method will be called regardless if the segue was triggered
    programmatically through the `PerformSegue` method or was just set to a button
    in the storyboard file.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 无论segue是通过`PerformSegue`方法编程触发还是仅设置在storyboard文件中的按钮，`PrepareForSegue`方法都会被调用。
- en: See also
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Interface Builder* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。开发工具")中的*Interface Builder*配方，*开发工具*'
- en: Unwinding in storyboards
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在storyboard中回退
- en: Another very useful feature of storyboards is **unwinding**. Unwinding is a
    process similar to that of a segue, but instead of presenting the next view controller,
    it reverses to a previous view controller in a storyboard. The great thing about
    it is that it allows us to go back to any view controller, not just the one that
    is right before the current controller we are in. This recipe will show how to
    use unwinding.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Storyboards的另一个非常实用的功能是**解包**。解包是一个类似于转场的过程，但它不是显示下一个视图控制器，而是将故事板中的视图控制器反转到之前的一个。它的好处是它允许我们回到任何视图控制器，而不仅仅是当前控制器之前的一个。本食谱将展示如何使用解包。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need the project `StoryboardApp` we created in the
    previous recipe. Open it in Xamarin Studio.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要在之前的食谱中创建的`StoryboardApp`项目。在Xamarin Studio中打开它。
- en: How to do it…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to implement unwinding:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现解包：
- en: Add a new class to the project and name it `ModalController`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新类，并将其命名为`ModalController`。
- en: 'Make the class a custom view controller, similar to `FirstController` and `SecondController`
    in the project, as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类设为自定义视图控制器，类似于项目中`FirstController`和`SecondController`，如下所示：
- en: '[PRE43]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following method in the `FirstController` class:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FirstController`类中添加以下方法：
- en: '[PRE44]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Open the `MainStoryboard.storyboard` file in Xcode and add another `UIViewController`.
    Set this controller's **Class** to **ModalController**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode中打开`MainStoryboard.storyboard`文件并添加另一个`UIViewController`。将此控制器的**Class**设置为**ModalController**。
- en: Add **UIButton** to `SecondController` and set its title to `Show modal`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SecondController`中添加**UIButton**并将其标题设置为`Show modal`。
- en: Press *Ctrl* and drag from the button to `ModalController`. Set this segue to
    **modal**.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*键并从按钮拖动到`ModalController`。将此转场设置为**模态**。
- en: Add another button, this time on `ModalController`. Set its title to `Unwind
    to first`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ModalController`上添加另一个按钮。将其标题设置为`Unwind to first`。
- en: Press *Ctrl* and drag from the button to the **Exit** item on the controller's
    dock, as shown in the following screenshot:![How to do it…](img/8924OT_03_07.jpg)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*键并从按钮拖动到控制器工具栏上的**退出**项，如图下所示：![如何做到这一点…](img/8924OT_03_07.jpg)
- en: Select **unwindFromModalController** in the context menu that will appear.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的上下文菜单中选择**unwindFromModalController**。
- en: Compile and run the app on the simulator. Flow through the screens until you
    reach the modal controller and click on the **Unwind to first** button. The user
    interface will flow back to the first controller.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。浏览屏幕，直到到达模态控制器并点击**解包到第一个**按钮。用户界面将返回到第一个控制器。
- en: How it works…
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'By using unwinding or **unwind segues**, we can get back to any controller
    in the hierarchy. The basic requirement is to add a method decorated with the
    `Action` attribute to the controller you want to unwind to, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**解包**或**unwind segues**，我们可以回到层次结构中的任何控制器。基本要求是在你想要解包到的控制器中添加一个带有`Action`属性的装饰方法，如下所示：
- en: '[PRE45]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The attribute will basically expose the method as an action to Xcode so that
    when the storyboard file is opened, we will be able to add the unwind segue. This
    is how the action **unwindFromModalController** appeared when we dragged to the
    **Exit** item. It doesn't matter if the action is inside another class Xcode is
    smart enough to search all classes in the storyboard.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性基本上会将方法暴露给Xcode作为动作，这样当打开storyboard文件时，我们就可以添加解包转场。这就是我们在拖动到**退出**项时出现**unwindFromModalController**动作的原因。动作是否在另一个类中无关紧要，Xcode足够智能，可以搜索storyboard中的所有类。
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Exit** item in the dock of every view controller is responsible for creating
    unwind segues. It represents the exit of a view controller, which is determined
    by how the controller was displayed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图控制器工具栏中的**退出**项负责创建解包转场。它代表视图控制器的退出，这取决于控制器是如何显示的。
- en: There's more…
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can have access to the controller that initiated the unwind segue through
    the `UIStoryboardSegue` object that is passed to the unwind action, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递给解包动作的`UIStoryboardSegue`对象来访问启动解包转场的控制器，如下所示：
- en: '[PRE46]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Where is the unwind segue in the storyboard?
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故事板中的解包转场在哪里？
- en: 'When we create unwind segues, there is no apparent change in Xcode''s appearance
    or an indication that we created something, like when we create segues. After
    creating the unwind, we can find it by expanding the document outline, as shown
    in the following screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建解包转场时，Xcode的外观没有明显变化，也没有创建某些内容的指示，就像我们创建转场时一样。创建解包后，我们可以通过展开文档大纲来找到它，如图下所示：
- en: '![Where is the unwind segue in the storyboard?](img/8924OT_03_08.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![故事板中撤销转场在哪里？](img/8924OT_03_08.jpg)'
- en: See also
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Navigating through different view controllers* and *Modal view controllers*
    recipes
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*导航不同视图控制器* 和 *模态视图控制器* 的食谱'
