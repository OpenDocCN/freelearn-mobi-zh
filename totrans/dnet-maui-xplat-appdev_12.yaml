- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Implementing Razor Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Razor 组件
- en: In the previous chapter, we explored Blazor routing and layout and, subsequently,
    built a navigation framework by establishing our app’s routing and layout. Upon
    setting up the navigation framework, we crafted top-level pages. The implementation
    of Razor pages allows for password database navigation, akin to the XAML version.
    While Razor pages are indeed Razor components, they are not reusable. In this
    chapter, we will introduce the creation of reusable Razor components. Furthermore,
    we will delve into data binding and the Razor component lifecycle to foster a
    comprehensive understanding of these aspects. Armed with this knowledge, we will
    optimize our code by converting duplicate code into reusable Razor components.
    Ultimately, we will use the Razor components to implement CRUD operations within
    our app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Blazor 路由和布局，并随后通过设置应用程序的路由和布局来构建导航框架。在设置导航框架之后，我们创建了顶级页面。Razor
    页面的实现允许进行密码数据库导航，类似于 XAML 版本。虽然 Razor 页面确实是 Razor 组件，但它们是不可重用的。在本章中，我们将介绍创建可重用
    Razor 组件。此外，我们将深入研究数据绑定和 Razor 组件的生命周期，以全面理解这些方面。掌握这些知识后，我们将通过将重复代码转换为可重用 Razor
    组件来优化我们的代码。最终，我们将使用 Razor 组件在我们的应用程序中实现 CRUD 操作。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding Razor components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Razor 组件
- en: Creating a Razor class library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Razor 类库
- en: Creating reusable Razor components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用 Razor 组件
- en: Understanding the Razor component lifecycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Razor 组件的生命周期
- en: Refactoring Razor components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构 Razor 组件
- en: Using templated components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板化组件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章的源代码，您需要在您的 PC 或 Mac 上安装 Visual Studio 2022。有关详细信息，请参阅 *第 1 章*，*开始使用
    .NET MAUI* 中的 *开发环境设置* 部分。
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter10](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/d5302ca26a3c362a291785a9771d87ad8552bdb2).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter10](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/d5302ca26a3c362a291785a9771d87ad8552bdb2)。
- en: 'To check out the source code of this chapter, you can use the below command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的源代码，可以使用以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code* section in this book, in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书中源代码的信息，请参阅本书 *第 2 章*，*构建我们的第一个 .NET MAUI 应用程序* 中的 *管理源代码* 部分。
- en: Understanding Razor components
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Razor 组件
- en: Although we developed and utilized Razor components in the previous two chapters,
    we have not yet delved deeply into them. In this section, we will continue refining
    the app from the last chapter while exploring Razor components more thoroughly,
    thereby gaining a better understanding of key concepts surrounding these components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在前两章中开发和使用了 Razor 组件，但我们还没有深入探讨它们。在本节中，我们将继续完善上一章的应用程序，同时更深入地探索 Razor 组件，从而更好地理解这些组件周围的关键概念。
- en: 'Blazor apps are constructed using Razor components. The first Razor component
    in our app is `Main`, and it is defined in `Main.razor`, as illustrated below:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 应用程序使用 Razor 组件构建。我们应用程序中的第一个 Razor 组件是 `Main`，它定义在 `Main.razor` 文件中，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Router` component, which is installed within the `Main` component, takes
    care of routing pages and selecting the default layout component. All other Razor
    pages are managed by the `Router` components. These Razor pages, loaded by the
    `Router`, have route templates defined and serve to display the user interface.
    In our project, Razor pages can be found in the `Pages` folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装在 `Main` 组件内的 `Router` 组件负责处理页面路由和选择默认布局组件。所有其他 Razor 页面都由 `Router` 组件管理。这些由
    `Router` 加载的 Razor 页面定义了路由模板，用于显示用户界面。在我们的项目中，Razor 页面位于 `Pages` 文件夹中。
- en: 'To understand the startup sequence of the Blazor Hybrid app, we can refer to
    *Figure 10.1* below:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Blazor 混合应用的启动顺序，可以参考下面的 *图 10.1*：
- en: '![](img/B21554_10_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_10_01.png)'
- en: 'Figure 10.1: Startup of the Blazor Hybrid app'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：Blazor 混合应用程序的启动
- en: As a .NET MAUI application, the starting point of the Blazor Hybrid app is also
    the `MauiProgram` class **(1)**. Within the `MauiProgram` class, an instance of
    the `App` class **(2)** is constructed. The first XAML page to be loaded into
    this is the `MainPage` **(3)** class. This `MainPage` includes an instance of
    `BlazorWebView` **(4)** that hosts the Blazor pages. For further information on
    how the Razor component `Main` is loaded into `BlazorWebView`, please refer to
    *Chapter 8**, Introducing Blazor Hybrid App Development*. Once the `Main` component
    is loaded into `BlazorWebView`, it exhibits the root of the navigation stack.
    In this particular scenario, the root page of the navigation stack is the `Login`
    page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 .NET MAUI 应用程序，Blazor 混合应用程序的起点也是 `MauiProgram` 类 **(1)**。在 `MauiProgram`
    类中，创建了一个 `App` 类的实例 **(2)**。第一个要加载到该实例中的 XAML 页面是 `MainPage` 类 **(3)**。这个 `MainPage`
    包含了一个 `BlazorWebView` 的实例 **(4)**，它托管了 Blazor 页面。有关如何将 Razor 组件 `Main` 加载到 `BlazorWebView`
    的更多信息，请参阅 *第 8 章*，介绍 Blazor 混合应用程序开发。一旦 `Main` 组件被加载到 `BlazorWebView` 中，它就展示了导航堆栈的根。在这种情况下，导航堆栈的根页面是
    `Login` 页面。
- en: Additionally, there are reusable Razor components that act as the building blocks
    of Razor pages. These Razor components are stored in the `Shared` folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些可重用的 Razor 组件，它们是 Razor 页面的构建块。这些 Razor 组件存储在 `Shared` 文件夹中。
- en: Essentially, each file possessing a `.razor` file extension represents a Razor
    component, which is compiled into a C# class upon execution. The filename serves
    as the class name, while the folder name contributes to the namespace. For instance,
    the `Login` Razor component resides in the `Pages` folder, so the folder name
    `Pages` is included as part of the namespace. Thus, the complete name of the `Login`
    class is `PassXYZ.Vault.Pages.Login`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，每个具有 `.razor` 扩展名的文件代表一个 Razor 组件，它在执行时被编译成一个 C# 类。文件名作为类名，而文件夹名则贡献于命名空间。例如，`Login`
    Razor 组件位于 `Pages` 文件夹中，因此文件夹名 `Pages` 被包含在命名空间中。因此，`Login` 类的完整名称是 `PassXYZ.Vault.Pages.Login`。
- en: Razor components can be written either in a single file or divided into a Razor
    file (`.razor`) and a code-behind C# file (`.cs`). The code-behind C# file defines
    a partial class containing all the programming logic. This approach was employed
    when we created the `Login` component in *Chapter 8**, Introducing Blazor Hybrid
    App Development*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 组件可以编写在一个单独的文件中，也可以分为一个 Razor 文件（`.razor`）和一个代码后 C# 文件（`.cs`）。代码后 C# 文件定义了一个包含所有编程逻辑的部分类。这种方法在我们创建
    *第 8 章*，介绍 Blazor 混合应用程序开发中的 `Login` 组件时被采用。
- en: '![Figure 9.1: Razor component naming convention](img/B21554_10_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：Razor 组件命名约定](img/B21554_10_02.png)'
- en: 'Figure 10.2: Razor component naming convention'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：Razor 组件命名约定
- en: As shown in *Figure 10.2*, when creating the `Login` component, we incorporated
    the Bootstrap CSS style for styling purposes. Razor components offer CSS isolation,
    which simplifies CSS usage and prevents collisions with other components or libraries.
    Moreover, Razor components can include their own CSS style in a `.razor.css` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.2* 所示，在创建 `Login` 组件时，我们加入了 Bootstrap CSS 风格以用于样式化。Razor 组件提供了 CSS 隔离，这简化了
    CSS 的使用，并防止了与其他组件或库的冲突。此外，Razor 组件可以在 `.razor.css` 文件中包含它们自己的 CSS 风格。
- en: Inheritance
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'As a Razor component is a C# class, it encompasses all features inherent to
    a C# class. Consequently, a Razor component can serve as a child class of another
    Razor component. In *Chapter 9**, Understanding Blazor Layout and Routing*, we
    observed that all layout components are derived classes of `LayoutComponentBase`
    when creating layout components. As illustrated in the `MainLayout.razor` code
    below, we employ the `@inherits` directive to specify the `LayoutComponentBase`
    as the base class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Razor 组件是一个 C# 类，它包含了 C# 类固有的所有功能。因此，Razor 组件可以作为另一个 Razor 组件的子类。在 *第 9 章*，理解
    Blazor 布局和路由中，我们观察到在创建布局组件时，所有布局组件都是 `LayoutComponentBase` 的派生类。如下面的 `MainLayout.razor`
    代码所示，我们使用 `@inherits` 指令指定 `LayoutComponentBase` 作为基类：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every Razor component is derived from the `ComponentBase` class. As a result,
    it is feasible to create a Razor component derived from the `ComponentBase` class
    using a C# file, without requiring a Razor markup file. For instance, we can create
    an `AppName` Razor component within a C# class, demonstrated as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Razor 组件都是 `ComponentBase` 类的派生类。因此，可以使用 C# 文件创建一个从 `ComponentBase` 类派生的
    Razor 组件，而不需要 Razor 标记文件。例如，我们可以在一个 C# 类中创建一个 `AppName` Razor 组件，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`AppName` is a Razor component that is designed without a Razor markup file
    (`.razor`); however, it functions identically to other Razor components, as demonstrated
    here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppName` 是一个没有 Razor 标记文件（`.razor`）设计的 Razor 组件；然而，它与其他 Razor 组件的功能相同，如下所示：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above example is used to demonstrate how to create a Razor component in
    C# code. However, it’s generally recommended to create UI components utilizing
    Razor markup instead of C# code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例用于演示如何在 C# 代码中创建 Razor 组件。然而，通常建议使用 Razor 标记而不是 C# 代码来创建 UI 组件。
- en: In this section, we introduced Razor components. We can place reusable Razor
    components in a shared folder to ensure that they are accessible throughout the
    project. Additionally, a Razor class library can be created to share Razor components
    across multiple projects. In the subsequent section, we will delve into the process
    of packaging these Razor components into a library.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Razor 组件。我们可以将可重用的 Razor 组件放在共享文件夹中，以确保它们在整个项目中可访问。此外，可以创建一个 Razor
    类库来在多个项目中共享 Razor 组件。在下一节中，我们将深入了解将这些 Razor 组件打包成库的过程。
- en: Creating a Razor class library
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Razor 类库
- en: In our project, we create reusable components and store them in the `Shared`
    folder. These components can be utilized by other components, such as layout components
    or `NavMenu`. Additionally, we can encapsulate Razor components within the Razor
    class library, making them accessible for use across various projects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们创建可重用组件并将它们存储在 `Shared` 文件夹中。这些组件可以被其他组件使用，例如布局组件或 `NavMenu`。此外，我们可以在
    Razor 类库中封装 Razor 组件，使它们可以在各种项目中使用。
- en: The components in the Razor class library are not specific to a single project,
    making them suitable for use in any Blazor project, whether it be Blazor Hybrid,
    Blazor WebAssembly, or Blazor Server apps.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 类库中的组件不特定于单个项目，这使得它们适用于任何 Blazor 项目，无论是 Blazor 混合应用、Blazor WebAssembly
    还是 Blazor 服务器应用。
- en: 'In this book, we construct Razor components utilizing Bootstrap. Numerous open-source
    Razor class libraries built on top of Bootstrap can be found on GitHub. Several
    of these libraries are sufficiently robust for commercial product development.
    Below are a few examples:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用 Bootstrap 构建了 Razor 组件。你可以在 GitHub 上找到许多基于 Bootstrap 构建的开放源码 Razor
    类库。其中一些库足够健壮，适用于商业产品开发。以下是一些示例：
- en: '`BootstrapBlazor`: [https://github.com/dotnetcore/BootstrapBlazor](https://github.com/dotnetcore/BootstrapBlazor)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BootstrapBlazor`：[https://github.com/dotnetcore/BootstrapBlazor](https://github.com/dotnetcore/BootstrapBlazor)'
- en: '`Blazorise`: [https://github.com/Megabit/Blazorise](https://github.com/Megabit/Blazorise)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blazorise`：[https://github.com/Megabit/Blazorise](https://github.com/Megabit/Blazorise)'
- en: '`Havit.Blazor`: [https://github.com/havit/Havit.Blazor/](https://github.com/havit/Havit.Blazor/)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Havit.Blazor`：[https://github.com/havit/Havit.Blazor/](https://github.com/havit/Havit.Blazor/)'
- en: 'These open-source projects are constructed as Razor class libraries, enabling
    their reuse in a manner analogous to other .NET libraries. Razor class libraries
    can be published as `NuGet` packages, allowing for seamless integration into our
    Blazor projects. For example, the `BootstrapBlazor` library can be found at this
    link: [https://www.nuget.org/packages/BootstrapBlazor/](https://www.nuget.org/packages/BootstrapBlazor/).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些开源项目被构建为 Razor 类库，使得它们可以像其他 .NET 库一样被重用。Razor 类库可以作为 `NuGet` 包发布，从而能够无缝集成到我们的
    Blazor 项目中。例如，`BootstrapBlazor` 库可以在以下链接找到：[https://www.nuget.org/packages/BootstrapBlazor/](https://www.nuget.org/packages/BootstrapBlazor/)。
- en: In this section, we will develop a Razor class library similar to the aforementioned
    open-source projects. We will incorporate reusable Razor components within our
    Razor class library. This library can then be published as a NuGet package. We
    have the option to create a Razor class library using either Visual Studio or
    the .NET command line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个类似于上述开源项目的 Razor 类库。我们将在我们的 Razor 类库中包含可重用的 Razor 组件。然后，这个库可以发布为
    NuGet 包。我们有选择使用 Visual Studio 或 .NET 命令行创建 Razor 类库的选项。
- en: 'To create a Razor class library using Visual Studio, we can add a new project
    to our solution, as illustrated in *Figure 10.3*, by following these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Visual Studio 创建 Razor 类库，我们可以按照以下步骤在我们的解决方案中添加一个新的项目，如图 10.3 所示：
- en: Search for and select **Razor Class Library** from the project templates.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目模板中搜索并选择**Razor 类库**。
- en: Click **Next**, and name the project **PassXYZ.BlazorUI**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，并将项目命名为**PassXYZ.BlazorUI**。
- en: On the subsequent screen, click **Create** to establish the library.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏上，点击**创建**以建立库。
- en: '![Figure 9.2: Creating a Razor class library](img/B21554_10_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2：创建 Razor 类库](img/B21554_10_03.png)'
- en: 'Figure 10.3: Creating a Razor class library'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：创建 Razor 类库
- en: 'To create the project using a dotnet command line, we can navigate to the solution
    folder and execute the following command in the Command Prompt:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 dotnet 命令行创建项目，我们可以导航到解决方案文件夹，并在命令提示符中执行以下命令：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `dotnet new` command creates a new project utilizing the `razorclasslib`
    template, naming the project `PassXYZ.BlazorUI`. In order to include the project
    in the solution, we can execute the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet new` 命令使用 `razorclasslib` 模板创建一个新的项目，并将项目命名为 `PassXYZ.BlazorUI`。为了将项目包含在解决方案中，我们可以执行以下命令：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to create our Razor components using this skeleton project, we must
    remove the unused `Component1.*` and `ExampleJsInterop.cs` files from the `PassXYZ.BlazorUI`
    project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个骨架项目创建我们的 Razor 组件，我们必须从 `PassXYZ.BlazorUI` 项目中删除未使用的 `Component1.*` 和
    `ExampleJsInterop.cs` 文件。
- en: 'To utilize Razor components in the `PassXYZ.BlazorUI` project, we must include
    the project reference within the `PassXYZ.Vault` project. To do so, we can simply
    right-click the project node in Visual Studio and select `Add -> Project Reference`.
    Alternatively, we can directly modify the `PassXYZ.Vault.csproj` project file
    by adding the following line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `PassXYZ.BlazorUI` 项目中使用 Razor 组件，我们必须在 `PassXYZ.Vault` 项目中包含项目引用。为此，我们可以在
    Visual Studio 中右键单击项目节点并选择 `Add -> Project Reference`。或者，我们可以直接修改 `PassXYZ.Vault.csproj`
    项目文件，添加以下行：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to create a new Razor component utilizing this library, we must update
    the `PassXYZ.Vault\_Imports.razor` file by adding the following line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个使用此库的新 Razor 组件，我们必须通过添加以下行更新 `PassXYZ.Vault_Imports.razor` 文件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using static assets in the Razor class library
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Razor 类库中使用静态资产
- en: 'We employ Bootstrap within our Razor components, so it’s necessary to include
    Bootstrap CSS and JavaScript files in the Razor class library. From the perspective
    of a Blazor app, we can place these static assets in either the project’s `wwwroot`
    folder or the component library’s `wwwroot` folder. Taking the Bootstrap CSS file
    as an example, if we store it in the project’s `wwwroot` directory, we can reference
    it in `index.xhtml` using the following path:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的 Razor 组件中使用了 Bootstrap，因此有必要在 Razor 类库中包含 Bootstrap CSS 和 JavaScript
    文件。从 Blazor 应用的角度来看，我们可以将这些静态资产放置在项目的 `wwwroot` 文件夹或组件库的 `wwwroot` 文件夹中。以 Bootstrap
    CSS 文件为例，如果我们将其存储在项目的 `wwwroot` 目录中，我们可以在 `index.xhtml` 中使用以下路径引用它：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we opt to store it in the component library’s `wwwroot` folder, we can reference
    it using the following path:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择将其存储在组件库的 `wwwroot` 文件夹中，我们可以使用以下路径引用它：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The distinction lies in the necessity to reference the URL in the component
    library, which should begin with `_content/{LibraryProjectName}`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于在组件库中引用 URL 的必要性，该 URL 应以 `_content/{LibraryProjectName}` 开头。
- en: Once we have established a Razor class library project, we can proceed to include
    additional components in it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了 Razor 类库项目，我们就可以继续在其中包含额外的组件。
- en: Creating reusable Razor components
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的 Razor 组件
- en: In this section, we will refactor our code to develop reusable components. This
    process will enable us to gain a deeper understanding of the features of Razor
    components and learn how to optimize them to improve reusability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重构我们的代码以开发可重用组件。这个过程将使我们能够更深入地了解 Razor 组件的功能，并学习如何优化它们以提高可重用性。
- en: In *Chapter 8**, Introducing Blazor Hybrid App Development*, we created the
    Blazor Hybrid version of our app. Additionally, we incorporated layout and routing
    functionalities in *Chapter 9**, Understanding Blazor Routing and Layout*. As
    a result, our app can now browse and update the password database. However, we
    have not yet implemented the majority of CRUD operations. After refining the Razor
    components in this chapter, we will proceed to add these functionalities.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 8 章* 中，我们介绍了 Blazor 混合应用开发。此外，我们在 *第 9 章* 中引入了布局和路由功能，即理解 Blazor 路由和布局。因此，我们的应用现在可以浏览和更新密码数据库。然而，我们尚未实现大多数
    CRUD 操作。在本章中完善 Razor 组件后，我们将继续添加这些功能。
- en: To navigate the password database, we developed two Razor components – `Items`
    and `ItemDetail`. The `Items` class is employed to exhibit a list of password
    entries and groups within the current group, while the `ItemDetail` class is utilized
    for presenting the content of an individual password entry.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导航密码数据库，我们开发了两个Razor组件——`Items`和`ItemDetail`。`Items`类用于展示当前组内的密码条目和分组列表，而`ItemDetail`类用于展示单个密码条目的内容。
- en: Upon examining the layout of `Items` and `ItemDetail`, as illustrated in *Figure
    10.4*, we can observe that both pages possess a similarity in terms of their appearance
    and overall design.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`Items`和`ItemDetail`的布局，如图10.4所示，我们可以观察到两个页面在外观和整体设计上具有相似性。
- en: '![Figure 9.3: UI layout of Items and ItemDetail](img/B21554_10_04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：Items和ItemDetail的UI布局](img/B21554_10_04.png)'
- en: 'Figure 10.4: UI layout of Items and ItemDetail'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：Items和ItemDetail的UI布局
- en: The layout of both pages features a sidebar, a header, and a list view. The
    sidebar is defined in the `layout` component, while the header and list view are
    implemented in both `Items` and `ItemDetail` with partially duplicated code. In
    this chapter, we will optimize our code by abstracting the duplicated portions
    into reusable components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两个页面的布局都包含侧边栏、页眉和列表视图。侧边栏在`layout`组件中定义，而页眉和列表视图在`Items`和`ItemDetail`中实现，部分代码是重复的。在本章中，我们将通过将重复的部分抽象为可重用组件来优化我们的代码。
- en: 'There are two buttons in the header: `Add` and `Back`. The `Back` button allows
    for navigation back to the parent group, while the `Add` button enables the user
    to add a new item or field.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在页眉中有两个按钮：`添加`和`返回`。`返回`按钮允许用户导航回父组，而`添加`按钮允许用户添加新条目或字段。
- en: In the list view item, we can utilize the context menu to execute item-level
    operations, such as editing or deleting. The context menu comprises menu items
    designated for specific actions related to the selected item or field. When performing
    edit or delete CRUD operations, upon selecting a menu item, a modal dialog relevant
    to the chosen action will appear.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表视图条目中，我们可以使用上下文菜单来执行条目级操作，如编辑或删除。上下文菜单包含针对所选条目或字段特定操作的菜单项。当执行编辑或删除CRUD操作时，选择菜单项后，将出现与所选操作相关的模态对话框。
- en: In the present implementation, both `Items` and `ItemDetail` incorporate all
    UI elements within a single Razor markup. We will begin to streamline the code
    by breaking it down into smaller, reusable components, which will result in a
    cleaner implementation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实现中，`Items`和`ItemDetail`将所有UI元素都包含在一个单独的Razor标记中。我们将开始通过将其分解为更小的、可重用的组件来简化代码，这将导致更清晰的实现。
- en: 'In this chapter, we will transform modal dialogs, headers, and list views into
    Razor components. Let’s begin with modal dialogs. To facilitate adding, editing,
    and deleting operations, we require two types of dialog boxes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把模态对话框、页眉和列表视图转换为Razor组件。让我们从模态对话框开始。为了方便添加、编辑和删除操作，我们需要两种类型的对话框：
- en: 'Editor dialog: for adding or editing items or fields'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑对话框：用于添加或编辑条目或字段
- en: 'Confirmation dialog: for confirmation prior to deleting an item or a field'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认对话框：在删除条目或字段之前进行确认
- en: In *Chapter 9*, *Understanding Blazor Routing and Layout*, we implemented modal
    dialogs by utilizing HTML and CSS code from Bootstrap examples. However, we have
    not examined these elements thoroughly, as our markup files appear lengthy and
    intricate. In this chapter, we will dissect the code and convert it into Razor
    components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*理解Blazor路由和布局*中，我们通过利用Bootstrap示例中的HTML和CSS代码实现了模态对话框。然而，我们没有对这些元素进行彻底检查，因为我们的标记文件看起来既长又复杂。在本章中，我们将分析代码并将其转换为Razor组件。
- en: Creating a base modal dialog component
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本模态对话框组件
- en: To improve the editor and confirmation dialogs, we can first construct a base
    modal dialog. By leveraging this base modal dialog, we can create either editor
    or confirmation dialogs as needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进编辑和确认对话框，我们首先可以构建一个基本模态对话框。通过利用这个基本模态对话框，我们可以根据需要创建编辑器或确认对话框。
- en: To create a new Razor component in the `PassXYZ.BlazorUI` project, right-click
    on the project node and select `Add` -> `New Item…` -> `Razor Component` from
    the project template. Name the Razor component `ModalDialog`, and create a C#
    code-behind file for it. Next, enter the code shown in *Listing 10.1* into `ModalDialog.razor`
    and the code in *Listing 10.2* into `ModalDialog.razor.cs`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`PassXYZ.BlazorUI`项目中创建一个新的Razor组件，请右键单击项目节点，然后从项目模板中选择`添加` -> `新建项…` -> `Razor组件`。将Razor组件命名为`ModalDialog`，并为它创建一个C#代码后文件。接下来，将*列表10.1*中的代码输入到`ModalDialog.razor`中，将*列表10.2*中的代码输入到`ModalDialog.razor.cs`中。
- en: 'The UI code is derived from the `Items` and `ItemDetail` code found in *Chapter
    9*, *Understanding Blazor Routing and Layout*, as depicted in *Listing 10.1*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: UI代码是从*第9章*中找到的`Items`和`ItemDetail`代码派生出来的，如*列表10.1*所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10.1: `ModalDialog.razor` ([https://epa.ms/ModalDialog10-1](https://epa.ms/ModalDialog10-1))'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '列表10.1: `ModalDialog.razor` ([https://epa.ms/ModalDialog10-1](https://epa.ms/ModalDialog10-1))'
- en: In the markup code displayed in *Listing 10.1*, we observe a typical HTML code
    snippet with Bootstrap styling. We have incorporated C# variables within the HTML
    to construct the component UI.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在*列表10.1*中显示的标记代码中，我们观察到带有Bootstrap样式的典型HTML代码片段。我们在HTML中加入了C#变量来构建组件UI。
- en: This base dialog UI comprises a header **(1)** and a body **(4)**. Within the
    header, there is a title **(2)** and a close button **(3)**. The body contains
    a child content area **(5)** and two buttons (**Close** **(6)**/**Save** **(7)**).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此基本对话框UI包含一个标题栏 **(1)** 和一个主体 **(4)**。在标题栏中，有一个标题 **(2)** 和一个关闭按钮 **(3)**。主体包含一个子内容区域
    **(5)** 和两个按钮（**关闭** **(6)**/**保存** **(7)**）。
- en: For a visual representation of the layout of this base modal dialog, please
    refer to *Figure 10.5:*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看此基本模态对话框的布局的视觉表示，请参阅*图10.5*：
- en: '![Figure 9.4: Base dialog](img/B21554_10_05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：基本对话框](img/B21554_10_05.png)'
- en: 'Figure 10.5: Base dialog'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：基本对话框
- en: 'Although the HTML and CSS code closely resemble the Bootstrap example, we have
    substituted all hardcoded content with C# variables. If we were to use this modal
    dialog component to construct a new component, the following would serve as an
    example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTML和CSS代码与Bootstrap示例非常相似，但我们已将所有硬编码的内容替换为C#变量。如果我们使用此模态对话框组件来构建新的组件，以下将作为示例：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above markup code, we define the modal dialog using the `<ModalDialog>`
    component tag. Each modal dialog is assigned a unique ID for identification purposes.
    We can display the dialog box by clicking a button, wherein the modal dialog ID
    is provided to facilitate its identification.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述标记代码中，我们使用`<ModalDialog>`组件标签定义了模态对话框。每个模态对话框都分配了一个唯一的ID以供识别。我们可以通过点击按钮来显示对话框，其中模态对话框ID被提供以方便其识别。
- en: Within the `<ModalDialog>` component tag, we have assigned values to multiple
    attributes defined in the `ModalDialog` component, including the `ID`, `title`,
    `button text`, `event handler`, and more.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<ModalDialog>`组件标签内，我们为`ModalDialog`组件中定义的多个属性赋值，包括`ID`、`标题`、`按钮文本`、`事件处理器`等。
- en: Data binding
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Rather than directly assigning a string or data to the attribute of an HTML
    element, we have the option to assign a variable to it. This capability is the
    data binding feature provided by Razor components. In this section, we will explore
    how to use data binding effectively. In data binding, assigning a variable to
    the attribute of a DOM element results in data flow from Razor components to DOM
    elements. Conversely, responding to a DOM event causes data to flow from DOM elements
    to Razor components.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接将字符串或数据分配给HTML元素的属性，我们可以选择将变量分配给它。这种能力是Razor组件提供的数据绑定功能。在本节中，我们将探讨如何有效地使用数据绑定。在数据绑定中，将变量分配给DOM元素的属性会导致从Razor组件到DOM元素的数据流。相反，响应DOM事件会导致数据从DOM元素流向Razor组件。
- en: Since we can use a Razor component in the same way as a DOM element, the data
    flow between child and parent Razor components resembles the data exchange between
    Razor components and DOM elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以像使用DOM元素一样使用Razor组件，因此子Razor组件和父Razor组件之间的数据流类似于Razor组件和DOM元素之间的数据交换。
- en: 'For instance, we can bind the `id` variable to the `Id` attribute of `ModalDialog`,
    managing the button click event using the `OnSaveClicked` event handler:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将`id`变量绑定到`ModalDialog`的`Id`属性上，通过`OnSaveClicked`事件处理器来管理按钮点击事件：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous example, the data flows from the `id` variable to the `Id` attribute
    of `ModalDialog`. When the `OnSaveClicked` event handler is invoked, the data
    flows back from `ModalDialog` to the current context. The `ModalDialog` attributes,
    `Id` and `OnSaveAsync`, are defined in the C# code-behind file. In the following
    section, let’s examine the C# code-behind file of `ModalDialog`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，数据从 `id` 变量流向 `ModalDialog` 的 `Id` 属性。当 `OnSaveClicked` 事件处理器被调用时，数据从
    `ModalDialog` 流回当前上下文。`ModalDialog` 的属性 `Id` 和 `OnSaveAsync` 在 C# 代码隐藏文件中定义。在下一节中，我们将检查
    `ModalDialog` 的 C# 代码隐藏文件。
- en: Component parameters
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件参数
- en: Razor components’ attributes can be defined using component parameters. To establish
    component parameters, we need to create public properties adorned with the `[Parameter]`
    attribute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 组件的属性可以使用组件参数定义。为了建立组件参数，我们需要创建带有 `[Parameter]` 属性的公共属性。
- en: 'In the `ModalDialog` class, illustrated in *Listing 10.2*, we declare seven
    component parameters: `Id`, `Title`, `ChildContent`, `OnClose`, `OnSaveAsync`,
    `CloseButtonText`, and `SaveButtonText`. These component parameters can be utilized
    in data binding:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *列表 10.2* 中所示的 `ModalDialog` 类中，我们声明了七个组件参数：`Id`、`Title`、`ChildContent`、`OnClose`、`OnSaveAsync`、`CloseButtonText`
    和 `SaveButtonText`。这些组件参数可以用于数据绑定：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 10.2: `ModalDialog.razor.cs` ([https://epa.ms/ModalDialog10-2](https://epa.ms/ModalDialog10-2))'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10.2: `ModalDialog.razor.cs` ([https://epa.ms/ModalDialog10-2](https://epa.ms/ModalDialog10-2))'
- en: 'The parameters of the `ModalDialog` component are defined as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModalDialog` 组件的参数定义如下：'
- en: '`Id` **(1)**: This identifier is used to distinguish a modal dialog.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id` **(1)**: 这个标识符用于区分模态对话框。'
- en: '`Title` **(2)**: This represents the title of the modal dialog.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Title` **(2)**: 这代表模态对话框的标题。'
- en: '`ChildContent` **(3)**: This is designated for the insertion of the child component’s
    content. The data type that we’re referring to is a `RenderFragment` delegate,
    which represents a segment of UI content. For more details, please refer to the
    following Microsoft document. We’ll dive deeper into this topic in *Chapter 11*:
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code](https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChildContent` **(3)**: 这是为了插入子组件的内容而指定的。我们指的是的数据类型是 `RenderFragment` 委托，它代表一段
    UI 内容。有关更多详细信息，请参阅以下 Microsoft 文档。我们将在第 *11章* 中更深入地探讨这个主题：[https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code](https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code).'
- en: Two event handlers – `OnClose` **(4)** and `OnSaveAsync` **(5)** – are defined
    to manage button click actions. We can customize the text on both buttons using
    `CloseButtonText` **(6)** and `SaveButtonText` **(7)**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两个事件处理器 – `OnClose` **(4)** 和 `OnSaveAsync` **(5)** – 用于管理按钮点击操作。我们可以使用 `CloseButtonText`
    **(6)** 和 `SaveButtonText` **(7)** 来自定义两个按钮上的文本。
- en: We can handle component parameters similarly to HTML attributes. A C# field,
    property, or method return value can be assigned to the component parameter of
    `ModalDialog`. Once we create the base `ModalDialog` component, we can then develop
    `Editor` and `Confirmation` dialog components using it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理 HTML 属性一样处理组件参数。C# 字段、属性或方法返回值可以被分配给 `ModalDialog` 的组件参数。一旦我们创建了基本的
    `ModalDialog` 组件，我们就可以用它来开发 `Editor` 和 `Confirmation` 对话框组件。
- en: 'Let’s create a new modal dialog, `ConfirmDialog`, which will prompt the user
    to confirm the deletion of an item. To create a new `ConfirmDialog` component
    within the `PassXYZ.BlazorUI` project, you can right-click on the project node
    and select `Add` -> `New Item…` -> `Razor Component` from the project template.
    We can name the Razor component `ConfirmDialog` and input the following code provided
    in *Listing 10.3*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的模态对话框，`ConfirmDialog`，它将提示用户确认删除项目。要在 `PassXYZ.BlazorUI` 项目中创建新的 `ConfirmDialog`
    组件，您可以在项目节点上右键单击，然后从项目模板中选择 `Add` -> `New Item…` -> `Razor Component`。我们可以将 Razor
    组件命名为 `ConfirmDialog` 并输入 *列表 10.3* 中提供的以下代码：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10.3: `ConfirmDialog.razor` ([https://epa.ms/ConfirmDialog10-3](https://epa.ms/ConfirmDialog10-3))'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10.3: `ConfirmDialog.razor` ([https://epa.ms/ConfirmDialog10-3](https://epa.ms/ConfirmDialog10-3))'
- en: We define the `Id` **(1)** and `Title` **(2)** component parameters in the `ConfirmDialog`
    and pass their values to the base class using data binding. Additionally, we subscribe
    to the `OnSaveAsync` event by utilizing the `OnSave` event handler. We also define
    our own event handler, `OnConfirmClick`, as a component parameter, allowing other
    components to subscribe to it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ConfirmDialog`中定义了`Id` **(1)** 和`Title` **(2)** 组件参数，并通过数据绑定将它们的值传递给基类。此外，我们通过使用`OnSave`事件处理器来订阅`OnSaveAsync`事件。我们还定义了自己的事件处理器`OnConfirmClick`作为组件参数，允许其他组件订阅它。
- en: 'In the `ConfirmDialog`, we actually bind parameters using nested components.
    In this scenario, the data flow should follow the suggested directions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConfirmDialog`中，我们实际上是通过嵌套组件来绑定参数的。在这种情况下，数据流应遵循以下建议的方向：
- en: Change notifications should move upward through the hierarchy.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更通知应向上通过层次结构传播。
- en: New parameter values should flow downward through the hierarchy.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新参数值应向下通过层次结构传播。
- en: 'The values for the `Id` and `Title` attributes are assigned by the components
    that utilize `ConfirmDialog`, and their values cascade down to `ModalDialog`.
    The `Save` or `Close` button events are initiated within the `ModalDialog` component
    and subsequently propagate upwards through the chain to `ConfirmDialog` and higher-level
    components. Using the `Save` button as an example, the event follows the upward
    direction illustrated here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id`和`Title`属性值由使用`ConfirmDialog`的组件分配，并且它们的值会级联到`ModalDialog`。`Save`或`Close`按钮事件在`ModalDialog`组件内部启动，然后通过链向上传播到`ConfirmDialog`和更高层次的组件。以`Save`按钮为例，事件遵循此处所示的上行方向：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The process begins with the `onclick` event in the DOM. `ModalDialog` defines
    its own event, `OnSaveAsync`, which is activated by the `onclick` event handler.
    `ConfirmDialog`, on the other hand, establishes its own event called `OnConfirmClick`,
    which is initiated by the `OnSaveAsync` event handler.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 流程从DOM中的`onclick`事件开始。`ModalDialog`定义了自己的事件`OnSaveAsync`，该事件由`onclick`事件处理器激活。另一方面，`ConfirmDialog`建立了一个名为`OnConfirmClick`的事件，该事件由`OnSaveAsync`事件处理器启动。
- en: Nested components
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套组件
- en: '`ConfirmDialog` serves as an example of nested components. As demonstrated,
    we can embed components within other components by declaring them using HTML syntax.
    The embedded components appear as HTML tags, with the tag name corresponding to
    the component type. For instance, we can utilize `ModalDialog` inside `ConfirmDialog`,
    as illustrated here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmDialog`是嵌套组件的一个例子。如所示，我们可以通过使用HTML语法声明它们来在其他组件内嵌入组件。嵌入的组件看起来像HTML标签，标签名对应组件类型。例如，我们可以在`ConfirmDialog`内部使用`ModalDialog`，如下所示：'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Nested components serve as a means to construct a component hierarchy in Blazor.
    In object-oriented programming languages, inheritance and composition are two
    methods for extending and reusing a class. In Blazor, composition is employed
    within nested components to enhance functionalities. Inheritance represents an
    `'is-a'` relationship, whereas composition signifies a `'has-a'` relationship.
    In the case of nested components, the parent component encompasses a child component.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套组件是构建Blazor组件层次结构的一种手段。在面向对象的编程语言中，继承和组合是扩展和重用类的方法。在Blazor中，嵌套组件内部使用组合来增强功能。继承代表了一个`'is-a'`关系，而组合则代表了一个`'has-a'`关系。在嵌套组件的情况下，父组件包含子组件。
- en: In Microsoft Blazor and ASP.NET Core documents, the terms `"ancestor"` and `"descendant"`
    or `"parent"` and `"child"` are utilized to describe the relationship between
    nested components. In this context, the parent and child relationship is not one
    of inheritance but of composition. A more suitable term could be “outer component”
    or “inner component.” However, to maintain consistency with Microsoft documentation,
    I will not opt for alternative terms in our discussion. Please be mindful that
    when we discuss nested components and data binding, the ancestor and descendant
    relationship represents a `"has-a"` relationship or a composition.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Blazor和ASP.NET Core文档中，使用`"ancestor"`和`"descendant"`或`"parent"`和`"child"`等术语来描述嵌套组件之间的关系。在这种情况下，父子和关系不是继承关系，而是组合关系。一个更合适的术语可能是“外部组件”或“内部组件”。然而，为了与Microsoft文档保持一致，我将在我们的讨论中不选择替代术语。请注意，当我们讨论嵌套组件和数据绑定时，祖先和后代关系代表了一种“有”关系或组合关系。
- en: In our previous example, the `ConfirmDialog` component serves as the outer component,
    while the `ModalDialog` acts as the inner component. The relationship between
    them is such that the `ConfirmDialog` contains the `ModalDialog` within it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，`ConfirmDialog` 组件作为外部组件，而 `ModalDialog` 作为内部组件。它们之间的关系是 `ConfirmDialog`
    在其中包含 `ModalDialog`。
- en: Child content rendering
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子内容渲染
- en: 'When building nested components, there are often scenarios where one component
    sets the content of another component. The outer component supplies the content
    situated between the inner component’s opening and closing tags. In the case of
    `ConfirmDialog`, the content of `ModalDialog` is configured as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建嵌套组件时，经常会出现一个组件设置另一个组件内容的情况。外部组件提供位于内部组件打开和关闭标签之间的内容。在 `ConfirmDialog` 的情况下，`ModalDialog`
    的内容配置如下：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is accomplished by employing a unique component parameter called `ChildContent`,
    which is of the `RenderFragment` type. In the previous code, the `"Please confirm
    to delete @Title?"` string is assigned to the `ChildContent` parameter of `ModalDialog`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用一个独特的组件参数 `ChildContent` 来实现的，它属于 `RenderFragment` 类型。在之前的代码中，将 `"请确认删除
    @Title?"` 字符串分配给 `ModalDialog` 的 `ChildContent` 参数。
- en: The `ConfirmDialog` represents a relatively simple example of nested components.
    Let’s consider another example, `EditorDialog`, to further examine the features
    of Razor components. As previously mentioned, we require two dialog boxes to manage
    add, edit, and delete actions. The `ConfirmDialog` serves to seek user confirmation
    before deleting an item or a field. In order to add or edit an item or a field,
    we need a dialog box equipped with editing capabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmDialog` 代表了嵌套组件的一个相对简单的例子。让我们考虑另一个例子，`EditorDialog`，以进一步检查 Razor 组件的功能。如前所述，我们需要两个对话框来管理添加、编辑和删除操作。`ConfirmDialog`
    用于在删除项目或字段之前寻求用户确认。为了添加或编辑项目或字段，我们需要一个具有编辑功能的对话框。'
- en: We can follow the same procedure to create a new component, `EditorDialog`.
    After selecting `Add` -> `New Item…` -> `Razor Component` in the project template,
    we can assign the name `EditorDialog` to the Razor component and create a corresponding
    C# code-behind file. Subsequently, we can input the code from *Listing 10.4* into
    `EditorDialog.razor` and the code from *Listing 10.5* into `EditorDialog.razor.cs`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循相同的步骤来创建一个新的组件，`EditorDialog`。在项目模板中选择 `添加` -> `新建项…` -> `Razor 组件` 后，我们可以将
    `EditorDialog` 命名给 Razor 组件并创建相应的 C# 后置代码文件。随后，我们可以将 *清单 10.4* 中的代码输入到 `EditorDialog.razor`
    中，将 *清单 10.5* 中的代码输入到 `EditorDialog.razor.cs` 中。
- en: 'Let us examine the Razor markup code of `EditorDialog`, as displayed in *Listing
    10.4*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `EditorDialog` 的 Razor 标记代码，如 *清单 10.4* 所示：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10.4: `EditorDialog.razor` ([https://epa.ms/EditorDialog10-4](https://epa.ms/EditorDialog10-4))'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 10.4: `EditorDialog.razor` ([https://epa.ms/EditorDialog10-4](https://epa.ms/EditorDialog10-4))'
- en: 'The `EditorDialog`, built using `ModalDialog`, is designed for editing key-value
    pairs. There are two use cases we aim to support with this component: creating
    a new key-value pair, where both the key and value are editable, and modifying
    an existing key-value pair, where only the value field may need alteration.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ModalDialog` 构建的 `EditorDialog` 旨在编辑键值对。我们希望通过此组件支持两种用例：创建新的键值对，其中键和值都是可编辑的，以及修改现有的键值对，其中可能只需要更改值字段。
- en: To facilitate these scenarios, we use a component parameter called `IsKeyEditingEnabled`
    **(1)** to detect the conditions. To create a new key-value pair, the key input
    is rendered as an `<input>` element **(2)**, while to edit an existing key-value
    pair, the key is displayed as the title in the header area. In both cases, the
    value can be edited using a `<textarea>` element `(3)`. This constitutes the core
    functionality of our `EditorDialog` component.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于这些场景，我们使用一个名为 `IsKeyEditingEnabled` 的组件参数 **(1**) 来检测条件。为了创建新的键值对，键输入被渲染为一个
    `<input>` 元素 **(2**)，而为了编辑现有的键值对，键在标题区域显示。在两种情况下，值都可以使用 `<textarea>` 元素 `(3)`
    进行编辑。这构成了我们 `EditorDialog` 组件的核心功能。
- en: As shown in *Figure 10.6*, the UI depicts two different dialogs. On the left-hand
    side, a dialog appears when we intend to add a new field, requiring us to input
    the field name and content. Meanwhile, on the right-hand side, a dialog is displayed
    when we aim to edit an existing URL field. The field name is presented in the
    title, and the content can be modified in the `<textarea>` element.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.6* 所示，UI 描述了两个不同的对话框。在左侧，当我们打算添加新字段时，会出现一个对话框，要求我们输入字段名称和内容。同时，在右侧，当我们打算编辑现有的
    URL 字段时，会显示一个对话框。字段名称显示在标题中，内容可以在 `<textarea>` 元素中修改。
- en: '![Figure 9.5: Editing a field](img/B21554_10_06.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5：编辑字段](img/B21554_10_06.png)'
- en: 'Figure 10.6: Editing a field'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：编辑字段
- en: In the `EditorDialog` component, when we edit the key and value using the `<input>`
    and `<textarea>` HTML elements, the initial value is displayed. This initial value
    is set from the Razor component to the DOM. Once we make changes, the data flows
    from the DOM back to the Razor component, exemplifying two-way data binding.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `EditorDialog` 组件中，当我们使用 `<input>` 和 `<textarea>` HTML 元素编辑键和值时，会显示初始值。这个初始值是从
    Razor 组件设置到 DOM 的。一旦我们做出更改，数据就会从 DOM 流回 Razor 组件，这展示了双向数据绑定的例子。
- en: Two-way data binding
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: 'Two-way data binding can be established using the `@bind` Razor directive attribute.
    This syntax enables an HTML element attribute to bind to a field, property, expression
    value, or the result of a method. In *Listing 10.4*, the value of the `<input>`
    element is bound to the `Key` property within the `EditorDialog` component:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `@bind` Razor 指令属性来建立双向数据绑定。这种语法允许 HTML 元素属性绑定到一个字段、属性、表达式值或方法的结果。在 *清单
    10.4* 中，`<input>` 元素的值绑定到了 `EditorDialog` 组件内的 `Key` 属性：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the case of two-way data binding, the DOM element `<input>` value is updated
    whenever the `Key` property undergoes a change. Similarly, when the user modifies
    the `<input>` value in the DOM, the `Key` property is updated accordingly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向数据绑定的情况下，每当 `Key` 属性发生变化时，DOM 元素 `<input>` 的值都会更新。同样，当用户在 DOM 中修改 `<input>`
    的值时，`Key` 属性也会相应地更新。
- en: 'In the previous example, we have the option to replace the `@bind` directive
    attribute with two one-way data bindings, as demonstrated in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们有选择用两种单向数据绑定来替换 `@bind` 指令属性，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Upon rendering our `EditorDialog` component, the value of the `<input>` element
    is derived from the `Key` property. As the user inputs a value into the textbox
    and shifts the element focus, the `onchange` event is triggered, subsequently
    updating the `Key` property with the modified value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染 `EditorDialog` 组件时，`<input>` 元素的值是从 `Key` 属性派生出来的。当用户在文本框中输入值并改变元素焦点时，会触发
    `onchange` 事件，随后用修改后的值更新 `Key` 属性。
- en: 'For the `<input>` element, the default event of the `@bind` directive attribute
    is the `onchange` event. We can modify the event using the `@bind:event="{event}"`
    attribute. The `{event}` placeholder should represent a DOM event. For instance,
    we can replace the `onchange` event with the `oninput` event using the following
    code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `<input>` 元素，`@bind` 指令属性的默认事件是 `onchange` 事件。我们可以使用 `@bind:event="{event}"`
    属性来修改事件。`{event}` 占位符应代表一个 DOM 事件。例如，我们可以使用以下代码片段将 `onchange` 事件替换为 `oninput`
    事件：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Binding with component parameters
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定到组件参数
- en: In the previous section, we explored two-way data binding between a Razor component
    and a DOM element. As Razor components can function similarly to DOM elements,
    it is also possible to establish two-way data binding between two Razor components.
    This often occurs when there is a need for communication between parent and child
    components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分，我们探讨了 Razor 组件和 DOM 元素之间的双向数据绑定。由于 Razor 组件可以像 DOM 元素一样工作，因此也可以在两个 Razor
    组件之间建立双向数据绑定。这通常发生在需要父组件和子组件之间进行通信的情况下。
- en: We can bind a component parameter of an inner component to the property of an
    outer component using the `@bind-{PROPERTY}` syntax. In this case, `{PROPERTY}`
    refers to the property to be bound. We have explained that the `@bind` directive
    attribute can be replaced by two one-way data binding setups, which involve assigning
    a variable to the `<input>` value attribute and assigning an event handler to
    the `onchange` event. While the compiler can automatically add the event handler
    for `@bind`, it cannot do so for `@bind-{PROPERTY}`. Therefore, we need to define
    our own event of the `EventCallback<TValue>` type to bind with component parameters.
    The event name must follow the `{PARAMETER NAME}Changed` format. To illustrate
    the `@bind-{PROPERTY}` directive attribute’s usage, let’s use our `EditorDialog`
    component as an example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@bind-{PROPERTY}`语法将内部组件的组件参数绑定到外部组件的属性。在这种情况下，`{PROPERTY}`指的是要绑定的属性。我们已解释过，`@bind`指令属性可以被两个单向数据绑定设置替代，这涉及到将变量分配给`<input>`的值属性，并将事件处理程序分配给`onchange`事件。虽然编译器可以自动添加`@bind`的事件处理程序，但它不能为`@bind-{PROPERTY}`做同样的事情。因此，我们需要定义自己的`EventCallback<TValue>`类型的事件来与组件参数绑定。事件名称必须遵循`{PARAMETER
    NAME}Changed`格式。为了说明`@bind-{PROPERTY}`指令属性的使用，让我们以我们的`EditorDialog`组件为例。
- en: 'In our code, we utilize the `EditorDialog` in the `ItemDetail` component to
    edit a field, or similarly, in the `Items` component to edit an item. Let’s examine
    field editing as an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们在`ItemDetail`组件中使用`EditorDialog`来编辑字段，或者在`Items`组件中编辑项目。让我们以字段编辑为例进行考察：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the previous code of the `ItemDetail` component, we can create data binding
    for `Key` **(1)** and `Value` **(2)** to the `listGroupField` of the `Field` type.
    We need to implement the `{PARAMETER NAME}Changed` events in the C# code-behind
    for `EditorDialog`, as demonstrated in *Listing 10.5*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ItemDetail`组件的前一个代码中，我们可以为`Key` **(1**) 和 `Value` **(2**) 创建与`Field`类型的`listGroupField`的数据绑定。我们需要在`EditorDialog`的C#代码后部分实现`{PARAMETER
    NAME}Changed`事件，如下所示 *清单10.5*：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10.5: `EditorDialog.razor.cs` ([https://epa.ms/EditorDialog10-5](https://epa.ms/EditorDialog10-5))'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '清单10.5: `EditorDialog.razor.cs` ([https://epa.ms/EditorDialog10-5](https://epa.ms/EditorDialog10-5))'
- en: In *Listing 10.5*, we utilize the `Key` property as an example to illustrate
    the component parameter binding process. The `Key` property is defined as a component
    parameter with the `[Parameter]` attribute. An associated event, `KeyChanged`,
    is defined as an `EventCallback<TValue>` type. When the text input is modified
    by the user and the element focus shifts, the `Key` property setter is invoked.
    Within the setter of the `Key` property, the `KeyChanged` event is triggered,
    which notifies the outer `ItemDetail` component. Consequently, the linked variable
    `listGroupField.Key` is updated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *清单10.5* 中，我们利用`Key`属性作为示例来说明组件参数绑定过程。`Key`属性定义为具有`[Parameter]`属性的组件参数。相关的事件`KeyChanged`定义为`EventCallback<TValue>`类型。当用户修改文本输入并且元素焦点改变时，`Key`属性的setter被调用。在`Key`属性的setter中，触发`KeyChanged`事件，该事件通知外部的`ItemDetail`组件。因此，链接变量`listGroupField.Key`被更新。
- en: Communicating with cascading values and parameters
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与级联值和参数通信
- en: We can utilize data binding to transfer data between parent and child components.
    Data binding is effective when passing data to intermediate child components.
    However, there may be instances where we need to pass data to components located
    several levels deep. In such situations, utilizing data binding requires creating
    multiple levels of chained data binding – subsequently increasing the complexity
    as the chained levels expand. For instance, when passing data from `Items` to
    `ModalDialog`, we first need to establish a data binding with `ConfirmDialog`.
    Then, another level of data binding must be created between `ConfirmDialog` and
    `ModalDialog`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用数据绑定在父组件和子组件之间传递数据。当向中间子组件传递数据时，数据绑定非常有效。然而，可能存在需要将数据传递到位于几层深度的组件的情况。在这种情况下，利用数据绑定需要创建多个级别的链式数据绑定，随着链式级别的扩展，复杂性也随之增加。例如，当从`Items`传递数据到`ModalDialog`时，我们首先需要与`ConfirmDialog`建立数据绑定。然后，必须在`ConfirmDialog`和`ModalDialog`之间创建另一个级别的数据绑定。
- en: 'In the `Items` component, we need to pass the `Id` of the dialog to `ModalDialog`.
    An `Id` is necessary to identify the specific dialog instance we wish to display.
    As demonstrated below, we define `ConfirmDialog` within the `Items` component.
    The `Id` is defined within `Items` and passed to `ConfirmDialog` through the use
    of component parameters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Items` 组件中，我们需要将对话框的 `Id` 传递给 `ModalDialog`。`Id` 是必要的，用于识别我们希望显示的特定对话框实例。如下所示，我们在
    `Items` 组件中定义 `ConfirmDialog`。`Id` 在 `Items` 中定义，并通过组件参数传递给 `ConfirmDialog`：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, `ConfirmDialog` must pass the `Id` to `ModalDialog`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`ConfirmDialog` 必须将 `Id` 传递给 `ModalDialog`：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `ModalDialog`, `Id` is used as an attribute of the `<div>` element:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ModalDialog` 中，`Id` 被用作 `<div>` 元素的属性：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In order to prevent numerous levels of data binding, we can employ cascading
    values and parameters as a technique to facilitate data flow through a component
    hierarchy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止多级数据绑定，我们可以使用级联值和参数作为技术，以促进通过组件层次结构的数据流。
- en: '`CascadingValue` is a component within the Blazor framework. The outer component
    supplies a cascading value by using `CascadingValue`, while the inner component
    can obtain it by employing the `[CascadingParameter]` attribute. To demonstrate
    its usage, we can modify the `Items` component’s code as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingValue` 是 Blazor 框架中的一个组件。外部组件通过使用 `CascadingValue` 提供级联值，而内部组件可以通过使用
    `[CascadingParameter]` 属性来获取它。为了演示其用法，我们可以修改 `Items` 组件的代码如下：'
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We utilize cascading values with the `<CascadingValue>` tag. Within the `<CascadingValue>`
    tag, we assign the `_dialogDeleteId` variable to the `Value` attribute and the
    `Id` string to the `Name` attribute. As this `Id` is not directly employed by
    `ConfirmDialog`, the `Id` component parameter can be safely removed from `ConfirmDialog`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `<CascadingValue>` 标签来使用级联值。在 `<CascadingValue>` 标签内，我们将 `_dialogDeleteId`
    变量分配给 `Value` 属性，将 `Id` 字符串分配给 `Name` 属性。由于此 `Id` 并未直接由 `ConfirmDialog` 使用，因此可以安全地删除
    `ConfirmDialog` 中的 `Id` 组件参数。
- en: 'In the `ModalDialog`, we modify the `Id` property to be a parameter by utilizing
    the `[CascadingParameter]` attribute instead of a component parameter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ModalDialog` 中，我们通过使用 `[CascadingParameter]` 属性将 `Id` 属性修改为参数，而不是组件参数：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When working with just one cascading value, specifying its name is not mandatory,
    as the compiler can locate it by data type. However, to prevent ambiguities, we
    can assign a name to the cascading value using the `Name` attribute. Next, we
    will examine the final modifications in the `Items` component, which employs cascading
    values for both `ConfirmDialog` and `EditorDialog`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当只使用一个级联值时，指定其名称不是强制性的，因为编译器可以通过数据类型定位它。然而，为了防止歧义，我们可以使用 `Name` 属性给级联值赋予一个名称。接下来，我们将检查
    `Items` 组件的最终修改，该组件为 `ConfirmDialog` 和 `EditorDialog` 都使用了级联值：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As demonstrated, after implementing a cascading value, `ConfirmDialog` and `EditorDialog`
    no longer need to handle the `Id` field directly. Consequently, the code is more
    compact compared to the previous version.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在实现级联值之后，`ConfirmDialog` 和 `EditorDialog` 就不再需要直接处理 `Id` 字段。因此，与之前的版本相比，代码更加紧凑。
- en: In this section, we explored the creation of reusable components. Some Razor
    components might rely on data or network services, necessitating additional steps
    during their creation or destruction. We can accomplish these actions as part
    of the lifecycle management of Razor components.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了可重用组件的创建。一些 Razor 组件可能依赖于数据或网络服务，在它们的创建或销毁过程中需要额外的步骤。我们可以将这些操作作为 Razor
    组件生命周期管理的一部分来完成。
- en: In the following section, let us examine the lifecycle of Razor components in
    greater detail.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们更详细地考察 Razor 组件的生命周期。
- en: Understanding the Razor component lifecycle
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Razor 组件生命周期
- en: A Razor component, like any other object, possesses a lifecycle. It consists
    of a series of synchronous and asynchronous lifecycle methods that developers
    can override to perform additional operations during component initialization
    and rendering.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 组件，就像任何其他对象一样，具有生命周期。它由一系列同步和异步的生命周期方法组成，开发者可以重写这些方法以在组件初始化和渲染期间执行额外的操作。
- en: 'Refer to *Figure 10.7* for an overview of the Razor component lifecycle:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *图 10.7* 以了解 Razor 组件生命周期的概述：
- en: '![Figure 9.6: Razor component lifecycle](img/B21554_10_07.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6：Razor 组件生命周期](img/B21554_10_07.png)'
- en: 'Figure 10.7: Razor component lifecycle'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：Razor 组件生命周期
- en: 'In *Figure 10.7*, it is evident that we have the ability to add hooks during
    both the initialization and rendering phases. The methods listed below can be
    overridden to capture initialization events:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 10.7 中，很明显，我们有能力在初始化和渲染阶段添加钩子。以下方法可以被重写以捕获初始化事件：
- en: '`SetParametersAsync`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetParametersAsync`'
- en: '`OnInitialized` and `OnInitializedAsync`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInitialized` 和 `OnInitializedAsync`'
- en: '`OnParametersSet` and `OnParametersSetAsync`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnParametersSet` 和 `OnParametersSetAsync`'
- en: '`SetParametersAsync` and `OnInitializedAsync` are invoked only in the first
    render. `OnParametersSet``Async` is called every time a parameter is changed.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetParametersAsync` 和 `OnInitializedAsync` 只在第一次渲染时被调用。`OnParametersSetAsync`
    每次参数更改时都会被调用。'
- en: 'The following methods can be overridden to customize rendering:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法可以被重写以自定义渲染：
- en: '`ShouldRender`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShouldRender`'
- en: '`OnAfterRender` and `OnAfterRenderAsync`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnAfterRender` 和 `OnAfterRenderAsync`'
- en: We will examine these lifecycle methods in detail and demonstrate how they can
    be utilized in our code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细检查这些生命周期方法，并演示如何在我们的代码中利用它们。
- en: SetParametersAsync
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SetParametersAsync
- en: '`SetParametersAsync` is the first hook after the object is created and it has
    the following signature:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetParametersAsync` 是对象创建后的第一个钩子，其签名如下：'
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `ParameterView` parameter encompasses component parameters or cascading
    parameter values. `SetParametersAsync` assigns values to each property with either
    the `[Parameter]` or `[CascadingParameter]` attribute. This function can be overridden
    to incorporate any logic that must be executed before setting the parameters.
    The subsequent hook following `SetParametersAsync` is `OnInitializedAsync`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParameterView` 参数包括组件参数或级联参数值。`SetParametersAsync` 方法通过 `[Parameter]` 或 `[CascadingParameter]`
    属性将值分配给每个属性。此函数可以被重写以包含在设置参数之前必须执行的任何逻辑。`SetParametersAsync` 后续的钩子是 `OnInitializedAsync`。'
- en: OnInitialized and OnInitializedAsync
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnInitialized 和 OnInitializedAsync
- en: '`OnInitialized` and `OnInitializedAsync` are invoked when the component is
    initialized. They have the following signatures, respectively:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInitialized` 和 `OnInitializedAsync` 在组件初始化时被调用。它们的签名分别如下：'
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By overriding these two functions, we can incorporate logic to initialize our
    component at this stage. However, keep in mind that these functions are called
    only once, immediately following the component’s creation. For resource-intensive
    initialization tasks, asynchronous methods can be employed, such as downloading
    data via RESTful API calls. As illustrated in *Figure 10.7*, once an asynchronous
    method is completed, the DOM necessitates re-rendering.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写这两个函数，我们可以在这一阶段将逻辑集成到我们的组件中。然而，请注意，这些函数仅在组件创建后立即调用一次。对于资源密集型的初始化任务，可以使用异步方法，例如通过
    RESTful API 调用下载数据。如图 10.7 所示，一旦异步方法完成，DOM 需要重新渲染。
- en: OnParametersSet and OnParametersSetAsync
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnParametersSet 和 OnParametersSetAsync
- en: When component parameters are set or modified, `OnParametersSet` and `OnParametersSetAsync`
    are invoked. We observe that there are two versions to accommodate both synchronous
    and asynchronous scenarios. The asynchronous version, `OnParametersSetAsync`,
    can be employed to manage time-consuming tasks. Upon completion of the asynchronous
    task, the DOM must be re-rendered to display any updates.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件参数被设置或修改时，会调用 `OnParametersSet` 和 `OnParametersSetAsync`。我们注意到有两种版本以适应同步和异步场景。异步版本
    `OnParametersSetAsync` 可以用于管理耗时任务。异步任务完成后，必须重新渲染 DOM 以显示任何更新。
- en: 'The methods have the following signatures, respectively:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的签名分别如下：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These two methods are invoked whenever component parameters or cascading parameters
    change and may be called multiple times. In contrast, `OnInitializedAsync` is
    called only once.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在组件参数或级联参数更改时都会被调用，并且可能被多次调用。相比之下，`OnInitializedAsync` 只会被调用一次。
- en: As illustrated in *Figure 10.7*, the DOM can undergo multiple renderings during
    the initialization phase, resulting in the invocation of asynchronous calls. The
    methods involved in this rendering process include `ShouldRender` and `OnAfterRenderAsync`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 10.7 所示，在初始化阶段，DOM 可能会进行多次渲染，从而导致异步调用的调用。涉及此渲染过程的方法包括 `ShouldRender` 和 `OnAfterRenderAsync`。
- en: ShouldRender
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ShouldRender
- en: 'The `ShouldRender` method returns a Boolean value, indicating whether the component
    ought to be rendered. As illustrated in *Figure 10.7*, the first render disregards
    this method. Consequently, a component must be rendered at least once. This method
    possesses the following signature:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShouldRender`方法返回一个布尔值，指示组件是否应该被渲染。如图*图10.7*所示，第一次渲染会忽略此方法。因此，组件至少需要渲染一次。此方法具有以下签名：'
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: OnAfterRender and OnAfterRenderAsync
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnAfterRender和OnAfterRenderAsync
- en: '`OnAfterRender` and `OnAfterRenderAsync` are invoked after a component has
    completed its rendering process. Their respective signatures are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnAfterRender`和`OnAfterRenderAsync`在组件完成其渲染过程后调用。它们的相应签名如下：'
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These methods can be utilized to execute supplementary initialization tasks
    with the rendered content, such as invoking JavaScript code in the component.
    This method features a Boolean `firstRender` parameter, enabling us to attach
    JavaScript event handlers only once. Although there is an asynchronous version
    of this method, the framework does not schedule another render cycle upon the
    completion of the asynchronous task.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以用来执行与渲染内容相关的附加初始化任务，例如在组件中调用JavaScript代码。此方法具有一个布尔型`firstRender`参数，使我们能够仅附加一次JavaScript事件处理器。尽管此方法有一个异步版本，但在异步任务完成后，框架不会安排另一个渲染周期。
- en: 'To examine the impact of lifecycle methods, we can conduct a test by incorporating
    all lifecycle methods into the `ConfirmDialog` component, as demonstrated below:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查生命周期方法的影响，我们可以通过将所有生命周期方法集成到`ConfirmDialog`组件中来进行测试，如下所示：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have overridden all lifecycle methods in `ConfirmDialog` and added debug
    output to display the progress. Upon launching our app, we can observe the following
    output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已覆盖了`ConfirmDialog`中的所有生命周期方法，并添加了调试输出以显示进度。在启动我们的应用程序后，我们可以观察到以下输出：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The previous output is displayed when we first launch our app and the `Items`
    page appears. We can observe that the `Id` cascading parameter is not set before
    the `SetParametersAsync` method is called. Since we have overridden the asynchronous
    methods, multiple render cycles are scheduled to occur simultaneously. As a result,
    the `ShouldRender` and `OnAfterRenderAsync` methods are invoked multiple times
    due to parallel rendering.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次启动应用程序并且`Items`页面出现时，会显示之前的输出。我们可以观察到在调用`SetParametersAsync`方法之前，`Id`级联参数尚未设置。由于我们已覆盖了异步方法，因此同时安排了多个渲染周期。因此，由于并行渲染，`ShouldRender`和`OnAfterRenderAsync`方法被多次调用。
- en: 'Now, let’s consider another case, which occurs when we click on the context
    menu on the `Items` page. Upon clicking on the context menu of an item, such as
    a Google icon, the `ConfirmDialog` is initialized once more. The resulting output
    is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一种情况，即当我们点击`Items`页面上的上下文菜单时发生的情况。点击项目上下文菜单（例如Google图标）时，`ConfirmDialog`将再次初始化。结果输出如下：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `SetParametersAsync` method is called again, since the `Title` component
    parameter has been changed. In the subsequent calls, we can observe that the `Title`
    component parameter is set to `Google`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Title`组件参数已更改，因此再次调用了`SetParametersAsync`方法。在后续调用中，我们可以观察到`Title`组件参数被设置为`Google`。
- en: 'In our code, we use `OnParametersSet` to load the list of items in `Items.razor.cs`,
    as well as to load a list of fields in `ItemDetail.razor.cs`. Let’s examine `OnParametersSet`
    in `ItemDetail.razor.cs`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用`OnParametersSet`在`Items.razor.cs`中加载项目列表，以及在`ItemDetail.razor.cs`中加载字段列表。让我们检查`ItemDetail.razor.cs`中的`OnParametersSet`：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**(1)** In `OnParametersSet`, we check whether the `SelectedItemId` component
    parameter is `null`. This represents the `ID` of the selected item. **(2)** If
    it is not null, we can locate the item by calling the `IDataStore` method named
    `GetItem`. **(3)** Once we obtain the instance of the selected item, we can retrieve
    a list of fields by invoking the `GetFields` method.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 在`OnParametersSet`中，我们检查`SelectedItemId`组件参数是否为`null`。这代表所选项目的`ID`。**(2)**
    如果它不是`null`，我们可以通过调用名为`GetItem`的`IDataStore`方法来定位项目。**(3)** 一旦我们获得了所选项目的实例，我们可以通过调用`GetFields`方法来检索字段列表。'
- en: 'The implementation of `OnParametersSet` in `Items.razor.cs` is quite similar
    to this. For more details, you can refer to the following GitHub link: [https://epa.ms/Items10-6](https://epa.ms/Items10-6).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Items.razor.cs`中`OnParametersSet`的实现与此非常相似。有关更多详细信息，您可以参考以下GitHub链接：[https://epa.ms/Items10-6](https://epa.ms/Items10-6)。'
- en: Thus far, we have developed a near-complete password manager app, with its UI
    built using Blazor. We have established reusable modal dialog components to accommodate
    the context menu, enabling us to perform CRUD operations. The final component
    we need to address is the actual implementation of these CRUD operations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开发了一个几乎完整的密码管理器应用程序，其UI使用Blazor构建。我们已经建立了可重用的模态对话框组件来适应上下文菜单，使我们能够执行CRUD操作。我们需要解决的最后一个组件是实现这些CRUD操作的实际实现。
- en: Implementing CRUD operations
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CRUD操作
- en: After preparing the modal dialogs for CRUD operations, as discussed in the previous
    sections, we can now proceed to implement these CRUD operations in this section.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中讨论了为CRUD操作准备模态对话框之后，我们现在可以继续在本节中实现这些CRUD操作。
- en: CRUD operations of items
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目的CRUD操作
- en: 'To add or update an item, we can utilize the `UpdateItemAsync` method in `Items.razor.cs`
    to accommodate both scenarios. To distinguish between creating a new item and
    updating an existing one, we define a private `_isNewItem` field as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加或更新项目，我们可以利用`Items.razor.cs`中的`UpdateItemAsync`方法来适应这两种情况。为了区分创建新项目和更新现有项目，我们定义了一个私有`_isNewItem`字段，如下所示：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, we’ll see how to add or edit an item.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何添加或编辑项目。
- en: Adding a new item
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新项目
- en: 'To add a new item, simply click the `+` button located in the header of the
    `Items` page, as depicted in *Figure 10.8*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新项目，只需点击`Items`页面标题栏中的`+`按钮，如*图10.8*所示：
- en: '![Figure 9.7: Adding a new item](img/B21554_10_08.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7：添加新项目](img/B21554_10_08.png)'
- en: 'Figure 10.8: Adding a new item'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：添加新项目
- en: 'The Razor markup of this page header can be reviewed here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里查看此页眉的Razor标记：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The page header features the `Back` button **(1)**, the `Title` **(2)**, and
    the `Add` button **(3)**. The `Back` button is displayed only when there is an
    existing parent link.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 页眉部分包括`Back`按钮**（1**），`Title`**（2**）和`Add`按钮**（3**）。`Back`按钮仅在存在父链接时显示。
- en: Upon clicking the `Add` button, a modal dialog with an `Id` defined in the `_dialogEditId`
    variable will be displayed. The `onclick` event handler sets `_isNewItem` to true,
    allowing the modal dialog event handler to recognize that the action is intended
    to add a new item.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`Add`按钮后，将显示一个具有在`_dialogEditId`变量中定义的`Id`的模态对话框。`onclick`事件处理器将`_isNewItem`设置为`true`，使得模态对话框事件处理器能够识别该操作是添加新项目。
- en: Editing or deleting an item
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑或删除项目
- en: 'To edit or delete an item, click on the context menu found on the item, as
    demonstrated in *Figure 10.9*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑或删除一个项目，请点击项目上的上下文菜单，如*图10.9*所示：
- en: '![Figure 9.8: Editing or deleting an item](img/B21554_10_09.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8：编辑或删除项目](img/B21554_10_09.png)'
- en: 'Figure 10.9: Editing or deleting an item'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：编辑或删除项目
- en: 'Upon clicking the context menu button, a list of menu items will be displayed.
    Let’s examine the markup for the context menu found in `Items.razor`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 点击上下文菜单按钮后，将显示一个菜单项列表。让我们检查`Items.razor`中找到的上下文菜单的标记：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding markup code, a context menu button **(1)** is defined. Upon
    clicking this button, two menu items, `Edit` **(2)** and `Delete` **(3)**, will
    appear. As the context menu markup code runs within a `foreach` loop, we need
    to obtain a reference to the selected item for editing or deletion. In the C#
    code-behind logic, the `listGroupItem` variable is employed to reference the selected
    item.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的标记代码中，定义了一个上下文菜单按钮**（1**）。点击此按钮后，将显示两个菜单项，`Edit`**（2**）和`Delete`**（3**）。由于上下文菜单标记代码在`foreach`循环中运行，我们需要获取要编辑或删除的项目的引用。在C#代码后逻辑中，使用`listGroupItem`变量来引用所选项目。
- en: We can capture this reference through the `onclick` event handler of the context
    menu button.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过上下文菜单按钮的`onclick`事件处理器来捕获这个引用。
- en: Upon selecting the `Edit` menu item, it is crucial to set the `_isNewItem` variable
    to `false`. This adjustment allows the event handler of the modal dialog to discern
    that we are modifying an existing item.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择`Edit`菜单项时，将`_isNewItem`变量设置为`false`至关重要。这种调整使得模态对话框的事件处理器能够识别我们正在修改现有项目。
- en: 'Having completed all the previous setup, it’s time to examine the event handler
    in modal dialogs. First, let’s take a look at the `UpdateItemAsync` event handler
    within `Items.razor.cs`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有之前的设置后，现在是时候检查模态对话框中的事件处理器了。首先，让我们看看`Items.razor.cs`中的`UpdateItemAsync`事件处理器：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `UpdateItemAsync` event handler can manage both adding and editing an item.
    It checks the `_isNewItem` variable **(1)** to determine whether we aim to add
    or edit an item. Subsequently, it calls `IDataStore` methods to perform either
    addition or update actions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateItemAsync` 事件处理器可以管理添加和编辑项的操作。它检查 `_isNewItem` 变量 **(1)** 以确定我们是要添加还是编辑项。随后，它调用
    `IDataStore` 方法来执行添加或更新操作。'
- en: 'Now, let’s examine the event handler for deleting an item:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查删除项的事件处理器：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the `DeleteItemAsync` event handler, the item is simply removed from the
    list, and the `IDataStore` methods are called to execute the delete action.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DeleteItemAsync` 事件处理器中，项只是从列表中移除，并调用 `IDataStore` 方法来执行删除操作。
- en: CRUD operations of fields
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段的 CRUD 操作
- en: 'The CRUD operations for fields resemble those we implemented for items. To
    add or update a field, we can employ the `UpdateFieldAsync` method in `ItemDetail.razor.cs`
    to manage both scenarios. To determine whether we aim to create a new field or
    update an existing one, we define a private `_isNewField` field as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的 CRUD 操作与我们在项中实现的操作相似。要添加或更新字段，我们可以使用 `ItemDetail.razor.cs` 中的 `UpdateFieldAsync`
    方法来管理这两种情况。为了确定我们是要创建新字段还是更新现有字段，我们定义一个私有 `_isNewField` 字段如下：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The UI for CRUD operations also bears similarity to what we discussed in the
    previous section. To view the `Add` button and context menu items, please refer
    to *Figure 10.10*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 操作的 UI 与我们在上一节中讨论的内容相似。要查看 `添加` 按钮和上下文菜单项，请参阅 *图 10.10*。
- en: '![Figure 9.9: Add, edit, or delete a field](img/B21554_10_10.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9：添加、编辑或删除字段](img/B21554_10_10.png)'
- en: 'Figure 10.10: Add, edit, or delete a field'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：添加、编辑或删除字段
- en: 'We can examine the Razor markup code for the page header found in `ItemDetail.razor`
    as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式检查 `ItemDetail.razor` 中页面标题的 Razor 标记代码：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we can observe, the preceding source code is quite similar to the one found
    in `Items.razor`, with the exception of replacing the `_isNewItem` variable with
    `_isNewField`. We can consider refining this page header into a reusable component
    later on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，上述源代码与 `Items.razor` 中的源代码非常相似，只是将 `_isNewItem` 变量替换为 `_isNewField`。我们可以考虑稍后将其页面标题精炼成一个可重用的组件。
- en: 'Similar to the previous section, let’s now examine the source code for the
    list group and context menu:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节类似，现在让我们检查列表组和上下文菜单的源代码：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding source code of `ItemDetail.razor` features a context **Menu**
    button **(1)** and three buttons for the **Add** **(2)**, **Edit** **(3)**, and
    **Show** **(4)** menu items. You may have noticed that the source code is quite
    similar to that in `Items.razor`, encompassing a list group and a context menu.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `ItemDetail.razor` 的源代码具有一个上下文 **菜单** 按钮 **(1)** 和用于 **添加** **(2)**、**编辑**
    **(3)** 和 **显示** **(4)** 菜单项的三个按钮。你可能已经注意到，源代码与 `Items.razor` 中的源代码相当相似，包括一个列表组和上下文菜单。
- en: We will further develop this into a reusable component later in this chapter.
    The variation in the context menu lies in the addition of a menu item that displays
    or conceals a field, if it is a protected field such as a password. We utilize
    the `onclick` event handler, `OnToggleShowPassword`, to set the `IsHide` field
    property, thereby toggling the visibility of the password field.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面进一步将其开发成一个可重用的组件。上下文菜单的变化在于添加了一个显示或隐藏字段的菜单项，如果它是像密码这样的受保护字段。我们利用 `onclick`
    事件处理器 `OnToggleShowPassword` 来设置 `IsHide` 字段属性，从而切换密码字段的可见性。
- en: 'Finally, let’s examine the event handlers for modal dialogs in `ItemDetail.razor.cs`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来检查 `ItemDetail.razor.cs` 中模态对话框的事件处理器：
- en: '[PRE48]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `UpdateFieldAsync` event handler manages both the addition and editing of
    a field. It receives two parameters – `key` and `value` – which are passed from
    the modal dialog and are used to set the field of `listGroupField`. By examining
    the `_isNewField` variable, the handler determines whether the intent is to add
    or edit a field. Subsequently, it calls `IDataStore` methods to execute the add
    or update actions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateFieldAsync` 事件处理器管理字段的添加和编辑。它接收两个参数 – `key` 和 `value` – 这些参数从模态对话框传递过来，并用于设置
    `listGroupField` 的字段。通过检查 `_isNewField` 变量，处理器确定意图是添加还是编辑字段。随后，它调用 `IDataStore`
    方法来执行添加或更新操作。'
- en: 'To remove a field, the `DeleteFieldAsync` event handler below is triggered:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除字段，下面的 `DeleteFieldAsync` 事件处理器被触发：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the `DeleteFieldAsync` event handler, we simply remove the field from the
    selected item and invoke the `IDataStore` method to update the database.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DeleteFieldAsync` 事件处理器中，我们只需从所选项中删除字段，并调用 `IDataStore` 方法来更新数据库。
- en: Having implemented CRUD operations, we have now successfully completed the implementation
    of password manager features. We have developed a new version of the password
    manager app utilizing Blazor UI. The distinction between this version and the
    one described in *Part 1* of this book lies in our use of Blazor to construct
    all user interfaces. The appearance and functionality of the Blazor UI closely
    resemble web apps, while the XAML UI maintains the characteristics of native apps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了CRUD操作后，我们现在已经成功完成了密码管理器功能的实现。我们利用Blazor UI开发了一个新的密码管理器应用程序。与本书*第1部分*中描述的版本相比，本版本的差异在于我们使用Blazor构建所有用户界面。Blazor
    UI的外观和功能与Web应用程序相似，而XAML UI则保留了原生应用程序的特性。
- en: Although we have successfully implemented all the required functionalities,
    we can observe some duplicated code in our current implementation. To resolve
    this issue, we can refactor our code, transforming the duplicate sections into
    Razor components.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经成功实现了所有必需的功能，但我们可以在当前实现中观察到一些重复的代码。为了解决这个问题，我们可以重构我们的代码，将重复的部分转换为Razor组件。
- en: Refactoring Razor components
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构Razor组件
- en: In the current implementation, we can observe that most of the duplicated code
    is found in the `Items` and `ItemDetail` pages. Throughout the remainder of this
    chapter, we will transform this duplicated code into Razor components.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实现中，我们可以观察到大部分重复的代码都出现在`Items`和`ItemDetail`页面中。在本章的剩余部分，我们将将这些重复的代码转换为Razor组件。
- en: 'We will create the following components:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下组件：
- en: '`Navbar`: This component displays a navigation bar.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Navbar`：此组件显示导航栏。'
- en: '`Dropdown`: This component supports a context menu.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dropdown`：此组件支持上下文菜单。'
- en: '`ListView`: This component displays a list of items.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`：此组件显示项目列表。'
- en: The `ListView` component is the most complex one, so we will address it at the
    end of this section. For now, let’s focus on the `Navbar` and `Dropdown` components
    first.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`组件是最复杂的，所以我们将在本节末尾处理它。现在，让我们首先关注`Navbar`和`Dropdown`组件。'
- en: Creating the Navbar component
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Navbar组件
- en: 'Let’s examine the navigation bar UI in *Figure 10.11*. We can observe that
    the navigation bar features a **Back** button, a **Title**, and an **Add** button:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查*图10.11*中的导航栏UI。我们可以观察到导航栏具有一个**Back**按钮、一个**Title**和一个**Add**按钮：
- en: '![Figure 10.1: Navigation bar](img/B21554_10_11.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：导航栏](img/B21554_10_11.png)'
- en: 'Figure 10.11: Navigation bar'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：导航栏
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, **(1)** the `Back` button is displayed when a parent
    link is present. **(2)** The `Back` button is implemented using an `<a>` tag.
    **(3)** The `Title`, as a string, appears within the `<h1>` tag. **(4)** The `Add`
    button is implemented using a `<button>` tag. The styling of both the `Back` and
    `Add` buttons employs Bootstrap formatting.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，**(1)** 当存在父级链接时，会显示`Back`按钮。**(2)** `Back`按钮是通过一个`<a>`标签实现的。**(3)**
    `Title`作为一个字符串，出现在`<h1>`标签内。**(4)** `Add`按钮是通过一个`<button>`标签实现的。`Back`和`Add`按钮的样式都采用了Bootstrap格式化。
- en: 'To transform the preceding code into a Razor component, we can generate a new
    Razor component in the `PassXYZ.BlazorUI` project and name it `Navbar`. The `Navbar`
    component will display the UI elements illustrated in *Figure 10.11*, including
    a `Back` button, a title, and an `Add` button. In order to separate the UI and
    logic, we will create both a `Navbar.razor.cs` C# code-behind file and the Razor
    markup, `Navbar.razor`. We will define component parameters and event handlers
    in the C# code-behind file, as demonstrated in *Listing 10.6*:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将前面的代码转换为Razor组件，我们可以在`PassXYZ.BlazorUI`项目中生成一个新的Razor组件，并将其命名为`Navbar`。`Navbar`组件将显示*图10.11*中所示的用户界面元素，包括一个`Back`按钮、一个标题和一个`Add`按钮。为了分离UI和逻辑，我们将创建一个`Navbar.razor.cs`
    C#代码后文件和一个Razor标记文件，`Navbar.razor`。我们将在C#代码后文件中定义组件参数和事件处理器，如*列表10.6*所示：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 10.6: `Navbar.razor.cs` ([https://epa.ms/Navbar10-7](https://epa.ms/Navbar10-7))'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6：`Navbar.razor.cs` ([https://epa.ms/Navbar10-7](https://epa.ms/Navbar10-7))
- en: In `Navbar`, there are four component parameters and an event handler defined.
    We can assign the parent link for the `Back` button using the `ParentLink` parameter
    **(1)**. The value of `Title` is set according to the `Title` parameter **(3)**.
    For the `Add` button, it is necessary to provide an `Id` and an event handler
    for the dialog box; hence, the `DialogId` **(2)** and `OnAddClick` **(4)** parameters
    are utilized.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Navbar`中，定义了四个组件参数和一个事件处理器。我们可以使用`ParentLink`参数 **(1)** 为`Back`按钮分配父链接。`Title`的值根据`Title`参数
    **(3)** 设置。对于`Add`按钮，需要提供一个`Id`和对话框的事件处理器；因此，使用了`DialogId` **(2)** 和`OnAddClick`
    **(4)** 参数。
- en: 'Now, let us examine the Razor file of `Navbar`, presented in *Listing 10.7*:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查`Navbar`的Razor文件，它展示在*Listing 10.7*中：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 10.7: `Navbar.razor` ([https://epa.ms/Navbar10-8](https://epa.ms/Navbar10-8))'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '列表10.7: `Navbar.razor` ([https://epa.ms/Navbar10-8](https://epa.ms/Navbar10-8))'
- en: 'We can observe that the code closely resembles the code used in `Items` and
    `ItemDetail`. The key difference is that we have substituted hardcoded values
    with component parameters (`ParentLink` **(1)**, `DialogId` **(2)**, `Title` **(3)**,
    and `OnClickClose` **(4)**). With the integration of this new `Navbar` component,
    we can modify the code in `Items` by employing the `Navbar` component, as demonstrated
    below:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到代码与`Items`和`ItemDetail`中使用的代码非常相似。关键的区别在于，我们将硬编码的值替换为组件参数（`ParentLink`
    **(1)**，`DialogId` **(2)**，`Title` **(3)**，和`OnClickClose` **(4)**）。通过整合这个新的`Navbar`组件，我们可以通过使用`Navbar`组件来修改`Items`中的代码，如下所示：
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then proceed to replace the code in `ItemDetail` as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式替换`ItemDetail`中的代码：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As observed, we have streamlined the code by eliminating duplications, resulting
    in a more elegant and concise presentation.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如观察到的，我们通过消除重复来简化了代码，从而实现了更优雅和简洁的展示。
- en: Having completed the work for the `Navbar`, let us now shift our focus to the
    `Dropdown` component.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了`Navbar`的工作后，我们现在将注意力转向`Dropdown`组件。
- en: Creating a Dropdown component for the context menu
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建上下文菜单的Dropdown组件
- en: To develop a component akin to the context menu, we can reuse the Bootstrap
    `Dropdown` component. As illustrated in *Figure 10.12*, a context menu comprises
    a context menu button and a list of menu items. Upon clicking the context menu
    button, users are presented with a display of menu items.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发一个类似于上下文菜单的组件，我们可以重用Bootstrap的`Dropdown`组件。如图10.12所示，上下文菜单包括一个上下文菜单按钮和一系列菜单项。点击上下文菜单按钮后，用户将看到菜单项的显示。
- en: '![Figure 10.2: Context menu](img/B21554_10_12.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2: 上下文菜单](img/B21554_10_12.png)'
- en: 'Figure 10.12: Context menu'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '图10.12: 上下文菜单'
- en: 'The present code for the context menu is replicated in both the `Items` and
    `ItemDetail` pages, as demonstrated below:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当前上下文菜单的代码在`Items`和`ItemDetail`页面中都有复制，如下所示：
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `Dropdown` component of Bootstrap comprises a button and an unordered list.
    We must define an event handler for the button to perform the necessary action.
    In the previous code, we set the `item` variable to `listGroupItem`. Regarding
    the menu items, each is implemented as a `<button>` tag and accepts a dialog ID
    and an event handler as parameters. When a menu item is clicked, the corresponding
    modal dialog will be displayed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的`Dropdown`组件包括一个按钮和无序列表。我们必须为按钮定义一个事件处理器以执行必要的操作。在前面的代码中，我们将`item`变量设置为`listGroupItem`。关于菜单项，每个都实现为一个`<button>`标签，并接受一个对话框ID和事件处理器作为参数。当点击菜单项时，将显示相应的模态对话框。
- en: We can create two new Razor components in the `PassXYZ.BlazorUI` project, named
    `Dropdown` and `MenuItem`. To separate the UI and logic, we can implement them
    in the C# code-behind file (*Listing 10.9*) and the Razor file (*Listing 10.8*),
    which we will demonstrate now.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`PassXYZ.BlazorUI`项目中创建两个新的Razor组件，分别命名为`Dropdown`和`MenuItem`。为了分离UI和逻辑，我们可以在C#代码后文件（*Listing
    10.9*）和Razor文件（*Listing 10.8*）中实现它们，我们现在将演示这些。
- en: 'Let’s first examine the `Dropdown` component UI in Listing 10.8:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查列表10.8中的`Dropdown`组件UI：
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 10.8: `Dropdown.razor` ([https://epa.ms/Dropdown10-9](https://epa.ms/Dropdown10-9))'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '列表10.8: `Dropdown.razor` ([https://epa.ms/Dropdown10-9](https://epa.ms/Dropdown10-9))'
- en: 'In the `Dropdown` component, we define a button **(1)** and an unordered list
    **(2)**. The button’s click event is set up as an `OnClick` event handler. The
    items within the unordered list appear as child content of the `Dropdown` component.
    The component parameters can be found in the C# `Dropdown.razor.cs` code-behind
    file, as shown in *Listing 10.9*:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Dropdown` 组件中，我们定义了一个按钮 **(1)** 和一个无序列表 **(2)**。按钮的点击事件被设置为 `OnClick` 事件处理器。无序列表中的项作为
    `Dropdown` 组件的子内容出现。组件参数可以在 C# 的 `Dropdown.razor.cs` 代码隐藏文件中找到，如 *列表 10.9* 所示：
- en: '[PRE58]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 10.9: `Dropdown.razor.cs` ([https://epa.ms/Dropdown10-10](https://epa.ms/Dropdown10-10))'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10.9: `Dropdown.razor.cs` ([https://epa.ms/Dropdown10-10](https://epa.ms/Dropdown10-10))'
- en: 'In `Dropdown.razor.cs`, two component parameters `OnClick` **(1)** and `ChildContent`
    **(2)** are defined. The `MenuItem` component can be presented as the child content
    of the `Dropdown` component. The UI code for `MenuItem` can be observed in *Listing
    10.10*:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Dropdown.razor.cs` 中，定义了两个组件参数 `OnClick` **(1)** 和 `ChildContent` **(2)**。`MenuItem`
    组件可以作为 `Dropdown` 组件的子内容。`MenuItem` 的 UI 代码可以在 *列表 10.10* 中查看：
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 10.10: `MenuItem.razor` ([https://epa.ms/MenuItem10-11](https://epa.ms/MenuItem10-11))'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10.10: `MenuItem.razor` ([https://epa.ms/MenuItem10-11](https://epa.ms/MenuItem10-11))'
- en: 'The `MenuItem` component specifies three component parameters: `Id`, `OnClick`,
    and `ChildContent`. These parameters are defined within `MenuItem.razor.cs`, as
    demonstrated in *Listing 10.11*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuItem` 组件指定了三个组件参数：`Id`、`OnClick` 和 `ChildContent`。这些参数在 `MenuItem.razor.cs`
    中定义，如 *列表 10.11* 所示：'
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 10.11: `MenuItem.razor.cs` ([https://epa.ms/MenuItem10-12](https://epa.ms/MenuItem10-12))'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10.11: `MenuItem.razor.cs` ([https://epa.ms/MenuItem10-12](https://epa.ms/MenuItem10-12))'
- en: '**(1)** The `Id` parameter is employed to designate the dialog ID when a menu
    item is clicked. **(2)** `OnClick` is utilized to register an event handler for
    a button click event. **(3)** `ChildContent` serves to display child content,
    such as the name of the menu item.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** `Id` 参数用于指定当菜单项被点击时的对话框 ID。**(2)** `OnClick` 用于为按钮点击事件注册事件处理器。**(3)**
    `ChildContent` 用于显示子内容，例如菜单项的名称。'
- en: 'We have successfully implemented the components for the context menu. Now,
    we can replace the redundant code in the `Items` and `ItemDetail` pages with these
    context menu components. The implementation of the context menu on the `Items`
    page proceeds as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功实现了上下文菜单的组件。现在，我们可以用这些上下文菜单组件替换 `Items` 和 `ItemDetail` 页面中的冗余代码。在 `Items`
    页面上实现上下文菜单的步骤如下：
- en: '[PRE61]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On the `ItemDetail` page, the context menu is implemented as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ItemDetail` 页面上，上下文菜单的实现方式如下：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Following the refinement of the code for the `Items` and `ItemDetail` pages,
    we have implemented modal dialogs, navigation bars, and context menu components.
    Consequently, the code appears significantly more elegant and concise. Nevertheless,
    there is still potential for further refinement. The main UI logic in both the
    `Items` and `ItemDetail` pages revolves around a list view. We can optimize this
    part of the code by implementing a `ListView` component. In order to create a
    `ListView` component, we will need to utilize an advanced feature known as templated
    components.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `Items` 和 `ItemDetail` 页面的代码进行精炼后，我们实现了模态对话框、导航栏和上下文菜单组件。因此，代码看起来更加优雅和简洁。尽管如此，仍有进一步优化的空间。在
    `Items` 和 `ItemDetail` 页面中，主要的 UI 逻辑都围绕列表视图展开。我们可以通过实现 `ListView` 组件来优化这部分代码。为了创建
    `ListView` 组件，我们需要利用一个称为模板组件的高级功能。
- en: Using templated components
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板组件
- en: 'In constructing a Razor component, component parameters serve as the communication
    channels between parent and child components. While discussing nested components,
    we brought attention to a special `ChildContent` component parameter of the `RenderFragment`
    type. This parameter enables the parent component to set the content of the child
    component. For instance, the content of `MenuItem` in the following code can be
    assigned an HTML string:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Razor 组件时，组件参数是父组件和子组件之间的通信渠道。在讨论嵌套组件时，我们提到了一个特殊的 `ChildContent` 组件参数，其类型为
    `RenderFragment`。该参数允许父组件设置子组件的内容。例如，以下代码中 `MenuItem` 的内容可以分配一个 HTML 字符串：
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We are able to achieve this as `MenuItem` defines the following component parameter,
    which can be observed in *Listing 10.11*:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `MenuItem` 定义的以下组件参数来实现这一点，如 *列表 10.11* 所示：
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we want to explicitly specify the `ChildContent` parameter, we can achieve
    this as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想显式指定 `ChildContent` 参数，可以按照以下方式实现：
- en: '[PRE65]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`ChildContent` is a unique component parameter that can be implicitly used
    in markup language. To utilize `ChildContent`, we create a component capable of
    accepting a UI template of the `RenderFragment` type as its parameter. Furthermore,
    we can define multiple UI templates as parameters when developing a new component.
    Components of this nature are referred to as templated components.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildContent`是一个独特的组件参数，可以在标记语言中隐式使用。要使用`ChildContent`，我们需要创建一个能够接受`RenderFragment`类型UI模板作为其参数的组件。此外，我们可以在开发新组件时定义多个UI模板作为参数。这种类型的组件被称为模板组件。'
- en: A render fragment, of the `RenderFragment` type, signifies a portion of the
    UI designated for rendering. Furthermore, there is a generic version, `RenderFragment<TValue>`,
    which accepts a type parameter. A specific type can be provided when invoking
    `RenderFragment`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`RenderFragment`类型的渲染片段表示为渲染而指定的UI的一部分。此外，还有一个泛型版本，`RenderFragment<TValue>`，它接受一个类型参数。在调用`RenderFragment`时可以提供一个特定类型。
- en: Creating a ListView component
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建ListView组件
- en: 'To create a `ListView`, we need to utilize multiple UI templates as component
    parameters. We can create a new Razor component within the `PassXYZ.BlazorUI`
    project and name it `ListView`. Similar to what we did for `Navbar` and the context
    menu, we can separate the UI and code into a Razor file (*Listing 10.12*) and
    a C# code-behind file (*Listing 10.13*):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`ListView`，我们需要使用多个UI模板作为组件参数。我们可以在`PassXYZ.BlazorUI`项目中创建一个新的Razor组件，并将其命名为`ListView`。类似于我们对`Navbar`和上下文菜单所做的那样，我们可以将UI和代码分离到Razor文件(*列表10.12*)和C#代码后文件(*列表10.13*)中：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 10.12: `ListView.razor` ([https://epa.ms/ListView10-13](https://epa.ms/ListView10-13))'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '列表10.12: `ListView.razor` ([https://epa.ms/ListView10-13](https://epa.ms/ListView10-13))'
- en: 'In the `ListView` Razor file, we define three UI templates, `Header` **(1)**,
    `Row` **(2)**, and `Footer` **(3)**. We render the `Header` and `Footer` similarly
    to `ChildContent`, but the `Row` component parameter appears distinct. The rendering
    process for the `Row` component is as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ListView`Razor文件中，我们定义了三个UI模板，`Header` **(1)**、`Row` **(2)** 和 `Footer` **(3)**。我们像`ChildContent`一样渲染`Header`和`Footer`，但`Row`组件参数看起来是不同的。`Row`组件的渲染过程如下：
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Alternatively, we can render it like this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样渲染：
- en: '[PRE68]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We render it with an `item` argument. The type of `Row` is `RenderFragment<TValue>`,
    as we demonstrate in *Listing 10.13*:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`item`参数来渲染它。`Row`的类型是`RenderFragment<TValue>`，正如我们在*列表10.13*中展示的那样：
- en: '[PRE69]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 10.13: `ListView.razor.cs` ([https://epa.ms/ListView10-14](https://epa.ms/ListView10-14))'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '列表10.13: `ListView.razor.cs` ([https://epa.ms/ListView10-14](https://epa.ms/ListView10-14))'
- en: We define the `ListView` as a generic `ListView<TItem>` type with the `TItem`
    type parameter. In the `ListView` component, we can specify a list view header,
    using the `Header` **(1)** parameter, and a footer, using the `Footer` **(4)**
    parameter. The `ListView` can be bound to any data collection of the `IEnumerable<TItem>`
    type via the `Items` parameter **(3)**. The `Row` **(2)** parameter can be employed
    to establish the UI template for an individual item within the `foreach` loop.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ListView`定义为具有`TItem`类型参数的泛型`ListView<TItem>`类型。在`ListView`组件中，我们可以使用`Header`
    **(1)** 参数指定列表视图的标题，使用`Footer` **(4)** 参数指定页脚。`ListView`可以通过`Items`参数 **(3)**
    绑定到任何`IEnumerable<TItem>`类型的数据集合。`Row` **(2)** 参数可以用来为`foreach`循环中的单个项目建立UI模板。
- en: Using the ListView component
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ListView组件
- en: 'At this point, let’s examine the usage of the `ListView` component in the `Items`
    and `ItemDetail` pages. We will use the `ItemDetail` page as an example for our
    discussion:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我们来检查`Items`和`ItemDetail`页面中`ListView`组件的使用情况。我们将以`ItemDetail`页面作为我们讨论的例子：
- en: '[PRE70]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we have defined `Header`, `Row`, and `Footer` as optional parameters, there
    is no obligation to specify all of them. In the `ItemDetail` page, we utilize
    `Row` and `Footer`. **(1)** First, we need to pass the list of fields to the `Items`
    parameter. **(2)** In the `foreach` loop, each field is passed to the `ListView`
    as an argument for the `Row`, which is defined as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将`Header`、`Row`和`Footer`定义为可选参数，因此没有必要指定所有这些参数。在`ItemDetail`页面中，我们使用`Row`和`Footer`。**(1)**
    首先，我们需要将字段列表传递给`Items`参数。**(2)** 在`foreach`循环中，每个字段都被传递给`ListView`作为`Row`的参数，`Row`的定义如下：
- en: '[PRE71]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `"field"` value of the `Context` property is employed to specify the argument
    for `Row`. Within the UI template of `Row`, we showcase the key value of `field`
    and establish a context menu using the `Dropdown` and `MenuItem` components, which
    were implemented in the previous section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`属性的`"field"`值被用来指定`Row`的参数。在`Row`的UI模板中，我们展示了`field`的关键值，并使用`Dropdown`和`MenuItem`组件创建了一个上下文菜单，这些组件在上一节中已实现。'
- en: By utilizing the `ListView` component, we have significantly enhanced the implementation
    of the `ItemDetail` page. This improvement was achieved through the creation of
    our own Razor components.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ListView`组件，我们显著提升了`ItemDetail`页面的实现。这一改进是通过创建我们自己的Razor组件来实现的。
- en: Having completed the refactoring of our code, we have concluded the introduction
    of the `.NET MAUI Blazor Hybrid` app. In Part 2, we recreated our app using Blazor
    while maintaining the same functionalities.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 完成代码重构后，我们完成了`.NET MAUI Blazor Hybrid`应用的引入。在第二部分中，我们使用Blazor重新创建了我们的应用，同时保持了相同的功能。
- en: If you have experience in Blazor web app development, you may not see too much
    difference between the Blazor Hybrid app and the Blazor web app. This is precisely
    the advantage of the Blazor Hybrid app. You may now be wondering, how do we access
    a native API in a Blazor Hybrid app? Let’s have a brief overview in the next section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过Blazor Web应用开发的经验，你可能不会在Blazor Hybrid应用和Blazor Web应用之间看到太大的差异。这正是Blazor
    Hybrid应用的优点。你现在可能想知道，我们如何在Blazor Hybrid应用中访问原生API？让我们在下一节中简要概述。
- en: Accessing a native API from Blazor Hybrid apps
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Blazor Hybrid应用访问原生API
- en: When it comes to accessing native APIs, there isn’t a significant difference
    between .NET MAUI apps and Blazor Hybrid apps. As we learned in *Chapter 7*, *Using
    Platform-Specific Features*, it’s vital to always create an abstract layer that
    encapsulates native access at the platform layer. Hence, we’re not directly accessing
    native APIs from cross-platform code in .NET MAUI or Blazor Hybrid apps. In our
    app, while we do need to access native APIs, we will access a native API through
    an abstract layer.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到访问原生API时，.NET MAUI应用和Blazor Hybrid应用之间没有显著差异。正如我们在*第7章*中学习的*使用平台特定功能*，始终创建一个封装平台层原生访问的抽象层是至关重要的。因此，我们在.NET
    MAUI或Blazor Hybrid应用中不会直接从跨平台代码中访问原生API。在我们的应用中，虽然我们需要访问原生API，但我们将通过一个抽象层来访问原生API。
- en: Access to platform APIs from .NET has seen significant evolution over time,
    transitioning from Xamarin plugins to the unified NuGet dependency presented by
    Xamarin.Essentials. As discussed in *Chapter 7*, *Using Platform-Specific Features*,
    Xamarin.Essentials aimed to standardize all native access within a single library.
    Initially, the plan with .NET MAUI was to migrate everything as .NET MAUI Essentials.
    However, the .NET MAUI team later realized that breaking it down into more logically
    granular namespaces, such as `Microsoft.Maui.Storage` or `Microsoft.Maui.Devices`,
    and so on, made more sense.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET访问平台API随着时间的推移经历了显著的发展，从Xamarin插件过渡到Xamarin.Essentials提供的统一NuGet依赖项。正如*第7章*中讨论的*使用平台特定功能*，Xamarin.Essentials旨在将所有原生访问标准化到一个库中。最初，.NET
    MAUI的计划是将所有内容迁移到.NET MAUI Essentials。然而，.NET MAUI团队后来意识到，将它们分解成更逻辑上细粒度的命名空间，如`Microsoft.Maui.Storage`或`Microsoft.Maui.Devices`等，更有意义。
- en: 'In our app, we access platform-level APIs in the classes defined in the `Services`
    folder, such as `LoginService.cs`. For example, we defined a property, `IsPrivacyNoticeAccepted`,
    in `LoginService` to store whether the user has accepted the privacy notice or
    not. We use a `Preferences` API to store the data in platform-specific persistent
    storage. `Preferences` APIs are defined in the `Microsoft.Maui.Storage` namespace,
    as we can see from the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们通过`Services`文件夹中定义的类访问平台级别的API，例如`LoginService.cs`。例如，我们在`LoginService`中定义了一个属性`IsPrivacyNoticeAccepted`，用来存储用户是否接受了隐私通知。我们使用`Preferences`
    API将数据存储在平台特定的持久存储中。`Preferences` API定义在`Microsoft.Maui.Storage`命名空间中，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: APIs such as `Preferences` are provided by Microsoft as part of .NET MAUI libraries.
    If we find something that is not supported by Microsoft APIs, we have to create
    our own plugins or use plugins provided by the community. Please refer to *Chapter
    7* about how to create and use .NET MAUI plugins.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Preferences`等API由Microsoft作为.NET MAUI库的一部分提供。如果我们发现某些内容不支持Microsoft API，我们必须创建自己的插件或使用社区提供的插件。请参阅*第7章*了解如何创建和使用.NET
    MAUI插件。'
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained the process of creating Razor components. We covered
    topics such as data binding and the component lifecycle. Subsequently, we developed
    a set of modal dialog components to optimize our code. By utilizing Razor components,
    we can eliminate duplicate code and enhance the UI design. We incorporated CRUD
    operations within the event handlers of modal dialogs. As a result, we now have
    a new version of the password manager app.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了创建Razor组件的过程。我们涵盖了数据绑定和组件生命周期等主题。随后，我们开发了一套模态对话框组件以优化我们的代码。通过利用Razor组件，我们可以消除重复代码并增强UI设计。我们在模态对话框的事件处理程序中集成了CRUD操作。因此，我们现在有了密码管理器应用的新版本。
- en: In the subsequent chapter, we will transition to *Part 3* of this book. In *Part
    3*, we will introduce the implementation of unit tests and the process of publishing
    a .NET MAUI application to app stores.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将过渡到本书的*第三部分*。在*第三部分*中，我们将介绍单元测试的实现以及将.NET MAUI应用程序发布到应用商店的过程。
- en: Leave a review!
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: '*Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 40% discount code.*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*喜欢这本书吗？帮助像你这样的读者留下亚马逊评论。扫描下面的二维码获取40%的折扣码。*'
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠*'
