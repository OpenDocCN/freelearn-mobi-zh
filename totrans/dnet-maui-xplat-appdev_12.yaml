- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Razor Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored Blazor routing and layout and, subsequently,
    built a navigation framework by establishing our app’s routing and layout. Upon
    setting up the navigation framework, we crafted top-level pages. The implementation
    of Razor pages allows for password database navigation, akin to the XAML version.
    While Razor pages are indeed Razor components, they are not reusable. In this
    chapter, we will introduce the creation of reusable Razor components. Furthermore,
    we will delve into data binding and the Razor component lifecycle to foster a
    comprehensive understanding of these aspects. Armed with this knowledge, we will
    optimize our code by converting duplicate code into reusable Razor components.
    Ultimately, we will use the Razor components to implement CRUD operations within
    our app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Razor class library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable Razor components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Razor component lifecycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring Razor components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using templated components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter10](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/d5302ca26a3c362a291785a9771d87ad8552bdb2).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, you can use the below command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code* section in this book, in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor components
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we developed and utilized Razor components in the previous two chapters,
    we have not yet delved deeply into them. In this section, we will continue refining
    the app from the last chapter while exploring Razor components more thoroughly,
    thereby gaining a better understanding of key concepts surrounding these components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor apps are constructed using Razor components. The first Razor component
    in our app is `Main`, and it is defined in `Main.razor`, as illustrated below:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Router` component, which is installed within the `Main` component, takes
    care of routing pages and selecting the default layout component. All other Razor
    pages are managed by the `Router` components. These Razor pages, loaded by the
    `Router`, have route templates defined and serve to display the user interface.
    In our project, Razor pages can be found in the `Pages` folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the startup sequence of the Blazor Hybrid app, we can refer to
    *Figure 10.1* below:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_10_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Startup of the Blazor Hybrid app'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: As a .NET MAUI application, the starting point of the Blazor Hybrid app is also
    the `MauiProgram` class **(1)**. Within the `MauiProgram` class, an instance of
    the `App` class **(2)** is constructed. The first XAML page to be loaded into
    this is the `MainPage` **(3)** class. This `MainPage` includes an instance of
    `BlazorWebView` **(4)** that hosts the Blazor pages. For further information on
    how the Razor component `Main` is loaded into `BlazorWebView`, please refer to
    *Chapter 8**, Introducing Blazor Hybrid App Development*. Once the `Main` component
    is loaded into `BlazorWebView`, it exhibits the root of the navigation stack.
    In this particular scenario, the root page of the navigation stack is the `Login`
    page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there are reusable Razor components that act as the building blocks
    of Razor pages. These Razor components are stored in the `Shared` folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, each file possessing a `.razor` file extension represents a Razor
    component, which is compiled into a C# class upon execution. The filename serves
    as the class name, while the folder name contributes to the namespace. For instance,
    the `Login` Razor component resides in the `Pages` folder, so the folder name
    `Pages` is included as part of the namespace. Thus, the complete name of the `Login`
    class is `PassXYZ.Vault.Pages.Login`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Razor components can be written either in a single file or divided into a Razor
    file (`.razor`) and a code-behind C# file (`.cs`). The code-behind C# file defines
    a partial class containing all the programming logic. This approach was employed
    when we created the `Login` component in *Chapter 8**, Introducing Blazor Hybrid
    App Development*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Razor component naming convention](img/B21554_10_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Razor component naming convention'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 10.2*, when creating the `Login` component, we incorporated
    the Bootstrap CSS style for styling purposes. Razor components offer CSS isolation,
    which simplifies CSS usage and prevents collisions with other components or libraries.
    Moreover, Razor components can include their own CSS style in a `.razor.css` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a Razor component is a C# class, it encompasses all features inherent to
    a C# class. Consequently, a Razor component can serve as a child class of another
    Razor component. In *Chapter 9**, Understanding Blazor Layout and Routing*, we
    observed that all layout components are derived classes of `LayoutComponentBase`
    when creating layout components. As illustrated in the `MainLayout.razor` code
    below, we employ the `@inherits` directive to specify the `LayoutComponentBase`
    as the base class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every Razor component is derived from the `ComponentBase` class. As a result,
    it is feasible to create a Razor component derived from the `ComponentBase` class
    using a C# file, without requiring a Razor markup file. For instance, we can create
    an `AppName` Razor component within a C# class, demonstrated as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`AppName` is a Razor component that is designed without a Razor markup file
    (`.razor`); however, it functions identically to other Razor components, as demonstrated
    here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppName` 是一个没有 Razor 标记文件（`.razor`）设计的 Razor 组件；然而，它与其他 Razor 组件的功能相同，如下所示：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above example is used to demonstrate how to create a Razor component in
    C# code. However, it’s generally recommended to create UI components utilizing
    Razor markup instead of C# code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例用于演示如何在 C# 代码中创建 Razor 组件。然而，通常建议使用 Razor 标记而不是 C# 代码来创建 UI 组件。
- en: In this section, we introduced Razor components. We can place reusable Razor
    components in a shared folder to ensure that they are accessible throughout the
    project. Additionally, a Razor class library can be created to share Razor components
    across multiple projects. In the subsequent section, we will delve into the process
    of packaging these Razor components into a library.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Razor 组件。我们可以将可重用的 Razor 组件放在共享文件夹中，以确保它们在整个项目中可访问。此外，可以创建一个 Razor
    类库来在多个项目中共享 Razor 组件。在下一节中，我们将深入了解将这些 Razor 组件打包成库的过程。
- en: Creating a Razor class library
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Razor 类库
- en: In our project, we create reusable components and store them in the `Shared`
    folder. These components can be utilized by other components, such as layout components
    or `NavMenu`. Additionally, we can encapsulate Razor components within the Razor
    class library, making them accessible for use across various projects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们创建可重用组件并将它们存储在 `Shared` 文件夹中。这些组件可以被其他组件使用，例如布局组件或 `NavMenu`。此外，我们可以在
    Razor 类库中封装 Razor 组件，使它们可以在各种项目中使用。
- en: The components in the Razor class library are not specific to a single project,
    making them suitable for use in any Blazor project, whether it be Blazor Hybrid,
    Blazor WebAssembly, or Blazor Server apps.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 类库中的组件不特定于单个项目，这使得它们适用于任何 Blazor 项目，无论是 Blazor 混合应用、Blazor WebAssembly
    还是 Blazor 服务器应用。
- en: 'In this book, we construct Razor components utilizing Bootstrap. Numerous open-source
    Razor class libraries built on top of Bootstrap can be found on GitHub. Several
    of these libraries are sufficiently robust for commercial product development.
    Below are a few examples:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用 Bootstrap 构建了 Razor 组件。你可以在 GitHub 上找到许多基于 Bootstrap 构建的开放源码 Razor
    类库。其中一些库足够健壮，适用于商业产品开发。以下是一些示例：
- en: '`BootstrapBlazor`: [https://github.com/dotnetcore/BootstrapBlazor](https://github.com/dotnetcore/BootstrapBlazor)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BootstrapBlazor`：[https://github.com/dotnetcore/BootstrapBlazor](https://github.com/dotnetcore/BootstrapBlazor)'
- en: '`Blazorise`: [https://github.com/Megabit/Blazorise](https://github.com/Megabit/Blazorise)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blazorise`：[https://github.com/Megabit/Blazorise](https://github.com/Megabit/Blazorise)'
- en: '`Havit.Blazor`: [https://github.com/havit/Havit.Blazor/](https://github.com/havit/Havit.Blazor/)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Havit.Blazor`：[https://github.com/havit/Havit.Blazor/](https://github.com/havit/Havit.Blazor/)'
- en: 'These open-source projects are constructed as Razor class libraries, enabling
    their reuse in a manner analogous to other .NET libraries. Razor class libraries
    can be published as `NuGet` packages, allowing for seamless integration into our
    Blazor projects. For example, the `BootstrapBlazor` library can be found at this
    link: [https://www.nuget.org/packages/BootstrapBlazor/](https://www.nuget.org/packages/BootstrapBlazor/).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些开源项目被构建为 Razor 类库，使得它们可以像其他 .NET 库一样被重用。Razor 类库可以作为 `NuGet` 包发布，从而能够无缝集成到我们的
    Blazor 项目中。例如，`BootstrapBlazor` 库可以在以下链接找到：[https://www.nuget.org/packages/BootstrapBlazor/](https://www.nuget.org/packages/BootstrapBlazor/)。
- en: In this section, we will develop a Razor class library similar to the aforementioned
    open-source projects. We will incorporate reusable Razor components within our
    Razor class library. This library can then be published as a NuGet package. We
    have the option to create a Razor class library using either Visual Studio or
    the .NET command line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个类似于上述开源项目的 Razor 类库。我们将在我们的 Razor 类库中包含可重用的 Razor 组件。然后，这个库可以发布为
    NuGet 包。我们有选择使用 Visual Studio 或 .NET 命令行创建 Razor 类库的选项。
- en: 'To create a Razor class library using Visual Studio, we can add a new project
    to our solution, as illustrated in *Figure 10.3*, by following these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Visual Studio 创建 Razor 类库，我们可以按照以下步骤在我们的解决方案中添加一个新的项目，如图 10.3 所示：
- en: Search for and select **Razor Class Library** from the project templates.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目模板中搜索并选择**Razor 类库**。
- en: Click **Next**, and name the project **PassXYZ.BlazorUI**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，并将项目命名为**PassXYZ.BlazorUI**。
- en: On the subsequent screen, click **Create** to establish the library.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏上，点击**创建**以建立库。
- en: '![Figure 9.2: Creating a Razor class library](img/B21554_10_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Creating a Razor class library'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project using a dotnet command line, we can navigate to the solution
    folder and execute the following command in the Command Prompt:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `dotnet new` command creates a new project utilizing the `razorclasslib`
    template, naming the project `PassXYZ.BlazorUI`. In order to include the project
    in the solution, we can execute the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to create our Razor components using this skeleton project, we must
    remove the unused `Component1.*` and `ExampleJsInterop.cs` files from the `PassXYZ.BlazorUI`
    project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize Razor components in the `PassXYZ.BlazorUI` project, we must include
    the project reference within the `PassXYZ.Vault` project. To do so, we can simply
    right-click the project node in Visual Studio and select `Add -> Project Reference`.
    Alternatively, we can directly modify the `PassXYZ.Vault.csproj` project file
    by adding the following line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to create a new Razor component utilizing this library, we must update
    the `PassXYZ.Vault\_Imports.razor` file by adding the following line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using static assets in the Razor class library
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We employ Bootstrap within our Razor components, so it’s necessary to include
    Bootstrap CSS and JavaScript files in the Razor class library. From the perspective
    of a Blazor app, we can place these static assets in either the project’s `wwwroot`
    folder or the component library’s `wwwroot` folder. Taking the Bootstrap CSS file
    as an example, if we store it in the project’s `wwwroot` directory, we can reference
    it in `index.xhtml` using the following path:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we opt to store it in the component library’s `wwwroot` folder, we can reference
    it using the following path:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The distinction lies in the necessity to reference the URL in the component
    library, which should begin with `_content/{LibraryProjectName}`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Once we have established a Razor class library project, we can proceed to include
    additional components in it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable Razor components
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will refactor our code to develop reusable components. This
    process will enable us to gain a deeper understanding of the features of Razor
    components and learn how to optimize them to improve reusability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 8**, Introducing Blazor Hybrid App Development*, we created the
    Blazor Hybrid version of our app. Additionally, we incorporated layout and routing
    functionalities in *Chapter 9**, Understanding Blazor Routing and Layout*. As
    a result, our app can now browse and update the password database. However, we
    have not yet implemented the majority of CRUD operations. After refining the Razor
    components in this chapter, we will proceed to add these functionalities.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: To navigate the password database, we developed two Razor components – `Items`
    and `ItemDetail`. The `Items` class is employed to exhibit a list of password
    entries and groups within the current group, while the `ItemDetail` class is utilized
    for presenting the content of an individual password entry.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Upon examining the layout of `Items` and `ItemDetail`, as illustrated in *Figure
    10.4*, we can observe that both pages possess a similarity in terms of their appearance
    and overall design.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: UI layout of Items and ItemDetail](img/B21554_10_04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: UI layout of Items and ItemDetail'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The layout of both pages features a sidebar, a header, and a list view. The
    sidebar is defined in the `layout` component, while the header and list view are
    implemented in both `Items` and `ItemDetail` with partially duplicated code. In
    this chapter, we will optimize our code by abstracting the duplicated portions
    into reusable components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two buttons in the header: `Add` and `Back`. The `Back` button allows
    for navigation back to the parent group, while the `Add` button enables the user
    to add a new item or field.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In the list view item, we can utilize the context menu to execute item-level
    operations, such as editing or deleting. The context menu comprises menu items
    designated for specific actions related to the selected item or field. When performing
    edit or delete CRUD operations, upon selecting a menu item, a modal dialog relevant
    to the chosen action will appear.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: In the present implementation, both `Items` and `ItemDetail` incorporate all
    UI elements within a single Razor markup. We will begin to streamline the code
    by breaking it down into smaller, reusable components, which will result in a
    cleaner implementation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will transform modal dialogs, headers, and list views into
    Razor components. Let’s begin with modal dialogs. To facilitate adding, editing,
    and deleting operations, we require two types of dialog boxes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Editor dialog: for adding or editing items or fields'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Confirmation dialog: for confirmation prior to deleting an item or a field'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Understanding Blazor Routing and Layout*, we implemented modal
    dialogs by utilizing HTML and CSS code from Bootstrap examples. However, we have
    not examined these elements thoroughly, as our markup files appear lengthy and
    intricate. In this chapter, we will dissect the code and convert it into Razor
    components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base modal dialog component
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve the editor and confirmation dialogs, we can first construct a base
    modal dialog. By leveraging this base modal dialog, we can create either editor
    or confirmation dialogs as needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Razor component in the `PassXYZ.BlazorUI` project, right-click
    on the project node and select `Add` -> `New Item…` -> `Razor Component` from
    the project template. Name the Razor component `ModalDialog`, and create a C#
    code-behind file for it. Next, enter the code shown in *Listing 10.1* into `ModalDialog.razor`
    and the code in *Listing 10.2* into `ModalDialog.razor.cs`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI code is derived from the `Items` and `ItemDetail` code found in *Chapter
    9*, *Understanding Blazor Routing and Layout*, as depicted in *Listing 10.1*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10.1: `ModalDialog.razor` ([https://epa.ms/ModalDialog10-1](https://epa.ms/ModalDialog10-1))'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In the markup code displayed in *Listing 10.1*, we observe a typical HTML code
    snippet with Bootstrap styling. We have incorporated C# variables within the HTML
    to construct the component UI.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: This base dialog UI comprises a header **(1)** and a body **(4)**. Within the
    header, there is a title **(2)** and a close button **(3)**. The body contains
    a child content area **(5)** and two buttons (**Close** **(6)**/**Save** **(7)**).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: For a visual representation of the layout of this base modal dialog, please
    refer to *Figure 10.5:*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Base dialog](img/B21554_10_05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Base dialog'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the HTML and CSS code closely resemble the Bootstrap example, we have
    substituted all hardcoded content with C# variables. If we were to use this modal
    dialog component to construct a new component, the following would serve as an
    example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above markup code, we define the modal dialog using the `<ModalDialog>`
    component tag. Each modal dialog is assigned a unique ID for identification purposes.
    We can display the dialog box by clicking a button, wherein the modal dialog ID
    is provided to facilitate its identification.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Within the `<ModalDialog>` component tag, we have assigned values to multiple
    attributes defined in the `ModalDialog` component, including the `ID`, `title`,
    `button text`, `event handler`, and more.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than directly assigning a string or data to the attribute of an HTML
    element, we have the option to assign a variable to it. This capability is the
    data binding feature provided by Razor components. In this section, we will explore
    how to use data binding effectively. In data binding, assigning a variable to
    the attribute of a DOM element results in data flow from Razor components to DOM
    elements. Conversely, responding to a DOM event causes data to flow from DOM elements
    to Razor components.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Since we can use a Razor component in the same way as a DOM element, the data
    flow between child and parent Razor components resembles the data exchange between
    Razor components and DOM elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can bind the `id` variable to the `Id` attribute of `ModalDialog`,
    managing the button click event using the `OnSaveClicked` event handler:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous example, the data flows from the `id` variable to the `Id` attribute
    of `ModalDialog`. When the `OnSaveClicked` event handler is invoked, the data
    flows back from `ModalDialog` to the current context. The `ModalDialog` attributes,
    `Id` and `OnSaveAsync`, are defined in the C# code-behind file. In the following
    section, let’s examine the C# code-behind file of `ModalDialog`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Component parameters
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Razor components’ attributes can be defined using component parameters. To establish
    component parameters, we need to create public properties adorned with the `[Parameter]`
    attribute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ModalDialog` class, illustrated in *Listing 10.2*, we declare seven
    component parameters: `Id`, `Title`, `ChildContent`, `OnClose`, `OnSaveAsync`,
    `CloseButtonText`, and `SaveButtonText`. These component parameters can be utilized
    in data binding:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 10.2: `ModalDialog.razor.cs` ([https://epa.ms/ModalDialog10-2](https://epa.ms/ModalDialog10-2))'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters of the `ModalDialog` component are defined as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`Id` **(1)**: This identifier is used to distinguish a modal dialog.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Title` **(2)**: This represents the title of the modal dialog.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChildContent` **(3)**: This is designated for the insertion of the child component’s
    content. The data type that we’re referring to is a `RenderFragment` delegate,
    which represents a segment of UI content. For more details, please refer to the
    following Microsoft document. We’ll dive deeper into this topic in *Chapter 11*:
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code](https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two event handlers – `OnClose` **(4)** and `OnSaveAsync` **(5)** – are defined
    to manage button click actions. We can customize the text on both buttons using
    `CloseButtonText` **(6)** and `SaveButtonText` **(7)**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: We can handle component parameters similarly to HTML attributes. A C# field,
    property, or method return value can be assigned to the component parameter of
    `ModalDialog`. Once we create the base `ModalDialog` component, we can then develop
    `Editor` and `Confirmation` dialog components using it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new modal dialog, `ConfirmDialog`, which will prompt the user
    to confirm the deletion of an item. To create a new `ConfirmDialog` component
    within the `PassXYZ.BlazorUI` project, you can right-click on the project node
    and select `Add` -> `New Item…` -> `Razor Component` from the project template.
    We can name the Razor component `ConfirmDialog` and input the following code provided
    in *Listing 10.3*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10.3: `ConfirmDialog.razor` ([https://epa.ms/ConfirmDialog10-3](https://epa.ms/ConfirmDialog10-3))'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: We define the `Id` **(1)** and `Title` **(2)** component parameters in the `ConfirmDialog`
    and pass their values to the base class using data binding. Additionally, we subscribe
    to the `OnSaveAsync` event by utilizing the `OnSave` event handler. We also define
    our own event handler, `OnConfirmClick`, as a component parameter, allowing other
    components to subscribe to it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ConfirmDialog`中定义了`Id` **(1)** 和`Title` **(2)** 组件参数，并通过数据绑定将它们的值传递给基类。此外，我们通过使用`OnSave`事件处理器来订阅`OnSaveAsync`事件。我们还定义了自己的事件处理器`OnConfirmClick`作为组件参数，允许其他组件订阅它。
- en: 'In the `ConfirmDialog`, we actually bind parameters using nested components.
    In this scenario, the data flow should follow the suggested directions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConfirmDialog`中，我们实际上是通过嵌套组件来绑定参数的。在这种情况下，数据流应遵循以下建议的方向：
- en: Change notifications should move upward through the hierarchy.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更通知应向上通过层次结构传播。
- en: New parameter values should flow downward through the hierarchy.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新参数值应向下通过层次结构传播。
- en: 'The values for the `Id` and `Title` attributes are assigned by the components
    that utilize `ConfirmDialog`, and their values cascade down to `ModalDialog`.
    The `Save` or `Close` button events are initiated within the `ModalDialog` component
    and subsequently propagate upwards through the chain to `ConfirmDialog` and higher-level
    components. Using the `Save` button as an example, the event follows the upward
    direction illustrated here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id`和`Title`属性值由使用`ConfirmDialog`的组件分配，并且它们的值会级联到`ModalDialog`。`Save`或`Close`按钮事件在`ModalDialog`组件内部启动，然后通过链向上传播到`ConfirmDialog`和更高层次的组件。以`Save`按钮为例，事件遵循此处所示的上行方向：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The process begins with the `onclick` event in the DOM. `ModalDialog` defines
    its own event, `OnSaveAsync`, which is activated by the `onclick` event handler.
    `ConfirmDialog`, on the other hand, establishes its own event called `OnConfirmClick`,
    which is initiated by the `OnSaveAsync` event handler.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 流程从DOM中的`onclick`事件开始。`ModalDialog`定义了自己的事件`OnSaveAsync`，该事件由`onclick`事件处理器激活。另一方面，`ConfirmDialog`建立了一个名为`OnConfirmClick`的事件，该事件由`OnSaveAsync`事件处理器启动。
- en: Nested components
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套组件
- en: '`ConfirmDialog` serves as an example of nested components. As demonstrated,
    we can embed components within other components by declaring them using HTML syntax.
    The embedded components appear as HTML tags, with the tag name corresponding to
    the component type. For instance, we can utilize `ModalDialog` inside `ConfirmDialog`,
    as illustrated here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmDialog`是嵌套组件的一个例子。如所示，我们可以通过使用HTML语法声明它们来在其他组件内嵌入组件。嵌入的组件看起来像HTML标签，标签名对应组件类型。例如，我们可以在`ConfirmDialog`内部使用`ModalDialog`，如下所示：'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Nested components serve as a means to construct a component hierarchy in Blazor.
    In object-oriented programming languages, inheritance and composition are two
    methods for extending and reusing a class. In Blazor, composition is employed
    within nested components to enhance functionalities. Inheritance represents an
    `'is-a'` relationship, whereas composition signifies a `'has-a'` relationship.
    In the case of nested components, the parent component encompasses a child component.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套组件是构建Blazor组件层次结构的一种手段。在面向对象的编程语言中，继承和组合是扩展和重用类的方法。在Blazor中，嵌套组件内部使用组合来增强功能。继承代表了一个`'is-a'`关系，而组合则代表了一个`'has-a'`关系。在嵌套组件的情况下，父组件包含子组件。
- en: In Microsoft Blazor and ASP.NET Core documents, the terms `"ancestor"` and `"descendant"`
    or `"parent"` and `"child"` are utilized to describe the relationship between
    nested components. In this context, the parent and child relationship is not one
    of inheritance but of composition. A more suitable term could be “outer component”
    or “inner component.” However, to maintain consistency with Microsoft documentation,
    I will not opt for alternative terms in our discussion. Please be mindful that
    when we discuss nested components and data binding, the ancestor and descendant
    relationship represents a `"has-a"` relationship or a composition.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Blazor和ASP.NET Core文档中，使用`"ancestor"`和`"descendant"`或`"parent"`和`"child"`等术语来描述嵌套组件之间的关系。在这种情况下，父子和关系不是继承关系，而是组合关系。一个更合适的术语可能是“外部组件”或“内部组件”。然而，为了与Microsoft文档保持一致，我将在我们的讨论中不选择替代术语。请注意，当我们讨论嵌套组件和数据绑定时，祖先和后代关系代表了一种“有”关系或组合关系。
- en: In our previous example, the `ConfirmDialog` component serves as the outer component,
    while the `ModalDialog` acts as the inner component. The relationship between
    them is such that the `ConfirmDialog` contains the `ModalDialog` within it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，`ConfirmDialog` 组件作为外部组件，而 `ModalDialog` 作为内部组件。它们之间的关系是 `ConfirmDialog`
    在其中包含 `ModalDialog`。
- en: Child content rendering
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子内容渲染
- en: 'When building nested components, there are often scenarios where one component
    sets the content of another component. The outer component supplies the content
    situated between the inner component’s opening and closing tags. In the case of
    `ConfirmDialog`, the content of `ModalDialog` is configured as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建嵌套组件时，经常会出现一个组件设置另一个组件内容的情况。外部组件提供位于内部组件打开和关闭标签之间的内容。在 `ConfirmDialog` 的情况下，`ModalDialog`
    的内容配置如下：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is accomplished by employing a unique component parameter called `ChildContent`,
    which is of the `RenderFragment` type. In the previous code, the `"Please confirm
    to delete @Title?"` string is assigned to the `ChildContent` parameter of `ModalDialog`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用一个独特的组件参数 `ChildContent` 来实现的，它属于 `RenderFragment` 类型。在之前的代码中，将 `"请确认删除
    @Title?"` 字符串分配给 `ModalDialog` 的 `ChildContent` 参数。
- en: The `ConfirmDialog` represents a relatively simple example of nested components.
    Let’s consider another example, `EditorDialog`, to further examine the features
    of Razor components. As previously mentioned, we require two dialog boxes to manage
    add, edit, and delete actions. The `ConfirmDialog` serves to seek user confirmation
    before deleting an item or a field. In order to add or edit an item or a field,
    we need a dialog box equipped with editing capabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmDialog` 代表了嵌套组件的一个相对简单的例子。让我们考虑另一个例子，`EditorDialog`，以进一步检查 Razor 组件的功能。如前所述，我们需要两个对话框来管理添加、编辑和删除操作。`ConfirmDialog`
    用于在删除项目或字段之前寻求用户确认。为了添加或编辑项目或字段，我们需要一个具有编辑功能的对话框。'
- en: We can follow the same procedure to create a new component, `EditorDialog`.
    After selecting `Add` -> `New Item…` -> `Razor Component` in the project template,
    we can assign the name `EditorDialog` to the Razor component and create a corresponding
    C# code-behind file. Subsequently, we can input the code from *Listing 10.4* into
    `EditorDialog.razor` and the code from *Listing 10.5* into `EditorDialog.razor.cs`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循相同的步骤来创建一个新的组件，`EditorDialog`。在项目模板中选择 `添加` -> `新建项…` -> `Razor 组件` 后，我们可以将
    `EditorDialog` 命名给 Razor 组件并创建相应的 C# 后置代码文件。随后，我们可以将 *清单 10.4* 中的代码输入到 `EditorDialog.razor`
    中，将 *清单 10.5* 中的代码输入到 `EditorDialog.razor.cs` 中。
- en: 'Let us examine the Razor markup code of `EditorDialog`, as displayed in *Listing
    10.4*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `EditorDialog` 的 Razor 标记代码，如 *清单 10.4* 所示：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10.4: `EditorDialog.razor` ([https://epa.ms/EditorDialog10-4](https://epa.ms/EditorDialog10-4))'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 10.4: `EditorDialog.razor` ([https://epa.ms/EditorDialog10-4](https://epa.ms/EditorDialog10-4))'
- en: 'The `EditorDialog`, built using `ModalDialog`, is designed for editing key-value
    pairs. There are two use cases we aim to support with this component: creating
    a new key-value pair, where both the key and value are editable, and modifying
    an existing key-value pair, where only the value field may need alteration.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ModalDialog` 构建的 `EditorDialog` 旨在编辑键值对。我们希望通过此组件支持两种用例：创建新的键值对，其中键和值都是可编辑的，以及修改现有的键值对，其中可能只需要更改值字段。
- en: To facilitate these scenarios, we use a component parameter called `IsKeyEditingEnabled`
    **(1)** to detect the conditions. To create a new key-value pair, the key input
    is rendered as an `<input>` element **(2)**, while to edit an existing key-value
    pair, the key is displayed as the title in the header area. In both cases, the
    value can be edited using a `<textarea>` element `(3)`. This constitutes the core
    functionality of our `EditorDialog` component.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于这些场景，我们使用一个名为 `IsKeyEditingEnabled` 的组件参数 **(1**) 来检测条件。为了创建新的键值对，键输入被渲染为一个
    `<input>` 元素 **(2**)，而为了编辑现有的键值对，键在标题区域显示。在两种情况下，值都可以使用 `<textarea>` 元素 `(3)`
    进行编辑。这构成了我们 `EditorDialog` 组件的核心功能。
- en: As shown in *Figure 10.6*, the UI depicts two different dialogs. On the left-hand
    side, a dialog appears when we intend to add a new field, requiring us to input
    the field name and content. Meanwhile, on the right-hand side, a dialog is displayed
    when we aim to edit an existing URL field. The field name is presented in the
    title, and the content can be modified in the `<textarea>` element.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Editing a field](img/B21554_10_06.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Editing a field'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In the `EditorDialog` component, when we edit the key and value using the `<input>`
    and `<textarea>` HTML elements, the initial value is displayed. This initial value
    is set from the Razor component to the DOM. Once we make changes, the data flows
    from the DOM back to the Razor component, exemplifying two-way data binding.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two-way data binding can be established using the `@bind` Razor directive attribute.
    This syntax enables an HTML element attribute to bind to a field, property, expression
    value, or the result of a method. In *Listing 10.4*, the value of the `<input>`
    element is bound to the `Key` property within the `EditorDialog` component:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the case of two-way data binding, the DOM element `<input>` value is updated
    whenever the `Key` property undergoes a change. Similarly, when the user modifies
    the `<input>` value in the DOM, the `Key` property is updated accordingly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we have the option to replace the `@bind` directive
    attribute with two one-way data bindings, as demonstrated in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Upon rendering our `EditorDialog` component, the value of the `<input>` element
    is derived from the `Key` property. As the user inputs a value into the textbox
    and shifts the element focus, the `onchange` event is triggered, subsequently
    updating the `Key` property with the modified value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `<input>` element, the default event of the `@bind` directive attribute
    is the `onchange` event. We can modify the event using the `@bind:event="{event}"`
    attribute. The `{event}` placeholder should represent a DOM event. For instance,
    we can replace the `onchange` event with the `oninput` event using the following
    code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Binding with component parameters
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we explored two-way data binding between a Razor component
    and a DOM element. As Razor components can function similarly to DOM elements,
    it is also possible to establish two-way data binding between two Razor components.
    This often occurs when there is a need for communication between parent and child
    components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We can bind a component parameter of an inner component to the property of an
    outer component using the `@bind-{PROPERTY}` syntax. In this case, `{PROPERTY}`
    refers to the property to be bound. We have explained that the `@bind` directive
    attribute can be replaced by two one-way data binding setups, which involve assigning
    a variable to the `<input>` value attribute and assigning an event handler to
    the `onchange` event. While the compiler can automatically add the event handler
    for `@bind`, it cannot do so for `@bind-{PROPERTY}`. Therefore, we need to define
    our own event of the `EventCallback<TValue>` type to bind with component parameters.
    The event name must follow the `{PARAMETER NAME}Changed` format. To illustrate
    the `@bind-{PROPERTY}` directive attribute’s usage, let’s use our `EditorDialog`
    component as an example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@bind-{PROPERTY}`语法将内部组件的组件参数绑定到外部组件的属性。在这种情况下，`{PROPERTY}`指的是要绑定的属性。我们已解释过，`@bind`指令属性可以被两个单向数据绑定设置替代，这涉及到将变量分配给`<input>`的值属性，并将事件处理程序分配给`onchange`事件。虽然编译器可以自动添加`@bind`的事件处理程序，但它不能为`@bind-{PROPERTY}`做同样的事情。因此，我们需要定义自己的`EventCallback<TValue>`类型的事件来与组件参数绑定。事件名称必须遵循`{PARAMETER
    NAME}Changed`格式。为了说明`@bind-{PROPERTY}`指令属性的使用，让我们以我们的`EditorDialog`组件为例。
- en: 'In our code, we utilize the `EditorDialog` in the `ItemDetail` component to
    edit a field, or similarly, in the `Items` component to edit an item. Let’s examine
    field editing as an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们在`ItemDetail`组件中使用`EditorDialog`来编辑字段，或者在`Items`组件中编辑项目。让我们以字段编辑为例进行考察：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the previous code of the `ItemDetail` component, we can create data binding
    for `Key` **(1)** and `Value` **(2)** to the `listGroupField` of the `Field` type.
    We need to implement the `{PARAMETER NAME}Changed` events in the C# code-behind
    for `EditorDialog`, as demonstrated in *Listing 10.5*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ItemDetail`组件的前一个代码中，我们可以为`Key` **(1**) 和 `Value` **(2**) 创建与`Field`类型的`listGroupField`的数据绑定。我们需要在`EditorDialog`的C#代码后部分实现`{PARAMETER
    NAME}Changed`事件，如下所示 *清单10.5*：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10.5: `EditorDialog.razor.cs` ([https://epa.ms/EditorDialog10-5](https://epa.ms/EditorDialog10-5))'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '清单10.5: `EditorDialog.razor.cs` ([https://epa.ms/EditorDialog10-5](https://epa.ms/EditorDialog10-5))'
- en: In *Listing 10.5*, we utilize the `Key` property as an example to illustrate
    the component parameter binding process. The `Key` property is defined as a component
    parameter with the `[Parameter]` attribute. An associated event, `KeyChanged`,
    is defined as an `EventCallback<TValue>` type. When the text input is modified
    by the user and the element focus shifts, the `Key` property setter is invoked.
    Within the setter of the `Key` property, the `KeyChanged` event is triggered,
    which notifies the outer `ItemDetail` component. Consequently, the linked variable
    `listGroupField.Key` is updated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *清单10.5* 中，我们利用`Key`属性作为示例来说明组件参数绑定过程。`Key`属性定义为具有`[Parameter]`属性的组件参数。相关的事件`KeyChanged`定义为`EventCallback<TValue>`类型。当用户修改文本输入并且元素焦点改变时，`Key`属性的setter被调用。在`Key`属性的setter中，触发`KeyChanged`事件，该事件通知外部的`ItemDetail`组件。因此，链接变量`listGroupField.Key`被更新。
- en: Communicating with cascading values and parameters
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与级联值和参数通信
- en: We can utilize data binding to transfer data between parent and child components.
    Data binding is effective when passing data to intermediate child components.
    However, there may be instances where we need to pass data to components located
    several levels deep. In such situations, utilizing data binding requires creating
    multiple levels of chained data binding – subsequently increasing the complexity
    as the chained levels expand. For instance, when passing data from `Items` to
    `ModalDialog`, we first need to establish a data binding with `ConfirmDialog`.
    Then, another level of data binding must be created between `ConfirmDialog` and
    `ModalDialog`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用数据绑定在父组件和子组件之间传递数据。当向中间子组件传递数据时，数据绑定非常有效。然而，可能存在需要将数据传递到位于几层深度的组件的情况。在这种情况下，利用数据绑定需要创建多个级别的链式数据绑定，随着链式级别的扩展，复杂性也随之增加。例如，当从`Items`传递数据到`ModalDialog`时，我们首先需要与`ConfirmDialog`建立数据绑定。然后，必须在`ConfirmDialog`和`ModalDialog`之间创建另一个级别的数据绑定。
- en: 'In the `Items` component, we need to pass the `Id` of the dialog to `ModalDialog`.
    An `Id` is necessary to identify the specific dialog instance we wish to display.
    As demonstrated below, we define `ConfirmDialog` within the `Items` component.
    The `Id` is defined within `Items` and passed to `ConfirmDialog` through the use
    of component parameters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, `ConfirmDialog` must pass the `Id` to `ModalDialog`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `ModalDialog`, `Id` is used as an attribute of the `<div>` element:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In order to prevent numerous levels of data binding, we can employ cascading
    values and parameters as a technique to facilitate data flow through a component
    hierarchy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '`CascadingValue` is a component within the Blazor framework. The outer component
    supplies a cascading value by using `CascadingValue`, while the inner component
    can obtain it by employing the `[CascadingParameter]` attribute. To demonstrate
    its usage, we can modify the `Items` component’s code as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We utilize cascading values with the `<CascadingValue>` tag. Within the `<CascadingValue>`
    tag, we assign the `_dialogDeleteId` variable to the `Value` attribute and the
    `Id` string to the `Name` attribute. As this `Id` is not directly employed by
    `ConfirmDialog`, the `Id` component parameter can be safely removed from `ConfirmDialog`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ModalDialog`, we modify the `Id` property to be a parameter by utilizing
    the `[CascadingParameter]` attribute instead of a component parameter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When working with just one cascading value, specifying its name is not mandatory,
    as the compiler can locate it by data type. However, to prevent ambiguities, we
    can assign a name to the cascading value using the `Name` attribute. Next, we
    will examine the final modifications in the `Items` component, which employs cascading
    values for both `ConfirmDialog` and `EditorDialog`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As demonstrated, after implementing a cascading value, `ConfirmDialog` and `EditorDialog`
    no longer need to handle the `Id` field directly. Consequently, the code is more
    compact compared to the previous version.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the creation of reusable components. Some Razor
    components might rely on data or network services, necessitating additional steps
    during their creation or destruction. We can accomplish these actions as part
    of the lifecycle management of Razor components.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, let us examine the lifecycle of Razor components in
    greater detail.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Razor component lifecycle
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Razor component, like any other object, possesses a lifecycle. It consists
    of a series of synchronous and asynchronous lifecycle methods that developers
    can override to perform additional operations during component initialization
    and rendering.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to *Figure 10.7* for an overview of the Razor component lifecycle:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Razor component lifecycle](img/B21554_10_07.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Razor component lifecycle'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 10.7*, it is evident that we have the ability to add hooks during
    both the initialization and rendering phases. The methods listed below can be
    overridden to capture initialization events:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 10.7 中，很明显，我们有能力在初始化和渲染阶段添加钩子。以下方法可以被重写以捕获初始化事件：
- en: '`SetParametersAsync`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetParametersAsync`'
- en: '`OnInitialized` and `OnInitializedAsync`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInitialized` 和 `OnInitializedAsync`'
- en: '`OnParametersSet` and `OnParametersSetAsync`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnParametersSet` 和 `OnParametersSetAsync`'
- en: '`SetParametersAsync` and `OnInitializedAsync` are invoked only in the first
    render. `OnParametersSet``Async` is called every time a parameter is changed.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetParametersAsync` 和 `OnInitializedAsync` 只在第一次渲染时被调用。`OnParametersSetAsync`
    每次参数更改时都会被调用。'
- en: 'The following methods can be overridden to customize rendering:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法可以被重写以自定义渲染：
- en: '`ShouldRender`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShouldRender`'
- en: '`OnAfterRender` and `OnAfterRenderAsync`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnAfterRender` 和 `OnAfterRenderAsync`'
- en: We will examine these lifecycle methods in detail and demonstrate how they can
    be utilized in our code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细检查这些生命周期方法，并演示如何在我们的代码中利用它们。
- en: SetParametersAsync
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SetParametersAsync
- en: '`SetParametersAsync` is the first hook after the object is created and it has
    the following signature:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetParametersAsync` 是对象创建后的第一个钩子，其签名如下：'
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `ParameterView` parameter encompasses component parameters or cascading
    parameter values. `SetParametersAsync` assigns values to each property with either
    the `[Parameter]` or `[CascadingParameter]` attribute. This function can be overridden
    to incorporate any logic that must be executed before setting the parameters.
    The subsequent hook following `SetParametersAsync` is `OnInitializedAsync`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParameterView` 参数包括组件参数或级联参数值。`SetParametersAsync` 方法通过 `[Parameter]` 或 `[CascadingParameter]`
    属性将值分配给每个属性。此函数可以被重写以包含在设置参数之前必须执行的任何逻辑。`SetParametersAsync` 后续的钩子是 `OnInitializedAsync`。'
- en: OnInitialized and OnInitializedAsync
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnInitialized 和 OnInitializedAsync
- en: '`OnInitialized` and `OnInitializedAsync` are invoked when the component is
    initialized. They have the following signatures, respectively:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInitialized` 和 `OnInitializedAsync` 在组件初始化时被调用。它们的签名分别如下：'
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By overriding these two functions, we can incorporate logic to initialize our
    component at this stage. However, keep in mind that these functions are called
    only once, immediately following the component’s creation. For resource-intensive
    initialization tasks, asynchronous methods can be employed, such as downloading
    data via RESTful API calls. As illustrated in *Figure 10.7*, once an asynchronous
    method is completed, the DOM necessitates re-rendering.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写这两个函数，我们可以在这一阶段将逻辑集成到我们的组件中。然而，请注意，这些函数仅在组件创建后立即调用一次。对于资源密集型的初始化任务，可以使用异步方法，例如通过
    RESTful API 调用下载数据。如图 10.7 所示，一旦异步方法完成，DOM 需要重新渲染。
- en: OnParametersSet and OnParametersSetAsync
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnParametersSet 和 OnParametersSetAsync
- en: When component parameters are set or modified, `OnParametersSet` and `OnParametersSetAsync`
    are invoked. We observe that there are two versions to accommodate both synchronous
    and asynchronous scenarios. The asynchronous version, `OnParametersSetAsync`,
    can be employed to manage time-consuming tasks. Upon completion of the asynchronous
    task, the DOM must be re-rendered to display any updates.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件参数被设置或修改时，会调用 `OnParametersSet` 和 `OnParametersSetAsync`。我们注意到有两种版本以适应同步和异步场景。异步版本
    `OnParametersSetAsync` 可以用于管理耗时任务。异步任务完成后，必须重新渲染 DOM 以显示任何更新。
- en: 'The methods have the following signatures, respectively:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的签名分别如下：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These two methods are invoked whenever component parameters or cascading parameters
    change and may be called multiple times. In contrast, `OnInitializedAsync` is
    called only once.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在组件参数或级联参数更改时都会被调用，并且可能被多次调用。相比之下，`OnInitializedAsync` 只会被调用一次。
- en: As illustrated in *Figure 10.7*, the DOM can undergo multiple renderings during
    the initialization phase, resulting in the invocation of asynchronous calls. The
    methods involved in this rendering process include `ShouldRender` and `OnAfterRenderAsync`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 10.7 所示，在初始化阶段，DOM 可能会进行多次渲染，从而导致异步调用的调用。涉及此渲染过程的方法包括 `ShouldRender` 和 `OnAfterRenderAsync`。
- en: ShouldRender
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ShouldRender
- en: 'The `ShouldRender` method returns a Boolean value, indicating whether the component
    ought to be rendered. As illustrated in *Figure 10.7*, the first render disregards
    this method. Consequently, a component must be rendered at least once. This method
    possesses the following signature:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: OnAfterRender and OnAfterRenderAsync
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OnAfterRender` and `OnAfterRenderAsync` are invoked after a component has
    completed its rendering process. Their respective signatures are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These methods can be utilized to execute supplementary initialization tasks
    with the rendered content, such as invoking JavaScript code in the component.
    This method features a Boolean `firstRender` parameter, enabling us to attach
    JavaScript event handlers only once. Although there is an asynchronous version
    of this method, the framework does not schedule another render cycle upon the
    completion of the asynchronous task.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine the impact of lifecycle methods, we can conduct a test by incorporating
    all lifecycle methods into the `ConfirmDialog` component, as demonstrated below:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have overridden all lifecycle methods in `ConfirmDialog` and added debug
    output to display the progress. Upon launching our app, we can observe the following
    output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The previous output is displayed when we first launch our app and the `Items`
    page appears. We can observe that the `Id` cascading parameter is not set before
    the `SetParametersAsync` method is called. Since we have overridden the asynchronous
    methods, multiple render cycles are scheduled to occur simultaneously. As a result,
    the `ShouldRender` and `OnAfterRenderAsync` methods are invoked multiple times
    due to parallel rendering.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s consider another case, which occurs when we click on the context
    menu on the `Items` page. Upon clicking on the context menu of an item, such as
    a Google icon, the `ConfirmDialog` is initialized once more. The resulting output
    is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `SetParametersAsync` method is called again, since the `Title` component
    parameter has been changed. In the subsequent calls, we can observe that the `Title`
    component parameter is set to `Google`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we use `OnParametersSet` to load the list of items in `Items.razor.cs`,
    as well as to load a list of fields in `ItemDetail.razor.cs`. Let’s examine `OnParametersSet`
    in `ItemDetail.razor.cs`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**(1)** In `OnParametersSet`, we check whether the `SelectedItemId` component
    parameter is `null`. This represents the `ID` of the selected item. **(2)** If
    it is not null, we can locate the item by calling the `IDataStore` method named
    `GetItem`. **(3)** Once we obtain the instance of the selected item, we can retrieve
    a list of fields by invoking the `GetFields` method.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `OnParametersSet` in `Items.razor.cs` is quite similar
    to this. For more details, you can refer to the following GitHub link: [https://epa.ms/Items10-6](https://epa.ms/Items10-6).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have developed a near-complete password manager app, with its UI
    built using Blazor. We have established reusable modal dialog components to accommodate
    the context menu, enabling us to perform CRUD operations. The final component
    we need to address is the actual implementation of these CRUD operations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD operations
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After preparing the modal dialogs for CRUD operations, as discussed in the previous
    sections, we can now proceed to implement these CRUD operations in this section.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations of items
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add or update an item, we can utilize the `UpdateItemAsync` method in `Items.razor.cs`
    to accommodate both scenarios. To distinguish between creating a new item and
    updating an existing one, we define a private `_isNewItem` field as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, we’ll see how to add or edit an item.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new item
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a new item, simply click the `+` button located in the header of the
    `Items` page, as depicted in *Figure 10.8*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Adding a new item](img/B21554_10_08.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Adding a new item'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The Razor markup of this page header can be reviewed here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The page header features the `Back` button **(1)**, the `Title` **(2)**, and
    the `Add` button **(3)**. The `Back` button is displayed only when there is an
    existing parent link.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking the `Add` button, a modal dialog with an `Id` defined in the `_dialogEditId`
    variable will be displayed. The `onclick` event handler sets `_isNewItem` to true,
    allowing the modal dialog event handler to recognize that the action is intended
    to add a new item.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Editing or deleting an item
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To edit or delete an item, click on the context menu found on the item, as
    demonstrated in *Figure 10.9*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Editing or deleting an item](img/B21554_10_09.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Editing or deleting an item'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking the context menu button, a list of menu items will be displayed.
    Let’s examine the markup for the context menu found in `Items.razor`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding markup code, a context menu button **(1)** is defined. Upon
    clicking this button, two menu items, `Edit` **(2)** and `Delete` **(3)**, will
    appear. As the context menu markup code runs within a `foreach` loop, we need
    to obtain a reference to the selected item for editing or deletion. In the C#
    code-behind logic, the `listGroupItem` variable is employed to reference the selected
    item.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: We can capture this reference through the `onclick` event handler of the context
    menu button.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Upon selecting the `Edit` menu item, it is crucial to set the `_isNewItem` variable
    to `false`. This adjustment allows the event handler of the modal dialog to discern
    that we are modifying an existing item.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Having completed all the previous setup, it’s time to examine the event handler
    in modal dialogs. First, let’s take a look at the `UpdateItemAsync` event handler
    within `Items.razor.cs`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `UpdateItemAsync` event handler can manage both adding and editing an item.
    It checks the `_isNewItem` variable **(1)** to determine whether we aim to add
    or edit an item. Subsequently, it calls `IDataStore` methods to perform either
    addition or update actions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine the event handler for deleting an item:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the `DeleteItemAsync` event handler, the item is simply removed from the
    list, and the `IDataStore` methods are called to execute the delete action.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations of fields
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CRUD operations for fields resemble those we implemented for items. To
    add or update a field, we can employ the `UpdateFieldAsync` method in `ItemDetail.razor.cs`
    to manage both scenarios. To determine whether we aim to create a new field or
    update an existing one, we define a private `_isNewField` field as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The UI for CRUD operations also bears similarity to what we discussed in the
    previous section. To view the `Add` button and context menu items, please refer
    to *Figure 10.10*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: Add, edit, or delete a field](img/B21554_10_10.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Add, edit, or delete a field'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'We can examine the Razor markup code for the page header found in `ItemDetail.razor`
    as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we can observe, the preceding source code is quite similar to the one found
    in `Items.razor`, with the exception of replacing the `_isNewItem` variable with
    `_isNewField`. We can consider refining this page header into a reusable component
    later on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the previous section, let’s now examine the source code for the
    list group and context menu:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding source code of `ItemDetail.razor` features a context **Menu**
    button **(1)** and three buttons for the **Add** **(2)**, **Edit** **(3)**, and
    **Show** **(4)** menu items. You may have noticed that the source code is quite
    similar to that in `Items.razor`, encompassing a list group and a context menu.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We will further develop this into a reusable component later in this chapter.
    The variation in the context menu lies in the addition of a menu item that displays
    or conceals a field, if it is a protected field such as a password. We utilize
    the `onclick` event handler, `OnToggleShowPassword`, to set the `IsHide` field
    property, thereby toggling the visibility of the password field.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s examine the event handlers for modal dialogs in `ItemDetail.razor.cs`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `UpdateFieldAsync` event handler manages both the addition and editing of
    a field. It receives two parameters – `key` and `value` – which are passed from
    the modal dialog and are used to set the field of `listGroupField`. By examining
    the `_isNewField` variable, the handler determines whether the intent is to add
    or edit a field. Subsequently, it calls `IDataStore` methods to execute the add
    or update actions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a field, the `DeleteFieldAsync` event handler below is triggered:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the `DeleteFieldAsync` event handler, we simply remove the field from the
    selected item and invoke the `IDataStore` method to update the database.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Having implemented CRUD operations, we have now successfully completed the implementation
    of password manager features. We have developed a new version of the password
    manager app utilizing Blazor UI. The distinction between this version and the
    one described in *Part 1* of this book lies in our use of Blazor to construct
    all user interfaces. The appearance and functionality of the Blazor UI closely
    resemble web apps, while the XAML UI maintains the characteristics of native apps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Although we have successfully implemented all the required functionalities,
    we can observe some duplicated code in our current implementation. To resolve
    this issue, we can refactor our code, transforming the duplicate sections into
    Razor components.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Razor components
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the current implementation, we can observe that most of the duplicated code
    is found in the `Items` and `ItemDetail` pages. Throughout the remainder of this
    chapter, we will transform this duplicated code into Razor components.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the following components:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '`Navbar`: This component displays a navigation bar.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dropdown`: This component supports a context menu.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`: This component displays a list of items.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ListView` component is the most complex one, so we will address it at the
    end of this section. For now, let’s focus on the `Navbar` and `Dropdown` components
    first.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Navbar component
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine the navigation bar UI in *Figure 10.11*. We can observe that
    the navigation bar features a **Back** button, a **Title**, and an **Add** button:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Navigation bar](img/B21554_10_11.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Navigation bar'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, **(1)** the `Back` button is displayed when a parent
    link is present. **(2)** The `Back` button is implemented using an `<a>` tag.
    **(3)** The `Title`, as a string, appears within the `<h1>` tag. **(4)** The `Add`
    button is implemented using a `<button>` tag. The styling of both the `Back` and
    `Add` buttons employs Bootstrap formatting.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform the preceding code into a Razor component, we can generate a new
    Razor component in the `PassXYZ.BlazorUI` project and name it `Navbar`. The `Navbar`
    component will display the UI elements illustrated in *Figure 10.11*, including
    a `Back` button, a title, and an `Add` button. In order to separate the UI and
    logic, we will create both a `Navbar.razor.cs` C# code-behind file and the Razor
    markup, `Navbar.razor`. We will define component parameters and event handlers
    in the C# code-behind file, as demonstrated in *Listing 10.6*:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 10.6: `Navbar.razor.cs` ([https://epa.ms/Navbar10-7](https://epa.ms/Navbar10-7))'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In `Navbar`, there are four component parameters and an event handler defined.
    We can assign the parent link for the `Back` button using the `ParentLink` parameter
    **(1)**. The value of `Title` is set according to the `Title` parameter **(3)**.
    For the `Add` button, it is necessary to provide an `Id` and an event handler
    for the dialog box; hence, the `DialogId` **(2)** and `OnAddClick` **(4)** parameters
    are utilized.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us examine the Razor file of `Navbar`, presented in *Listing 10.7*:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 10.7: `Navbar.razor` ([https://epa.ms/Navbar10-8](https://epa.ms/Navbar10-8))'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe that the code closely resembles the code used in `Items` and
    `ItemDetail`. The key difference is that we have substituted hardcoded values
    with component parameters (`ParentLink` **(1)**, `DialogId` **(2)**, `Title` **(3)**,
    and `OnClickClose` **(4)**). With the integration of this new `Navbar` component,
    we can modify the code in `Items` by employing the `Navbar` component, as demonstrated
    below:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then proceed to replace the code in `ItemDetail` as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As observed, we have streamlined the code by eliminating duplications, resulting
    in a more elegant and concise presentation.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Having completed the work for the `Navbar`, let us now shift our focus to the
    `Dropdown` component.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Dropdown component for the context menu
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To develop a component akin to the context menu, we can reuse the Bootstrap
    `Dropdown` component. As illustrated in *Figure 10.12*, a context menu comprises
    a context menu button and a list of menu items. Upon clicking the context menu
    button, users are presented with a display of menu items.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Context menu](img/B21554_10_12.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Context menu'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The present code for the context menu is replicated in both the `Items` and
    `ItemDetail` pages, as demonstrated below:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `Dropdown` component of Bootstrap comprises a button and an unordered list.
    We must define an event handler for the button to perform the necessary action.
    In the previous code, we set the `item` variable to `listGroupItem`. Regarding
    the menu items, each is implemented as a `<button>` tag and accepts a dialog ID
    and an event handler as parameters. When a menu item is clicked, the corresponding
    modal dialog will be displayed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: We can create two new Razor components in the `PassXYZ.BlazorUI` project, named
    `Dropdown` and `MenuItem`. To separate the UI and logic, we can implement them
    in the C# code-behind file (*Listing 10.9*) and the Razor file (*Listing 10.8*),
    which we will demonstrate now.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first examine the `Dropdown` component UI in Listing 10.8:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 10.8: `Dropdown.razor` ([https://epa.ms/Dropdown10-9](https://epa.ms/Dropdown10-9))'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Dropdown` component, we define a button **(1)** and an unordered list
    **(2)**. The button’s click event is set up as an `OnClick` event handler. The
    items within the unordered list appear as child content of the `Dropdown` component.
    The component parameters can be found in the C# `Dropdown.razor.cs` code-behind
    file, as shown in *Listing 10.9*:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 10.9: `Dropdown.razor.cs` ([https://epa.ms/Dropdown10-10](https://epa.ms/Dropdown10-10))'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Dropdown.razor.cs`, two component parameters `OnClick` **(1)** and `ChildContent`
    **(2)** are defined. The `MenuItem` component can be presented as the child content
    of the `Dropdown` component. The UI code for `MenuItem` can be observed in *Listing
    10.10*:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 10.10: `MenuItem.razor` ([https://epa.ms/MenuItem10-11](https://epa.ms/MenuItem10-11))'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MenuItem` component specifies three component parameters: `Id`, `OnClick`,
    and `ChildContent`. These parameters are defined within `MenuItem.razor.cs`, as
    demonstrated in *Listing 10.11*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 10.11: `MenuItem.razor.cs` ([https://epa.ms/MenuItem10-12](https://epa.ms/MenuItem10-12))'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The `Id` parameter is employed to designate the dialog ID when a menu
    item is clicked. **(2)** `OnClick` is utilized to register an event handler for
    a button click event. **(3)** `ChildContent` serves to display child content,
    such as the name of the menu item.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'We have successfully implemented the components for the context menu. Now,
    we can replace the redundant code in the `Items` and `ItemDetail` pages with these
    context menu components. The implementation of the context menu on the `Items`
    page proceeds as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On the `ItemDetail` page, the context menu is implemented as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Following the refinement of the code for the `Items` and `ItemDetail` pages,
    we have implemented modal dialogs, navigation bars, and context menu components.
    Consequently, the code appears significantly more elegant and concise. Nevertheless,
    there is still potential for further refinement. The main UI logic in both the
    `Items` and `ItemDetail` pages revolves around a list view. We can optimize this
    part of the code by implementing a `ListView` component. In order to create a
    `ListView` component, we will need to utilize an advanced feature known as templated
    components.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Using templated components
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In constructing a Razor component, component parameters serve as the communication
    channels between parent and child components. While discussing nested components,
    we brought attention to a special `ChildContent` component parameter of the `RenderFragment`
    type. This parameter enables the parent component to set the content of the child
    component. For instance, the content of `MenuItem` in the following code can be
    assigned an HTML string:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We are able to achieve this as `MenuItem` defines the following component parameter,
    which can be observed in *Listing 10.11*:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we want to explicitly specify the `ChildContent` parameter, we can achieve
    this as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`ChildContent` is a unique component parameter that can be implicitly used
    in markup language. To utilize `ChildContent`, we create a component capable of
    accepting a UI template of the `RenderFragment` type as its parameter. Furthermore,
    we can define multiple UI templates as parameters when developing a new component.
    Components of this nature are referred to as templated components.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: A render fragment, of the `RenderFragment` type, signifies a portion of the
    UI designated for rendering. Furthermore, there is a generic version, `RenderFragment<TValue>`,
    which accepts a type parameter. A specific type can be provided when invoking
    `RenderFragment`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ListView component
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a `ListView`, we need to utilize multiple UI templates as component
    parameters. We can create a new Razor component within the `PassXYZ.BlazorUI`
    project and name it `ListView`. Similar to what we did for `Navbar` and the context
    menu, we can separate the UI and code into a Razor file (*Listing 10.12*) and
    a C# code-behind file (*Listing 10.13*):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 10.12: `ListView.razor` ([https://epa.ms/ListView10-13](https://epa.ms/ListView10-13))'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ListView` Razor file, we define three UI templates, `Header` **(1)**,
    `Row` **(2)**, and `Footer` **(3)**. We render the `Header` and `Footer` similarly
    to `ChildContent`, but the `Row` component parameter appears distinct. The rendering
    process for the `Row` component is as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Alternatively, we can render it like this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We render it with an `item` argument. The type of `Row` is `RenderFragment<TValue>`,
    as we demonstrate in *Listing 10.13*:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 10.13: `ListView.razor.cs` ([https://epa.ms/ListView10-14](https://epa.ms/ListView10-14))'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: We define the `ListView` as a generic `ListView<TItem>` type with the `TItem`
    type parameter. In the `ListView` component, we can specify a list view header,
    using the `Header` **(1)** parameter, and a footer, using the `Footer` **(4)**
    parameter. The `ListView` can be bound to any data collection of the `IEnumerable<TItem>`
    type via the `Items` parameter **(3)**. The `Row` **(2)** parameter can be employed
    to establish the UI template for an individual item within the `foreach` loop.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Using the ListView component
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, let’s examine the usage of the `ListView` component in the `Items`
    and `ItemDetail` pages. We will use the `ItemDetail` page as an example for our
    discussion:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we have defined `Header`, `Row`, and `Footer` as optional parameters, there
    is no obligation to specify all of them. In the `ItemDetail` page, we utilize
    `Row` and `Footer`. **(1)** First, we need to pass the list of fields to the `Items`
    parameter. **(2)** In the `foreach` loop, each field is passed to the `ListView`
    as an argument for the `Row`, which is defined as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `"field"` value of the `Context` property is employed to specify the argument
    for `Row`. Within the UI template of `Row`, we showcase the key value of `field`
    and establish a context menu using the `Dropdown` and `MenuItem` components, which
    were implemented in the previous section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`属性的`"field"`值被用来指定`Row`的参数。在`Row`的UI模板中，我们展示了`field`的关键值，并使用`Dropdown`和`MenuItem`组件创建了一个上下文菜单，这些组件在上一节中已实现。'
- en: By utilizing the `ListView` component, we have significantly enhanced the implementation
    of the `ItemDetail` page. This improvement was achieved through the creation of
    our own Razor components.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ListView`组件，我们显著提升了`ItemDetail`页面的实现。这一改进是通过创建我们自己的Razor组件来实现的。
- en: Having completed the refactoring of our code, we have concluded the introduction
    of the `.NET MAUI Blazor Hybrid` app. In Part 2, we recreated our app using Blazor
    while maintaining the same functionalities.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 完成代码重构后，我们完成了`.NET MAUI Blazor Hybrid`应用的引入。在第二部分中，我们使用Blazor重新创建了我们的应用，同时保持了相同的功能。
- en: If you have experience in Blazor web app development, you may not see too much
    difference between the Blazor Hybrid app and the Blazor web app. This is precisely
    the advantage of the Blazor Hybrid app. You may now be wondering, how do we access
    a native API in a Blazor Hybrid app? Let’s have a brief overview in the next section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过Blazor Web应用开发的经验，你可能不会在Blazor Hybrid应用和Blazor Web应用之间看到太大的差异。这正是Blazor
    Hybrid应用的优点。你现在可能想知道，我们如何在Blazor Hybrid应用中访问原生API？让我们在下一节中简要概述。
- en: Accessing a native API from Blazor Hybrid apps
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Blazor Hybrid应用访问原生API
- en: When it comes to accessing native APIs, there isn’t a significant difference
    between .NET MAUI apps and Blazor Hybrid apps. As we learned in *Chapter 7*, *Using
    Platform-Specific Features*, it’s vital to always create an abstract layer that
    encapsulates native access at the platform layer. Hence, we’re not directly accessing
    native APIs from cross-platform code in .NET MAUI or Blazor Hybrid apps. In our
    app, while we do need to access native APIs, we will access a native API through
    an abstract layer.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到访问原生API时，.NET MAUI应用和Blazor Hybrid应用之间没有显著差异。正如我们在*第7章*中学习的*使用平台特定功能*，始终创建一个封装平台层原生访问的抽象层是至关重要的。因此，我们在.NET
    MAUI或Blazor Hybrid应用中不会直接从跨平台代码中访问原生API。在我们的应用中，虽然我们需要访问原生API，但我们将通过一个抽象层来访问原生API。
- en: Access to platform APIs from .NET has seen significant evolution over time,
    transitioning from Xamarin plugins to the unified NuGet dependency presented by
    Xamarin.Essentials. As discussed in *Chapter 7*, *Using Platform-Specific Features*,
    Xamarin.Essentials aimed to standardize all native access within a single library.
    Initially, the plan with .NET MAUI was to migrate everything as .NET MAUI Essentials.
    However, the .NET MAUI team later realized that breaking it down into more logically
    granular namespaces, such as `Microsoft.Maui.Storage` or `Microsoft.Maui.Devices`,
    and so on, made more sense.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET访问平台API随着时间的推移经历了显著的发展，从Xamarin插件过渡到Xamarin.Essentials提供的统一NuGet依赖项。正如*第7章*中讨论的*使用平台特定功能*，Xamarin.Essentials旨在将所有原生访问标准化到一个库中。最初，.NET
    MAUI的计划是将所有内容迁移到.NET MAUI Essentials。然而，.NET MAUI团队后来意识到，将它们分解成更逻辑上细粒度的命名空间，如`Microsoft.Maui.Storage`或`Microsoft.Maui.Devices`等，更有意义。
- en: 'In our app, we access platform-level APIs in the classes defined in the `Services`
    folder, such as `LoginService.cs`. For example, we defined a property, `IsPrivacyNoticeAccepted`,
    in `LoginService` to store whether the user has accepted the privacy notice or
    not. We use a `Preferences` API to store the data in platform-specific persistent
    storage. `Preferences` APIs are defined in the `Microsoft.Maui.Storage` namespace,
    as we can see from the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们通过`Services`文件夹中定义的类访问平台级别的API，例如`LoginService.cs`。例如，我们在`LoginService`中定义了一个属性`IsPrivacyNoticeAccepted`，用来存储用户是否接受了隐私通知。我们使用`Preferences`
    API将数据存储在平台特定的持久存储中。`Preferences` API定义在`Microsoft.Maui.Storage`命名空间中，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: APIs such as `Preferences` are provided by Microsoft as part of .NET MAUI libraries.
    If we find something that is not supported by Microsoft APIs, we have to create
    our own plugins or use plugins provided by the community. Please refer to *Chapter
    7* about how to create and use .NET MAUI plugins.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Preferences`等API由Microsoft作为.NET MAUI库的一部分提供。如果我们发现某些内容不支持Microsoft API，我们必须创建自己的插件或使用社区提供的插件。请参阅*第7章*了解如何创建和使用.NET
    MAUI插件。'
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained the process of creating Razor components. We covered
    topics such as data binding and the component lifecycle. Subsequently, we developed
    a set of modal dialog components to optimize our code. By utilizing Razor components,
    we can eliminate duplicate code and enhance the UI design. We incorporated CRUD
    operations within the event handlers of modal dialogs. As a result, we now have
    a new version of the password manager app.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了创建Razor组件的过程。我们涵盖了数据绑定和组件生命周期等主题。随后，我们开发了一套模态对话框组件以优化我们的代码。通过利用Razor组件，我们可以消除重复代码并增强UI设计。我们在模态对话框的事件处理程序中集成了CRUD操作。因此，我们现在有了密码管理器应用的新版本。
- en: In the subsequent chapter, we will transition to *Part 3* of this book. In *Part
    3*, we will introduce the implementation of unit tests and the process of publishing
    a .NET MAUI application to app stores.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将过渡到本书的*第三部分*。在*第三部分*中，我们将介绍单元测试的实现以及将.NET MAUI应用程序发布到应用商店的过程。
- en: Leave a review!
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: '*Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 40% discount code.*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*喜欢这本书吗？帮助像你这样的读者留下亚马逊评论。扫描下面的二维码获取40%的折扣码。*'
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠*'
