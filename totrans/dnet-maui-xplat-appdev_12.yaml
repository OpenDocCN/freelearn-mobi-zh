- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Razor Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored Blazor routing and layout and, subsequently,
    built a navigation framework by establishing our app’s routing and layout. Upon
    setting up the navigation framework, we crafted top-level pages. The implementation
    of Razor pages allows for password database navigation, akin to the XAML version.
    While Razor pages are indeed Razor components, they are not reusable. In this
    chapter, we will introduce the creation of reusable Razor components. Furthermore,
    we will delve into data binding and the Razor component lifecycle to foster a
    comprehensive understanding of these aspects. Armed with this knowledge, we will
    optimize our code by converting duplicate code into reusable Razor components.
    Ultimately, we will use the Razor components to implement CRUD operations within
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Razor class library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable Razor components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Razor component lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring Razor components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using templated components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter10](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/d5302ca26a3c362a291785a9771d87ad8552bdb2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, you can use the below command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code* section in this book, in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we developed and utilized Razor components in the previous two chapters,
    we have not yet delved deeply into them. In this section, we will continue refining
    the app from the last chapter while exploring Razor components more thoroughly,
    thereby gaining a better understanding of key concepts surrounding these components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor apps are constructed using Razor components. The first Razor component
    in our app is `Main`, and it is defined in `Main.razor`, as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Router` component, which is installed within the `Main` component, takes
    care of routing pages and selecting the default layout component. All other Razor
    pages are managed by the `Router` components. These Razor pages, loaded by the
    `Router`, have route templates defined and serve to display the user interface.
    In our project, Razor pages can be found in the `Pages` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the startup sequence of the Blazor Hybrid app, we can refer to
    *Figure 10.1* below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Startup of the Blazor Hybrid app'
  prefs: []
  type: TYPE_NORMAL
- en: As a .NET MAUI application, the starting point of the Blazor Hybrid app is also
    the `MauiProgram` class **(1)**. Within the `MauiProgram` class, an instance of
    the `App` class **(2)** is constructed. The first XAML page to be loaded into
    this is the `MainPage` **(3)** class. This `MainPage` includes an instance of
    `BlazorWebView` **(4)** that hosts the Blazor pages. For further information on
    how the Razor component `Main` is loaded into `BlazorWebView`, please refer to
    *Chapter 8**, Introducing Blazor Hybrid App Development*. Once the `Main` component
    is loaded into `BlazorWebView`, it exhibits the root of the navigation stack.
    In this particular scenario, the root page of the navigation stack is the `Login`
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there are reusable Razor components that act as the building blocks
    of Razor pages. These Razor components are stored in the `Shared` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, each file possessing a `.razor` file extension represents a Razor
    component, which is compiled into a C# class upon execution. The filename serves
    as the class name, while the folder name contributes to the namespace. For instance,
    the `Login` Razor component resides in the `Pages` folder, so the folder name
    `Pages` is included as part of the namespace. Thus, the complete name of the `Login`
    class is `PassXYZ.Vault.Pages.Login`.
  prefs: []
  type: TYPE_NORMAL
- en: Razor components can be written either in a single file or divided into a Razor
    file (`.razor`) and a code-behind C# file (`.cs`). The code-behind C# file defines
    a partial class containing all the programming logic. This approach was employed
    when we created the `Login` component in *Chapter 8**, Introducing Blazor Hybrid
    App Development*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Razor component naming convention](img/B21554_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Razor component naming convention'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 10.2*, when creating the `Login` component, we incorporated
    the Bootstrap CSS style for styling purposes. Razor components offer CSS isolation,
    which simplifies CSS usage and prevents collisions with other components or libraries.
    Moreover, Razor components can include their own CSS style in a `.razor.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a Razor component is a C# class, it encompasses all features inherent to
    a C# class. Consequently, a Razor component can serve as a child class of another
    Razor component. In *Chapter 9**, Understanding Blazor Layout and Routing*, we
    observed that all layout components are derived classes of `LayoutComponentBase`
    when creating layout components. As illustrated in the `MainLayout.razor` code
    below, we employ the `@inherits` directive to specify the `LayoutComponentBase`
    as the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Every Razor component is derived from the `ComponentBase` class. As a result,
    it is feasible to create a Razor component derived from the `ComponentBase` class
    using a C# file, without requiring a Razor markup file. For instance, we can create
    an `AppName` Razor component within a C# class, demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`AppName` is a Razor component that is designed without a Razor markup file
    (`.razor`); however, it functions identically to other Razor components, as demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The above example is used to demonstrate how to create a Razor component in
    C# code. However, it’s generally recommended to create UI components utilizing
    Razor markup instead of C# code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced Razor components. We can place reusable Razor
    components in a shared folder to ensure that they are accessible throughout the
    project. Additionally, a Razor class library can be created to share Razor components
    across multiple projects. In the subsequent section, we will delve into the process
    of packaging these Razor components into a library.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Razor class library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our project, we create reusable components and store them in the `Shared`
    folder. These components can be utilized by other components, such as layout components
    or `NavMenu`. Additionally, we can encapsulate Razor components within the Razor
    class library, making them accessible for use across various projects.
  prefs: []
  type: TYPE_NORMAL
- en: The components in the Razor class library are not specific to a single project,
    making them suitable for use in any Blazor project, whether it be Blazor Hybrid,
    Blazor WebAssembly, or Blazor Server apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we construct Razor components utilizing Bootstrap. Numerous open-source
    Razor class libraries built on top of Bootstrap can be found on GitHub. Several
    of these libraries are sufficiently robust for commercial product development.
    Below are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BootstrapBlazor`: [https://github.com/dotnetcore/BootstrapBlazor](https://github.com/dotnetcore/BootstrapBlazor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blazorise`: [https://github.com/Megabit/Blazorise](https://github.com/Megabit/Blazorise)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Havit.Blazor`: [https://github.com/havit/Havit.Blazor/](https://github.com/havit/Havit.Blazor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These open-source projects are constructed as Razor class libraries, enabling
    their reuse in a manner analogous to other .NET libraries. Razor class libraries
    can be published as `NuGet` packages, allowing for seamless integration into our
    Blazor projects. For example, the `BootstrapBlazor` library can be found at this
    link: [https://www.nuget.org/packages/BootstrapBlazor/](https://www.nuget.org/packages/BootstrapBlazor/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will develop a Razor class library similar to the aforementioned
    open-source projects. We will incorporate reusable Razor components within our
    Razor class library. This library can then be published as a NuGet package. We
    have the option to create a Razor class library using either Visual Studio or
    the .NET command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Razor class library using Visual Studio, we can add a new project
    to our solution, as illustrated in *Figure 10.3*, by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for and select **Razor Class Library** from the project templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next**, and name the project **PassXYZ.BlazorUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the subsequent screen, click **Create** to establish the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2: Creating a Razor class library](img/B21554_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Creating a Razor class library'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project using a dotnet command line, we can navigate to the solution
    folder and execute the following command in the Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dotnet new` command creates a new project utilizing the `razorclasslib`
    template, naming the project `PassXYZ.BlazorUI`. In order to include the project
    in the solution, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In order to create our Razor components using this skeleton project, we must
    remove the unused `Component1.*` and `ExampleJsInterop.cs` files from the `PassXYZ.BlazorUI`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize Razor components in the `PassXYZ.BlazorUI` project, we must include
    the project reference within the `PassXYZ.Vault` project. To do so, we can simply
    right-click the project node in Visual Studio and select `Add -> Project Reference`.
    Alternatively, we can directly modify the `PassXYZ.Vault.csproj` project file
    by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create a new Razor component utilizing this library, we must update
    the `PassXYZ.Vault\_Imports.razor` file by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using static assets in the Razor class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We employ Bootstrap within our Razor components, so it’s necessary to include
    Bootstrap CSS and JavaScript files in the Razor class library. From the perspective
    of a Blazor app, we can place these static assets in either the project’s `wwwroot`
    folder or the component library’s `wwwroot` folder. Taking the Bootstrap CSS file
    as an example, if we store it in the project’s `wwwroot` directory, we can reference
    it in `index.xhtml` using the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we opt to store it in the component library’s `wwwroot` folder, we can reference
    it using the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The distinction lies in the necessity to reference the URL in the component
    library, which should begin with `_content/{LibraryProjectName}`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have established a Razor class library project, we can proceed to include
    additional components in it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable Razor components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will refactor our code to develop reusable components. This
    process will enable us to gain a deeper understanding of the features of Razor
    components and learn how to optimize them to improve reusability.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 8**, Introducing Blazor Hybrid App Development*, we created the
    Blazor Hybrid version of our app. Additionally, we incorporated layout and routing
    functionalities in *Chapter 9**, Understanding Blazor Routing and Layout*. As
    a result, our app can now browse and update the password database. However, we
    have not yet implemented the majority of CRUD operations. After refining the Razor
    components in this chapter, we will proceed to add these functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: To navigate the password database, we developed two Razor components – `Items`
    and `ItemDetail`. The `Items` class is employed to exhibit a list of password
    entries and groups within the current group, while the `ItemDetail` class is utilized
    for presenting the content of an individual password entry.
  prefs: []
  type: TYPE_NORMAL
- en: Upon examining the layout of `Items` and `ItemDetail`, as illustrated in *Figure
    10.4*, we can observe that both pages possess a similarity in terms of their appearance
    and overall design.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: UI layout of Items and ItemDetail](img/B21554_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: UI layout of Items and ItemDetail'
  prefs: []
  type: TYPE_NORMAL
- en: The layout of both pages features a sidebar, a header, and a list view. The
    sidebar is defined in the `layout` component, while the header and list view are
    implemented in both `Items` and `ItemDetail` with partially duplicated code. In
    this chapter, we will optimize our code by abstracting the duplicated portions
    into reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two buttons in the header: `Add` and `Back`. The `Back` button allows
    for navigation back to the parent group, while the `Add` button enables the user
    to add a new item or field.'
  prefs: []
  type: TYPE_NORMAL
- en: In the list view item, we can utilize the context menu to execute item-level
    operations, such as editing or deleting. The context menu comprises menu items
    designated for specific actions related to the selected item or field. When performing
    edit or delete CRUD operations, upon selecting a menu item, a modal dialog relevant
    to the chosen action will appear.
  prefs: []
  type: TYPE_NORMAL
- en: In the present implementation, both `Items` and `ItemDetail` incorporate all
    UI elements within a single Razor markup. We will begin to streamline the code
    by breaking it down into smaller, reusable components, which will result in a
    cleaner implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will transform modal dialogs, headers, and list views into
    Razor components. Let’s begin with modal dialogs. To facilitate adding, editing,
    and deleting operations, we require two types of dialog boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Editor dialog: for adding or editing items or fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Confirmation dialog: for confirmation prior to deleting an item or a field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Understanding Blazor Routing and Layout*, we implemented modal
    dialogs by utilizing HTML and CSS code from Bootstrap examples. However, we have
    not examined these elements thoroughly, as our markup files appear lengthy and
    intricate. In this chapter, we will dissect the code and convert it into Razor
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base modal dialog component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve the editor and confirmation dialogs, we can first construct a base
    modal dialog. By leveraging this base modal dialog, we can create either editor
    or confirmation dialogs as needed.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Razor component in the `PassXYZ.BlazorUI` project, right-click
    on the project node and select `Add` -> `New Item…` -> `Razor Component` from
    the project template. Name the Razor component `ModalDialog`, and create a C#
    code-behind file for it. Next, enter the code shown in *Listing 10.1* into `ModalDialog.razor`
    and the code in *Listing 10.2* into `ModalDialog.razor.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI code is derived from the `Items` and `ItemDetail` code found in *Chapter
    9*, *Understanding Blazor Routing and Layout*, as depicted in *Listing 10.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.1: `ModalDialog.razor` ([https://epa.ms/ModalDialog10-1](https://epa.ms/ModalDialog10-1))'
  prefs: []
  type: TYPE_NORMAL
- en: In the markup code displayed in *Listing 10.1*, we observe a typical HTML code
    snippet with Bootstrap styling. We have incorporated C# variables within the HTML
    to construct the component UI.
  prefs: []
  type: TYPE_NORMAL
- en: This base dialog UI comprises a header **(1)** and a body **(4)**. Within the
    header, there is a title **(2)** and a close button **(3)**. The body contains
    a child content area **(5)** and two buttons (**Close** **(6)**/**Save** **(7)**).
  prefs: []
  type: TYPE_NORMAL
- en: For a visual representation of the layout of this base modal dialog, please
    refer to *Figure 10.5:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Base dialog](img/B21554_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Base dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the HTML and CSS code closely resemble the Bootstrap example, we have
    substituted all hardcoded content with C# variables. If we were to use this modal
    dialog component to construct a new component, the following would serve as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the above markup code, we define the modal dialog using the `<ModalDialog>`
    component tag. Each modal dialog is assigned a unique ID for identification purposes.
    We can display the dialog box by clicking a button, wherein the modal dialog ID
    is provided to facilitate its identification.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `<ModalDialog>` component tag, we have assigned values to multiple
    attributes defined in the `ModalDialog` component, including the `ID`, `title`,
    `button text`, `event handler`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than directly assigning a string or data to the attribute of an HTML
    element, we have the option to assign a variable to it. This capability is the
    data binding feature provided by Razor components. In this section, we will explore
    how to use data binding effectively. In data binding, assigning a variable to
    the attribute of a DOM element results in data flow from Razor components to DOM
    elements. Conversely, responding to a DOM event causes data to flow from DOM elements
    to Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can use a Razor component in the same way as a DOM element, the data
    flow between child and parent Razor components resembles the data exchange between
    Razor components and DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can bind the `id` variable to the `Id` attribute of `ModalDialog`,
    managing the button click event using the `OnSaveClicked` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the data flows from the `id` variable to the `Id` attribute
    of `ModalDialog`. When the `OnSaveClicked` event handler is invoked, the data
    flows back from `ModalDialog` to the current context. The `ModalDialog` attributes,
    `Id` and `OnSaveAsync`, are defined in the C# code-behind file. In the following
    section, let’s examine the C# code-behind file of `ModalDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: Component parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Razor components’ attributes can be defined using component parameters. To establish
    component parameters, we need to create public properties adorned with the `[Parameter]`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ModalDialog` class, illustrated in *Listing 10.2*, we declare seven
    component parameters: `Id`, `Title`, `ChildContent`, `OnClose`, `OnSaveAsync`,
    `CloseButtonText`, and `SaveButtonText`. These component parameters can be utilized
    in data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.2: `ModalDialog.razor.cs` ([https://epa.ms/ModalDialog10-2](https://epa.ms/ModalDialog10-2))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters of the `ModalDialog` component are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id` **(1)**: This identifier is used to distinguish a modal dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Title` **(2)**: This represents the title of the modal dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChildContent` **(3)**: This is designated for the insertion of the child component’s
    content. The data type that we’re referring to is a `RenderFragment` delegate,
    which represents a segment of UI content. For more details, please refer to the
    following Microsoft document. We’ll dive deeper into this topic in *Chapter 11*:
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code](https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-8.0#define-reusable-renderfragments-in-code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two event handlers – `OnClose` **(4)** and `OnSaveAsync` **(5)** – are defined
    to manage button click actions. We can customize the text on both buttons using
    `CloseButtonText` **(6)** and `SaveButtonText` **(7)**.
  prefs: []
  type: TYPE_NORMAL
- en: We can handle component parameters similarly to HTML attributes. A C# field,
    property, or method return value can be assigned to the component parameter of
    `ModalDialog`. Once we create the base `ModalDialog` component, we can then develop
    `Editor` and `Confirmation` dialog components using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new modal dialog, `ConfirmDialog`, which will prompt the user
    to confirm the deletion of an item. To create a new `ConfirmDialog` component
    within the `PassXYZ.BlazorUI` project, you can right-click on the project node
    and select `Add` -> `New Item…` -> `Razor Component` from the project template.
    We can name the Razor component `ConfirmDialog` and input the following code provided
    in *Listing 10.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.3: `ConfirmDialog.razor` ([https://epa.ms/ConfirmDialog10-3](https://epa.ms/ConfirmDialog10-3))'
  prefs: []
  type: TYPE_NORMAL
- en: We define the `Id` **(1)** and `Title` **(2)** component parameters in the `ConfirmDialog`
    and pass their values to the base class using data binding. Additionally, we subscribe
    to the `OnSaveAsync` event by utilizing the `OnSave` event handler. We also define
    our own event handler, `OnConfirmClick`, as a component parameter, allowing other
    components to subscribe to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ConfirmDialog`, we actually bind parameters using nested components.
    In this scenario, the data flow should follow the suggested directions:'
  prefs: []
  type: TYPE_NORMAL
- en: Change notifications should move upward through the hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New parameter values should flow downward through the hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The values for the `Id` and `Title` attributes are assigned by the components
    that utilize `ConfirmDialog`, and their values cascade down to `ModalDialog`.
    The `Save` or `Close` button events are initiated within the `ModalDialog` component
    and subsequently propagate upwards through the chain to `ConfirmDialog` and higher-level
    components. Using the `Save` button as an example, the event follows the upward
    direction illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The process begins with the `onclick` event in the DOM. `ModalDialog` defines
    its own event, `OnSaveAsync`, which is activated by the `onclick` event handler.
    `ConfirmDialog`, on the other hand, establishes its own event called `OnConfirmClick`,
    which is initiated by the `OnSaveAsync` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Nested components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConfirmDialog` serves as an example of nested components. As demonstrated,
    we can embed components within other components by declaring them using HTML syntax.
    The embedded components appear as HTML tags, with the tag name corresponding to
    the component type. For instance, we can utilize `ModalDialog` inside `ConfirmDialog`,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Nested components serve as a means to construct a component hierarchy in Blazor.
    In object-oriented programming languages, inheritance and composition are two
    methods for extending and reusing a class. In Blazor, composition is employed
    within nested components to enhance functionalities. Inheritance represents an
    `'is-a'` relationship, whereas composition signifies a `'has-a'` relationship.
    In the case of nested components, the parent component encompasses a child component.
  prefs: []
  type: TYPE_NORMAL
- en: In Microsoft Blazor and ASP.NET Core documents, the terms `"ancestor"` and `"descendant"`
    or `"parent"` and `"child"` are utilized to describe the relationship between
    nested components. In this context, the parent and child relationship is not one
    of inheritance but of composition. A more suitable term could be “outer component”
    or “inner component.” However, to maintain consistency with Microsoft documentation,
    I will not opt for alternative terms in our discussion. Please be mindful that
    when we discuss nested components and data binding, the ancestor and descendant
    relationship represents a `"has-a"` relationship or a composition.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, the `ConfirmDialog` component serves as the outer component,
    while the `ModalDialog` acts as the inner component. The relationship between
    them is such that the `ConfirmDialog` contains the `ModalDialog` within it.
  prefs: []
  type: TYPE_NORMAL
- en: Child content rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When building nested components, there are often scenarios where one component
    sets the content of another component. The outer component supplies the content
    situated between the inner component’s opening and closing tags. In the case of
    `ConfirmDialog`, the content of `ModalDialog` is configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is accomplished by employing a unique component parameter called `ChildContent`,
    which is of the `RenderFragment` type. In the previous code, the `"Please confirm
    to delete @Title?"` string is assigned to the `ChildContent` parameter of `ModalDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConfirmDialog` represents a relatively simple example of nested components.
    Let’s consider another example, `EditorDialog`, to further examine the features
    of Razor components. As previously mentioned, we require two dialog boxes to manage
    add, edit, and delete actions. The `ConfirmDialog` serves to seek user confirmation
    before deleting an item or a field. In order to add or edit an item or a field,
    we need a dialog box equipped with editing capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We can follow the same procedure to create a new component, `EditorDialog`.
    After selecting `Add` -> `New Item…` -> `Razor Component` in the project template,
    we can assign the name `EditorDialog` to the Razor component and create a corresponding
    C# code-behind file. Subsequently, we can input the code from *Listing 10.4* into
    `EditorDialog.razor` and the code from *Listing 10.5* into `EditorDialog.razor.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the Razor markup code of `EditorDialog`, as displayed in *Listing
    10.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.4: `EditorDialog.razor` ([https://epa.ms/EditorDialog10-4](https://epa.ms/EditorDialog10-4))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EditorDialog`, built using `ModalDialog`, is designed for editing key-value
    pairs. There are two use cases we aim to support with this component: creating
    a new key-value pair, where both the key and value are editable, and modifying
    an existing key-value pair, where only the value field may need alteration.'
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate these scenarios, we use a component parameter called `IsKeyEditingEnabled`
    **(1)** to detect the conditions. To create a new key-value pair, the key input
    is rendered as an `<input>` element **(2)**, while to edit an existing key-value
    pair, the key is displayed as the title in the header area. In both cases, the
    value can be edited using a `<textarea>` element `(3)`. This constitutes the core
    functionality of our `EditorDialog` component.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 10.6*, the UI depicts two different dialogs. On the left-hand
    side, a dialog appears when we intend to add a new field, requiring us to input
    the field name and content. Meanwhile, on the right-hand side, a dialog is displayed
    when we aim to edit an existing URL field. The field name is presented in the
    title, and the content can be modified in the `<textarea>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Editing a field](img/B21554_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Editing a field'
  prefs: []
  type: TYPE_NORMAL
- en: In the `EditorDialog` component, when we edit the key and value using the `<input>`
    and `<textarea>` HTML elements, the initial value is displayed. This initial value
    is set from the Razor component to the DOM. Once we make changes, the data flows
    from the DOM back to the Razor component, exemplifying two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two-way data binding can be established using the `@bind` Razor directive attribute.
    This syntax enables an HTML element attribute to bind to a field, property, expression
    value, or the result of a method. In *Listing 10.4*, the value of the `<input>`
    element is bound to the `Key` property within the `EditorDialog` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the case of two-way data binding, the DOM element `<input>` value is updated
    whenever the `Key` property undergoes a change. Similarly, when the user modifies
    the `<input>` value in the DOM, the `Key` property is updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we have the option to replace the `@bind` directive
    attribute with two one-way data bindings, as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Upon rendering our `EditorDialog` component, the value of the `<input>` element
    is derived from the `Key` property. As the user inputs a value into the textbox
    and shifts the element focus, the `onchange` event is triggered, subsequently
    updating the `Key` property with the modified value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `<input>` element, the default event of the `@bind` directive attribute
    is the `onchange` event. We can modify the event using the `@bind:event="{event}"`
    attribute. The `{event}` placeholder should represent a DOM event. For instance,
    we can replace the `onchange` event with the `oninput` event using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Binding with component parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we explored two-way data binding between a Razor component
    and a DOM element. As Razor components can function similarly to DOM elements,
    it is also possible to establish two-way data binding between two Razor components.
    This often occurs when there is a need for communication between parent and child
    components.
  prefs: []
  type: TYPE_NORMAL
- en: We can bind a component parameter of an inner component to the property of an
    outer component using the `@bind-{PROPERTY}` syntax. In this case, `{PROPERTY}`
    refers to the property to be bound. We have explained that the `@bind` directive
    attribute can be replaced by two one-way data binding setups, which involve assigning
    a variable to the `<input>` value attribute and assigning an event handler to
    the `onchange` event. While the compiler can automatically add the event handler
    for `@bind`, it cannot do so for `@bind-{PROPERTY}`. Therefore, we need to define
    our own event of the `EventCallback<TValue>` type to bind with component parameters.
    The event name must follow the `{PARAMETER NAME}Changed` format. To illustrate
    the `@bind-{PROPERTY}` directive attribute’s usage, let’s use our `EditorDialog`
    component as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we utilize the `EditorDialog` in the `ItemDetail` component to
    edit a field, or similarly, in the `Items` component to edit an item. Let’s examine
    field editing as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code of the `ItemDetail` component, we can create data binding
    for `Key` **(1)** and `Value` **(2)** to the `listGroupField` of the `Field` type.
    We need to implement the `{PARAMETER NAME}Changed` events in the C# code-behind
    for `EditorDialog`, as demonstrated in *Listing 10.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.5: `EditorDialog.razor.cs` ([https://epa.ms/EditorDialog10-5](https://epa.ms/EditorDialog10-5))'
  prefs: []
  type: TYPE_NORMAL
- en: In *Listing 10.5*, we utilize the `Key` property as an example to illustrate
    the component parameter binding process. The `Key` property is defined as a component
    parameter with the `[Parameter]` attribute. An associated event, `KeyChanged`,
    is defined as an `EventCallback<TValue>` type. When the text input is modified
    by the user and the element focus shifts, the `Key` property setter is invoked.
    Within the setter of the `Key` property, the `KeyChanged` event is triggered,
    which notifies the outer `ItemDetail` component. Consequently, the linked variable
    `listGroupField.Key` is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with cascading values and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can utilize data binding to transfer data between parent and child components.
    Data binding is effective when passing data to intermediate child components.
    However, there may be instances where we need to pass data to components located
    several levels deep. In such situations, utilizing data binding requires creating
    multiple levels of chained data binding – subsequently increasing the complexity
    as the chained levels expand. For instance, when passing data from `Items` to
    `ModalDialog`, we first need to establish a data binding with `ConfirmDialog`.
    Then, another level of data binding must be created between `ConfirmDialog` and
    `ModalDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Items` component, we need to pass the `Id` of the dialog to `ModalDialog`.
    An `Id` is necessary to identify the specific dialog instance we wish to display.
    As demonstrated below, we define `ConfirmDialog` within the `Items` component.
    The `Id` is defined within `Items` and passed to `ConfirmDialog` through the use
    of component parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `ConfirmDialog` must pass the `Id` to `ModalDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In `ModalDialog`, `Id` is used as an attribute of the `<div>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In order to prevent numerous levels of data binding, we can employ cascading
    values and parameters as a technique to facilitate data flow through a component
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '`CascadingValue` is a component within the Blazor framework. The outer component
    supplies a cascading value by using `CascadingValue`, while the inner component
    can obtain it by employing the `[CascadingParameter]` attribute. To demonstrate
    its usage, we can modify the `Items` component’s code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We utilize cascading values with the `<CascadingValue>` tag. Within the `<CascadingValue>`
    tag, we assign the `_dialogDeleteId` variable to the `Value` attribute and the
    `Id` string to the `Name` attribute. As this `Id` is not directly employed by
    `ConfirmDialog`, the `Id` component parameter can be safely removed from `ConfirmDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ModalDialog`, we modify the `Id` property to be a parameter by utilizing
    the `[CascadingParameter]` attribute instead of a component parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with just one cascading value, specifying its name is not mandatory,
    as the compiler can locate it by data type. However, to prevent ambiguities, we
    can assign a name to the cascading value using the `Name` attribute. Next, we
    will examine the final modifications in the `Items` component, which employs cascading
    values for both `ConfirmDialog` and `EditorDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated, after implementing a cascading value, `ConfirmDialog` and `EditorDialog`
    no longer need to handle the `Id` field directly. Consequently, the code is more
    compact compared to the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the creation of reusable components. Some Razor
    components might rely on data or network services, necessitating additional steps
    during their creation or destruction. We can accomplish these actions as part
    of the lifecycle management of Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, let us examine the lifecycle of Razor components in
    greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Razor component lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Razor component, like any other object, possesses a lifecycle. It consists
    of a series of synchronous and asynchronous lifecycle methods that developers
    can override to perform additional operations during component initialization
    and rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to *Figure 10.7* for an overview of the Razor component lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Razor component lifecycle](img/B21554_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Razor component lifecycle'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 10.7*, it is evident that we have the ability to add hooks during
    both the initialization and rendering phases. The methods listed below can be
    overridden to capture initialization events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetParametersAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnInitialized` and `OnInitializedAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnParametersSet` and `OnParametersSetAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetParametersAsync` and `OnInitializedAsync` are invoked only in the first
    render. `OnParametersSet``Async` is called every time a parameter is changed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods can be overridden to customize rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ShouldRender`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnAfterRender` and `OnAfterRenderAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will examine these lifecycle methods in detail and demonstrate how they can
    be utilized in our code.
  prefs: []
  type: TYPE_NORMAL
- en: SetParametersAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SetParametersAsync` is the first hook after the object is created and it has
    the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `ParameterView` parameter encompasses component parameters or cascading
    parameter values. `SetParametersAsync` assigns values to each property with either
    the `[Parameter]` or `[CascadingParameter]` attribute. This function can be overridden
    to incorporate any logic that must be executed before setting the parameters.
    The subsequent hook following `SetParametersAsync` is `OnInitializedAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: OnInitialized and OnInitializedAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OnInitialized` and `OnInitializedAsync` are invoked when the component is
    initialized. They have the following signatures, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By overriding these two functions, we can incorporate logic to initialize our
    component at this stage. However, keep in mind that these functions are called
    only once, immediately following the component’s creation. For resource-intensive
    initialization tasks, asynchronous methods can be employed, such as downloading
    data via RESTful API calls. As illustrated in *Figure 10.7*, once an asynchronous
    method is completed, the DOM necessitates re-rendering.
  prefs: []
  type: TYPE_NORMAL
- en: OnParametersSet and OnParametersSetAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When component parameters are set or modified, `OnParametersSet` and `OnParametersSetAsync`
    are invoked. We observe that there are two versions to accommodate both synchronous
    and asynchronous scenarios. The asynchronous version, `OnParametersSetAsync`,
    can be employed to manage time-consuming tasks. Upon completion of the asynchronous
    task, the DOM must be re-rendered to display any updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods have the following signatures, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These two methods are invoked whenever component parameters or cascading parameters
    change and may be called multiple times. In contrast, `OnInitializedAsync` is
    called only once.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in *Figure 10.7*, the DOM can undergo multiple renderings during
    the initialization phase, resulting in the invocation of asynchronous calls. The
    methods involved in this rendering process include `ShouldRender` and `OnAfterRenderAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: ShouldRender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ShouldRender` method returns a Boolean value, indicating whether the component
    ought to be rendered. As illustrated in *Figure 10.7*, the first render disregards
    this method. Consequently, a component must be rendered at least once. This method
    possesses the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: OnAfterRender and OnAfterRenderAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OnAfterRender` and `OnAfterRenderAsync` are invoked after a component has
    completed its rendering process. Their respective signatures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These methods can be utilized to execute supplementary initialization tasks
    with the rendered content, such as invoking JavaScript code in the component.
    This method features a Boolean `firstRender` parameter, enabling us to attach
    JavaScript event handlers only once. Although there is an asynchronous version
    of this method, the framework does not schedule another render cycle upon the
    completion of the asynchronous task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine the impact of lifecycle methods, we can conduct a test by incorporating
    all lifecycle methods into the `ConfirmDialog` component, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have overridden all lifecycle methods in `ConfirmDialog` and added debug
    output to display the progress. Upon launching our app, we can observe the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is displayed when we first launch our app and the `Items`
    page appears. We can observe that the `Id` cascading parameter is not set before
    the `SetParametersAsync` method is called. Since we have overridden the asynchronous
    methods, multiple render cycles are scheduled to occur simultaneously. As a result,
    the `ShouldRender` and `OnAfterRenderAsync` methods are invoked multiple times
    due to parallel rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s consider another case, which occurs when we click on the context
    menu on the `Items` page. Upon clicking on the context menu of an item, such as
    a Google icon, the `ConfirmDialog` is initialized once more. The resulting output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `SetParametersAsync` method is called again, since the `Title` component
    parameter has been changed. In the subsequent calls, we can observe that the `Title`
    component parameter is set to `Google`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we use `OnParametersSet` to load the list of items in `Items.razor.cs`,
    as well as to load a list of fields in `ItemDetail.razor.cs`. Let’s examine `OnParametersSet`
    in `ItemDetail.razor.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**(1)** In `OnParametersSet`, we check whether the `SelectedItemId` component
    parameter is `null`. This represents the `ID` of the selected item. **(2)** If
    it is not null, we can locate the item by calling the `IDataStore` method named
    `GetItem`. **(3)** Once we obtain the instance of the selected item, we can retrieve
    a list of fields by invoking the `GetFields` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `OnParametersSet` in `Items.razor.cs` is quite similar
    to this. For more details, you can refer to the following GitHub link: [https://epa.ms/Items10-6](https://epa.ms/Items10-6).'
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have developed a near-complete password manager app, with its UI
    built using Blazor. We have established reusable modal dialog components to accommodate
    the context menu, enabling us to perform CRUD operations. The final component
    we need to address is the actual implementation of these CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After preparing the modal dialogs for CRUD operations, as discussed in the previous
    sections, we can now proceed to implement these CRUD operations in this section.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations of items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add or update an item, we can utilize the `UpdateItemAsync` method in `Items.razor.cs`
    to accommodate both scenarios. To distinguish between creating a new item and
    updating an existing one, we define a private `_isNewItem` field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll see how to add or edit an item.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a new item, simply click the `+` button located in the header of the
    `Items` page, as depicted in *Figure 10.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Adding a new item](img/B21554_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Adding a new item'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Razor markup of this page header can be reviewed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The page header features the `Back` button **(1)**, the `Title` **(2)**, and
    the `Add` button **(3)**. The `Back` button is displayed only when there is an
    existing parent link.
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking the `Add` button, a modal dialog with an `Id` defined in the `_dialogEditId`
    variable will be displayed. The `onclick` event handler sets `_isNewItem` to true,
    allowing the modal dialog event handler to recognize that the action is intended
    to add a new item.
  prefs: []
  type: TYPE_NORMAL
- en: Editing or deleting an item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To edit or delete an item, click on the context menu found on the item, as
    demonstrated in *Figure 10.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Editing or deleting an item](img/B21554_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Editing or deleting an item'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking the context menu button, a list of menu items will be displayed.
    Let’s examine the markup for the context menu found in `Items.razor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding markup code, a context menu button **(1)** is defined. Upon
    clicking this button, two menu items, `Edit` **(2)** and `Delete` **(3)**, will
    appear. As the context menu markup code runs within a `foreach` loop, we need
    to obtain a reference to the selected item for editing or deletion. In the C#
    code-behind logic, the `listGroupItem` variable is employed to reference the selected
    item.
  prefs: []
  type: TYPE_NORMAL
- en: We can capture this reference through the `onclick` event handler of the context
    menu button.
  prefs: []
  type: TYPE_NORMAL
- en: Upon selecting the `Edit` menu item, it is crucial to set the `_isNewItem` variable
    to `false`. This adjustment allows the event handler of the modal dialog to discern
    that we are modifying an existing item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having completed all the previous setup, it’s time to examine the event handler
    in modal dialogs. First, let’s take a look at the `UpdateItemAsync` event handler
    within `Items.razor.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `UpdateItemAsync` event handler can manage both adding and editing an item.
    It checks the `_isNewItem` variable **(1)** to determine whether we aim to add
    or edit an item. Subsequently, it calls `IDataStore` methods to perform either
    addition or update actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine the event handler for deleting an item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the `DeleteItemAsync` event handler, the item is simply removed from the
    list, and the `IDataStore` methods are called to execute the delete action.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations of fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CRUD operations for fields resemble those we implemented for items. To
    add or update a field, we can employ the `UpdateFieldAsync` method in `ItemDetail.razor.cs`
    to manage both scenarios. To determine whether we aim to create a new field or
    update an existing one, we define a private `_isNewField` field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The UI for CRUD operations also bears similarity to what we discussed in the
    previous section. To view the `Add` button and context menu items, please refer
    to *Figure 10.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: Add, edit, or delete a field](img/B21554_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Add, edit, or delete a field'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can examine the Razor markup code for the page header found in `ItemDetail.razor`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As we can observe, the preceding source code is quite similar to the one found
    in `Items.razor`, with the exception of replacing the `_isNewItem` variable with
    `_isNewField`. We can consider refining this page header into a reusable component
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the previous section, let’s now examine the source code for the
    list group and context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding source code of `ItemDetail.razor` features a context **Menu**
    button **(1)** and three buttons for the **Add** **(2)**, **Edit** **(3)**, and
    **Show** **(4)** menu items. You may have noticed that the source code is quite
    similar to that in `Items.razor`, encompassing a list group and a context menu.
  prefs: []
  type: TYPE_NORMAL
- en: We will further develop this into a reusable component later in this chapter.
    The variation in the context menu lies in the addition of a menu item that displays
    or conceals a field, if it is a protected field such as a password. We utilize
    the `onclick` event handler, `OnToggleShowPassword`, to set the `IsHide` field
    property, thereby toggling the visibility of the password field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s examine the event handlers for modal dialogs in `ItemDetail.razor.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `UpdateFieldAsync` event handler manages both the addition and editing of
    a field. It receives two parameters – `key` and `value` – which are passed from
    the modal dialog and are used to set the field of `listGroupField`. By examining
    the `_isNewField` variable, the handler determines whether the intent is to add
    or edit a field. Subsequently, it calls `IDataStore` methods to execute the add
    or update actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a field, the `DeleteFieldAsync` event handler below is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the `DeleteFieldAsync` event handler, we simply remove the field from the
    selected item and invoke the `IDataStore` method to update the database.
  prefs: []
  type: TYPE_NORMAL
- en: Having implemented CRUD operations, we have now successfully completed the implementation
    of password manager features. We have developed a new version of the password
    manager app utilizing Blazor UI. The distinction between this version and the
    one described in *Part 1* of this book lies in our use of Blazor to construct
    all user interfaces. The appearance and functionality of the Blazor UI closely
    resemble web apps, while the XAML UI maintains the characteristics of native apps.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have successfully implemented all the required functionalities,
    we can observe some duplicated code in our current implementation. To resolve
    this issue, we can refactor our code, transforming the duplicate sections into
    Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Razor components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the current implementation, we can observe that most of the duplicated code
    is found in the `Items` and `ItemDetail` pages. Throughout the remainder of this
    chapter, we will transform this duplicated code into Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Navbar`: This component displays a navigation bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dropdown`: This component supports a context menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`: This component displays a list of items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ListView` component is the most complex one, so we will address it at the
    end of this section. For now, let’s focus on the `Navbar` and `Dropdown` components
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Navbar component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine the navigation bar UI in *Figure 10.11*. We can observe that
    the navigation bar features a **Back** button, a **Title**, and an **Add** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Navigation bar](img/B21554_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Navigation bar'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, **(1)** the `Back` button is displayed when a parent
    link is present. **(2)** The `Back` button is implemented using an `<a>` tag.
    **(3)** The `Title`, as a string, appears within the `<h1>` tag. **(4)** The `Add`
    button is implemented using a `<button>` tag. The styling of both the `Back` and
    `Add` buttons employs Bootstrap formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform the preceding code into a Razor component, we can generate a new
    Razor component in the `PassXYZ.BlazorUI` project and name it `Navbar`. The `Navbar`
    component will display the UI elements illustrated in *Figure 10.11*, including
    a `Back` button, a title, and an `Add` button. In order to separate the UI and
    logic, we will create both a `Navbar.razor.cs` C# code-behind file and the Razor
    markup, `Navbar.razor`. We will define component parameters and event handlers
    in the C# code-behind file, as demonstrated in *Listing 10.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.6: `Navbar.razor.cs` ([https://epa.ms/Navbar10-7](https://epa.ms/Navbar10-7))'
  prefs: []
  type: TYPE_NORMAL
- en: In `Navbar`, there are four component parameters and an event handler defined.
    We can assign the parent link for the `Back` button using the `ParentLink` parameter
    **(1)**. The value of `Title` is set according to the `Title` parameter **(3)**.
    For the `Add` button, it is necessary to provide an `Id` and an event handler
    for the dialog box; hence, the `DialogId` **(2)** and `OnAddClick` **(4)** parameters
    are utilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us examine the Razor file of `Navbar`, presented in *Listing 10.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.7: `Navbar.razor` ([https://epa.ms/Navbar10-8](https://epa.ms/Navbar10-8))'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe that the code closely resembles the code used in `Items` and
    `ItemDetail`. The key difference is that we have substituted hardcoded values
    with component parameters (`ParentLink` **(1)**, `DialogId` **(2)**, `Title` **(3)**,
    and `OnClickClose` **(4)**). With the integration of this new `Navbar` component,
    we can modify the code in `Items` by employing the `Navbar` component, as demonstrated
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then proceed to replace the code in `ItemDetail` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As observed, we have streamlined the code by eliminating duplications, resulting
    in a more elegant and concise presentation.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed the work for the `Navbar`, let us now shift our focus to the
    `Dropdown` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Dropdown component for the context menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To develop a component akin to the context menu, we can reuse the Bootstrap
    `Dropdown` component. As illustrated in *Figure 10.12*, a context menu comprises
    a context menu button and a list of menu items. Upon clicking the context menu
    button, users are presented with a display of menu items.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Context menu](img/B21554_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Context menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'The present code for the context menu is replicated in both the `Items` and
    `ItemDetail` pages, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `Dropdown` component of Bootstrap comprises a button and an unordered list.
    We must define an event handler for the button to perform the necessary action.
    In the previous code, we set the `item` variable to `listGroupItem`. Regarding
    the menu items, each is implemented as a `<button>` tag and accepts a dialog ID
    and an event handler as parameters. When a menu item is clicked, the corresponding
    modal dialog will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: We can create two new Razor components in the `PassXYZ.BlazorUI` project, named
    `Dropdown` and `MenuItem`. To separate the UI and logic, we can implement them
    in the C# code-behind file (*Listing 10.9*) and the Razor file (*Listing 10.8*),
    which we will demonstrate now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first examine the `Dropdown` component UI in Listing 10.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.8: `Dropdown.razor` ([https://epa.ms/Dropdown10-9](https://epa.ms/Dropdown10-9))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Dropdown` component, we define a button **(1)** and an unordered list
    **(2)**. The button’s click event is set up as an `OnClick` event handler. The
    items within the unordered list appear as child content of the `Dropdown` component.
    The component parameters can be found in the C# `Dropdown.razor.cs` code-behind
    file, as shown in *Listing 10.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.9: `Dropdown.razor.cs` ([https://epa.ms/Dropdown10-10](https://epa.ms/Dropdown10-10))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Dropdown.razor.cs`, two component parameters `OnClick` **(1)** and `ChildContent`
    **(2)** are defined. The `MenuItem` component can be presented as the child content
    of the `Dropdown` component. The UI code for `MenuItem` can be observed in *Listing
    10.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.10: `MenuItem.razor` ([https://epa.ms/MenuItem10-11](https://epa.ms/MenuItem10-11))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MenuItem` component specifies three component parameters: `Id`, `OnClick`,
    and `ChildContent`. These parameters are defined within `MenuItem.razor.cs`, as
    demonstrated in *Listing 10.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.11: `MenuItem.razor.cs` ([https://epa.ms/MenuItem10-12](https://epa.ms/MenuItem10-12))'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The `Id` parameter is employed to designate the dialog ID when a menu
    item is clicked. **(2)** `OnClick` is utilized to register an event handler for
    a button click event. **(3)** `ChildContent` serves to display child content,
    such as the name of the menu item.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have successfully implemented the components for the context menu. Now,
    we can replace the redundant code in the `Items` and `ItemDetail` pages with these
    context menu components. The implementation of the context menu on the `Items`
    page proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `ItemDetail` page, the context menu is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Following the refinement of the code for the `Items` and `ItemDetail` pages,
    we have implemented modal dialogs, navigation bars, and context menu components.
    Consequently, the code appears significantly more elegant and concise. Nevertheless,
    there is still potential for further refinement. The main UI logic in both the
    `Items` and `ItemDetail` pages revolves around a list view. We can optimize this
    part of the code by implementing a `ListView` component. In order to create a
    `ListView` component, we will need to utilize an advanced feature known as templated
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Using templated components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In constructing a Razor component, component parameters serve as the communication
    channels between parent and child components. While discussing nested components,
    we brought attention to a special `ChildContent` component parameter of the `RenderFragment`
    type. This parameter enables the parent component to set the content of the child
    component. For instance, the content of `MenuItem` in the following code can be
    assigned an HTML string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We are able to achieve this as `MenuItem` defines the following component parameter,
    which can be observed in *Listing 10.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to explicitly specify the `ChildContent` parameter, we can achieve
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`ChildContent` is a unique component parameter that can be implicitly used
    in markup language. To utilize `ChildContent`, we create a component capable of
    accepting a UI template of the `RenderFragment` type as its parameter. Furthermore,
    we can define multiple UI templates as parameters when developing a new component.
    Components of this nature are referred to as templated components.'
  prefs: []
  type: TYPE_NORMAL
- en: A render fragment, of the `RenderFragment` type, signifies a portion of the
    UI designated for rendering. Furthermore, there is a generic version, `RenderFragment<TValue>`,
    which accepts a type parameter. A specific type can be provided when invoking
    `RenderFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ListView component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a `ListView`, we need to utilize multiple UI templates as component
    parameters. We can create a new Razor component within the `PassXYZ.BlazorUI`
    project and name it `ListView`. Similar to what we did for `Navbar` and the context
    menu, we can separate the UI and code into a Razor file (*Listing 10.12*) and
    a C# code-behind file (*Listing 10.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.12: `ListView.razor` ([https://epa.ms/ListView10-13](https://epa.ms/ListView10-13))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ListView` Razor file, we define three UI templates, `Header` **(1)**,
    `Row` **(2)**, and `Footer` **(3)**. We render the `Header` and `Footer` similarly
    to `ChildContent`, but the `Row` component parameter appears distinct. The rendering
    process for the `Row` component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can render it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We render it with an `item` argument. The type of `Row` is `RenderFragment<TValue>`,
    as we demonstrate in *Listing 10.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10.13: `ListView.razor.cs` ([https://epa.ms/ListView10-14](https://epa.ms/ListView10-14))'
  prefs: []
  type: TYPE_NORMAL
- en: We define the `ListView` as a generic `ListView<TItem>` type with the `TItem`
    type parameter. In the `ListView` component, we can specify a list view header,
    using the `Header` **(1)** parameter, and a footer, using the `Footer` **(4)**
    parameter. The `ListView` can be bound to any data collection of the `IEnumerable<TItem>`
    type via the `Items` parameter **(3)**. The `Row` **(2)** parameter can be employed
    to establish the UI template for an individual item within the `foreach` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ListView component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, let’s examine the usage of the `ListView` component in the `Items`
    and `ItemDetail` pages. We will use the `ItemDetail` page as an example for our
    discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have defined `Header`, `Row`, and `Footer` as optional parameters, there
    is no obligation to specify all of them. In the `ItemDetail` page, we utilize
    `Row` and `Footer`. **(1)** First, we need to pass the list of fields to the `Items`
    parameter. **(2)** In the `foreach` loop, each field is passed to the `ListView`
    as an argument for the `Row`, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `"field"` value of the `Context` property is employed to specify the argument
    for `Row`. Within the UI template of `Row`, we showcase the key value of `field`
    and establish a context menu using the `Dropdown` and `MenuItem` components, which
    were implemented in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing the `ListView` component, we have significantly enhanced the implementation
    of the `ItemDetail` page. This improvement was achieved through the creation of
    our own Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed the refactoring of our code, we have concluded the introduction
    of the `.NET MAUI Blazor Hybrid` app. In Part 2, we recreated our app using Blazor
    while maintaining the same functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience in Blazor web app development, you may not see too much
    difference between the Blazor Hybrid app and the Blazor web app. This is precisely
    the advantage of the Blazor Hybrid app. You may now be wondering, how do we access
    a native API in a Blazor Hybrid app? Let’s have a brief overview in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a native API from Blazor Hybrid apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to accessing native APIs, there isn’t a significant difference
    between .NET MAUI apps and Blazor Hybrid apps. As we learned in *Chapter 7*, *Using
    Platform-Specific Features*, it’s vital to always create an abstract layer that
    encapsulates native access at the platform layer. Hence, we’re not directly accessing
    native APIs from cross-platform code in .NET MAUI or Blazor Hybrid apps. In our
    app, while we do need to access native APIs, we will access a native API through
    an abstract layer.
  prefs: []
  type: TYPE_NORMAL
- en: Access to platform APIs from .NET has seen significant evolution over time,
    transitioning from Xamarin plugins to the unified NuGet dependency presented by
    Xamarin.Essentials. As discussed in *Chapter 7*, *Using Platform-Specific Features*,
    Xamarin.Essentials aimed to standardize all native access within a single library.
    Initially, the plan with .NET MAUI was to migrate everything as .NET MAUI Essentials.
    However, the .NET MAUI team later realized that breaking it down into more logically
    granular namespaces, such as `Microsoft.Maui.Storage` or `Microsoft.Maui.Devices`,
    and so on, made more sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, we access platform-level APIs in the classes defined in the `Services`
    folder, such as `LoginService.cs`. For example, we defined a property, `IsPrivacyNoticeAccepted`,
    in `LoginService` to store whether the user has accepted the privacy notice or
    not. We use a `Preferences` API to store the data in platform-specific persistent
    storage. `Preferences` APIs are defined in the `Microsoft.Maui.Storage` namespace,
    as we can see from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: APIs such as `Preferences` are provided by Microsoft as part of .NET MAUI libraries.
    If we find something that is not supported by Microsoft APIs, we have to create
    our own plugins or use plugins provided by the community. Please refer to *Chapter
    7* about how to create and use .NET MAUI plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained the process of creating Razor components. We covered
    topics such as data binding and the component lifecycle. Subsequently, we developed
    a set of modal dialog components to optimize our code. By utilizing Razor components,
    we can eliminate duplicate code and enhance the UI design. We incorporated CRUD
    operations within the event handlers of modal dialogs. As a result, we now have
    a new version of the password manager app.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent chapter, we will transition to *Part 3* of this book. In *Part
    3*, we will introduce the implementation of unit tests and the process of publishing
    a .NET MAUI application to app stores.
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 40% discount code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_a_review_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
