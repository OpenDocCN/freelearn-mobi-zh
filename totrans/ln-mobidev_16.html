<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Scaling Strategies</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn what determines your app's scalability and what you need to do for it to scale well. You will also learn when scaling will become important and what elements will influence your scaling strategy. When you just get started, the scale is not important at all. In fact, we did tell you earlier to do things that do not scale. So, what made us change our mind? Nothing really. It is still important to prove your hypotheses and, until that is done, it would be a waste of time to make your app scale. However, what is important is that you should think about the scalability of your app and what your strategy will be in case your app becomes very popular and starts to grow quickly. Now, it is perfectly fine that your app backend can handle only one hundred simultaneous connections. But your app backend also needs to be capable of handling thousands of simultaneous requests, if not more. Not being able to scale things quickly leads to downtime, which leads to sad users, which in turn leads to a large churn percentage. People walk away and, instead of steady growth, your short moment of fame will be gone. This would be even a bigger waste. So, we need a plan and this chapter will help you to define this plan.</p>
<p>Specifically, in the chapter, we will cover the following topics:</p>
<ul>
<li>Learn why it is important to make your app able to scale</li>
<li>Determine when and how to scale your app and how analytics can help</li>
<li>Find out what you need to do to have a scalable backend</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Make it scalable but do not scale it right away</h1>
                </header>
            
            <article>
                
<p>In the real world, the definition of scalability may vary from culture to culture, but for your app it is important that it is responsive and functional in the most common circumstances.</p>
<p>If you foresee any issues at a given moment in time, it is time to scale up; but the key element here is that being able to scale up quickly is more important. Make sure that you can do the right things when there is momentum!</p>
<p>So, you made an app and it has been shown on a site such as Product Hunt or Betalist. You have some enthusiastic early adopters for an audience. As an early-stage startup company, you should not care too much about how well your app scales, but you should have an idea on how to make it scale if your audience suddenly becomes larger than expected.</p>
<p>Scalability is not just about the backend solution for your app. It is also about to what extent it is possible to automate the services for your app and how easy it will be to serve any amount of app users. Only when your app services can be near 100% automated, <span>will</span> you have a really scalable solution. Anything that requires your personal, or other people's attention, prevents your app from being fully scalable. The more support your app requires, the less scalable it will be.</p>
<p>The scalability of your app could also be limited by the nature of your app and its targeted audience. A game app: Flappy Bird, for example, can by definition be very scalable. It has no backend and the game is distributed by the App Store or Play Store. For things such as leaderboards, you can use the Google or Apple services. You can trust that these services are scalable. A social app will be harder to scale because it requires that you have a (complex) backend solution. Although it is distributed via the stores, your users need to be able to download and upload streams of data that not just involve text, but also images and video. Your server should be capable of handling that load.</p>
<p>All of it needs to be stored somewhere and it needs to be delivered quickly. Also, moderation, although it can be automated to a large extent, becomes more important when user-generated content comes in. Moderation requires manual intervention that will have an effect on the scalability of the app. Other apps, such as Uber, come with other (non-technical) challenges. They need to deal with all kinds of regulations that also require manual interaction. Anything that requires manual interaction can threaten the scalability of your solution. Once your hypotheses are proven and your app starts to grow, it is important to automate as many components of your app as possible.</p>
<p>If you need more staff, you can hire more people, of course. However, automation is better. In this chapter, we will focus in particular on the technical scalability of an app. When the distribution of the app itself is taken care of by the Play Store or App Store, there is no need to have a strategy. The stores can distribute these apps as often as you want without the need to worry about scaling. Well, this is why they charge 30% (for paid apps), right? Discussing the scalability of your app is relevant if your app will use some kind of backend. For example, you might use a backend to share stories, images, videos, or whatever.</p>
<p>Let's say that you have created a first MVP for your app. The MVP itself is not an app yet. It is just there for validation. Imagine that through a website or email, you obtain user input that requires some kind of processing. As we have seen in previous chapters, it is perfectly fine to have a concierge service. You will be doing the process partly or completely manually. True, that does not scale, but why would you automate the process if you do not know yet if it is going to work out?</p>
<p>If your MVP does work as expected, it will result in a few happy customers. You have proven your hypotheses and you can start to automate the process. You actually built an app and created the backend for it. You stored all data (texts, images, and video) on a single server. If this went well, there will be more happy customers. And then, your app gets featured in the App Store or a very influential early adopter writes a blog about your app and it goes Boom! Suddenly a lot of people start using your app and smoke is coming out of your server(s). You quickly need to come up with a solution before things start to slow down or before they stop working. You need to prevent people from becoming disappointed or your momentum will be gone. You can add a couple of extra servers and think of some smart load-balancing solution, but, on the other hand, you could save yourself a lot of trouble if you start to utilize cloud services, running on, for example, Amazon or Azure from the beginning.</p>
<div class="packt_infobox">If you think it won't go that fast, then consider this: If you do not expect your app to go Boom! then why bother building it in the first place? Even pet projects can suddenly become very popular!</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="299" src="assets/1bdaba72-6279-48fc-af4f-6e850718d183.png" width="610"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A scalable backend</h1>
                </header>
            
            <article>
                
<p>Depending on your particular situation, a mobile backend solution may have to deal with these situations:</p>
<ul>
<li>Database and load balancing the database tier</li>
<li>Web server and load balancing</li>
<li>Reducing the amount of data that goes 'over the line' (low bandwidth support)</li>
<li>Storage of media (images, video, and audio)</li>
<li>Content delivery (video streaming)</li>
</ul>
<p>Cloud storage space is pretty affordable nowadays and, with most solutions, you just need to click a few buttons to scale up (and spend a little bit more money). So, why not use cloud services right from the start? If you have the skills and the time, you can build your own solution and run it on the (scalable) cloud using an Infrastructure-as-a-Service (IaaS) solution such as AWS or Azure. If you do not have the skills or time, you can also choose to use a Mobile Backend as a Service (MBaaS). The latter will be less flexible and it will be more costly, but no matter which one you choose, both services will be scalable without too much effort on your side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud-based storage and processing</h1>
                </header>
            
            <article>
                
<p>Run your app backend solution and store your data in the cloud, for example at:</p>
<ul>
<li>Amazon (Amazon Web Services and Amazon Storage Service, S3 for example)</li>
<li>Google (App Engine, Cloud Storage, Cloud Datastore, and Cloud SQL)</li>
<li>Azure (Virtual server, databases, storage, and content delivery)</li>
<li>Heroku</li>
</ul>
<p>Most of these solutions offer at least these components:</p>
<ul>
<li>Virtual servers</li>
<li>Databases</li>
<li>Storage of media (images and video)</li>
<li>Content delivery (video)</li>
</ul>
<p>Things that will have an influence on what service to use are pricing, specific needs, database support, database type (NoSQL versus SQL), and the programming language that is most convenient for you or your team. Also, the ease of use and the pricing for push notification services are important to evaluate. The programming languages that you can use vary from cloud solution to cloud solution. Google App Engine is a better choice for Java developers, and .NET believers better deploy their solution in the Azure Cloud.</p>
<p>Most cloud solutions offer multiple programming environments. If you want to do Java on Heroku, or Node.js on AWS or Azure, then you can do so. All solutions support Java, PHP, Python, and Ruby programming languages. Azure and Amazon both support .NET but Azure will probably be the preferred choice here. Go is supported by all of them, except Amazon:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="314" src="assets/2616c4c1-3dc4-4522-966b-b127cc110fa6.png" width="240"/></div>
<p>If you prefer to go for a ready-made backend solution, such as Firebase and Parse server, please check out <a href="f05cc1f7-9372-486a-b2ea-4fe6f4a5d69f.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Cloud Solutions for App Experiments</em>. An MBaaS is convenient and to a particular extent just as scalable, but convenience comes with a price. You start with a freemium plan, but when you need to scale up to a premium plan, it is often more expensive than developing your own cloud solution. Another pitfall can be that it could lead to a vendor lock-in more than would be the case otherwise. However, if you need an extra database or an extra server for storage or to process data, it is easy to scale things up, but the same applies to IaaS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Seen from a client perspective</h1>
                </header>
            
            <article>
                
<p>Let's look at an example. From the perspective of a client (here, an Android app) the architectural picture could look as shown in the following figure. From some endpoint, the API is being consumed. This will result in receiving data that will be handled by the Retrofit client (HTTP client for Android) in this example. It consumes data in the <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) format and eventually changes this data into objects using a JSON converter, such as Gson library, a library capable of doing object mapping on JSON data. Often an SDK is available from the party offering the service, which will make it faster and easier to consume data from the endpoint or to send data to it. The Parser Server SDKs, for example, will take care of object mapping and data synchronization from and to the Parse server. As you can see here, it does not really matter to your Android or iOS app what the structure of the backend will look like and where it is hosted. For the client side, all that matters is the interface, which, in this example, is a REST API delivering JSON data on request:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="217" src="assets/084d051c-0c59-4bc1-957c-1eabef8bb6f2.png" width="408"/></div>
<p>Things are not always as ideal as in this preceding image. If you are developing an app that is getting its data from an endpoint that originally was intended to use with a website or another non-mobile solution, you might need to create a middleware solution first. Mobile scalability also means that you need to deal with low bandwidth circumstances. It is important to limit the amount of data in a single transaction as much as possible. Anything that is not instantly needed to be displayed in your app should not be in there. Your app should download thumbnails instead of downloading images or videos; it should have a paging mechanism (<span class="packt_screen">Load More</span> options) and the data should be optimized for use on a device that may have a low bandwidth connection.</p>
<p>The following picture nicely demonstrates the difference between a non-optimized and an optimized situation for mobile usage:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="367" src="assets/b4eae3c6-da6b-43b2-b360-e2846f90f54a.png" width="276"/></div>
<p>Instead of loading the whole dataset in JSON with large and descriptive names, you should load the smallest amount of data possible and persist it on the device for caching purposes. Even with low-bandwidth conditions, and even if you do not have an internet connection, your app will remain responsive and usable. For further optimization, your app should retrieve thumbnails first. It makes no sense to download hi-res images if your user only sees a small picture of it. Also, your (middleware) solution should allow your app to retrieve the app in chunks. Have a look at the Facebook app for example. It only loads a part of the stream, and when you scroll down (some apps have a <span class="packt_screen">Load More</span> button for this at the bottom of the list), it loads another section of the data. If you are building things from scratch and you go for a mobile-first strategy, then this paging mechanism is something you need right away. If the current API is intended for non-mobile use, you should consider creating a middleware solution first to optimize the data stream.</p>
<p>A well scalable app comes with an improved user experience and better reliability, and will be easier to leverage particular events. Think of holidays or particular happenings that, depending on the type of app, could all heavily influence the amount of traffic involved with your app. A scalable app backend should be easy to scale up, allowing you to deliver what is needed during peak hours/day. It should also allow you to scale down at other moments to avoid wasting resources when they are not utilized.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">You should know when you need to scale up or to scale down</h1>
                </header>
            
            <article>
                
<p>If you are using analytics the right way, you will know when to up or to downscale your solution. Seasonality and also the nature of your app can help to make some forecasts here. At what time of the day or during what specific events will your app be used the most, or when will your users be using the app less? For example, if your app is an alarm clock, people will use it less during the holiday season. Also, if your app is related to the Olympic Games you can expect a peak usage during that event. During holidays, people often spend more money in the App Store, resulting in additional downloads and app usage. Finally, campaigns, certainly when you are offering your app at a lower price, will have a heavy impact on your app's usage rates. Other events are much harder to predict. What if your app gets featured and grows 150% a day? You better be prepared for it.</p>
<p>The number of users says something about the number of simultaneous users. That last number is what is really important for scaling your app backend. You can have ten million users that are using your app regularly or you can have ten million users that are using your app every day. One is quite different from the other. Metrics can tell you something about the average time spent in the app in a particular time frame. If you have an international app, it is important to segment this by time zone. Your users may use your app all day long but (maybe) not while they are sleeping.</p>
<p>Anyhow, it is important to realize that it is okay if your app does not scale yet or if it only supports a small number of (concurrent) users as long as it can be scaled up relatively easily. Do not scale because your app needs to be scalable. You need to be prepared to do the right things when necessary, but also do not put too much effort in it. Perfectionism has killed many great projects. Do not let that happen to you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A real horror story about an app backend that did not scale</h1>
                </header>
            
            <article>
                
<p>Low bandwidth can create a poor user experience even with caching and keeping data consumption to a minimum, but some things are outside your control. On the other hand, a totally overloaded backend is something that you have control over to a certain level. Your users judge the total app experience. This is why the whole architecture matters.</p>
<p>Here is an example to illustrate this point. A while ago, I was working on an Android SecondScreen app for a well-known international TV show. A <strong>Non Disclosure Agreement</strong> (<strong>NDA</strong>) prevents me to tell you which one, but it does not really matter to the story. Anyhow, the show was broadcasted on television. The people watching the show at home were able to give their votes for the various candidates that appeared on the show. Due to this, it was easy to predict that there would be a lot of traffic at the time the show was broadcasted. So, when asking the third party that was developing the backend of the app about the scalability of their solution, they told me that they could guarantee that at least 100K users could use the use the app while watching the show. I was naïve not to ask them if they did some proper load testing at their end. I just assumed that they were a professional company. Unfortunately, they turned out to be not so professional.</p>
<p>When the show's new season started and people began to use the app for the first time, something went horribly wrong during the first broadcast. The first 30 minutes went fine and about 40K users were using the app actively by voting. Then, the app stopped working in most cases and it became very hard to vote. The reason for this was that the backend could not handle the large traffic load. Although it was not the frontend (the app) to blame instead of the backend, from the user's perspective it was the app that sucked. The poor performance generated a lot of negative reviews. Even though the next broadcast went well, it was hard to recover from the bad reviews. The damage was done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Captain hindsight to the rescue!</h1>
                </header>
            
            <article>
                
<p>Here is the retrospective on this issue. If we had a proper load test that proved what was promised, then the situation perhaps could have been avoided. Also, if we would have been able to upscale quickly, we could have avoided a lot of trouble.</p>
<p>Predicting the future is pretty hard unless you have a crystal ball that actually works. As far as I know, there are none. So instead, always make sure that you can respond quickly to new situations.</p>
<p>You need to be prepared for situations that you can, more or less, foresee. Go figure it out for yourself and do some heavy load tests. Break things before your users do it for you. If you notice any trouble, then you need to find the bottlenecks and see what the best fixes are for them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">To scale up or to refactor? That is the question</h1>
                </header>
            
            <article>
                
<p>Just realize that upscaling is not always the correct answer. If your architecture is bad you can add another database or another server, but that would just be a short-term patch and you would be wasting hardware resources (and money). If a better architecture without upscaling results in a better performance, then that is what you should preferably do. In addition, you still need to make sure that you can scale up quickly.</p>
<p>It is a common practice to keep the app as thin as possible (although there are some exceptions). Let your servers do all the heavy work instead of a small device that otherwise could lead to battery drain and heavy CPU usage. From this perspective, scalability often applies to the backend alone.</p>
<p>As your app user base grows from 10 users to a population of 100, to 10K, 100K, or 1 million, scalability becomes more and more important. The best practices here are as follows:</p>
<ul>
<li>Keep the app as thin as possible</li>
<li>Keep it simple and do not scale yet, but make it scalable</li>
<li>Use cloud storage and deployment</li>
<li>Consider building the interface (API) first</li>
<li>It is important to obtain great insights through analytics</li>
<li>Follow the market, plan your campaigns carefully</li>
<li>Keep data traffic as low as possible and don't transfer data that will not be utilized</li>
<li>Use autoscale options where possible</li>
</ul>
<p>Things that influence the scalability of your solutions involve the following:</p>
<ul>
<li>Database</li>
<li>Storage</li>
<li>Average size of traffic</li>
<li>Regions of your server and where (most of) your users reside</li>
<li>The choice between using an MBaaS, hosting your solution yourself, and cloud-based solutions such as App Engine, Azure, or Amazon</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auto-scaling</h1>
                </header>
            
            <article>
                
<p>If you choose to use Azure as a backend for your mobile app, you can use Azure's mobile services. It offers most infrastructure for you, including processing, storage, and scaling options. You can pick a pricing tier, such as free, one of the basic, or one of the premium plans. An example from the Microsoft document that shows how scaling works in Azure is provided in the following picture. The picture is taken from the classic environment and it looks a bit different in the 'new' portal; however, the way it is presented here is clearer:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="400" src="assets/66fe4123-b6cd-47bb-8176-d7d3ee333592.png" width="425"/></div>
<p>Most Azure services, including the previously mentioned one, come with autoscaling. The solution will automatically scale up or down depending on traffic or by following schedules. Think, for example, of a day and night schedule, a weekend versus weekdays schedule, or a schedule for a specific period when you are running a campaign. It depends on how your app is used as to what will work best for you. If you have no clue, you can learn what the best approach will be by keeping an eye on statistics.</p>
<p>On Amazon, you have more or less the same options for autoscaling and AWS Mobile Services can help you to build apps faster. It comes with support for push notifications, user analytics, data storage, and synchronization options. It can automatically increase the number of instances during peak hours (or days) and decrease them when less capacity is needed, thus saving you money by reducing costs:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="347" src="assets/e82cb26e-186f-4179-be21-c06b2d5fc010.png" width="528"/></div>
<p>Amazon Cloud Watch enables auto-scaling, which is a monitoring service for AWS Cloud resources and applications. You can read more about it at <a href="https://aws.amazon.com/autoscaling/"><span class="URLPACKT">https://aws.amazon.com/autoscaling/</span></a>.</p>
<p>There are some very good books available on the topic that provide you with more in-depth knowledge of any of the IaaS here. I suggest that you check them out later. In this chapter, we just had a look at what your options are and how it affects your strategy.</p>
<p>Another interesting read is: <a href="http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html"><span class="URLPACKT">http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html</span></a>.</p>
<p>Scaling an MBaaS, such as Firebase, basically comes down to picking another price plan. Unlike Azure, Amazon, and App Engine, it does not come with autoscale options and in general, it is less suitable to support a very large number of users. This, however, should not prevent you from using Firebase, for example, as it is a great solution to get started and more importantly, it allows you to validate quickly. Additionally, if you want to migrate from MBaaS to IaaS later, you can use the time that you have saved earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned about a scaling strategy for your app and how this strategy applies in particular to your app backend. A good architecture and the ability to scale, not the scale itself, are key elements here.</p>
<p>By definition, storing data and processing services in the cloud is often very scalable but, depending on what you choose, could also be very costly. If you want to use data from an API that originally was not intended to be consumed on a mobile device, you might need to create a middleware solution first. This way you can ensure that your app works well even with low-bandwidth conditions. Minimizing the amount of data and paging it can help improve your app's performance.</p>
<p>Cloud services offer convenience but at a price. This should not be an issue as soon as your app becomes profitable. There are many ways for monetization and we are going to look at that in the next chapter. Do you need to create a premium app or will in-app purchases lead to more revenue? Let's find out!</p>


            </article>

            
        </section>
    </body></html>