- en: Chapter 3. SpriteKit and 2D Game Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the basics of coding in Swift, the generic flow and class
    structure of an iOS app, as well as the optional structuring of apps with storyboards
    and segues, we can move on to transforming our apps into playable games.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will begin with the 2D game design and game development
    framework created exclusively by Apple for iOS game developers known as SpriteKit.
    SpriteKit first became available with iOS 7 to help simplify the game development
    process for the family of iOS devices. The framework runs a typical rendering
    loop to draw and update 2D objects/sprites to your game's scene. There's much
    going on behind the scenes to run this loop and draw your game sprites. Thankfully,
    Apple built the first party game development frameworks to do much of the heavy
    lifting for us. This way, we can focus more on making the game itself without
    worrying too much about how that game will connect and run with the hardware,
    something developers in the past had to contend with.
  prefs: []
  type: TYPE_NORMAL
- en: Every update of iOS and Xcode continues to add more tools and frameworks to
    improve the ease of game design, including the companion framework introduced
    first at *WWDC15* for iOS 9 known as **GameplayKit**. GameplayKit can allow us
    to separate, copy, and modularize the game logic and even copy for use in future
    game projects, be it SpriteKit or the 3D framework of our next chapter, SceneKit.
    We will go over GameplayKit in later chapters as well. At the end of this chapter,
    we will look at a complete game example that is for a simple game in its gameplay
    but somewhat complex in its logic.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of iOS game development engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpriteKit and the 3D game framework, SceneKit, were not the first methods used
    for developing games in iOS. We'll quickly see why it became a welcomed addition
    to the developer toolset. Initially, we, the game developers, had to practically
    talk directly with the GPU using the OpenGL API to put both 2D and 3D graphics/vertices
    on to the screen. On the upper level, there always was Foundation and CocoaTouch
    to interact with user gestures to manipulate UIKit objects, but dealing with game
    development essentials, such as SpriteSheets, mipmaps, normal maps, partial emitters,
    bounding boxes, and culling, involved some level of lower-level structuring. Apple
    made those calls to various graphics buffers and VBOs slightly easier when they
    created their GLKit framework in 2011\. Thankfully, various third-party frameworks,
    such as Cocos2D, Box2D, Sparrow, GameMaker, Unity, Unreal Engine, and others made
    this process less engineering-intensive in an effort to keep the *design* aspect
    of game design the focus. GameMaker, Unity, and Unreal Engine are more sandboxing-
    / drag-and-drop-styled engines akin to the mentality behind storyboards and segues,
    while engines such as Cocos2D and Sparrow are more code-heavy / boilerplate OOP
    structures that shortcut the initial coding buildup. Engines such as Unity and
    Unreal Engine are great in that they offer a more hands-on sandboxing-type environment
    with various features that simplify the MVC model. Some drawbacks to such engines
    are that they are sometimes closed source, usually cost money to utilize to their
    fullest and aren't device-specific (Unity particularly falls into this category).
    Working with these visual engines could sometimes lead to optimizations being
    required in platform-specific IDEs such as Xcode, due to a sometimes *one-size-fits-all*
    methodology. Apple's SpriteKit and the 3D API, SceneKit which we'll see later,
    give us a first-party platform-specific middle ground that grants the developer
    both upper-level API editing, but even lower-level graphic API (OpenGL/Metal)
    customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The negatives to sandbox/drag-and-drop-styled engines have decreased over time.
    Engines used by AAA studios, such as Unreal Engine, Unity, Havok, and others have
    lessened their upper-level ambiguity between the API and targeted devices' lower-level
    code. A good example of this would be Unity's IL2CPP, which converts the upper-level
    API calls directly to fast device-specific C++ code. This includes code and graphics
    pipeline optimizations that make use of Apple's slim Metal API. This homogenization
    of upper level applications with traditional boilerplate code now allows developers
    from all skill levels to make amazing games. That is why from iOS 8, iOS 9, and
    onwards, the Apple game development frameworks adopted a more visual design methodology.
    Xcode 7 introduced game state machines, components, and the ability to edit/copy
    and reuse player actions and animations throughout your projects. This allows
    developers to work specifically in iOS/Xcode while utilizing the visual design
    benefits of the device-independent game engines.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will learn how to make a tile puzzle game named `SwiftSweeper`
    using the SpriteKit framework and with a more traditional boilerplate code method.
    This means that we will make our first demo game in a code-heavy / model-centric
    fashion. Not only will this give us a look into the inner workings of SpriteKit's
    code but it will also let us utilize more from the Swift programming language
    from [Chapter 1](part0014_split_000.html#DB7S1-d06b23b4a4554b3182353558917969c2
    "Chapter 1. The Swift Programming Language"), *The Swift Programming Language*.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude this chapter by briefly mentioning Apple's latest SpriteKit
    demo game, DemoBots, which utilizes more of the visual tools/frameworks from Xcode
    7 and later. Seeing the more code-intensive method first though will later let
    us appreciate the time saved with these newer tools.
  prefs: []
  type: TYPE_NORMAL
- en: Apple has gone out of their way to mimic the visual design methodology to game
    design seen in other engines since game design is as much about code/logic as
    it is about art and design.
  prefs: []
  type: TYPE_NORMAL
- en: The game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game loop is a game developer's roadmap. The names differ depending on the
    framework and platform, but the same rules apply. The game loop comprises of all
    the methods, physics updates, and draw calls that occur during a single frame
    of your game and their order of execution. The golden rule to game development
    is to try to keep this loop always spinning in full iterations at no slower than
    16.6 milliseconds, or 60 frames per second.
  prefs: []
  type: TYPE_NORMAL
- en: There are aspects of the game loop that don't have to be controlled by the game
    developer as much as they used to be in the past, though we do have the option
    to work down to the very GPU calls using OpenGL, or even better, Apple's Metal
    API. We will discuss more on these topics later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the SpriteKit game loop looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game loop](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding is an illustration given to us directly from the Apple Developer
    site. We see a number of functions that are called during a single frame. The
    first function iterated through is `update()`. The `update()` function is where
    we add most of our own game-specific updates and various checks on game objects
    (such as positions and character statuses).
  prefs: []
  type: TYPE_NORMAL
- en: The loop structure gives us the option to do updates after we know a certain
    set of tasks in the frame have happened, that's where `didEvaluateActions()`,
    `didSimulatePhysics()`, `didApplyConstraints()`, and `didFinishUpdate()` functions
    come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anyone coming from Unity might be familiar with its general game loop functions,
    such as `Awake()`, `Start()`, `FixedUpdate()`, `update()`, and `LateUpdate()`.
    The SpriteKit game loop allows some similar code/render flow, but as we'll see,
    there are some slight differences.
  prefs: []
  type: TYPE_NORMAL
- en: For more on the game loop and its functions, see the following link from the
    Apple documentation at [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the other game loop methods could make sure certain calls in your
    game don't go out of order and can even help with the important task of making
    the most out of each frame in a fast, efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the public game PikiPop, mentioned previously, here''s how
    the game uses the game loop in its main `GameScene.swift` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code first checks whether the player is playable with the `isPlayable`
    Boolean. This status can mean a number of things, like if the player is alive
    or not, is spawning, and so on. The game loop's `update()` function, which is
    being overridden from its parent `update()` function of the `SKScene` object,
    takes a parameter of the time utility type `CFTimeInterval`. `CFTimeInterval`
    is a special Core Foundation double type that measures time in seconds and thus
    updates the player object (if not null) during each interval.
  prefs: []
  type: TYPE_NORMAL
- en: As a brief summary of PikiPop, it's a procedural 2D side-scrolling game somewhat
    similar to the game Flappy Bird. Unlike Flappy Bird, Piki is able to traverse
    the game in all directions based on player taps and swipes. Piki could get trapped
    between the stage objects and the edge of the stage.
  prefs: []
  type: TYPE_NORMAL
- en: '![The game loop](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is Piki getting injured if pushed into the left-hand side
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Edges in that game's stages use SpriteKit's own special objects named **SKConstraints**.
    More on these later, but in short, they dictate the range and orientation SpriteKit
    sprites can take. Sprites in SpriteKit (both developer-defined objects, such as
    PikiPop's Player object and the default `SKSpriteNode`) are all derived from `SKNode`
    objects that work with `SKConstraints` and other physics-based framework functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could check whether Piki is being pushed against the corner in the `update()`
    part of the game loop, but since constraints are part of the framework''s physics
    architecture, it''s best to do this check during the `didSimulatePhysics()` portion
    of the render loop of `SKScene` as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of this code, `let block: (SKNode!, UnsafeMutablePointer<ObjCBool>)
    -> Void = { node, stop in`, is done in what''s known as a **block** or a **closure**
    syntax, which Swift lets us do rather dynamically. Don''t mind the details of
    this kind of code for the moment; just note that we check the player''s position
    in *x* versus the edge of the window''s frame in this portion of the game loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s more information on writing blocks/closures in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Tile game – SwiftSweeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time to stop talking about SpriteKit and get right into it! As stated at the
    beginning of this chapter, we will first show you how to make a simple-looking
    tile game in SpriteKit using the slightly more difficult boilerplate/code-drive-styled
    design. Don't worry, this is not going to involve direct calls to the GPU with
    C++ and handling extremely tiny memory requirements like veteran game developers
    did during the early console days. However, we will be using lots of code-heavy
    calls with SpriteKit objects, functions, and classes. Granted, getting down into
    the code directly is continually becoming less of the developer's responsibility
    as Apple continues to make more design-centric functionalities in Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the code structure can give you an edge over developers coming in on
    a more top-down methodology and coding will always be behind custom game logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tile game – SwiftSweeper](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What is SwiftSweeper?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SwiftSweeper` is a clone of the classic tile puzzle game, MineSweeper, written
    entirely in Swift. `SwiftSweeper` makes use of Swift''s ability to use Unicode
    emoticons so that we don''t have to use many image assets and should give us a
    great starting point to making our own tile/puzzler game with difficulty levels.'
  prefs: []
  type: TYPE_NORMAL
- en: We will build up much of the game from scratch, but the full source code can
    be found at [https://github.com/princetrunks/SwiftSweeper](https://github.com/princetrunks/SwiftSweeper).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As at the time writing of this book, this was built in Xcode 7 Beta (7A120f)
    for the initial iOS 9 release and optimized for iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the game is to tap every tile on the game board without hitting
    mines hidden throughout the board. You do get some help though. Every tile that
    isn't a mine will tell the player how many tiles around it are mines. If the player
    knows that a tile without a doubt is a mine via the process of elimination, they
    can plant a flag on that tile to make sure that they don't tap that space. Tap
    all of the tiles that aren't a mine to win the game! `SwiftSweeper` even saves
    the time it took you to win for each difficulty level you chose to give the game
    a bit of replay value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our SpriteKit game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the goal of our game, here''s how we go about building it
    in SpriteKit:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open Xcode and create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select the Game template and click on **Next**.![Creating our SpriteKit
    game](img/00023.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, fill in the product name. We will name this project `SwiftSweeperExample`
    and make sure that the language is Swift with **SpriteKit** selected as the game
    technology as well as the devices set to iPhone.![Creating our SpriteKit game](img/00024.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on **Next**, and we now have a brand new SpriteKit game project
    with a number of files already written up for us to get us started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the project's main file in the navigation pane and deselect all
    but the **Portrait** selection in the **Device Orientation** field.![Creating
    our SpriteKit game](img/00025.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are going to work mostly with code, we can also either ignore or delete
    the `GameScene.sks` file for now. These files are Xcode's option for you to visually
    design your game scene. We will know more on these files later when we work with
    our more visually designed SpriteKit game example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run the app to see Apple's default SpriteKit project, which has `Hello
    World` written in Chalkduster font and a rotating spaceship appears where you
    click or tap on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An overview of the SpriteKit structure and objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we add our code, let's use this template to get an idea on how SpriteKit's
    basic objects, functions, and flow work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we stated in the previous chapter, `AppDelegate.swift` is the main entry
    point. The code then moves to `GameViewController.swift`, which is a child of
    the `UIViewController` class that imports the SpriteKit framework. The following
    code is written in the `viewDidLoad()` function of `GameViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Using the keyword `override`, this version of `viewDidLoad()` can now either
    add to or well override the parent class's functionality. `super.viewDidLoad()`
    calls the parent class's original functionality and then it works its own custom
    functionality. This is how Swift handles the OOP concept of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we see how a game scene is first created with `GameViewController`. A
    major aspect of SpriteKit is that it works in scenes that are members of the `SKScene`
    class, which are themselves children of the `SKNode` class. The `SKNode` classes
    are the main building blocks of nearly every object in SpriteKit. Be it sprites,
    lights, videos, effects, physics fields, audio files (`SKAudioNodes`), cameras
    (`SKCameraNodes`), or labels/UI objects, they are `SKNode` classes. These objects
    all hold important information, most importantly coordinate information of object''s
    node family. For games, this allows the developer to create custom classes, such
    as `Enemies`, `GameLights`, `Tiles`, and so on, that all have screen and other
    information on both parent and child nodes. For example, we can hit every enemy
    on the screen with an attack by the player by calling an inherited function in
    a parent `Enemy` class. We don''t need to check for each individual type of enemy
    but instead enumerate through the parent nodes in the various game loop functions
    of `SKScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Do you remember the block/closure call in PikiPop? To actually use it in the
    `didSimulatePhysics()` function of `SKScene`, we call the `enumerateChildNodesWithName`
    function of `SKNode` to target only those nodes in the scene and have that block
    of code run for each member in the scene with that name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The name is simply a *string* that can be set using the `SKNode.name` property.
    Have every custom node initiate with a given name (or change during game play),
    and you have a whole group of objects you can single out in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more on `SKNode` in Apple's official documentation at [https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/](https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/).
  prefs: []
  type: TYPE_NORMAL
- en: Scene transitions and the choice of code, storyboards, and/or SKS files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GameScene.swift` class in our project inherits from `SKScene`, and it is
    there that the game loop / rendering functions we mentioned earlier occur. SpriteKit
    runs on scenes, and scenes can be transitioned and segued to and from it.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we showed how to structure a game using storyboards
    and segues. `SKScene` makes it where you don't even have to use storyboards but
    just straight code to transition. We can use storyboards, and we can also visually
    design each individual scene using `.sks` files or a combination of all three
    methods. With code, `SKScene` can transition with the `SKTransition` objects and
    functions. Actually, as we'll see with `SwiftSweeper`, we can just use code to
    manually refresh assets in the scene to do *transitions*. This method is rather
    old fashioned and not as elegant as `SKTransition` storyboards and SKS files,
    so let's take a quick look at how to transition scenes in code with `SKTransition`,
    storyboards, and briefly into SKS files via code. Later, and in the next chapter,
    we will focus much more on the visual SKS files since every update to iOS and
    Xcode continues to put the focus on these visual tools to shorten the coding time
    and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: An SKTransition example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code changes the game''s scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SKTransition` classes are really just types of segues. As in the preceding
    code, the transition is a directional switch to the next scene with the `SKTransitionDirection.Up`
    enumerator type. As we saw in `GameViewController`, the new scene is created with
    the similar functions that control the scene''s view size and aspect ratio and
    then presents that scene to the unwrapped view with `self.scene!.view!.presentScene(scene,
    transition: transition)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that this takes place in the same function as we see in our current
    project''s `GameScene.swift` class, `override func touchesBegan(touches: Set<UITouch>,
    withEvent event: UIEvent?){}`. This is the function that handles touch gestures
    from the player and checks whether the name of the node touched matches the `SceneChangeButton`
    string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More on `SKTransition` and other neat transition effects you can give your
    games can be found here in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/](https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of Swift 2.0 / iOS 9, this touch delegate function takes in a parameter
    that is a set of `UITouches` via `touches: Set<UITouch>` and an optional `UIEvent`.
    This is a change from past Swift iterations and could change in future updates.'
  prefs: []
  type: TYPE_NORMAL
- en: A SKScene/storyboard example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the code for a `SKScene`/storyboard example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in the previous chapter, using the visual help of storyboard files
    can give us great visual road maps to our apps, both game and non-game. The preceding
    code uses a link to an `@IBAction` linkage on a storyboard file to set a new scene.
  prefs: []
  type: TYPE_NORMAL
- en: Storyboards in games can be great for the prototyping phase when we know just
    the general structure of our game, and can be perfect for the game's menu navigations
    or even for all individual game scenes***.
  prefs: []
  type: TYPE_NORMAL
- en: The button itself is removed before the transition via the `button.removeFromSuperview()`
    call to prevent a memory leak caused by the new scene being drawn over what could
    have been an unseen menu button—unseen to the player but not to the game's memory
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***It''s usually the best practice to only use storyboards for overall navigation
    menus and not for each individual level/scene. The `SKScene` and `SKNode` functionality
    can let us reuse similar scene structures and save much of the coding for similarly
    structured levels. Games with many levels could turn our storyboards into a web
    of confusing structures and thus undo their initial purpose. Scenes with the actual
    gameplay could just be in their own single view controller in the storyboard,
    and we''d have the pause, share, and other menus be controlled by storyboard segues.'
  prefs: []
  type: TYPE_NORMAL
- en: SKScene transitions with SKS files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `.sks` file is a special SpriteKit scene file that can allow the creation
    of a scene as well as the placement of the player, particles, enemies, and level
    assets in a visual, drag and drop way. Transitioning to a visually designed `.sks`
    file in Swift is the same as our initial `SKTransition` example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The creation of the `gameScene` constant with the `SKScene` initializer `fileNamed`
    and then presenting that scene to the view works the same with either the `.swift`
    file or `.sks` file. This gives us the flexibility to both code and/or visually
    design our game scenes. In the case of `SwiftSweeper`, we will do the more code-centric
    methodology, but feel free to build on this game on your own if you wish with
    either more code, Storyboards, and/or with visually designed `SpriteKitScene`
    (`.sks`) files.
  prefs: []
  type: TYPE_NORMAL
- en: Assets, sprites, and icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of Xcode 7, game assets are placed in the `Assets.xcassets` folder. Previous
    versions of Xcode might have had an `Images.xcassets` folder for the game's icons
    and sprites, but this has changed and might continue to change with each new iOS
    release.
  prefs: []
  type: TYPE_NORMAL
- en: '![Assets, sprites, and icons](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An image from Apple's WWDC15 conference
  prefs: []
  type: TYPE_NORMAL
- en: Starting with iOS 9 and Xcode 7, the `assets` folder was given even more flexibility
    with the ability to handle the various app icon sizes, the launch image, sets
    of images, and sprite atlases. This also allows us to develop with various memory
    saving capabilities introduced in iOS 9 like **app slicing** / **app thinning**
    and on-demand resources. The app slicing/thinning feature makes sure that only
    the assets relevant to the device are downloaded, which saves space on the player's
    iPhone or iPad. On-demand resources let us tag assets that are available in the
    device's memory only during certain parts of our games. This way, we can create
    even larger games for our players to experience without taxing the sometimes-limited
    space in the Apple family of devices.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more on app slicing/thinning at [https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html).
  prefs: []
  type: TYPE_NORMAL
- en: When setting up your game for on-demand services, something that could be great
    to know in the initial planning of your games, can be found in the official documentation
    at [https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/](https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/).
  prefs: []
  type: TYPE_NORMAL
- en: Sprite atlases and animating sprites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SwiftSweeper actually doesn't use animating sprites; as we'll see, it simply
    uses Unicode emoticon characters to animate the screen. Yet, we can't discuss
    SpriteKit and 2D game development without mentioning sprites, animating and optimizing
    them with texture atlases/sprite sheets, could we? A sprite atlas is a collection
    of images bundled into a single image, also known as a **sprite sheet** or **texture
    atlas**. While developing 2D games, it is highly recommended to use texture atlases
    as opposed to various image sets because to the renderer, texture atlases will
    equate to far fewer draw calls and thus can make sure that your game runs at that
    needed 60 fps. The `Collectables.atlas` folder in `Assets.xcassets` could hold
    all of your game's collectables and with the `SKTextureAtlas` class, efficiently
    draw those collectables to the screen. When storing the images to say the player's
    idle, walking, and jumping animations, we use texture atlases to store them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a texture atlas is very simple and is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Simply click on your `Assests.xcassets` folder and right-click on an empty part
    of the folder's hierarchy.![Sprite atlases and animating sprites](img/00027.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New Sprite Atlas** and just like this, we have a folder where we
    can store various sprites for our game.![Sprite atlases and animating sprites](img/00028.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to name the folder based on how you wish to categorize the groups
    of sprites. You'd need this name when referencing them in code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a reference to this atlas in code and animate the sprites, we use
    `SKTextureAtlas` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, this code creates an `SKTextureAtlas` reference to the player's sprite
    atlas using the initializer `SKTextureAtlas(named:"Player.atlas")`. Then, we create
    an array of textures using one of Swift's orders block `map(NSRange){…}`. This
    is a closure block that iterates through the textures in the sprite atlas based
    on the range specified in the map call. The `number` object is a simple index
    object we can use to represent the index of the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done because our player has these sprite names for the normal/idle
    animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we know that the sprite animations are named with an indexed naming structure,
    it's better to use Swift's functional programming tools, such as `map()`, here
    to simplify the code. 2D Sprites with many frame-by-frame animations (games such
    as Metal Slug) could be iterated through in such a fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '`SKTextureAtlas` also has a class function named `preloadTextureAtlases` we
    can use to preload an array of texture atlases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is great to make sure that a stage's sprites are loaded before entering
    the stage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our game logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of simplicity, MineSweeper won't have many different assets or
    any sprite textures. It instead uses Swift's Unicode emoticon character capabilities
    and `UIView` calls to design the game's graphics in a rather old-fashioned, very
    MineSweeper-like way.
  prefs: []
  type: TYPE_NORMAL
- en: Not only do we do this to give us a somewhat simplistic starting point, but
    to show how Swift code and SpriteKit classes can let us create the entire game's
    logic and flow without the initial need of sprite assets. This way, if developing
    as a team or by yourself, the game can be made before doing the sometimes grueling
    process of making wonderful visual assets. Thinking with code and structure first
    can ensure that you have a working prototype that you can polish later with sprites,
    music, and atmosphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve so far left SwiftSweeper waiting as just a shell of the SpriteKit game
    template. It''s about time we get to the game''s model:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's add our image assets. For more information, visit [https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo](https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a link to the `Assets.xcassets` folder of `SwiftSweeper`. We can add
    these individually, but the simplest way is to just replace your project's `Assets.xcassets`
    folder directly in your computer where your project's folder is located. You can
    have Xcode open while you do this, it'll automatically update from the original
    template files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s add the sound files from the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY](https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the sounds by doing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `SwiftSweeperExample` folder that holds the Swift files and
    then go to **New** | **Group** from the menu.![Creating our game logic](img/00029.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this folder `Sounds` and drag it to the bottom of the files within the
    same `SwiftSweeperExample` folder.![Creating our game logic](img/00030.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Sounds` folder and select `Add Files To "SwiftSweeperExample"`.![Creating
    our game logic](img/00031.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the sounds from the `SwiftSweeperSounds` folder, and they should now be
    in your project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Creating our game logic](img/00032.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: All of the assets should be now in the project, so now we can build our game.
    Let's first start with the actual tiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a new Swift file, name it `Tile`, and paste the following code into
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some stepwise logic we adhere to while creating tiles:'
  prefs: []
  type: TYPE_NORMAL
- en: While building any code logic, we usually place the properties about this object
    at the top. We know that each tile in a game of MineSweeper will be part of a
    row and a column. The number of the row and the column this tile will have during
    gameplay won't change during the course of a single round, so we make them constants
    with the keyword `let` and set them with the type `Int` as we know that you can't
    have fractions of a row or a column, at least in terms of the tile objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A tile can have a few different states. It could be already tapped, it could
    have a flag placed on it, and if it's a a mine. Since these are true/false properties,
    we set them with as Boolean variables `isTileDown`, `isFlagged`, and `isAMine`.
    We set them to `false` initially.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tiles in MineSweeper count how many tiles around them are mines, so we create
    the integer counter `nearbyMines` to hold that information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an instance of a tile object is created, we want the game to set its row
    and column number placement on the `GameBoard`, so we create the default initializer,
    `init`, to have two parameter inputs for both the row and column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all we need for the `Tile` objects, so let's move on to setting the button
    functionality of these `Tile` objects with the `MineTileButton` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Swift file and name it `MineTileButton` and paste the following
    code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the explanation of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are creating a `UIButton` object, we import the UIKit framework for
    this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the properties of this button object. We need a `Tile` object named
    `tile` to reference, a `CGFloat` size named `tileSize` to represent the rectangle
    this button will occupy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initializer for this class takes in a `Tile` object named `tileButton`
    and a `CGFloat` named `size`. We assign the class''s own tile to `tileButton`
    and `tileSize` to `size` and then we make a square named `tileBoundingFrame` with
    the `CGRectMake()` method. This is done just after we set an *x* and *y* value
    of `CGFloat` to the square based on the `tileSize`. The `UIButton` parent `init(frame:
    )` initializer uses the `tileBoundingFrame` as the parameter via `super.init(frame:
    tileBoundingFrame)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Xcode 5, the `init` function is needed mainly to keep the compiler happy
    while dealing with UI objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function `getTileLabelText()` returns a string based on the status of the
    `tile` object. If the tile is not a mine, we know that we have to either place
    something for there being no tiles; traditionally, this is just a blank space
    or an empty `""` string, but for now, we are just placing `0` there, leaving the
    logic open for customization. Honestly, we could simply return the nested if-else
    statement's return `\(self.tile.nearbyMines)`, and it'd return the same result.
    As we see, it's returning the particular `Tile` object's `nearbyMines` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the tile is a mine, then we return the collision Unicode emoji character.
    The `getTileLabelText()` function is called when the player taps an `unflagged`
    tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swift's ability to use Unicode character symbols can be a great visual aid in
    the planning process of your games. The collision Unicode emoji used in line `(6)`
    is `U+1F4A5 (128165)`. If you see only a square box and not the red explosion-like
    character, it can be seen in the full project download mentioned earlier in the
    chapter or at the following link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Find more information on this emoji at [http://www.charbase.com/1f4a5-unicode-collision-symbol](http://www.charbase.com/1f4a5-unicode-collision-symbol).
  prefs: []
  type: TYPE_NORMAL
- en: GameBoard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our tile object and button logic that will represent each tile
    object named `MineTileButton`, we need to create an object representing the collection
    of these objects, that is, `GameBoard`.
  prefs: []
  type: TYPE_NORMAL
- en: The full `GameBoard.swift` code is a bit too large to show here in its entirety,
    so we will summarize its main features and segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the entire code either in the full project link mentioned earlier
    in the chapter, or directly below in order to copy to your current game project
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mega.co.nz/#!X8FB2aAK](https://mega.co.nz/#!X8FB2aAK)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `GameBoard`, we are looking to create a tiled board of 10x10 size that
    also has three levels of difficulty: easy, medium, and hard. To create the difficulty,
    we simply use an enumerator named `difficulty` to store the game''s difficulty
    levels.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important properties of `GameBoard` include `boardSize_` (which is
    set to `10` in this case), a variable that will represent the number of mines
    that will be placed named `mineRandomizer`, the number of mines active on the
    board named `mineCount`, and the Tile objects that will populate the board named
    `tiles`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a note of the syntax used for the `tiles` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can create an ordered 2D array (or matrix) in Swift*. The `GameBoard`
    object will basically store an array of an array of `Tile` type objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Swift does have more ways to express matrices, for example, we can use Structs
    to define our own unique matrices. As at the time of this publication, Swift does
    not have its own true functionality for fixed length arrays, as we see in various
    C languages. However, using the nested braces `[[]]` is fine for what we are trying
    to accomplish.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initializer for `GameBoard`, `init(selectedDifficulty:difficulty){}`, takes
    in the player-selected difficulty as it''s single parameter then builds the board
    based on the `boardSize` property and then uses the following nested for-in loop
    to populate the entire board with `Tile` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the `tiles` object is a 2D array, we first need to perform this nested
    loop that first creates a 1D array of `Tile` objects (named `tilesRow`) for each
    row and then add a tile for each column in that row with the `.append` function.
    The main tiles 2D array is then appended that `tilesRow` array.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to make a `GameBoard` instance that is a rectangle or of another
    shape, you'd have to take into account the differing column and row amounts. This
    would make the nested for-loop have more complexity by needing a separate `columnSize`
    and `rowSize` property. Many puzzle games will make their boards look complex
    to the player but might still keep their internal structures simple to either
    squares or rectangles by instead filling in that tile with a nonplayable section
    or background/transparent tile.
  prefs: []
  type: TYPE_NORMAL
- en: It's a way for a developer to cut corners while at the same time allowing complex
    functionality and design. It's why we built this game with separate classes representing
    the Tiles, the tile button functionalities, and the game board layout.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance, we can continue to customize what each tile does and thus
    allow a myriad of features based on a simple foundation.
  prefs: []
  type: TYPE_NORMAL
- en: It's why video games have always been the poster children to make the most out
    of object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if at first it's tough to get a full understanding of this, as nested
    loops tend to be brain twisters. Just observe how the interior for-loop won't
    exit until it's done filling in columns based on the `boardSize`_ property. This
    kind of loop is made easier with the fact that the rows and columns are all equal
    at 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initializer then calls the `resetBoard()` function, which resets the `mineCount`
    to `0`, and does two more nested for-loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This board-iterating for-loop randomly sets which tiles are mines using the
    `createRandomMineTiles()` function as well as resets the tiles to being untouched
    with the `tiles[row][column].isTileDown = false` call. The `createRandomMineTiles()`
    function works off the current difficulty level, particularly the `mineRandomizer`
    property that is determined in the `implementDifficulty()` function. The higher
    the `mineRandomizer` value, the less of a chance the iterated tile will be made
    into a mine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next nested for-loop in `resetBoard()` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This iterates through every tile on the board and sets the number the player
    will see if tapped. That number of course being the number of mines surrounding
    a non-mine tile, that is, the `nearbyMines` property of the `Tile` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This rather complex chain of calculations begins with the `calculateNearbyMines()`
    function and runs through the array/tile index calculating functions, `getNearbyTiles()`
    and `getAdjacentTileLocation()`. We provided various detailed comments in each
    of these functions to get a better understanding on how they work. It''s advised
    that you read the intricate details on how it''s done but to not muddy an already
    complex game logic explanation, take notes on the following line in `getNearbyTiles()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If any line in these three complex functions is to be understood, it's this
    one. The `nearbyTileOffset` object is an explicitly written array of tuples, which
    contains every offset that could exist around a single 2D tile. Actually, it's
    best to think of each member of this array as an (*x*,*y*) 2D Vector.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, as commented in the preceding code, the offset of (`-1`,`-1`) would be
    to the bottom left of the tile since `x = -1` (left 1) and `y = -1` (down 1).
    Similarly, (`1`,`0`) is to the right, (`1`,`1`) is the top-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: We also have to take into account that some tiles are on the edge and/or column
    of the board, thus some of the tile offsets won't return the reference to another
    tile; they'll instead return nil.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This for-loop in `getNearbyTiles()` not only checks the offsets of every tile,
    but also, using the call to `getAjacentTileLocation()`, accounts for edge or corner
    tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Again, these three functions are rather complex, even in a less line-by-line
    / semi-generic explanation of their functionality. So, don't worry if you don't
    understand the flow/order at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for `resetBoard()`, we can''t win the game without knowing if the
    player got every non-mine tile, so we get that information with the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the player's number of completed moves (counted in the `GameScene` class)
    equals `numOfTappedTilesToWin`, the player wins!
  prefs: []
  type: TYPE_NORMAL
- en: This is all done before the player makes the first move! This is done in order
    to have the values already predetermined. Yes, we could make some of these calculations
    during the player's touch, but dealing with boilerplate game logic is usually
    fast enough to prepare the game at load time so that we can use the game play
    to focus on effects, sequences, and other visual notifications during the game
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is controlled by the `GameScene.swift` file, which we will
    summarize next.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together in GameScene.swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have the core of SwiftSweeper's logic set up, but now it's time to present
    it in our `SKScene` provided by the game template, `GameScene`. This scene uses
    the game/rendering loop functions that we mentioned at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The SwiftSweeper version of `GameScene.swift` is rather large at about 800 lines
    of code, so like `GameBoard`, we won't be going over it line by line but instead
    we'll be summarizing some of the important aspects of the scene. As stated previously,
    every update to Xcode and iOS brings more visual ways of setting up these scenes,
    so getting to know every line of code in this example isn't necessary, but still
    recommended if you really wish to dive deep into how to use code to present SpriteKit
    game scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code can be found in the full project link mentioned earlier in the
    chapter or (if you''ve been building it from scratch throughout the chapter) at
    the link mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mega.co.nz/#!PgljBL7b](https://mega.co.nz/#!PgljBL7b)'
  prefs: []
  type: TYPE_NORMAL
- en: We used various `//MARK:` comments to section off parts of this code, so you
    can navigate easier. After copying the code into your project, you could build
    and run the app. As long as everything was placed into the project correctly,
    you should have a working version of SwiftSweeper running on your phone or in
    the phone simulators. Play through it a bit to get an idea what is being done
    in GameScene to present the game. Sometimes, seeing a game in action lets us see
    the code behind it better. If any errors pop up, something went wrong and if all
    else fails, you can download the completed project from [https://github.com/princetrunks/SwiftSweeper](https://github.com/princetrunks/SwiftSweeper).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first visual entry point in GameScene, `didMoveToView()`, is actually rather
    small as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We simply set the background color to white and load the instructions. Again,
    we didn't say that this was meant to be a beautiful-looking game.
  prefs: []
  type: TYPE_NORMAL
- en: The `loadInstructions()` function manually places the instructions sprite on
    the screen and sets the `currentGameState_ enum to .Instructions`. A **game state**
    or **state machine** is common game development methodology that instructs characters,
    the player, and the game itself what state it is in. This could be used to make
    sure that certain parts of the gameplay don't happen in parts they aren't suppose
    to. iOS 9 / Xcode 7 introduced the framework; we'll dive into more later chapters
    named GamePlayKit, which, among other game logic functions, works with state machines
    that can be modular and independent from a specific scene. Components from the
    class `SKComponents` and more modern usage of `SKAction`, also introduced in iOS
    9, work in the same way, independent from OOP inheritance. Think of more dynamic/usable
    versions of protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next overall step in the GameScene is the `chooseDifficultyMenu()` that
    came with the `removeInstructions()` function, which was called after the player
    taps the screen. This tap is checked in the function we mentioned in a few examples
    prior, `touchesBegan()`, using the game state as a logic check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `touchesBegan` function is actually rather simple. It only checks
    if we tapped the flag button or if we tapped on the instructions. What about the
    tiles? Well, remember that we made these tiles all members of `UIButton` with
    the `MineTileButton` class. Here''s the function that controls this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Members of the `UIButton` class send out a reference of what has been tapped
    to the scene. In this game, is an object of the type, `MineTileButton`. Using
    the game state to check if it's logical to the scene, we either end the round
    if a mine is hit with the `mineHit()` function or we increment the moves performed
    (used to calculate the win by comparing it to `numOfTappedTilesToWin_` calculated
    at the start of the round). If the game state is `.FlagPlanting`, then we instead
    deal with the logic behind planting a flag on the tiles. Tiles with flags don't
    react to `.MineTap` game state taps and thus, if you put a flag on the wrong tile,
    you won't get the win until you uncover all of the non-mine tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Through the rest of the code, we'll find a timer, alerts for the player based
    on the outcome, and even the ability to save times per difficulty levels using
    the class functions of the `NSUserDefaults` class.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it's not exactly all that visually elegant, but intricate in code and
    most importantly a fully functioning game. We advise you to check out more of
    the code in `GameScene.swift`, but one major issue to our design one might have
    caused in the beginning is that this only works with iPhones.
  prefs: []
  type: TYPE_NORMAL
- en: Using visual tools such as autolayout, seen briefly in the previous chapter,
    will allow easier design changes for the entire family of iOS devices. Since many
    of the visual assets in SwiftSweeper's GameScene were manually placed in the view
    (particularly the instructions), we'd have to account for every device type in
    code. This is possible, but as the family of devices grows, manual code used for
    screen visuals could be broken rather easily in future iOS updates and device
    announcements. That's why in our next chapter about SceneKit and later, we will
    mostly diverge from this code-centric structure and embrace the hands-on tools
    and newer frameworks such as GamePlaykit from Xcode 7 and later.
  prefs: []
  type: TYPE_NORMAL
- en: DemoBots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As at the initial publication of this book, *WWDC15* recently completed and
    gave us a great new SpriteKit demo project for iOS 9 and Xcode 7 named **DemoBots**.
  prefs: []
  type: TYPE_NORMAL
- en: '![DemoBots](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: DemoBots is a SpriteKit project provided by Apple that uses components, state
    machines, on-demand services, GameplayKit, ReplayKit, and more!
  prefs: []
  type: TYPE_NORMAL
- en: The full project documentation to DemoBots can be found at [https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it in action from *WWDC15*, see the video and PDF file from the *Deeper
    into GameplayKit with DemoBots* keynote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/videos/wwdc/2015/?id=609](https://developer.apple.com/videos/wwdc/2015/?id=609)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SpriteKit keynote can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/videos/wwdc/2015/?id=604](https://developer.apple.com/videos/wwdc/2015/?id=604)'
  prefs: []
  type: TYPE_NORMAL
- en: DemoBots's gameplay even has easily editable enemy AI / navigation schemes uses
    the `SKCameraNode` introduced in iOS 9 that follows the player and doesn't move
    the scene around in the view as in past versions of SpriteKit. As we mentioned
    at the beginning of the chapter, mimicking the tools we see in multiplatform game
    engines.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We went through a number of topics here in this chapter. We first spoke on why
    SpriteKit was a welcomed addition to iOS after years of developers only having
    third-party gaming frameworks, such as Cocos2D and Sparrow. We discussed how SpriteKit
    fits in the game development ecosystem as rather powerful, multiplatform game
    engines, such as Unity and Unreal Engine, continue to become more prominent. Next,
    we went into the SpriteKit game loop and rendering cycle that is used by `SKScene`.
    Then, we began to build our demo tile game, `SwiftSweeper`, and dove more into
    the basic structure of SpriteKit's most prominent object classes. The iOS 9 `assets`
    folder was reviewed in addition to texture atlases and how to animate sprites
    using these asset tools. Then, we went into the rather complex logic and code
    that goes into mimicking a tile game such as MineSweeper.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move on to iOS's 3D game development framework, SceneKit, where we
    will diverge more towards the visual tools Apple now brings to us since iOS 8
    / iOS 9\. We'll take less of a code-centric methodology now that we know the basic
    scene/code structure that both SceneKit and SpriteKit share. SpriteKit scenes
    can overlay SceneKit scenes, so we will see some of what we hinted at with Apple's
    own DemoBots demo shortly.
  prefs: []
  type: TYPE_NORMAL
