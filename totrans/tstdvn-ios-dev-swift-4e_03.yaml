- en: '*Chapter* 2: Understanding Test-Driven Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen what unit tests are and how they can help in development,
    we are going to learn about **test-driven development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: After giving you some insights into the origin and objective of TDD, we will
    move ahead and have a look at the benefits and drawbacks of it. By the end of
    the chapter, you will have a clear idea about the relevance of TDD and what should
    be or can be tested using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main topics that we will cover in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The origin of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TDD workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The origin of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 1996, Kent Beck, Ward Cunningham, and Ron Jeffries introduced a new software
    development methodology called **Extreme Programming** while they were working
    on the project *Comprehensive Compensation System* at Chrysler. The word *Extreme* indicates
    that the concepts behind Extreme Programming are totally different from the concepts
    used in software development back then. For many people, these concepts sound
    extreme even today.
  prefs: []
  type: TYPE_NORMAL
- en: The methodology is based on 12 rules or practices. One of the rules states that
    developers have to write unit tests and all parts of the software have to be thoroughly
    tested. All tests have to pass before the software (or a new feature) can be released
    to customers. The tests should be written before the production code that they
    test.
  prefs: []
  type: TYPE_NORMAL
- en: This so-called test-first programming led to TDD. As the name suggests, in TDD,
    tests drive the development. This means that the developer writes code only because
    there is a test that fails. The tests dictate whether the code has to be written,
    and they also provide a measure when a feature is "done" – it is done when all
    tests for the feature pass.
  prefs: []
  type: TYPE_NORMAL
- en: This might sound silly to you if you haven't done any TDD before. You have to
    try and keep with it for some time to see the advantages and that it's not silly
    but rather quite clever. In TDD you always focus on one feature of the product
    you are building. And as you have tests for all the features you have built before,
    you don't have to keep the details of the rest of the code in mind. You can trust
    in the existing tests and that you won't break something that worked before.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the focus on just one feature at a time, you will have a working
    piece of software almost all the time. So, when your boss enters your office and
    asks you for a demonstration of the current status of the project, you are only
    a few minutes away from a presentable (that is, compiled) and thoroughly tested
    piece of software.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what TDD refers to, let's look into its workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The TDD workflow – red, green, refactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The normal workflow of TDD comprises three steps – *red*, *green*, *refactor*.
    The following sections describe these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Red
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You start by writing a failing test. It needs to test a required feature of
    the software product that is not already implemented or an edge case that you
    want to make sure is covered. The name red comes from the way most IDEs indicate
    a failing test. Xcode uses a red diamond with a white x on it as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Xcode marks a failing test with a white cross in a red diamond'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Xcode marks a failing test with a white cross in a red diamond
  prefs: []
  type: TYPE_NORMAL
- en: It is very important that the test you write in this step initially fails. Otherwise,
    you can't ensure that the test works and really tests the feature that you want
    to implement. It could be that you have written a test that always passes and
    is, therefore, useless. Or, it is possible that the feature is already implemented.
    Either way, you gain insight into your code.
  prefs: []
  type: TYPE_NORMAL
- en: Green
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the green step, you write the simplest code that makes the test pass. It
    doesn't matter whether the code you write is good and clean. The code can also
    be silly and even wrong. It is enough when all the tests pass. The name green
    refers to how most IDEs indicate a passing test. Xcode uses a green diamond with
    a white checkmark.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Xcode marks a passing test with a white checkmark in a green
    diamond'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Xcode marks a passing test with a white checkmark in a green diamond
  prefs: []
  type: TYPE_NORMAL
- en: It is very important that you try to write the simplest code that makes the
    test pass. By doing so, you only write code that you actually need and that is
    the simplest implementation possible. When I say simple, I mean that it should
    be easy to read, understand, and change. Test code should always be easy to understand.
    Try to write your tests such that you understand them even when you haven't worked
    on them for months. When tests break, it's often while you are working on something
    completely different. A clear and easy-to-understand test helps you to find the
    problem quickly and get back to the context you were working on.
  prefs: []
  type: TYPE_NORMAL
- en: Often the simplest implementation will not be enough for the feature you're
    trying to implement, but still enough to make all the tests pass. This just means
    that you need another failing test to further drive the development of that feature.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the green step, you write just enough code to make all the tests pass
    again. As I just mentioned, it doesn't matter what the code looks like in the
    green step. In the refactor step you improve the code. You remove duplication,
    extract common values, and so on. Do what is needed to make the code as good as
    possible. The tests help you to not break already implemented features while refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't skip this step. Always try to think about how you can improve the code
    after you have implemented a feature. Doing so helps to keep the code clean and
    maintainable. This ensures that it is always in good shape.
  prefs: []
  type: TYPE_NORMAL
- en: As you have written only a few lines of code since the last refactor step, the
    changes needed to make the code clean shouldn't take much time.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TDD comes with advantages and disadvantages. These are the main advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You only write code that is needed**: You should stop writing production
    code when all your tests pass and you can''t think of another test to write. If
    your project needs another feature, you need a test to drive the implementation
    of that feature. The code you write is the simplest code possible. So, all the
    code ending up in the product is actually needed to implement the features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More modular design**: In TDD, you concentrate on one microfeature at a time.
    And as you write the test first, the code automatically becomes easy to test.
    Code that is easy to test has a clear interface. This results in a modular design
    for your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to maintain**: As the different parts of your app are decoupled from
    each other and have clear interfaces, the code becomes easier to maintain. You
    can exchange the implementation of a microfeature with a better implementation
    without affecting another module. You could even keep the tests and rewrite the
    complete app. When all the tests pass, you are done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to refactor**: Every feature is thoroughly tested. You don''t need
    to be afraid to make drastic changes because if all the tests still pass, everything
    is fine. This point is very important because you, as a developer, improve your
    skills each and every day. If you open the project after 6 months of working on
    something else, most probably, you''ll have many ideas on how to improve the code.
    But your memory about all the different parts and how they fit together won''t
    be fresh anymore. So, making changes can be dangerous. With a complete test suite,
    you can easily improve the code without the fear of breaking your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High test coverage**: There is a test for every feature. This results in
    high test coverage. High test coverage helps you gain confidence in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests document the code**: Test code shows how your code is meant to be used.
    As such, it documents your code. Test code is sample code that shows what the
    code does and how the interface has to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less debugging**: How often have you wasted a day finding a nasty bug? How
    often have you copied an error message from Xcode and searched for it on the internet?
    With TDD, you write fewer bugs because the tests tell you early on whether you''ve
    made a mistake. And the bugs you write are found much earlier. You can concentrate
    on fixing bugs when your memory is still fresh about what the code is supposed
    to do and how it does it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we'll discuss the disadvantages of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like everything else in the world, TDD has some disadvantages. The main
    ones are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No silver bullet**: Tests help to find bugs, but they can''t find all bugs
    that you introduce in the test code and implementation code. If you haven''t understood
    the problem you need to solve, writing tests most probably won''t help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It seems slower at the beginning**: When you start TDD, you will get the
    feeling that it takes longer to make easy implementations. You need to think about
    the interfaces, write the test code, and run the tests before you can finally
    start writing the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All the members of a team need to do it**: As TDD influences the design of
    code, it is recommended that either all the members of a team use TDD or no one
    at all. In addition to this, it''s sometimes difficult to justify TDD to management
    because they often have the feeling that the implementation of new features takes
    longer if developers write code that won''t end up in the product half of the
    time. It helps if the whole team agrees on the importance of unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests need to be maintained when requirements change**: Probably, the strongest
    argument against TDD is that the tests have to be maintained just as the code
    has to. Whenever requirements change, you need to change the code and tests. But
    you are working with TDD. This means that you need to change the tests first,
    and then make the tests pass. So, in reality, tests help you to understand the
    new requirements and implement the code without breaking other features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginners often ask which part of their code they should write tests for. The
    following section tries to find an answer to that.
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What should be tested? When using TDD and following its ideology, the answer
    is easy – everything. You only write production code because there is a failing
    test.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it's not that easy. For example, should the position and color
    of a button be tested? Should the view hierarchy be tested? Probably not; the
    color and exact position of the button is not important for the functioning of
    an app. In the early stages of development, these kinds of things tend to change.
    With Auto Layout, different screen sizes, and different localizations of apps,
    the exact position of buttons and labels depends on many parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should test the features that make the app useful for a user
    and those that need to work. Users don't care whether the button is exactly 20
    points from the rightmost edge of the screen. Users seek apps that are easy to
    understand and a joy to use.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, you should not test the whole app at once using unit tests.
    Unit tests are meant to test small units of computation. They need to be fast
    and reliable. Things such as database access and networking should be tested using
    integration tests, where the tests drive the real finished app. Integration tests
    are allowed to be slow because they are run a lot less often than unit tests.
    Usually, they are run with the help of a continuous integration system each night
    on a server, where it doesn't matter that the complete test suite takes several
    minutes (or even hours) to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dipped our toes into the new waters of TDD in general. The
    chapter showed the workflow of TDD – red, green, refactor – which we will use
    throughout this book to build an app. In addition, we have seen what the advantages
    and the disadvantages of TDD are.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore how TDD works in Xcode, the tool most
    of us use to build iOS apps.
  prefs: []
  type: TYPE_NORMAL
