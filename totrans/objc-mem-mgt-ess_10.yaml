- en: Chapter 10. Tips and Tricks for Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory management is something that every programmer dealing with Objective-C
    will encounter although Apple introduces a lot of tools to assist in ferreting
    out memory-related issues such as Instruments and NSZombies. There are some more
    subtle techniques and tools that are present in Objective-C and Xcode, which we
    will be looking into in this chapter. Some are obvious and some will give you
    a new perspective with regards to Objective-C. We will also cover some important
    topics such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the @property keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the getter/setter methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the property attribute in Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to avoid KVC and KVO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C, C, and memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objective-C and the C programming language are closely related as Objective-C
    is a proper superset of C, which means that anything that works in C will work
    with Objective-C. So inherently, it also means that memory management methods
    and protocols that you are familiar with in C or C++ will also apply to Objective-C.
    However, a good thing about Objective-C is that the compiler does a lot of this
    memory management for you under the hood. This means that you do not need to write
    too much code to handle memory management in Objective-C compared to C or C++.
  prefs: []
  type: TYPE_NORMAL
- en: However, do note that although you can mix C++ and Objective-C together, Objective-C
    is not a superset of C++. This does not mean that you can be totally hands off
    with regards to memory management since Objective-C does not have a garbage collector
    like what you get in Java.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of **Automatic Reference Counting** (**ARC**) support in Xcode
    4.2 and iOS 4 and 5 onwards, developers everywhere thought that their days of
    laborious memory management are over, but make no mistake as you need to keep
    in mind that ARC is a compile time memory management mechanism, where the compiler
    will examine the source code and then add the `retain` and `release` messages
    into the compiled code. ARC is not the traditional garbage collection mechanism
    that Java and C# programmers are familiar with where garbage collection is done
    during runtime by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: So, the introduction of ARC means that there is even less typing for you as
    a developer as you do not need to type in `retain` and `release` messages explicitly
    into your code, which makes your code more verbose. However, as we saw in the
    previous chapters where we introduced retain cycles and other types of memory
    leaks, using ARC means that you will still need to be aware of memory management
    principles and that is where Objective-C and Xcode shines compared to their C
    programming language counterparts. Its built-in mechanism helps programmers avoid
    leaking memory through a series of good practices. So, let's start by looking
    at these good practices in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have done some Java and C# programming and come from a Java or C# background,
    you should be familiar with getter and setter methods or you may also know them
    as accessors and mutators, respectively. They are a fundamental pillar of good
    programming. Getters/setters or accessors/mutators, are also known as methods
    used in keeping the principle of encapsulation where member variables are made
    private to protect them from other code which could be potentially malicious,
    and the getter/setter acts as a gatekeeper or intermediary between the private
    member variable and other code. Take a look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding two methods should not be unfamiliar to you from a Java or C#
    perspective. Getters and setters can be considered bad if used improperly. Making
    a variable public and yet writing a getter and setter method is a good example
    as this violates the concept of encapsulation. Now, getter and setter methods
    are a good foundation for recommended programming practices as they confer the
    following benefits and more:'
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the internal state of the objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting different access levels such as read only, write only, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a public interface will make it easier for you to make code changes
    when you need to change the implementation layer, which will be apparent when
    you need to make changes across many files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing you to enforce strict rules on what can be done and not be done with
    your objects via these getter and setter methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getter and setter methods generally start with the get and set prefix. This
    may come as a surprise to you, but Objective-C has very strong support for getter
    and setter methods. However, you may ask, "where are the getter and setter methods
    in Objective-C? I don't recall setting any methods or writing any code that start
    with `get` or `set`?" However, actually, they are present and are already in your
    code, but you just do not realize it yet since Objective-C has an abstraction
    layer for you so that you do not need to spend too much time writing getter and
    setter methods. This abstraction layer allows you to customize your getter and
    setter methods as we shall see later on. The way that Objective-C lets you define
    get and set methods and the various attributes such as `readonly`, `readwrite`,
    and so on is via the `@property` keyword in your code. Getters and setters go
    hand in hand with memory management as you can write code to clean up the memory
    in these methods if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: The property attribute in Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been doing some Objective-C programming, you would have come across
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I would bet that you would generally have a foggy idea of what terms such
    as `nonatomic` or `retain` mean when you are assigning these properties such as
    `nonatomic` and so on to your objects. These keywords, such as `nonatomic` or
    `readonly`, actually define the properties of your objects, which are used in
    the getter and setter methods automatically created for you in Xcode. These terms
    are coding keywords related to memory management and access control and were not
    created just to baffle you or to give you additional typing to do (at least not
    as much typing as typing getter and setter methods themselves). Anyway, let''s
    go through what these terms mean so that you will get a better understanding of
    these keywords in relation to getter and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `nonatomic` | This property is not thread safe, but it is faster than `atomic`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic` | This property is used for completeness and will not allow bad
    things to happen if a different thread tries to access this object at some point
    in your code. However, it is slower than `nonatomic` due to additional bookkeeping
    overhead required. |'
  prefs: []
  type: TYPE_TB
- en: '| `strong` | This is used with ARC and helps by not letting you worry about
    the retain count of an object as it is autoreleased when you are done with it.
    In code that does not support ARC, it is a synonym for the retain property. |'
  prefs: []
  type: TYPE_TB
- en: '| `weak` | This means that the reference count is not increased by 1, and it
    does not become an owner of an object, but it does hold a reference to it. This
    is just another term for `unsafe_unretained` for the non-ARC code. |'
  prefs: []
  type: TYPE_TB
- en: '| `assign` | This property will generate a setter method, which will assign
    the value to the object instead of copying or retaining it. |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` | This is used for when the object is mutable where you create a copy
    of the object. Do note that copy cannot be used together with retain as the copy
    of the object will already have its retain count incremented by 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `readonly` | This property will make the object read-only and no setter method
    will be created in the `@implementation` section of the code. |'
  prefs: []
  type: TYPE_TB
- en: '| `readwrite` | This means that the `read` and `write` attribute properties
    are applicable and the getter and setter methods are automatically created for
    you. |'
  prefs: []
  type: TYPE_TB
- en: So, `@property(nonatomic, retain) NSString *text` will tell the compiler, "I
    have a member variable of the type NSString named text, so I will need a pair
    of getter/setter methods, which will use the retain/release procedure."
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have defined the attributes of your member variables such as which
    one has `readonly`, which one has `readwrite`, and so on, what next?
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will use the `@synthesize` keyword. The `@synthesize` keyword will
    tell the compiler, "Now that I have declared the property `nonatomic` and `retain`
    for my `NSString *text` object, please create the code now for the getter and
    setter pair of methods for my `NSString *text` object."
  prefs: []
  type: TYPE_NORMAL
- en: So, with just these two lines of code, we can tell Objective-C to create our
    getter and setter methods for us and assign properties such as read-only, write-only,
    and so on for our objects or variables. This is much better than typing in verbose
    getter and setter code as you would do in Java or C#.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do note that `@synthesize` is automatically provided to you by default in Xcode
    4.4 and onwards, but there may be cases where you need to add in the `@synthesize`
    keyword yourself explicitly, which we will go through later.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know why `@synthesize` does what it does. `@property` and `@synthesize`
    helps to automate the creation of getter and setter methods along with ease of
    creation with regards to access rules and controls with only a few lines of code.
    The getter and setter methods do exist once you use `@property` and `@synthesize`,
    but you do not see them physically in your code as these methods do not show up
    in your code base, but you can actually have access to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at my property declaration here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In your implementation file, you will find that the following code will compile
    perfectly fine, and this shows that `_myInt` is accessing the variable directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the variable is synthesized, an instance variable (or iVar for short) is
    automatically created and prefaced with an underscore. The presence of this underscore
    in a variable name is a naming convention to indicate that this is an iVar, and
    this is done automatically for you within Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is why there is no compiler error when you call `_myInt` as `_myInt`
    is automatically created for you by the compiler when you tell the compiler the
    properties of what `myInt` will do.
  prefs: []
  type: TYPE_NORMAL
- en: '`@synthesize` will also create the validation rules, which you assign to a
    variable using your `@property` keyword. Validation rules such as `readonly` means
    that when you try to assign a value to your variable, you will get a compiler
    error **read only property cannot be reassigned**, and that is the validation
    rule of your automatically created setter (mutator) method at work without the
    writing of verbose code.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some code, shall we? Let's create an object called `UserObject`
    and assign a variable call `Age` to it.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: We begin by clicking on **File** | **New** or by pressing *Command* + *N* on
    your keyboard, and select **Cocoa Touch** and **Objective-C class**, as shown
    here:![The property attribute in Objective-C](img/00050.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we put in the name of the class, which is `UserObject`, and leave it as
    a subclass of `NSObject`:![The property attribute in Objective-C](img/00051.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on **Next** followed by **Create** and your `UserObject` class
    will be created for you. Then, you should end up with this in your `UserObject.h`
    file. Add an integer called `age` and assign the `nonatomic` and `readonly` properties
    to it in your `UserObject` header file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now if you try to build your code, you will get a warning, **Autosynthesized
    property 'age' will use synthesized instance variable '_age', not existing instance
    variable 'age',** because you have not explicitly added in the code `@synthesize
    age` in the `.m` implementation file of your `UserObject` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This warning is just a friendly reminder that since you did not add in the
    `@synthesize age` code, Xcode will create an instance variable called `_age` for
    all your setter and getter methods. This is a harmless warning, but for me, I
    prefer to keep my code as warning free as possible, so I will add the `@synthesize
    age;` line of code to my `.m` implementation file of `UserObject` and get something
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add `NSString *name` to our `UserObject` class and assign the `readwrite`,
    `nonatomic` property so that our code will now look as follows. The `readwrite`
    property as shown previously will tell the compiler that we want getter and setter
    methods to be automatically created for us and that the `nonatomic` property means
    that we are okay with the `age` variable being non-thread-safe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now create an instance of the `UserObject` class using `UserObject *user
    = [[UserObject alloc] init]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we can see the magic of Xcode, where we put in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we did not create a getter or setter method for our `NSString *name`,
    but Xcode was smart enough to create it for us once we assigned the properties
    to `NSString *name`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, in some specific cases, you may want to override the default getter
    and setter methods that Xcode provides. Doing so is very easy, and using our `int
    age` as an example, we just create the following methods in our `UserObject .h`
    header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We put in our custom getter and setter methods in our `.m`, `UserObject` implementation
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So now, when you call the `setAge` method explicitly using the syntax such as
    `[self setAge];`, the code will call your custom setter method, since you have
    added your own getter and setter code to override the default getter and setter
    code that Xcode has created for you. This gives you efficiency and flexibility
    as Xcode will assume that you want the default getter and setter methods for your
    variables, and yet, you are free to override them if you need to which could occur
    in special cases.
  prefs: []
  type: TYPE_NORMAL
- en: Performance guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although iOS devices such as iPhones and iPads have a lot of memory compared
    to the early Nokia phones, it does not mean that you can be sloppy with regards
    to memory management. The iOS memory model and other mobile OSes do not include
    disk swap space, which are present on computer OSes, where persistent storage
    space is used as an extension of the memory space so that persistent storage can
    be used as a form of RAM for situations where low memory is encountered. So, the
    apps that you develop for iOS devices are more limited in the amount of memory
    that you can access.
  prefs: []
  type: TYPE_NORMAL
- en: Using large amounts of memory will lead to a serious degradation of system performance
    and triggering of the three memory warning levels, where the last warning level
    will lead to your application crashing. Plus, apps running under multitasking
    will share system memory with all other running apps that have higher priority
    such as the SMS application and phone application. So, you will never have 100
    percent of the phone memory available for your application under any circumstance
    and even a brand new iOS device will have background processes running. So, reducing
    the amount of memory used by your iOS app should be a high priority task and not
    something that should be filed under a low priority tag.
  prefs: []
  type: TYPE_NORMAL
- en: If there is less free memory available in your device, that means the system
    will have a higher probability of being unable to fulfill future memory requests.
    If such a situation was to occur, the system will remove suspected apps and nonvolatile
    resources from memory. However, this is not a good solution as this is only temporary
    and those suspended apps and nonvolatile resources may be needed again a short
    while later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UIViewController` class in `UIKit` in the iOS SDK provides useful ways
    to help you receive memory warnings in the console, which we saw in the previous
    chapters. I have listed three ways to implement memory warning notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: You should implement the `applicationDidReceiveMemoryWarning` delegate method
    as this will be triggered when your application has some low memory warnings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a more granular memory warning such as `Received memory warning. Level=1`
    or `Received memory warning. Level=2` in your debug console, specifically for
    your `UIViewController`, you can implement the `didReceiveMemoryWarning` method
    of your custom `UIViewController` subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get down to a class level, you can register your object to receive the `UIApplicationDidReceiveMemoryWarningNotification`
    notification via the `addObserver` method to call a specific method once the memory
    is running low, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you see any of these warnings triggered in your code, you should respond
    immediately by looking at how you can write the code to free up any unwanted memory.
    A few ways to do this can be:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing any views that are not visible to the user but are still loaded in
    memory by calling the `removeFromSuperview` method such as `[myView removeFromSuperview];`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing any images that are not on screen by setting them to `nil`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purging any data structures that are not used by your code at this point in
    time by calling the `release` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine that you have a memory leak in your application and the leak causing
    the crash only appears after using the application for 2 hours. So, if you wish
    to replicate the memory leak and trigger the crash in your code, you need to run
    the application for 2 hours each time to see the crash. This can be a time consuming
    task as you need to leave your app running, but thankfully, Xcode provides a way
    to trigger the memory warning without actually producing a memory leak, and this
    feature comes courtesy of the iOS simulator. You can click on **Hardware** | **Simulate
    Memory Warning** in order to trigger a memory warning so that you can write and
    test your memory cleanup code under the relevant memory warning method handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows where you need to click to trigger a memory warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance guidelines](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Doing so will allow you to test your iOS application under low memory conditions
    and then write the relevant code to reduce memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Don't overthink about memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory management is not something that is overly complex or difficult to wrap
    your head around. So, in order to further aid you with memory management, here
    are a few handy tips:'
  prefs: []
  type: TYPE_NORMAL
- en: You can try to make your resource files such as audio, images, and property
    lists as small as possible. To reduce the space occupied by property list files,
    you can use the `NSPropertyListSerialization` class while the free, open source
    command-line tool called Pngcrush can be used to compress PNG files as you can
    have savings of 20 percent or more depending on your PNG files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core Data is more than just a persistent storage framework. Core Data provides
    a memory efficient way of managing large data sets, and if you manipulate large
    structured data, using the Core Data persistent store or SQLite database as a
    data store as opposed to NSData or NSUserDefault will ensure that you can have
    efficient memory usage provided by Apple's own Core Data framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources should always be loaded when you need it, such as when you only need
    to see it on the device screen. This is called lazy loading, which we have seen
    in the previous chapter. You could be tempted to load all resources much in advance
    before you actually use it. However, this will actually mean that your resource
    is occupying memory when it is actually not being used at the current moment.
    So to optimize memory usage, always practice lazy loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, this is a little-known tip that you can use in your **Build Settings**:
    you can add the `-mthumb` compiler flag to help reduce the size of your code by
    using 16-bit instructions instead of 32-bit instructions, which uses up less space
    and this can result in savings of up to 35 percent. However, one caveat is that
    if your iOS application floating point intensive code and your application needs
    to support ARMv6 such as older generation iPod Touches and older iPhones, then
    the `-mthumb` option should not be used for your application. However, if your
    code is for ARMv7, then you can enable the `-mthumb` option in your Xcode project,
    which is enabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to avoid KVC and KVO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KVC and KVO, which we covered previously in [Chapter 7](part0056_split_000.html#page
    "Chapter 7. Key-value Programming Approaches"), *Key-value Programming Approaches*,
    seems like a great mechanism for notifications at a very granular level, but it
    is possible to go wrong with KVO if you use it incorrectly. The `removeObserver`
    method will crash if you are not the observer for that key path, so keeping an
    exact track of the properties that you are observing is a must.
  prefs: []
  type: TYPE_NORMAL
- en: 'KVO only has one callback method. If you have multiple notifications, you need
    to handle them within one callback method, which makes your code inelegant and
    clunky like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With a few more notifications, you will write a lot of if-else statements and
    you will be able to see how unwieldy the code will be and many bad things such
    as crashes, bugs, and so on will appear, and this requires more debugging time.
  prefs: []
  type: TYPE_NORMAL
- en: KVO registering can crash your app if you do it multiple times. If you have
    a superclass that is observing the same parameter on the same object, the `removeObserver`
    method will be called twice and it would lead to a crash on the second time.
  prefs: []
  type: TYPE_NORMAL
- en: KVO works in a wonderful and magical way in the same way as callbacks. Code
    utilizing callback can be painful to debug. So, I would recommend KVO usage if
    you have adequate experience with KVO and start with small projects as the API
    documentation is sparse and it can lead to debugging problems down the road if
    you are not well versed with KVO.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we reached the end of this chapter. This chapter covers some details
    of Objective-C, such as property attributes, which you have been typing in but
    do not have a clear idea of. We also covered memory management guidelines, where
    I have outlined some tips and tricks to add to your knowledge of memory management
    and debugging memory-related issues in your code. This chapter just covers a small
    subset of memory management and I hope that you have dived deep into the previous
    chapters, where the various memory management techniques are covered more in-depth.
    Finally, one more chapter lies ahead, where we will go through some of the new
    tools and functionalities of Xcode 6, which you can use in your projects. So,
    let's proceed, shall we?
  prefs: []
  type: TYPE_NORMAL
