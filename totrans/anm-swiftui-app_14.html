<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor204"/>14</h1>
<h1 id="_idParaDest-194"><a id="_idTextAnchor205"/>Creating a Color Game</h1>
<p>In the last chapter, we built a game where the user had to find words by using the letters of a larger word. In this project, we will continue the “finding” theme and build another game, where the user must find colors within a broader color.</p>
<p>The goal of this project will be to generate a random RGB color and then have the user manipulate separate sliders for each of the individual RGB values in order to completely match that random color. For example, there will be one slider for red, one slider for green, and one slider for blue, with each slider containing a range from 0 to 255 (the range of each RGB value). Then, the user will have to adjust those sliders to see whether they can find the exact RGB random color. </p>
<p>We will also add three difficulty levels to the game, from easy to extreme. And if the user is skilled enough to work out the individual RGB values in the given color, we will display a shower of confetti over the user interface.</p>
<p>In building this game, you will learn about adding pre-built animations to a project using Swift packages, which includes the aforementioned confetti animation for when the user gets a high score. We will also add a spring animation to SwiftUI sliders and make them visible when needed, and invisible when not.</p>
<p>So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding colors</li>
<li>Creating the <code>Title</code> View</li>
<li>Creating the target and guess circles</li>
<li>Creating the <code>Picker</code> View</li>
<li>Creating the target and guess rectangles</li>
<li>Making the color sliders</li>
<li>Keeping track of the user’s score with a button</li>
<li>Showing the user’s score in an <code>Alert</code> View</li>
<li>Resetting the game</li>
<li>Adding a background</li>
<li>Adding confetti using Swift packages</li>
</ul>
<h1 id="_idParaDest-195"><a id="_idTextAnchor206"/>Technical requirements</h1>
<p>As always, you can find the code and download the completed project from the <code>Chapter 14</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor207"/>Understanding colors</h1>
<p>Before we begin, let’s just have<a id="_idIndexMarker773"/> a quick look at colors. There are two color models that you may be familiar with, primary colors and RGB colors.</p>
<p>Primary colors are the basic colors from which all other colors can be derived. In traditional color theory, the primary colors are red, blue, and yellow. Primary colors are used in many different fields, such as art, printing, and graphic design.</p>
<p>RGB (which is short for Red, Green, and Blue) colors make up a color model in which the colors are combined to create different intensities of red, green, and blue light that can be displayed on electronic displays and devices, such as computers, TVs, phones, and tablets.</p>
<p>RGB colors<a id="_idIndexMarker774"/> are represented by their red, green, and blue components, each of which has a value between 0 and 255. The value 0 represents the absence of that color, while 255 represents the maximum intensity of that color. By varying the values of the RGB components, a wide range of colors can be created. For example, (255, 0, 0) represents pure red, (0, 255, 0) represents pure green, and (0, 0, 255) represents pure blue. Combinations of these colors can create many different colors and hues of colors.</p>
<p>We will be adding three sliders, which will represent<a id="_idIndexMarker775"/> each RGB color, and the user has to manipulate those sliders to find a target color by combining different amounts of those RGB colors.</p>
<p>Let’s jump right in and get this game off the ground. We’ll start by adding a title to the user interface.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor208"/>Creating the Title view</h1>
<p>Let’s get started by creating<a id="_idIndexMarker776"/> a new Xcode project – I’m calling it <code>VStack</code> to organize the views vertically.</p>
<p>The first objective here will be to give the UI a title; it’s not a lot of code, but we’ll still put it in its own file anyway. So, create a new SwiftUI View file, and call it <code>TitleView</code>, then add the following code to the <code>body</code> property:</p>
<pre class="source-code">
struct TitleView: View {
    var body: some View {
        HStack {
            Text("Find").foregroundColor(.red)
            Text("The").foregroundColor(.green)
            Text("Color").foregroundColor(.blue)
        } .foregroundColor(.blue)
            .fontWeight(.black)
            .font(Font.system(size: 35, design: .serif))
    }
}</pre>
<p>Inside the <code>HStack</code>, there are three <code>Text</code> views, each with different colors – <code>"Find"</code> with the red color, <code>"The"</code> with green, and <code>"Color"</code> with blue – all colored using the <code>foregroundColor</code> modifier.</p>
<p>After the <code>HStack</code>, three additional modifiers are applied to the view. The first is <code>.foregroundColor(.blue)</code>, which sets the text color of all the <code>Text</code> views to blue. The next is <code>.fontWeight(.black)</code>, which sets the font weight of all the <code>Text</code> views to bold. And lastly, <code>.font(Font.system(size: 35, design: .serif))</code> sets the font and size of all the <code>Text</code> views to <code>35</code> points with a Serif design font.</p>
<p>Next, we’ll go back into <code>ContentView</code> and display the title by adding the following code:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack {
                //MARK: - TITLE
                 TitleView().padding()
        }
    }
}</pre>
<p>I also added some <code>padding</code> so the <code>Title</code> view won’t be too close to the notch at the top of the iPhone<a id="_idIndexMarker777"/> when we finish adding all the views.</p>
<p>And now, we can see the colorful title that starts off the UI:</p>
<div><div><img alt="Figure 14.1: Game title " src="img/B18674_14_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1: Game title</p>
<p>With that, we can move on to the next part of the UI, the target and guess circles.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor209"/>Creating the target and guess circles</h1>
<p>The next task<a id="_idIndexMarker778"/> is to create<a id="_idIndexMarker779"/> two colored circles:</p>
<ul>
<li>One circle will be the target circle, which will show a randomly generated color; because it is an RGB color, the user will need to combine three RGB values to find this target color.</li>
<li>The other circle will be their “guess” circle – kind of like a sketchpad, where the user can see their current progress as they manipulate the sliders.</li>
</ul>
<p>These two circles<a id="_idIndexMarker780"/> will be created<a id="_idIndexMarker781"/> in their own SwiftUI file, so let’s make them now. Press <em class="italic">Command + N</em>, select <code>TargetAndGuessCircleView</code>. </p>
<p>We want to use this file inside of <code>ContentView</code> – in order to do so, we will need some <code>Binding</code> variables inside the struct:</p>
<pre class="source-code">
struct TargetAndGuessCircleView: View {
    //target variables
    @Binding var redTarget: Double
    @Binding var greenTarget: Double
    @Binding var blueTarget: Double
    
    //guess variables
    @Binding var redGuess: Double
    @Binding var greenGuess: Double
    @Binding var blueGuess: Double
    
    //picker variable
    @Binding var selectedPickerIndex: Int
           •••••••</pre>
<p>There are seven variables needed for this file – three variables for the target circle, three variables for the guess circle, and one integer (which we will use for a <code>Picker</code> view) will allow the user to select a difficulty level. </p>
<p>After adding those <code>Binding</code> properties, we notice we have an error in the <code>previews</code> struct. Remember that when we add these variables to a file, the <code>previews</code> struct always has to be updated<a id="_idIndexMarker782"/> with some dummy<a id="_idIndexMarker783"/> data in order for it to work again. So, modify the <code>previews</code> struct so it looks like this:</p>
<pre class="source-code">
struct TargetAndGuessCircleView_Previews: PreviewProvider {
    static var previews: some View {
        TargetAndGuessCircleView(redTarget: .constant(0.3), 
        greenTarget: .constant(0.2), blueTarget: 
        .constant(0.7), redGuess: .constant(0.7), 
        greenGuess: .constant(0.4), blueGuess: 
        .constant(0.7), selectedPickerIndex: .constant(2))
    }
}</pre>
<p>After that, let’s go back into the <code>body</code> property. We want to add a <code>ZStack</code> so that we can overlay the target circle over the guess circle. We can create these two circles with the following code:</p>
<pre class="source-code">
ZStack {
    //MARK: - GUESS CIRCLE
    if selectedPickerIndex == 0 {
        Circle()
            .fill(Color(red: redGuess, green: greenTarget,
              blue: blueTarget, opacity: 1.0))
            .frame(height: 200)
    }
    else if selectedPickerIndex == 1 {
        Circle()
            .fill(Color(red: redGuess, green: greenGuess,
              blue: blueTarget, opacity: 1.0))
    .frame(height: 200)
    }
    else if selectedPickerIndex == 2 {
        Circle()
            .fill(Color(red: redGuess, green: greenGuess,
              blue: blueGuess, opacity: 1.0))
            .frame(height: 200)
    }
     
     //MARK: - TARGET CIRCLE
     Circle()
        .fill(Color(red: redTarget, green: greenTarget,
          blue: blueTarget, opacity: 1.0))
        .frame(height: 80)
}</pre>
<p>Inside the <code>ZStack</code>, we start off with the guess<a id="_idIndexMarker784"/> circle; this will be the bigger<a id="_idIndexMarker785"/> circle, with the <code>frame</code> height set to <code>200</code>. Here, we’re using an <code>if else</code> statement and checking the <code>selectedPickerIndex</code> variable to see what difficulty level the user has chosen. If they’ve chosen <code>0</code>; in that case, we will supply the green and blue RGB target colors to the user, so they only have to work out the red RGB target value. If they’ve selected <code>1</code>; in that case, we only supply the user with the blue RGB value, and they have to work out the red and green values themselves. Finally, if the user selected the <code>2</code>; in that case, we don’t supply the user with any RGB target values and they have to work out the individual target color value themselves.</p>
<p>Next, we create the target circle – this will be the randomly generated<a id="_idIndexMarker786"/> colored circle that the user<a id="_idIndexMarker787"/> has to try and match by manipulating the sliders. Notice that we’re creating this circle much smaller, only <code>80</code> points, and because we are in a <code>ZStack</code>, this circle will be on top of the guess circle. The reason for this overlaying of circles is that as the user is trying to work out the colors, their guess circle will change in color and they can better visualize how close they are to the target color.</p>
<p>Lastly, at the end of the <code>ZStack</code>, we’re using the <code>onAppear</code> modifier. This modifier will run an action every time the <code>ZStack</code> gets redrawn; if the <code>ZStack</code> gets redrawn, it means the user chose to play a new game (using a button that we will create later) and the sliders will go back to <strong class="bold">0</strong>.</p>
<p>That finishes up the <code>TargetAndGuessCircleView</code> file. Let’s go back into <code>ContentView</code> and add the <code>State</code> variables that we need in order to display <code>TargetAndGuessCircleView</code>:</p>
<pre class="source-code">
//target variables
    @State var redTarget = Double.random(in: 0..&lt;1)
    @State var greenTarget = Double.random(in: 0..&lt;1)
    @State var blueTarget = Double.random(in: 0..&lt;1)
    //guess variables
    @State var redGuess: Double
    @State var greenGuess: Double
    @State var blueGuess: Double
    //picker variable
    @State var selectedPickerIndex = 1</pre>
<p>There are seven <code>State</code> properties, one for each of the <code>Binding</code> properties we made in the previous file. The variables are each set to a random double value between <code>0</code> and <code>1</code> using the <code>Double.random(in: 0..&lt;1)</code> method. The function will generate a new random number every time it’s called, meaning that every time the user starts a new game, a new random value will be used to pick an RGB value.</p>
<p>Continuing from here, we notice<a id="_idIndexMarker788"/> that there’s an error<a id="_idIndexMarker789"/> in the <code>Previews</code> struct of <code>ContentView</code>. This is a familiar error – it is Xcode telling us that we declared a property in the <code>ContentView</code> struct, yet we are not including it here in the <code>Previews</code> struct. Let’s fix that by inputting some data into the <code>Previews</code> struct, like so:</p>
<pre class="source-code">
ContentView(redGuess: 0.5, greenGuess: 0.5, blueGuess: 0.5)</pre>
<p>That will fix the error in <code>ContentView</code>, but we also need to update the Swift file that contains the main startup code for the project. That file will be named the same as what you named your app – I named this project <code>Find the Color</code>, so in the Project Navigator to the left of Xcode, there will be a file with a Swift extension, called <code>Find_The_ColorApp.swift</code>.</p>
<p>Click on that Swift file, and update the code to the following:</p>
<pre class="source-code">
@main
struct Find_The_ColorApp: App {
  var body: some Scene {
      WindowGroup {
          ContentView(redGuess: 0.5, greenGuess: 0.5,
            blueGuess: 0.5)
      }
  }
}</pre>
<p>We can now go back into <code>ContentView</code>, call the <code>TargetAndGuessCircleView</code> file, and pass in the appropriate <code>State</code> variables. Add the following code directly underneath the title code:</p>
<pre class="source-code">
//MARK: - TARGET AND GUESS CIRCLES
    TargetAndGuessCircleView(redTarget: $redTarget,
      greenTarget: $greenTarget, blueTarget: $blueTarget,
      redGuess: $redGuess, greenGuess: $greenGuess,
      blueGuess: $blueGuess, selectedPickerIndex:
      $selectedPickerIndex)</pre>
<p>This is how<a id="_idIndexMarker790"/> the UI should<a id="_idIndexMarker791"/> look now:</p>
<div><div><img alt="Figure 14.2: Target and guess circles " src="img/B18674_14_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2: Target and guess circles</p>
<p>Let’s continue by adding the <code>Picker</code> view to allow the user to select the difficulty for the game.</p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor210"/>Creating the Picker view</h1>
<p>To create the <code>Picker</code> view, let’s make<a id="_idIndexMarker792"/> a new SwiftUI View file called <code>PickerView</code> for this purpose.</p>
<p>Inside this file, we need to add a <code>Binding</code> property so that we can use it inside <code>ContentView</code>, as well as add an array of titles for the picker:</p>
<pre class="source-code">
    @Binding var selectedPickerIndex: Int
    @State var levels = ["Easy 😌", "Hard 😓", "Extreme! 
      🥵"]</pre>
<p>The code here has a <code>Binding</code> variable to hold the value of <code>selectedPickerIndex</code>; that way, we can keep track of which button on the picker the user has selected. Then, we have a <code>State</code> array of titles that we will use on the individual picker buttons, along with an appropriate emoji signifying the difficulty level.</p>
<p>Next, as we’ve done before, update the <code>Previews</code> struct with some dummy data, to satisfy Xcode:</p>
<pre class="source-code">
struct PickerView_Previews: PreviewProvider {
    static var previews: some View {
        PickerView(selectedPickerIndex: .constant(1))
    }
}</pre>
<p>With the previews up and running, we can now create and style the <code>Picker</code> control. Move into the <code>body</code> property and add this code:</p>
<pre class="source-code">
 var body: some View {
  VStack {
      Picker("Numbers", selection: $selectedPickerIndex) {
              ForEach(0 ..&lt; levels.count, id: \.self) { 
                index in
                  Text(levels[index])
              }
          }
          .pickerStyle(SegmentedPickerStyle())
          .background(Color.yellow)
          .cornerRadius(8)
          .padding(.horizontal)
          .shadow(color: Color.black, radius: 2, y: 4)
          .padding(.top)
      
      Text("Difficulty Level: " + 
        "\(levels[selectedPickerIndex])").bold()
          .padding(5)
          .animation(.easeInOut(duration: 0.2), value:
            selectedPickerIndex)
      }
  }
}</pre>
<p>This is what we are doing here.</p>
<p>The code adds a <code>Picker</code> component<a id="_idIndexMarker793"/> and a <code>Text</code> component. The <code>VStack</code> is used to arrange the <code>Picker</code> and <code>Text</code> components vertically. <code>Picker</code> is used to display a list of options, with the options being the elements in the <code>levels</code> array; it takes two arguments: <code>Numbers</code> and <code>selection: $selectedPickerIndex</code>, where <code>Numbers</code> is the label for the picker and <code>$selectedPickerIndex</code> is a state variable that keeps track of the currently selected option.</p>
<p>The <code>ForEach</code> loop is used to iterate through the <code>levels</code> array, creating a new <code>Text</code> component for each element in the array. Each <code>Text</code> component is configured to display the corresponding element from the <code>levels</code> array.</p>
<p>The <code>pickerStyle</code> method is used to change<a id="_idIndexMarker794"/> the appearance of the picker to a segmented picker style. We have used the <code>background</code>, <code>cornerRadius</code>, <code>padding</code>, and <code>shadow</code> modifiers before, and these apply various visual styles to the picker.</p>
<p>The <code>Text</code> component is used to display the difficulty level in the UI under the <code>Picker</code> component. It takes the <code>"Difficulty Level: " + "(levels[selectedPickerIndex])"</code> string and makes it bold, then applies some padding and animation to it. The animation is added so that instead of the difficulty level string appearing and disappearing instantly, it will ease in and out with a <code>0.2</code>-second duration, for a smoother transition in the UI.</p>
<p>Now, we have a <code>Picker</code> component that can be used to select the difficulty level of the game, and a <code>Text</code> string to display that level.</p>
<p>The result is shown here:</p>
<div><div><img alt="Figure 14.3: The segmented picker " src="img/B18674_14_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3: The segmented picker</p>
<p>With the <code>Picker</code> control done, move back<a id="_idIndexMarker795"/> into <code>ContentView</code> and call <code>PickerView</code><strong class="bold"> </strong>directly under the target and guess circle code:</p>
<pre class="source-code">
//MARK: - PICKER
    PickerView(selectedPickerIndex: $selectedPickerIndex)</pre>
<p>That code will add the <code>PickerView</code> file into the UI under the target and guess circles. The result is shown here:</p>
<div><div><img alt="Figure 14.4: The picker in the UI " src="img/B18674_14_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4: The picker in the UI</p>
<p>Now, if you click on the picker, you will see that the guess circle changes color; it won’t change to more than three shades of colors, as the picker displays a random color from each RGB value while the preview is running. If you stop the preview and restart it, another set of three random colors will be displayed.</p>
<p>Shortly, we will implement sliders to change the guess<a id="_idIndexMarker796"/> circle colors, and change the target circle color when the user starts a new game. Before that, let’s continue with the next part of the UI, making target and guess rectangles. I’ll explain what they are for next.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor211"/>Creating the target and guess rectangles</h1>
<p>So far, we have given the user<a id="_idIndexMarker797"/> a guess circle<a id="_idIndexMarker798"/> so they can see how close they are coming to the target color. Let’s do something similar to that and give them another visual cue – let’s create a guess rectangle and a target rectangle, and put them directly under the <code>Picker</code> control. We can also add an RGB value indicator, so they can see the actual values of each slider as they change, which can be helpful when they’re trying to figure out how much of the slider they need to move and in which direction. </p>
<p>Start by creating a new file to make these rectangles, called <code>TargetAndGuessRectView</code>. This file will contain very similar code to the <code>TargetAndGuessCircleView</code> file, which means adding the needed <code>Binding</code> properties:</p>
<pre class="source-code">
    @Binding var redTarget: Double
    @Binding var greenTarget: Double
    @Binding var blueTarget: Double
    @Binding var redGuess: Double
    @Binding var greenGuess: Double
    @Binding var blueGuess: Double
    @Binding var selectedPickerIndex: Int</pre>
<p>You should be familiar with these <code>Binding</code> variables, as we’ve created them before in the <code>TargetAndGuessCircleView</code> file. Actually, you can refactor all the code and combine the two guess and target files into one file if you’d like, or create a data model and make the properties available to all the files... I’ll leave that as a challenge for you.</p>
<p>Moving on, we need a combination of VStacks and HStacks to position the <code>Rectangle</code> and <code>Text</code> views. Add this code to the body of the file (I’ll explain it all next):</p>
<pre class="source-code">
var body: some View {
  VStack {
      HStack {
          //MARK: - TARGET RECTANGLE
          VStack {
              Rectangle()
                  .foregroundColor(Color(red: redTarget,
                    green: greenTarget, blue: blueTarget, 
                    opacity: 1.0))
                  .cornerRadius(5)
                  .padding(.init(top: 0, leading: 10, 
                    bottom: 0, trailing: 0))
                  .frame(height: 40)
              Text("Target Color to Match").bold()
          }
          //MARK: - GUESS RECTANGLE
          VStack {
              if selectedPickerIndex == 0 {
                  Rectangle()
                      .foregroundColor(Color(red: redGuess,
                        green: greenTarget, blue: 
                        blueTarget, opacity: 1.0))
                      .modifier(rectModifier())
              }
             else if selectedPickerIndex == 1 {
                  Rectangle()
                .foregroundColor(Color(red: redGuess,
                  green: greenGuess, blue: blueTarget,
                  opacity: 1.0))
                .modifier(rectModifier())
         }
              else if selectedPickerIndex == 2 {
                   Rectangle()
                      .foregroundColor(Color(red: redGuess,
                        green: greenGuess, blue: blueGuess,
                        opacity: 1.0))
                      .modifier(rectModifier())
              }
              HStack {
                  Image(systemName: "r.circle.fill")
                      .foregroundColor(.red)
                  Text("\(Int(redGuess * 255.0))")
                      .font(.callout)
                  Image(systemName: "g.circle.fill")
                      .foregroundColor(.green)
                  Text("\(Int(greenGuess * 255.0))")
                      .font(.callout)
                  Image(systemName: "b.circle.fill")
                      .foregroundColor(.blue)
                  Text("\(Int(blueGuess * 255.0))")
                      .font(.callout)
              }
           }
      }
        }
    }
}
struct rectModifier : ViewModifier {
    func body(content: Content) -&gt; some View {
        content
            .cornerRadius(5)
            .padding(.init(top: 0, leading: 0, bottom: 0,
              trailing: 10))
            .frame(height: 40)
    }
}</pre>
<p>Here’s a breakdown of what the code is doing.</p>
<p>The first <code>VStack</code> contains<a id="_idIndexMarker799"/> a rectangle with the color<a id="_idIndexMarker800"/> determined by the values of <code>redTarget</code>, <code>greenTarget</code>, and <code>blueTarget</code>. It also has a corner radius of <code>5</code> and padding on the leading edge, with a height of <code>40</code>. Below the rectangle, there is a <code>Text</code> view displaying the <code>"Target Color to Match"</code> string in bold font.</p>
<p>The second <code>VStack</code> contains a rectangle with the color determined by the values of <code>redGuess</code>, <code>greenGuess</code>, and <code>blueGuess</code>, and is modified by the <code>rectModifier</code> struct (more on the <code>rectModifier</code> struct in a moment). The color of the rectangle is determined by <code>selectedPickerIndex</code>, which is an integer value. If <code>selectedPickerIndex</code> is <code>0</code>, the color is determined by <code>redGuess</code>, <code>greenTarget</code>, and <code>blueTarget</code>. If <code>selectedPickerIndex</code> is <code>1</code>, the color is determined by <code>redGuess</code>, <code>greenGuess</code>, and <code>blueTarget</code>. If <code>selectedPickerIndex</code> is <code>2</code>, the color is determined by <code>redGuess</code>, and <code>greenGuess</code>, <code>blueGuess</code>. Below the rectangle, there is an <code>HStack</code> containing an image and text displaying the values of <code>redGuess</code>, <code>greenGuess</code>, and <code>blueGuess</code>, respectively. </p>
<p>Now the target<a id="_idIndexMarker801"/> and guess rectangles<a id="_idIndexMarker802"/> are in place, as well as the three <code>Text</code> views that will display the RGB values as the user works the slider, let’s continue and look at that last bit of code, the <code>rectModifer</code> struct.</p>
<p>The <code>rectModifier</code> struct is a <code>ViewModifier</code> that modifies the <code>Rectangle</code> view. It is a struct that conforms to the <code>ViewModifier</code> protocol and defines a single method, <code>body(content: Content) -&gt; some View</code>, which takes a single argument content of the <code>Content</code> type and returns a modified version of that content wrapped in a <code>view</code>.</p>
<p>In this specific case, the struct is modifying the appearance of a <code>rectangle</code> view. The modifications are made by chaining together a series of view modifiers on the <code>content</code> parameter in the <code>body</code> method, such as setting the corner radius to <code>5</code>, adding <code>padding</code> to the trailing edge, and setting the height of the rectangle to <code>40</code>.</p>
<p>When <code>rectModifier()</code> is called, it is passed the <code>rectangle</code> view as the <code>content</code> parameter, and it applies the modifications defined in the struct to that <code>rectangle</code> view, returning the modified version of that view. In other words, <code>rectModifier()</code> is a simple way to package a set of modifiers that can be applied to any view, and it provides a way to reuse the same set of modifiers on multiple views, saving on coding time and readability.</p>
<p>Here is the result of what we just coded:</p>
<div><div><img alt="Figure 14.5: Target and guess rectangles " src="img/B18674_14_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5: Target and guess rectangles</p>
<p>The sliders will now display the RGB values for the user. </p>
<p>Now, it’s time<a id="_idIndexMarker803"/> to go back<a id="_idIndexMarker804"/> into the <code>ContentView</code> and make a call to this file directly underneath the <code>Picker</code> code so that we can display these two rectangles and text in the main UI:</p>
<pre class="source-code">
 //MARK: - TARGET AND GUESS RECTANGLES
    TargetAndGuessRectView(redTarget: $redTarget,
      greenTarget: $greenTarget, blueTarget: $blueTarget,
      redGuess: $redGuess, greenGuess: $greenGuess,
      blueGuess: $blueGuess, selectedPickerIndex:
      $selectedPickerIndex)</pre>
<p>Again, this is familiar code – we are simply calling <code>TargetAndGuessRectView</code> and passing<a id="_idIndexMarker805"/> in the appropriate <code>State</code> variables. Here<a id="_idIndexMarker806"/> is the result:</p>
<div><div><img alt="Figure 14.6: Target and Guess Rectangles in the UI " src="img/B18674_14_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6: Target and Guess Rectangles in the UI</p>
<p>We just need the sliders, and a button to check the score, so let’s do that now.</p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor212"/>Making the color sliders</h1>
<p>To start creating<a id="_idIndexMarker807"/> the sliders, make a new SwiftUI View file and call it <code>SliderView</code>.</p>
<p>As the sliders are only used to manipulate the guess circle, we won’t need any <code>Target</code> variables in this file. Instead, we just need three <code>Guess</code> variables, as well as a variable to track the value of the picker control, which you can add like this:</p>
<pre class="source-code">
    @Binding var redGuess: Double
    @Binding var greenGuess: Double
    @Binding var blueGuess: Double
    @Binding var selectedPickerIndex: Int</pre>
<p>Again, we need to update the <code>Previews</code> struct, because it’s giving us this error: <code>Binding</code> variables in its <code>SliderView</code> struct initializer. Let’s give it what it wants, by updating <code>Previews</code> with the following code:</p>
<pre class="source-code">
struct StyleTheSliders_Previews: PreviewProvider {
    static var previews: some View {
        SliderView(redGuess: .constant(0.5), greenGuess: 
          .constant(0.5), blueGuess: .constant(0.5), 
          selectedPickerIndex: .constant(1))
    }
}</pre>
<p>With the previews operational again, let’s continue by making a separate struct for the creation of the slider itself. Add <code>CreateSlider</code> outside and underneath the <code>SliderView</code> struct:</p>
<pre class="source-code">
struct CreateSlider: View {
    @Binding var value: Double
    var color: Color
    var body: some View {
        HStack {
            Text("0")
                .bold()
                .foregroundColor(color)
            
            Slider(value: $value, in: 0.0...1.0)
            Text("255")
                .bold()
                .foregroundColor(color)
        }.padding(.init(top: 10, leading: 10, bottom: 10, 
          trailing: 10))
    }
}</pre>
<p>This code defines<a id="_idIndexMarker808"/> a new SwiftUI struct called <code>CreateSlider</code> that takes in two parameters: a <code>Binding</code> variable called <code>value</code> of the <code>Double</code> type, and a variable called <code>color</code> of the <code>Color</code> type.</p>
<p>Here is what each line of code does.</p>
<p>As we’ve seen before, <code>@Binding var value: Double</code> is a property wrapper that creates a two-way binding between the struct’s <code>value</code> variable and another variable. This allows the struct to read and write the value of the variable that it is bound to.</p>
<p><code>var color: Color</code> creates a variable called <code>color</code> that is of the <code>Color</code> type.</p>
<p><code>Text("0")</code> creates a <code>Text</code> view with a value of <code>0</code>, and gets the following modifiers placed on it: <code>.bold()</code> makes the text bold, and <code>foregroundColor(color)</code> sets the color of the text to the <code>color</code> variable passed to the struct.</p>
<p>Then we add the slider, <code>Slider(value: $value, in: 0.0...1.0)</code>. This creates a <code>Slider</code> view that reads and writes its value to the <code>value</code> property. The <code>in</code> parameter sets the range of the slider to go from <code>0.0</code> to <code>1.0</code>.</p>
<p>Then, we add another <code>Text</code> view, add the text <code>255</code>, and put some padding on it using <code>.padding(.init(top: 10, leading: 10, bottom: 10, trailing: 10))</code>. This is a <code>View</code> modifier that adds a padding of <code>10</code> points to the top, leading, bottom, and trailing edge of the view.</p>
<p>With the slider created, we will need<a id="_idIndexMarker809"/> to call this <code>CreateSlider</code> struct several times inside the <code>SliderView</code> struct and add some styling to it as well. So, back up into the <code>SliderView</code> struct, add the following code:</p>
<pre class="source-code">
var body: some View {
    //MARK: - SLIDERS FOR THE GUESS CIRCLE
    VStack {
        //red slider - this slider will always be visible
          and represents the "Easy" option on the picker
        CreateSlider(value: $redGuess, color: .red)
            .background(Capsule().stroke(Color.red,
              lineWidth: 3))
            .padding(.horizontal)
            .accentColor(.red)
            .padding(5)
        
        switch selectedPickerIndex {
        case 1:
            //green slider - shown when the "Hard" option 
              is selected
            CreateSlider(value: $greenGuess, color: .green)
                .background(Capsule().stroke(Color.green,
                  lineWidth: 4))
                .padding(.horizontal)
                .accentColor(.green)
                .padding(5)
        case 2:
          //blue slider - this is shown when the 
            "Extreme" option is selected
              CreateSlider(value: $greenGuess, color:
                .green)
                  .background(Capsule().stroke(Color.green,
                    lineWidth: 4))
                  .padding(.horizontal)
                  .accentColor(.green)
                  .padding(5)
              
              CreateSlider(value: $blueGuess, color: .blue)
                  .background(Capsule().stroke(Color.blue,
                    lineWidth: 4))
                  .padding(.horizontal)
                  .accentColor(.blue)
                  .padding(5)
          default:
              EmptyView()
          }
      }
  }</pre>
<p>Let’s break this code down. It starts off by defining a SwiftUI view called <code>SliderView</code> that uses a <code>VStack</code> to lay out three sliders for adjusting the values of the <code>redGuess</code>, <code>greenGuess</code>, and <code>blueGuess</code> properties. The struct has a <code>VStack</code> used to organize three sliders vertically. </p>
<p>Those three sliders<a id="_idIndexMarker810"/> are added by calls to the <code>CreateSlider</code> view. The <code>CreateSlider</code> view uses the <code>background</code> modifier and a capsule shape in order to outline the slider with a red color.</p>
<p>Next up is a <code>switch</code> statement – since we are using one for the first time, let me explain what it is and the difference between using a <code>switch</code> statement and an <code>if </code><code>else</code> statement.</p>
<p>So, an <code>if else</code> statement is used to evaluate a Boolean expression and execute a block of code if the expression is <code>true</code>, and another block of code if the expression is <code>false</code>. It can be used for any type of condition or comparison. A <code>switch</code> statement, on the other hand, is used to match a value or expression against multiple possible cases and execute a block of code for the matching case. </p>
<p>A <code>switch</code> statement is typically used for matching against multiple possible values for a single variable or expression and is often used for situations where multiple conditions need to be checked in a more concise and readable way. For example, when you have multiple conditions with multiple <code>if else</code> statements, you can use a <code>switch</code> statement over <code>if else</code>. It makes the code more readable and easier to maintain.</p>
<p class="callout-heading">Note</p>
<p class="callout">In general, <code>if else</code> statements are good for complex conditions, while <code>switch</code> statements are good for simple conditions. In Swift, you can use either, depending on what you are trying to accomplish.</p>
<p>So, going back to our code, the <code>switch</code> statement checks the <code>selectedPickerIndex</code> value to see whether it is equal to <code>1</code>; if so, it means the user selected the <code>selectedPickerIndex</code> value is equal to <code>2</code>, it will create both the green and blue sliders, because the user has selected the <code>selectedPickerIndex</code> is not <code>1</code> or <code>2</code>, it will return an empty view.</p>
<p>Next, the <code>CreateSlider</code> struct is used to create the sliders, and it takes two arguments, <code>value</code> and <code>color</code>. It displays the minimum and maximum values of the slider and it uses the <code>color</code> argument to change the color of the <code>"0"</code> text view and the <code>"255"</code> text view. </p>
<p><code>SliderView</code> uses the <code>CreateSlider</code> struct to create the sliders<a id="_idIndexMarker811"/> for RGB colors. The <code>selectedPickerIndex</code> binding is used to decide which sliders to show, based on the user’s selection.</p>
<p><code>SliderView</code> is now complete, so let’s use it inside <code>ContentView</code>. Add the following code just after the <code>Picker</code> code:</p>
<pre class="source-code">
 //MARK: - SLIDER
    Spacer()
    SliderView(redGuess: $redGuess, greenGuess: 
      $greenGuess, blueGuess: $blueGuess, 
      selectedPickerIndex: $selectedPickerIndex)
        .scaleEffect(1)
        .animation(.interactiveSpring(response: 0.4, 
          dampingFraction: 0.5, blendDuration: 0.5), value: 
          selectedPickerIndex)
     Spacer()</pre>
<p>This code calls the <code>SliderView</code> struct and fills in the <code>Binding</code> variables, then adds a spring animation to the sliders as they appear and disappear in the UI. The <code>interactiveSpring</code> animation is a type of animation that simulates the behavior of a spring, and takes three parameters:</p>
<ul>
<li><code>response</code>: This value controls the stiffness of the spring. A lower value will result in a softer spring, and a higher value will result in a stiffer spring. A value of <code>0.4</code> will provide a moderate stiffness.</li>
<li><code>dampingFraction</code>: This value controls the damping of the spring, which is a measure of how quickly the spring’s oscillations will die out. A lower value will result in a spring with less damping, and a higher value will result in a spring with more damping. A value of <code>0.5</code> means that the spring’s oscillations will die out relatively quickly.</li>
<li><code>blendDuration</code>: This value controls the duration of the animation’s blending. A lower value will result in a shorter blend duration, and a higher value will result in a longer blend duration. A value of <code>0.5</code> seconds is a moderate blend duration.</li>
</ul>
<p>As well as the <code>interactiveSpring</code> animation, we’re using the <code>scaleEffect</code> modifier and passing<a id="_idIndexMarker812"/> in a value of <code>1</code>. What this does is help smooth out the animation as each slider appears and disappears. Go ahead and try it out. If you click on the picker control to choose a difficulty level, each slider will appear and disappear on the screen with a springy animation to it:</p>
<div><div><img alt="Figure 14.7: The sliders " src="img/B18674_14_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7: The sliders</p>
<p>As you move the sliders, the guess circle color will update smoothly, and the RGB values will change in the RGB<a id="_idIndexMarker813"/> text string.</p>
<p>The last UI component to add is a button that will let the user check their score as they play. </p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor213"/>Keeping track of the user’s score with a button </h1>
<p>To make this a game, the user<a id="_idIndexMarker814"/> needs a way to check their progress<a id="_idIndexMarker815"/> and see a number that reflects how close they are to a perfect score/color match.</p>
<p>Let’s add a button right after the <code>SliderView</code> struct’s <code>Spacer()</code> in <code>ContentView</code>:</p>
<pre class="source-code">
 //MARK: - BUTTON
    Button(action: {
         
    }) {
        Text("Check Score")
            .foregroundColor(.black)
            .padding(EdgeInsets(top: 12, leading: 20, 
              bottom: 12, trailing: 20))
            .background(Color.yellow)
            .cornerRadius(20)
            .shadow(color: Color.black, radius: 2, y: 4)
    }</pre>
<p>This code creates a <code>Button</code> view, which we have named <code>Check Score</code>. The button gets styled with a black foreground, yellow background, padding, a corner radius, and finally, a black shadow to make the button stand out a bit.</p>
<p>The body of the button is currently empty right now, but what we want to do is to put some code in there that will trigger an alert and show the user their current score, so that they know how close they are to the target value.</p>
<p>To do this, we need to create a function that calculates a score. So, at the bottom of the <code>ContentView</code> struct, add this code:</p>
<pre class="source-code">
func calculateScore() -&gt; Int {
        let redDiff = redGuess - redTarget
        let greenDiff = greenGuess - greenTarget
        let blueDiff = blueGuess - blueTarget
        let easyDifference = redDiff * redDiff
        let hardDifference = easyDifference + greenDiff * 
          greenDiff
        let extremeDifference = hardDifference + blueDiff * 
          blueDiff
        let calculatedDifference: Double
        switch selectedPickerIndex {
            case 0:
                calculatedDifference = sqrt(easyDifference)
            case 1:
                calculatedDifference = sqrt(hardDifference)
            case 2:
                calculatedDifference = 
                  sqrt(extremeDifference)
            default:
                calculatedDifference = 0.0
        }
        return Int((1.0 - calculatedDifference) * 100 + 
          0.5)
    } </pre>
<p>This code defines<a id="_idIndexMarker816"/> a function named <code>calculateScore</code> that returns<a id="_idIndexMarker817"/> an <code>Int</code> value. This function is used to calculate a score based on the difference between the <code>guess</code> values of <code>red</code>, <code>green</code>, and <code>blue</code>, and the <code>target</code> values of <code>red</code>, <code>green</code>, and <code>blue</code>.</p>
<p>Here’s how it works. The function first calculates the difference between the <code>guess</code> values and the <code>target</code> values for <code>red</code>, <code>green</code>, and <code>blue</code>. Next, it calculates <code>easyDifference</code> by getting the square root of the <code>redDiff</code> variable. Next, it calculates <code>hardDifference</code> by adding the square of the <code>greenDiff</code> variable to <code>easyDifference</code>. Then, it calculates <code>extremeDifference</code> by adding the square root of <code>blueDiff</code> to <code>hardDifference</code>.</p>
<p>After that, it uses a <code>switch</code> statement to determine which level of difficulty is currently selected, and assigns the <code>calculatedDifference</code> variable a value based on that:</p>
<ul>
<li>If <code>selectedPickerIndex</code> is <code>0</code>, then <code>calculatedDifference</code> is the square root of <code>easyDifference</code></li>
<li>If <code>selectedPickerIndex</code> is <code>1</code>, then <code>calculatedDifference</code> is the square root of <code>hardDifference</code></li>
<li>If <code>selectedPickerIndex</code> is <code>2</code>, then <code>calculatedDifference</code> is the square root of <code>extremeDifference</code></li>
<li>If <code>selectedPickerIndex</code> is any other value, then <code>calculatedDifference</code> is set to <code>0.0</code></li>
</ul>
<p>Finally, it returns an <code>integer</code> value that is calculated by taking <code>(1.0 - calculatedDifference) * 100 + 0.5</code>, which is the final score.</p>
<p>This function is used to calculate a score based on how close the <code>guess</code> values are to the <code>target</code> values. The smaller<a id="_idIndexMarker818"/> the difference between<a id="_idIndexMarker819"/> the values, the higher the score will be. If the <code>guess</code> value is equal to the <code>target</code> value, the user gets a perfect score of 100.</p>
<p>Now, the <code>calculateScore</code> function is complete; let’s use it to show the user their score in an <code>Alert</code> view.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor214"/>Showing the user’s score in an Alert view</h1>
<p>To create an <code>Alert</code> view, we<a id="_idIndexMarker820"/> first need a state variable to keep track<a id="_idIndexMarker821"/> of the alert and trigger it when the <code>state</code> value changes. At the top of the file, underneath the other variables we created, add the following <code>State</code> variable:</p>
<pre class="source-code">
//user feedback variable
    @State var showAlert = false</pre>
<p>Then, we need to add the <code>Alert</code> modifier after the <code>Button</code> code’s closing brace:</p>
<pre class="source-code">
.alert(isPresented: $showAlert) { () -&gt; Alert in
        Alert(title: Text("Your Score"), message:           Text("\(calculateScore())"),
              primaryButton: Alert.Button.default(Text("New
                Game?"), action: {
            // Start a new game?
        }),
              secondaryButton: 
                Alert.Button.destructive(Text("Continue 
                  Playing"), action: {
            // Continue with the present game
           
        }))
    }</pre>
<p>The code creates a title, a message, and two buttons – a primary button and a secondary button. </p>
<p>The title will be the message to the user, and the message will be the user’s score. We’re doing that by calling the <code>calculatedScore</code> function inside a <code>Text</code> view using string interpolation; remember, the <code>calculateScore</code> function returns an integer, and that value will be shown to the user as their current score. </p>
<p>Then, the primary button<a id="_idIndexMarker822"/> will prompt<a id="_idIndexMarker823"/> the user to start a new game, while the secondary button will prompt the user to continue playing.</p>
<p>To trigger the alert, we need to toggle the <code>showAlert</code> variable to <code>true</code> inside the <code>Button</code> body, like this:</p>
<pre class="source-code">
    Button(action: {
                <strong class="bold">showAlert = true</strong>
            }) {</pre>
<p>Now, we can try the game out. Slide the sliders and try to get as close to the target circle color as you can, then press the <strong class="bold">Check Score</strong> button to see your score:</p>
<div><div><img alt=" Figure 14.8: Alert view showing the user’s score " src="img/B18674_14_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 14.8: Alert view showing the user’s score</p>
<p>From this screen, if the user<a id="_idIndexMarker824"/> presses <strong class="bold">Continue Playing?</strong>, the game will continue<a id="_idIndexMarker825"/> from where it left off. However, if they press <strong class="bold">New Game?</strong>, nothing will happen – that’s because we haven’t added any logic to start a new game yet. Let’s do that next. </p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor215"/>Resetting the game</h1>
<p>We want to give the user the opportunity<a id="_idIndexMarker826"/> to start a new game, and we can do that by adding a <code>reset</code> function to the file. This function will reset the sliders to <strong class="bold">0</strong> and generate another random target color for the middle target circle.</p>
<p>Add the following function underneath the <code>calculateScore</code> function:</p>
<pre class="source-code">
 //MARK: - RESET THE GAME
    func reset() {
        redTarget = Double.random(in: 0..&lt;1)
        greenTarget = Double.random(in: 0..&lt;1)
        blueTarget = Double.random(in: 0..&lt;1)
        redGuess = 0.0
        greenGuess = 0.0
        blueGuess = 0.0
    }</pre>
<p>This function creates new random colors and stores them in the <code>Target</code> variables. It also resets the <code>Guess</code> variables back to <code>0</code>, which will move all the sliders back to their starting points on the left.</p>
<p>Let’s call the <code>reset</code> function inside the <code>Alert</code> modifier’s secondary button, like this:</p>
<pre class="source-code">
.alert(isPresented: $showAlert) { () -&gt; Alert in
  Alert(title: Text("Your Score"), message:
    Text("\(calculateScore())"),
        primaryButton: Alert.Button.default(Text("Continue
          Playing?"), action: {
                }),
        secondaryButton: Alert.Button.destructive(Text("New 
          Game?"), action: {
      // Start a new game?
<strong class="bold">      reset()</strong>
  }))</pre>
<p>Now, when we press the secondary<a id="_idIndexMarker827"/> button, <strong class="bold">New Game?</strong>, a new game starts with a new target color, and the sliders are set back to their starting position:</p>
<div><div><img alt="Figure 14.9: Starting a new game " src="img/B18674_14_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9: Starting a new game</p>
<p>The sliders are set back to zero, and a new<a id="_idIndexMarker828"/> random target color is generated and shown.</p>
<p>Let’s finish this project by adding two more things – a background, and a confetti animation that will appear when the user gets a perfect score of 100.</p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor216"/>Adding a background</h1>
<p>First, the background. You can<a id="_idIndexMarker829"/> find the resource for this project in the <code>Chapter 14</code> folder on GitHub (it’s the only asset in the folder); just drag and drop the <code>background</code> image file into the Asset Catalog. After you’ve done that, add the following code in <code>ContentView</code>, after the closing brace of the main <code>VStack</code>, like this:</p>
<pre class="source-code">
.background(Image("background").resizable().edgesIgnoringSa
  feArea(.all))</pre>
<p>Here, we are using the <code>background</code> modifier, passing the name of the image, resizing it, and setting <code>edgesIgnoringSafeArea</code> to stretch it out throughout the whole screen. It’s a subtle background, but it has a nice pattern to it that I think works as a backdrop for the colorful UI:</p>
<div><div><img alt="Figure 14.10: Background added " src="img/B18674_14_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10: Background added</p>
<p>Now, let’s look at Swift packages, and how to make some confetti.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor217"/>Adding confetti using Swift packages</h1>
<p>A Swift package<a id="_idIndexMarker830"/> is pre-built software<a id="_idIndexMarker831"/> that we can use in any of our projects, in which all the coding work has been done for us; all we have to do is configure it in our project.</p>
<p>To add a Swift package, in Xcode, go to the <strong class="bold">File</strong> menu and select <strong class="bold">Add Packages…</strong>:</p>
<div><div><img alt="Figure 14.11: Add Packages… " src="img/B18674_14_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11: Add Packages…</p>
<p>In<a id="_idIndexMarker832"/> the <strong class="bold">All Sources</strong> window, enter <a href="https://github.com/simibac/ConfettiSwiftUI.git">https://github.com/simibac/ConfettiSwiftUI.git</a> in the search<a id="_idIndexMarker833"/> box:</p>
<div><div><img alt="Figure 14.12: Adding the URL " src="img/B18674_14_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12: Adding the URL</p>
<p>When the <strong class="bold">Add Package</strong> button is clicked, Xcode<a id="_idIndexMarker834"/> will add the Confetti package<a id="_idIndexMarker835"/> to the project. The Confetti package contains all the code needed to create all kinds of confetti, dispersed in different ways.</p>
<p>Now, we need to import the Confetti framework into the <code>ContentView</code> file at the top:</p>
<pre class="source-code">
import ConfettiSwiftUI</pre>
<p>Next, we need a variable that can trigger the confetti (placed after the other project variables):</p>
<pre class="source-code">
//confetti variable
    @State var counter = 0</pre>
<p>Now, we can call the <code>confettiCannon</code> initializer in <code>ContentView</code> just after the target and guess rectangle code, like this:</p>
<pre class="source-code">
//MARK: - CONFETTI CANNON
    .confettiCannon(counter: $counter, num: 100, colors: 
      [.pink, .red, .blue, .purple, .orange], rainHeight: 
      1800.0, radius: 500.0)</pre>
<p>This code calls<a id="_idIndexMarker836"/> the <code>confettiCannon</code> initializer, using the <code>counter</code> variable to trigger the animation. The number of pieces<a id="_idIndexMarker837"/> of confetti being created will be 100, and the <code>colors</code> array lets you add the colors that you want the confetti to be. <code>rainHeight</code> will set how high the confetti goes upward, and the radius will set how wide the confetti spreads.</p>
<p class="callout-heading">Note</p>
<p class="callout">I filled out the variables for our example; however, you can play around with these values and configure them the way you like. There are many parameters that the creator, Simon Bachmann, has built into the <code>confettiCannon</code> initializer, so it’s very customizable. For a full list, follow this link: <a href="https://github.com/simibac/ConfettiSwiftUI#parameters">https://github.com/simibac/ConfettiSwiftUI#parameters</a>.</p>
<p>Finally, we want to trigger the confetti in the <code>Button</code> body only when the user scores a perfect 100. So, add the following code into the <code>Button</code> body, right after the <code>showAlert</code> variable is set to <code>true</code>, and then we can test out the animation:</p>
<pre class="source-code">
 Button(action: {
        showAlert = true
        //if a score of 100 is achieved, make the confetti 
          fall by adding 1 to the counter variable
        <strong class="bold">if calculateScore() == 100 {</strong>
<strong class="bold">               counter += 1</strong>
<strong class="bold">                     }</strong></pre>
<p>This is just a simple <code>if</code> statement that checks whether the <code>calculateScore</code> function returns <code>100</code>. If so, we add <code>1</code> to the <code>counter</code> variable, which will trigger the animation. </p>
<p>And if you’re wondering how adding a value of <code>1</code> triggers the confetti cannon, well, that’s how the Confetti package is configured –when a value of <code>1</code> is added to its <code>counter</code> variable, it triggers the confetti.</p>
<p>Okay, now when the user gets<a id="_idIndexMarker838"/> a score of 100, the confetti cannon will shoot<a id="_idIndexMarker839"/> the confetti from the middle of the screen upward, and the confetti will slowly rain down the entire interface, all the way past the bottom of the screen:</p>
<div><div><img alt="Figure 14.13: Confetti animation " src="img/B18674_14_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13: Confetti animation</p>
<p>And that’s the color-matching game finished.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor218"/>Summary</h1>
<p>In this project, we learned about RGB colors, <code>switch</code> statements, implementing a <code>Picker</code> view, adding a <code>Slider</code> view, and creating a <code>reset</code> function, as well as using Swift packages to import pre-built code into our project.</p>
<p>Play around with the code, and think of ways that you can take the game further. For example, maybe you want to play a sound effect when a perfect score is reached, such as a “pop” sound, or maybe you want to display the score on a label in the UI rather than having to click a button to check it. There are many different things that you can do to add more fun to the project.</p>
<p>The next chapter will look at some advanced animations we can create by integrating the SpriteKit framework into our SwiftUI projects. SpriteKit gives us a particle system that creates all kinds of very realistic effects and animations that you can use in your projects.</p>
</div>
<div><div></div>
</div>
</body></html>