<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Views, Widgets, and Styles</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Inserting a widget into a layout</li>
<li>Using graphics to show the button state</li>
<li>Creating a widget at runtime</li>
<li>Creating a custom component</li>
<li>Applying a style to a View</li>
<li>Turning a style into a theme</li>
<li>Selecting a theme based on the Android OS version</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>The term <strong>widgets</strong> can refer to several different concepts in Android. When most people talk about widgets, they are referring to <strong>app widgets</strong>, which are typically seen on the home screen. App widgets are like mini applications by themselves as they usually provide a subset of functionality, based on their main application. (Usually, most app widgets are installed along with an application, but that is not a requirement. They can be standalone apps in a widget format.) A common app widget example is a weather application that offers several different app widgets for the home screen. <a href="1521f6e9-278d-413a-9d00-374d369b6acb.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Beyond Your App - Home Screen Widgets, Search, and the System UI</em>, will discuss home screen app widgets and provide recipes to create your own.</p>
<p>When developing for Android, the term widgets generally refers to specialized Views placed in the layout files, such as a <span class="packt_screen">Button</span>, <span class="packt_screen">TextView</span>, <span class="packt_screen">CheckBox</span>, and so on. This chapter will focus on widgets for screen layouts.</p>
<p>To see the list of widgets provided in the <strong>Android SDK</strong>, open a layout file in Android Studio, and click on the <span class="packt_screen">Design</span> tab. Along the left-hand side of the <span class="packt_screen">Design</span> view, you will see the list of items that can be placed on the layout: <span class="packt_screen">Common</span>, <span class="packt_screen">Text</span>, <span class="packt_screen">Buttons</span>, <span class="packt_screen">Widgets</span>, <span class="packt_screen">Layouts</span>, <span class="packt_screen">Containers</span>, <span class="packt_screen">Google</span>, and <span class="packt_screen">Legacy</span>. Even though many of the items are not in the <span class="packt_screen">Widget</span> category, by definition, they are still widgets. As you can see in the following screenshot, the <span class="packt_screen">Widgets</span> category groups the more complicated controls:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/33485eb8-95a3-42d6-9f5d-dba55d072fe5.png" style="width:42.50em;height:29.33em;"/></div>
<p>As you can see from the list, the Android SDK provides many useful widgets—from a simple <span class="packt_screen">TextView</span>, <span class="packt_screen">Button</span>, or <span class="packt_screen">Checkbox</span>, to the much more complex widgets such as the <span class="packt_screen">WebView</span>, <span class="packt_screen">ProgressBar</span>, and <span class="packt_screen">SearchView</span>. As useful as the built-in widgets are, it's also very easy to expand on what's provided in the SDK. We can extend an existing widget to customize its functionality, or we can create our own widget from scratch by extending the base View class. (We will provide an example of this in the <em>Creating a custom component</em> recipe later.)</p>
<p>The visual look of widgets can also be customized. These settings can be used to create <strong>styles</strong>, which in turn can be used to create <strong>themes</strong>. Just like with other development environments, creating a theme offers the benefit of easily changing the appearance throughout our entire application with minimal effort. Lastly, the Android SDK also provides many built-in themes and variations, such as the Material theme introduced in Android 5 and later the Material Design 2.0.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inserting a widget into a layout</h1>
                </header>
            
            <article>
                
<p>As you may have seen from previous recipes, <strong>widgets</strong> are declared in a layout file, or created in code. For this recipe, we will go step by step to add a button with the Android Studio Designer. (For later recipes, we will just show the layout XML.) After creating the button, we will create a method to receive the button click events using <kbd>onClickListener()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Start a new project in Android Studio and call it <kbd>InsertWidget</kbd>. Use the default options for creating a <span class="packt_screen">Phone and Tablet</span> project and select <span class="packt_screen">Empty Activity</span> when prompted for the <span class="packt_screen">Activity Type</span>. You can delete the default <kbd>TextView</kbd> (or leave it) as it will not be needed for this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To insert a widget into a layout, follow these steps:</p>
<ol>
<li>Open the <kbd>activity_main.xml</kbd> file in Android Studio and click on the <span class="packt_screen">Design</span> tab. As you can see, by default, Android Studio adds a <kbd>TextView</kbd> to the layout. Select the <kbd>TextView</kbd> and delete it:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73e5ebe5-038d-4277-9f6c-19aab5efc25a.png"/></div>
<ol start="2">
<li>Find <span class="packt_screen">Button</span> in the widget list and drag it to the center of the activity screen on the right:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/da220ca8-1259-4491-9945-b7d54804b6cf.png"/></div>
<ol start="3">
<li class="CDPAlignLeft CDPAlign">Though we placed the button in the center of the screen, the button will not actually be centered when you run the app. If we want it centered, we need to set the layout properties accordingly. (Currently, the button is just centered in the design tool to make it easier to work with but this has no affect when the app is running.) To center the button, start by selecting the button in the design view. When it is selected, you will see the edge nodes. Drag each edge node to the corresponding edge of the screen as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3f0babc7-7a16-48de-a5a7-f758e24112ce.png"/></p>
<ol start="4">
<li class="CDPAlignLeft CDPAlign">To view the <kbd>xml</kbd> created, click on the <span class="packt_screen">Text</span> tab as shown in the following screenshot. See how the button is centered using the <kbd>ConstraintLayout</kbd> parameters. Also, take note of the default ID as we will need it for the next step:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb81e949-1a40-4441-8416-75bbbf5b9989.png"/></p>
<ol start="5">
<li>Now, open the <kbd>MainActivity.java</kbd> file to edit the code. Add the following code to the <kbd>onCreate()</kbd> method to set up <kbd>onClickListener()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">Button button = (Button)findViewById(R.id.button); 
button.setOnClickListener(new View.OnClickListener() { 
    @Override 
    public void onClick(View view) { 
        Toast.makeText(MainActivity.this,"Clicked",<br/>             Toast.LENGTH_SHORT).show(); 
    } 
}); </pre>
<ol start="6">
<li>Run the application on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Creating the UI with the Android Studio is as simple as dragging and dropping Views. You can also edit the properties of the Views directly in the <span class="packt_screen">Design</span> tab. Switching to the XML code is as simple as hitting the <span class="packt_screen">Text</span> tab.</p>
<p>What we did here is very common in Android development – creating the UI in XML, then hooking up the UI components (Views) in the Java code. To reference a View from code, it must have a resource identifier associated with it. This is done using the <kbd>id</kbd> parameter:</p>
<pre>android:id="@+id/button" </pre>
<p>Our <kbd>onClickListener</kbd> function displays a pop-up message on the screen called <strong>Toast</strong>, when the button is pressed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Take a look again at the format of the identifier we created previously, <kbd>@+id/button</kbd>. The <kbd>@</kbd> sign specifies this is going to be a resource and the <kbd>+</kbd> sign indicates a new resource. (If we failed to include the plus sign, we would get a compile-time error stating <span class="packt_screen">No resource matched the indicated name</span>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Butter Knife – Field and method binding for Android views</em> (open source project): <a href="http://jakewharton.github.io/butterknife/"><span class="URLPACKT">http://jakewharton.github.io/butterknife/</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using graphics to show button state</h1>
                </header>
            
            <article>
                
<p>We've talked about the versatility of Android Views and how behavior and visual appearance can be customized. In this recipe, we will create a drawable <strong>state selector</strong>, which is a resource defined in XML that specifies the drawable to use based on the View's state.<br/>
The most commonly used states, along with the possible values, include the following:</p>
<ul>
<li><kbd>state_pressed=["true" | "false"]</kbd></li>
<li><kbd>state_focused=["true" | "false"]</kbd></li>
<li><kbd>state_selected=["true" | "false"]</kbd></li>
<li><kbd>state_checked=["true" | "false"]</kbd></li>
<li><kbd>state_enabled=["true" | "false"]</kbd></li>
</ul>
<p>To define a state selector, create an XML file with the <kbd>&lt;selector&gt;</kbd> element, as shown:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;selector  &gt; 
&lt;/selector&gt; </pre>
<p>Within the <kbd>&lt;selector&gt;</kbd> element, we define an <kbd>&lt;item&gt;</kbd> element to identify the drawable to be used based on the specified state(s). Here's an example <kbd>&lt;item&gt;</kbd> element using multiple states:</p>
<pre> &lt;item 
    android:drawable="@android:color/darker_gray" 
    android:state_checked="true" 
    android:state_selected="false"/&gt; </pre>
<div class="packt_tip">It's important to remember the file is read from top to bottom so the first item that meets the state requirements will be used. A default drawable, one with no states included, would need to go last.</div>
<p>For this recipe, we will use a state selector to change the background color based on the <kbd>ToggleButton</kbd> state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it <kbd>StateSelector</kbd> using the default <span class="packt_screen">Phone &amp; Tablet</span> options. When prompted for the <span class="packt_screen">Activity Type</span>, select <span class="packt_screen">Empty Activity</span>. To make it easier to type the code for this recipe, we will use a color as the graphic to represent the button state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will start by creating the state selector, which is a resource file defined with XML code. We will then set up the button to use our new state selector. Here are the steps:</p>
<ol>
<li>Create a new <span class="packt_screen">Drawable resource file</span> in the <kbd>res/drawable</kbd> folder and call it: <kbd>state_selector.xml</kbd>. The file should contain the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;selector </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"</span><span>&gt;<br/></span><span>    &lt;item<br/></span><span>        </span><span>android</span><span>:drawable=</span><span>"@android:color/darker_gray"<br/></span><span>        </span><span>android</span><span>:state_checked=</span><span>"true"</span><span>/&gt;<br/></span><span>    &lt;item<br/></span><span>        </span><span>android</span><span>:drawable=</span><span>"@android:color/white"<br/></span><span>        </span><span>android</span><span>:state_checked=</span><span>"false"</span><span>/&gt;<br/></span><span>&lt;/selector&gt;</span></pre>
<ol start="2">
<li>Now open the <kbd>activity_main.xml</kbd> file and drop in <kbd>ToggleButton</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;ToggleButton 
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content" 
    android:text="New ToggleButton" 
    android:id="@+id/toggleButton" 
    android:layout_centerVertical="true" 
    android:layout_centerHorizontal="true" 
    android:background="@drawable/state_selector" /&gt; </pre>
<ol start="3">
<li>Run the application on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The main concept to understand here is the Android State Selector. As shown in step 1, we created a resource file to specify a <strong>drawable</strong> (a color in this case) based on <kbd>state_checked</kbd>.</p>
<p>Android supports many other state conditions besides checked. While typing in <kbd>android:state</kbd>, look at the autocomplete drop-down menu to see the list of other options.</p>
<p>Once we have the drawable resource created (the XML from step 1), we just have to tell the view to use it. Since we want the background color to change based on the state, we use the <kbd>android:background</kbd> property. The <kbd>state_selector.xml</kbd> is a drawable resource that can be passed to any property that accepts a drawable. We could, for example, replace the check image of a checkbox with the following XML:</p>
<pre><span>&lt;CheckBox<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/checkBox"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"</span><span><br/></span><span>    </span><span>android</span><span>:button=</span><span>"@drawable/state_selector"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"CheckBox"</span><span> </span><span>/&gt;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>What if we wanted actual images for the graphics instead of just a color change? This is as easy as changing the drawable referenced in the item state. The source code available for download uses two graphics, downloaded from: <a href="https://pixabay.com/"><span class="URLPACKT">https://pixabay.com/</span></a> (this site was chosen because the images are free to use and don't require a login).</p>
<p>Once you have your desired images, place them in the <kbd>res/drawable</kbd> folder. Then, change the state item line in the XML to reference your images. Here's an example:</p>
<pre>&lt;item 
    android:drawable="@drawable/checked_on" 
    android:state_checked="true"/&gt; </pre>
<p>(Change <kbd>check_on</kbd> to match your image resource name)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using designated folders for screen-specific resources</h1>
                </header>
            
            <article>
                
<p>When Android encounters a <kbd>@drawable</kbd> reference, it expects to find the target in one of the <kbd>res/drawable</kbd> folders. These are designed for different screen densities - <kbd>ldpi</kbd> (low dots per inch), <kbd>mdpi</kbd> (medium), <kbd>hdpi</kbd> (high), and <kbd>xhdpi</kbd> (extra-high) - and they allow us to create resources for specific target devices. When an application is running on a specific device, Android will load resources from the designated folder that most closely matches the actual screen density.</p>
<p>If it finds this folder empty, it will try the next nearest match and so on until it finds the named resource. For tutorial purposes, a separate set of files for each possible density is not required, and so placing our images in the <kbd>drawable</kbd> folder is a simple way to run the exercise on any device.</p>
<div class="packt_tip">For a complete list of resource identifiers available, visit <a href="http://developer.android.com/guide/topics/resources/providing-resources.html"><span class="URLPACKT">http://developer.android.com/guide/topics/resources/providing-resources.html</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>For another example of Android resource selection, see the <em>Selecting a theme based on the Android version </em><span>recipe</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a widget at runtime</h1>
                </header>
            
            <article>
                
<p>As mentioned before, generally, the UI is declared in XML files and then modified during runtime through the Java code. It is possible to create the UI completely in Java code, though for a complex layout, it would generally not be considered best practice.</p>
<p>In this recipe, we are going to add a view to the existing layout defined in <kbd>activity_main.xml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it <kbd>RuntimeWidget</kbd>. Select the <span class="packt_screen">Empty Activity</span> option when prompted for the <span class="packt_screen">Activity Type</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will start by adding an ID attribute to the existing layout so we can access the layout in code. Once we have a reference to the layout in code, we can add new views to the existing layout. Here are the steps:</p>
<ol>
<li>Open<kbd>res/layout/activity_main.xml</kbd> and add an ID attribute to the root <kbd>ConstraintLayout</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">android:id="@+id/layout" </pre>
<ol start="2">
<li>Completely remove the default <kbd>&lt;TextView&gt;</kbd> element.</li>
<li>Open the <kbd>MainActivity.java</kbd> file so we can add code to the <kbd>onCreate()</kbd> method. Add the following code (after <kbd>setContentView())</kbd> to get a reference to <kbd>ConstraintLayout</kbd>:</li>
</ol>
<pre style="padding-left: 60px">ConstraintLayout layout = findViewById(R.id.<span>layout</span>)<span>;</span></pre>
<ol start="4">
<li>Create <kbd>DatePicker</kbd> and add it to the layout with the following code:</li>
</ol>
<pre style="padding-left: 60px">DatePicker datePicker = new DatePicker(this); 
layout.addView(datePicker); </pre>
<ol start="5">
<li>Run the program on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This is hopefully very straightforward code. First, we get a reference to the parent layout using <kbd>findViewById</kbd>. We added the ID to the existing <kbd>ConstraintLayout</kbd> (in step 1) to get a reference. We create a <kbd>DatePicker</kbd> in code and add it to the layout with the <kbd>addView()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>What if we wanted to create the entire layout from code? Though it may not be considered best practice, there are times when it is certainly easier (and less complex) to create the entire layout from code. Let's see how this example would look if we didn't use the layout from <kbd>activity_main.xml</kbd>. Here's how <kbd>onCreate()</kbd> would look:</p>
<pre><span>@Override<br/></span><span>protected void </span><span>onCreate</span>(Bundle savedInstanceState) {<br/>    <span>super</span>.onCreate(savedInstanceState)<span>;<br/></span><span>    </span>ConstraintLayout layout = <span>new </span>ConstraintLayout(<span>this</span>)<span>;<br/></span><span>    </span>DatePicker datePicker = <span>new </span>DatePicker(<span>this</span>)<span>;<br/></span><span>    </span>layout.addView(datePicker)<span>;<br/></span><span>    </span>setContentView(layout)<span>;<br/></span>}</pre>
<p>In this example, it's really not that different. If you create a view in code and want to reference it later, you either need to keep a reference to the object, or assign the view an ID to use <kbd>findViewByID()</kbd>. To give a view an ID, use the <kbd>setID()</kbd> method by passing in <kbd>View.generateViewId()</kbd> (to generate a unique ID) or define the ID using <kbd>&lt;resources&gt;</kbd> in XML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom component</h1>
                </header>
            
            <article>
                
<p>As we have seen in previous recipes, the Android SDK provides a wide range of components. But what happens when you can't find a prebuilt component that fits your unique needs? You can always create your own!</p>
<p>In this recipe, we will walk through creating a custom component that derives from the <kbd>View</kbd> class, just like the built-in widgets. Here's a high-level overview:</p>
<ol>
<li>Create a new class that extends View.</li>
<li>Create custom constructor(s).</li>
<li>Override <kbd>onMeasure()</kbd>, as the default implementation returns a size of 100 x 100.</li>
<li>Override <kbd>onDraw()</kbd>, as the default implementation draws nothing.</li>
<li>Define custom methods and listeners (such as the <kbd>onClick()</kbd> event).</li>
<li>Implement custom functionality.</li>
</ol>
<div class="packt_tip">Overriding <kbd>onMeasure()</kbd> and <kbd>onDraw()</kbd> is not strictly required, but the default behavior is likely not what you would want.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Start a new project in Android Studio and call it <kbd>CustomView</kbd>. Use the default wizard options, including the <span class="packt_screen">Phone &amp; Tablet SDK</span> and select <span class="packt_screen">Empty Activity</span> when prompted for the <span class="packt_screen">Activity Type</span>. Once the project files are created and open in Android Studio, you are ready to begin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will create a new class for our custom component to derive from the Android <kbd>View</kbd> class. Our custom component could be a subclass of an existing class, such as the activity, but we will create it in a separate file to make it easier to maintain. Here are the steps:</p>
<ol>
<li>Start by creating a new Java class and calling it <kbd>CustomView</kbd>. This is where we will implement our custom component, as described in the <em>Introduction</em>.</li>
<li>Change the class constructor so it extends View. It should look as follows:</li>
</ol>
<pre style="padding-left: 60px">public class CustomView extends View {</pre>
<ol start="3">
<li>Define a <kbd>Paint</kbd> object for the class, which will be used in <kbd>onDraw()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">final Paint mPaint = new Paint();</pre>
<ol start="4">
<li>Create a default constructor, which requires the activity <kbd>Context</kbd>, so we can inflate the view. We will set the paint properties here as well. The constructor should look as follows:</li>
</ol>
<pre style="padding-left: 60px">public CustomView(Context context) { 
    super(context); 
    mPaint.setColor(Color.BLACK); 
    mPaint.setTextSize(30); 
} </pre>
<ol start="5">
<li>Override the <kbd>onDraw()</kbd> method as follows:</li>
</ol>
<pre style="padding-left: 60px">@Override 
protected void onDraw(Canvas canvas) { 
    super.onDraw(canvas); 
    setBackgroundColor(Color.CYAN); 
    canvas.drawText("Custom Text", 100, 100, mPaint); 
    invalidate(); 
} </pre>
<ol start="6">
<li>Finally, inflate our custom view in <kbd>MainActivity.java</kbd> by replacing <kbd>setContentView()</kbd> in the <kbd>onCreate()</kbd> method with our view, as shown:</li>
</ol>
<pre style="padding-left: 60px">setContentView(new CustomView(this)); </pre>
<ol start="7">
<li>Run the application on a device or emulator to see it in action.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We start by extending the <kbd>View</kbd> class, just as the built-in components do. Next, we create the default constructor. This is important as we need the context to pass down to the <kbd>super</kbd> class, which we do with the following call:</p>
<pre>super(context);</pre>
<p>We need to override <kbd>onDraw()</kbd>, otherwise, as mentioned in the <em>Introduction</em>, our custom view won't display anything. When <kbd>onDraw()</kbd> is called, the system passes in a <strong>Canvas</strong> object. The canvas is the screen area of our view. (Since we didn't override <kbd>onMeasure()</kbd>, our view would be 100 x 100, but since our entire activity consists of just this view, we get the whole screen as our canvas.)</p>
<p>We created the <kbd>Paint</kbd> object at the class level, and as <kbd>final</kbd>, to be more efficient with memory allocation. (<kbd>onDraw()</kbd> should be as efficient as possible since it can be called multiple times per second.) As you see from running the program, our <kbd>onDraw()</kbd> implementation just sets the background color to cyan and prints text to the screen (using <kbd>drawText()</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Actually, there's a lot more. We've just touched the surface of what you can do with a custom component. Fortunately, as you see from this example, it doesn't take a lot of code to get basic functionality. We could easily spend an entire chapter on topics such as passing layout parameters to the view, adding listener callbacks, overriding <kbd>onMeasure()</kbd>, using our view in the IDE, and so on. These are all features you can add as your needs dictate.</p>
<p>While a custom component is always an option, there are other options that might require less coding. Extending an existing widget is often enough without the overhead of creating a custom component from scratch. If what you need is a solution with multiple widgets, there's also the <strong>compound control</strong>. A compound control, such as a combo box, is just two or more controls grouped together as a single widget.</p>
<p>A compound control would generally extend from a layout, not a View, since you will be adding multiple widgets. You probably wouldn't need to override <kbd>onDraw()</kbd> and <kbd>onMeasure()</kbd>, as each widget would handle the drawing in their respective methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>For more information on drawing, look at <a href="a9bb5495-da76-415c-b83e-c75d0b8ce4fd.xhtml">Chapter 10</a>, <em>Graphics and Animation</em>.</li>
<li>For full details on the <kbd>View</kbd> object, refer to the Android Developer resource at <a href="http://developer.android.com/reference/android/view/View.html"><span class="URLPACKT">http://developer.android.com/reference/android/view/View.html</span></a><span class="URLPACKT">.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying a style to a View</h1>
                </header>
            
            <article>
                
<p>A <strong>style</strong> is a collection of property settings to define the look of a View. As you have already seen while defining layouts, a view offers many settings to determine how it looks, as well as functions. We have already set a view height, width, background color, and padding, plus there are many more settings such as text color, font, text size, margin, and so on. Creating a style is as simple as pulling these settings from the layout and putting them in a style resource.</p>
<p>In this recipe, we will go through the steps of creating a style and hooking it up to a view.</p>
<p>Similar to Cascading Style Sheets, Android Styles allow you to specify your design settings separate from the UI code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new Android Studio project and call it <kbd>Styles</kbd>. Use the default wizard options to create a <span class="packt_screen">Phone &amp; Tablet</span> project and select <span class="packt_screen">Empty Activity</span> when prompted for the <kbd>Activity type</kbd>. We haven't looked at it before, but by default, the wizard also creates a <kbd>styles.xml</kbd> file, which we will use for this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will create our own style resource to change the appearance of <kbd>TextView</kbd>. We can add our new style to the <kbd>styles.xml</kbd> resource created by Android Studio using the following steps:</p>
<ol>
<li>Open the default <kbd>styles.xml</kbd> file located in <kbd>res/values</kbd>, as shown here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/35a07f43-6fcc-4395-8f50-9e704ba94725.png" style="width:26.25em;height:21.42em;"/></div>
<ol start="2">
<li>We will create a new style called <kbd>MyStyle</kbd> by adding the following XML below the existing <kbd>AppTheme</kbd> style:</li>
</ol>
<pre style="padding-left: 60px">&lt;style name="MyStyle"&gt; 
    &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; 
    &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; 
    &lt;item name="android:background"&gt;#000000&lt;/item&gt; 
    &lt;item name="android:textColor"&gt;#AF0000&lt;/item&gt; 
    &lt;item name="android:textSize"&gt;20sp&lt;/item&gt; 
    &lt;item name="android:padding"&gt;8dp&lt;/item&gt; 
    &lt;item name="android:gravity"&gt;center&lt;/item&gt; 
&lt;/style&gt; </pre>
<ol start="3">
<li>Now tell the view to use this style. Open the <kbd>activity_main.xml</kbd> file and add the following attribute to the existing <kbd>&lt;TextView&gt;</kbd> element:</li>
</ol>
<pre style="padding-left: 60px">style="@style/MyStyle" </pre>
<p style="padding-left: 60px">4. Either run the application or view the results in the <span class="packt_screen">Design</span> tab.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A style is a resource, defined by using the <kbd>&lt;style&gt;</kbd> element in a <kbd>&lt;resources&gt;</kbd> element of an XML file. We used the existing <kbd>styles.xml</kbd> file, but that is not a requirement, as we can use whatever filename we want. As seen in this recipe, multiple <kbd>&lt;style&gt;</kbd> elements can be included in one XML file.</p>
<p>Once the style is created, you can easily apply it to any number of other views as well. What if you wanted to have a button with the same style? Just drop a button in the layout and assign the same style.</p>
<p>What if we created a new button, but wanted the button to expand the full width of the view? How do we override the style for just that view? Simply specify the attribute in the layout as you've always done. The local attribute will take priority over the attribute in the style.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There is another feature of styles<strong>: inheritance</strong>. By specifying a parent when defining the style, we can have styles build on each other, creating a hierarchy of styles. If you look at the default style in <kbd>styles.xml</kbd>: <kbd>AppTheme</kbd>, you will see the following line:</p>
<pre>&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; </pre>
<p><kbd>AppTheme</kbd> inherits from a theme defined in the Android SDK.</p>
<div class="packt_tip">If you want to inherit from a style you have created yourself, there is a shortcut method. Instead of using the parent attribute, you can specify the parent name first, followed by a period, then the new name, such as the following:<br/>
<kbd>&lt;style name="MyParent.MyStyle" &gt;</kbd></div>
<p>You saw how to specify a style for a view, but what if we wanted all the <kbd>TextView</kbd> objects in our application to use a specific style? We'd have to go back to each <kbd>TextView</kbd> and specify the style. But there's another way. We can include a <kbd>textViewStyle</kbd> item in a style to automatically assign a style to all <kbd>TextView</kbd> objects. (There's a style for each of the widget types so you can do this for <kbd>Button</kbd>, <kbd>ToggleButton</kbd>, <kbd>TextView</kbd>, and so on.)</p>
<p>To set the style for all <kbd>TextView</kbd> objects, add the following line to the <kbd>AppTheme</kbd> style:</p>
<pre>&lt;item name="android:textViewStyle"&gt;@style/MyStyle&lt;/item&gt;</pre>
<p>Since the theme for our application already uses <kbd>AppTheme</kbd>, we only have to add that single line to <kbd>AppTheme</kbd> to have all our <kbd>TextView</kbd> objects styled with our custom <kbd>MyStyle</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>The Android Design Support Library at <a href="https://www.google.com/design/spec/material-design/introduction.html">https://www.google.com/design/spec/material-design/introduction.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Turning a style into a theme</h1>
                </header>
            
            <article>
                
<p>A <strong>theme</strong> is a style applied to an activity or the whole application. To set a theme, use the <kbd>android:theme</kbd> attribute in the <kbd>AndroidManifest.xml</kbd> file. The <kbd>theme</kbd> attribute applies to the <kbd>&lt;Application&gt;</kbd> element as well as the <kbd>&lt;Activity&gt;</kbd> elements. All views within that element will be styled with the theme specified.</p>
<p>It's common to set the application theme, but then override a specific activity with a different theme.</p>
<p>In the previous recipe, we set <kbd>textViewStyle</kbd> using the <kbd>AppTheme</kbd> style (which the wizard created automatically). In this recipe, you will learn how to set both the application and activity themes.</p>
<p>Along with the style settings we have already explored, there are additional style options we didn't discuss because they don't apply to a View, they apply to the window as a whole. Settings such as hiding the application title or action bar and setting the window background, just to name a few, apply to the window and therefore must be set as a theme.</p>
<p>For this recipe, we are going to create a new theme based on the autogenerated <kbd>AppTheme</kbd>. Our new theme will modify the window appearance to make it a <strong>dialog</strong>. We will also look at the <kbd>theme</kbd> settings in the <kbd>AndroidManifest.xml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Start a new project in Android Studio and call it <kbd>Themes</kbd>. Use the default wizard options and select <span class="packt_screen">Empty Activity</span> when prompted for the <span class="packt_screen">Activity type</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We start by adding a new theme to the existing <kbd>styles.xml</kbd> file to make our activity look like a dialog. Here are the steps to create the new theme and set the activity to use the new theme:</p>
<ol>
<li>Since themes are defined in the same resource as styles, open the <kbd>styles.xml</kbd> file located in <kbd>res/values</kbd> and create a new style. We will create a new style based on the <kbd>AppTheme</kbd> already provided, and set <kbd>windowIsFloating</kbd>. The XML will be as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;style name="AppTheme.MyDialog"&gt; 
    &lt;item name="android:windowIsFloating"&gt;true&lt;/item&gt; 
&lt;/style&gt; </pre>
<ol start="2">
<li>Next, set the activity to use this new dialog theme. Open the <kbd>AndroidManifest.xml</kbd> file and add a <kbd>theme</kbd> attribute to the activity element, as shown:</li>
</ol>
<pre style="padding-left: 60px">&lt;activity android:name=".MainActivity" 
    android:theme="@style/AppTheme.MyDialog"&gt; </pre>
<div class="packt_infobox">Note that both application and activity will now have a theme specified.</div>
<ol start="3">
<li>Now run the application on a device or emulator to see the dialog theme in action.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our new theme, <kbd>MyDialog</kbd>, inherits the base <kbd>AppTheme</kbd> using the alternative parent declaration, since <kbd>AppTheme</kbd> is defined in our code (and not a system theme). As mentioned in the <em>Introduction</em>, some settings apply to the window as a whole, which is what we see with the <kbd>windowIsFloating</kbd> setting. Once our new theme is declared, we assign our theme to the activity in the <kbd>AndroidManifest</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You might have noticed we could have just added <kbd>windowIsFloating</kbd> to the existing <kbd>AppTheme</kbd> and been done. Since this application only has one activity, the end result would be the same, but then any new activities would also appear as a dialog.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting a theme based on the Android version</h1>
                </header>
            
            <article>
                
<p>Most users prefer to see apps using the latest themes provided by Android. To be competitive with the many other apps in the market, you'll probably want to upgrade your app as well, but what about your users who are still running older versions of Android? By setting up our resources properly, we can use <strong>resource selection</strong> in Android to automatically define the parent theme based on the Android OS version the user is running.</p>
<p>First, let's explore the three main themes available in Android:</p>
<ul>
<li>Theme - Gingerbread and earlier</li>
<li>Theme.Holo - Honeycomb (API 11)</li>
<li>Theme.Material - Lollipop (API 21)</li>
</ul>
<p>This recipe will show how to properly set up the resource directories for Android to use the most appropriate theme based on the API version the app is running on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Start a new project in Android Studio and call it <kbd>AutomaticThemeSelector</kbd>. Use the default wizard option to make a <span class="packt_screen">Phone &amp; Tablet</span> project. Select the <span class="packt_screen">Empty Activity</span> when prompted for the <span class="packt_screen">Activity Type</span>. On the <span class="packt_screen">Configure Activity</span> dialog, deselect the <span class="packt_screen">Backwards Compatibility</span> (<span class="packt_screen">AppCompat</span>) checkbox.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Normally, we use the <span class="packt_screen">AppCompat</span> option when creating a project but in the preceding <em>Getting ready</em> section, we deselected this option as we need to explicitly set our resources manually. We will verify we are extending from the generic <kbd>Activity</kbd> class, then we can add our new style resources to select the theme based on the API. Here are the steps:</p>
<ol>
<li>We need to make sure <kbd>MainActivity</kbd> extends from <kbd>Activity</kbd> and not <kbd>AppCompatActivity</kbd>. Open <kbd>ActivityMain.java</kbd> and if necessary, change it to read as follows:</li>
</ol>
<pre style="padding-left: 60px">public class MainActivity extends Activity { </pre>
<ol start="2">
<li>Open <kbd>activity_main.xml</kbd> and drop in two views: <kbd>Button</kbd> and <kbd>Checkbox</kbd>.</li>
<li>Open <kbd>styles.xml</kbd> and remove <kbd>AppTheme</kbd> as it will not be used. Add our new theme so the file reads as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;resources&gt; 
    &lt;style name="AutomaticTheme" parent="android:Theme.Light"&gt; 
    &lt;/style&gt; 
&lt;/resources&gt; </pre>
<ol start="4">
<li>We need to create two new values folders for API 11 and 21. To do this, we need to change Android Studio to use the project view rather than the Android view. (Otherwise, we won't see the new folders in the next step.) At the top of the <span class="packt_screen">Project</span> window, it shows <span class="packt_screen">Android</span>; change this to <span class="packt_screen">Project</span> for the project view. See the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9f845c84-9762-4f9c-8b8a-207f574c8ee3.png" style="width:25.25em;height:20.67em;"/></div>
<ol start="5">
<li>Create a new directory by right-clicking on the <kbd>res</kbd> folder and navigating to <span class="packt_screen">New</span> | <span class="packt_screen">Directory</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7f0a6e45-657d-4982-ac7b-e423ad33cc87.png" style="width:38.83em;height:46.42em;"/></div>
<p style="padding-left: 90px">Use the following name for the first directory: <kbd>values-v11</kbd>.</p>
<p style="padding-left: 90px">Repeat this for the second directory using <kbd>values-v21</kbd>.</p>
<ol start="6">
<li>Now create a <kbd>styles.xml</kbd> file in each of the new directories. (Right-click on the <kbd>values-v11</kbd> directory and go to the <span class="packt_screen">New</span> | <span class="packt_screen">File</span> option.) For <kbd>values-v11</kbd>, use the following style to define the Holo theme:</li>
</ol>
<pre style="padding-left: 60px">&lt;resources&gt; &lt;style name="AutomaticTheme"<br/> parent="android:Theme.Holo.Light"&gt; &lt;/style&gt;<br/>&lt;/resources&gt;</pre>
<p style="padding-left: 60px">For <kbd>values-v21</kbd>, use the following code to define the Material theme:</p>
<pre style="padding-left: 60px"><span>&lt;resources&gt; &lt;style </span><span>name=</span><span>"AutomaticTheme"<br/></span><span>    </span><span>parent=</span><span>"android:Theme.Material.Light"</span><span>&gt; &lt;/style&gt;<br/></span><span>&lt;/resources&gt;</span></pre>
<ol start="7">
<li>The last step is to tell the application to use our new theme. To do this, open <kbd>AndroidManifest.xml</kbd> and change the application <kbd>android:theme</kbd> attribute to <kbd>AutomaticTheme</kbd>. It should read as follows:</li>
</ol>
<pre style="padding-left: 60px">android:theme="@style/AutomaticTheme"</pre>
<ol start="8">
<li>Now run the application on a physical device or emulator. If you want to see the three different themes, you will need to have a device or emulator running the different versions of Android.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we are using the Android resource selection process to assign the appropriate theme (which is a resource) based on the API version. Since we need to choose the theme based on the OS version in which it was released, we created two new values folders specifying the API version. This gives us a total of three <kbd>styles.xml</kbd> files: the default style, one in the <kbd>values-v11</kbd> directory, and the last in the <kbd>values-v21</kbd> directory.</p>
<p>Notice the same theme name is defined in all three <kbd>styles.xml</kbd> files. This is how the resource selection works. Android will use the resource from the directory that best fits our values. Here we are using the API level, but other criteria are available as well. It is very common to define separate resources based on other criteria, such as screen size, screen density, and even orientation.</p>
<p>The last step was to specify our new theme as the application theme, which we did in the Android Manifest.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>For more information on resource selection, see the <em>Using designated folders for screen-specific resources</em> section as well as the <em>Using graphics to show button state </em><span>recipe</span><em>.</em></p>


            </article>

            
        </section>
    </body></html>