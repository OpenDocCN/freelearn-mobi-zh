["```kt\n    val minApiLevel = Build.VERSION_CODES.O\n    if (android.os.Build.VERSION.SDK_INT < minApiLevel) {\n      // PiP not supported on this device\n      return false\n    }\n    ```", "```kt\nactivity.enterPictureInPictureMode()\n```", "```kt\noverride fun onPictureInPictureExited() {\n  super.onPictureInPictureExited()\n  // Any logic that we want to add when the user comes back\n     to the full screen experience in our app\n}\n```", "```kt\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest\n    xmlns:android =\n        \"http://schemas.android.com/apk/res/android\">\n    <application>\n        <activity\n            android:name = \"com.packt.playback.presentation\n                .PlaybackActivity\"\n            android:supportsPictureInPicture=\"true\"\n            android:resizeableActivity=\"true\"\n            android:screenOrientation=\"landscape\"/>\n    </application>\n</manifest>\n```", "```kt\noverride fun onUserLeaveHint() {\n    super.onUserLeaveHint()\n    val aspectRatio = Rational(16, 9)\n    val params = PictureInPictureParams.Builder()\n        .setAspectRatio(aspectRatio)\n        .build()\n    enterPictureInPictureMode(params)\n}\n```", "```kt\nclass PiPActionReceiver(private val togglePlayPause: () -> Unit) : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent:\n    Intent?) {\n        when (intent?.action) {\n            ACTION_TOGGLE_PLAY -> {\n                togglePlayPause()\n            }\n        }\n    }\n    companion object {\n        const val ACTION_TOGGLE_PLAY =\n            \"com.packflix.action.TOGGLE_PLAY\"\n    }\n}\n```", "```kt\nprivate lateinit var pipActionReceiver: PiPActionReceiver\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    pipActionReceiver = PiPActionReceiver {\n        //TODO handle there the play/pause logic\n    }\n    val filter =\n        IntentFilter(PiPActionReceiver.ACTION_TOGGLE_PLAY)\n    if (Build.VERSION.SDK_INT >=\n    Build.VERSION_CODES.TIRAMISU) {\n        registerReceiver(pipActionReceiver, filter,\n            RECEIVER_NOT_EXPORTED)\n    } else {\n        registerReceiver(pipActionReceiver, filter)\n    }\n    setContent {\n        PlaybackScreen()\n    }\n}\n```", "```kt\nprivate fun getIntentForTogglePlayPauseAction():\nRemoteAction {\n    val icon: Icon = Icon.createWithResource(this,\n        R.drawable.baseline_play_arrow_24)\n    val intent =\n    Intent(PiPActionReceiver.ACTION_TOGGLE_PLAY).let {\n   intent ->\n        PendingIntent.getBroadcast(this, 0, intent,\n            PendingIntent.FLAG_UPDATE_CURRENT or\n                PendingIntent.FLAG_IMMUTABLE)\n    }\n    return RemoteAction(icon, \"Toggle Play\", \"Play or pause\n        the video\", intent)\n}\n```", "```kt\noverride fun onUserLeaveHint() {\n    super.onUserLeaveHint()\n    val aspectRatio = Rational(16, 9)\n    val params = PictureInPictureParams.Builder()\n        .setAspectRatio(aspectRatio)\n        .setActions(listOf(\n            getIntentForTogglePlayPauseAction()))\n        .build()\n    enterPictureInPictureMode(params)\n}\n```", "```kt\n@AndroidEntryPoint\nclass PlaybackActivity: ComponentActivity() {\n    private val viewModel: PlaybackViewModel by\n    viewModels()\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        pipActionReceiver = PiPActionReceiver {\n            viewModel.togglePlayPause()\n        }\n        ...\n    }\n}\n```", "```kt\n[versions]\n...\nmediarouter = \"1.7.0\"\ngoogle-cast = \"21.4.0\"\n[libraries]\n...\nmedia-router = { group = \"androidx.mediarouter\", name=\"mediarouter\", version.ref=\"mediarouter\"}\ngoogle-cast = { group = \"com.google.android.gms\", name=\"play-services-cast-framework\", version.ref=\"google-cast\"}\n```", "```kt\n    implementation(libs.media.router)\n    implementation(libs.google.cast)\n```", "```kt\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.BLUETOOTH_CONNECT\" />\n<uses-permission android:name=\"android.permission.BLUETOOTH_SCAN\" />\n<uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n```", "```kt\n@Composable\nfun MediaRouteDiscoveryOptions(mediaRouter: MediaRouter) {\n    val context = LocalContext.current\n    val routeSelector = remember {\n        MediaRouteSelector.Builder()\n            .addControlCategory(\n                MediaControlIntent.CATEGORY_REMOTE_PLAYBACK\n            )\n            .build()\n    }\n    val mediaRoutes = remember {\n    mutableStateListOf<MediaRouter.RouteInfo>() }\n    DisposableEffect(mediaRouter) {\n        mediaRouter.addCallback(routeSelector, callback,\n            MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN)\n        onDispose {\n            mediaRouter.removeCallback(callback)\n        }\n    }\n}\n```", "```kt\nval callback = remember {\n    object : MediaRouter.Callback() {\n        override fun onRouteAdded(router: MediaRouter,\n        route: MediaRouter.RouteInfo) {\n            mediaRoutes.add(route)\n        }\n        override fun onRouteRemoved(router: MediaRouter,\n        route: MediaRouter.RouteInfo) {\n            mediaRoutes.remove(route)\n        }\n    }\n}\n```", "```kt\nAndroidView(\n    factory = { ctx ->\n        MediaRouteButton(ctx).apply {\n            setRouteSelector(routeSelector)\n        }\n    },\n    modifier = Modifier\n        .wrapContentWidth()\n        .wrapContentHeight()\n)\n```", "```kt\n@Composable\nfun TopMediaRow(mediaRouter: MediaRouter, modifier:\nModifier = Modifier) {\n    Row(\n        modifier = modifier\n            .fillMaxWidth()\n            .padding(20.dp),\n        horizontalArrangement = Arrangement.SpaceBetween,\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(text = \"S1:E1 \\\"Pilot\\\"\", color = Color.White)\n        MediaRouteDiscoveryOptions(mediaRouter =\n            mediaRouter)\n    }\n}\n```", "```kt\nTopMediaRow(\n    mediaRouter =\n        MediaRouter.getInstance(LocalContext.current),\n    modifier = Modifier.align(Alignment.TopCenter))\n```", "```kt\nval castContext = CastContext.getSharedInstance(context)\n```", "```kt\nprivate val sessionManagerListener = object : SessionManagerListener<CastSession> {\n    override fun onSessionStarted(session: CastSession,\n    sessionId: String) {\n        castSession = session\n        updateUIForCastSession(true)\n    }\n    override fun onSessionEnded(p0: CastSession, p1: Int) {\n        castSession = null\n        updateUIForCastSession(false)\n    }\n    override fun onSessionResumed(session: CastSession, p1:\n    Boolean) {\n        castSession = session\n        updateUIForCastSession(true)\n    }\n    override fun onSessionStarting(p0: CastSession) {}\n    override fun onSessionStartFailed(\n        p0: CastSession, p1: Int) {}\n    override fun onSessionResuming(session: CastSession,\n        p1: String) {}\n    override fun onSessionResumeFailed(session:\n        CastSession, p1: Int) { }\n    override fun onSessionEnding(session: CastSession) {}\n    override fun onSessionSuspended(p0: CastSession,\n        p1: Int) {}\n}\n```", "```kt\noverride fun onStart() {\n    super.onStart()\n    castContext.sessionManager.addSessionManagerListener(\n        sessionManagerListener, CastSession::class.java)\n}\noverride fun onStop() {\n    super.onStop()\n    castContext.sessionManager.removeSessionManagerListener\n        (sessionManagerListener, CastSession::class.java)\n}\n```", "```kt\nprivate fun updateUIForCastSession(isCasting: Boolean) {\n    viewModel.setCastingState(isCasting)\n}\n```", "```kt\nprivate val _isCasting = MutableStateFlow<Boolean>(false)\nval isCasting: MutableStateFlow<Boolean> = _isCasting\n```", "```kt\nfun setCastingState(isCasting: Boolean) {\n    _isCasting.value = isCasting\n}\n```", "```kt\n@Composable\nfun PlaybackScreen() {\n    ...\n    val isCasting = viewModel.isCasting.collectAsState()\n    Box(\n        ...\n    ) {\n        if (isCasting.value) {\n            NowCastingView()\n        } else {\n            //VideoPlayerComposable and the rest of the UI...\n        }\n    }\n}\n```", "```kt\n@Composable\nfun NowCastingView() {\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n    ) {\n        Column(\n            modifier = Modifier.padding(16.dp)\n        ) {\n            Text(\n                text = \"Now Casting\",\n                style =\n                    MaterialTheme.typography.headlineMedium\n            )\n        }\n    }\n}\n```", "```kt\noverride fun onSessionStarted(session: CastSession,\nsessionId: String) {\n    castSession = session\n    updateUIForCastSession(true)\n    loadMedia(session)\n}\n```", "```kt\nprivate fun loadMedia(castSession: CastSession) {\n    val mediaInfo = MediaInfo.Builder(viewModel.mediaUrl)\n        .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED)\n        .setContentType(\"video/mp4\")\n        .build()\n    val mediaLoadOptions = MediaLoadOptions\n        .Builder()\n        .setAutoplay(true)\n        .setPlayPosition(0)\n        .build()\n    castSession.remoteMediaClient?.load(mediaInfo,\n        mediaLoadOptions)\n}\n```"]