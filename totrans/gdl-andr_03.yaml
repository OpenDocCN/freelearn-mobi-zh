- en: Chapter 3. Managing Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency management is one of the areas where Gradle really shines. In the
    best case scenario, all you need to do is add one line to your build file, and
    Gradle will download the dependency from a remote repository and make sure its
    classes are available to your project. Gradle even goes a step further. In case
    a dependency for your project has dependencies of its own, Gradle will resolve
    those, and take care of everything. These dependencies of dependencies are called
    **transitive dependencies**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces the concepts of dependency management, and explains
    the multiple ways of adding dependencies to Android projects. These are the main
    topics we will be talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we discuss dependencies, we usually mean external dependencies, such as
    libraries that are provided by other developers. Manually managing dependencies
    can be a big hassle. You have to locate the library, download the JAR file, copy
    it into your project, and reference it. Often these JAR files have no version
    in their name, so you need to remember to add it yourself, in order to know when
    to update. You also need to make sure the libraries are stored in a source control
    system, so that the team members can work with the code base without manually
    downloading the dependencies themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using repositories can solve these issues. A repository can be seen as a collection
    of files. Gradle does not define any repositories for your project by default,
    so you need to add them to the `repositories` block. If you use Android Studio,
    this is done for you. We have mentioned the `repositories` block briefly in the
    previous chapters; it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Gradle supports three different kinds of repositories: Maven, Ivy, and static
    files or directories. Dependencies are fetched from the repositories during the
    execution phase of the build. Gradle also keeps a local cache, so a particular
    version of a dependency only needs to be downloaded to your machine once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency is identified by three elements: group, name, and version. The
    group specifies the organization that created the library and is usually a reverse
    domain name. The name is a unique identifier for the library. The version specifies
    which version of the library you want to use. Using these three elements, a dependency
    can be declared in the `dependencies` block with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shorthand for the full Groovy map notation, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only required field for a dependency is the name. Group and version are
    optional elements. Nonetheless, it is recommended to add the group for clarity,
    and the version in order to make sure libraries are not updated automatically,
    which could cause a build to break.
  prefs: []
  type: TYPE_NORMAL
- en: Preconfigured repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For your convenience, Gradle has preconfigured three Maven repositories: JCenter,
    Maven Central, and the local Maven repository. To include them in your build script,
    you need to include these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Maven Central and JCenter are two well-known online repositories. There is no
    reason to use both of them at the same time, and it is always recommended to use
    JCenter, which is also the default repository in Android projects created with
    Android Studio. JCenter is a superset of Maven Central, so when you make the switch,
    you can leave your already defined dependencies intact. On top of that, it supports
    HTTPS, unlike Maven Central.
  prefs: []
  type: TYPE_NORMAL
- en: The local Maven repository is a local cache of all the dependencies you have
    used, and you can add your own dependencies as well. By default, the repository
    can be found in the home directory in a folder called `.m2`. On Linux or Mac OS
    X, the path is `~/.m2`. On Microsoft Windows, it is `%UserProfile%\.m2`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these preconfigured repositories, you can also add other public, or
    even private repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Remote repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some organizations create interesting plugins or libraries, and prefer to host
    them on their own Maven or Ivy server, instead of publishing them to Maven Central
    or JCenter. To add those repositories to your build, all you need to do is to
    add the URL to a `maven` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for Ivy repositories. Apache Ivy is a dependency manager that
    is popular in the Ant world. Gradle supports these repositories in a format that
    is identical to the one that is used for Maven repositories. Add the repository
    URL to an `ivy` block, and you are good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If your organization is running its own repository, chances are that it is
    secured, and you need credentials to access it. This is how you add credentials
    for a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The approach for Maven and Ivy is the same here as well. You can add a `credentials`
    block with the same format to the configuration of your Ivy repository.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Storing credentials**'
  prefs: []
  type: TYPE_NORMAL
- en: It is not a good idea to store your credentials in the build configuration file.
    The build configuration file is plain text, and is checked into the source control
    system. A better idea would be to use a separate Gradle properties file, as we
    have seen in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"), *Basic
    Build Customization*.
  prefs: []
  type: TYPE_NORMAL
- en: Local repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to run Maven and Ivy repositories on your own hard drive or
    a network drive. To add these to the build, you just need to configure the URL
    to a relative or absolute path to the location on the drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: New Android projects have a dependency on the Android Support Library by default.
    When installing the Google repositories using the SDK manager, two Maven repositories
    are created on your hard drive `ANDROID_SDK/extras/google/m2repository` and `ANDROID_SDK/extras/android/m2repository`.
    This is where Gradle gets the libraries provided by Google, such as the Android
    Support Library and Google Play Services.
  prefs: []
  type: TYPE_NORMAL
- en: You can add a regular directory as a repository as well, using `flatDirs`. This
    enables you to add files from that directory in the `dependency` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter, when we talk about library projects, we will look at
    an example of how this can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Local dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you might still need to manually download a JAR file or a native
    library. Perhaps you want to create your own library that you can reuse in several
    projects, without publishing it to a public or private repository. In those cases,
    it is impossible to use any of the online resources, and you will have to use
    different ways to add the dependencies. We will describe how to use file dependencies,
    how to include native libraries, and how you can include library projects in your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: File dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a JAR file as a dependency, you can use the `files` method that Gradle
    provides. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This can get tedious if you have a lot of JAR files, so it might be easier
    to add an entire folder at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, a newly created Android project will have a libs folder, and declare
    it to be used for dependencies. Instead of simply depending on all files in the
    folder, there is a filter that makes sure that only JAR files are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This means that in any Android project that is created in Android Studio, you
    can drop a JAR in the libs folder, and it will automatically be included in the
    compile classpath and the final APK.
  prefs: []
  type: TYPE_NORMAL
- en: Native libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Libraries written in C or C++ can be compiled to platform-specific native code.
    These libraries typically consist of several `.so` files, one for every platform.
    The Android plugin supports native libraries by default, all you need to do is
    create a directory called `jniLibs` on the module level, and create subdirectories
    for each platform. Drop the `.so` files in the applicable directory, and you are
    good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If this convention does not work for you, you can just set the location yourself
    in the build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Library projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to share a library that uses Android APIs, or includes Android resources,
    you need to create a library project. Library projects generally behave the same
    as application projects. You can use the same tasks to build and test library
    projects, and they can have different build variants. The difference is in the
    output. Where an application project generates an APK that can be installed and
    run on an Android device, a library project generates a `.aar` file. This file
    can be used as a library for Android application projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using library project modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of applying the Android application plugin, the build script applies
    the Android library plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are two ways to include a library project in your application. One is
    to have it as a module inside your project; another is to create a `.aar` file,
    which can be reused in multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you set up a library project as a module in your project, you need to add
    the module to `settings.gradle` and add it as a dependency to the application
    module. The settings file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the library module is called `library`, and this corresponds
    to a folder with the same name. To use the library in the Android module, a dependency
    needs to be added to the `build.gradle` file of the Android module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will include the output of the library in the classpath of the application
    module. We will look at this approach in more detail in [Chapter 5](ch05.html
    "Chapter 5. Managing Multimodule Builds"), *Managing Multimodule Builds*.
  prefs: []
  type: TYPE_NORMAL
- en: Using .aar files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you create a library that you want to reuse in different Android applications,
    you can build a `.aar` file, and add it to your project as a dependency. The `.aar`
    file will be generated in the `build/output/aar/` folder of the module''s directory
    when building the library. To add the `.aar` file as a dependency, you need to
    create a folder in the application module, copy the `.aar` file to it, and add
    the folder as a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make it possible to add any file inside that folder as a dependency.
    You can reference the dependency as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This tells Gradle to look for a library with a certain name that has the `.aar`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few dependency-related concepts that are interesting to understand,
    even if you might not need to use them today. One of them is the concept of configurations,
    which explains the `compile` keyword that we have been using for dependencies
    throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you might have to work with an SDK that is only present on certain
    devices, like a Bluetooth SDK from a specific vendor, for example. In order to
    be able to compile the code, you need to add the SDK to your compile classpath.
    You do not need to include the SDK in your APK though, because it is already on
    the device. This is where dependency configurations come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle groups dependencies into configurations, which are just named sets of
    files. These are the standard configurations for an Android app or library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provided`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testCompile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`androidTestCompile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `compile` configuration is the default one and contains all dependencies
    required to compile the main application. Everything in this configuration is
    not only added to the classpath, but also to the generated APK.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies in the `apk` configuration will only be added to the package,
    and are not added to the compilation classpath. The `provided` configuration does
    the exact opposite, and its dependencies will not be packaged. These two configurations
    only take JAR dependencies. Trying to add library projects to them will result
    in an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `testCompile` and `androidTestCompile` configurations add extra
    libraries specifically for testing. These configurations are used when running
    test-related tasks, which can be useful when adding a testing framework such as
    JUnit or Espresso. You only want these frameworks to be present in the test APK,
    not in the release APK.
  prefs: []
  type: TYPE_NORMAL
- en: Besides those standard configurations, the Android plugin also generates configurations
    for every build variant, making it possible to add dependencies to configurations
    such as `debugCompile`, `releaseProvided`, and so on. This can be useful if you
    want to add a logging framework to only your debug builds, for example. You can
    find more information on this in [Chapter 4](ch04.html "Chapter 4. Creating Build
    Variants"), *Creating Build Variants*.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Versioning is an important aspect of dependency management. Dependencies added
    to repositories such as JCenter are assumed to follow a set of rules for versioning,
    called semantic versioning. With semantic versioning, a version number always
    has the format `major.minor.patch`, and the numbers are incremented according
    to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A major version goes up when you make incompatible API changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A minor version gets updated when you add functionality in a backwards-compatible
    manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A patch is incremented when you make bug fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some situations, you might want to get the latest version of a dependency
    every time you build your app or library. The best way to accomplish this is by
    using dynamic versions. There are several ways to apply dynamic versions, here
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we tell Gradle to get the latest patch release. In line two,
    we specify that we want to get every new minor version, and it has to be at least
    minor version 2\. In the last line, we tell Gradle always to get the newest version
    of the library.
  prefs: []
  type: TYPE_NORMAL
- en: You should be careful with using dynamic versions. If you allow Gradle to pick
    up the latest version, it might pick up a dependency version that is unstable,
    causing the build to break. Even worse, you could end up with different versions
    of a dependency on the build server and on your personal machine, causing your
    application's behavior to be inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Studio will warn you about the possible problems with dynamic versions
    when you try to use it in your build file, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic versions](img/B01061_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inside Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to add new dependencies is to use Android Studio''s **Project
    Structure** dialog. Open the dialog from the **File** menu and navigate to the
    **Dependencies** tab to get an overview of your current dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inside Android Studio](img/B01061_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this dialog, you can add new dependencies by clicking on the green plus
    icon. You can add other modules, files, and you can even search JCenter for libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inside Android Studio](img/B01061_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Android Studio dialog makes it easy to get an overview of the dependencies
    in your project, and to add new libraries. You do not need to manually add lines
    to the `build.gradle` file, and it is easy to search JCenter straight from the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at several ways to add dependencies to an Android
    project. We learned about repositories, all the forms they can come in, and how
    we can depend on files without using repositories.
  prefs: []
  type: TYPE_NORMAL
- en: You now also know about some important concepts regarding dependencies, namely
    configurations, semantic versioning, and dynamic versions.
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned build variants on several occasions already, and in the next
    chapter, we will finally explain what build variants are, and why they are useful.
    Build variants can make it easier to develop, test, and distribute apps. Understanding
    how variants work can significantly speed up your development and distribution
    process.
  prefs: []
  type: TYPE_NORMAL
