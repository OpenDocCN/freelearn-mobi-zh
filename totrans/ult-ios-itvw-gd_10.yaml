- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Great User Experiences with UIKit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18653_06.xhtml#_idTextAnchor196), we took a break from coding
    and discussed topics that evolve our code, such as testing, debugging, and more.
    Now, it’s time to go back to what we love to do, and what is more loveable in
    iOS development than building a great UI experience?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: For most iOS developers, UIKit is considered to be the most critical framework
    right after Foundation, and in iOS interviews, it’s a mandatory topic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though UIKit is a huge framework, this chapter will cover the essential
    topics required for iOS developers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We will go over the **Auto** **Layout** system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss the different **UIView** features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will ensure a deep understanding of **UITableViews**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk about **UIViewController** and its role in our app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will dive into the navigation world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn the basic concepts of animations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I said – UIKit is an enormous topic, and there are many more, but we are
    focusing on the mandatory interview issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We will start with what is driving our layout, and that’s the Auto Layout system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Answering questions about Auto Layout
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UIKit is a vast topic, and over the years, it has become even more significant,
    gaining more and more capabilities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The engine that drives how things are placed on the screen is what Apple calls
    Auto Layout, which is why I chose to start the UIKit chapter with that topic in
    mind.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Auto Layout is Apple technology that defines the *relationships between the
    different elements* on the screen and tremendously influences our ability to move
    fast with UI development. We can say that mastering Auto Layout sets us up with
    the ability to provide a great UI in a decent amount of time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: But there is more than just time efficiency – Auto Layout can help us *adapt
    our app to different screen sizes* or even platforms (**iPad** versus **iPhone**).
    It can also help us automatically set the UI direction according to the current
    localization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go over some of the most common Auto Layout questions now. Isn’t it an
    excellent start for a UIKit chapter?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain what content hugging and compression resistance are in Auto
    Layout and how they are used to control the layout of UI elements?”
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Compression resistance** and **content hugging** are two essential concepts
    in Auto Layout that define views'' behavior when their size and layout change.
    At this stage, the interviewer assumes we already know the basics of Auto Layout
    and wants to see how we handle more complex situations where two different views
    are “fighting” over limited space to satisfy all their constraints.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Compression resistance and content hugging are two of UIView’s properties that
    define the layout behavior when there isn’t enough space to satisfy all the constraints.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over what these terms mean for constraints:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Content hugging**: When content hugging is set to high priority, the view
    wants to become *as small as possible* with a specific axe'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compression resistance**: When the compression resistance property is set
    to high, the view wants to become *as big as possible* with a specific axe'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One great example to demonstrate a possible conflict between two views is a
    UIView (let’s say `UITableViewCell`) with two subviews – a leading label and a
    button (see *Figure 7**.1*):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A view with a label and a button](img/Figure_7.1_B18653.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A view with a label and a button
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at *Figure 7**.1*, we can see a possible use case – both the label
    and button can have a short text, and as a result, their intrinsic content size
    is small. If these two views try to set their width according to their content,
    one will have to “give up” and fill the remaining space. To ensure that the button
    will try to become as small as possible and the label will fill the remaining
    space, we need to set their content hugging and compression resistance accordingly.
    Let’s see how to do that in code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Calling `setcompressionResistencePriority` for `label` means that when the cell
    is resized horizontally, the auto-layout system will try to maintain the intrinsic
    content size of the label and *prevent it from* *being compressed*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: However, calling `setContentHuggingPrioirty` for button means that when the
    cell is resized horizontally, and there is extra space available, the auto-layout
    system will *try to expand* `button` to fill the available space and prevent it
    from being stretched too much.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: We can set these priorities in the code and Interface Builder quite easily.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: There are many other examples where this settlement is needed, such as a page
    title’s width that conflicts with its alignment or complex screens with dynamic
    font size.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how to use size classes in Interface Builder to adapt layouts
    for different screen sizes and orientations?”
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: This question is important because it tests our understanding by taking Auto
    Layout and trying to adapt our layout to *different sizes* *and orientations*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Notice I didn’t mention iPad or iPhone – these terms are irrelevant when discussing
    Auto Layout. We must consider our layout fully responsive according to different
    size levels, aka, size classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Size classes** are a feature that allows us to create one UI for various
    screen sizes. A screen size can be an iPhone or an iPad, but it can also be an
    iPad app being presented on a split screen and therefore needs to change its layout
    to an iPhone app.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The classes we have today are **Compact** and **Regular**. Compact usually means
    an iPhone or an iPad app in a split screen, and Regular means an iPad app. As
    mentioned, we shouldn’t think of these classes as iPhone versus iPad. Size classes
    allow us to think responsively regardless of our app’s device.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: To use size classes in Interface Builder, we first need to open the storyboard
    we want to work on. Then, in the bottom right corner of the `w Any h Any` class,
    which means the layout will be the same for all devices and orientations. We can
    select another size class from the control to create a different layout for a
    specific screen size or orientation. For example, we can choose the `w Compact
    h Regular` class to create a layout for iPhones in portrait orientation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: One good use case is a login screen, where on a small screen, we want the username
    and password text fields to be laid out vertically, and on a bigger screen, we
    may want them to be laid out horizontally. The layout of the text fields according
    to size can be managed using size classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: More examples of different values in different size classes are fonts, Auto
    Layout, and constant size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: “What is the purpose of the safe area in Auto Layout, and how do you ensure
    that your views are properly positioned within the safe area?”
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The **safe area** is an important topic when working with layouts across different
    devices. Every iOS developer must know how to handle the safe area, which contains
    the status bar, sensors, and round corners of modern iPhones. This question tests
    our experience working with different devices and creating a layout agnostic to
    the device type we work on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The safe area is a feature in Auto Layout that provides a **layout guide** that
    helps us position elements above and below areas on the screen reserved for sensors,
    round corners, and generally areas the user isn’t supposed to touch.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: However, we can position non-interactive views in the safe area zone, such as
    videos or backgrounds. Still, we must consider that iOS elements, sensors, and
    screen round corners may partially cover these views.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure we position a view outside the safe area, we can use a property named
    `safeAreaLayoutGuide`. Here’s an example of positioning a label below the top
    safe area using `safeAreaLayoutGuide`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that `view`, the UIViewController main view, has a property named
    `safeAreaLayoutGuide`, and that guide represents the end of the safe area zone.
    This guide is equivalent to the screen edges in older devices, but in modern devices,
    it means the interactive part of the display.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: It is best practice to check your layout with different devices to ensure it
    is usable in all displays.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Auto Layout is a fundamental topic in UIKit and iOS development. There’s no
    way to get into UI development without working closely with Auto Layout, and the
    UI is an important topic in iOS. If you started your iOS development career with
    SwiftUI, ensure you are familiar with Auto Layout, at least for the basic terms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Solving UIView questions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UIView is the basic building block for user interaction in iOS UIKit. At its
    roots, it represents a rectangle on the screen that can display graphics and handle
    user interactions and animations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Before we go over any interview questions, it is crucial to understand the roles
    of UIView in UIKit, and its relationship with CALayer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the main features of UIView:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Manage subviews**: UIView can contain additional UIViews called **subviews**,
    which can include their own subviews. This capability allows us to build complex
    UIs and reusable components. UIView is also responsible for handling the layout
    of its subviews using the Auto Layout system we discussed in the previous chapter.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Respond to user interaction**: Another important role UIView has is to respond
    to user interaction, which is not a minor topic. Preparing for the interview involves
    learning about the **responder chain**, which handles user interactions with UIView’s
    hierarchy.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw graphics**: UIView can draw graphics: lines, shapes, images, and texts.
    UIView does that using another framework called **Core Graphics**, which is responsible
    for drawing basic graphics using the **CPU**.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what about CALayer? Well, we already know the UIView can draw using Core
    Graphics, but that’s not an efficient way. Therefore, it has a CALayer. The CALayer
    is responsible for drawing the content inside UIView, which uses **Core Animation**
    and the device’s **GPU**. Each UIView has a primary CALayer that can have sublayers
    of its own.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The CALayer is responsible for the content drawing, and UIView is accountable
    for the layout and user interaction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how the responder chain works in iOS?”
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The responder chain is a key concept in iOS UI development. The idea discusses
    the management of user interaction in multi-layer screens.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The question is vital because user interaction is a critical topic in UI development,
    and the responder chain is not a simple concept to understand at first glance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The term “responder chain” refers to a mechanism in which the user touches the
    screen, and each UIView passes the touch forward to its corresponding subviews
    until one of the views responds.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us explore this in *Figure 7**.2*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Example of a responder chain in iOS](img/Figure_7.2_B18653.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Example of a responder chain in iOS
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7**.2*, the touch starts with `UIApplication` and goes down
    until it reaches the first view that responds to the touch, in this case, `UITextField`.
    The respond chain “asks” each of the views if it is the first responder by calling
    the `becomeFirstResponder()` function. That’s why calling directly to `become
    FirstResponder()` on a text field brings up the keyboard and makes the text field
    the currently active input field.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In short, a responder chain is our ability to control which view catches the
    user interaction while views are placed on top of each other. There are more cases
    where this comes in handy, such as transparent views or scrolls.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: “How can you respond to device orientation changes in UIView?”
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In many apps, responding to device orientation is crucial because it provides
    the user with an optional layout for the app just by rotating the device.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: But that’s not the real reason why it’s essential to understand that question
    correctly. We should know how to structure our UI to support different screen
    proportions and adjust the layout and the controls according to the new orientation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The question tests our flexibility and readiness for a radical layout change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling device orientation changes requires tackling that problem from different
    angles. Let’s list some of the things we can do:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Verify our Auto Layout constraints**: Auto Layout is a great technique to
    ensure our layout will stay usable after changing the screen bounds. We can define
    constraint relationships and limit view size or margins to ensure our layout is
    updated correctly with changing orientation.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animate changes**: If possible, we should animate changes to our views to
    provide our users with a seamless and smooth change experience.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override the willTransition(to:with) method**: The**willTransition(to:with)**
    method gets called just before the view transitions to a new size or a trait collection.
    That’s where we can modify the view appearance in addition to what Auto Layout
    already changed. For example, we can show or hide subviews, change texts, or modify
    constraint values.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update layout**: Position or rearrange views, and in general, make changes
    to our layout to fit the new orientation. That, of course, is according to our
    design and product requirements.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all app makers support landscape and portrait states in their products,
    as this is more a design decision than an engineering one. But building our views
    with orientation change in mind is a good practice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: “Why does UIView not have a ‘viewDidAppear’ method as UIViewController does?”
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t discussed view controllers just yet, but that’s a question many candidates
    struggle to answer. This question aims to see whether we understand the relationship
    UIViews have with their view controller. Many junior developers ask themselves
    that question because understanding the UIView role isn’t intuitive. More experienced
    developers should answer that question more easily.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: UIView doesn’t have a `viewDidAppear` method like **UIViewController** because
    the primary role of UIView is to be a visual component and not handle life cycle
    events.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: When we look back to the `viewDidLoad`, `viewWillAppear`, and `viewDidAppear`.
    If we need to perform tasks in the life cycle events such as performing network
    requests, loading data, or setting a state, we should do it in the view controller
    and update the view accordingly. Doing any of these is not part of the UIView’s
    role.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: MVC will be discussed in detail in [*Chapter 11*](B18653_11.xhtml#_idTextAnchor329).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain the difference between setNeedsLayout, layoutSubviews, and
    layoutIfNeeded in UIView? When would you use each of these methods, and how do
    they impact the layout process?”
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: These three UIView methods (`setNeedsLayout`, `layoutSubviews`, and `layoutIfNeeded`)
    tell the story of UIView rendering cycle optimization. This is not a go/no-go
    question but more like a bonus question. I have interviewed hundreds of iOS developers
    in my career, and most of them can’t fully answer this question as they don’t
    understand how the layout system works precisely.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Answering this question correctly will benefit us in an interview situation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s understand how the layout system works – UIView refreshes the layout
    of its subviews once every screen refresh rate (in 60Hz, it’s once every 16.67
    milliseconds), only if it needs to. What does that mean? For example, if the view
    changes its frame, it must refresh the layout of its subviews. The reason it happens
    every 16.67 milliseconds is because of efficiency. If we change the UIView’s frame
    multiple times within these 16.67 milliseconds, it will refresh the layout of
    its subviews only once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Now, what does it mean “refresh the layout of its subviews”? It means that the
    system runs the `layoutSubiews()` method, which we can override and perform additional
    changes if we like.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: We understand now that changing the UIView frame marks the view as “dirty,”
    so in the next run loop, it will run `layoutSubviews()`. But we don’t have to
    change its frame or one of the related constraints to mark the view as dirty.
    We can just call `setNeedsLayout()` to ensure that the view will update its subviews
    in the next run loop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need the view to run `layoutSubviews` immediately without waiting
    for the next run loop. One good example is animations and constraint changes.
    In this case, we can call `layoutIfNeeded()`, which will call `layoutSubviews()`
    only if UIView is marked as dirty.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: It is now clear why we never call `layoutSubviews()` directly – the system does
    that for us much more efficiently, and it is better to stick with the natural
    process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: As I said at the beginning of this section – UIView is our UI building block
    and one of the fundamental parts of MVC and **MVVM**. Understanding how it works
    beyond adding and removing subviews is essential to us as iOS developers and can
    help us influence our app performance and experience. Additionally, some of the
    discussed questions in this section will be asked in an interview.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s move on to another important side of the MVC pattern: UIViewController.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: “What is the difference between the frame and bounds properties?”
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Even though `bounds` and `frame` are quite similar, the difference between them
    is crucial to understand how the layout system works. The difference is important,
    especially when dealing with animations, positioning, and transitions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In short, the `frame` property represents the position and size of a UIView
    relative to its superview’s coordinate system, while the `bounds` property represents
    the position and size of a UIView relative to its own coordinate system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the `bounds` and `frame` properties for the same view,
    positioned in *x*:50 and *y*:100:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Frame:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Origin: (*x*: 50, *y*: 100)'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: (width: 200, height: 150)'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bounds:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Origin: (*x*: 0, *y*: 0)'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: (width: 200, height: 150)'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that the origin is different, but the size is the same. That’s because
    the origin in the frame is relative to its superview.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to note that there are cases where the frame and bounds
    sizes can differ. Unlike the `bounds` property, which represents the view’s size
    in its own coordinate system, the frame size is calculated and can change during
    animations. Therefore, it is possible to observe different size values between
    the `frame` and `bounds` properties. While the bounds size property remains constant,
    the frame size property can reflect the current size values during animations
    or transformations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Understanding everything about UIViewController
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UIViewController is a core class in iOS development and behaves as a building
    block for most iOS apps that use UIKit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'UIViewController has multiple roles in iOS development:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**It is the C in the MVC pattern**: If the UIView is the V (View) and our model
    is the M, the UIViewController is the one that coordinates between the presentation
    layer and the business layer. That role affects many of the features UIViewController
    has, such as life cycle events and memory management functions.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling life cycle events**: We explained this role of UIViewController
    in the previous section. UIViewController has another function: to manage the
    various life cycle events on the screen. By creating subclasses of UIViewController,
    we can take advantage of its different methods to handle all stages of a screen’s
    life cycle.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leading player in the navigation system**: We can present UIViewController
    above another UIViewController or push and pop it into and from a navigation stack.
    As such, UIViewController plays a significant role in iOS app navigation by representing
    a “screen” in our project (note – a UIViewController isn’t equivalent to a “screen,”
    but a screen always has a root view controller).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loading and unloading views**: Usually, we don’t present views on the screen
    without a UIViewController that handles them. We can indeed add a UIView to the
    app window, but that’s an edge case. Adding a view to the window brings with it
    issues such as life cycle management, model and data linking, and many more, and
    they are considered not ideal.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m not sure that, as iOS candidates, we will encounter an interview without
    a question about UIViewController.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: “Can you list all the life cycle events or methods of a UIViewController, in
    the order in which they occur?”
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: That is probably one of the most common questions interviewers ask. It isn’t
    a difficult question and is also easy to learn and complete.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: This question is usually considered a critical factor in the interview process,
    as not doing well can lead to concerns for most interviewers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand why – our understanding of UIViewController life cycle events
    influences the decisions of where to load and release data, how to build our UI,
    perform animation, and provide a good user experience to the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to be familiar with the UIViewController life cycle to
    handle user interaction and view updates.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We need to ensure we don’t have any gaps in our answer to this question.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s list the life cycle events, ordered by their call timing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**loadView()**: This is called before the view hierarchy is created. UIKit
    doesn’t create the view before **loadView()** is called, so we’ll get nil when
    accessing the UIViewController **view** property.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**viewDidLoad()**: This is called after the view is loaded. That’s where we
    can perform additional setups to the view, such as adding subviews and observers.
    Unlike many other life cycle methods, **viewDidLoad** is called only once.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**viewWillLayoutSubviews()**: This is called just before the view lays out
    its subviews. We can make additional changes to constraints at this time.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**viewDidLayoutSubviews()**: This is called after the view lays out its subviews.
    We can do tasks that require a final layout. For example, position views, scroll
    view content size, and animations.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**viewWillAppear()**: This is called before the view is presented on the screen.
    UIKit calls that method one or more times. That’s the place to load data if needed.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**viewDidAppear()**: This is called after the view is already presented on
    the screen. UIKit calls that method one or more times. Generally, that’s an excellent
    place to show start animations.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**viewWillDisappear()**: This is called just before the view is removed from
    the parent view controller or is hidden by a modal view controller. We can do
    some cleanup tasks here, such as stop timers and animations, perform savings,
    or stop media playback.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**viewDidDisapper()**: This is called after the view is removed from the parent
    view controller. We usually perform tasks that do not influence the user experience
    – for example, logging, states, cleaning temporary files, and resetting data.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is imperative to mention that some of the methods in the list *can be called
    multiple times* in different use cases. For example, `viewWillLayoutSubviews`
    can be called when the main view changes its size, such as an orientation change.
    The `viewWillDisappear` method might be called when a model is presented above
    the view controller. We should provide examples of each one of the life cycle
    events to show our understanding.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain the concept of UIViewController containment? How would you
    implement it in your app?”
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the previous question, this question is more advanced and requires
    knowledge of design patterns and architecture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**UIViewController containment** creates modular and reusable UI interfaces
    and increases our project flexibility.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: With UIViewController containment, we can add a view controller to another view
    controller and make it a child view controller. This differs from adding a subview
    because UIViewController represents an independent MVC unit and has its own responsibility.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at *Figure 7**.3*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Divide our screen into different view controllers](img/Figure_7.3_B18653.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Divide our screen into different view controllers
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.3* shows that a screen represented by a UIViewContoller is divided
    into two additional view controllers.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways of adding a view controller child:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Drag a new view controller in the storyboard**: We can use Xcode **Storyboard**
    to drag a new view controller to an existing view controller. That creates a container
    view that is linked to another view controller. Because a single **XIB file**
    represents a single view controller or a view, we can do that only in storyboards
    and not in standard XIB files.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding a child controller using code**: We can easily add a new child view
    controller in code using the **addChild(UIViewController:)** method. Let’s see
    an example of that:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are four steps we need to do:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Call the **addChild** method to ensure the new UIViewController is added as
    a child in the view controller hierarchy.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new view controller main view *as a subview* to the parent view controller.
    The views hierarchy needs to correspond to the view controller hierarchy.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the child view controller *view frame or constraints*. It can be whatever
    we need.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Notify the system* that the child view controller has been moved to the parent.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the advantages of adding the new view controller “according to the guidelines”
    is that we can sync the life cycle events we discussed in the previous question.
    A `viewWillAppear` method being called on the parent view controller is also called
    on its child view controller, as long as they are added correctly. The life cycle
    events sync is critical when reusing the view controller as a child view controller
    on different screens.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: We are already using UIViewController containment in our apps!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'You may feel that UIViewController containment is strange to you if you haven’t
    tried that before. But – most likely, you already used some kind of child view
    controller implementation in your apps. Let’s see two good examples:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**UINavigationController**: Navigating in UIKit is done with a parent view
    controller (UINavigationController) and a child view controller, the top view
    controller. Imagine yourself implementing your own navigation controller – how
    would you do that? How will you implement the push and pop view controllers’ actions?
    This is a great thinking exercise that can prepare you for the question.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**UISplitViewController**: Apple provides a split view controller for apps
    that run on iPads. In UISplitViewController, we have two additional child view
    controllers – master and detail view controllers. Both divide the screen into
    two different areas, each of which is a separate view controller. Now that you
    know how to add a child view controller, that’s easy.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: “How do you pass data between view controllers in iOS?”
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Passing data between view controllers is an important task in iOS development.
    The dynamic nature of apps presenting the same UI with different information requires
    us to update a view controller with new information constantly. The question tests
    our knowledge of the various design patterns of passing data between objects in
    general and between view controllers explicitly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways of passing data between view controllers! The problem is
    that all those ways make it extremely easy to answer the question. And therefore,
    we need to explain the use case and reason for each one of the ways we present
    to the interviewer. Let’s see some examples:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a delegate**: If we have a child-parent relationship, we use a delegate
    to notify of events and data between the child and the parent view controller.
    A delegate is a simple pattern based on a protocol used when we want to implement
    a simple update with a well-defined interface. However, the delegate pattern is
    considered a bit outdated as we have more advanced patterns today.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using dependency injection**: One way to pass data to a new view controller
    when presenting or pushing it into the stack is to use dependency injection. This
    can be achieved using the **init** function or setting one of its properties.
    One example can be a screen that displays contact information. In the **init**
    function, we can pass the contact entity that needs to be displayed. It’s important
    to note that this approach creates a one-way data stream and can be used whenever
    a new view controller needs to be displayed.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using a closure**: If we pass the information in one direction only, closure
    is a great way to do that. We can define a closure on the destination view controller
    and set it on the source view controller. Whenever we want to pass information
    from the source to its parent, the source just needs to run the closure with the
    relevant parameters. That’s a simple way to pass data with minimal coupling.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Combine**: Combine is an advanced and reactive version of closure.
    It lets us stream data updates, including error handling, async operations, and
    data manipulation from one object to another.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post notification**: If the two view controllers have no reference to each
    other, a notification may be a good solution. Even though we can attach data to
    the notification, posting a notification is considered to be an anti-pattern by
    many developers. A notification doesn’t have a straightforward interface; all
    living objects can observe it and respond. These two reasons alone make it less
    recommended than the other methods.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are already aware of all the methods I just presented, but listing them
    can help you answer that question and help you with design-pattern tasks and home
    assessments. That is one of my goals in this book – to organize your thoughts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Making sure we are ready with UITableView
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UITableView, followed by UICollectionView, is one of the oldest UI components
    in UIKit. In fact, UITableView was there from the start, and UICollectionView
    was added four years later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Why is UITableView considered to be a fundamental component? The reason is apparent.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Both UITableView and UICollectionView are specialized in displaying a significant
    *amount of data* efficiently and straightforwardly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: UITableView does more than that – it provides an interface for displaying items
    in a way suitable for *small screens*, including features like multi-selection,
    editing, headers, and footers. It became the primary way of displaying menus and
    data in many apps.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Apple ensured a component style, UITableView, was carried over to SwiftUI from
    day one to keep this capability with us.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: “How does the queuing mechanism work in a UITableView, and what are some best
    practices for optimizing its performance?”
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Like several other questions we discussed earlier (for example – UIViewController
    life cycle), that’s another go-no-go question you probably want to make sure you
    are ready for. This question tests our understanding of the primary mechanism
    of UITableView that enables its efficiency and performance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The UITableView queuing mechanism is the foundation for many on-top features
    and issues we may encounter, such as async operations during scroll, optimizations,
    and state management.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: That mechanism is also the basis for additional controls such as UICollectionView
    and MKMapView.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The UITableView mechanism ensures efficiency and high performance when scrolling
    with a large amount of data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with displaying a large number of items is *memory*. Allocating
    so many views, most off-screen, creates a memory overload, eventually leading
    to app termination.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do is to allocate only the views we see on the screen and release
    off-screen views while we are scrolling the list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: But allocating new views each time raises a performance issue. If the user scrolls
    fast, allocating and creating new views takes a few milliseconds, which causes
    lags even when running on powerful devices.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: This lag is where the queuing solution comes into practice. Instead of deallocating
    the view when it goes off-screen, UITableView puts it in a deque pool and pulls
    it from where it needs to display a new view in the list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The queuing mechanism makes the UITableView scrolling fast and smooth. But
    dequeuing cells also creates new problems, some of which are detailed here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Working on an existing cell**: Before we display the cell, we must remember
    it might already have existing information. We need to clear the cell after it
    moves out of the pool by calling the **prepareForReuse** method or overriding
    its properties before we display it.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verify responses from async operations**: A common issue in UITableViews
    is loading images async from a backend service. We start the request when the
    cell is being displayed, but when we get the response, the cell is already dequeued
    and connected to another entity. In this case, we need to ensure that the data
    we get in the response matches the current entity the cell is supposed to represent.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with multiple pools**: There are cases where we have numerous types
    of cells, probably based on different classes and UI. In this case, we need to
    create multiple deque pools, which we also need to handle and ensure.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, UITableView provides an excellent mechanism to display big chunks
    of information but also brings us new issues we must handle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: “What is pagination in UITableView, and how would you implement it to efficiently
    load and display large amounts of data while maintaining good performance and
    user experience?”
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When we think of a UITableView, we imagine a contacts list or pizza recipes.
    But there are cases when it either takes time to load the data or the list is
    so big that it creates a memory overload. For example – social media posts, images,
    and data from the backend. From our point of view – an infinite number of items.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The interviewer wants to see how we handle a more complex situation than just
    displaying a closed list of items.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Pagination** in a UITableView is a technique that involves loading and displaying
    data in small batches based on the table view scroll position.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We use pagination when we have a large amount of data, and loading everything
    simultaneously is inefficient. For example, if we have data from our backend or
    large images and videos stored in our persistent store.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: With pagination, we load the data we want to display on the screen (and a little
    bit more), and when the user keeps scrolling, we load “another page” of data.
    This technique of loading data on demand is much faster for initial loading, doesn’t
    create memory overload, and is much more efficient overall.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'However, pagination creates some other challenges we need to tackle, which
    are detailed here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Decide the page loading trigger**: To perform the additional loading operation,
    we need to decide the loading trigger. For example, load more data when the user
    reaches the last visible row or a scrolling offset. Also, we need to ensure we
    are not sending multiple requests simultaneously since the trigger might be happening
    multiple times during that scroll.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Showing a loading indicator**: It is important to provide the user an indication
    there’s more data to view and is currently being loaded. It is common practice
    to show the indication in the last row at the bottom of the list.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load data in the background**: To provide smooth scrolling without blocking
    the UI and creating lagging, we should load the data in a background thread using
    async functions, GCD, or **NSOperation**.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle the “no more data” use case**: That may sound like a weird issue,
    but developers sometimes forget to handle it. When the user scrolls to the last
    item on the list, the trigger for loading more is activated. If the request returns
    empty, the trigger might be activated again because our list meets the trigger
    condition. In this case, the list will enter an infinite loop of trying to fetch
    data without a result. The solution might be to use some temporary flag to avoid
    ongoing fetching.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination is a technique that has pros and cons and should be considered carefully.
    It involves both the backend and client and can provide high performance and good
    user experience but requires us to deal with more complex fetching patterns.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: “What are the different approaches for adjusting cell size in a UITableView,
    and how do you determine the optimal size for cells based on the content they
    will display?”
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Cell size in UITableView was always an issue for iOS developers, mainly when
    the need for accessibility and dynamic font size evolved over the years.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: This question tests our knowledge of UITableView delegate, our ability to use
    Auto Layout with cells, and the tradeoffs we need to make between performance
    and simplicity.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to adjust a cell size:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**Set a custom height for each row**: Implement the **tableView(_:heightForRowAt:)**
    delegate method that returns a different height for each row. In this way, we
    need to calculate the size of each row ourselves. It can be a constant size or
    according to the cell content. Calculating the cell size ourselves can be inaccurate
    if not done right, but it can be faster and more efficient in terms of performance
    when dealing with large datasets. Here’s an example of such an implementation:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code example, we pull the cell data according to its row index and calculate
    the size based on the UITableView size. We can see how error-prone this code snippet
    is, as it needs to be very accurate. But – since we are not using the Auto Layout
    system, it is much faster.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Using self-size cells**: The other option is to use self-size cells. In self-size
    cells, the cell’s height is set automatically by its content, using Auto Layout
    constraints. Some things to notice here are as follows:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must ensure a *continuous sequence of constraints* from top to bottom for
    the cell to get a valid intrinsic content size.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to ensure that the UITableView **rowHeight** property is set to **automaticDimension**.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We said that self-size cells are less efficient in terms of performance. To
    “help” UITableView measure its size, we can use the **estimatedRowHeight** property
    or implement the corresponding **tableView(_:estimatedHeightForRow:)** delegate
    method to provide a row height estimation until the cell is shown on the screen.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The self-size cells should be good enough for most cases, and it needs to be
    our go-to approach unless we encounter performance issues that will require us
    to set custom heights for cells.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: UITableView is a central topic in iOS development and interviews. The coding
    or the home assessment will probably include UITableView as a primary component.
    Make sure there are no mistakes with this control!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Performing navigation well
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigation is a critical component in UIKit and iOS development. Navigation
    allows us to move the user from one UIViewController to another intuitively and
    simply.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of navigating the user to another screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Present a modal view controller**: If we need to present a screen with a
    task to complete or to make a decision, a view controller can present another
    view controller on top of it.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push another view controller**: If we want to navigate the user down the
    app hierarchy to the next stage, we can push a new view controller to the stack.
    This technique requires a UINavigationController to handle the push and pop operations
    and provide a navigation bar to ease the transitions.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interviewers do not generally ask questions about the push and present, as these
    actions are fairly simple to understand and implement. Most questions and challenges
    are related to transitions, navigation bars, life cycle methods, and design patterns.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: “What is the purpose of the navigationItem property in a view controller, and
    how can you use it to customize the behavior and appearance of a navigation bar
    in iOS development?”
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The `navigationItem` property is just that, a property. Why on earth is there
    a question about a specific property?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s because `navigationItem` holds an entire concept behind it. This
    question tests our ability to understand how the navigation controller works and
    the design concept of empowering view controllers to impact the navigation bar’s
    appearance, despite it being a component of the navigation controller.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the way `navigationItem` and view controllers work is an interesting
    design pattern that can be used in other cases and is worth learning.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Every UIViewController has a property named `navigationItem`. That property
    contains several properties and methods used to customize the navigation bar’s
    behavior with data associated with the view controller itself.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: For example, `navigationItem` contains the `title` property, which is used to
    set the *current title* value displayed in the navigation bar.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Other important items of information that can be set in `navigationItem` are
    the *left and right buttons*. Let’s see an example of how the view controller
    modifies the navigation bar using the `navigationItem` property:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our code example, the `navigationItem` property contains a title and a right
    bar button with the `"Button"` title. When the user navigates from that screen,
    the navigation controller will get a new `navigationItem` property from the next
    controller and update its navigation bar properties.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: It’s a technique that empowers the navigation controller to update its navigation
    bar based on the context of the visible view controller. Thinking further, we
    can use this technique in other cases as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: “What are some of the preset options for presenting a UIViewController in iOS,
    and why is it important to understand these options?”
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Presenting a view controller with another view controller is a familiar and
    straightforward task iOS developers do all the time.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: However, there are several ways of presenting a view controller. Each one of
    the options is suitable for a different use case and can influence the presenter’s
    view controller life cycle events.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Our job is to explain the different options to the product team and select the
    one that fits our use case.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: There are several preset options available to us. Each one influences the look
    and feel of the presented view controller.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s name some of them:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Fullscreen**: The presented view controller takes up the entire screen.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PageSheet**: The presented view controller doesn’t fill the whole screen,
    and the screen can be pulled down using a simple swipe gesture.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**overCurrentContext**: The view controller is presented and hides the current
    view controller context.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, the different types of presentations need to be suitable for the
    user experience we want to provide to our users. But we also must consider the
    influence of these types on the different life cycle events being fired.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: For example – if we use `viewWillDisappear` and `viewDidDisappear` of the presenting
    view controller *are not being called*. In Page Sheet, we assume the underlying
    view controller is still visible. Therefore, some life cycle events related to
    appearance are also not being called.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we must change how we present the modal view controllers or communicate
    any changes or updates using a delegate pattern or Combine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The rule is simple – we need to adjust the preset option to the user experience
    we want to provide to our users. Do we hide the underlying screen? That’s a good
    starting question.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: “How would you design a navigation system for an iOS app using the coordinator
    pattern, where view controllers don’t decide where to go next, and a coordinator
    object is responsible for managing the navigation flow?”
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: That’s an advanced question about navigation in iOS apps, and it’s not related
    directly to how to technically implement UINavigationController or present a view
    controller modally.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: This question deals with the separation of concerns principle and design patterns
    we can use in our project to provide more flexibility and modularity.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: That’s one of the questions that doesn’t come with a school-ready answer, and
    you can think about your answer during your interview and discuss it with your
    interviewer. More important is to develop a set of principles and ideas for how
    to nail this challenge.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: A **coordinator pattern** is a popular design pattern that separates the navigation
    logic from the UI.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s discuss how to approach this question and decide on the basic principles
    we want to keep:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The view controller (or its view model, for that matter) *doesn’t decide where
    to navigate* but only sends touch events
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We keep the navigation *logic in another class* called **Coordinator**
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create one **Coordinator** for each view controller or a **Coordinator**
    for a single flow
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Coordinator** has a reference to the navigation controller and *can push
    or pop view* controllers as needed
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Coordinator** needs to *observe events* that happen in the currently displayed
    view controller
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these assumptions, we can imagine the following pattern (*Figure 7**.4*):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A coordinator pattern (suggestion)](img/Figure_7.4_B18653.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – A coordinator pattern (suggestion)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Notice this is just a suggestion, as this pattern is not set in stone.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some modifications we can suggest according to different project’s
    needs:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: If the project becomes more prominent, we can have *several coordinators* and
    sometimes even a hierarchy of coordinators.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can decide that the coordinator *observes state change* in the view model.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also don’t have to use observers for navigating but provide the view controller
    a *reference to the coordinator*. The view controller can send the coordinator
    what happened, and the coordinator can decide what to do next.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can play with the pattern if we keep the basic design principles and explain
    what we do well.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Empowering user experience with animations
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike what many think, animations in iOS are not for “fun”- they play a significant
    role in providing our app with a sleek and smooth experience. As a result, they
    are part of our developer’s tools set.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Animation in iOS relies on a framework called **Core Animation**, which is one
    of UIKit's dependencies. So, even though this chapter discusses UIKit, we can
    find Core Animation in many classes and methods in UIKit.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Going over the core concepts of animation in UIKit
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what do we need to know about animations when practicing for an interview?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We need to know several classes, terms, methods, and techniques. Let’s go over
    them before we move on to an advanced interview question.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Performing UIView animations
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UIView animations are probably the simplest animations we have in UIKit. In
    a UIView animation, we provide a closure with our final state, and UIKit runs
    the animation automatically. Let’s see a code example that takes a view and fades
    it out by changing its `alpha` value:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We see a simple code that receives a duration and a closure and animates the
    changes inside the closure, in this case, changing the `myView` alpha property
    to `0.0`. Notice that Core Animation doesn’t animate all UIView properties. Here
    is the list of UIView animatable properties: `frame`, `bounds`, `center`, `transform`,
    `alpha`, `backgroundColor`, and `tintcolor`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Animating Auto Layout constraints changes
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to understand how to animate constraints changes because it is not
    as straightforward as the other properties we modify. Constraints are part of
    the Auto Layout, and UIKit performs Auto Layout changes every run loop (every
    16.67 milliseconds). This means we need to “force” Auto Layout to perform the
    changes inside the animation closure by calling the `layoutIfNeeded` method. Here’s
    an example of a constraints change of a view:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that it’s not enough to create or modify the constraint within the
    animation closure. We also need to “force” the changes to happen on time; therefore,
    we call the `layoutIfNeeded` method.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Playing with timing and easing
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can adjust the animations to create what we want the user to perceive using
    timing and easing. Timing means different duration and delays, so we can have
    a longer or shorter animation. `springWithDamping` and `initialSpringVelocity`
    that can help us achieve even more customized animation easing. Let’s see an example
    of that:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We scale the `myView` size by modifying its `transform` property and doing
    that animatedly. We can also see that we pass these two important parameters:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**usingSpringWithDamping**: This controls how much the spring effect is damped,
    with higher values resulting in less oscillation and a quick settling time'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**initialSpringVelocity**: This controls the initial velocity of the animation,
    with higher values resulting in a faster start and a more substantial effect'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to play with these values to achieve the desired result.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Building keyframe animations
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more complex animations, we can use keyframe animation. Keyframe animation
    allows us to create animations in stages or sequences. We can define the different
    stages and provide a relative duration and start time for each one of them. Here’s
    an example of a keyframe animation:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How do we read this code block? It’s easy. The total animation duration is 3
    seconds and is split into two sequences.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The first sequence starts at the beginning (relative time 0) and takes half
    the total time (relative duration 0.5, meaning 1.5 seconds).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The second sequence starts in the middle of the total animation time (relative
    time 0.5, meaning 1.5 seconds) and takes half of the animation time (relative
    duration 0.5, implying 1.5 seconds).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The sequences don’t have to sync with each other, and it’s up to us to sync
    them if we need.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Performing transitions between screens
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UIKit allows us to perform transitions between screens, or to be precise, between
    UIViewControllers. We can pick one of the built-in transitions or even create
    our own transition.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we present a UIViewController with a dissolve animation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: UIKit provides a short list of built-in animations that, in many cases, are
    not sufficient. Therefore, we have the option to create a custom animation and
    even an interactive animation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the context of an interview – just like many other topics, it is important
    to understand how the custom transition works. We are not required to remember
    every API’s detail, but we need to know what we are capable of, what possibilities
    it opens up, and how to build it so it can be reused across our project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating CALayers
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We touched on CALayer earlier when we discussed UIView but haven’t discussed
    its importance for us as iOS developers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: We already know that iOS graphics is built with layers – UIViews (backed up
    with CALayers) and underneath we have Core Animation, which is built upon **Metal**.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: CALayers provides hardware-accelerated rendering components, which lets us manipulate
    graphics and perform sophisticated animations and image processing. We can also
    blend layers and add visual effects. Overall, CALayers help us to go down the
    graphics architecture and get closer to the hardware and the GPU to achieve more
    power and efficiency.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the core concepts of animation techniques can help us achieve
    a better user experience. As iOS developers, we are expected to be familiar with
    the essential tools and classes to provide the desired animations our product
    team requires.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s review an interesting interview question related to animation in UIKit.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: “How can you create custom transitions between UIViewControllers in an iOS app?”
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We discussed custom transitions a little earlier when we went over the animation
    core concepts, and this question tests our experience with the custom transition
    API. The Custom UIViewController transition API requires us to handle reusability,
    a deep understanding of how animations work, how view controllers work with each
    other, how to perform advanced techniques such as snapshotting, and how to implement
    a relatively complex UIKit API.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Custom animation is considered an advanced topic, and we should at least understand
    the basics of it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: To create a custom transition between UIViewControllers, we must implement the
    `UIViewControllerAnimatedTransitioning` protocol (any object can conform to that
    protocol).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'This protocol has two functions: `animateTransition(using:)` and `transitionDuration(using:)`.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In `animateTransition(using:)`, we handle the view hierarchy, constraints changes,
    and animations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: In `transitioDuration(using:)`, we return the duration in `TimeInterval`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '`UIViewControllerAnimatedTransitioning` defines a transition, present or dismiss.
    To determine precisely what happens in each scenario, we must implement `UIViewControllerTransitionDelegate`
    to specify which object handles each use case.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Once we do that, to use our custom transition, we need to set the UIViewController
    `modalPresentationStyle` property to custom and the `transitionDelegate` property
    to the object that conforms to `UIViewControllerAnimatedTransitioning`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have two different protocols to implement and things get a little
    complex here, let’s look at *Figure 7**.5* to understand how everything is related
    to each other:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Custom UIViewController transition delegate](img/Figure_7.5_B18653.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Custom UIViewController transition delegate
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the leading role of `UIViewControllerTransitionDelegate` is
    to decide which object will handle the animation when presenting or dismissing
    the presented view controller. It’s worth saying that all three components can
    be the same object, and this is where the reusability concept comes in. If we
    want to be able to reuse our transitions across the project, we need to do two
    things:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Separate the *different components* of different objects.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When animating, reduce coupling between the presented/presenting view controller
    and the transitioning object *using protocols* and not explicitly the original
    view controller class. For example, suppose we are animating a view from one controller
    to another. In that case, we shouldn’t use a direct reference to the view but
    rather a protocol with a **getView()** method so that we can reuse that with another
    view controller.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, transitioning between view controllers is a task that involves
    different techniques expected from a senior iOS developer. However, the concept
    needs to be done at least once to understand it fully.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed many crucial topics related to UIKit, such as
    UIView, UIViewController, UITableView, navigation, and animations. UIKit has a
    massive presence in iOS developers’ day-to-day work and significantly influences
    the user experience.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了许多与UIKit相关的重要主题，例如UIView、UIViewController、UITableView、导航和动画。UIKit在iOS开发者日常工作中占有巨大比重，并对用户体验产生了重大影响。
- en: But – UIKit is also considered the “old” UI framework. The iOS development world
    is transitioning to a new, more modern era of declarative programming.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 但——UIKit也被认为是“旧”的UI框架。iOS开发界正在向一个新、更现代的声明式编程时代过渡。
- en: Our next chapter will handle just that – SwiftUI and declarative programming.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的章节将专门处理这个问题——SwiftUI和声明式编程。
