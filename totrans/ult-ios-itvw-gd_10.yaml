- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building Great User Experiences with UIKit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UIKit构建出色的用户体验
- en: In [*Chapter 6*](B18653_06.xhtml#_idTextAnchor196), we took a break from coding
    and discussed topics that evolve our code, such as testing, debugging, and more.
    Now, it’s time to go back to what we love to do, and what is more loveable in
    iOS development than building a great UI experience?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18653_06.xhtml#_idTextAnchor196)中，我们暂时放下了编码，讨论了那些使我们的代码演化的主题，如测试、调试等。现在，是时候回到我们热爱的事情上，而在iOS开发中，还有什么比构建一个出色的UI体验更令人喜爱呢？
- en: For most iOS developers, UIKit is considered to be the most critical framework
    right after Foundation, and in iOS interviews, it’s a mandatory topic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数iOS开发者来说，UIKit被认为是继Foundation之后最重要的框架，在iOS面试中，它是一个必考话题。
- en: 'Even though UIKit is a huge framework, this chapter will cover the essential
    topics required for iOS developers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UIKit是一个庞大的框架，但本章将涵盖iOS开发者所需的必要主题：
- en: We will go over the **Auto** **Layout** system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾**自动** **布局**系统
- en: We will discuss the different **UIView** features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论不同的**UIView**功能
- en: We will ensure a deep understanding of **UITableViews**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将确保对**UITableViews**有深入的理解
- en: We will talk about **UIViewController** and its role in our app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论**UIViewController**及其在我们应用中的作用
- en: We will dive into the navigation world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将深入导航的世界
- en: We will learn the basic concepts of animations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习动画的基本概念
- en: As I said – UIKit is an enormous topic, and there are many more, but we are
    focusing on the mandatory interview issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说——UIKit是一个巨大的主题，还有很多其他内容，但我们专注于必须面试的问题。
- en: We will start with what is driving our layout, and that’s the Auto Layout system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从驱动我们布局的东西开始，那就是自动布局系统。
- en: Answering questions about Auto Layout
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答关于自动布局的问题
- en: UIKit is a vast topic, and over the years, it has become even more significant,
    gaining more and more capabilities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: UIKit是一个庞大的主题，多年来，它已经变得更为重要，获得了越来越多的功能。
- en: The engine that drives how things are placed on the screen is what Apple calls
    Auto Layout, which is why I chose to start the UIKit chapter with that topic in
    mind.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动屏幕上元素布局的引擎，苹果称之为自动布局（Auto Layout），这就是为什么我选择以这个主题为起点来开始UIKit章节。
- en: Auto Layout is Apple technology that defines the *relationships between the
    different elements* on the screen and tremendously influences our ability to move
    fast with UI development. We can say that mastering Auto Layout sets us up with
    the ability to provide a great UI in a decent amount of time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自动布局是苹果技术，它定义了屏幕上不同元素之间的*关系*，极大地影响了我们快速进行UI开发的能力。我们可以这样说，掌握自动布局使我们能够在合理的时间内提供出色的UI。
- en: But there is more than just time efficiency – Auto Layout can help us *adapt
    our app to different screen sizes* or even platforms (**iPad** versus **iPhone**).
    It can also help us automatically set the UI direction according to the current
    localization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不仅仅是时间效率——自动布局可以帮助我们*适应不同的屏幕尺寸*或甚至平台（**iPad**与**iPhone**），它还可以帮助我们根据当前的本地化自动设置UI方向。
- en: We’ll go over some of the most common Auto Layout questions now. Isn’t it an
    excellent start for a UIKit chapter?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回顾一些最常见的自动布局问题。这不是UIKit章节的一个极好的开始吗？
- en: “Can you explain what content hugging and compression resistance are in Auto
    Layout and how they are used to control the layout of UI elements?”
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释一下在自动布局中内容吸附和压缩抵抗是什么，以及它们是如何用来控制UI元素布局的吗？”
- en: '*Why is this* *question important?*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要*？'
- en: '**Compression resistance** and **content hugging** are two essential concepts
    in Auto Layout that define views'' behavior when their size and layout change.
    At this stage, the interviewer assumes we already know the basics of Auto Layout
    and wants to see how we handle more complex situations where two different views
    are “fighting” over limited space to satisfy all their constraints.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩抵抗**和**内容吸附**是自动布局中的两个基本概念，它们定义了当视图的大小和布局发生变化时视图的行为。在这个阶段，面试官假设我们已经了解了自动布局的基础知识，并想看看我们如何处理更复杂的情况，即两个不同的视图在有限的区域内“争夺”空间以满足所有约束。'
- en: '*What is* *the answer?*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是* *答案*？'
- en: Compression resistance and content hugging are two of UIView’s properties that
    define the layout behavior when there isn’t enough space to satisfy all the constraints.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩抵抗和内容吸附是UIView的属性，当没有足够的空间来满足所有约束时，它们定义了布局行为。
- en: 'Let’s go over what these terms mean for constraints:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些术语对约束的含义：
- en: '**Content hugging**: When content hugging is set to high priority, the view
    wants to become *as small as possible* with a specific axe'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容紧缩**：当内容紧缩被设置为高优先级时，视图希望沿着特定轴尽可能小。'
- en: '**Compression resistance**: When the compression resistance property is set
    to high, the view wants to become *as big as possible* with a specific axe'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩阻力**：当压缩阻力属性被设置为高时，视图希望沿着特定轴尽可能大。'
- en: 'One great example to demonstrate a possible conflict between two views is a
    UIView (let’s say `UITableViewCell`) with two subviews – a leading label and a
    button (see *Figure 7**.1*):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子来展示两个视图之间可能存在的冲突是一个UIView（比如说`UITableViewCell`）有两个子视图——一个引导标签和一个按钮（见图7.1*）：
- en: '![Figure 7.1 – A view with a label and a button](img/Figure_7.1_B18653.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 带有标签和按钮的视图](img/Figure_7.1_B18653.jpg)'
- en: Figure 7.1 – A view with a label and a button
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 带有标签和按钮的视图
- en: 'Looking at *Figure 7**.1*, we can see a possible use case – both the label
    and button can have a short text, and as a result, their intrinsic content size
    is small. If these two views try to set their width according to their content,
    one will have to “give up” and fill the remaining space. To ensure that the button
    will try to become as small as possible and the label will fill the remaining
    space, we need to set their content hugging and compression resistance accordingly.
    Let’s see how to do that in code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图7.1。1，我们可以看到一个可能的用例——标签和按钮都可以有简短的文字，因此它们的固有内容大小很小。如果这两个视图尝试根据其内容设置宽度，其中一个将不得不“放弃”并填充剩余的空间。为了确保按钮会尝试尽可能小，而标签会填充剩余的空间，我们需要相应地设置它们的内容紧缩和压缩阻力。让我们看看如何在代码中做到这一点：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Calling `setcompressionResistencePriority` for `label` means that when the cell
    is resized horizontally, the auto-layout system will try to maintain the intrinsic
    content size of the label and *prevent it from* *being compressed*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为`label`调用`setCompressionResistancePriority`意味着当单元格水平调整大小时，自动布局系统将尝试保持标签的固有内容大小并*防止其*被压缩。
- en: However, calling `setContentHuggingPrioirty` for button means that when the
    cell is resized horizontally, and there is extra space available, the auto-layout
    system will *try to expand* `button` to fill the available space and prevent it
    from being stretched too much.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为按钮调用`setContentHuggingPriority`意味着当单元格水平调整大小并且有额外空间可用时，自动布局系统将*尝试扩展*`button`以填充可用空间并防止其过度拉伸。
- en: We can set these priorities in the code and Interface Builder quite easily.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码和Interface Builder中非常容易地设置这些优先级。
- en: There are many other examples where this settlement is needed, such as a page
    title’s width that conflicts with its alignment or complex screens with dynamic
    font size.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他例子需要这种解决方案，例如页面标题的宽度与其对齐方式冲突，或者具有动态字体大小的复杂屏幕。
- en: “Can you explain how to use size classes in Interface Builder to adapt layouts
    for different screen sizes and orientations?”
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释一下如何在Interface Builder中使用尺寸类别来适应不同屏幕尺寸和方向的布局吗？”
- en: '*Why is this* *question important?*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: This question is important because it tests our understanding by taking Auto
    Layout and trying to adapt our layout to *different sizes* *and orientations*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题很重要，因为它通过使用自动布局并尝试将我们的布局适应于*不同的大小*和*方向*来测试我们的理解。
- en: Notice I didn’t mention iPad or iPhone – these terms are irrelevant when discussing
    Auto Layout. We must consider our layout fully responsive according to different
    size levels, aka, size classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有提到iPad或iPhone——在讨论自动布局时，这些术语是不相关的。我们必须根据不同的尺寸级别全面考虑我们的布局，也就是所谓的尺寸类别。
- en: '*What is* *the answer?*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: '**Size classes** are a feature that allows us to create one UI for various
    screen sizes. A screen size can be an iPhone or an iPad, but it can also be an
    iPad app being presented on a split screen and therefore needs to change its layout
    to an iPhone app.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**尺寸类别**是一个功能，允许我们为各种屏幕尺寸创建一个UI。屏幕尺寸可以是iPhone或iPad，也可以是正在分割屏幕上展示的iPad应用，因此需要将其布局更改为iPhone应用。'
- en: The classes we have today are **Compact** and **Regular**. Compact usually means
    an iPhone or an iPad app in a split screen, and Regular means an iPad app. As
    mentioned, we shouldn’t think of these classes as iPhone versus iPad. Size classes
    allow us to think responsively regardless of our app’s device.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天有的类是**紧凑型**和**常规型**。紧凑型通常意味着在分割屏幕上的iPhone或iPad应用，而常规型意味着iPad应用。如前所述，我们不应该将这些类别视为iPhone与iPad之间的对比。尺寸类别允许我们无论应用设备如何都能以响应式的方式思考。
- en: To use size classes in Interface Builder, we first need to open the storyboard
    we want to work on. Then, in the bottom right corner of the `w Any h Any` class,
    which means the layout will be the same for all devices and orientations. We can
    select another size class from the control to create a different layout for a
    specific screen size or orientation. For example, we can choose the `w Compact
    h Regular` class to create a layout for iPhones in portrait orientation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Interface Builder 中使用尺寸类别，我们首先需要打开我们想要工作的故事板。然后，在 `w Any h Any` 类的右下角，这意味着布局将适用于所有设备和方向。我们可以从控制面板中选择另一个尺寸类别来为特定屏幕尺寸或方向创建不同的布局。例如，我们可以选择
    `w Compact h Regular` 类来为竖屏方向的 iPhone 创建布局。
- en: One good use case is a login screen, where on a small screen, we want the username
    and password text fields to be laid out vertically, and on a bigger screen, we
    may want them to be laid out horizontally. The layout of the text fields according
    to size can be managed using size classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的用例是登录屏幕，在小型屏幕上，我们希望用户名和密码文本字段垂直布局，而在大屏幕上，我们可能希望它们水平布局。可以根据尺寸管理文本字段的布局。
- en: More examples of different values in different size classes are fonts, Auto
    Layout, and constant size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不同尺寸类别中的不同值示例包括字体、Auto Layout 和固定大小。
- en: “What is the purpose of the safe area in Auto Layout, and how do you ensure
    that your views are properly positioned within the safe area?”
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “Auto Layout 中的安全区域有什么作用？你如何确保你的视图在安全区域内正确定位？”
- en: '*Why is this* *question important?*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个* *问题为什么重要？*'
- en: The **safe area** is an important topic when working with layouts across different
    devices. Every iOS developer must know how to handle the safe area, which contains
    the status bar, sensors, and round corners of modern iPhones. This question tests
    our experience working with different devices and creating a layout agnostic to
    the device type we work on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当在不同设备上处理布局时，**安全区域**是一个重要的话题。每个 iOS 开发者都必须知道如何处理安全区域，它包含状态栏、传感器和现代 iPhone 的圆角。这个问题测试了我们与不同设备工作的经验，以及创建与设备类型无关的布局的能力。
- en: '*What is* *the answer?*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The safe area is a feature in Auto Layout that provides a **layout guide** that
    helps us position elements above and below areas on the screen reserved for sensors,
    round corners, and generally areas the user isn’t supposed to touch.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安全区域是 Auto Layout 中的一个功能，它提供了一个 **布局指南**，帮助我们定位屏幕上为传感器、圆角以及用户不应触摸的一般区域预留的区域上方和下方。
- en: However, we can position non-interactive views in the safe area zone, such as
    videos or backgrounds. Still, we must consider that iOS elements, sensors, and
    screen round corners may partially cover these views.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以在安全区域区域内定位非交互视图，例如视频或背景。尽管如此，我们必须考虑到 iOS 元素、传感器和屏幕圆角可能会部分覆盖这些视图。
- en: 'To ensure we position a view outside the safe area, we can use a property named
    `safeAreaLayoutGuide`. Here’s an example of positioning a label below the top
    safe area using `safeAreaLayoutGuide`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们将视图定位在安全区域之外，我们可以使用一个名为 `safeAreaLayoutGuide` 的属性。以下是一个使用 `safeAreaLayoutGuide`
    将标签定位在顶部安全区域下方的示例：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that `view`, the UIViewController main view, has a property named
    `safeAreaLayoutGuide`, and that guide represents the end of the safe area zone.
    This guide is equivalent to the screen edges in older devices, but in modern devices,
    it means the interactive part of the display.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `view`，即 UIViewController 的主视图，有一个名为 `safeAreaLayoutGuide` 的属性，而这个指南代表安全区域区的末端。这个指南相当于旧设备上的屏幕边缘，但在现代设备上，它意味着显示器的交互部分。
- en: It is best practice to check your layout with different devices to ensure it
    is usable in all displays.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用不同的设备检查你的布局，以确保它在所有显示设备上可用。
- en: Auto Layout is a fundamental topic in UIKit and iOS development. There’s no
    way to get into UI development without working closely with Auto Layout, and the
    UI is an important topic in iOS. If you started your iOS development career with
    SwiftUI, ensure you are familiar with Auto Layout, at least for the basic terms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Auto Layout 是 UIKit 和 iOS 开发中的基本主题。没有与 Auto Layout 亲密合作就无法进入 UI 开发，UI 是 iOS
    中的一个重要主题。如果你以 SwiftUI 开始你的 iOS 开发生涯，确保你熟悉 Auto Layout，至少是基本术语。
- en: Solving UIView questions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 UIView 问题
- en: UIView is the basic building block for user interaction in iOS UIKit. At its
    roots, it represents a rectangle on the screen that can display graphics and handle
    user interactions and animations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: UIView 是 iOS UIKit 中用户交互的基本构建块。在本质上，它代表屏幕上的一个矩形，可以显示图形并处理用户交互和动画。
- en: Before we go over any interview questions, it is crucial to understand the roles
    of UIView in UIKit, and its relationship with CALayer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论任何面试问题之前，理解UIView在UIKit中的作用及其与CALayer的关系至关重要。
- en: 'Let’s go over the main features of UIView:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下UIView的主要功能：
- en: '**Manage subviews**: UIView can contain additional UIViews called **subviews**,
    which can include their own subviews. This capability allows us to build complex
    UIs and reusable components. UIView is also responsible for handling the layout
    of its subviews using the Auto Layout system we discussed in the previous chapter.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理子视图**：UIView可以包含额外的UIView，称为**子视图**，这些子视图可以包含它们自己的子视图。这种能力使我们能够构建复杂的UI和可重用组件。UIView还负责使用我们在上一章中讨论的自动布局系统处理其子视图的布局。'
- en: '**Respond to user interaction**: Another important role UIView has is to respond
    to user interaction, which is not a minor topic. Preparing for the interview involves
    learning about the **responder chain**, which handles user interactions with UIView’s
    hierarchy.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应用户交互**：UIView另一个重要的角色是响应用户交互，这并非一个微不足道的话题。准备面试涉及学习**响应者链**，它处理与UIView层次结构的用户交互。'
- en: '**Draw graphics**: UIView can draw graphics: lines, shapes, images, and texts.
    UIView does that using another framework called **Core Graphics**, which is responsible
    for drawing basic graphics using the **CPU**.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘制图形**：UIView可以绘制图形：线条、形状、图像和文本。UIView使用另一个名为**Core Graphics**的框架来完成这项工作，该框架负责使用**CPU**绘制基本图形。'
- en: So, what about CALayer? Well, we already know the UIView can draw using Core
    Graphics, but that’s not an efficient way. Therefore, it has a CALayer. The CALayer
    is responsible for drawing the content inside UIView, which uses **Core Animation**
    and the device’s **GPU**. Each UIView has a primary CALayer that can have sublayers
    of its own.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CALayer呢？好吧，我们已经知道UIView可以使用Core Graphics进行绘制，但这并不是一个高效的方法。因此，它有一个CALayer。CALayer负责绘制UIView内部的内容，它使用**Core
    Animation**和设备的**GPU**。每个UIView都有一个主要的CALayer，它可以有自己的子层。
- en: The CALayer is responsible for the content drawing, and UIView is accountable
    for the layout and user interaction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CALayer负责内容绘制，而UIView负责布局和用户交互。
- en: “Can you explain how the responder chain works in iOS?”
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释一下在iOS中响应者链是如何工作的吗？”
- en: '*Why is this* *question important?*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: The responder chain is a key concept in iOS UI development. The idea discusses
    the management of user interaction in multi-layer screens.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 响应者链是iOS UI开发中的一个关键概念。这个概念讨论了多层屏幕中用户交互的管理。
- en: The question is vital because user interaction is a critical topic in UI development,
    and the responder chain is not a simple concept to understand at first glance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题至关重要，因为用户交互是UI开发中的一个关键主题，响应者链并不是一个一开始就能简单理解的概念。
- en: '*What is* *the answer?*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The term “responder chain” refers to a mechanism in which the user touches the
    screen, and each UIView passes the touch forward to its corresponding subviews
    until one of the views responds.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “响应者链”这个术语指的是用户触摸屏幕时的一种机制，每个UIView将触摸传递给其对应的子视图，直到其中一个视图做出响应。
- en: 'Let us explore this in *Figure 7**.2*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在*图7.2*中探索这个问题：
- en: '![Figure 7.2 – Example of a responder chain in iOS](img/Figure_7.2_B18653.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – iOS中响应者链的示例](img/Figure_7.2_B18653.jpg)'
- en: Figure 7.2 – Example of a responder chain in iOS
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – iOS中响应者链的示例
- en: As shown in *Figure 7**.2*, the touch starts with `UIApplication` and goes down
    until it reaches the first view that responds to the touch, in this case, `UITextField`.
    The respond chain “asks” each of the views if it is the first responder by calling
    the `becomeFirstResponder()` function. That’s why calling directly to `become
    FirstResponder()` on a text field brings up the keyboard and makes the text field
    the currently active input field.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.2*所示，触摸从`UIApplication`开始，向下传递，直到它达到第一个响应触摸的视图，在这种情况下，是`UITextField`。响应链“询问”每个视图是否是第一个响应者，通过调用`becomeFirstResponder()`函数。这就是为什么直接在文本字段上调用`becomeFirstResponder()`会弹出键盘，并使文本字段成为当前活动输入字段的原因。
- en: In short, a responder chain is our ability to control which view catches the
    user interaction while views are placed on top of each other. There are more cases
    where this comes in handy, such as transparent views or scrolls.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，响应者链是我们控制哪个视图在视图重叠时捕获用户交互的能力。还有更多情况下这很有用，比如透明视图或滚动视图。
- en: “How can you respond to device orientation changes in UIView?”
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你如何在UIView中响应设备方向变化？”
- en: '*Why is this* *question important?*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: In many apps, responding to device orientation is crucial because it provides
    the user with an optional layout for the app just by rotating the device.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，响应设备方向至关重要，因为它通过旋转设备为用户提供了一个可选的布局。
- en: But that’s not the real reason why it’s essential to understand that question
    correctly. We should know how to structure our UI to support different screen
    proportions and adjust the layout and the controls according to the new orientation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是正确理解这个问题的真正原因。我们应该知道如何构建我们的UI以支持不同的屏幕比例，并根据新的方向调整布局和控制。
- en: The question tests our flexibility and readiness for a radical layout change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题测试了我们的灵活性和对激进布局变化的准备情况。
- en: '*What is* *the answer?*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'Handling device orientation changes requires tackling that problem from different
    angles. Let’s list some of the things we can do:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 处理设备方向变化需要从不同的角度来解决问题。让我们列出我们可以做的事情：
- en: '**Verify our Auto Layout constraints**: Auto Layout is a great technique to
    ensure our layout will stay usable after changing the screen bounds. We can define
    constraint relationships and limit view size or margins to ensure our layout is
    updated correctly with changing orientation.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证我们的Auto Layout约束**：Auto Layout是一种确保在更改屏幕边界后布局仍然可用的优秀技术。我们可以定义约束关系并限制视图大小或边距，以确保布局能够随着方向的变化正确更新。'
- en: '**Animate changes**: If possible, we should animate changes to our views to
    provide our users with a seamless and smooth change experience.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画变化**：如果可能的话，我们应该对视图的变化进行动画处理，以向用户提供无缝且平滑的变化体验。'
- en: '**Override the willTransition(to:with) method**: The**willTransition(to:with)**
    method gets called just before the view transitions to a new size or a trait collection.
    That’s where we can modify the view appearance in addition to what Auto Layout
    already changed. For example, we can show or hide subviews, change texts, or modify
    constraint values.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重写willTransition(to:with)方法**：在视图过渡到新大小或特性集合之前，**willTransition(to:with)**方法会被调用。这就是我们可以在Auto
    Layout已经更改的基础上修改视图外观的地方。例如，我们可以显示或隐藏子视图，更改文本或修改约束值。'
- en: '**Update layout**: Position or rearrange views, and in general, make changes
    to our layout to fit the new orientation. That, of course, is according to our
    design and product requirements.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新布局**：定位或重新排列视图，并在一般情况下，根据我们的设计和产品要求对布局进行更改。当然，这是根据我们的设计和产品要求来进行的。'
- en: Not all app makers support landscape and portrait states in their products,
    as this is more a design decision than an engineering one. But building our views
    with orientation change in mind is a good practice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有应用程序开发者都支持他们的产品中的横屏和竖屏状态，因为这更多的是一个设计决策而不是一个工程决策。但考虑到方向变化来构建我们的视图是一个好的实践。
- en: “Why does UIView not have a ‘viewDidAppear’ method as UIViewController does?”
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “为什么UIView没有像UIViewController那样的‘viewDidAppear’方法？”
- en: '*Why is this* *question important?*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: We haven’t discussed view controllers just yet, but that’s a question many candidates
    struggle to answer. This question aims to see whether we understand the relationship
    UIViews have with their view controller. Many junior developers ask themselves
    that question because understanding the UIView role isn’t intuitive. More experienced
    developers should answer that question more easily.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论视图控制器，但这是一个许多候选人难以回答的问题。这个问题旨在了解我们是否理解UIView与其视图控制器之间的关系。许多初级开发者会问自己这个问题，因为理解UIView的角色并不直观。更有经验的开发者应该更容易回答这个问题。
- en: '*What is* *the answer?*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: UIView doesn’t have a `viewDidAppear` method like **UIViewController** because
    the primary role of UIView is to be a visual component and not handle life cycle
    events.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: UIView没有像**UIViewController**那样的`viewDidAppear`方法，因为UIView的主要角色是作为一个视觉组件，而不是处理生命周期事件。
- en: When we look back to the `viewDidLoad`, `viewWillAppear`, and `viewDidAppear`.
    If we need to perform tasks in the life cycle events such as performing network
    requests, loading data, or setting a state, we should do it in the view controller
    and update the view accordingly. Doing any of these is not part of the UIView’s
    role.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾`viewDidLoad`、`viewWillAppear`和`viewDidAppear`时。如果我们需要在生命周期事件中执行任务，例如执行网络请求、加载数据或设置状态，我们应该在视图控制器中执行这些操作并相应地更新视图。执行这些操作中的任何一项都不是UIView的角色。
- en: MVC will be discussed in detail in [*Chapter 11*](B18653_11.xhtml#_idTextAnchor329).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: MVC将在[*第11章*](B18653_11.xhtml#_idTextAnchor329)中详细讨论。
- en: “Can you explain the difference between setNeedsLayout, layoutSubviews, and
    layoutIfNeeded in UIView? When would you use each of these methods, and how do
    they impact the layout process?”
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释一下setNeedsLayout、layoutSubviews和layoutIfNeeded在UIView中的区别吗？你会在什么情况下使用这些方法，它们如何影响布局过程？”
- en: '*Why is this* *question important?*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: These three UIView methods (`setNeedsLayout`, `layoutSubviews`, and `layoutIfNeeded`)
    tell the story of UIView rendering cycle optimization. This is not a go/no-go
    question but more like a bonus question. I have interviewed hundreds of iOS developers
    in my career, and most of them can’t fully answer this question as they don’t
    understand how the layout system works precisely.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个UIView方法（`setNeedsLayout`、`layoutSubviews`和`layoutIfNeeded`）讲述了UIView渲染周期优化的故事。这不仅仅是一个是/否的问题，更像是一个加分问题。在我的职业生涯中，我面试了数百名iOS开发者，其中大多数人无法完全回答这个问题，因为他们并不完全理解布局系统是如何工作的。
- en: Answering this question correctly will benefit us in an interview situation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正确回答这个问题将有助于我们在面试场合。
- en: '*What is* *the answer?*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是* *答案？*'
- en: First, let’s understand how the layout system works – UIView refreshes the layout
    of its subviews once every screen refresh rate (in 60Hz, it’s once every 16.67
    milliseconds), only if it needs to. What does that mean? For example, if the view
    changes its frame, it must refresh the layout of its subviews. The reason it happens
    every 16.67 milliseconds is because of efficiency. If we change the UIView’s frame
    multiple times within these 16.67 milliseconds, it will refresh the layout of
    its subviews only once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解布局系统是如何工作的——UIView在每次屏幕刷新率时刷新其子视图的布局（在60Hz中，它每16.67毫秒刷新一次），只有当它需要时。这意味着什么？例如，如果视图改变了它的frame，它必须刷新其子视图的布局。它每16.67毫秒发生一次的原因是效率。如果我们在这16.67毫秒内多次更改UIView的frame，它将只刷新一次其子视图的布局。
- en: Now, what does it mean “refresh the layout of its subviews”? It means that the
    system runs the `layoutSubiews()` method, which we can override and perform additional
    changes if we like.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，"刷新其子视图的布局"是什么意思？这意味着系统会运行`layoutSubviews()`方法，我们可以覆盖它并执行我们喜欢的额外更改。
- en: We understand now that changing the UIView frame marks the view as “dirty,”
    so in the next run loop, it will run `layoutSubviews()`. But we don’t have to
    change its frame or one of the related constraints to mark the view as dirty.
    We can just call `setNeedsLayout()` to ensure that the view will update its subviews
    in the next run loop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，改变UIView的frame会将视图标记为“脏”，因此在下一次运行循环中，它将运行`layoutSubviews()`。但我们不必改变它的frame或相关的约束来标记视图为脏。我们只需调用`setNeedsLayout()`来确保视图将在下一个运行循环中更新其子视图。
- en: Sometimes, we need the view to run `layoutSubviews` immediately without waiting
    for the next run loop. One good example is animations and constraint changes.
    In this case, we can call `layoutIfNeeded()`, which will call `layoutSubviews()`
    only if UIView is marked as dirty.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要视图立即运行`layoutSubviews`，而不必等待下一个运行循环。一个很好的例子是动画和约束变化。在这种情况下，我们可以调用`layoutIfNeeded()`，这只会调用`layoutSubviews()`，如果UIView被标记为脏。
- en: It is now clear why we never call `layoutSubviews()` directly – the system does
    that for us much more efficiently, and it is better to stick with the natural
    process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很清楚为什么我们从不直接调用`layoutSubviews()`——系统会为我们更高效地完成这项工作，并且坚持自然过程会更好。
- en: As I said at the beginning of this section – UIView is our UI building block
    and one of the fundamental parts of MVC and **MVVM**. Understanding how it works
    beyond adding and removing subviews is essential to us as iOS developers and can
    help us influence our app performance and experience. Additionally, some of the
    discussed questions in this section will be asked in an interview.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头所说——UIView是我们的UI构建块，也是MVC和**MVVM**的基本组成部分之一。理解它如何工作，而不仅仅是添加和删除子视图，对我们iOS开发者来说至关重要，并且可以帮助我们影响我们的应用性能和体验。此外，本节中讨论的一些问题将在面试中被问到。
- en: 'Now let’s move on to another important side of the MVC pattern: UIViewController.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向MVC模式另一个重要的方面：UIViewController。
- en: “What is the difference between the frame and bounds properties?”
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “frame和bounds属性之间的区别是什么？”
- en: '*Why is this* *question important?*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Even though `bounds` and `frame` are quite similar, the difference between them
    is crucial to understand how the layout system works. The difference is important,
    especially when dealing with animations, positioning, and transitions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`bounds`和`frame`非常相似，但它们之间的区别对于理解布局系统的工作方式至关重要。这种区别在处理动画、定位和转换时尤为重要。
- en: '*What is* *the answer?*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: In short, the `frame` property represents the position and size of a UIView
    relative to its superview’s coordinate system, while the `bounds` property represents
    the position and size of a UIView relative to its own coordinate system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`frame`属性表示UIView相对于其父视图坐标系统的位置和尺寸，而`bounds`属性表示UIView相对于其自身坐标系统的位置和尺寸。
- en: 'Here’s an example of the `bounds` and `frame` properties for the same view,
    positioned in *x*:50 and *y*:100:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个关于相同视图的`bounds`和`frame`属性的示例，该视图位于*x*:50和*y*:100：
- en: 'Frame:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧大小：
- en: 'Origin: (*x*: 50, *y*: 100)'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '原点：(*x*: 50，*y*: 100)'
- en: 'Size: (width: 200, height: 150)'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尺寸：(宽度：200，高度：150)
- en: 'Bounds:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界：
- en: 'Origin: (*x*: 0, *y*: 0)'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '原点：(*x*: 0，*y*: 0)'
- en: 'Size: (width: 200, height: 150)'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尺寸：(宽度：200，高度：150)
- en: We can see that the origin is different, but the size is the same. That’s because
    the origin in the frame is relative to its superview.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到原点不同，但尺寸相同。这是因为帧中的原点是相对于其父视图的。
- en: However, it’s important to note that there are cases where the frame and bounds
    sizes can differ. Unlike the `bounds` property, which represents the view’s size
    in its own coordinate system, the frame size is calculated and can change during
    animations. Therefore, it is possible to observe different size values between
    the `frame` and `bounds` properties. While the bounds size property remains constant,
    the frame size property can reflect the current size values during animations
    or transformations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，在某些情况下，帧和边界的大小可能不同。与表示视图在其自身坐标系统中的尺寸的`bounds`属性不同，帧大小是在动画过程中计算和可能改变的。因此，在`frame`和`bounds`属性之间可能会观察到不同的尺寸值。虽然边界尺寸属性保持不变，但帧尺寸属性可以在动画或转换期间反映当前尺寸值。
- en: Understanding everything about UIViewController
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解关于UIControler的一切
- en: UIViewController is a core class in iOS development and behaves as a building
    block for most iOS apps that use UIKit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS开发中，UIControler是一个核心类，它作为使用UIKit的大多数iOS应用的构建块。
- en: 'UIViewController has multiple roles in iOS development:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS开发中，UIViewController扮演着多个角色：
- en: '**It is the C in the MVC pattern**: If the UIView is the V (View) and our model
    is the M, the UIViewController is the one that coordinates between the presentation
    layer and the business layer. That role affects many of the features UIViewController
    has, such as life cycle events and memory management functions.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它是MVC模式中的C**：如果UIView是V（视图）而我们的模型是M，那么UIViewController就是协调表示层和业务层之间的那个。这个角色影响了许多与UIViewController相关的功能，例如生命周期事件和内存管理功能。'
- en: '**Handling life cycle events**: We explained this role of UIViewController
    in the previous section. UIViewController has another function: to manage the
    various life cycle events on the screen. By creating subclasses of UIViewController,
    we can take advantage of its different methods to handle all stages of a screen’s
    life cycle.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理生命周期事件**：我们在上一节中解释了UIViewController的这个角色。UIViewController还有一个功能：管理屏幕上的各种生命周期事件。通过创建UIViewController的子类，我们可以利用其不同的方法来处理屏幕生命周期的所有阶段。'
- en: '**Leading player in the navigation system**: We can present UIViewController
    above another UIViewController or push and pop it into and from a navigation stack.
    As such, UIViewController plays a significant role in iOS app navigation by representing
    a “screen” in our project (note – a UIViewController isn’t equivalent to a “screen,”
    but a screen always has a root view controller).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航系统中的领先者**：我们可以将UIViewController显示在另一个UIViewController之上，或者将其推入和从导航堆栈中弹出。因此，通过代表项目中的“屏幕”（注意——一个UIViewController并不等同于“屏幕”，但一个屏幕始终有一个根视图控制器），UIControler在iOS应用导航中发挥着重要作用。'
- en: '**Loading and unloading views**: Usually, we don’t present views on the screen
    without a UIViewController that handles them. We can indeed add a UIView to the
    app window, but that’s an edge case. Adding a view to the window brings with it
    issues such as life cycle management, model and data linking, and many more, and
    they are considered not ideal.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载和卸载视图**：通常，我们不会在没有处理它们的UIViewController的情况下在屏幕上显示视图。我们确实可以向应用程序窗口添加UIView，但这只是一个特殊情况。将视图添加到窗口会带来许多问题，如生命周期管理、模型和数据链接等，这些都不被认为是理想的。'
- en: I’m not sure that, as iOS candidates, we will encounter an interview without
    a question about UIViewController.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定作为iOS候选人，我们是否会遇到一个不涉及UIViewController问题的面试。
- en: “Can you list all the life cycle events or methods of a UIViewController, in
    the order in which they occur?”
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能按发生的顺序列出所有UIControler的生命周期事件或方法吗？”
- en: '*Why is this* *question important?*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: That is probably one of the most common questions interviewers ask. It isn’t
    a difficult question and is also easy to learn and complete.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是面试官最常问的问题之一。这个问题并不难，而且也容易学习和完成。
- en: This question is usually considered a critical factor in the interview process,
    as not doing well can lead to concerns for most interviewers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通常被认为是面试过程中的一个关键因素，因为表现不佳可能会引起大多数面试官的担忧。
- en: Let’s understand why – our understanding of UIViewController life cycle events
    influences the decisions of where to load and release data, how to build our UI,
    perform animation, and provide a good user experience to the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下原因——我们对 UIViewController 生命周期事件的了解会影响我们关于在哪里加载数据和释放数据、如何构建我们的 UI、执行动画以及为用户提供良好用户体验的决定。
- en: It is also important to be familiar with the UIViewController life cycle to
    handle user interaction and view updates.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 UIViewController 生命周期对于处理用户交互和视图更新也很重要。
- en: We need to ensure we don’t have any gaps in our answer to this question.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的答案对此问题的回答没有遗漏。
- en: '*What is* *the answer?*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'Let’s list the life cycle events, ordered by their call timing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按调用时间顺序列出生命周期事件：
- en: '**loadView()**: This is called before the view hierarchy is created. UIKit
    doesn’t create the view before **loadView()** is called, so we’ll get nil when
    accessing the UIViewController **view** property.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**loadView()**: 这是在视图层次结构创建之前被调用的。UIKit 在调用 **loadView()** 之前不会创建视图，因此当我们访问
    UIViewController 的 **view** 属性时，会得到 nil。'
- en: '**viewDidLoad()**: This is called after the view is loaded. That’s where we
    can perform additional setups to the view, such as adding subviews and observers.
    Unlike many other life cycle methods, **viewDidLoad** is called only once.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewDidLoad()**: 这是在视图加载之后被调用的。在那里我们可以对视图进行额外的设置，例如添加子视图和观察者。与许多其他生命周期方法不同，**viewDidLoad**
    只会被调用一次。'
- en: '**viewWillLayoutSubviews()**: This is called just before the view lays out
    its subviews. We can make additional changes to constraints at this time.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewWillLayoutSubviews()**: 这是在视图布局其子视图之前被调用的。我们可以在此时对约束进行额外的修改。'
- en: '**viewDidLayoutSubviews()**: This is called after the view lays out its subviews.
    We can do tasks that require a final layout. For example, position views, scroll
    view content size, and animations.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewDidLayoutSubviews()**: 这是在视图布局其子视图之后被调用的。我们可以执行需要最终布局的任务。例如，定位视图、滚动视图内容大小和动画。'
- en: '**viewWillAppear()**: This is called before the view is presented on the screen.
    UIKit calls that method one or more times. That’s the place to load data if needed.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewWillAppear()**: 这是在视图在屏幕上呈现之前被调用的。UIKit 会调用该方法一次或多次。如果需要，那是一个加载数据的好地方。'
- en: '**viewDidAppear()**: This is called after the view is already presented on
    the screen. UIKit calls that method one or more times. Generally, that’s an excellent
    place to show start animations.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewDidAppear()**: 这是在视图已经在屏幕上呈现之后被调用的。UIKit 会调用该方法一次或多次。通常，那是一个展示开始动画的好地方。'
- en: '**viewWillDisappear()**: This is called just before the view is removed from
    the parent view controller or is hidden by a modal view controller. We can do
    some cleanup tasks here, such as stop timers and animations, perform savings,
    or stop media playback.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewWillDisappear()**: 这是在视图即将从父视图控制器中移除或被模态视图控制器隐藏之前被调用的。我们可以在那里执行一些清理任务，例如停止计时器和动画、执行保存操作或停止媒体播放。'
- en: '**viewDidDisapper()**: This is called after the view is removed from the parent
    view controller. We usually perform tasks that do not influence the user experience
    – for example, logging, states, cleaning temporary files, and resetting data.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewDidDisappear()**: 这是在视图从父视图控制器中移除之后被调用的。我们通常执行不会影响用户体验的任务——例如，记录日志、保存状态、清理临时文件和重置数据。'
- en: It is imperative to mention that some of the methods in the list *can be called
    multiple times* in different use cases. For example, `viewWillLayoutSubviews`
    can be called when the main view changes its size, such as an orientation change.
    The `viewWillDisappear` method might be called when a model is presented above
    the view controller. We should provide examples of each one of the life cycle
    events to show our understanding.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 强调一点，列表中的某些方法在不同的用例中可能会被多次调用。例如，当主视图的大小改变时，如方向改变，`viewWillLayoutSubviews` 可能会被调用。`viewWillDisappear`
    方法可能在模型在视图控制器之上呈现时被调用。我们应该提供每个生命周期事件的示例来展示我们的理解。
- en: “Can you explain the concept of UIViewController containment? How would you
    implement it in your app?”
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释一下 UIViewController 容纳的概念吗？你如何在你的应用中实现它？”
- en: '*Why is this* *question important?*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题重要？*'
- en: Compared to the previous question, this question is more advanced and requires
    knowledge of design patterns and architecture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个问题相比，这个问题更高级，需要了解设计模式和架构知识。
- en: '**UIViewController containment** creates modular and reusable UI interfaces
    and increases our project flexibility.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**`UIViewController`包含**功能创建模块化和可重用的UI界面，并增加了我们的项目灵活性。'
- en: '*What is* *the answer?*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是* *答案？*'
- en: With UIViewController containment, we can add a view controller to another view
    controller and make it a child view controller. This differs from adding a subview
    because UIViewController represents an independent MVC unit and has its own responsibility.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UIViewController`包含，我们可以将一个视图控制器添加到另一个视图控制器中，并使其成为子视图控制器。这与添加子视图不同，因为`UIViewController`代表一个独立的MVC单元，并有其自己的职责。
- en: 'Take a look at *Figure 7**.3*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 看看*图7**.3*：
- en: '![Figure 7.3 – Divide our screen into different view controllers](img/Figure_7.3_B18653.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 将屏幕划分为不同的视图控制器](img/Figure_7.3_B18653.jpg)'
- en: Figure 7.3 – Divide our screen into different view controllers
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 将屏幕划分为不同的视图控制器
- en: '*Figure 7**.3* shows that a screen represented by a UIViewContoller is divided
    into two additional view controllers.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7**.3*显示，由`UIViewContoller`表示的屏幕被划分为两个额外的视图控制器。'
- en: 'There are two main ways of adding a view controller child:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加视图控制器子控制器主要有两种方式：
- en: '**Drag a new view controller in the storyboard**: We can use Xcode **Storyboard**
    to drag a new view controller to an existing view controller. That creates a container
    view that is linked to another view controller. Because a single **XIB file**
    represents a single view controller or a view, we can do that only in storyboards
    and not in standard XIB files.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在故事板中拖动一个新的视图控制器**：我们可以使用Xcode **Storyboard**将一个新的视图控制器拖动到一个现有的视图控制器上。这会创建一个容器视图，它与另一个视图控制器相关联。因为单个**XIB文件**代表一个视图控制器或视图，所以我们只能在故事板中这样做，而不能在标准的XIB文件中这样做。'
- en: '**Adding a child controller using code**: We can easily add a new child view
    controller in code using the **addChild(UIViewController:)** method. Let’s see
    an example of that:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用代码添加子控制器**：我们可以使用`**addChild(UIViewController:)**`方法轻松地在代码中添加一个新的子视图控制器。让我们看看一个例子：'
- en: '[PRE2]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are four steps we need to do:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行四个步骤：
- en: Call the **addChild** method to ensure the new UIViewController is added as
    a child in the view controller hierarchy.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`**addChild**`方法以确保新的`UIViewController`被添加到视图控制器层次结构中作为子控制器。
- en: Add the new view controller main view *as a subview* to the parent view controller.
    The views hierarchy needs to correspond to the view controller hierarchy.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的视图控制器主视图*作为子视图*添加到父视图控制器。视图层次结构需要与视图控制器层次结构相对应。
- en: Set the child view controller *view frame or constraints*. It can be whatever
    we need.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置子视图控制器的*视图框架或约束*。它可以是我们需要的任何东西。
- en: '*Notify the system* that the child view controller has been moved to the parent.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*通知系统*子视图控制器已被移动到父控制器。'
- en: One of the advantages of adding the new view controller “according to the guidelines”
    is that we can sync the life cycle events we discussed in the previous question.
    A `viewWillAppear` method being called on the parent view controller is also called
    on its child view controller, as long as they are added correctly. The life cycle
    events sync is critical when reusing the view controller as a child view controller
    on different screens.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 按照指南添加新的视图控制器“根据指南”的一个优点是，我们可以同步我们在前一个问题中讨论的生命周期事件。当在父视图控制器上调用`viewWillAppear`方法时，只要它们被正确添加，也会在子视图控制器上调用。当将视图控制器作为不同屏幕上的子视图控制器重用时，生命周期事件的同步至关重要。
- en: We are already using UIViewController containment in our apps!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的应用中使用`UIViewController`包含功能了！
- en: 'You may feel that UIViewController containment is strange to you if you haven’t
    tried that before. But – most likely, you already used some kind of child view
    controller implementation in your apps. Let’s see two good examples:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有尝试过，你可能会觉得`UIViewController`包含很奇怪。但——很可能是，你已经在你的应用中使用了一些形式的子视图控制器实现。让我们看看两个好的例子：
- en: '**UINavigationController**: Navigating in UIKit is done with a parent view
    controller (UINavigationController) and a child view controller, the top view
    controller. Imagine yourself implementing your own navigation controller – how
    would you do that? How will you implement the push and pop view controllers’ actions?
    This is a great thinking exercise that can prepare you for the question.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**UINavigationController**: 在UIKit中导航是通过父视图控制器（UINavigationController）和子视图控制器，即顶部视图控制器来完成的。想象一下你自己实现自己的导航控制器——你会怎么做？你将如何实现推入和弹出视图控制器的动作？这是一个很好的思考练习，可以帮助你为这个问题做好准备。'
- en: '**UISplitViewController**: Apple provides a split view controller for apps
    that run on iPads. In UISplitViewController, we have two additional child view
    controllers – master and detail view controllers. Both divide the screen into
    two different areas, each of which is a separate view controller. Now that you
    know how to add a child view controller, that’s easy.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**UISplitViewController**: 苹果为在iPad上运行的应用程序提供了一个分割视图控制器。在UISplitViewController中，我们有两个额外的子视图控制器——主视图控制器和详细视图控制器。两者都将屏幕分为两个不同的区域，每个区域都是一个独立的视图控制器。现在你知道了如何添加子视图控制器，这很简单。'
- en: “How do you pass data between view controllers in iOS?”
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何在iOS中在视图控制器之间传递数据？”
- en: '*Why is this* *question important?*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Passing data between view controllers is an important task in iOS development.
    The dynamic nature of apps presenting the same UI with different information requires
    us to update a view controller with new information constantly. The question tests
    our knowledge of the various design patterns of passing data between objects in
    general and between view controllers explicitly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS开发中，在视图控制器之间传递数据是一个重要的任务。应用程序动态呈现相同UI但包含不同信息的特点要求我们不断更新视图控制器以包含新信息。这个问题测试了我们对于在对象之间，尤其是视图控制器之间传递数据的各种设计模式的知识。
- en: '*What is* *the answer?*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'There are many ways of passing data between view controllers! The problem is
    that all those ways make it extremely easy to answer the question. And therefore,
    we need to explain the use case and reason for each one of the ways we present
    to the interviewer. Let’s see some examples:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图控制器之间传递数据有许多方法！问题是所有这些方法都使得回答问题变得极其容易。因此，我们需要解释我们向面试官展示的每一种方法的用例和原因。让我们看看一些例子：
- en: '**Using a delegate**: If we have a child-parent relationship, we use a delegate
    to notify of events and data between the child and the parent view controller.
    A delegate is a simple pattern based on a protocol used when we want to implement
    a simple update with a well-defined interface. However, the delegate pattern is
    considered a bit outdated as we have more advanced patterns today.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用代理**: 如果我们有一个子-父关系，我们使用代理来通知子视图控制器和父视图控制器之间的事件和数据。代理是一个简单的基于协议的模式，当我们想要实现一个具有明确定义接口的简单更新时使用。然而，随着今天有更多高级模式，代理模式被认为有点过时了。'
- en: '**Using dependency injection**: One way to pass data to a new view controller
    when presenting or pushing it into the stack is to use dependency injection. This
    can be achieved using the **init** function or setting one of its properties.
    One example can be a screen that displays contact information. In the **init**
    function, we can pass the contact entity that needs to be displayed. It’s important
    to note that this approach creates a one-way data stream and can be used whenever
    a new view controller needs to be displayed.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用依赖注入**: 在呈现或推入堆栈时将数据传递给新的视图控制器的一种方法是通过依赖注入。这可以通过使用**init**函数或设置其属性之一来实现。一个例子可以是一个显示联系信息的屏幕。在**init**函数中，我们可以传递需要显示的联系实体。需要注意的是，这种方法创建了一个单向数据流，并且可以在需要显示新的视图控制器时使用。'
- en: '**Using a closure**: If we pass the information in one direction only, closure
    is a great way to do that. We can define a closure on the destination view controller
    and set it on the source view controller. Whenever we want to pass information
    from the source to its parent, the source just needs to run the closure with the
    relevant parameters. That’s a simple way to pass data with minimal coupling.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用闭包**: 如果我们只向一个方向传递信息，闭包是一个很好的方法。我们可以在目标视图控制器上定义一个闭包，并将其设置在源视图控制器上。每当我们要从源传递信息到其父控制器时，源只需要运行带有相关参数的闭包。这是一个简单的方法，以最小的耦合传递数据。'
- en: '**Using Combine**: Combine is an advanced and reactive version of closure.
    It lets us stream data updates, including error handling, async operations, and
    data manipulation from one object to another.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Combine**: Combine 是闭包的高级和响应式版本。它允许我们从一个对象向另一个对象流式传输数据更新，包括错误处理、异步操作和数据操作。'
- en: '**Post notification**: If the two view controllers have no reference to each
    other, a notification may be a good solution. Even though we can attach data to
    the notification, posting a notification is considered to be an anti-pattern by
    many developers. A notification doesn’t have a straightforward interface; all
    living objects can observe it and respond. These two reasons alone make it less
    recommended than the other methods.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布通知**：如果两个视图控制器没有相互引用，通知可能是一个好的解决方案。尽管我们可以将数据附加到通知上，但许多开发者认为发布通知是一种反模式。通知没有直接的接口；所有活动对象都可以观察它并做出响应。仅仅这两个原因就使得它不如其他方法推荐。'
- en: You are already aware of all the methods I just presented, but listing them
    can help you answer that question and help you with design-pattern tasks and home
    assessments. That is one of my goals in this book – to organize your thoughts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了我刚刚展示的所有方法，但列出它们可以帮助你回答那个问题，并帮助你完成设计模式任务和家庭作业。这是本书的一个目标之一——组织你的思想。
- en: Making sure we are ready with UITableView
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保我们准备好使用UITableView
- en: UITableView, followed by UICollectionView, is one of the oldest UI components
    in UIKit. In fact, UITableView was there from the start, and UICollectionView
    was added four years later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: UITableView，随后是UICollectionView，是UIKit中最古老的UI组件之一。事实上，UITableView从一开始就存在，而UICollectionView是在四年后被添加的。
- en: Why is UITableView considered to be a fundamental component? The reason is apparent.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么UITableView被认为是一个基本组件？原因很明显。
- en: Both UITableView and UICollectionView are specialized in displaying a significant
    *amount of data* efficiently and straightforwardly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 两者，UITableView 和 UICollectionView，都擅长高效且直接地显示大量数据。
- en: UITableView does more than that – it provides an interface for displaying items
    in a way suitable for *small screens*, including features like multi-selection,
    editing, headers, and footers. It became the primary way of displaying menus and
    data in many apps.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: UITableView 不仅于此 – 它提供了一个界面，用于以适合 *小屏幕* 的方式显示项目，包括多选、编辑、头部和尾部等特性。它成为许多应用程序显示菜单和数据的主要方式。
- en: Apple ensured a component style, UITableView, was carried over to SwiftUI from
    day one to keep this capability with us.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 确保了从第一天起将组件样式UITableView带到SwiftUI中，以保持这种能力。
- en: “How does the queuing mechanism work in a UITableView, and what are some best
    practices for optimizing its performance?”
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何在UITableView中实现队列机制，以及有哪些最佳实践可以优化其性能？”
- en: '*Why is this* *question important?*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Like several other questions we discussed earlier (for example – UIViewController
    life cycle), that’s another go-no-go question you probably want to make sure you
    are ready for. This question tests our understanding of the primary mechanism
    of UITableView that enables its efficiency and performance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论的几个问题（例如 – UIViewController生命周期）一样，这也是一个你可能会想要确保准备好的去或不去的问题。这个问题测试了我们对于使UITableView高效和性能良好的主要机制的理解。
- en: The UITableView queuing mechanism is the foundation for many on-top features
    and issues we may encounter, such as async operations during scroll, optimizations,
    and state management.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: UITableView的队列机制是许多顶部特性和我们可能遇到的问题的基础，例如滚动时的异步操作、优化和状态管理。
- en: That mechanism is also the basis for additional controls such as UICollectionView
    and MKMapView.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 那个机制也是UICollectionView和MKMapView等附加控件的基础。
- en: '*What is* *the answer?*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个答案是什么？*'
- en: The UITableView mechanism ensures efficiency and high performance when scrolling
    with a large amount of data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: UITableView 机制确保在滚动大量数据时效率和性能高。
- en: The main problem with displaying a large number of items is *memory*. Allocating
    so many views, most off-screen, creates a memory overload, eventually leading
    to app termination.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 显示大量项目的主要问题是 *内存*。分配如此多的视图，其中大多数在屏幕之外，会导致内存过载，最终导致应用程序终止。
- en: What we want to do is to allocate only the views we see on the screen and release
    off-screen views while we are scrolling the list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是只分配屏幕上看到的视图，并在滚动列表时释放屏幕外的视图。
- en: But allocating new views each time raises a performance issue. If the user scrolls
    fast, allocating and creating new views takes a few milliseconds, which causes
    lags even when running on powerful devices.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但每次分配新视图都会引发性能问题。如果用户滚动速度快，分配和创建新视图需要几毫秒，这即使在强大的设备上运行也会造成延迟。
- en: This lag is where the queuing solution comes into practice. Instead of deallocating
    the view when it goes off-screen, UITableView puts it in a deque pool and pulls
    it from where it needs to display a new view in the list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种延迟是队列解决方案开始实施的地方。当视图离开屏幕时，UITableView不会将其销毁，而是将其放入deque池，并在需要显示列表中的新视图时从池中取出。
- en: 'The queuing mechanism makes the UITableView scrolling fast and smooth. But
    dequeuing cells also creates new problems, some of which are detailed here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 队列机制使得UITableView滚动快速且平滑。但 dequeuing单元格也带来了新的问题，其中一些问题在此详细说明：
- en: '**Working on an existing cell**: Before we display the cell, we must remember
    it might already have existing information. We need to clear the cell after it
    moves out of the pool by calling the **prepareForReuse** method or overriding
    its properties before we display it.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理现有单元格**：在我们显示单元格之前，我们必须记住它可能已经存在信息。我们需要在单元格从池中移出后通过调用**prepareForReuse**方法或在我们显示它之前覆盖其属性来清除单元格。'
- en: '**Verify responses from async operations**: A common issue in UITableViews
    is loading images async from a backend service. We start the request when the
    cell is being displayed, but when we get the response, the cell is already dequeued
    and connected to another entity. In this case, we need to ensure that the data
    we get in the response matches the current entity the cell is supposed to represent.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证异步操作响应**：在UITableView中，一个常见问题是异步从后端服务加载图片。我们在单元格显示时开始请求，但当我们得到响应时，单元格已经被dequeued并连接到另一个实体。在这种情况下，我们需要确保我们得到的响应数据与单元格应该表示的当前实体相匹配。'
- en: '**Working with multiple pools**: There are cases where we have numerous types
    of cells, probably based on different classes and UI. In this case, we need to
    create multiple deque pools, which we also need to handle and ensure.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与多个池一起工作**：有些情况下，我们拥有多种类型的单元格，可能基于不同的类和UI。在这种情况下，我们需要创建多个deque池，我们还需要处理并确保它们。'
- en: To summarize, UITableView provides an excellent mechanism to display big chunks
    of information but also brings us new issues we must handle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，UITableView提供了一个出色的机制来显示大量信息，但也带来了我们必须处理的新问题。
- en: “What is pagination in UITableView, and how would you implement it to efficiently
    load and display large amounts of data while maintaining good performance and
    user experience?”
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “UITableView中的分页是什么，你将如何实现它以高效地加载和显示大量数据，同时保持良好的性能和用户体验？”
- en: '*Why is this* *question important?*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: When we think of a UITableView, we imagine a contacts list or pizza recipes.
    But there are cases when it either takes time to load the data or the list is
    so big that it creates a memory overload. For example – social media posts, images,
    and data from the backend. From our point of view – an infinite number of items.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到UITableView时，我们会想象联系人列表或披萨食谱。但有时它可能需要时间来加载数据，或者列表太大，以至于造成内存过载。例如——社交媒体帖子、图片和后端的数据。从我们的角度来看——无限数量的项目。
- en: The interviewer wants to see how we handle a more complex situation than just
    displaying a closed list of items.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官想看到我们如何处理比仅显示一个关闭的项目列表更复杂的情况。
- en: '*What is* *the answer?*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个答案是什么？*'
- en: '**Pagination** in a UITableView is a technique that involves loading and displaying
    data in small batches based on the table view scroll position.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**UITableView中的分页**是一种技术，它涉及根据表格视图的滚动位置分批加载和显示数据。'
- en: We use pagination when we have a large amount of data, and loading everything
    simultaneously is inefficient. For example, if we have data from our backend or
    large images and videos stored in our persistent store.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有大量数据时，我们使用分页，同时加载所有数据是不高效的。例如，如果我们有来自后端的数据或存储在我们持久存储中的大图片和视频。
- en: With pagination, we load the data we want to display on the screen (and a little
    bit more), and when the user keeps scrolling, we load “another page” of data.
    This technique of loading data on demand is much faster for initial loading, doesn’t
    create memory overload, and is much more efficient overall.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分页，我们加载屏幕上要显示的数据（以及一点点更多），当用户继续滚动时，我们加载“另一页”的数据。这种按需加载数据的技术对于初始加载来说要快得多，不会造成内存过载，并且总体上更高效。
- en: 'However, pagination creates some other challenges we need to tackle, which
    are detailed here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，分页创建了一些我们需要解决的挑战，这些挑战在此详细说明：
- en: '**Decide the page loading trigger**: To perform the additional loading operation,
    we need to decide the loading trigger. For example, load more data when the user
    reaches the last visible row or a scrolling offset. Also, we need to ensure we
    are not sending multiple requests simultaneously since the trigger might be happening
    multiple times during that scroll.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**决定页面加载触发器**：为了执行额外的加载操作，我们需要决定加载触发器。例如，当用户达到最后一个可见行或滚动偏移量时加载数据。此外，我们需要确保我们不会同时发送多个请求，因为触发器可能会在滚动过程中多次发生。'
- en: '**Showing a loading indicator**: It is important to provide the user an indication
    there’s more data to view and is currently being loaded. It is common practice
    to show the indication in the last row at the bottom of the list.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示加载指示器**：向用户提供一个指示还有更多数据可以查看并且正在加载是很重要的。在列表底部最后一行显示指示是常见的做法。'
- en: '**Load data in the background**: To provide smooth scrolling without blocking
    the UI and creating lagging, we should load the data in a background thread using
    async functions, GCD, or **NSOperation**.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在后台加载数据**：为了提供平滑的滚动而不会阻塞UI和产生延迟，我们应该使用异步函数、GCD或**NSOperation**在后台线程中加载数据。'
- en: '**Handle the “no more data” use case**: That may sound like a weird issue,
    but developers sometimes forget to handle it. When the user scrolls to the last
    item on the list, the trigger for loading more is activated. If the request returns
    empty, the trigger might be activated again because our list meets the trigger
    condition. In this case, the list will enter an infinite loop of trying to fetch
    data without a result. The solution might be to use some temporary flag to avoid
    ongoing fetching.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理“没有更多数据”的情况**：这听起来可能像是一个奇怪的问题，但开发者有时会忘记处理它。当用户滚动到列表的最后一项时，加载更多数据的触发器被激活。如果请求返回空数据，触发器可能会再次被激活，因为我们的列表满足了触发条件。在这种情况下，列表将进入一个无限循环，试图获取数据但没有结果。解决方案可能是使用一些临时标志来避免持续获取。'
- en: Pagination is a technique that has pros and cons and should be considered carefully.
    It involves both the backend and client and can provide high performance and good
    user experience but requires us to deal with more complex fetching patterns.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是一种既有优点也有缺点的技术，需要仔细考虑。它涉及到后端和客户端，可以提供高性能和良好的用户体验，但需要我们处理更复杂的获取模式。
- en: “What are the different approaches for adjusting cell size in a UITableView,
    and how do you determine the optimal size for cells based on the content they
    will display?”
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “在UITableView中调整单元格大小的不同方法有哪些，以及你是如何根据它们将要显示的内容确定单元格的最佳大小的？”
- en: '*Why is this* *question important?*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Cell size in UITableView was always an issue for iOS developers, mainly when
    the need for accessibility and dynamic font size evolved over the years.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在UITableView中，单元格大小一直是iOS开发者的问题，尤其是在需要可访问性和动态字体大小随时间演变的年份。
- en: This question tests our knowledge of UITableView delegate, our ability to use
    Auto Layout with cells, and the tradeoffs we need to make between performance
    and simplicity.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题测试了我们对UITableView代理的了解，我们使用Auto Layout与单元格的能力，以及我们在性能和简单性之间需要做出的权衡。
- en: '*What is* *the answer?*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'There are two ways to adjust a cell size:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 调整单元格大小有两种方法：
- en: '**Set a custom height for each row**: Implement the **tableView(_:heightForRowAt:)**
    delegate method that returns a different height for each row. In this way, we
    need to calculate the size of each row ourselves. It can be a constant size or
    according to the cell content. Calculating the cell size ourselves can be inaccurate
    if not done right, but it can be faster and more efficient in terms of performance
    when dealing with large datasets. Here’s an example of such an implementation:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为每一行设置自定义高度**：实现返回每行不同高度的**tableView(_:heightForRowAt:)**代理方法。这样，我们就需要自己计算每行的大小。它可以是固定大小或根据单元格内容。如果做得不正确，自己计算单元格大小可能会不准确，但在处理大量数据集时，它可能更快、更高效。以下是一个这样的实现示例：'
- en: '[PRE3]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code example, we pull the cell data according to its row index and calculate
    the size based on the UITableView size. We can see how error-prone this code snippet
    is, as it needs to be very accurate. But – since we are not using the Auto Layout
    system, it is much faster.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们根据单元格的行索引获取单元格数据，并根据UITableView的大小计算大小。我们可以看到这个代码片段有多容易出错，因为它需要非常精确。但是——因为我们没有使用Auto
    Layout系统，所以它要快得多。
- en: '**Using self-size cells**: The other option is to use self-size cells. In self-size
    cells, the cell’s height is set automatically by its content, using Auto Layout
    constraints. Some things to notice here are as follows:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用自适应单元格**: 另一个选项是使用自适应单元格。在自适应单元格中，单元格的高度会自动根据其内容通过自动布局约束来设置。以下是一些需要注意的事项：'
- en: We must ensure a *continuous sequence of constraints* from top to bottom for
    the cell to get a valid intrinsic content size.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须确保单元格从上到下有一个连续的约束序列，以便获得有效的固有内容大小。
- en: We need to ensure that the UITableView **rowHeight** property is set to **automaticDimension**.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保 `UITableView` 的 `rowHeight` 属性设置为 `automaticDimension`。
- en: We said that self-size cells are less efficient in terms of performance. To
    “help” UITableView measure its size, we can use the **estimatedRowHeight** property
    or implement the corresponding **tableView(_:estimatedHeightForRow:)** delegate
    method to provide a row height estimation until the cell is shown on the screen.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提到自适应单元格在性能方面效率较低。为了“帮助” `UITableView` 测量其大小，我们可以使用 `estimatedRowHeight` 属性或实现相应的
    `tableView(_:estimatedHeightForRow:)` 代理方法来提供行高估计，直到单元格显示在屏幕上。
- en: The self-size cells should be good enough for most cases, and it needs to be
    our go-to approach unless we encounter performance issues that will require us
    to set custom heights for cells.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应单元格对于大多数情况来说应该足够好，除非我们遇到需要为单元格设置自定义高度的性能问题，否则它应该是我们的首选方法。
- en: UITableView is a central topic in iOS development and interviews. The coding
    or the home assessment will probably include UITableView as a primary component.
    Make sure there are no mistakes with this control!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 是 iOS 开发和面试中的一个核心主题。编码或家庭评估可能包括 `UITableView` 作为主要组件。确保这个控件没有错误！'
- en: Performing navigation well
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行良好的导航
- en: Navigation is a critical component in UIKit and iOS development. Navigation
    allows us to move the user from one UIViewController to another intuitively and
    simply.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是 UIKit 和 iOS 开发中的一个关键组件。导航允许我们直观且简单地让用户从一个 `UIViewController` 跳转到另一个。
- en: 'There are two ways of navigating the user to another screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式将用户导航到另一个屏幕：
- en: '**Present a modal view controller**: If we need to present a screen with a
    task to complete or to make a decision, a view controller can present another
    view controller on top of it.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示模态视图控制器**: 如果我们需要显示一个需要完成任务或做出决定的屏幕，一个视图控制器可以在其上方显示另一个视图控制器。'
- en: '**Push another view controller**: If we want to navigate the user down the
    app hierarchy to the next stage, we can push a new view controller to the stack.
    This technique requires a UINavigationController to handle the push and pop operations
    and provide a navigation bar to ease the transitions.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送另一个视图控制器**: 如果我们想要将用户导航到应用层次结构的下一阶段，我们可以将新的视图控制器推入堆栈。这种技术需要一个 `UINavigationController`
    来处理推送和弹出操作，并提供一个导航栏以简化过渡。'
- en: Interviewers do not generally ask questions about the push and present, as these
    actions are fairly simple to understand and implement. Most questions and challenges
    are related to transitions, navigation bars, life cycle methods, and design patterns.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官通常不会问关于推送和显示的问题，因为这些操作相对简单易懂且易于实现。大多数问题和挑战都与过渡、导航栏、生命周期方法和设计模式相关。
- en: “What is the purpose of the navigationItem property in a view controller, and
    how can you use it to customize the behavior and appearance of a navigation bar
    in iOS development?”
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “视图控制器中 `navigationItem` 属性的目的是什么？你如何使用它来定制 iOS 开发中导航栏的行为和外观？”
- en: '*Why is this* *question important?*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: The `navigationItem` property is just that, a property. Why on earth is there
    a question about a specific property?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigationItem` 属性就是这样，一个属性。为什么会有关于特定属性的问题？'
- en: Well, that’s because `navigationItem` holds an entire concept behind it. This
    question tests our ability to understand how the navigation controller works and
    the design concept of empowering view controllers to impact the navigation bar’s
    appearance, despite it being a component of the navigation controller.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是因为 `navigationItem` 背后有一个完整的概念。这个问题测试了我们理解导航控制器工作方式和赋予视图控制器影响导航栏外观设计概念的能力。
- en: Generally, the way `navigationItem` and view controllers work is an interesting
    design pattern that can be used in other cases and is worth learning.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`navigationItem` 和视图控制器的工作方式是一个有趣的设计模式，可以在其他情况下使用，并且值得学习。
- en: '*What is* *the answer?*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: Every UIViewController has a property named `navigationItem`. That property
    contains several properties and methods used to customize the navigation bar’s
    behavior with data associated with the view controller itself.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个UIViewController都有一个名为 `navigationItem` 的属性。该属性包含几个属性和方法，用于使用与视图控制器本身相关联的数据来自定义导航栏的行为。
- en: For example, `navigationItem` contains the `title` property, which is used to
    set the *current title* value displayed in the navigation bar.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`navigationItem` 包含 `title` 属性，该属性用于设置在导航栏中显示的 *当前标题* 值。
- en: 'Other important items of information that can be set in `navigationItem` are
    the *left and right buttons*. Let’s see an example of how the view controller
    modifies the navigation bar using the `navigationItem` property:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 `navigationItem` 中设置的其它重要信息项包括 *左右按钮*。让我们看看视图控制器如何使用 `navigationItem` 属性修改导航栏的示例：
- en: '[PRE4]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our code example, the `navigationItem` property contains a title and a right
    bar button with the `"Button"` title. When the user navigates from that screen,
    the navigation controller will get a new `navigationItem` property from the next
    controller and update its navigation bar properties.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，`navigationItem` 属性包含一个标题和一个带有 `"按钮"` 标题的右侧栏按钮。当用户从该屏幕导航时，导航控制器将从下一个控制器获取新的
    `navigationItem` 属性并更新其导航栏属性。
- en: It’s a technique that empowers the navigation controller to update its navigation
    bar based on the context of the visible view controller. Thinking further, we
    can use this technique in other cases as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种使导航控制器能够根据可见视图控制器的上下文来更新其导航栏的技术。进一步思考，我们还可以在其他情况下使用这项技术。
- en: “What are some of the preset options for presenting a UIViewController in iOS,
    and why is it important to understand these options?”
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “iOS中展示UIViewController的预设选项有哪些，为什么理解这些选项很重要？”
- en: '*Why is this* *question important?*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要*？'
- en: Presenting a view controller with another view controller is a familiar and
    straightforward task iOS developers do all the time.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个视图控制器来展示视图控制器是iOS开发者经常进行的一项熟悉且直接的任务。
- en: However, there are several ways of presenting a view controller. Each one of
    the options is suitable for a different use case and can influence the presenter’s
    view controller life cycle events.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几种方式可以展示视图控制器。每个选项都适合不同的用例，并且可以影响展示者的视图控制器生命周期事件。
- en: Our job is to explain the different options to the product team and select the
    one that fits our use case.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的职责是向产品团队解释不同的选项，并选择适合我们用例的选项。
- en: '*What is* *the answer?*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么*？'
- en: There are several preset options available to us. Each one influences the look
    and feel of the presented view controller.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种预设选项可供选择。每个选项都会影响所展示的视图控制器的外观和感觉。
- en: 'Let’s name some of them:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列举一些：
- en: '**Fullscreen**: The presented view controller takes up the entire screen.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全屏**：所展示的视图控制器占据整个屏幕。'
- en: '**PageSheet**: The presented view controller doesn’t fill the whole screen,
    and the screen can be pulled down using a simple swipe gesture.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面视图**：所展示的视图控制器不会填满整个屏幕，可以通过简单的滑动手势向下拉动屏幕。'
- en: '**overCurrentContext**: The view controller is presented and hides the current
    view controller context.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖当前上下文**：视图控制器被展示并隐藏了当前视图控制器上下文。'
- en: Obviously, the different types of presentations need to be suitable for the
    user experience we want to provide to our users. But we also must consider the
    influence of these types on the different life cycle events being fired.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，不同类型的展示需要适合我们希望提供给用户的用户体验。但我们还必须考虑这些类型对正在触发不同生命周期事件的影响。
- en: For example – if we use `viewWillDisappear` and `viewDidDisappear` of the presenting
    view controller *are not being called*. In Page Sheet, we assume the underlying
    view controller is still visible. Therefore, some life cycle events related to
    appearance are also not being called.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 - 如果我们使用展示视图控制器的 `viewWillDisappear` 和 `viewDidDisappear` 没有被调用。在页面视图中，我们假设底层视图控制器仍然可见。因此，一些与外观相关的生命周期事件也没有被调用。
- en: In this case, we must change how we present the modal view controllers or communicate
    any changes or updates using a delegate pattern or Combine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须改变我们展示模态视图控制器的方式，或者使用代理模式或Combine来传达任何更改或更新。
- en: The rule is simple – we need to adjust the preset option to the user experience
    we want to provide to our users. Do we hide the underlying screen? That’s a good
    starting question.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 规则很简单 – 我们需要调整预设选项以提供我们希望提供给用户的用户体验。我们是否隐藏了底层的屏幕？这是一个很好的起始问题。
- en: “How would you design a navigation system for an iOS app using the coordinator
    pattern, where view controllers don’t decide where to go next, and a coordinator
    object is responsible for managing the navigation flow?”
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你将如何设计一个使用协调器模式的iOS应用的导航系统，其中视图控制器不决定下一步去哪里，而是由协调器对象负责管理导航流程？”
- en: '*Why is this* *question important?*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: That’s an advanced question about navigation in iOS apps, and it’s not related
    directly to how to technically implement UINavigationController or present a view
    controller modally.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于iOS应用导航的高级问题，它与如何技术实现UINavigationController或以模态方式显示视图控制器没有直接关系。
- en: This question deals with the separation of concerns principle and design patterns
    we can use in our project to provide more flexibility and modularity.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题涉及到关注点分离原则和设计模式，我们可以在项目中使用它们来提供更多的灵活性和模块化。
- en: That’s one of the questions that doesn’t come with a school-ready answer, and
    you can think about your answer during your interview and discuss it with your
    interviewer. More important is to develop a set of principles and ideas for how
    to nail this challenge.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些没有现成答案的问题之一，你可以在面试期间思考你的答案，并与面试官讨论。更重要的是，要开发一套原则和想法，以应对这个挑战。
- en: '*What is* *the answer?*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: A **coordinator pattern** is a popular design pattern that separates the navigation
    logic from the UI.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**协调器模式**是一种流行的设计模式，它将导航逻辑与UI分离。'
- en: 'So, let’s discuss how to approach this question and decide on the basic principles
    we want to keep:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来讨论如何解决这个问题，并确定我们想要保留的基本原则：
- en: The view controller (or its view model, for that matter) *doesn’t decide where
    to navigate* but only sends touch events
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图控制器（或其视图模型，无论如何）*不决定导航到哪里*，只是发送触摸事件
- en: We keep the navigation *logic in another class* called **Coordinator**
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将导航*逻辑放在另一个名为**协调器**的类中*
- en: We can create one **Coordinator** for each view controller or a **Coordinator**
    for a single flow
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为每个视图控制器创建一个**协调器**，或者为单个流程创建一个**协调器**。
- en: The **Coordinator** has a reference to the navigation controller and *can push
    or pop view* controllers as needed
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调器**有一个对导航控制器的引用，并且可以根据需要推送或弹出视图控制器'
- en: The **Coordinator** needs to *observe events* that happen in the currently displayed
    view controller
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调器**需要*观察当前显示的视图控制器中发生的事件*'
- en: 'Based on these assumptions, we can imagine the following pattern (*Figure 7**.4*):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些假设，我们可以想象以下模式（*图7.4*）：
- en: '![Figure 7.4 – A coordinator pattern (suggestion)](img/Figure_7.4_B18653.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 协调器模式（建议）](img/Figure_7.4_B18653.jpg)'
- en: Figure 7.4 – A coordinator pattern (suggestion)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 协调器模式（建议）
- en: Notice this is just a suggestion, as this pattern is not set in stone.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只是一个建议，因为这个模式并不是一成不变的。
- en: 'Here are some modifications we can suggest according to different project’s
    needs:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同项目的需求，这里有一些我们可以提出的修改建议：
- en: If the project becomes more prominent, we can have *several coordinators* and
    sometimes even a hierarchy of coordinators.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果项目变得更加突出，我们可以有*多个协调器*，有时甚至是一个协调器的层次结构。
- en: We can decide that the coordinator *observes state change* in the view model.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以决定协调器*观察视图模型的状态变化*。
- en: We also don’t have to use observers for navigating but provide the view controller
    a *reference to the coordinator*. The view controller can send the coordinator
    what happened, and the coordinator can decide what to do next.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也不必使用观察者进行导航，而是为视图控制器提供一个*协调器的引用*。视图控制器可以向协调器发送发生了什么，协调器可以决定接下来做什么。
- en: We can play with the pattern if we keep the basic design principles and explain
    what we do well.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持基本的设计原则并解释我们做了什么，我们可以对这个模式进行一些调整。
- en: Empowering user experience with animations
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过动画赋予用户体验力量
- en: Unlike what many think, animations in iOS are not for “fun”- they play a significant
    role in providing our app with a sleek and smooth experience. As a result, they
    are part of our developer’s tools set.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多人认为的不同，iOS中的动画不是为了“娱乐”- 它在我们应用中提供了流畅和顺滑体验的重要作用。因此，它们是我们开发者工具集的一部分。
- en: Animation in iOS relies on a framework called **Core Animation**, which is one
    of UIKit's dependencies. So, even though this chapter discusses UIKit, we can
    find Core Animation in many classes and methods in UIKit.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: iOS中的动画依赖于一个名为**Core Animation**的框架，这是UIKit的依赖之一。因此，尽管本章讨论的是UIKit，我们可以在UIKit的许多类和方法中找到Core
    Animation。
- en: Going over the core concepts of animation in UIKit
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾UIKit中动画的核心概念
- en: So, what do we need to know about animations when practicing for an interview?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在准备面试时，我们需要了解哪些关于动画的知识呢？
- en: We need to know several classes, terms, methods, and techniques. Let’s go over
    them before we move on to an advanced interview question.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解几个类、术语、方法和技巧。在我们继续讨论高级面试问题之前，让我们回顾一下它们。
- en: Performing UIView animations
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行UIView动画
- en: 'UIView animations are probably the simplest animations we have in UIKit. In
    a UIView animation, we provide a closure with our final state, and UIKit runs
    the animation automatically. Let’s see a code example that takes a view and fades
    it out by changing its `alpha` value:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: UIView动画可能是UIKit中最简单的动画之一。在UIView动画中，我们提供一个包含最终状态的闭包，UIKit会自动运行动画。让我们看看一个代码示例，它接受一个视图并通过改变其`alpha`值来将其淡出：
- en: '[PRE5]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We see a simple code that receives a duration and a closure and animates the
    changes inside the closure, in this case, changing the `myView` alpha property
    to `0.0`. Notice that Core Animation doesn’t animate all UIView properties. Here
    is the list of UIView animatable properties: `frame`, `bounds`, `center`, `transform`,
    `alpha`, `backgroundColor`, and `tintcolor`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一段简单的代码，它接收一个持续时间和一个闭包，并在闭包内部动画化变化，在这种情况下，改变`myView`的alpha属性为`0.0`。注意，Core
    Animation并不动画化所有UIView属性。以下是可动画化的UIView属性列表：`frame`、`bounds`、`center`、`transform`、`alpha`、`backgroundColor`和`tintcolor`。
- en: Animating Auto Layout constraints changes
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画化自动布局约束变化
- en: 'We need to understand how to animate constraints changes because it is not
    as straightforward as the other properties we modify. Constraints are part of
    the Auto Layout, and UIKit performs Auto Layout changes every run loop (every
    16.67 milliseconds). This means we need to “force” Auto Layout to perform the
    changes inside the animation closure by calling the `layoutIfNeeded` method. Here’s
    an example of a constraints change of a view:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解如何动画化约束变化，因为这不像我们修改的其他属性那样直接。约束是自动布局的一部分，UIKit在每次运行循环（每16.67毫秒）时都会执行自动布局变化。这意味着我们需要通过调用`layoutIfNeeded`方法“强制”自动布局在动画闭包内执行这些变化。以下是一个视图约束变化的示例：
- en: '[PRE6]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that it’s not enough to create or modify the constraint within the
    animation closure. We also need to “force” the changes to happen on time; therefore,
    we call the `layoutIfNeeded` method.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，仅仅在动画闭包内创建或修改约束是不够的。我们还需要“强制”这些变化按时发生；因此，我们调用`layoutIfNeeded`方法。
- en: Playing with timing and easing
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩转时序和缓动
- en: 'We can adjust the animations to create what we want the user to perceive using
    timing and easing. Timing means different duration and delays, so we can have
    a longer or shorter animation. `springWithDamping` and `initialSpringVelocity`
    that can help us achieve even more customized animation easing. Let’s see an example
    of that:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调整动画的时序和缓动来创建用户想要感知的效果。时序意味着不同的持续时间和延迟，因此我们可以有一个更长或更短的动画。`springWithDamping`和`initialSpringVelocity`可以帮助我们实现更定制的动画缓动。让我们看看一个示例：
- en: '[PRE7]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We scale the `myView` size by modifying its `transform` property and doing
    that animatedly. We can also see that we pass these two important parameters:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过修改`myView`的`transform`属性并动画化这个过程来缩放`myView`的大小。我们还可以看到我们传递了这两个重要的参数：
- en: '**usingSpringWithDamping**: This controls how much the spring effect is damped,
    with higher values resulting in less oscillation and a quick settling time'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用springWithDamping**：这控制了弹簧效果的阻尼程度，更高的值会导致更少的振荡和更快的稳定时间'
- en: '**initialSpringVelocity**: This controls the initial velocity of the animation,
    with higher values resulting in a faster start and a more substantial effect'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**initialSpringVelocity**：这控制了动画的初始速度，更高的值会导致更快的开始和更显著的效果'
- en: It’s important to play with these values to achieve the desired result.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要调整这些值以实现期望的结果。
- en: Building keyframe animations
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建关键帧动画
- en: 'For more complex animations, we can use keyframe animation. Keyframe animation
    allows us to create animations in stages or sequences. We can define the different
    stages and provide a relative duration and start time for each one of them. Here’s
    an example of a keyframe animation:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的动画，我们可以使用关键帧动画。关键帧动画允许我们分阶段或序列地创建动画。我们可以定义不同的阶段，并为每个阶段提供相对持续时间和起始时间。以下是一个关键帧动画的示例：
- en: '[PRE8]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How do we read this code block? It’s easy. The total animation duration is 3
    seconds and is split into two sequences.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何阅读这个代码块？很简单。整个动画的持续时间是3秒，并且分为两个序列。
- en: The first sequence starts at the beginning (relative time 0) and takes half
    the total time (relative duration 0.5, meaning 1.5 seconds).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个序列从开始（相对时间0）开始并持续总时间的一半（相对持续时间0.5，意味着1.5秒）。
- en: The second sequence starts in the middle of the total animation time (relative
    time 0.5, meaning 1.5 seconds) and takes half of the animation time (relative
    duration 0.5, implying 1.5 seconds).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个序列在总动画时间的中点开始（相对时间0.5，意味着1.5秒）并持续动画时间的一半（相对持续时间0.5，意味着1.5秒）。
- en: The sequences don’t have to sync with each other, and it’s up to us to sync
    them if we need.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 序列不必相互同步，如果需要，由我们来同步它们。
- en: Performing transitions between screens
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在屏幕之间执行过渡
- en: UIKit allows us to perform transitions between screens, or to be precise, between
    UIViewControllers. We can pick one of the built-in transitions or even create
    our own transition.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: UIKit允许我们在屏幕之间执行过渡，或者更准确地说，在UIViewControllers之间。我们可以选择内置的过渡之一，甚至创建自己的过渡。
- en: 'This is how we present a UIViewController with a dissolve animation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何使用溶解动画来展示UIViewController：
- en: '[PRE9]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: UIKit provides a short list of built-in animations that, in many cases, are
    not sufficient. Therefore, we have the option to create a custom animation and
    even an interactive animation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: UIKit提供了一小部分内置动画，在很多情况下，这些动画是不够的。因此，我们有创建自定义动画甚至交互式动画的选项。
- en: Now, in the context of an interview – just like many other topics, it is important
    to understand how the custom transition works. We are not required to remember
    every API’s detail, but we need to know what we are capable of, what possibilities
    it opens up, and how to build it so it can be reused across our project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在面试的背景下——就像许多其他主题一样，理解自定义过渡的工作方式很重要。我们不需要记住每个API的细节，但我们需要知道我们能够做什么，它打开了哪些可能性，以及如何构建它，以便在整个项目中重用。
- en: Manipulating CALayers
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作CALayers
- en: We touched on CALayer earlier when we discussed UIView but haven’t discussed
    its importance for us as iOS developers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论UIView时提到了CALayer，但还没有讨论它对我们作为iOS开发者的重要性。
- en: We already know that iOS graphics is built with layers – UIViews (backed up
    with CALayers) and underneath we have Core Animation, which is built upon **Metal**.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道iOS图形是通过层构建的——UIView（由CALayers支持）以及其下是Core Animation，它是建立在**Metal**之上的。
- en: CALayers provides hardware-accelerated rendering components, which lets us manipulate
    graphics and perform sophisticated animations and image processing. We can also
    blend layers and add visual effects. Overall, CALayers help us to go down the
    graphics architecture and get closer to the hardware and the GPU to achieve more
    power and efficiency.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: CALayers提供了硬件加速渲染组件，这使得我们可以操纵图形并执行复杂的动画和图像处理。我们还可以混合层并添加视觉效果。总的来说，CALayers帮助我们深入图形架构，更接近硬件和GPU，以实现更多功能和效率。
- en: Understanding the core concepts of animation techniques can help us achieve
    a better user experience. As iOS developers, we are expected to be familiar with
    the essential tools and classes to provide the desired animations our product
    team requires.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 理解动画技术的核心概念可以帮助我们实现更好的用户体验。作为iOS开发者，我们预计应该熟悉提供所需动画的基本工具和类。
- en: Now let’s review an interesting interview question related to animation in UIKit.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一个与UIKit中动画相关有趣的面试问题。
- en: “How can you create custom transitions between UIViewControllers in an iOS app?”
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何在iOS应用中创建UIViewControllers之间的自定义过渡？”
- en: '*Why is this* *question important?*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: We discussed custom transitions a little earlier when we went over the animation
    core concepts, and this question tests our experience with the custom transition
    API. The Custom UIViewController transition API requires us to handle reusability,
    a deep understanding of how animations work, how view controllers work with each
    other, how to perform advanced techniques such as snapshotting, and how to implement
    a relatively complex UIKit API.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在介绍动画核心概念时简要讨论了自定义过渡，这个问题测试了我们对自定义过渡 API 的经验。自定义 UIViewController 过渡 API 要求我们处理可重用性，深入理解动画的工作原理，视图控制器如何相互协作，如何执行高级技术，如快照，以及如何实现相对复杂的
    UIKit API。
- en: Custom animation is considered an advanced topic, and we should at least understand
    the basics of it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义动画被认为是一个高级主题，我们至少应该了解其基本概念。
- en: '*What is* *the answer?*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: To create a custom transition between UIViewControllers, we must implement the
    `UIViewControllerAnimatedTransitioning` protocol (any object can conform to that
    protocol).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 UIViewControllers 之间创建自定义过渡，我们必须实现 `UIViewControllerAnimatedTransitioning`
    协议（任何对象都可以遵守该协议）。
- en: 'This protocol has two functions: `animateTransition(using:)` and `transitionDuration(using:)`.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议包含两个函数：`animateTransition(using:)` 和 `transitionDuration(using:)`。
- en: In `animateTransition(using:)`, we handle the view hierarchy, constraints changes,
    and animations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `animateTransition(using:)` 中，我们处理视图层次结构、约束更改和动画。
- en: In `transitioDuration(using:)`, we return the duration in `TimeInterval`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `transitionDuration(using:)` 中，我们返回 `TimeInterval` 中的持续时间。
- en: '`UIViewControllerAnimatedTransitioning` defines a transition, present or dismiss.
    To determine precisely what happens in each scenario, we must implement `UIViewControllerTransitionDelegate`
    to specify which object handles each use case.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewControllerAnimatedTransitioning` 定义了一个过渡，展示或消失。为了精确确定每个场景中发生的事情，我们必须实现
    `UIViewControllerTransitionDelegate` 来指定哪个对象处理每个用例。'
- en: Once we do that, to use our custom transition, we need to set the UIViewController
    `modalPresentationStyle` property to custom and the `transitionDelegate` property
    to the object that conforms to `UIViewControllerAnimatedTransitioning`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，为了使用我们的自定义过渡，我们需要将 UIViewController 的 `modalPresentationStyle` 属性设置为自定义，并将
    `transitionDelegate` 属性设置为符合 `UIViewControllerAnimatedTransitioning` 的对象。
- en: 'Since we have two different protocols to implement and things get a little
    complex here, let’s look at *Figure 7**.5* to understand how everything is related
    to each other:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个不同的协议需要实现，这里的事情变得有些复杂，让我们看看 *图 7.5* 来理解所有这些是如何相互关联的：
- en: '![Figure 7.5 – Custom UIViewController transition delegate](img/Figure_7.5_B18653.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 自定义 UIViewController 过渡代理](img/Figure_7.5_B18653.jpg)'
- en: Figure 7.5 – Custom UIViewController transition delegate
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 自定义 UIViewController 过渡代理
- en: 'We can see that the leading role of `UIViewControllerTransitionDelegate` is
    to decide which object will handle the animation when presenting or dismissing
    the presented view controller. It’s worth saying that all three components can
    be the same object, and this is where the reusability concept comes in. If we
    want to be able to reuse our transitions across the project, we need to do two
    things:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`UIViewControllerTransitionDelegate` 的主要作用是在展示或消失展示视图控制器时决定哪个对象将处理动画。值得一提的是，这三个组件可以是同一个对象，这就是可重用性概念所在。如果我们希望能够在整个项目中重用我们的过渡，我们需要做两件事：
- en: Separate the *different components* of different objects.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将不同对象的 *不同组件* 分离。
- en: When animating, reduce coupling between the presented/presenting view controller
    and the transitioning object *using protocols* and not explicitly the original
    view controller class. For example, suppose we are animating a view from one controller
    to another. In that case, we shouldn’t use a direct reference to the view but
    rather a protocol with a **getView()** method so that we can reuse that with another
    view controller.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画过程中，应通过协议而不是直接引用原始视图控制器类来减少展示/展示视图控制器与过渡对象之间的耦合，使用协议。例如，假设我们正在将一个视图从一个控制器动画到另一个控制器。在这种情况下，我们不应直接使用视图的引用，而应使用具有
    **getView()** 方法的协议，这样我们就可以与另一个视图控制器重用它。
- en: As we can see, transitioning between view controllers is a task that involves
    different techniques expected from a senior iOS developer. However, the concept
    needs to be done at least once to understand it fully.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，视图控制器之间的过渡是一个涉及不同技术的高级 iOS 开发者需要完成的任务。然而，这个概念至少需要做一次，才能完全理解它。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed many crucial topics related to UIKit, such as
    UIView, UIViewController, UITableView, navigation, and animations. UIKit has a
    massive presence in iOS developers’ day-to-day work and significantly influences
    the user experience.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了许多与UIKit相关的重要主题，例如UIView、UIViewController、UITableView、导航和动画。UIKit在iOS开发者日常工作中占有巨大比重，并对用户体验产生了重大影响。
- en: But – UIKit is also considered the “old” UI framework. The iOS development world
    is transitioning to a new, more modern era of declarative programming.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 但——UIKit也被认为是“旧”的UI框架。iOS开发界正在向一个新、更现代的声明式编程时代过渡。
- en: Our next chapter will handle just that – SwiftUI and declarative programming.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的章节将专门处理这个问题——SwiftUI和声明式编程。
