<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor187"/>13</h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor188"/>Creating a Word Game (Part 2)</h1>
<p>In the first part of our project, we put together a good portion of the interface and implemented much of the game’s functionality, so we currently have a working game that can list all the user’s entered words. </p>
<p>Let’s continue here in the second part of the project, finishing off the settings screen so that the user can select the language of their choice, and adding more elements to the UI to help make it more polished – for example, adding user feedback.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating a settings screen</li>
<li>Styling the UI</li>
<li>Implementing user feedback with alerts</li>
<li>Adding a Footer View to display more information</li>
<li>Adding haptics and button sounds</li>
</ul>
<h1 id="_idParaDest-181"><a id="_idTextAnchor189"/>Technical requirements</h1>
<p>You can download the resources and finished project from the <code>Chapter 13</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor190"/>Creating a settings screen</h1>
<p>Now that we can set<a id="_idIndexMarker716"/> the word length, let’s put together the settings view<a id="_idIndexMarker717"/> so that the user can click on the info button and actually change the language from there. We want to create three buttons – one for each language – and a fourth button, the <strong class="bold">Done</strong> button, which users can use to complete their selection and dismiss the page.</p>
<p>So, inside <code>SettingsView</code>, we’ll first need a variable to access <code>DataModel</code>. Add this observed object variable at the top of the <code>SettingsView</code> struct:</p>
<pre class="source-code">
 @ObservedObject var appData = DataModel()</pre>
<p>Next, let’s add a title for this <a id="_idIndexMarker718"/>page called <code>Language Settings</code> in the <code>body</code> property:</p>
<pre class="source-code">
 VStack {
        Text("Language Settings")
            .font(.title).bold()
            .padding(.top, 20)
        }</pre>
<p>Here, we simply add the <code>Text</code> view with a little padding and bold font, all inside of <code>VStack</code>.</p>
<p>Next, let’s <a id="_idIndexMarker719"/>add a <code>Form</code> view and a <code>Section</code> header view inside <code>VStack</code> to group <a id="_idIndexMarker720"/>the buttons that we will be adding. Place this code just under the <code>padding</code> modifier:</p>
<pre class="source-code">
        Form {
            Section(header: Text("Select a language")) {
            }
        }</pre>
<p>The <code>Form</code> view is a container that’s commonly used to group controls together, and the <code>Section</code> header will add some header text to each grouping. This is what <code>SettingsView</code> looks like so far:</p>
<div><div><img alt="Figure 13.1: Styling the SettingsView using the Form and Section header views " src="img/B18674_13_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: Styling the SettingsView using the Form and Section header views</p>
<p>Next, we <a id="_idIndexMarker721"/>will <a id="_idIndexMarker722"/>add buttons to let the user select a language.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor191"/>Adding the language buttons</h2>
<p>The buttons we <a id="_idIndexMarker723"/>will create will be styled with a wood image background and some text applied to them. Let’s do the button styling in a separate struct.</p>
<p>Add the following struct anywhere in the file, as long as it’s not inside the <code>SettingsView</code> struct (I usually create other structs just above the <code>Previews</code> struct):</p>
<pre class="source-code">
//style the button with a background and text
struct configureButton: View {
  var buttonText = ""
  var body: some View {
      ZStack {
          Image("background").resizable()
              .frame(width: 70, height: 35)
              .cornerRadius(10)
          Text(buttonText)
              .foregroundColor(.white)
              .shadow(color: .black, radius: 1, x: 1, y: 1)
      }
  }
}</pre>
<p>We’re calling<a id="_idIndexMarker724"/> the <code>configureButton</code> struct, and inside it, we create a <code>string</code> variable that will hold the text for the button. Then, we’re using the background image in the Assets Catalog and setting its size and <code>cornerRadius</code> value. After that, we add a <code>Text</code> view with white color and shadow, all done inside of <code>ZStack</code> so that they overlay each other.</p>
<p>Let’s proceed to add the first button, which will let the user play the game in the English language. Add the following code inside the <code>Section</code> header braces:</p>
<pre class="source-code">
var body: some View {
    VStack {
        Text("Language Settings")
            .font(.title).bold()
            .padding(.top, 20)
        Form {
            Section(header: Text("Select a language")) {
 <strong class="bold">       VStack(alignment: .center, spacing: 10) {</strong>
<strong class="bold">            HStack {</strong>
<strong class="bold">                //english button</strong>
<strong class="bold">                Button(action: {</strong>
<strong class="bold">                   </strong>
<strong class="bold">                }){</strong>
<strong class="bold">                    configureButton(buttonText: "English")</strong>
<strong class="bold">                }</strong>
<strong class="bold">                Spacer()</strong>
<strong class="bold">                </strong>
<strong class="bold">                //english flag</strong>
<strong class="bold">                Image("engFlag").resizable()</strong>
<strong class="bold">                    .border(Color.black, width: 1.5)</strong>
<strong class="bold">                    .frame(width: 50, height: 30)</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
      }
    }
  }
}</pre>
<p>In this code block, we<a id="_idIndexMarker725"/> added <code>VStack</code> with a center alignment and a spacing of 10 points. This will keep each button vertically spaced from each other by 10 points.</p>
<p>Along with creating a button to select the English language, I want to add a flag for the chosen country’s language as well. We do this in <code>HStack</code> – the button will be on the left, and the flag will be on the right of the screen. Next, I call the <code>configureButton</code> struct in the button closure, which will set the button to the word <strong class="bold">English</strong> and give it the wood background image. For the flag, I added a small border around it with a 1.5-point width, so it has a nice defined edge, and since this is associated with the English button, we will use the American flag image.</p>
<p>Now you can try it out; press the <code>ButtonStyle</code> protocol to control what flashes when the button is pressed. </p>
<p>Let’s do that. Add <a id="_idIndexMarker726"/>the following code underneath the <code>configureButton</code> struct:</p>
<pre class="source-code">
struct ButtonFlash: ButtonStyle {
    func makeBody(configuration: Configuration) -&gt; some 
View {
    configuration.label
        .shadow(color: .black, radius: 2, x: 2, y: 2)
        .opacity(configuration.isPressed ? 0.3 : 1)
  }
}</pre>
<p>This struct is called <code>ButtonFlash</code>, and it<a id="_idIndexMarker727"/> uses the <code>ButtonStyle</code> protocol. This is a protocol that applies interactive behavior and custom appearance to buttons. The <code>ButtonStyle</code> protocol requires that we use the <code>makeBody</code> method to configure the behavior and look for the button label.</p>
<p>In the code, we’re only calling two modifiers in the <code>makeBody</code> function – <code>shadow</code> and <code>opacity</code>. The <code>opacity</code> modifier will check the <code>isPressed</code> property to see whether it’s <code>true</code>. If it is <code>true</code>, that means the button has been pressed, so we can change the opacity to <code>.3</code>, which will make the button fade out slightly. Otherwise, if the button is not pressed, the button will remain at full opacity.</p>
<p>All we need to do next is call the <code>buttonFlash</code> structure on the button, like this:</p>
<pre class="source-code">
      HStack {
                //english button
                Button(action: {
                   
                }){
                    configureButton(buttonText: "English")
<strong class="bold">                }.buttonStyle(ButtonFlash())</strong>
                Spacer()
                 
                //english flag
                Image("engFlag").resizable()
                    .border(Color.black, width: 1.5)
                    .frame(width: 50, height: 30)
            }</pre>
<p>The <code>buttonStyle</code> protocol <a id="_idIndexMarker728"/>automatically creates a new modifier for us, also using <code>buttonStyle</code>, which we can access like any other modifier by using dot syntax and then passing in the name of our new struct, <code>ButtonFlash</code>.</p>
<p>Now, the button has a new look. It has a shadow around its text that gives it a sort of 3D look:</p>
<div><div><img alt="Figure 13.2: The English language button " src="img/B18674_13_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: The English language button</p>
<p>When you press<a id="_idIndexMarker729"/> the button, the modifiers will help make it look like it’s actually being pushed down. Also, it will just look like the button is being pushed, rather than the whole row.</p>
<p>Now, with the configuring and styling of the button complete, let’s add two more buttons for the other languages. Add this code right after the closing brace of <code>HStack</code>:</p>
<pre class="source-code">
          Divider()
            HStack {
                //English button
                Button(action: {
                    
                }){
                    configureButton(buttonText: "Spanish")
                }.buttonStyle(ButtonFlash())
                Spacer()
                //Spanish flag
                Image("esFlag").resizable()
                    .border(Color.black, width: 1.5)
                    .frame(width: 50, height: 30)
            }
            Divider()
            
            HStack {
                //Italian button
                Button(action: {
                    
                }){
                    configureButton(buttonText: "Italian")
                }.buttonStyle(ButtonFlash())
                Spacer()
                //italian flag
                Image("itFlag").resizable()
                    .border(Color.black, width: 1.5)
                    .frame(width: 50, height: 30)
            }</pre>
<p>The code starts with <code>Divider</code>, which is a very thin line that delineates the first button from the second one. Then, we use another <code>HStack</code>, similar to what we’ve just added for the <code>Divider</code> and then create our <strong class="bold">Italian</strong> button.</p>
<p>Now, the buttons are complete, but they don’t do anything when they’re pressed other than look nice. We need to make them functional and actually select the individual languages. This is simple – we just have to access our data model and change the language properties to the correct value, either <code>true</code> or <code>false</code>.</p>
<p>Let’s start with <a id="_idIndexMarker730"/>the <strong class="bold">English</strong> button. Inside the body of the button, add the following code:</p>
<pre class="source-code">
                    appData.englishIsOn = true
                    appData.spanishIsOn = false
                    appData.italianIsOn = false</pre>
<p>What we are doing here is accessing <code>DataModel</code> and changing <code>englishIsOnProperty</code> to <code>true</code> because the <code>false</code>. Now, if the <strong class="bold">English</strong> button is pressed, only that data file will be used to make a new random word.</p>
<p>Let’s add similar logic inside the <strong class="bold">Spanish</strong> button:</p>
<pre class="source-code">
                    appData.englishIsOn = false
                    appData.spanishIsOn = true
                    appData.italianIsOn = false</pre>
<p>For the <code>false</code>, and that the Spanish property is set to <code>true</code>.</p>
<p>Finally, let’s add the following code to the <strong class="bold">Italian</strong> button:</p>
<pre class="source-code">
                    appData.englishIsOn = false
                    appData.spanishIsOn = false
                    appData.italianIsOn = true</pre>
<p>Now, all the buttons are complete, and they will implement the user’s chosen language.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor192"/>Adding a checkmark</h2>
<p>However, we can <a id="_idIndexMarker731"/>improve the design a little bit here. Currently, when the user presses the language buttons, there’s no indication that the button selected anything. How about we add a checkmark next to the flag for the selected language?</p>
<p>Let’s add another struct that will make checkmarks for the buttons. Add the following struct under the <code>ButtonFlash</code> struct:</p>
<pre class="source-code">
//add a checkmark
struct addCheckmark: View {
    var isLanguageOn: Bool = false
    var body: some View {
        VStack{
            Image(systemName: "checkmark.circle")
                .imageScale(.small).foregroundColor(.green)
                .font(Font.largeTitle.weight(.regular))
                .opacity(isLanguageOn ? 1.0 : 0)
        }
    }
}</pre>
<p>I’m calling the struct <code>addCheckmark</code> and then creating a Boolean to check which language has been selected. Inside the body of the struct, we create a small checkmark, color it green, and set the opacity of the checkmark to either fully visible or hidden, depending on whether the <code>isLanguageOn</code> property is <code>true</code> or not. </p>
<p>Now, we can call this struct inside each <code>HStack</code>, so a checkmark will be placed toward the flag side. For the sake of brevity, I will add the checkmark code to the first <code>HStack</code>, but you need to add it to all three <code>HStack</code> instances as well, in the same location that I use here:</p>
<pre class="source-code">
  VStack(alignment: .center, spacing: 10) {
            HStack {
                //english button
                Button(action: {
                    appData.englishIsOn = true
                    appData.spanishIsOn = false
                    appData.italianIsOn = false
                }){
                    configureButton(buttonText: "English")
                }.buttonStyle(ButtonFlash())
                Spacer()
                //english - checkmark appears when 
                  englishIsOn is true
               <strong class="bold"> addCheckmark(isLanguageOn: </strong>
<strong class="bold">                  appData.englishIsOn)</strong>
                //english flag
                Image("engFlag").resizable()
                    .border(Color.black, width: 1.5)
                    .frame(width: 50, height: 30)
            }
            Divider()</pre>
<p>The code calls <a id="_idIndexMarker732"/>the <code>addCheckmark</code> struct, and a checkmark is added to each button when pressed.</p>
<p>If you now run the app from <code>ContentView</code>, you will see that you can press the information button to bring up the settings screen, select a language, and then dismiss the screen by sliding it down. </p>
<div><div><img alt="Figure 13.3: The language buttons complete " src="img/B18674_13_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3: The language buttons complete</p>
<p>Also, if you stop the app <a id="_idIndexMarker733"/>and run it again, note that your selection choice will remain, as we store these settings internally in user defaults by using the <code>@AppStorage</code> property wrapper in the data model.</p>
<p>We’re just about done with the settings view, but I’d like to add one more modification here – how about giving the user another way of dismissing the settings screen by adding a dismiss button, instead of just sliding down from the top?</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor193"/>Adding a dismiss button</h2>
<p>For the dismiss<a id="_idIndexMarker734"/> button, we’ll need a property that can access the app’s environment. The environment is the part of the app that is generated automatically for us, and it’s where we can access system-wide settings such as the color scheme or layout direction.</p>
<p>It’s in this environment where we need to dismiss a screen, and to do so, we first need to create a variable using the <code>@Environment</code> wrapper. Add this underneath the <code>ObservedObject</code> property at the top of the <code>SettingsView</code> file:</p>
<pre class="source-code">
//dismiss the SettingsView
    @Environment(\.presentationMode) var presentationMode</pre>
<p>Now, we will use this property to dismiss the view. Add this final <code>HStack</code> just after the closing brace of the last <code>HStack</code> in the file:</p>
<pre class="source-code">
          //MARK: - DISMISS BUTTON
             HStack(alignment: .center) {
                Spacer()
                
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }){
                    HStack {
                        Image(systemName: "checkmark")
                        Text("Done")
                            .padding(.horizontal, 5)
                    }.padding(8)
                        .shadow(color: .black, radius: 1, 
                          x: 1, y: 1)
                }.foregroundColor(Color.white)
                    .background(Color.green)
                     .cornerRadius(20).shadow(color: 
                       .black, radius: 1, x: 1, y: 1)
                    .buttonStyle(ButtonFlash())
                
               Spacer()
            }</pre>
<p>Firstly, we used two <code>Spacer</code> instances at the top and bottom of the code to align the button in the center of this <code>HStack</code>.</p>
<p>Inside the button, the <code><a id="_idIndexMarker735"/></code><code>presentationMode</code> property on the <code>wrappedValue</code> property will gain access to the setting screen data, and then a call to the <code>dismiss</code> function will close the settings screen.</p>
<p>The button is styled with a checkmark, and the text says <code>ButtonFlash</code> function so that it flashes like the other buttons.</p>
<p>Now, run the app from <code>ContentView</code>, and you can see that the dismiss button works perfectly:</p>
<div><div><img alt="Figure 13.4: The Done button " src="img/B18674_13_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4: The Done button</p>
<p>This <a id="_idIndexMarker736"/>completes <code>SettingsView</code>. Let’s go back to <code>ContentView</code> and continue styling the UI.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor194"/>Styling the UI</h1>
<p>In <code>ContentView</code>, let’s add some<a id="_idIndexMarker737"/> more features for the user; we’ll a background, some animations <a id="_idIndexMarker738"/>to the game, as well as a word count and language display label. Adding some more styling will help the UI come alive.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor195"/>Adding the background</h2>
<p>We’ll start by adding a<a id="_idIndexMarker739"/> background to the scene. We currently have a title and buttons that are styled with a wooden look, so let’s continue the wooden theme and use a wood image as a background. Add the following code after the closing brace of <code>VStack</code>:</p>
<pre class="source-code">
    .background(Image("background").resizable()
          .edgesIgnoringSafeArea([.all])
          .aspectRatio(contentMode: .fill)
          .frame(width: 500, height: 800))</pre>
<p>This code sets a wooden image as the background and uses the <code>edgesIgnoringSafeAreas</code> modifier to stretch the background out to fill the screen. Also, the aspect ratio is set to <code>fill</code>, and it sets a frame to size this background image:</p>
<div><div><img alt="Figure 13.5: A wooden background " src="img/B18674_13_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5: A wooden background</p>
<p>The background looks<a id="_idIndexMarker740"/> good, but it does introduce a small problem – we need to change the color and size of the <code>wordToPlayFrom</code> property, as its black color makes it hard to see against the wood background. Let’s do that now. Just after the button code, we can style this <code>Text</code> view to make it look better:</p>
<pre class="source-code">
     //MARK: - WORD TO PLAY FROM
      Text("\(wordToPlayFrom)")
          .font(.custom("HelveticaNeue-Medium", size: 38))
          .foregroundColor(.white)
          .shadow(color: .black, radius: 1, x: 1, y: 1)</pre>
<p>The code adds a custom <code>Helvetica</code> font with a size of <code>38</code> points, while changing the color of the text to<a id="_idIndexMarker741"/> white and adding a shadow so that it stands out a little more. This is what it looks like:</p>
<div><div><img alt="Figure 13.6: The styled base word " src="img/B18674_13_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6: The styled base word</p>
<p>That looks much clearer now!</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor196"/>Adding animations to the game word</h2>
<p>How about we also add<a id="_idIndexMarker742"/> some animation to the new word? We can use the <code>scaleEffect</code> modifier to flip the word horizontally as it comes into view. </p>
<p>Let’s first add a property to track this animation, right after the other properties in <code>ContentView</code>:</p>
<pre class="source-code">
    @State private var horizontalFLip = false</pre>
<p>Now, in the <code>WORD TO PLAY FROM</code> Pragma Mark, and right after the <code>shadow</code> modifier, add the following code:</p>
<pre class="source-code">
            .scaleEffect(x: horizontalFLip ? -1 : 1, y: 1)
            .scaleEffect(x: horizontalFLip ? -1 : 1, y: 1)
            .animation(.spring(dampingFraction:0.8),value: 
              horizontalFLip)</pre>
<p>By calling the <code>scaleEffect</code> modifier twice, each call will flip the text horizontally by 180° so that it completely makes one revolution, horizontally, as it enters the screen. It also gets a <code>spring</code> animation applied to it, which will make it grow and shrink just a little bit; you can control the growth and shrinkage by setting the <code>dampingFraction</code> parameter to a lower or higher value. </p>
<p>As well as this, we want the animation to start when the button is pressed because that’s when a new word appears on the screen, so let’s toggle the <code>horizontalFlip</code> Boolean inside the button:</p>
<pre class="source-code">
//MARK: - BUTTON
      Button(action: {
          appData.getRandomWord()
          wordToPlayFrom = appData.baseWord
<strong class="bold">          horizontalFLip.toggle()</strong>
      }){</pre>
<p>Before we try it out, let’s go a bit further with the new incoming word – we’ll add pointing hands on each side of the new word and add a <code>spring</code> animation as well. Let’s put the <code>Text</code> view that is displaying <code>wordToPlayFrom</code> into <code>HStack</code>, like this:</p>
<pre class="source-code">
<strong class="bold">HStack {</strong>
      Text(wordToPlayFrom)
          .font(.custom("HelveticaNeue-Medium", size: 38))
          .foregroundColor(.white)
          .shadow(color: .black, radius: 1, x: 1, y: 1)
          .scaleEffect(x: horizontalFLip ? -1 : 1, y: 1)
          .scaleEffect(x: horizontalFLip ? -1 : 1, y: 1)
          .animation(.spring(dampingFraction:0.8),value: 
            horizontalFLip)
<strong class="bold">  }</strong></pre>
<p>Next, let’s add some <a id="_idIndexMarker743"/>pointing hand images that will point to the word to play from. The first image is the system image called <code>hand.point.right</code>, and it <a id="_idIndexMarker744"/>goes inside <code>HStack</code> just above the <code>Text</code> view code, and the next image is called the <code>hand.point.left</code> image, which gets placed below the <code>Text</code> view code, again, all inside the <code>HStack</code> view we just added:</p>
<pre class="source-code">
//MARK: - WORD TO PLAY FROM
 HStack () {
<strong class="bold">      //right hand image</strong>
<strong class="bold">      Image(systemName: "hand.point.right")</strong>
<strong class="bold">          .foregroundColor(.black)</strong>
<strong class="bold">          .font(.system(size: 30))</strong>
<strong class="bold">          .animation(.spring(dampingFraction:0.2),value: </strong>
<strong class="bold">            horizontalFLip)</strong>
      
      Text(wordToPlayFrom)
          .font(.custom("HelveticaNeue-Medium", size: 38))
          .foregroundColor(.white)
          .shadow(color: .black, radius: 1, x: 1, y: 1)
          .scaleEffect(x: horizontalFLip ? -1 : 1, y: 1)
          .scaleEffect(x: horizontalFLip ? -1 : 1, y: 1)
          .animation(.spring(dampingFraction:0.8),value: 
            horizontalFLip)
      
  <strong class="bold">    //left hand image</strong>
<strong class="bold">      Image(systemName:"hand.point.left")</strong>
<strong class="bold">         .foregroundColor(.black)</strong>
<strong class="bold">         .font(.system(size: 30))</strong>
<strong class="bold">         .padding(-4)</strong>
<strong class="bold">         .animation(.spring(dampingFraction:0.2),value: </strong>
<strong class="bold">           horizontalFLip)</strong>
  }</pre>
<p>The code starts off with <a id="_idIndexMarker745"/>a system image of a hand that’s pointing right, setting the foreground color to black and setting the image size by using the <code>font</code> modifier. Then, we add the spring animation to it, which has a damping fraction of <code>.4</code> (again, the larger the value, the less spring animation there will be).</p>
<p>Then, we go to the left-hand image and do the same thing, setting its size and color, as well as a little padding to position it a bit more to the left. Also, the <code>value</code> parameter in the <code>spring</code> animation will be the <code>horizontalFlip</code> Boolean property and toggled inside the button’s body, which is how the animation gets triggered.</p>
<p>Now, give the app another go – you’ll see that every time you hit the button to add a new word, not only does the word flip horizontally, and stretch and shrink, but also the two hands bounce in and out as the word enters the <a id="_idIndexMarker746"/>screen:</p>
<div><div><img alt="Figure 13.7: Animating the base word, plus the hand images " src="img/B18674_13_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7: Animating the base word, plus the hand images</p>
<p>Before we continue with more enhancements, let’s fix one issue we have, which is that the <code>letterCount</code> string only appears on the UI when the button is pressed. It's much better to always have it on the UI and just update it when the button is pressed. We can fix that with one line of code, a call to the <code>getRandomWord</code> function in <code>ContentView</code>. Let’s add that call down at the bottom of <code>VStack</code>, just after the <code>frame</code> modifier of the background:</p>
<pre class="source-code">
.onAppear (perform: appData.getRandomWord)</pre>
<p>The <code>onAppear</code> modifier will call the <code>getRandomWord</code> function and populate the <code>letterCount</code> string so that it always stays on the screen:</p>
<div><div><img alt="Figure 13.8: The word length and flag string displayed " src="img/B18674_13_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8: The word length and flag string displayed</p>
<p>Next, we need<a id="_idIndexMarker747"/> to implement the alert system to give the user feedback about any words that don’t get accepted into the list.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor197"/>Implementing user feedback with alerts</h1>
<p>The user can get<a id="_idIndexMarker748"/> a random word and try and make some words out of that word in the language of their choice, but there are certain checks that we’ve put in place that will stop those words from entering the list. Now, we need to let the user know why a certain word is not acceptable, using SwiftUI alerts.</p>
<p>Let’s go back into <code>DataModel</code> and fill out the <code>displayErrorMessage</code> function stub with the appropriate code to get a message alert. Add the following code right into the method:</p>
<pre class="source-code">
//error message
    func displayErrorMessage(messageTitle: String, 
      description: String) {
        errorTitle = messageTitle
        errorDescription = description
        errorMessageIsShown = true
    }</pre>
<p>The code takes the <code>messageTitle</code> string and assigns it to the <code>errorTitle</code> property. Then, it takes the description string and assigns it to the <code>errorDescription</code> property. After that, the <code>errorMessagesIsShown</code> Boolean is set to <code>true</code> because <a id="_idIndexMarker749"/>at this point the function has been triggered, and we’ll need to have this property set to <code>true</code> in order to initiate the alert message.</p>
<p>Next, the <code>displayErrorMessage</code> function needs to be called in the right place. If you remember from when we set up the <code>addWordToListist</code> method earlier and added the method stubs in the data model, we also made a call to the <code>displayErrorMessage</code> method. Here is a look at the complete <code>addWordToList</code> method that has a call to <code>displayErrorMessage</code>, so there is nothing for us to do there:</p>
<pre class="source-code">
    func addWordToList() {
    let usersWord = 
      userEnteredWord.lowercased().trimmingCharacters(in: 
      .whitespacesAndNewlines)
    
    //guard against single letter words – they are too easy
    guard usersWord.count &gt; 1 else {
        return
    }
    //is the word a duplicate
    guard isWordDuplicate(word: usersWord) else {
        <strong class="bold">displayErrorMessage(messageTitle: "You already used </strong>
<strong class="bold">          this word", description: "Keep looking!")</strong>
        return
    }
    //is the word possible given your base word letters to 
      work with?
    guard isWordFoundInBaseWord(userGuessWord: usersWord)
      else {
<strong class="bold">        displayErrorMessage(messageTitle: "This word is not </strong>
<strong class="bold">          possible", description: "Create only words from </strong>
<strong class="bold">          the letters in the given word")</strong>
        return
    }
    //is the word a real word in the dictionary? - only 
      real words are allowed
    guard isWordInDictionary(word: usersWord) else {
        <strong class="bold">displayErrorMessage(messageTitle: "This is not a </strong>
<strong class="bold">          valid word", description: "Use only real words")</strong>
        return
    }
    userEnteredWordsArray.insert(usersWord, at: 0)
    userEnteredWord = ""
  }</pre>
<p>Here’s a quick refresher on how the <code>addNewWord</code> function works. </p>
<p>First, the word is made lowercase – that’s because all the word files are lowercase, and it’s how we can compare words. Then, we trim out any whitespaces that they might have typed into the text field. </p>
<p>The next line of code guards against single-letter words – again, there is only a handful of those in any given language, and there’s no point in including them in the game here.</p>
<p>Then, we start to check the user’s word to see whether it’s a duplicate word. If it is, that means they added that word to the list already, so the <code>displayErrorMessage</code> function will display an error message of <strong class="bold">You already used this word</strong>, along with an instruction that says <strong class="bold">Keep looking</strong>.</p>
<p>The next <code>guard</code> statement checks whether the word is even possible to make, given the letters the user is working with. If it’s not possible, the <code>displayErrorMessage</code> function will be<a id="_idIndexMarker750"/> called and display the <strong class="bold">This word is not possible</strong> error, along with an instruction that says <strong class="bold">Create only words from the letters in the </strong><strong class="bold">given word</strong>.</p>
<p>Next, the <code>displayErrorMessage</code> function will be called if the word is not a real word in the chosen language, showing the user an alert that says <strong class="bold">This is not a valid word</strong>, along with an instruction that says <strong class="bold">Use only </strong><strong class="bold">real words</strong>.</p>
<p>Finally, after the user’s word has been processed and gone through all those checks, it’s entered into <code>userEnteredWordsArray</code>. Remember, an array’s elements are indexed, starting from 0, which is the beginning of the array. The index is how we access different elements in an array, so in the <code>insert(at)</code> method, we pass in the “<code>0</code>” value, which means inserting the user’s word into the list at the beginning of the list, the top. This way, as the user enters words, they will always be placed at the top of the list so they are visible on the screen, and if there are many words, the user can scroll up through the list to see them.</p>
<p>The final line of code sets the user-entered word back to an empty string, ready to start the process again.</p>
<p>Now that we have the error alerts all set up, we just need to add the <code>alert</code> modifier to make it functional. We can add it right after the <code>onAppear</code> modifier in <code>ContentView</code>, like this:</p>
<pre class="source-code">
     //add the alert popup
    .alert(isPresented: $appData.errorMessageIsShown) {
        Alert(title: Text(appData.errorTitle), message: 
          Text(appData.errorDescription), dismissButton: 
          .default(Text("OK")))
    }</pre>
<p>The <code>alert</code> modifier has a parameter called <code>isPresented</code>, and this will present an alert message when the <code>errorMessageIsShown</code> Boolean variable becomes <code>true</code>. When it does become <code>true</code>, the code in the alert body – this being the error title and description – gets executed.</p>
<p>Now, try it out. Enter <a id="_idIndexMarker751"/>a word that is already in the list, and you should see a popup like this:</p>
<div><div><img alt="Figure 13.9: An alert message for duplicate words " src="img/B18674_13_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9: An alert message for duplicate words</p>
<p>If you enter a word that is not possible given the letters you have, you will see this alert:</p>
<div><div><img alt="Figure 13.10: An alert message for words that are not possible using the given word " src="img/B18674_13_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10: An alert message for words that are not possible using the given word</p>
<p>And finally, if you enter <a id="_idIndexMarker752"/>a word that does not exist in the chosen language’s dictionary, you will see this alert:</p>
<div><div><img alt="Figure 13.11: An alert message for words that are not real " src="img/B18674_13_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11: An alert message for words that are not real</p>
<p>Now, we have three <a id="_idIndexMarker753"/>different checks on the user’s words, just to give them feedback and let them know where they went wrong. The user can then press the <strong class="bold">OK</strong> button to dismiss the alert and continue playing.</p>
<p>Let’s now continue with the UI and add a footer view to display some more information about the user’s progress in the game.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor198"/>Adding a Footer View to display more information</h1>
<p>The Footer view that <a id="_idIndexMarker754"/>we will add will <a id="_idIndexMarker755"/>contain two pieces of information – first, how many words the user has found so far, and second, what their letter average is for each found word. </p>
<p>To do this, create a<a id="_idIndexMarker756"/> new <code>FooterView</code>. This will contain the <code>Text</code> views we need to display that information.</p>
<p>Now let’s get to work and add some code. Add the following properties inside the <code>FooterView</code> struct: </p>
<pre class="source-code">
struct FooterView: View {
    //MARK: - PROPERTIES
    @ObservedObject var appData = DataModel()
    @Binding var userEnteredWordsArray: [String]
    
    var foundWords: Double {
        let wordCount = userEnteredWordsArray.count
        //if theres no words in the array, return 0
        if wordCount == 0 {
            return 0
        }
        var letterAverage = 0
        //get a total of all the letters in each word
        for letterCount in userEnteredWordsArray {
            letterAverage += letterCount.count
        }
        return Double(letterAverage / wordCount)
    }
•••••••</pre>
<p>As you recall, when we add a <code>Binding</code> variable to a struct, we need to include it in the <code>Previews</code> struct; otherwise, we will get an Xcode error. Modify the <code>Previews</code> struct as such to keep Xcode happy:</p>
<pre class="source-code">
struct FooterView_Previews: PreviewProvider {
    static var previews: some View {
      FooterView( userEnteredWordsArray: .constant(["0"]))
          .previewLayout(.fixed(width: 350, height: 125))
  }</pre>
<p>Okay, we are now error-free, so let’s go back to the <code>FooterView</code> struct and review the code we just added there.</p>
<p>There’s a <code>userEnteredWordsArray</code> property that we will use to bind to the <code>ContentView</code> s<a id="_idTextAnchor199"/>truct later.</p>
<p>Next, we have a <a id="_idIndexMarker757"/>computed <a id="_idIndexMarker758"/>property called <code>foundWords</code>. A computed<a id="_idIndexMarker759"/> property is a property that has a body and runs code in its body when the property is accessed. The <code>foundWords</code> property displays how many words the user has found so far by using the <code>count</code> property, which will return the number of elements in <code>userEnteredWordsArray</code>. If there are no words in the array, it will return <code>0</code>.</p>
<p>Next, inside the <code>foundWords</code> computed property, we create a variable called <code>totalLetters</code> and use it to hold all the letters of the user’s word. To get all those letters, we use a <code>for in</code> loop to iterate through the array, storing the amount of letters from each word the user enters on the list back in the <code>totalLetters</code> va<a id="_idTextAnchor200"/>riable. </p>
<p>Finally, the <code>foundWords</code> computed property returns all the letters from every word divided by the number of words entered, which returns the average amount of letters per word.</p>
<p>Now, let’s go into the <code>body</code> property and start designing two text views that will display this information. Add the following code:</p>
<pre class="source-code">
VStack {
    HStack(spacing: 80) {
        ZStack {
            Image("background").resizable()
            .frame(width: 80, height: 50)
            .clipShape(Capsule())
            .shadow(color: .black, radius: 1, x: 1, y: 1)
            .shadow(color: .black, radius: 1, x: -1, y: -1)
            
            Text("\(userEnteredWordsArray.count)")
            .frame(width: 50, height: 20)
            .font(.system(size: 25))
            .padding(20)
            .foregroundColor(.white)
            .font(.system(size: 80))
               
            
            Image("foundWords").resizable()
            .aspectRatio(contentMode: .fill).frame(width: 
              100, height: 70)
            .shadow(color: .black, radius: 1, x: 1, y: 1)
            .offset(y: 40)
            .padding(.horizontal, -10)
            .padding(.bottom, -10)
         }
     }
         }</pre>
<p>The first thing we do is <a id="_idIndexMarker760"/>style the<a id="_idIndexMarker761"/> background that the text will be placed over. We use the <code>background</code> image from Assets catalog and set its size to a width of <code>80</code> points and a height of <code>50</code> points. Then, we use the <code>clipShape</code> modifier to turn the rectangle into a capsule and add some shadow to the image. Note that we’re using the <code>shadow</code> modifier twice here – this gives the image a more defined border than just a single call would.</p>
<p>Next, the text gets added, and by calling the <code>count</code> property on <code>textField</code>, we can show how many words the user has found so far. Then, we set the font size and add some padding and a foreground color of white.</p>
<p>We’re putting the images all inside three stacks: </p>
<ul>
<li>First, inside <code>VStack</code> to hold all of the views vertically on the screen and line them up accordingly </li>
<li>Then, inside <code>HStack</code>, which will put the two <code>textField</code> instances we need side by side horizontally</li>
<li>Finally, <code>ZStack</code> so that we can position the text directly over the background image</li>
</ul>
<p>Finally, we add the <code>foundWords</code> image, size it up, and give it a little bit of shadow and some padding so that we can offset it downward from the text.</p>
<p>Now, we can add the<a id="_idIndexMarker762"/> other text, which will display the average amount of letters per word. Just after the closing bracket of the <code>ZStack</code>, add the following code:</p>
<pre class="source-code">
ZStack {
        Image("background").resizable()
            .frame(width: 80, height: 50)
            .clipShape(Capsule())
            .shadow(color: .black, radius: 1, x: 1, y: 1)
            .shadow(color: .black, radius: 1, x: -1, y: -1)
            
        Text("\(foundWords, specifier: "%.0f")")
            .frame(width: 50, height: 20)
            .font(.system(size: 25))
            .padding(20)
            .foregroundColor(Color.white)
            .font(.system(size: 80))
            
        Image("letterAverage").resizable()
            .aspectRatio(contentMode: .fill)
            .shadow(color: .black, radius: 1, x: 1, y: 1)
            .frame(width: 100, height: 70)
            .offset(y: 40)
            .padding(.bottom, -10)
    }</pre>
<p>This code replicates the previous <code>Text</code> view we added, only this time we’re displaying the <code>foundWords</code> computed <a id="_idIndexMarker763"/>property, which<a id="_idIndexMarker764"/> will show the letter average from the <code>foundWords</code> array, and using the format specifier, it will format the text view to two decimal places.</p>
<p>Now, we can call <code>FooterView</code> inside <code>ContentView</code>. Let’s go back there and add a call to <code>FooterView</code> at the end of the code in the main <code>VStack</code>:</p>
<pre class="source-code">
//MARK: - FOOTER VIEW
    FooterView(userEnteredWordsArray: 
      $appData.userEnteredWordsArray)</pre>
<p>Now, go ahead and try the app. Every word that you enter into the list will be counted on the bottom-left side of the screen, and the average amount of letters per word that you are getting will be displayed on the bottom-right side:</p>
<div><div><img alt="Figure 13.12: Displaying the found words and letter average " src="img/B18674_13_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12: Displaying the found words and letter average</p>
<p>From the figure, we can see that the given random word is <strong class="bold">cambering</strong>, and I found 4 related words so far, so the footer view displays those <strong class="bold">4</strong> found words. The letter average for<a id="_idIndexMarker765"/> those<a id="_idIndexMarker766"/> words is also displayed, <strong class="bold">4</strong> letters per word.</p>
<p>Before we move on to more feedback, let’s just do one more check in the <code>addWordToList</code> function. I want to be able to stop the user from entering single-letter words, and that’s very easy to do. There are many single-letter words in any given language, so it’s not really a big deal, but we might as well prevent them anyway. Code inside the <code>addWordToList</code> function just after <code>userWord</code> is declared:</p>
<pre class="source-code">
//guard against one letter words - they are too easy
        guard usersWord.count &gt; 1 else {
            return
        }</pre>
<p>We’re checking the count of <code>usersWord</code> to see whether it’s greater than 1; if not, we won’t allow single-letter words in the list and the function will just return right here. Give it a try and you’ll <a id="_idIndexMarker767"/>see <a id="_idIndexMarker768"/>that you cannot enter single-letter words.</p>
<p>Up next, in the spirit of giving the user feedback, we’ll continue and add haptics and audio to the game.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor201"/>Adding haptics and button sounds</h1>
<p>Haptics are a form<a id="_idIndexMarker769"/> of sensory feedback that works by accessing the internal vibration hardware on an iPhone, providing a physical response when the phone is being used. You are probably <a id="_idTextAnchor202"/>familiar with haptics, as it’s felt every time we set our phones to vibrate. We won’t use a full vibration but just a brief one that the user can feel every time they click on a button.</p>
<p>The best place to add such code is in the button itself, so let’s do that. We’re going to use the <code>UIImpactFeedbackGenerator</code> class for this, and it is actually quite simple to implement. First, inside <code>ContentView</code>, we need an instance of that class underneath all the properties that we already added:</p>
<pre class="source-code">
//haptic feedback
var hapticImpact = UIImpactFeedbackGenerator(style: 
  .medium)</pre>
<p>We have set the <code>hapticImpact</code> variable style to <code>medium</code>, but you can set the vibration to <code>heavy</code>, <code>light</code>, <code>ridged</code>, or <code>soft</code>.</p>
<p>Now, to use this, we just simply call this variable inside the button like this:</p>
<pre class="source-code">
            //MARK: - BUTTON
            Button(action: {
                <strong class="bold">hapticImpact.impactOccurred()</strong>
                appData.getRandomWord()
             
                   •••••••          </pre>
<p>And that’s it – every time the <strong class="bold">New Word</strong> button is pressed, the user will feel a slight vibration on their finger. In order to try this out, you actually have to run this on a device, as you cannot use haptics in the simulator.</p>
<p>Since we’ve implemented haptics here with the <code>ContentView</code> button, how about we also add it to the <code>SettingsView</code> language buttons? Let’s go into <code>SettingsView</code> and add the same code as we did here. First, create an instance of the <code>UIImpactFeedbackGenerator</code> class at the top of the file, in <code>SettingsView</code>:</p>
<pre class="source-code">
    //haptic feedback
       var hapticImpact = UIImpactFeedbackGenerator(style: 
         .light)</pre>
<p>Now, in each of the three language buttons, add the following code:</p>
<pre class="source-code">
hapticImpact.impactOccurred()</pre>
<p>And that’s it – it’s very easy to implement tactile feedback for the user.</p>
<p>And how about one other form of feedback that we are already familiar with – audio? We can add a button click sound to the <strong class="bold">New Word</strong> button, so not only does the user feel the button being pressed but they also hear it.</p>
<p>We have already<a id="_idIndexMarker770"/> done this several times, so for the sake of brevity, I won’t go over the code; instead, you can simply refer back to many of the other projects in which we’ve added audio (such as our record player project).</p>
<p>As we always do, we create a <a id="_idIndexMarker771"/>new <code>PlaySound</code> and add the following code to the file:</p>
<pre class="source-code">
import Foundation
import AVFoundation
var player: AVAudioPlayer?
func playSound(sound: String, type: String) {
    if let path = Bundle.main.path(forResource: sound, 
      ofType: type) {
        do {
        player = try AVAudioPlayer(contentsOf: 
          URL(fileURLWithPath: path))
        player?.play()
        
        } catch {
            print("Could not load audio file")
        }
    }
}</pre>
<p>Now that we have our sound file, all we need to do is use it inside the body of the <strong class="bold">New </strong><strong class="bold">Word</strong> button:</p>
<pre class="source-code">
playSound(sound: "buttonClick", type: "m4a")</pre>
<p>And that completes the sound. </p>
<p>Now, the user has three forms of feedback when they press the <strong class="bold">New Word</strong> button – they see the button being pressed because, during the press, the button changes its form, they feel the <a id="_idIndexMarker772"/>impact with their finger because we accessed the internal vibration motor of the phone, and they hear a clicking sound. This feedback all comes together to give the user a more enriched and tactile experience when interacting with the app.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor203"/>Summary</h1>
<p>In this project, we built a complete app from start to finish and included different animations along the way.</p>
<p>We organized properties and functions in a data model, created separate header and footer views, implemented a picker control, and created some specific functions that can process and check a word’s authenticity within three different languages. We also implemented user feedback in three different ways – in the form of pop-up alerts to the user, in the form of haptic feedback, and as audio. Plus, we’ve added three languages to the game to make it educational for users learning languages. </p>
<p>How about taking the gamer further by adding some more animations to it, by revisiting previous projects and using code that you already implemented into different areas of the game? For example, if the user gets a certain number of words in their list, they could be rewarded with points that get displayed in an animated label at the top. Alternatively, we could add another button that will ask the user to find only words that are palindromes.</p>
<p>In the next chapter, we will build another game – this time, a color-matching game.</p>
</div>
<div><div></div>
</div>
</body></html>