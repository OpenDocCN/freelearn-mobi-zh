- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Building the UI for Your Messaging App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的消息应用构建 UI
- en: In this first chapter, we’re going to start building a messaging app called
    WhatsPackt (referring to a popular messaging app that you probably already know
    about). At this point in the project, we must make some important technical decisions
    and create the structure needed to build it. This is what we will be focusing
    on, as well as working on the app’s user interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将开始构建一个名为 WhatsPackt 的消息应用（指的是您可能已经了解的一个流行的消息应用）。在这个项目的这个阶段，我们必须做出一些重要的技术决策并创建构建它所需的结构。这是我们关注的重点，以及我们将在应用的用户界面上进行工作。
- en: By the end of this chapter, you will have hands-on experience creating a messaging
    app from scratch, organizing and defining the app modules, deciding which dependency
    injection framework you will use, using Jetpack Navigation to navigate between
    the app features, and using Jetpack Compose to build the main parts of the user
    interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将获得从零开始创建消息应用的实际经验，组织并定义应用模块，决定您将使用哪个依赖注入框架，使用 Jetpack Navigation 在应用功能之间导航，以及使用
    Jetpack Compose 构建用户界面的主要部分。
- en: 'This chapter is organized into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章组织了以下主题：
- en: Defining the app structure and navigation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用结构和导航
- en: Building the main screen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建主屏幕
- en: Building the chats list
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建聊天列表
- en: Building the messages list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建消息列表
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Android Studio is the official standard **integrated development environment**
    (**IDE**) for developing Android apps. Although you can use other IDEs, editors,
    and Android tools if you prefer, all the examples in this book will be based on
    this IDE.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 是官方标准的 **集成开发环境**（**IDE**）用于开发 Android 应用。尽管如果您愿意，可以使用其他 IDE、编辑器和
    Android 工具，但本书中的所有示例都将基于此 IDE。
- en: 'For that reason, we recommend that you set up your computer with the latest
    stable version of Android Studio installed. If you haven’t already, you can download
    it here: [https://developer.android.com/studio](https://developer.android.com/studio).
    By following the installation steps, you will be able to install the IDE and set
    up at least one emulator with one Android SDK installed.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议您使用安装了最新稳定版 Android Studio 的计算机。如果您还没有安装，可以在此处下载：[https://developer.android.com/studio](https://developer.android.com/studio)。按照安装步骤，您将能够安装
    IDE 并设置至少一个安装了 Android SDK 的模拟器。
- en: 'Once installed, we can start creating the project. Android Studio will offer
    us a set of templates to start with. We will choose the **Empty Activity** option,
    as shown in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以开始创建项目。Android Studio 将提供一系列模板以供选择。我们将选择 **Empty Activity** 选项，如图下截图所示：
- en: '![Figure 1.1: Android Studio new project template selection with the Empty
    Activity option selected](img/B19443_01_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：选择 Empty Activity 选项的 Android Studio 新项目模板](img/B19443_01_1.jpg)'
- en: 'Figure 1.1: Android Studio new project template selection with the Empty Activity
    option selected'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：选择 Empty Activity 选项的 Android Studio 新项目模板
- en: 'You will then be asked to select a project and package name:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将被要求选择项目名称和包名称：
- en: '![Figure 1.2: Android Studio – adding a new project name and package name](img/B19443_01_2.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：Android Studio – 添加新项目名称和包名称](img/B19443_01_2.jpg)'
- en: 'Figure 1.2: Android Studio – adding a new project name and package name'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：Android Studio – 添加新项目名称和包名称
- en: 'After that, you’re all set! Android Studio will generate the main folders and
    files needed so that you can start working on our project. Your project structure
    should look as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您就准备就绪了！Android Studio 将生成所需的主要文件夹和文件，以便您可以开始我们的项目。您的项目结构应如下所示：
- en: '![Figure 1.3: Android Studio – project template structure](img/B19443_01_3.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：Android Studio – 项目模板结构](img/B19443_01_3.jpg)'
- en: 'Figure 1.3: Android Studio – project template structure'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：Android Studio – 项目模板结构
- en: 'Note that all the code for this chapter can be found in this book’s GitHub
    repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章的所有代码都可以在这个书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt)。
- en: 'Now, we are ready to start coding our new messaging app. To do so, we will
    have to make some important technical decisions: we will have to decide how our
    project is going to be structured, how we will navigate between the different
    screens or features, and how we are going to set and provide the components needed
    (defining and organizing the dependencies between every component).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始编码我们的新消息应用。为此，我们必须做出一些重要的技术决策：我们必须决定我们的项目将如何结构化，我们将如何在不同屏幕或功能之间导航，以及我们将如何设置和提供所需的组件（定义和组织每个组件之间的依赖关系）。
- en: Defining the app structure and navigation
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用结构和导航
- en: 'Before designing the app structure, we must have a basic idea of the features
    it should include. In our case, we want to have the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用结构之前，我们必须对它应包含的基本功能有一个基本的概念。在我们的案例中，我们希望有以下功能：
- en: A main screen to create new or access already existing conversations
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新对话或访问已存在的对话的主屏幕
- en: A list containing all the conversations
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有对话的列表
- en: A screen for a single conversation
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个对话的屏幕
- en: As this is going to be a production-ready app, we must design its code base
    while considering that it should be easy to scale and maintain. In that regard,
    we should use modularization.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个即将投入生产的应用，我们必须在设计代码库时考虑到它应该易于扩展和维护。在这方面，我们应该使用模块化。
- en: Modularization
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化
- en: '**Modularization** is the practice of dividing the code of an application into
    loosely coupled and self-contained parts, each of which can be compiled and tested
    in isolation. This technique allows developers to break down large and complex
    applications into more manageable parts that are easier to maintain.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化**是将应用程序的代码划分为松散耦合且自包含的部分的实践，每个部分都可以独立编译和测试。这种技术允许开发者将大型和复杂的应用程序分解成更易于维护的更小部分。'
- en: By modularizing Android applications, modules can be built in parallel, which
    can significantly improve build time. Additionally, independent modules can be
    tested separately, which makes it easier to identify and correct errors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模块化Android应用程序，模块可以并行构建，这可以显著提高构建时间。此外，独立的模块可以单独测试，这使得识别和纠正错误变得更加容易。
- en: While the most common way to create modules in Android development is by utilizing
    the Android libraries system via Gradle dependencies, alternative build systems
    such as Bazel and Buck also facilitate modularization. Bazel provides a robust
    system for declaring modules and dependencies, and its parallelized building capabilities
    can lead to even faster build times. Similarly, Buck also supports modular development
    by providing fine-grained build rules and speeding up incremental builds.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Android开发中创建模块最常见的方法是通过Gradle依赖项利用Android库系统，但Bazel和Buck等替代构建系统也促进了模块化。Bazel提供了一个强大的系统来声明模块和依赖项，其并行构建能力可以导致更快的构建时间。同样，Buck也通过提供细粒度的构建规则和加速增量构建来支持模块化开发。
- en: By exploring various build systems, such as Gradle, Bazel, and Buck, developers
    can find the most suitable modular approach to structure their Android applications.
    Each build system offers unique features for managing dependencies and organizing
    code, enabling developers to implement various patterns to achieve a modular architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索各种构建系统，如Gradle、Bazel和Buck，开发者可以找到最适合其Android应用程序的模块化方法。每个构建系统都提供独特的功能来管理依赖项和组织代码，使开发者能够实现各种模式以实现模块化架构。
- en: Among the organizational patterns, the most common ones are modularization by
    layers and modularization by feature modules.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织模式中，最常见的是按层进行模块化和按功能模块进行模块化。
- en: Modularization by layers
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层次模块化
- en: It is common to structure an app by grouping its components based on a set of
    layers depending on the architecture chosen by the developers. One popular architecture
    is clean architecture, which splits the code base between the data, domain (or
    business), and presentation layers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，根据开发者选择的架构，通过将组件分组到一系列层中来结构化应用。一个流行的架构是清洁架构，它将代码库分为数据、领域（或业务）和表示层。
- en: 'With this approach, each module focuses on a specific layer of the architecture,
    such as the presentation layer, domain layer, or data layer. These modules are
    usually more independent of each other and may have different responsibilities
    and technologies, depending on the layer they belong to. Following this pattern,
    our app structure would look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，每个模块都专注于架构的特定层，例如表示层、领域层或数据层。这些模块通常彼此之间更加独立，并且可能根据它们所属的层具有不同的责任和技术。遵循此模式，我们的应用结构将如下所示：
- en: '![Figure 1.4: App modularization by layers](img/B19443_01_4.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4：按层进行应用模块化](img/B19443_01_4.jpg)'
- en: 'Figure 1.4: App modularization by layers'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：按层进行应用模块化
- en: From this diagram, you can see why layer modularization is also referred to
    as vertical modularization.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图中，你可以看到为什么层模块化也被称为垂直模块化。
- en: Modularization by feature
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按功能模块化
- en: 'When modularizing an app by feature (or using horizontal modularization), the
    application is divided into modules that focus on specific features or related
    tasks, such as authentication or navigation. These horizontal modules can share
    common components and resources. We can see this structure in the following figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当按功能（或使用横向模块化）对应用进行模块化时，应用被划分为专注于特定功能或相关任务的模块，例如身份验证或导航。这些横向模块可以共享公共组件和资源。我们可以在以下图中看到这种结构：
- en: '![Figure 1.5: App modularization by feature](img/B19443_01_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5：按功能进行应用模块化](img/B19443_01_05.jpg)'
- en: 'Figure 1.5: App modularization by feature'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：按功能进行应用模块化
- en: In our case, we are going to have a main `app` module that will depend on every
    one of the feature modules that our app needs (one for every one of the features
    we are going to implement). Then, every one of the feature modules will also depend
    on two other common modules (in this example, we have divided them into `common`
    and `common_framework`, using the first to include framework-independent code,
    and the second to use code that depends on the Android framework).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将有一个主要的 `app` 模块，它将依赖于我们应用需要的每个功能模块（每个我们将要实现的功能都有一个）。然后，每个功能模块也将依赖于另外两个公共模块（在这个例子中，我们将它们分为
    `common` 和 `common_framework`，第一个用于包含与框架无关的代码，第二个用于使用依赖于 Android 框架的代码）。
- en: One of the main advantages of this pattern is that it can scale with the company
    if it evolves into a feature-based team (where every team is focused on a single
    or group of features). This will enable every team to be responsible for one feature
    module, or a set of feature modules, where they have ownership of the code in
    those modules. It also allows teams to be easily autonomous regarding their problem
    space and features.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的主要优势之一是它可以随着公司的发展而扩展，如果它演变成基于功能的团队（每个团队都专注于单个或一组功能），那么它就可以实现。这将使每个团队负责一个功能模块，或一组功能模块，他们将对这些模块中的代码拥有所有权。这也允许团队在问题空间和功能方面更容易地实现自治。
- en: WhatsPackt modularization
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WhatsPackt 模块化
- en: 'In our WhatsPackt example, we are going to combine both modularization approaches:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 WhatsPackt 示例中，我们将结合两种模块化方法：
- en: We will use a modularization based on features for our features.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用基于功能的模块化来构建我们的功能。
- en: We will use a modularization based on layers for the common modules. This will
    allow us to share common code between the feature modules.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用基于层的模块化来构建公共模块。这将允许我们在功能模块之间共享公共代码。
- en: 'The structure of our modules and its dependencies will be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块的结构及其依赖关系如下所示：
- en: '![Figure 1.6: Our app modules structure and dependencies](img/B19443_01_6.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6：我们的应用模块结构和依赖关系](img/B19443_01_6.jpg)'
- en: 'Figure 1.6: Our app modules structure and dependencies'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：我们的应用模块结构和依赖关系
- en: 'Now, we are going to start creating this structure in Android Studio. To create
    a module, follow these steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始在 Android Studio 中创建这个结构。要创建一个模块，请按照以下步骤操作：
- en: Select **File** | **New...** | **New Module**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **新建...** | **新建模块**。
- en: In the **Create New Module** dialog, choose the **Android** **Library** template.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建新模块**对话框中，选择**Android** **库**模板。
- en: 'Fill in the **Module name**, **Package name**, and **Language** fields, as
    shown here:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写**模块名称**、**包名称**和**语言**字段，如图所示：
- en: '![Figure 1.7: The Create New Module dialog](img/B19443_01_7.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7：创建新模块对话框](img/B19443_01_7.jpg)'
- en: 'Figure 1.7: The Create New Module dialog'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：创建新模块对话框
- en: Click **Finish**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**。
- en: 'We will have to do this same process for all the modules we want to build,
    except for the `:app` module, which should have been already created when we created
    the project. This is going to be our main point of entry to the app. So, we must
    create the following modules:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对所有我们想要构建的模块执行此相同的过程，除了 `:app` 模块，它应该在创建项目时已经创建。这将成为我们进入应用的主要入口点。因此，我们必须创建以下模块：
- en: '**:****common:domain**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:****通用：领域**'
- en: '**:****common:data**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:****通用：数据**'
- en: '**:****common:framework**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:****通用：框架**'
- en: '**:****feature:create_chat**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:****功能：创建聊天**'
- en: '**:****feature:conversations**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:****功能：会话**'
- en: '**:****feature:chat**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:****功能：聊天**'
- en: 'Once we’ve done this, we should have built the following project structure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这些，我们应该已经构建了以下项目结构：
- en: '![Figure 1.8: Project structure, including all modules](img/B19443_01_8.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8：项目结构，包括所有模块](img/B19443_01_8.jpg)'
- en: 'Figure 1.8: Project structure, including all modules'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：项目结构，包括所有模块
- en: 'The next step is to set the dependencies between modules. We will do this in
    the `build.gradle` file of every module. For example, in the `build.gradle` file
    of the `:app` module, include the following code in the `dependencies` section:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置模块之间的依赖关系。我们将在每个模块的 `build.gradle` 文件中执行此操作。例如，在 `:app` 模块的 `build.gradle`
    文件中，在 `dependencies` 部分包含以下代码：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that our app modules are ready, we can start working on the next step:
    dependency injection.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了应用模块，我们可以开始进行下一步：依赖注入。
- en: Dependency injection
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency injection** is a design pattern and technique that’s used in software
    engineering to decouple the objects in an application and reduce dependencies
    between them. In Android, dependency injection involves providing an instance
    of a class or a component to another class, rather than creating it explicitly
    within the class itself.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**是一种在软件工程中用于解耦应用程序中对象并减少它们之间依赖的设计模式和技巧。在 Android 中，依赖注入涉及向另一个类提供一个类或组件的实例，而不是在类内部显式创建它。'
- en: By implementing dependency injection in an Android app, you can make the app’s
    code more modular, reusable, and testable. Dependency injection also helps improve
    the maintainability of the code base and reduce the complexity of the application
    architecture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Android 应用中实现依赖注入，你可以使应用代码更加模块化、可重用和可测试。依赖注入还有助于提高代码库的可维护性并减少应用程序架构的复杂性。
- en: 'Some of the most popular dependency injection libraries that are used in Android
    development are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 开发中使用的最流行的依赖注入库如下：
- en: '**Dagger** ([https://dagger.dev/](https://dagger.dev/)): Dagger is a compile-time
    dependency injection library developed by Google that uses annotations and code
    generation to create a dependency graph that can be used to provide dependencies
    to the app’s components. Its main advantage is that it builds this dependency
    graph at compile time, whereas other libraries (such as Koin) do it at runtime.
    For larger apps, this can imply a performance problem.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dagger** ([https://dagger.dev/](https://dagger.dev/))：Dagger 是由 Google 开发的一个编译时依赖注入库，它使用注解和代码生成来创建一个依赖图，该图可用于向应用组件提供依赖。其主要优势是它在编译时构建这个依赖图，而其他库（如
    Koin）则在运行时进行。对于大型应用，这可能会导致性能问题。'
- en: '**Hilt** ([https://dagger.dev/hilt/](https://dagger.dev/hilt/)): Hilt is a
    dependency injection library built on top of Dagger that provides a simplified
    way to perform dependency injection in Android apps. It reduces the boilerplate
    code required for Dagger and provides predefined bindings for Android-specific
    components, such as activities and fragments.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hilt** ([https://dagger.dev/hilt/](https://dagger.dev/hilt/))：Hilt 是一个基于
    Dagger 构建的依赖注入库，它为 Android 应用提供了简化依赖注入的方法。它减少了 Dagger 所需的样板代码，并为 Android 特定组件（如活动和片段）提供了预定义的绑定。'
- en: '**Koin** ([https://insert-koin.io/](https://insert-koin.io/)): Koin is a lightweight
    dependency injection library for Kotlin that focuses on simplicity and ease of
    use. It uses a **domain-specific language** (**DSL**) to define the dependencies
    and provide them to the app’s components, which makes it easier to do the setup
    and start using it.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Koin** ([https://insert-koin.io/](https://insert-koin.io/))：Koin 是一个专注于简洁和易用的
    Kotlin 轻量级依赖注入库。它使用 **领域特定语言**（**DSL**）来定义依赖并提供给应用组件，这使得设置和开始使用它变得更加容易。'
- en: Ultimately, the choice of dependency injection library depends on your specific
    requirements and preferences, and both Dagger and Koin are worth considering,
    depending on your needs. In this case, we are going to use Hilt as it is the current
    recommendation by Google.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，选择依赖注入库取决于你的具体需求和偏好，Dagger 和 Koin 都是值得考虑的选项，具体取决于你的需求。在这种情况下，我们将使用 Hilt，因为它是目前
    Google 的推荐。
- en: 'To set up Hilt in our project, follow these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中设置 Hilt，请按照以下步骤操作：
- en: 'Add the Hilt Gradle plugin to your project-level **build.gradle** file (replace
    **[version]** with the latest version available for you):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Hilt Gradle 插件添加到你的项目级别的 **build.gradle** 文件中（将 **[版本]** 替换为你可用的最新版本）：
- en: '[PRE1]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Apply the Hilt Gradle plugin and enable view binding in your app-level **build.gradle**
    file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用级别的 **build.gradle** 文件中应用 Hilt Gradle 插件并启用视图绑定：
- en: '[PRE2]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, create an **Application** class in our **:app** module. The **Application**
    class serves as a base class for maintaining the global application state (this
    refers to data or settings that need to be maintained throughout the entire life
    cycle of the application). While it’s not created by default, creating a custom
    **Application** class is crucial for initialization tasks, such as setting up
    dependency injection frameworks or initializing libraries. In this particular
    instance, to make Hilt work, you should annotate your **Application** class with
    the **@****HiltAndroidApp** annotation:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的 **:app** 模块中创建一个 **Application** 类。**Application** 类作为维护全局应用状态的基础类（这指的是在整个应用生命周期中需要维护的数据或设置）。虽然它不是默认创建的，但创建一个自定义的
    **Application** 类对于初始化任务至关重要，例如设置依赖注入框架或初始化库。在这个特定实例中，为了让 Hilt 正常工作，你应该使用 **@HiltAndroidApp**
    注解来标注你的 **Application** 类：
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With that, we are all set – we will continue defining the modules and dependencies
    once we advance in this project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经准备就绪——一旦我们在这个项目中进一步推进，我们将继续定义模块和依赖项。
- en: Navigation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航
- en: The next step is to decide what our approach to handling the navigation between
    screens and features in our application will be. It is important to note that
    we are going to use Jetpack Compose to build the user interface of our app, so
    the chosen approach must be compatible with it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是决定我们处理应用中屏幕和功能之间导航的方法。需要注意的是，我们将使用 Jetpack Compose 来构建应用的用户界面，因此所选方法必须与之兼容。
- en: 'In this case, we’re going to use Navigation Compose as it provides a simple
    and easy-to-use way to handle in-app navigation within an Android app. Here are
    some benefits of using Navigation Compose:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用 Navigation Compose，因为它提供了一种简单且易于使用的处理 Android 应用内导航的方法。以下是使用 Navigation
    Compose 的好处：
- en: '**Declarative UI**: Navigation Compose follows the same declarative approach
    as Jetpack Compose, which makes it easier to understand and maintain the navigation
    flow in your application.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式 UI**：Navigation Compose 遵循与 Jetpack Compose 相同的声明式方法，这使得理解和维护应用中的导航流程更加容易。'
- en: '**Type-safety**: With Navigation Compose, you can define your navigation graph
    and actions in a type-safe way. This helps prevent runtime crashes caused by incorrect
    navigation action names and arguments.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：使用 Navigation Compose，你可以以类型安全的方式定义你的导航图和操作。这有助于防止由错误的导航操作名称和参数引起的运行时崩溃。'
- en: '**Animation and transition support**: Navigation Compose provides built-in
    support for animating screen transitions, making it easy to create smooth and
    visually appealing navigation experiences.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画和过渡支持**：Navigation Compose 提供了内置的动画屏幕过渡支持，这使得创建平滑且视觉上吸引人的导航体验变得容易。'
- en: '**Deep linking**: Navigation Compose supports deep linking, allowing you to
    create URLs that can directly navigate to specific screens or actions within your
    app. This is useful for implementing features such as app shortcuts, notifications,
    or sharing content.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度链接**：Navigation Compose 支持深度链接，允许你创建可以直接导航到应用中特定屏幕或操作的 URL。这对于实现应用快捷方式、通知或共享内容等功能非常有用。'
- en: '**Integration with Jetpack Compose**: As part of the Jetpack Compose family,
    Navigation Compose works seamlessly with other Compose libraries and components,
    allowing you to build a consistent UI and navigation experience across your app.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与 Jetpack Compose 集成**：作为 Jetpack Compose 家族的一部分，Navigation Compose 与其他 Compose
    库和组件无缝集成，允许你在整个应用中构建一致的 UI 和导航体验。'
- en: '**Modularity and scalability**: Navigation Compose enables you to build modular
    navigation graphs, making it easier to scale your app and manage complex navigation
    flows.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化和可扩展性**：Navigation Compose使您能够构建模块化的导航图，这使得扩展您的应用和管理复杂的导航流程变得更加容易。'
- en: In summary, Navigation Compose simplifies navigation management, improves the
    robustness of our app, and will help us to create a more consistent, accessible,
    and visually appealing user experience.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Navigation Compose简化了导航管理，提高了我们应用的健壮性，并将帮助我们创建一个更一致、更易访问和更具视觉吸引力的用户体验。
- en: 'To start using Navigation Compose, we must do the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Navigation Compose，我们必须做以下事情：
- en: 'First, we need to include the dependencies that are required in our Gradle
    files:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的Gradle文件中包含所需的依赖项：
- en: '[PRE4]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The version used in the previous code is the latest stable one at the time of
    writing this book, but there will likely be a new version by the time you are
    reading this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，前一个代码版本是当时最新的稳定版本，但当你阅读本书时，可能已经有一个新版本了。
- en: Next, in the **app** module, create a new package called **ui.navigation**.
    Then, create a file called **WhatsPacktNavigation**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**app**模块中，创建一个名为**ui.navigation**的新包。然后，创建一个名为**WhatsPacktNavigation**的文件。
- en: 'Now, create a **NavHost** composable and provide a **NavController** instance.
    The **NavHost** composable functions as a container for managing navigation between
    different composables in an app. It acts as the central hub where navigation routes
    are defined and composables are switched in and out based on the navigation state.
    Each screen or view in your application corresponds to a composable that **NavHost**
    can display. Here, we will start by creating the **WhatsPacktNavigation** composable
    function. This will be responsible for holding **NavHost**:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个**NavHost**可组合项，并提供一个**NavController**实例。**NavHost**可组合项充当管理应用中不同可组合项之间导航的容器。它作为中央枢纽，在这里定义导航路由，并根据导航状态切换可组合项。您的应用程序中的每个屏幕或视图都对应于**NavHost**可以显示的可组合项。在这里，我们将首先创建**WhatsPacktNavigation**可组合项函数。这将负责持有**NavHost**：
- en: '[PRE5]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we’ve created the first screen (which we’ll call **MainScreen**), we will
    complete **NavHost**, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了第一个屏幕（我们将称之为**MainScreen**），我们将完成**NavHost**，如下所示：
- en: '[PRE6]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also include dynamic parameters in the route, like so:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以在路由中包含动态参数，如下所示：
- en: '[PRE7]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have a second composable that defines another navigation destination
    associated with the `"chat/{chatId}"` route. The `{chatId}` part is a dynamic
    parameter that can be passed when navigating to this destination.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有一个第二个可组合项，它定义了与`"chat/{chatId}"`路由相关联的另一个导航目的地。`{chatId}`部分是一个动态参数，可以在导航到该目的地时传递。
- en: Using these two configurations – that is, navigation with and without parameters
    – should have us covered but since we are using feature-based modularization,
    we might encounter the problem of having to navigate from one module to another
    where there isn’t a direct dependency between them. In those cases, we will use
    deep links.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个配置——即带有和不带有参数的导航——应该可以满足我们的需求，但由于我们正在使用基于功能的模块化，我们可能会遇到必须从一个模块导航到另一个模块，而它们之间没有直接依赖关系的问题。在这种情况下，我们将使用深度链接。
- en: '`NavHost`, you need to add a `deepLink` parameter with the URI pattern you
    want to use for that destination. This pattern should include a scheme, a host,
    and an optional path. In our example, if we have `ChatScreen`, which takes a `chatId`
    argument, we can add a deep link `URI` like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavHost`，你需要添加一个带有你想要用于该目的地的URI模式的`deepLink`参数。这个模式应该包括一个方案、一个主机和一个可选的路径。在我们的例子中，如果我们有一个`ChatScreen`，它接受一个`chatId`参数，我们可以添加一个类似这样的深度链接`URI`：'
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One common practice to keep our `NavHost` leaner and delegate the definition
    of routes and URIs to every screen is to define the route with constants. Here
    is an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`NavHost`更简洁，并将路由和URI的定义委托给每个屏幕，一个常见的做法是使用常量来定义路由。以下是一个示例：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By doing this, developers can easily manage, update, and maintain the routes
    in a centralized manner.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，开发者可以轻松地以集中化的方式管理、更新和维护路由。
- en: 'Then, in `NavHost`, we would define `uriPattern` using these constants:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`NavHost`中，我们将使用这些常量来定义`uriPattern`：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead of adding this information to every screen, a better option is to create
    a class where we are going to put all the route constants:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将此信息添加到每个屏幕，更好的选择是创建一个类，我们将把所有的路由常量放在这个类中：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Having the route’s definition in the same place will facilitate reading and
    maintaining our code so that we can easily manage, update, and maintain the routes
    in a centralized manner, while also improving code readability and reducing the
    possibility of errors caused by hardcoded or duplicated strings throughout the
    code base.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由的定义放在同一个地方将有助于阅读和维护我们的代码，这样我们可以轻松地以集中化的方式管理、更新和维护路由，同时提高代码的可读性并减少由于硬编码或代码库中重复字符串引起的错误的可能性。
- en: 'We will place the file that contains this class in our `:common:framework`
    module as we will need to access those constants from every feature module. Another
    common practice is to create a dedicated `:common:navigation` module and add the
    definition of the route and even the `NavHost` definition there. In our case,
    we will define the routes using the latest approach – that is, route constants:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个包含此类的文件放在我们的 `:common:framework` 模块中，因为我们需要从每个功能模块访问这些常量。另一个常见的做法是创建一个专门的
    `:common:navigation` 模块，并在其中添加路由定义甚至 `NavHost` 定义。在我们的情况下，我们将使用最新的方法定义路由——即路由常量：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we completed our `NavHost` definition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们完成了 `NavHost` 的定义。
- en: 'In our app, we will want to navigate to three different parts of the app (conversations
    list, create new chat, and the single chat screen). The navigation destinations
    can be added to `NavHost` by using extension functions on `NavGraphBuilder`. These
    extension functions are defined as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们希望导航到应用的三个不同部分（会话列表、创建新聊天和单个聊天屏幕）。可以通过在 `NavGraphBuilder` 上使用扩展函数将导航目标添加到
    `NavHost`。这些扩展函数定义如下：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `addConversationsList(navController)` sets up `ConversationsListScreen`
    and defines click listeners for navigating to the `NewConversation` and `Chat`
    destinations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`addConversationsList(navController)` 设置 `ConversationsListScreen` 并为导航到
    `NewConversation` 和 `Chat` 目标定义了点击监听器。
- en: Then, `addNewConversation(navController)` sets up `CreateConversationScreen`
    and defines a click listener for navigating to the `Chat` destination upon creating
    a new conversation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`addNewConversation(navController)` 设置 `CreateConversationScreen` 并在创建新会话时定义了一个点击监听器，用于导航到
    `Chat` 目标。
- en: Finally, `addChat(navController)` sets up `ChatScreen` and extracts the `chatId`
    argument from `backStackEntry`. It also defines a click listener for navigating
    back to the previous screen using `navController.popBackStack()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`addChat(navController)` 设置 `ChatScreen` 并从 `backStackEntry` 中提取 `chatId`
    参数。它还定义了一个点击监听器，用于使用 `navController.popBackStack()` 返回到上一个屏幕。
- en: 'Now, we are almost ready to hit the **Run** button for the first time. But
    first, to avoid compilation problems, we should create the screen’s composables
    in their respective modules:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎准备好第一次点击 **运行** 按钮了。但首先，为了避免编译问题，我们应该在各自的模块中创建屏幕的可组合组件：
- en: '**ConversationsListScreen** in **:feature:conversations**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConversationsListScreen** 在 **:feature:conversations**'
- en: '**CreateConversationScreen** in **:feature:create_chat**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CreateConversationScreen** 在 **:feature:create_chat**'
- en: '**ChatScreen** in **:feature:chat**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChatScreen** 在 **:feature:chat**'
- en: 'For example, we can create `ChatScreen` and leave it as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建 `ChatScreen` 并将其保留如下：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are missing one last change (for now). We need to include the `MainNavigation`
    composable as the content in `MainActivity`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还缺少最后一个更改（目前是这样）。我们需要在 `MainActivity` 中包含 `MainNavigation` 可组合组件作为内容：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, we’ve added `navHostController`, which we created using `rememberNav`
    **Controller()**. This is used to remember the navigation state across recompositions.
    Here, `navHostController` manages the navigation between different composables
    in the application. Then, the `MainNavigation` composable is called with `navHostController`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们添加了 `navHostController`，这是通过 `rememberNav Controller()` 创建的。这用于在重组之间记住导航状态。在这里，`navHostController`
    管理应用程序中不同可组合组件之间的导航。然后，使用 `navHostController` 调用 `MainNavigation` 可组合组件。
- en: So far, we have chosen and created the module structure for our app, chosen
    a dependency injection framework, added the dependencies we need, and structured
    the navigation that defines how our screens are going to be accessed. Now, it’s
    time for us to start working on each of the screens we need to build this app.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经选择了并创建了应用模块结构，选择了依赖注入框架，添加了所需的依赖项，并结构化了导航，定义了我们的屏幕如何被访问。现在，是我们开始构建构建此应用所需的每个屏幕的时候了。
- en: Building the main screen
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建主屏幕
- en: Now that we have the main structure of our app ready, it is time to start building
    the main screen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了应用的主要结构，是时候开始构建主屏幕了。
- en: 'Let’s analyze what components our main screen will have:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下我们的主屏幕将包含哪些组件：
- en: '![Figure 1.9: The ConversationsList screen](img/B19443_01_9.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9：ConversationsList 屏幕截图](img/B19443_01_9.jpg)'
- en: 'Figure 1.9: The ConversationsList screen'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：ConversationsList 屏幕截图
- en: 'As you can see, we are going to include the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将包括以下内容：
- en: A top bar
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个顶部栏
- en: A tab bar to navigate to the main sections (note that this book will only cover
    the development of the chat section; we will not cover the status and calls sections)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标签栏，用于导航到主要部分（请注意，本书将仅涵盖聊天部分的开发；我们不会涵盖状态和通话部分）
- en: A list containing the current conversations (which we will complete later in
    this chapter)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含当前对话的列表（我们将在本章后面完成）
- en: A floating button to create a new chat
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于创建新聊天的浮动按钮
- en: Let’s start with the main screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从主屏幕开始。
- en: Adding a scaffold to the main screen
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Scaffold 添加到主屏幕
- en: 'Previously, we created an empty version of the first screen (`ConversationsListScreen`),
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了一个第一个屏幕的空版本（`ConversationsListScreen`），如下所示：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, it’s time to start working on this screen. The first component we are going
    to add is a `Scaffold`, you can easily organize your app’s layout and maintain
    a consistent look and feel across different screens.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始工作在这个屏幕上了。我们将要添加的第一个组件是 `Scaffold`，您可以使用它轻松组织应用布局，并在不同屏幕之间保持一致的外观和感觉。
- en: 'Here’s a brief overview of the main components of `Scaffold`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Scaffold` 的主要组件的简要概述：
- en: '**topBar**: A slot for placing a top app bar, typically used for displaying
    the app’s title and navigation icons. You can use the **TopAppBar** composable
    to create a top app bar.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**topBar**：一个用于放置顶部应用栏的槽位，通常用于显示应用的标题和导航图标。您可以使用 **TopAppBar** 组合组件来创建顶部应用栏。'
- en: '**bottomBar**: A slot for placing a bottom app bar, typically used for actions,
    navigation tabs, or a bottom navigation bar. You can use the **BottomAppBar**
    or **TabRow** composable to create a bottom app bar.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bottomBar**：一个用于放置底部应用栏的槽位，通常用于操作、导航标签或底部导航栏。您可以使用 **BottomAppBar** 或 **TabRow**
    组合组件来创建底部应用栏。'
- en: '**drawerContent**: A slot for placing a navigation drawer, which is a panel
    that displays the app’s navigation options. You can use the **Drawer** or **ModalDrawer**
    composable to create a navigation drawer.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**drawerContent**：一个用于放置导航抽屉的槽位，这是一个显示应用导航选项的面板。您可以使用 **Drawer** 或 **ModalDrawer**
    组合组件来创建导航抽屉。'
- en: '**floatingActionButton**: A slot for placing a floating action button, which
    is a circular button that hovers above the content and represents the primary
    action of the screen. You can use the **FloatingActionButton** composable to create
    a floating action button.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**floatingActionButton**：一个用于放置浮动操作按钮的槽位，这是一个悬浮在内容上方的圆形按钮，代表屏幕的主要操作。您可以使用 **FloatingActionButton**
    组合组件来创建浮动操作按钮。'
- en: '**content**: A slot for placing the main content of the screen, which can be
    any composable that displays the app’s data or UI elements.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**：一个用于放置屏幕主要内容的槽位，可以是任何可以显示应用数据或 UI 元素的组合组件。'
- en: In our case, we are going to use `topBar`, `bottomBar` with `TabRow` (to navigate
    between tabs), `floatingActionButton` (to create new chats), and the content,
    where we are going to place our main content – in our case, the list of conversations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用 `topBar`、`bottomBar` 与 `TabRow`（用于在标签之间导航）、`floatingActionButton`（用于创建新的聊天），以及内容区域，我们将在这里放置我们的主要内容——在我们的案例中，是聊天列表。
- en: 'Let’s create the `Scaffold` composable in our `ConversationsListScreen`. We
    will add the modifiers for all the components we want to include, but we’ll leave
    them empty (for now):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `ConversationsListScreen` 中创建 `Scaffold` 组合组件。我们将添加所有想要包含的组件的修饰符，但暂时将它们留空：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Scaffold` composable we have created includes `topBar`, `bottomBar`, `floatingAction`
    **Button**, and the content of the main area of the screen. We will continue implementing
    each of those components.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 `Scaffold` 组合组件包括 `topBar`、`bottomBar`、`floatingAction` **Button** 和屏幕主要区域的内容。我们将继续实现这些组件中的每一个。
- en: 'Now, depending on your Android Studio version, you may see the following error:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据您的 Android Studio 版本，您可能会看到以下错误：
- en: '![Figure 1.10: An error with the content padding parameter](img/B19443_01_10.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10：内容填充参数错误](img/B19443_01_10.jpg)'
- en: 'Figure 1.10: An error with the content padding parameter'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：内容填充参数错误
- en: This is happening because the `Scaffold` composable provides a padding parameter
    to the content Lambda. We will need to take this padding into account when we
    place the inside components since the scaffold could overlap them if we don’t.
    For example, in our case, we must consider the padding because otherwise, our
    content will be kept behind `bottomBar`. We will use this parameter layer when
    we build the content.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Scaffold`可组合组件向内容Lambda提供了填充参数。在放置内部组件时，我们需要考虑这个填充，因为如果不考虑，scaffold可能会覆盖它们。例如，在我们的案例中，我们必须考虑填充，否则我们的内容将保持在`bottomBar`后面。当我们构建内容时，我们将使用这个参数层。
- en: Now, we will add a `TopAppBar` composable to the `Scaffold` composable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向`Scaffold`可组合组件添加一个`TopAppBar`可组合组件。
- en: Adding the TopAppBar composable to the main screen
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将`TopAppBar`可组合组件添加到主屏幕
- en: 'The `TopAppBar` composable represents a toolbar located at the top of the screen
    and provides a consistent look and feel across different screens in your app.
    It typically displays the following elements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopAppBar`可组合组件代表屏幕顶部的工具栏，并为应用中不同屏幕提供一致的外观和感觉。它通常显示以下元素：'
- en: '**Title**: The main text that’s displayed in the app bar, usually representing
    the app’s name or the current screen’s title'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：在应用栏中显示的主要文本，通常代表应用名称或当前屏幕的标题'
- en: '**Navigation icon**: An optional icon located at the beginning of the app bar,
    usually used to open a navigation drawer or navigate back into the app'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航图标**：位于应用栏开头的一个可选图标，通常用于打开导航抽屉或导航回应用'
- en: '**Actions**: A set of optional icons or buttons located at the end of the app
    bar, representing common actions or settings related to the current screen'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：一组可选的图标或按钮，位于应用栏的末尾，代表与当前屏幕相关的常见操作或设置'
- en: To add a `TopAppBar` composable, we must create the `conversations_list_title`
    string in the module’s `strings.xml` file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加`TopAppBar`可组合组件，我们必须在模块的`strings.xml`文件中创建`conversations_list_title`字符串。
- en: 'Then, we are going to create the `TopAppBar` composable while setting the title
    to `WhatsPackt` and adding `IconButton` with a menu icon. Here, `IconButton` has
    an `onClick` function where you can define the action to perform when the button
    is clicked:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个`TopAppBar`可组合组件，同时将标题设置为`WhatsPackt`并添加带有菜单图标的`IconButton`。在这里，`IconButton`有一个`onClick`函数，您可以在按钮被点击时定义要执行的操作：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we are going to create a `TabRow` composable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`TabRow`可组合组件。
- en: Adding the TabRow composable to the bottom of the main screen
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将`TabRow`可组合组件添加到主屏幕底部
- en: 'The `TabRow` composable is a horizontal row of tabs that allows users to navigate
    between different views or sections within an app. The `TabRow` composable mainly
    consists of the following elements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabRow`可组合组件是一个水平排列的标签行，允许用户在应用的不同视图或部分之间导航。`TabRow`可组合组件主要由以下元素组成：'
- en: '**Tabs**: A collection of individual **Tab** composables that represent different
    sections or views within the app. Each **Tab** composable can have a text label,
    an icon, or both to describe its content.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：代表应用中不同部分或视图的**Tab**可组合组件集合。每个**Tab**可组合组件可以有一个文本标签、一个图标或两者兼而有之，以描述其内容。'
- en: '**Selected tab indicator**: A visual indicator that highlights the currently
    selected tab, making it easy for users to understand which section they are viewing.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选中标签指示器**：一个视觉指示器，突出显示当前选中的标签，使用户易于理解他们正在查看的哪个部分。'
- en: 'Before creating the `TabRow` composable, we’ll have to provide a list and the
    tabs it is going to contain:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`TabRow`可组合组件之前，我们必须提供一个列表以及它将要包含的标签：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can add `TabRow`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加`TabRow`：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For every row, we are adding a `Tab` composable, where we indicate the title
    (using a `Text` composable), the selected value when the tab is selected, and
    the `onClick` action (which we are not implementing).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，我们都在添加一个`Tab`可组合组件，其中我们指明标题（使用`Text`可组合组件），当标签被选中时的选中值，以及`onClick`操作（我们尚未实现）。
- en: 'After that, we can make our code more readable by creating a data class to
    store the title of the `Tab` composable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过创建一个数据类来存储`Tab`可组合组件的标题来使我们的代码更易于阅读：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we can change our `TabRow` code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更改我们的`TabRow`代码：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`TabRow` composables are usually combined with a pager, where the content will
    be shown. When clicking and navigating between tabs, the main content that’s displayed
    should change.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabRow`可组合组件通常与分页器结合使用，其中将显示内容。当点击和在不同标签之间导航时，显示的主要内容应该改变。'
- en: Now, let’s add the pager to our screen content.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将分页器添加到我们的屏幕内容中。
- en: Adding a pager
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加分页器
- en: A pager is a UI component that allows users to swipe through multiple pages
    or screens horizontally or vertically. It is commonly used to display screens
    or views in a carousel-like fashion.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 分页器是一个 UI 组件，允许用户水平或垂直滑动多个页面或屏幕。它通常用于以类似旋转木马的方式显示屏幕或视图。
- en: We are going to use `HorizontalPager`, which, as its name suggests, allows the
    user to horizontally swipe between screens or composables. One of its main advantages
    is that it will not create all pages at once; it will only create the current
    page and the immediate previous/next pages, which will be off-screen. Once a page
    is out of this three-page window, it will be removed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `HorizontalPager`，正如其名称所暗示的，允许用户在屏幕或可组合组件之间水平滑动。其主要优点是它不会一次性创建所有页面；它只会创建当前页面以及立即的上一页和下一页，这些页面将位于屏幕之外。一旦一个页面超出这个三页窗口，它将被移除。
- en: 'To do so, we are going to have to tweak some of the previous code we had in
    our `Conversations``ListScreen` composable:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可能需要调整我们在 `ConversationsListScreen` 可组合组件中的一些先前代码：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, since `HorizontalPager` is part of the foundation API and is (at the
    time of writing) an experimental API (which means that it could change its public
    interface in the future), we need to add the `@``OptIn(ExperimentalFoundationApi::class)`
    annotation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于 `HorizontalPager` 是基础 API 的一部分，并且在编写时是一个实验性 API（这意味着它可能会在未来更改其公共接口），我们需要添加
    `@OptIn(ExperimentalFoundationApi::class)` 注解。
- en: Second, we have added a new field called `pagerState`. Its responsibility is
    to hold the state of the pager, including information about the number of pages,
    the current page, the scrolling position, and the scrolling behavior.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们添加了一个名为 `pagerState` 的新字段。它的职责是保持分页器的状态，包括有关页面数量、当前页面、滚动位置和滚动行为的信息。
- en: 'Next, we will add `HorizontalPager` to the content function, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照以下方式将 `HorizontalPager` 添加到内容函数中：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we will be using a `LaunchedEffect` function. This function is used to
    manage side effects, such as launching tasks that have been completed asynchronously
    in the context of a composable hierarchy. Side effects are operations that can
    have an impact outside of the composable function itself, such as network requests,
    database operations, or, in the case of the previous example, scrolling to a specific
    page in a pager.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 `LaunchedEffect` 函数。此函数用于管理副作用，例如在可组合层次结构上下文中异步完成的任务。副作用是可以在可组合函数本身之外产生影响的操作，例如网络请求、数据库操作，或者在上一个示例中，在分页器中滚动到特定页面。
- en: '`LaunchedEffect` takes a key (or a set of keys) as its first parameter. When
    the key changes, the effect will be re-launched, canceling any ongoing work from
    the previous effect. The second parameter is a suspending Lambda function, which
    will be executed in the effect’s coroutine scope.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`LaunchedEffect` 函数接受一个键（或一组键）作为其第一个参数。当键发生变化时，效果将被重新启动，取消之前效果的任何正在进行的工作。第二个参数是一个挂起
    Lambda 函数，它将在效果的协程作用域中执行。'
- en: The main advantage of using `LaunchedEffect` is that it integrates well with
    the Compose life cycle. When the composable that called `LaunchedEffect` leaves
    the composition, the effect will be automatically canceled, cleaning up any ongoing
    work.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LaunchedEffect` 的主要优势是它与 Compose 生命周期集成良好。当调用 `LaunchedEffect` 的可组合组件离开组合时，效果将被自动取消，清理任何正在进行的工作。
- en: Coming back to our code, in our case, we are changing the current page in `pagerState`
    and animating the scroll to the next selected page. This will be triggered every
    time `selectedIndex.value` is changed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码，在我们的情况下，我们正在更改 `pagerState` 中的当前页面，并动画滚动到下一个选定的页面。这将在 `selectedIndex.value`
    发生变化时触发。
- en: The next component will allow the user to create a new chat – we will create
    this button using a `FloatingActionButton` composable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件将允许用户创建一个新的聊天 - 我们将使用 `FloatingActionButton` 可组合组件创建此按钮。
- en: Adding the FloatingActionButton composable
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 FloatingActionButton 可组合组件
- en: 'The `FloatingActionButton` composable is a Material Design composable that
    represents a circular button floating above the UI. It’s typically used to promote
    the primary action in an application (for example, adding a new item, composing
    a message, or starting a new process). Following the Material Design guidelines
    (you can check them here: [https://m3.material.io/](https://m3.material.io/)),
    we are going to use it to create a new chat from `ConversationsListScreen`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloatingActionButton`可组合组件是一个表示在UI上方浮动的圆形按钮的Material Design可组合组件。它通常用于促进应用中的主要操作（例如，添加新项目、编写消息或启动新流程）。遵循Material
    Design指南（您可以在[https://m3.material.io/](https://m3.material.io/)中查看），我们将使用它从`ConversationsListScreen`创建新的聊天：'
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our `FloatingActionButton` composable is taking an `onClick` modifier. Here,
    we will include the code to navigate to the create chat screen. Inside this button,
    we have included an `Icon` composable, which we are using as an image of one of
    the `Icons.Default` predefined images.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FloatingActionButton`可组合组件使用了`onClick`修饰符。在这里，我们将包含导航到创建聊天屏幕的代码。在这个按钮内部，我们包含了一个`Icon`可组合组件，我们将其用作`Icons.Default`预定义图像之一。
- en: 'At this point, our conversations list screen should look similar to this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的对话列表屏幕应该看起来类似于这个：
- en: '![Figure 1.11: The conversations list screen with a top bar, tab bar, and floating
    action button](img/B19443_01_11.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11：带有顶部栏、标签栏和浮动操作按钮的对话列表屏幕](img/B19443_01_11.jpg)'
- en: 'Figure 1.11: The conversations list screen with a top bar, tab bar, and floating
    action button'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：带有顶部栏、标签栏和浮动操作按钮的对话列表屏幕
- en: 'With that, we have created our `Scaffold` composable with all the elements
    we need to help the user navigate. Now, we are ready for the last step (and the
    most important one) to complete the screen: creating the list of existing conversations.
    To do that, we are going to start creating a conversation item.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就创建了一个包含所有帮助用户导航的元素的`Scaffold`可组合组件。现在，我们准备好完成屏幕的最后一步（也是最重要的一步）：创建现有对话的列表。为此，我们将开始创建一个对话项。
- en: Creating the conversations list
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对话列表
- en: In this section, we are going to create all the pieces we need to show the conversations
    list. We will start with the UI data model, which will represent the information
    that the app is going to show in the list, the `Conversation` composable, which
    will draw every item of the list, and finally the list composable itself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建展示对话列表所需的所有组件。我们将从UI数据模型开始，它将代表应用在列表中将要显示的信息，`Conversation`可组合组件，它将绘制列表中的每个项目，最后是列表本身的可组合组件。
- en: Modeling the conversation
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟对话
- en: 'First, we are going to model what is going to be the entity we will be using
    through our conversations list components: the `Conversation` model.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将模拟我们将在对话列表组件中使用的实体：`Conversation`模型。
- en: As part of the conversation model, we want to show the avatar of the other participant
    (we are just doing one-to-one conversations), their name, the first line of the
    last message, the time the message was received, and a number indicating how many
    unread messages there are.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对话模型的一部分，我们希望显示其他参与者的头像（我们只是进行一对一的对话）、他们的名字、最后一条消息的第一行、接收消息的时间以及表示未读消息数量的数字。
- en: 'Taking that information into account, we will start creating a data class to
    hold the data we’ll need:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些信息，我们将开始创建一个数据类来保存我们需要的数据：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As the avatar could be reusable across the app, we are going to create it first.
    We can include it in the `:common:framework` module so that it is visible and
    can be reused from the other feature modules.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于头像可以在整个应用中重复使用，我们将首先创建它。我们可以将其包含在`:common:framework`模块中，以便它可见并可从其他功能模块中重复使用。
- en: Jetpack Compose doesn’t include support to asynchronously load images from a
    URL out of the box, but there are plenty of third-party libraries that will help
    us accomplish this. The most popular options are Coil and Glide, which, in terms
    of performance, caching, and image loading, are quite similar. We are going to
    use Coil just for simplicity and because it is Kotlin-first (whereas Glide is
    programmed in Java).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose默认不包含从URL异步加载图像的支持，但有许多第三方库可以帮助我们完成这项任务。最受欢迎的选项是Coil和Glide，在性能、缓存和图像加载方面相当相似。我们将仅为了简单起见并因为它是Kotlin优先（而Glide是用Java编写的）而使用Coil。
- en: 'As always, we need to include the dependency in our module’s `build.gradle`
    file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要在我们的模块的`build.gradle`文件中包含依赖项：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this point, we’re ready to create our `Avatar` composable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好创建我们的 `Avatar` 可组合：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are creating an avatar using `AsyncImage`, which will load an image
    provided by a URL. This image will be modified to have a circular shape. Also,
    we should pass the size of the image when using this composable (we have chosen
    50 density-independent pixels).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用 `AsyncImage` 创建头像，该头像将加载由 URL 提供的图像。此图像将被修改为圆形形状。此外，我们应在使用此可组合时传递图像的大小（我们选择了
    50 密度无关像素）。
- en: 'Now, we can create `ConversationItem`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建 `ConversationItem`：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s take a closer look at what this composable does:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个可组合做了什么：
- en: 'The **ConversationItem** composable accepts the following parameters: name,
    message, timestamp, **avatarUrl**, and an optional **unreadMessages** with a default
    value of **0**.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConversationItem** 可组合接受以下参数：名称、消息、时间戳、**头像URL**，以及一个具有默认值 **0** 的可选 **未读消息**。'
- en: A **Row** layout is used to arrange the contents horizontally. It has a **fillMaxWidth()**
    modifier to occupy the full width of the parent and a padding of 8 density-independent
    pixels.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Row** 布局来水平排列内容。它具有 **fillMaxWidth()** 修饰符，以占用父级的全部宽度，并具有 8 密度无关像素的填充。
- en: The **Avatar** composable is used to display the avatar. We already know how
    it works – the only thing to remark on is that we want it to have a size of 50
    density-independent pixels.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Avatar** 可组合用于显示头像。我们已经知道它是如何工作的——唯一需要指出的是，我们希望它的大小为 50 密度无关像素。'
- en: A **Spacer** composable with a width of 8 density pixels is added to provide
    some space between the avatar and the text content.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个宽度为 8 密度像素的 **Spacer** 可组合，以在头像和文本内容之间提供一些空间。
- en: A **Column** layout is used to arrange the name and message text vertically.
    The **Column** layout has a **Modifier.weight()** modifier, which ensures that
    it takes up all the available space between the avatar and the timestamp.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Column** 布局来垂直排列名称和消息文本。**Column** 布局具有 **Modifier.weight()** 修饰符，确保它占据头像和时间戳之间的所有可用空间。
- en: Inside the **Column** layout, a **Text** composable is used to display the name
    with a bold font weight and a font size of 16 scale-independent pixels. Another
    **Text** composable is used to display the message with a maximum of one line
    and an ellipsis overflow.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Column** 布局内部，使用 **Text** 可组合以粗体字体重量和 16 尺度无关像素的字体大小显示名称。另一个 **Text** 可组合用于显示消息，最多一行，并带有省略号溢出。
- en: Another **Column** layout is added to the main **Row** layout to arrange the
    timestamp and unread messages badge vertically. The **Column** layout has a **horizontalAlignment**
    value of **Alignment.End** to align its children to the end of the available space.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主 **Row** 布局中添加另一个 **Column** 布局来垂直排列时间戳和未读消息徽章。**Column** 布局的 **horizontalAlignment**
    值为 **Alignment.End**，以将其子项对齐到可用空间的末尾。
- en: Inside this second **Column** layout, a **Text** composable is used to display
    the time with a font size of 12 scale-independent pixels and a gray color.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个第二个 **Column** 布局内部，使用 **Text** 可组合以 12 尺度无关像素的字体大小和灰色显示时间。
- en: A conditional statement checks if there are any unread messages (that is, **conversation.unreadMessages
    > 0**). If there are unread messages, the unread messages count shows a text with
    a circular background drawn using the **drawBehind** modifier.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句检查是否有任何未读消息（即 **conversation.unreadMessages > 0**）。如果有未读消息，未读消息计数将显示一个带有圆形背景的文本，该背景使用
    **drawBehind** 修饰符绘制。
- en: Now that we have our `ConversationItem` composable, it is time to finish this
    screen. Let’s create the `ConversationList` composable!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `ConversationItem` 可组合，是时候完成这个屏幕了。让我们创建 `ConversationList` 可组合！
- en: Creating the ConversationList composable
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ConversationList 可组合
- en: 'As the last step for this screen, we are going to create the list of conversations:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此屏幕的最后一步，我们将创建对话列表：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `ConversationList` composable takes a list of `Conversation` objects and
    uses `LazyColumn` to display them efficiently. The `items` function is used to
    loop through the conversations list and will render `ConversationItem` for each
    conversation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConversationList` 可组合接受一个 `Conversation` 对象列表，并使用 `LazyColumn` 高效地显示它们。`items`
    函数用于遍历对话列表，并为每个对话渲染 `ConversationItem`。'
- en: 'Finally, we will include the list in the `HorizontalPager` logic, in our `ConversationsListScreen`
    composable:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将此列表包含在 `HorizontalPager` 逻辑中，在我们的 `ConversationsListScreen` 可组合中：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to test it, we can fake the data of the conversations:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想测试它，我们可以伪造对话的数据：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that here, I’m using a random avatar generator just to make it as similar
    as possible to how it would be when we connect this UI with real conversations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，我正在使用一个随机头像生成器，只是为了使其尽可能接近我们将这个UI与真实对话连接时的样子。
- en: 'The following screenshot shows what our app would look like with more conversations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的应用在更多对话中的样子：
- en: '![Figure 1.12: ConversationsList screen completed](img/B19443_01_12.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12：ConversationsList屏幕完成](img/B19443_01_12.jpg)'
- en: 'Figure 1.12: ConversationsList screen completed'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：ConversationsList屏幕完成
- en: Now, let’s switch to the chat screen, also known as the messages list. Whereas
    the conversations list is a list showing all the conversations we have, the messages
    list will show the list of messages we have with one user (a single chat screen).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换到聊天屏幕，也称为消息列表。与显示所有对话的对话列表不同，消息列表将显示我们与一个用户（单个聊天屏幕）的对话列表。
- en: Building the messages list
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建消息列表
- en: In this section, we are going to create the UI models that are needed to create
    the chat screen and the messages two users could have exchanged. Then, we will
    create the `Message` composable, and finally, the rest of the screen, including
    the list of messages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建创建聊天屏幕和两个用户可能交换的消息所需的UI模型。然后，我们将创建`Message`可组合组件，最后是屏幕的其余部分，包括消息列表。
- en: Modeling the Chat and Message models
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟Chat和Message模型
- en: 'Taking into account the information we have to show on the chat screen, we
    are going to need two data models: one for the static data related to the conversation
    (for example, the name of the user we are talking to, their avatar, and so on)
    and one data model per message. This will be the model for the `Chat` model:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在聊天屏幕上需要显示的信息，我们将需要两个数据模型：一个用于与对话相关的静态数据（例如，我们正在与之交谈的用户的姓名、他们的头像等），以及每个消息一个数据模型。这将作为`Chat`模型的模型：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, we will need the ID of the chat, the name of the person we are
    talking to, and their avatar address.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要聊天ID、我们正在与之交谈的人的姓名和他们的头像地址。
- en: 'Regarding the `Message` model, we will create the following classes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Message`模型，我们将创建以下类：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, we need the sender’s name, their avatar, the timestamp, whether
    the message is mine or not (which we will take into account so that we can arrange
    the message one to the left or the right), and the content of the message.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要发送者的姓名、他们的头像、时间戳、消息是否是我的（我们将考虑这一点，以便我们可以将消息排列在左边或右边），以及消息的内容。
- en: Since our application is going to have two types of content (messages and images),
    we need two different kinds of `MessageContent`. That’s the reason it has been
    modeled as a sealed class. We have two data classes with the data needed for every
    type of message content.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用将有两种类型的内容（消息和图片），我们需要两种不同类型的`MessageContent`。这就是为什么它被建模为一个密封类。我们有两个数据类，包含每种类型消息内容所需的数据。
- en: Now, we need to convert these models into some composables.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这些模型转换为一些可组合组件。
- en: Creating the MessageItem composable
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建MessageItem可组合组件
- en: The `MessageItem` composable is going to draw each of our chat messages.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageItem`可组合组件将绘制我们聊天中的每条消息。'
- en: 'To start, we will create a `Row` layout. We will set the arrangement of the
    row contents depending on the message’s author:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`Row`布局。我们将根据消息的作者设置行内容的排列：
- en: '[PRE35]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, inside this row, we are going to place the rest of the components of
    the message. We will start with the avatar; we will only show the avatar if the
    message is not from the user:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个行内，我们将放置消息的其余组件。我们将从头像开始；如果消息不是来自用户，我们将只显示头像：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we are going to add a `Column` layout so that we can arrange the rest
    of the message information:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个`Column`布局，以便我们可以安排剩余的消息信息：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The message will include the following information:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 消息将包含以下信息：
- en: '**The name of the sender (if the author is not the current user)**: To know
    if the message is from the current user, the app will check if the author of the
    message is the current user using **if (message.isMine**. If this is positive,
    we will add a **Space** composable; if the message author is not the current user,
    we will show the **Text** composable and their name.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送者姓名（如果作者不是当前用户）**：为了知道消息是否来自当前用户，应用将检查消息的作者是当前用户使用**if (message.isMine**）。如果是肯定的，我们将添加一个**Space**可组合组件；如果消息作者不是当前用户，我们将显示**Text**可组合组件和他们的名字。'
- en: '**The content**: The app will show a bubble containing text if the content
    is text. The color of the bubble will depend on whether the sender of the message
    is the current user and the time the message was created. A timestamp with the
    date and time of creation will be shown at the bottom of the message.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**：如果内容是文本，则应用将显示包含文本的气泡。气泡的颜色将取决于消息的发送者是否是当前用户以及消息创建的时间。将在消息底部显示创建日期和时间的戳记。'
- en: Now that we have `MessageItem`, it’s time to create the rest of the chat screen.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`MessageItem`，是时候创建聊天屏幕的其余部分了。
- en: Adding the TopAppBar and BottomRow composables
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加TopAppBar和BottomRow可组合组件
- en: 'As we did for the conversations list, we are going to add the `Scaffold` structure
    and its `TopAppBar` and `BottomRow` composables to this screen:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对对话列表所做的那样，我们将添加`Scaffold`结构和其`TopAppBar`和`BottomRow`可组合组件到这个屏幕：
- en: '[PRE38]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we are hardcoding the title of the chat. This is just for preview
    purposes; we’ll correct that in the next chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在硬编码聊天标题。这只是为了预览目的；我们将在下一章中纠正这一点。
- en: 'In the case of the bottom bar, we are adding a new composable that will contain
    `Textfield` and the send button needed to send a message. This is what this composable
    will look like:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部栏的情况下，我们正在添加一个新的可组合组件，该组件将包含`Textfield`和发送消息所需的发送按钮。这就是这个可组合组件的外观：
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are creating a `Box` composable to arrange the children composables
    accordingly (the text field at the left and the `Send` button at the right). Then,
    we’re defining a property called `text` to store text field changes and using
    the `remember` delegate to remember its last value between recompositions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Box`可组合组件来相应地排列子可组合组件（左边的文本字段和右边的`Send`按钮）。然后，我们定义了一个名为`text`的属性来存储文本字段的变化，并使用`remember`代理来记住其重组之间的最后一个值。
- en: 'As shown in the preceding code block, the main components of this composable
    are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，此可组合组件的主要组件如下：
- en: '**OutlinedTextField**: To write the message. It will take its value from the
    text property and modify it every time the value of the text field changes.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OutlinedTextField**：用于编写消息。它将从文本属性中获取其值，并在文本字段值每次更改时修改它。'
- en: '**IconButton**: To send the message. Its **onClick** parameter is not doing
    anything yet (apart from restarting the **text** property value). We will configure
    this in the next chapter.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IconButton**：用于发送消息。它的`onClick`参数目前没有任何作用（除了重启**text**属性值）。我们将在下一章中进行配置。'
- en: With that, our chat screen is almost ready. The last thing we need to do is
    add the messages list.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的聊天屏幕几乎准备好了。我们最后需要做的是添加消息列表。
- en: Adding the messages list
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加消息列表
- en: 'Earlier, we were adding the messages list as a composable in the `content`
    parameter of the `Scaffold` composable. This composable will look as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们曾将消息列表作为可组合组件添加到`Scaffold`可组合组件的`content`参数中。这个可组合组件将如下所示：
- en: '[PRE40]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With that, we have added `LazyColumn`, which will show the list – every item
    in the list is a `MessageItem` composable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们添加了`LazyColumn`，它将显示列表——列表中的每个项目都是一个`MessageItem`可组合组件。
- en: 'Since we haven’t connected it to any kind of data source yet, we are using
    a function to generate a list of fake messages just for preview purposes:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有将其连接到任何类型的数据源，我们正在使用一个函数来生成一个仅用于预览目的的假消息列表：
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can add more messages if you want by adding them to the list that’s been
    created inside the `getFakeMessages()` function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想添加更多消息，可以通过将它们添加到`getFakeMessages()`函数内部创建的列表中来实现。
- en: 'Finally, we should have a screen that looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该有一个看起来像这样的屏幕：
- en: '![Figure 1.13: Chat screen UI finished](img/B19443_01_13.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13：聊天屏幕UI完成](img/B19443_01_13.jpg)'
- en: 'Figure 1.13: Chat screen UI finished'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：聊天屏幕UI完成
- en: With that, we are done with the user interface for now. We will continue working
    on this app during the next two chapters!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在已经完成了用户界面。我们将在接下来的两章中继续开发这个应用！
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this first chapter, we started our first project, WhatsPackt, a messaging
    app.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们开始了我们的第一个项目，WhatsPackt，一个消息应用。
- en: We accomplished several initial tasks to build this app, such as organizing
    modules, preparing dependency injection and navigation, constructing the main
    screen, creating the conversations list, and building the messages list.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了构建此应用的一些初始任务，例如组织模块、准备依赖注入和导航、构建主屏幕、创建对话列表和构建消息列表。
- en: Throughout this process, we’ve learned about modularization and the various
    approaches to organizing it. We’ve also learned about popular libraries for managing
    dependency injection, how to initialize them, and how to set up Compose navigation.
    Additionally, we became familiar with using Jetpack Compose to create our user
    interface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我们学习了模块化以及组织模块的各种方法。我们还了解了用于管理依赖注入的流行库，如何初始化它们，以及如何设置 Compose 导航。此外，我们还熟悉了使用
    Jetpack Compose 来创建我们的用户界面。
- en: As we move forward, it’s time to give some love and life to our chats. In the
    next chapter, we will explore how to retrieve and send messages and integrate
    them into our recently created user interfaces.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，是时候给我们的聊天添加一些活力和生命力了。在下一章中，我们将探讨如何检索和发送消息，并将它们集成到我们最近创建的用户界面中。
