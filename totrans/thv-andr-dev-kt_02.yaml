- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the UI for Your Messaging App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, we’re going to start building a messaging app called
    WhatsPackt (referring to a popular messaging app that you probably already know
    about). At this point in the project, we must make some important technical decisions
    and create the structure needed to build it. This is what we will be focusing
    on, as well as working on the app’s user interface.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have hands-on experience creating a messaging
    app from scratch, organizing and defining the app modules, deciding which dependency
    injection framework you will use, using Jetpack Navigation to navigate between
    the app features, and using Jetpack Compose to build the main parts of the user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is organized into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the app structure and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the main screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the chats list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the messages list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio is the official standard **integrated development environment**
    (**IDE**) for developing Android apps. Although you can use other IDEs, editors,
    and Android tools if you prefer, all the examples in this book will be based on
    this IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, we recommend that you set up your computer with the latest
    stable version of Android Studio installed. If you haven’t already, you can download
    it here: [https://developer.android.com/studio](https://developer.android.com/studio).
    By following the installation steps, you will be able to install the IDE and set
    up at least one emulator with one Android SDK installed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, we can start creating the project. Android Studio will offer
    us a set of templates to start with. We will choose the **Empty Activity** option,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Android Studio new project template selection with the Empty
    Activity option selected](img/B19443_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Android Studio new project template selection with the Empty Activity
    option selected'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be asked to select a project and package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Android Studio – adding a new project name and package name](img/B19443_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Android Studio – adding a new project name and package name'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you’re all set! Android Studio will generate the main folders and
    files needed so that you can start working on our project. Your project structure
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Android Studio – project template structure](img/B19443_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Android Studio – project template structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all the code for this chapter can be found in this book’s GitHub
    repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to start coding our new messaging app. To do so, we will
    have to make some important technical decisions: we will have to decide how our
    project is going to be structured, how we will navigate between the different
    screens or features, and how we are going to set and provide the components needed
    (defining and organizing the dependencies between every component).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the app structure and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before designing the app structure, we must have a basic idea of the features
    it should include. In our case, we want to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A main screen to create new or access already existing conversations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list containing all the conversations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A screen for a single conversation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this is going to be a production-ready app, we must design its code base
    while considering that it should be easy to scale and maintain. In that regard,
    we should use modularization.
  prefs: []
  type: TYPE_NORMAL
- en: Modularization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Modularization** is the practice of dividing the code of an application into
    loosely coupled and self-contained parts, each of which can be compiled and tested
    in isolation. This technique allows developers to break down large and complex
    applications into more manageable parts that are easier to maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: By modularizing Android applications, modules can be built in parallel, which
    can significantly improve build time. Additionally, independent modules can be
    tested separately, which makes it easier to identify and correct errors.
  prefs: []
  type: TYPE_NORMAL
- en: While the most common way to create modules in Android development is by utilizing
    the Android libraries system via Gradle dependencies, alternative build systems
    such as Bazel and Buck also facilitate modularization. Bazel provides a robust
    system for declaring modules and dependencies, and its parallelized building capabilities
    can lead to even faster build times. Similarly, Buck also supports modular development
    by providing fine-grained build rules and speeding up incremental builds.
  prefs: []
  type: TYPE_NORMAL
- en: By exploring various build systems, such as Gradle, Bazel, and Buck, developers
    can find the most suitable modular approach to structure their Android applications.
    Each build system offers unique features for managing dependencies and organizing
    code, enabling developers to implement various patterns to achieve a modular architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Among the organizational patterns, the most common ones are modularization by
    layers and modularization by feature modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modularization by layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common to structure an app by grouping its components based on a set of
    layers depending on the architecture chosen by the developers. One popular architecture
    is clean architecture, which splits the code base between the data, domain (or
    business), and presentation layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this approach, each module focuses on a specific layer of the architecture,
    such as the presentation layer, domain layer, or data layer. These modules are
    usually more independent of each other and may have different responsibilities
    and technologies, depending on the layer they belong to. Following this pattern,
    our app structure would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: App modularization by layers](img/B19443_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: App modularization by layers'
  prefs: []
  type: TYPE_NORMAL
- en: From this diagram, you can see why layer modularization is also referred to
    as vertical modularization.
  prefs: []
  type: TYPE_NORMAL
- en: Modularization by feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When modularizing an app by feature (or using horizontal modularization), the
    application is divided into modules that focus on specific features or related
    tasks, such as authentication or navigation. These horizontal modules can share
    common components and resources. We can see this structure in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: App modularization by feature](img/B19443_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: App modularization by feature'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are going to have a main `app` module that will depend on every
    one of the feature modules that our app needs (one for every one of the features
    we are going to implement). Then, every one of the feature modules will also depend
    on two other common modules (in this example, we have divided them into `common`
    and `common_framework`, using the first to include framework-independent code,
    and the second to use code that depends on the Android framework).
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of this pattern is that it can scale with the company
    if it evolves into a feature-based team (where every team is focused on a single
    or group of features). This will enable every team to be responsible for one feature
    module, or a set of feature modules, where they have ownership of the code in
    those modules. It also allows teams to be easily autonomous regarding their problem
    space and features.
  prefs: []
  type: TYPE_NORMAL
- en: WhatsPackt modularization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our WhatsPackt example, we are going to combine both modularization approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use a modularization based on features for our features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use a modularization based on layers for the common modules. This will
    allow us to share common code between the feature modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure of our modules and its dependencies will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Our app modules structure and dependencies](img/B19443_01_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Our app modules structure and dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to start creating this structure in Android Studio. To create
    a module, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** | **New...** | **New Module**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create New Module** dialog, choose the **Android** **Library** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the **Module name**, **Package name**, and **Language** fields, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.7: The Create New Module dialog](img/B19443_01_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: The Create New Module dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will have to do this same process for all the modules we want to build,
    except for the `:app` module, which should have been already created when we created
    the project. This is going to be our main point of entry to the app. So, we must
    create the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**:****common:domain**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:****common:data**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:****common:framework**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:****feature:create_chat**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:****feature:conversations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:****feature:chat**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we’ve done this, we should have built the following project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: Project structure, including all modules](img/B19443_01_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Project structure, including all modules'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set the dependencies between modules. We will do this in
    the `build.gradle` file of every module. For example, in the `build.gradle` file
    of the `:app` module, include the following code in the `dependencies` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our app modules are ready, we can start working on the next step:
    dependency injection.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Dependency injection** is a design pattern and technique that’s used in software
    engineering to decouple the objects in an application and reduce dependencies
    between them. In Android, dependency injection involves providing an instance
    of a class or a component to another class, rather than creating it explicitly
    within the class itself.'
  prefs: []
  type: TYPE_NORMAL
- en: By implementing dependency injection in an Android app, you can make the app’s
    code more modular, reusable, and testable. Dependency injection also helps improve
    the maintainability of the code base and reduce the complexity of the application
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most popular dependency injection libraries that are used in Android
    development are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dagger** ([https://dagger.dev/](https://dagger.dev/)): Dagger is a compile-time
    dependency injection library developed by Google that uses annotations and code
    generation to create a dependency graph that can be used to provide dependencies
    to the app’s components. Its main advantage is that it builds this dependency
    graph at compile time, whereas other libraries (such as Koin) do it at runtime.
    For larger apps, this can imply a performance problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hilt** ([https://dagger.dev/hilt/](https://dagger.dev/hilt/)): Hilt is a
    dependency injection library built on top of Dagger that provides a simplified
    way to perform dependency injection in Android apps. It reduces the boilerplate
    code required for Dagger and provides predefined bindings for Android-specific
    components, such as activities and fragments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Koin** ([https://insert-koin.io/](https://insert-koin.io/)): Koin is a lightweight
    dependency injection library for Kotlin that focuses on simplicity and ease of
    use. It uses a **domain-specific language** (**DSL**) to define the dependencies
    and provide them to the app’s components, which makes it easier to do the setup
    and start using it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, the choice of dependency injection library depends on your specific
    requirements and preferences, and both Dagger and Koin are worth considering,
    depending on your needs. In this case, we are going to use Hilt as it is the current
    recommendation by Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Hilt in our project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Hilt Gradle plugin to your project-level **build.gradle** file (replace
    **[version]** with the latest version available for you):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the Hilt Gradle plugin and enable view binding in your app-level **build.gradle**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create an **Application** class in our **:app** module. The **Application**
    class serves as a base class for maintaining the global application state (this
    refers to data or settings that need to be maintained throughout the entire life
    cycle of the application). While it’s not created by default, creating a custom
    **Application** class is crucial for initialization tasks, such as setting up
    dependency injection frameworks or initializing libraries. In this particular
    instance, to make Hilt work, you should annotate your **Application** class with
    the **@****HiltAndroidApp** annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we are all set – we will continue defining the modules and dependencies
    once we advance in this project.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to decide what our approach to handling the navigation between
    screens and features in our application will be. It is important to note that
    we are going to use Jetpack Compose to build the user interface of our app, so
    the chosen approach must be compatible with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we’re going to use Navigation Compose as it provides a simple
    and easy-to-use way to handle in-app navigation within an Android app. Here are
    some benefits of using Navigation Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative UI**: Navigation Compose follows the same declarative approach
    as Jetpack Compose, which makes it easier to understand and maintain the navigation
    flow in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type-safety**: With Navigation Compose, you can define your navigation graph
    and actions in a type-safe way. This helps prevent runtime crashes caused by incorrect
    navigation action names and arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation and transition support**: Navigation Compose provides built-in
    support for animating screen transitions, making it easy to create smooth and
    visually appealing navigation experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deep linking**: Navigation Compose supports deep linking, allowing you to
    create URLs that can directly navigate to specific screens or actions within your
    app. This is useful for implementing features such as app shortcuts, notifications,
    or sharing content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with Jetpack Compose**: As part of the Jetpack Compose family,
    Navigation Compose works seamlessly with other Compose libraries and components,
    allowing you to build a consistent UI and navigation experience across your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity and scalability**: Navigation Compose enables you to build modular
    navigation graphs, making it easier to scale your app and manage complex navigation
    flows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, Navigation Compose simplifies navigation management, improves the
    robustness of our app, and will help us to create a more consistent, accessible,
    and visually appealing user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Navigation Compose, we must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to include the dependencies that are required in our Gradle
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The version used in the previous code is the latest stable one at the time of
    writing this book, but there will likely be a new version by the time you are
    reading this.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the **app** module, create a new package called **ui.navigation**.
    Then, create a file called **WhatsPacktNavigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a **NavHost** composable and provide a **NavController** instance.
    The **NavHost** composable functions as a container for managing navigation between
    different composables in an app. It acts as the central hub where navigation routes
    are defined and composables are switched in and out based on the navigation state.
    Each screen or view in your application corresponds to a composable that **NavHost**
    can display. Here, we will start by creating the **WhatsPacktNavigation** composable
    function. This will be responsible for holding **NavHost**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we’ve created the first screen (which we’ll call **MainScreen**), we will
    complete **NavHost**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also include dynamic parameters in the route, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have a second composable that defines another navigation destination
    associated with the `"chat/{chatId}"` route. The `{chatId}` part is a dynamic
    parameter that can be passed when navigating to this destination.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using these two configurations – that is, navigation with and without parameters
    – should have us covered but since we are using feature-based modularization,
    we might encounter the problem of having to navigate from one module to another
    where there isn’t a direct dependency between them. In those cases, we will use
    deep links.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavHost`, you need to add a `deepLink` parameter with the URI pattern you
    want to use for that destination. This pattern should include a scheme, a host,
    and an optional path. In our example, if we have `ChatScreen`, which takes a `chatId`
    argument, we can add a deep link `URI` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'One common practice to keep our `NavHost` leaner and delegate the definition
    of routes and URIs to every screen is to define the route with constants. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, developers can easily manage, update, and maintain the routes
    in a centralized manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in `NavHost`, we would define `uriPattern` using these constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of adding this information to every screen, a better option is to create
    a class where we are going to put all the route constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Having the route’s definition in the same place will facilitate reading and
    maintaining our code so that we can easily manage, update, and maintain the routes
    in a centralized manner, while also improving code readability and reducing the
    possibility of errors caused by hardcoded or duplicated strings throughout the
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will place the file that contains this class in our `:common:framework`
    module as we will need to access those constants from every feature module. Another
    common practice is to create a dedicated `:common:navigation` module and add the
    definition of the route and even the `NavHost` definition there. In our case,
    we will define the routes using the latest approach – that is, route constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we completed our `NavHost` definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, we will want to navigate to three different parts of the app (conversations
    list, create new chat, and the single chat screen). The navigation destinations
    can be added to `NavHost` by using extension functions on `NavGraphBuilder`. These
    extension functions are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `addConversationsList(navController)` sets up `ConversationsListScreen`
    and defines click listeners for navigating to the `NewConversation` and `Chat`
    destinations.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `addNewConversation(navController)` sets up `CreateConversationScreen`
    and defines a click listener for navigating to the `Chat` destination upon creating
    a new conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `addChat(navController)` sets up `ChatScreen` and extracts the `chatId`
    argument from `backStackEntry`. It also defines a click listener for navigating
    back to the previous screen using `navController.popBackStack()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are almost ready to hit the **Run** button for the first time. But
    first, to avoid compilation problems, we should create the screen’s composables
    in their respective modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ConversationsListScreen** in **:feature:conversations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CreateConversationScreen** in **:feature:create_chat**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ChatScreen** in **:feature:chat**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we can create `ChatScreen` and leave it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are missing one last change (for now). We need to include the `MainNavigation`
    composable as the content in `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we’ve added `navHostController`, which we created using `rememberNav`
    **Controller()**. This is used to remember the navigation state across recompositions.
    Here, `navHostController` manages the navigation between different composables
    in the application. Then, the `MainNavigation` composable is called with `navHostController`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have chosen and created the module structure for our app, chosen
    a dependency injection framework, added the dependencies we need, and structured
    the navigation that defines how our screens are going to be accessed. Now, it’s
    time for us to start working on each of the screens we need to build this app.
  prefs: []
  type: TYPE_NORMAL
- en: Building the main screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the main structure of our app ready, it is time to start building
    the main screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze what components our main screen will have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: The ConversationsList screen](img/B19443_01_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: The ConversationsList screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we are going to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A top bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tab bar to navigate to the main sections (note that this book will only cover
    the development of the chat section; we will not cover the status and calls sections)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list containing the current conversations (which we will complete later in
    this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A floating button to create a new chat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the main screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a scaffold to the main screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we created an empty version of the first screen (`ConversationsListScreen`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, it’s time to start working on this screen. The first component we are going
    to add is a `Scaffold`, you can easily organize your app’s layout and maintain
    a consistent look and feel across different screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief overview of the main components of `Scaffold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**topBar**: A slot for placing a top app bar, typically used for displaying
    the app’s title and navigation icons. You can use the **TopAppBar** composable
    to create a top app bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bottomBar**: A slot for placing a bottom app bar, typically used for actions,
    navigation tabs, or a bottom navigation bar. You can use the **BottomAppBar**
    or **TabRow** composable to create a bottom app bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**drawerContent**: A slot for placing a navigation drawer, which is a panel
    that displays the app’s navigation options. You can use the **Drawer** or **ModalDrawer**
    composable to create a navigation drawer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**floatingActionButton**: A slot for placing a floating action button, which
    is a circular button that hovers above the content and represents the primary
    action of the screen. You can use the **FloatingActionButton** composable to create
    a floating action button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**content**: A slot for placing the main content of the screen, which can be
    any composable that displays the app’s data or UI elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we are going to use `topBar`, `bottomBar` with `TabRow` (to navigate
    between tabs), `floatingActionButton` (to create new chats), and the content,
    where we are going to place our main content – in our case, the list of conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `Scaffold` composable in our `ConversationsListScreen`. We
    will add the modifiers for all the components we want to include, but we’ll leave
    them empty (for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Scaffold` composable we have created includes `topBar`, `bottomBar`, `floatingAction`
    **Button**, and the content of the main area of the screen. We will continue implementing
    each of those components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, depending on your Android Studio version, you may see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: An error with the content padding parameter](img/B19443_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: An error with the content padding parameter'
  prefs: []
  type: TYPE_NORMAL
- en: This is happening because the `Scaffold` composable provides a padding parameter
    to the content Lambda. We will need to take this padding into account when we
    place the inside components since the scaffold could overlap them if we don’t.
    For example, in our case, we must consider the padding because otherwise, our
    content will be kept behind `bottomBar`. We will use this parameter layer when
    we build the content.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add a `TopAppBar` composable to the `Scaffold` composable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the TopAppBar composable to the main screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TopAppBar` composable represents a toolbar located at the top of the screen
    and provides a consistent look and feel across different screens in your app.
    It typically displays the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Title**: The main text that’s displayed in the app bar, usually representing
    the app’s name or the current screen’s title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation icon**: An optional icon located at the beginning of the app bar,
    usually used to open a navigation drawer or navigate back into the app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: A set of optional icons or buttons located at the end of the app
    bar, representing common actions or settings related to the current screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add a `TopAppBar` composable, we must create the `conversations_list_title`
    string in the module’s `strings.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we are going to create the `TopAppBar` composable while setting the title
    to `WhatsPackt` and adding `IconButton` with a menu icon. Here, `IconButton` has
    an `onClick` function where you can define the action to perform when the button
    is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to create a `TabRow` composable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the TabRow composable to the bottom of the main screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TabRow` composable is a horizontal row of tabs that allows users to navigate
    between different views or sections within an app. The `TabRow` composable mainly
    consists of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tabs**: A collection of individual **Tab** composables that represent different
    sections or views within the app. Each **Tab** composable can have a text label,
    an icon, or both to describe its content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selected tab indicator**: A visual indicator that highlights the currently
    selected tab, making it easy for users to understand which section they are viewing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before creating the `TabRow` composable, we’ll have to provide a list and the
    tabs it is going to contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add `TabRow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For every row, we are adding a `Tab` composable, where we indicate the title
    (using a `Text` composable), the selected value when the tab is selected, and
    the `onClick` action (which we are not implementing).
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can make our code more readable by creating a data class to
    store the title of the `Tab` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can change our `TabRow` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`TabRow` composables are usually combined with a pager, where the content will
    be shown. When clicking and navigating between tabs, the main content that’s displayed
    should change.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add the pager to our screen content.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pager is a UI component that allows users to swipe through multiple pages
    or screens horizontally or vertically. It is commonly used to display screens
    or views in a carousel-like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use `HorizontalPager`, which, as its name suggests, allows the
    user to horizontally swipe between screens or composables. One of its main advantages
    is that it will not create all pages at once; it will only create the current
    page and the immediate previous/next pages, which will be off-screen. Once a page
    is out of this three-page window, it will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we are going to have to tweak some of the previous code we had in
    our `Conversations``ListScreen` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, since `HorizontalPager` is part of the foundation API and is (at the
    time of writing) an experimental API (which means that it could change its public
    interface in the future), we need to add the `@``OptIn(ExperimentalFoundationApi::class)`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we have added a new field called `pagerState`. Its responsibility is
    to hold the state of the pager, including information about the number of pages,
    the current page, the scrolling position, and the scrolling behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add `HorizontalPager` to the content function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will be using a `LaunchedEffect` function. This function is used to
    manage side effects, such as launching tasks that have been completed asynchronously
    in the context of a composable hierarchy. Side effects are operations that can
    have an impact outside of the composable function itself, such as network requests,
    database operations, or, in the case of the previous example, scrolling to a specific
    page in a pager.
  prefs: []
  type: TYPE_NORMAL
- en: '`LaunchedEffect` takes a key (or a set of keys) as its first parameter. When
    the key changes, the effect will be re-launched, canceling any ongoing work from
    the previous effect. The second parameter is a suspending Lambda function, which
    will be executed in the effect’s coroutine scope.'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using `LaunchedEffect` is that it integrates well with
    the Compose life cycle. When the composable that called `LaunchedEffect` leaves
    the composition, the effect will be automatically canceled, cleaning up any ongoing
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to our code, in our case, we are changing the current page in `pagerState`
    and animating the scroll to the next selected page. This will be triggered every
    time `selectedIndex.value` is changed.
  prefs: []
  type: TYPE_NORMAL
- en: The next component will allow the user to create a new chat – we will create
    this button using a `FloatingActionButton` composable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the FloatingActionButton composable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FloatingActionButton` composable is a Material Design composable that
    represents a circular button floating above the UI. It’s typically used to promote
    the primary action in an application (for example, adding a new item, composing
    a message, or starting a new process). Following the Material Design guidelines
    (you can check them here: [https://m3.material.io/](https://m3.material.io/)),
    we are going to use it to create a new chat from `ConversationsListScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Our `FloatingActionButton` composable is taking an `onClick` modifier. Here,
    we will include the code to navigate to the create chat screen. Inside this button,
    we have included an `Icon` composable, which we are using as an image of one of
    the `Icons.Default` predefined images.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our conversations list screen should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: The conversations list screen with a top bar, tab bar, and floating
    action button](img/B19443_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: The conversations list screen with a top bar, tab bar, and floating
    action button'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have created our `Scaffold` composable with all the elements
    we need to help the user navigate. Now, we are ready for the last step (and the
    most important one) to complete the screen: creating the list of existing conversations.
    To do that, we are going to start creating a conversation item.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the conversations list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create all the pieces we need to show the conversations
    list. We will start with the UI data model, which will represent the information
    that the app is going to show in the list, the `Conversation` composable, which
    will draw every item of the list, and finally the list composable itself.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the conversation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we are going to model what is going to be the entity we will be using
    through our conversations list components: the `Conversation` model.'
  prefs: []
  type: TYPE_NORMAL
- en: As part of the conversation model, we want to show the avatar of the other participant
    (we are just doing one-to-one conversations), their name, the first line of the
    last message, the time the message was received, and a number indicating how many
    unread messages there are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking that information into account, we will start creating a data class to
    hold the data we’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As the avatar could be reusable across the app, we are going to create it first.
    We can include it in the `:common:framework` module so that it is visible and
    can be reused from the other feature modules.
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose doesn’t include support to asynchronously load images from a
    URL out of the box, but there are plenty of third-party libraries that will help
    us accomplish this. The most popular options are Coil and Glide, which, in terms
    of performance, caching, and image loading, are quite similar. We are going to
    use Coil just for simplicity and because it is Kotlin-first (whereas Glide is
    programmed in Java).
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we need to include the dependency in our module’s `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we’re ready to create our `Avatar` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating an avatar using `AsyncImage`, which will load an image
    provided by a URL. This image will be modified to have a circular shape. Also,
    we should pass the size of the image when using this composable (we have chosen
    50 density-independent pixels).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create `ConversationItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at what this composable does:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ConversationItem** composable accepts the following parameters: name,
    message, timestamp, **avatarUrl**, and an optional **unreadMessages** with a default
    value of **0**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Row** layout is used to arrange the contents horizontally. It has a **fillMaxWidth()**
    modifier to occupy the full width of the parent and a padding of 8 density-independent
    pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Avatar** composable is used to display the avatar. We already know how
    it works – the only thing to remark on is that we want it to have a size of 50
    density-independent pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Spacer** composable with a width of 8 density pixels is added to provide
    some space between the avatar and the text content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Column** layout is used to arrange the name and message text vertically.
    The **Column** layout has a **Modifier.weight()** modifier, which ensures that
    it takes up all the available space between the avatar and the timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the **Column** layout, a **Text** composable is used to display the name
    with a bold font weight and a font size of 16 scale-independent pixels. Another
    **Text** composable is used to display the message with a maximum of one line
    and an ellipsis overflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another **Column** layout is added to the main **Row** layout to arrange the
    timestamp and unread messages badge vertically. The **Column** layout has a **horizontalAlignment**
    value of **Alignment.End** to align its children to the end of the available space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this second **Column** layout, a **Text** composable is used to display
    the time with a font size of 12 scale-independent pixels and a gray color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A conditional statement checks if there are any unread messages (that is, **conversation.unreadMessages
    > 0**). If there are unread messages, the unread messages count shows a text with
    a circular background drawn using the **drawBehind** modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our `ConversationItem` composable, it is time to finish this
    screen. Let’s create the `ConversationList` composable!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ConversationList composable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the last step for this screen, we are going to create the list of conversations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `ConversationList` composable takes a list of `Conversation` objects and
    uses `LazyColumn` to display them efficiently. The `items` function is used to
    loop through the conversations list and will render `ConversationItem` for each
    conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will include the list in the `HorizontalPager` logic, in our `ConversationsListScreen`
    composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to test it, we can fake the data of the conversations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that here, I’m using a random avatar generator just to make it as similar
    as possible to how it would be when we connect this UI with real conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what our app would look like with more conversations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: ConversationsList screen completed](img/B19443_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: ConversationsList screen completed'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s switch to the chat screen, also known as the messages list. Whereas
    the conversations list is a list showing all the conversations we have, the messages
    list will show the list of messages we have with one user (a single chat screen).
  prefs: []
  type: TYPE_NORMAL
- en: Building the messages list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create the UI models that are needed to create
    the chat screen and the messages two users could have exchanged. Then, we will
    create the `Message` composable, and finally, the rest of the screen, including
    the list of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the Chat and Message models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Taking into account the information we have to show on the chat screen, we
    are going to need two data models: one for the static data related to the conversation
    (for example, the name of the user we are talking to, their avatar, and so on)
    and one data model per message. This will be the model for the `Chat` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we will need the ID of the chat, the name of the person we are
    talking to, and their avatar address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the `Message` model, we will create the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need the sender’s name, their avatar, the timestamp, whether
    the message is mine or not (which we will take into account so that we can arrange
    the message one to the left or the right), and the content of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Since our application is going to have two types of content (messages and images),
    we need two different kinds of `MessageContent`. That’s the reason it has been
    modeled as a sealed class. We have two data classes with the data needed for every
    type of message content.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to convert these models into some composables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MessageItem composable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MessageItem` composable is going to draw each of our chat messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will create a `Row` layout. We will set the arrangement of the
    row contents depending on the message’s author:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside this row, we are going to place the rest of the components of
    the message. We will start with the avatar; we will only show the avatar if the
    message is not from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we are going to add a `Column` layout so that we can arrange the rest
    of the message information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The message will include the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The name of the sender (if the author is not the current user)**: To know
    if the message is from the current user, the app will check if the author of the
    message is the current user using **if (message.isMine**. If this is positive,
    we will add a **Space** composable; if the message author is not the current user,
    we will show the **Text** composable and their name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The content**: The app will show a bubble containing text if the content
    is text. The color of the bubble will depend on whether the sender of the message
    is the current user and the time the message was created. A timestamp with the
    date and time of creation will be shown at the bottom of the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have `MessageItem`, it’s time to create the rest of the chat screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the TopAppBar and BottomRow composables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did for the conversations list, we are going to add the `Scaffold` structure
    and its `TopAppBar` and `BottomRow` composables to this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are hardcoding the title of the chat. This is just for preview
    purposes; we’ll correct that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the bottom bar, we are adding a new composable that will contain
    `Textfield` and the send button needed to send a message. This is what this composable
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a `Box` composable to arrange the children composables
    accordingly (the text field at the left and the `Send` button at the right). Then,
    we’re defining a property called `text` to store text field changes and using
    the `remember` delegate to remember its last value between recompositions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding code block, the main components of this composable
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OutlinedTextField**: To write the message. It will take its value from the
    text property and modify it every time the value of the text field changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IconButton**: To send the message. Its **onClick** parameter is not doing
    anything yet (apart from restarting the **text** property value). We will configure
    this in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, our chat screen is almost ready. The last thing we need to do is
    add the messages list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the messages list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we were adding the messages list as a composable in the `content`
    parameter of the `Scaffold` composable. This composable will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have added `LazyColumn`, which will show the list – every item
    in the list is a `MessageItem` composable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we haven’t connected it to any kind of data source yet, we are using
    a function to generate a list of fake messages just for preview purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can add more messages if you want by adding them to the list that’s been
    created inside the `getFakeMessages()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should have a screen that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Chat screen UI finished](img/B19443_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Chat screen UI finished'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are done with the user interface for now. We will continue working
    on this app during the next two chapters!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, we started our first project, WhatsPackt, a messaging
    app.
  prefs: []
  type: TYPE_NORMAL
- en: We accomplished several initial tasks to build this app, such as organizing
    modules, preparing dependency injection and navigation, constructing the main
    screen, creating the conversations list, and building the messages list.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this process, we’ve learned about modularization and the various
    approaches to organizing it. We’ve also learned about popular libraries for managing
    dependency injection, how to initialize them, and how to set up Compose navigation.
    Additionally, we became familiar with using Jetpack Compose to create our user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: As we move forward, it’s time to give some love and life to our chats. In the
    next chapter, we will explore how to retrieve and send messages and integrate
    them into our recently created user interfaces.
  prefs: []
  type: TYPE_NORMAL
