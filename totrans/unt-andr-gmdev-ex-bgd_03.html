<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations</h1></div></div></div><p>
<em>In the previous chapter we learned about the GUI. We started by creating a simple Tic-tac-toe game to learn about the basic pieces. This was followed by styling the GUI to change the look of the game. Finally, we adjusted the game so it would expand automatically to fit a screen of any size.</em>
</p><p>
<em>This chapter is about the core of any game: meshes, materials, and animations. Without these blocks there is generally nothing to show players. You could, of course, just use flat images in the GUI. But, where is the fun in that? If you are going to choose a 3D game engine, you might as well make full use of its capabilities.</em>
</p><p>
<em>To understand meshes, materials, and animations, we will be creating a Tank Battle game. This project will be used in a few other chapters. By the end of the book, it will be one of the two robust games we will create. For this chapter, the player will get to drive a tank around a small city, he/she will be able to shoot at animated targets, and we will add a counter to track the scores.</em>
</p><p>This chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Importing the meshes</li><li class="listitem" style="list-style-type: disc">Creating the materials</li><li class="listitem" style="list-style-type: disc">Animations</li><li class="listitem" style="list-style-type: disc">Creating the prefabs</li><li class="listitem" style="list-style-type: disc">Ray tracing</li></ul></div><p>We will be starting a new project for this chapter, so follow along in the first section to get it started.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Setting up</h1></div></div></div><p>Though this project will eventually grow to become much larger than the previous ones, the actual setup is similar and not overly complex. You will also need a number of starting assets for this project; they will be described during the <a id="id184" class="indexterm"/>setup process. Due to the complexity and specific nature of these assets, it is recommended to use the ones provided for now.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Time for action – the setup</h1></div></div></div><p>As we have done in the previous two chapters, we will need to create a new project so that we can create our next game. Obviously, the first thing to do is to start a new Unity project. For organizational purposes, name it <code class="literal">Ch3_TankBattle_CS</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">This project will also grow to become much larger than our previous projects, so we should create some folders to keep things organized. For starters, create six folders. The top level folders will be the <code class="literal">Models</code>, <code class="literal">Scripts</code>, and <code class="literal">Prefabs</code> folders. Inside <code class="literal">Models</code>, create <code class="literal">Environment</code>, <code class="literal">Tanks</code>, and <code class="literal">Targets</code>. Having these folders makes the project significantly more manageable. Any complete model can consist of a mesh file, one or more textures, a material for every texture, and potentially dozens of animation files.</li><li class="listitem">Before we go too far, it is a good idea to change your target platform to Android, if you haven't already done so. Every time the target platform is changed, all of the assets in the project need to be re-imported. This is an automatic step carried out by Unity, but will take an increasing amount of time as your project grows. By setting our target platform before there is anything in the project, we save loads of time later.</li><li class="listitem">We will also make use of a very powerful part of Unity. Prefabs are special objects that make the process of creating a game significantly easier. The name means prefabricated—created beforehand and replicated. What this means for us is, we can completely set up a target for our tank to shoot at and turn it into a prefab. Then, we can place instances of that prefab throughout the game world. If we ever need to make a change to the targets, all we need to do is modify the original prefab. Any change made to a prefab is also made on any instance of that prefab. Don't worry; it makes more sense when used.</li><li class="listitem">We will also need to create some meshes and textures for this project. To start with, we will need a tank. It is kind of hard to have a battle of tanks without any tanks. The tank that is provided has a turret and cannon, which are separate pieces. We will also use a trick to make the tank's treads look like they are moving, so that each of them are separate pieces and also use a separate texture.</li><li class="listitem">For the location of our battle, a portion of a city was created. Instead of applying a specific texture to the city, some tile-able textures will be used. Also, there is a wall around the city to keep the player from falling out of the world.</li><li class="listitem">Finally, we will need an animated target. The one that is provided is rigged up like the human arm, with a bull's eye for the hand. It has four animations. The first starts in a curled position and goes to an extended position. The second is the reverse of the first one, going from the extended position to the curled position.<a id="id185" class="indexterm"/> The third starts in the extended position and is flung back, as if hit in the front, and returns to the curled position. The last is just like the third one, but it goes forward as if hit from behind. These are fairly simple animations, but they will serve us well in learning about Unity's animation system.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>
<em>What just happened?</em>
</h2></div></div></div><p>Very little happened here, we simply created the project and added some folders. There was also a little discussion about the assets we would be using for this chapter's project.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Importing the meshes</h1></div></div></div><p>There are several ways to import assets to Unity. We will be going over perhaps the simplest and certainly the best ways for groups of assets.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Time for action – importing the tank</h1></div></div></div><p>Let's get started.</p><div><ol class="orderedlist arabic"><li class="listitem">Inside the Unity Editor, start <a id="id186" class="indexterm"/>by right-clicking on your <code class="literal">Tanks</code> folder and selecting <strong>Show in Explorer</strong> from the menu.</li><li class="listitem">This opens the folder that contains the asset that was selected. In this case, the <code class="literal">Models</code> folder is opened in the Windows folder browser. We just need to put our tank and its textures into the <code class="literal">Tanks</code> folder.<div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>The files provided for this chapter are <code class="literal">Tank.blend</code>, <code class="literal">Tanks_Type01.png</code>, and <code class="literal">TankTread.png</code> files. Also, utilizing <code class="literal">.blend</code> files in Unity requires Blender to be installed on your system. Blender is a free modeling program available at <a class="ulink" href="http://www.blender.org">http://www.blender.org</a>. Unity makes use of it in order to convert the previously mentioned files into ones that it can fully utilize.</p></div></div></li><li class="listitem">When we return to Unity, the fact that we added files will be detected and they will be automatically imported. This is one of the best things about Unity. There is no need to explicitly tell Unity to import. If there are changes within the project's assets, it just does so.</li><li class="listitem">You might also <a id="id187" class="indexterm"/>notice that an extra folder and some files were created when Unity imported our tank. Whenever a new mesh is imported, by default Unity will try to pair it with the materials. We will go into more detail about what a material is in Unity in the next section. For now, it is an object that keeps track of how to display a texture on a mesh. Based on the information in the mesh, Unity looks in the project for a material with the correct name. If one cannot be found, a <code class="literal">Materials</code> folder is created next to the mesh and the missing materials are created inside it. When creating these materials, Unity also searches for the right textures. This is why it is important to add textures to the folder at the same time as the mesh, so that they all can be imported together. If you did not add the textures at the same time as the tank, the section about creating materials will describe how to add textures to materials.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just imported our tank into Unity. It is really quite simple. Changes made to any of the assets or folders of the project are automatically detected by Unity, and anything that needs to be is suitably imported.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Tank import settings</h1></div></div></div><p>When importing any asset into Unity, it is done by using a default group of settings. Any of these settings can<a id="id188" class="indexterm"/> be changed from the <strong>Inspector</strong> window. With your new tank selected, we will go over the import settings for a model here.</p><div><img src="img/2014OT_03_01.png.jpg" alt="Tank import settings"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The top of the Unity Editor has three tabs: <a id="id189" class="indexterm"/><strong>Model</strong>, <strong>Rig</strong><a id="id190" class="indexterm"/>, and <strong>Animations</strong>. The <strong>Model</strong> page handles the mesh itself, while <strong>Rig</strong> and <strong>Animations</strong><a id="id191" class="indexterm"/> are for importing animations. For now, we only care about the <strong>Model</strong> page, so select it if it is not already selected.</li><li class="listitem" style="list-style-type: disc">The <strong>Meshes</strong> section<a id="id192" class="indexterm"/> of the <strong>Import Settings</strong> window starts with the <strong>Scale Factor</strong> attribute. This is a value that tells Unity how big the mesh is<a id="id193" class="indexterm"/> by default. One generic unit or one meter from your modeling program translates to one unit in Unity. This tank was made in generic units, so the tank's scale factor is one. If you were working in centimeters when making the tank, the scale factor would be 0.01, because a centimeter is a hundredth of a meter.</li><li class="listitem" style="list-style-type: disc">The next option, <a id="id194" class="indexterm"/><strong>Mesh Compression</strong>, will become important in the final chapter when we go over the optimization of our<a id="id195" class="indexterm"/> games. The higher the compression is set, the smaller the file is in the game. However, this will start to introduce weirdness to your mesh as Unity works to make it smaller. For now, leave it <strong>Off</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Read/Write Enabled</strong><a id="id196" class="indexterm"/> is useful if you want to make changes to the mesh while the game is playing. This could allow you to do some really cool things such as destructible environments where your scripts break the meshes into pieces based on where they are being shot at.<a id="id197" class="indexterm"/> However, it also means that Unity has to keep a copy of the mesh in memory, which could really start to lag a system if it is complex. This is outside the scope of this book, so unchecking the option is a good idea.</li><li class="listitem" style="list-style-type: disc"><strong>Optimize Mesh</strong><a id="id198" class="indexterm"/> is a good one to leave on, unless you are doing something specific and fancy with the mesh. With it on, Unity does some special magic behind the scenes. In computer graphics and <a id="id199" class="indexterm"/>especially Unity, every mesh is ultimately a series of triangles being drawn on screen. This option allows Unity to reorder the triangles in the file so that the whole mesh will be drawn faster and more easily.</li><li class="listitem" style="list-style-type: disc">The next option, <a id="id200" class="indexterm"/><strong>Generate Colliders</strong>, is a useful one if doing complex things with <strong>Physics</strong>. Unity has a set of simple collider shapes that should be used whenever possible, because they are easier to process. However, there are situations where they won't quite get the job done, for example, rubble or a half-pipe where the collision shape is too complex to be made with a series of simple shapes. That is why Unity has a <strong>Mesh Collider</strong> component. With this option checked, a <strong>Mesh Collider</strong> component is added to every mesh in our model. We will be sticking with simple colliders in this chapter, so leave the <strong>Generate Colliders</strong> option off.</li><li class="listitem" style="list-style-type: disc"><strong>Swap UVs</strong> <a id="id201" class="indexterm"/>and <strong>Generate Lightmap UVs</strong> are primarily used when working with lighting, especially lightmaps. Unity can handle two sets of UV coordinates on a model. Normally, the first is used for the texture and the second for the lightmap or shadow texture. If they are in the wrong order, <strong>Swap UVs</strong> will change them, so that the second set now comes first. If you need an unwrap for a lightmap, but did not create one, <strong>Generate Lightmap UVs</strong> will create one for you. We are not working with lightmaps in this project, so both of these can remain off.</li><li class="listitem" style="list-style-type: disc">The next section of options, <a id="id202" class="indexterm"/><strong>Normals &amp; Tangents</strong>, begins with the <strong>Normals</strong> option. This defines how Unity will get a hold of the normals of your mesh. By default, they are imported from the file; but there is also the option to make Unity calculate them based on the way the mesh is defined. Or, if we set this option to <strong>None</strong>, Unity will not import the normals. <strong>Normals</strong> are needed if we want our mesh to be affected by real-time lighting or make use of normal maps. We will be making use of real-time lighting in this project, so leave it set to <strong>Import</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Tangents</strong>, <strong>Smoothing Angle</strong>, and <strong>Split Tangents</strong> are used if your mesh has a normal map. <a id="id203" class="indexterm"/>Tangents are needed to determine how lighting interacts with a normal-mapped surface. By default, Unity will calculate these for you. Importing tangents is only possible from a few file types. The <a id="id204" class="indexterm"/>smoothing angle dictates whether shading across an edge would be smooth or sharp, based on the angle between the two faces. The <a id="id205" class="indexterm"/><strong>Split Tangents</strong> option is there to handle a few specific lighting quirks. If lighting is broken by seams, enabling this option will fix it. Normal maps are great for making a low-resolution game look like a high-resolution one. However, because of all the extra files and information needed to use them, they are not ideal for a mobile game. Therefore, we will not be using them in this book and all of these options can be turned off to save memory.</li><li class="listitem" style="list-style-type: disc">The last section, <strong>Materials</strong>, defines how Unity should look for materials. The first option,<a id="id206" class="indexterm"/> <strong>Import Materials</strong>, is to decide whether or not a material should be imported. If it is turned off, a default white material will be applied. This material will not show up anywhere in your project; it is a hidden default. For models that will not have any textures, such as collision meshes, this could be turned off. For our tank and nearly every other case, this should be left on.</li><li class="listitem" style="list-style-type: disc">The last two options,<a id="id207" class="indexterm"/> <strong>Material Naming</strong> and <strong>Material Search</strong><a id="id208" class="indexterm"/>, work together<a id="id209" class="indexterm"/> to name and find the materials for the mesh.<a id="id210" class="indexterm"/> Directly below them, there is a text box that describes how Unity will go about searching for the material. The name of the material being searched for can be the name of the texture used in the modeling program, the name of the material created in the modeling program, or the name of the model plus the material. If a texture name cannot be found, the material name will be used instead. By default, Unity does a <strong>Recursive-Up</strong> search. This means that we start by looking in the <code class="literal">Materials</code> folder, followed by any materials that are in the same folder. We then check the parent folder for matching materials, followed by the folder above that. This continues until we either find the material that has the correct name or we reach the root assets folder. Alternatively we have the options of checking the entire project by only looking in the <code class="literal">Materials</code> folder that is next to our model. The defaults for these options are just fine. In general, they do not need to be changed. They are most easily changed with the Unity Editor scripting, which will not be covered in this book.</li><li class="listitem" style="list-style-type: disc">Next, we have a pair of buttons: <a id="id211" class="indexterm"/><strong>Revert</strong> and <strong>Apply</strong>.<a id="id212" class="indexterm"/> Whenever changes are made to the import settings, one of these two buttons must be chosen. The <strong>Revert</strong> button cancels the changes and switches the import settings back to what they were before changes were made. <strong>Apply</strong> confirms the changes and re-imports the model with the new settings. If these buttons are not selected, Unity will complain with a pop up and force a choice before letting you mess with anything else.<div><img src="img/2014OT_03_02.png.jpg" alt="Tank import settings"/></div></li><li class="listitem" style="list-style-type: disc">Finally, we have two types of previews. The <a id="id213" class="indexterm"/><strong>Imported Object</strong> section is a preview of what the object will look like in the<a id="id214" class="indexterm"/> <strong>Inspector</strong> window, if added to the <strong>Scene</strong> view and selected. The <strong>Preview</strong> window<a id="id215" class="indexterm"/> is what the model will look like in the <strong>Scene</strong> view. You can click-and-drag in this window to rotate the object and look at it from different angles. Also, there is a little blue button in this window. By clicking on this button, you will be able to add labels to the object. Then, these labels are also searchable in the <strong>Project</strong> window.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Setting up the tank</h2></div></div></div><p>Now that we have the tank imported, we need to set it up. We will be adjusting the arrangement of the tank as well as creating a few scripts.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec41"/>Time for action – creating the tank</h1></div></div></div><p>At this point, the creation of <a id="id216" class="indexterm"/>our tank will primarily consist of the creation and arrangement of the tank's components.</p><div><ol class="orderedlist arabic"><li class="listitem">Start by dragging the tank from the <strong>Project</strong> window to the <strong>Hierarchy</strong> window. You will notice that the name of the tank appears in blue color in the <strong>Hierarchy</strong> window. This is because it is a prefab instance. Any model in your project largely acts like a prefab. But, we want our tank to do more than just sit there. So, being a prefab of a static mesh is not helpful. Therefore, select your tank in the <strong>Hierarchy</strong> window and we will start making it useful by removing the <code class="literal">Animator</code> component. To do this, select the gear to the right of the <code class="literal">Animator</code> component in the <strong>Inspector</strong> window. From the new drop-down list, select <strong>Remove Component</strong> and it will be removed.</li><li class="listitem">If you are using the tank provided by default, selecting the different parts of it will reveal that all the pivot points are at the base. This will not be useful for making our turret and cannon pivot properly. The easiest way to solve this is by adding new empty <code class="literal">GameObject</code> to act as pivot points.<div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>Any object in the scene is a <code class="literal">GameObject</code>. Any empty <code class="literal">GameObject</code> is one that only has a <strong>Transform</strong> component.</p></div></div></li><li class="listitem">At the top of the Unity Editor, <strong>Create Empty</strong> is the first option under the <strong>GameObject</strong> button. It creates the objects we need. Create two empty <code class="literal">GameObjects</code>, and position one at the base of the turret and the other at the base of the cannon. Also, rename them to <code class="literal">TurretPivot</code> and <code class="literal">CannonPivot</code> respectively. This can be done with the textbox at the very top of the <strong>Inspector</strong> window, if the object is selected.</li><li class="listitem">In the <strong>Hierarchy</strong> window, drag <code class="literal">TurretPivot</code> onto <code class="literal">Tank</code>. This changes the parent of <code class="literal">TurretPivot</code> to <code class="literal">Tank</code>. Then, drag the object, that is, the turret mesh, onto <code class="literal">TurretPivot</code>. In code, we will be rotating the pivot point, not the mesh directly. When a parent object moves or rotates, all of the children objects move with it. When you make this change, Unity will complain about the change to the original hierarchy of the object; just checking to make sure it is a change you want to do and not an accident.<div><img src="img/2014OT_03_03.png.jpg" alt="Time for action – creating the tank"/></div></li><li class="listitem">Because losing that connection to the prefab can potentially break a game, Unity just wants to be<a id="id217" class="indexterm"/> sure that we actually want it to happen. So, click on <strong>Continue</strong> and we can finish working with the tank without other complaints from Unity. We also need to make <code class="literal">CannonPivot</code> a child of <code class="literal">TurretPivot</code>, and the cannon a child of <code class="literal">CannonPivot</code>.</li><li class="listitem">To finish off our hierarchy changes, we need to place the camera. Because we want it to appear as if the player is actually in the tank, the camera should be placed behind and above the tank with a tilt slightly downward to focus on a spot a few tank lengths ahead. Once positioned, make it a child of <code class="literal">TurretPivot</code> as well.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>
<em>What just happened?</em>
</h2></div></div></div><p>We set up the basic structure that our tank will use. By making use of multiple objects in this way, we can control their movements and actions independently from each other. At this point, instead of having a rigid tank that only points forward, we can tilt, rotate, and aim each piece independently.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>Also, the tank should be centered above the point that you want the whole thing to pivot around. If yours is not, you can select everything that is under the base tank object in the <strong>Hierarchy</strong> window and move it around.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec42"/>Time for action – keeping score</h1></div></div></div><p>A short script for keeping track <a id="id218" class="indexterm"/>of the player's score will constitute the focus of this short section.</p><div><ol class="orderedlist arabic"><li class="listitem">To make this tank work, we are going to need three scripts. The first is fairly simple. Create a new script and name it <code class="literal">ScoreCounter</code>. It will, as the name implies, track the score. Create it in the <code class="literal">Scripts</code> folder and clear out the default functions, just like every other script we have made so far.</li><li class="listitem">Add the following line of code to the new script:<div><pre class="programlisting">public static int score = 0;</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For the most part, this should look familiar from the previous chapter. First we define an integer counter. Because it is static, other scripts (such as the ones we will create for the targets) will be able to modify this number and give us the score.</li></ul></div></li><li class="listitem">We follow with an <code class="literal">OnGUI</code> function that defines a <code class="literal">Rect</code> class and displays the score using the <code class="literal">GUI.Box</code> function. A Box is just like a Label, but it has a black background by default. This will make it easier to see as we move around.<div><pre class="programlisting">public void OnGUI() {
  Rect scoreRect = new Rect(0, 0, 100, 30);
  GUI.Box(scoreRect, "" + score);
}</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just created a very simple script. It will track our score throughout the game. Also, instead of doing any of the score incrementation itself, other scripts will update the counter to give points to the player.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec43"/>Time for action – controlling the chassis</h1></div></div></div><p>A normal tank rotates in place, and it can easily move forward and back. We will make our tank do this with the creation of a single script.</p><div><ol class="orderedlist arabic"><li class="listitem">The second script is called <code class="literal">ChassisControls</code>. It will make our tank move around. Create it in the <code class="literal">Scripts</code> folder as well.</li><li class="listitem">The first three lines<a id="id219" class="indexterm"/> of the script define the variables the tank will need to move around. We will also be able to change them in the <strong>Inspector</strong> window, in case our tank is too fast or too slow. The first line defines a variable that holds a connection to a <code class="literal">CharacterController</code> component. This component will easily move the tank around, but will allow it to be stopped by walls and other colliders. The next two lines of code define how fast we move and rotate:<div><pre class="programlisting">public CharacterController characterControl;
public float moveSpeed = 10f;
public float rotateSpeed = 45f;</pre></div></li><li class="listitem">Now let's add our good friend <code class="literal">OnGUI</code> to the mix. This should look mostly familiar. We are<a id="id220" class="indexterm"/> creating four buttons that will sit in the bottom-left corner of the screen. When the first two buttons are pressed, we make a call to a function that will move our tank and give it a value for how fast it can move. A positive value is going to move us forward and a negative value will move us backward. The last two buttons do the same thing, except with rotation instead of movement. A positive value will rotate to the right and a negative value will rotate the tank to the left. These buttons are also <code class="literal">RepeatButtons</code>. A normal button will only activate once for each time it is pressed. A repeat button is active as long as it is held down. The good side of this is that it will allow our tank to move every frame the button is held down. The down side is a quirk in how the <code class="literal">RepeatButton</code> and <code class="literal">OnGUI</code> functions work. If one of these buttons is active, nothing will be drawn after that button in the <code class="literal">OnGUI</code> function. It is a bit annoying, but suits our needs for now.<div><pre class="programlisting">public void OnGUI() {
  Rect fore = new Rect(50, Screen.height – 150, 50, 50);
  if(GUI.RepeatButton(fore, "f")) {
    MoveTank(moveSpeed);
  }

  Rect back = new Rect(50, Screen.height – 50, 50, 50);
  if(GUI.RepeatButton(back, "b")) {
    MoveTank(-moveSpeed);
  }

  Rect left = new Rect(0, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(left, "l")) {
    RotateTank(-rotateSpeed);
  }

  Rect right = new Rect(100, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(right, "r")) {
    RotateTank(rotateSpeed);
  }
}</pre></div></li><li class="listitem">Only two functions left to go. We start the following line of code by defining our <code class="literal">MoveTank</code> function. It needs to be passed with a speed value to dictate how far and in which direction to go. It was mentioned a moment ago; a positive value will go forward and a negative value will go backwards.<div><pre class="programlisting">public void MoveTank(float speed) {</pre></div></li><li class="listitem">In order to move in three-dimensional spaces, we need a vector—a value with both direction and magnitude. Therefore, we define a movement vector and set it to the tank's forward direction, multiplied by the tank's speed, and again multiplied by the amount of time since the last frame. If you remember from the geometry class, <a id="id221" class="indexterm"/>3D space has three directions: x, y, and z. In Unity, the following convention applies: x is to the right, y is up, and z is forward. The <strong>Transform</strong> component holds an object's position, rotation, and scale. We can access the <strong>Transform</strong> component of any object in Unity by calling upon the <code class="literal">.transform</code> value that Unity provides. The <strong>Transform</strong> component also provides a forward value that will give us a vector that points forward relative to the object. Also, we want to move at a regular pace, for example, a certain number of meters per second, hence we make use of <code class="literal">Time.deltaTime</code>. This is a value provided by Unity that holds how many seconds it has been since the last frame of the game was drawn on screen. Think of it like a flip book. In order to make it look like a guy is walking across the page, he needs to move slightly on each page. In the case of a game, the pages are not flipped regularly. So, we have to modify our movement by how long it has taken to flip to the new page. This helps us to maintain an even pace.<div><pre class="programlisting">  Vector3 move = characterControl.transform.forward * speed * Time.deltaTime;</pre></div></li><li class="listitem">Next, we want to stay on the ground. In general, any character you want to control in a game does not automatically receive all of the physics that a boulder would, such as gravity. For example, when jumping,  you temporarily remove gravity so the character can go up. That is why the next line of code does a simple implementation of gravity by subtracting the normal speed of gravity and again keeps it in pace with our frame rate:<div><pre class="programlisting">  move.y -= 9.8f * Time.deltaTime;</pre></div></li><li class="listitem">Finally, for the <a id="id222" class="indexterm"/><code class="literal">MoveTank</code> function, we actually do the moving. The <code class="literal">CharacterController</code> component has a special <code class="literal">Move</code> function that will move the character but constrain it by collisions. We just need to tell it how far and in which direction we want to move this frame by passing the <code class="literal">Move</code> vector to it. That final curly brace, of course, closes off the function.<div><pre class="programlisting">  characterControl.Move(move);
}</pre></div></li><li class="listitem">The <code class="literal">RotateTank</code> function is the last one. This function also needs a speed value to dictate how fast and in which direction to rotate. We start by defining another vector; but, instead of defining which direction to move, this one will dictate which direction to rotate around. In this case, we will be rotating around our up direction. We then multiply that by our speed and <code class="literal">Time.deltaTime</code> to move fast enough and keep pace with our frame rate.<div><pre class="programlisting">public void RotateTank(float speed) {Vector3 rotate = Vector3.up * speed * Time.deltaTime;</pre></div></li><li class="listitem">The last bit of the function actually does the rotation. The <strong>Transform</strong> component provides a <code class="literal">Rotate</code> function. Rotation, especially in 3D space, can become weird and<a id="id223" class="indexterm"/> difficult very quickly. The <code class="literal">Rotate</code> function handles all of that for us; we just need to supply it with the values to be applied for rotation. Also, don't forget the curly brace to close off the function.<div><pre class="programlisting">  characterControl.transform.Rotate(rotate);
}</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a script to control the movement of our tank. It will draw a group of buttons on the screen, so that our tank can move forward and back. This is done using a special <code class="literal">Move</code> function from the <code class="literal">CharacterController</code> component. We also used a special <code class="literal">Rotate</code> function provided by the <strong>Transform</strong> component to rotate our tank using another set of buttons.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec44"/>Time for action – controlling the turret</h1></div></div></div><p>This script will allow the player<a id="id224" class="indexterm"/> to rotate their turret and aim the cannon.</p><div><ol class="orderedlist arabic"><li class="listitem">The last script we need to create for our tank is <code class="literal">TurretControls</code>. This script will allow players to rotate the turret left and right and tilt the cannon up and down. As with all of the others, create it in the <code class="literal">Scripts</code> folder.</li><li class="listitem">The first two variables we define will hold pointers to the turret and cannon pivots, the empty <code class="literal">GameObjects</code> that we created for our tank. The second set is the speed that our turret and cannon will rotate at. Finally we have some limit values. If we didn't limit how much our cannon could rotate, it would just spin around and around, passing through our tank. This isn't the most realistic behavior for a tank, so we must put some limits on it. The limits are in the range of 300 because straight ahead is zero degree and down is 90 degree. We want it to be the upwards angle, so it is in the range of 300. We also use 359.9 because Unity will change 360 to zero so it can continue to rotate.<div><pre class="programlisting">public Transform turretPivot;
public Transform cannonPivot;

public float turretSpeed = 45f;
public float cannonSpeed = 20f;

public float lowCannonLimit = 315f;
public float highCannonLimit = 359.9f;</pre></div></li><li class="listitem">The next step is to create the <code class="literal">OnGUI</code> function to draw buttons and give the player control of the turret. This function is almost identical to the <code class="literal">OnGUI</code> function we made for the <code class="literal">ChassisControls</code> script. The differences are in the fact that the <code class="literal">Rects</code> class will move to the bottom-right corner of the screen, and that we are calling the <code class="literal">RotateCannon</code> and <code class="literal">RotateTurret</code> functions. When we send a speed to <code class="literal">RotateCannon</code>, we need a positive value to go up and a negative value to <a id="id225" class="indexterm"/>go down. <code class="literal">RotateTurret</code> will largely function like the <code class="literal">RotateTank</code> function; a positive speed will rotate to the right and a negative speed will rotate to the left.<div><pre class="programlisting">public void OnGUI() {
  Rect up = new Rect(Screen.width – 100, Screen.height – 150, 50, 50);
  if(GUI.RepeatButton(up, "u")) {
    RotateCannon(cannonSpeed);
  }

  Rect down = new Rect(Screen.width – 100, Screen.height – 50, 50, 50);
  if(GUI.RepeatButton(down, "d")) {
    RotateCannon(-cannonSpeed);
  }

  Rect left = new Rect(Screen.width – 150, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(left, "l")) {
    RotateTurret(-turretSpeed);
  }

  Rect right = new Rect(Screen.width – 50, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(right, "r")) {
    RotateTurret(turretSpeed);
  }
}</pre></div></li><li class="listitem">Next is the <a id="id226" class="indexterm"/><code class="literal">RotateTurret</code> function. It works exactly in the same way as the <code class="literal">RotateTank</code> function. However, instead of looking at a <code class="literal">CharacterController</code> component 's <code class="literal">Transform</code> variable, we act upon the <code class="literal">turretPivot</code> variable that was defined at the beginning of the function.<div><pre class="programlisting">public void RotateTurret(float speed) {
  Vector3 rotate = Vector3.up * speed * Time.deltaTime;
  turretPivot.Rotate(rotate);
}</pre></div></li><li class="listitem">The last function, <code class="literal">RotateCannon</code>, gets a little more down-and-dirty with rotations. The fault completely lies with the need to put limits on the rotation of the cannon. After <a id="id227" class="indexterm"/>opening the function, the first step is to figure out how much we are going to be rotating this frame. We are using a float value instead of a vector because we have to set the rotation ourselves.<div><pre class="programlisting">public void RotateCannon(float speed) {
  float rotate = speed * Time.deltaTime;</pre></div></li><li class="listitem">Next, we define a variable that holds our current rotation. We do this because Unity will not let us act on the rotation directly. Unity actually keeps track of rotation as a quaternion. This is a complex method of defining rotations that is beyond the scope of this book. Luckily, Unity gives us access to an x, y, z method of defining rotations called <code class="literal">EulerAngles</code>. It is a rotation around each of the three axes in 3D space. The <code class="literal">localEulerAngles</code> value of a <strong>Transform</strong> component is the rotation relative to the parent <code class="literal">GameObject</code>.<div><pre class="programlisting">Vector3 euler = cannonPivot.localEulerAngles;</pre></div><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>It is called <code class="literal">EulerAngles</code> because of <em>Leonhard Euler</em>, a Swiss mathematician who defined this method of defining rotations.</p></div></div></li><li class="listitem">Next, we adjust the rotation and apply the limits in one go through the use of the <code class="literal">Mathf.Clamp</code> function<a id="id228" class="indexterm"/>. <code class="literal">Mathf</code> is a group of useful math functions. The <code class="literal">Clamp</code> function takes a value and makes it no lower and no higher than the other two values passed to the function. So, we first send it our x axis rotation, which is the result of subtracting <code class="literal">rotate</code> from the current x rotation of <code class="literal">euler</code>. Because the positive rotation is clockwise around an axis, we have to subtract our rotation to go up instead of down with a positive value. Next, we pass our lower limit to the <code class="literal">Clamp</code> function, followed by our higher limit: the <code class="literal">lowCannonLimit</code> and <code class="literal">highCannonLimit</code> variables that we defined at the top of the script.<div><pre class="programlisting">euler.x = Mathf.Clamp(euler.x – rotate, lowCannonLimit, highCannonLimit);</pre></div></li><li class="listitem">Finally, we have to actually apply the new rotation to our cannon's pivot point. This is simply setting the <code class="literal">localEulerAngles</code> value of the <strong>Transform</strong> component to the new value. And again, be sure to use the curly brace to close off the function.<div><pre class="programlisting">  cannonPivot.localEulerAngles = euler;
}</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a script that will control the turret of the tank. Through the use of buttons on the screen, the player is able<a id="id229" class="indexterm"/> to tilt the cannon and rotate the turret. This script functioned in a very similar manner to the <code class="literal">ChassisControls</code> script we created earlier. The difference came in limiting the amount the cannon can tilt.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec45"/>Time for action – putting the pieces together</h1></div></div></div><p>That was the last of the scripts, for the moment. We have our tank and our scripts; the next step is to put them<a id="id230" class="indexterm"/> together.</p><div><ol class="orderedlist arabic"><li class="listitem">Now, we need to add them to our tank. Remember how we added our <code class="literal">Tic-tac-toe</code> script to the camera in the last chapter? Start by selecting your tank in the <strong>Hierarchy</strong> window. Before they work, we will first need to add the <code class="literal">CharacterController</code> component to our tank. So, go to the top of the Unity Editor and select <strong>Component</strong>, then select <strong>Physics</strong>, and finally click on the <strong>Character Controller</strong> option.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You will notice that a green capsule also appears on the tank in the Scene view; at the same time the new component is added. This capsule represents the space that will collide and interact with other colliders. The values on the CharacterController component let us control how it interacts with other colliders. For most cases, the defaults for the first four are just fine.<p>
<strong>Slope Limit</strong>: This attribute shows us how steep an incline the controller can move up.</p><p>
<strong>Step Offset</strong>: This attribute shows us how high a step can be before it starts to block movement.</p><p>
<strong>Skin Width</strong>: This defines how far another collider can penetrate this controller's collider before it is completely stopped. This is mostly used for squeezing between objects.</p><p>
<strong>Min Move Distance</strong>: This attribute is for limiting jitter. It is the minimum amount of movement that has to be applied in a frame before it will actually move.</p><p>
<strong>Center</strong>, <strong>Radius</strong>, and <strong>Height</strong>: These attributes define the size of the capsule that you see in the Scene view. They are used for the collision.</p><div><img src="img/2014OT_03_04.png.jpg" alt="Time for action – putting the pieces together"/></div></li></ul></div></li><li class="listitem">The last three values are what we care about right now. We need to adjust these values to <a id="id231" class="indexterm"/>match our tank's values as closely as possible. Admittedly the capsule is round and our tank is square, but a <code class="literal">CharacterController</code> component is the easiest way to move a character with collision and will be used most often. Use values of <code class="literal">2.3</code> for the <strong>Radius</strong> attribute and the <strong>Y</strong> portion of the <strong>Center</strong> attribute; everything else can be left at the default values.</li><li class="listitem">It is now time to add the scripts to our tank. Do this by selecting the tank in the <strong>Hierarchy</strong> window and dragging the <code class="literal">ChassisControls</code>, <code class="literal">TurretControls</code>, and <code class="literal">ScoreCounter</code> scripts onto the <strong>Inspector</strong> window. This is just as we did it in the previous chapters.</li><li class="listitem">Before the tank will work, we need to finish creating the connections that we started in our scripts. Start by clicking the <code class="literal">CharacterController</code> component's name and dragging it to the <strong>Character Control</strong> value that is on our new <code class="literal">ChassisControls</code> script component. Unity lets us connect object variables in the Unity Editor, so that they do not have to be hard coded.</li><li class="listitem">We also need to connect our turret and cannon pivot points. So, click-and-drag the points from the <strong>Hierarchy</strong> window to the corresponding variable on the <code class="literal">TurretControls</code> script component.</li><li class="listitem">Save the scene as <code class="literal">TankBattle</code> and try it out.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just finished putting our tank together. Unless you look at the <strong>Scene</strong> view while using the movement controls, it is hard to tell that the tank is moving. The turret controls can be seen in the <strong>Game</strong> view, though. Other than not having a point of reference for whether or not our tank is moving, it runs pretty well. The next step and the next section will give us that reference point as we add our city.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Have a go hero – cannon alignment</h2></div></div></div><p>You might notice a quick jump when you first try to tilt the cannon. Such behavior is annoying and makes the game look broken. Try adjusting the cannon to fix it. If you are having trouble with it, take a look at the cannon's starting rotation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec46"/>Creating the materials</h1></div></div></div><p>In Unity, the materials are<a id="id232" class="indexterm"/> the defining factor for how models are drawn on the screen. They can be as simple as coloring it all blue, or as complex as reflective water with waves. In this section, we will cover the details of the controls for a material. We will also create our city and some simple materials to texture it with.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec47"/>Time for action – creating the city</h1></div></div></div><p>Creating a city gives our tanks and our players a good place to play.</p><div><ol class="orderedlist arabic"><li class="listitem">For the purposes of this section, no part of the provided city was given a specific texture. It was just unwrapped and some tile-able textures were created. So, we need to start by importing the city and the textures to the <code class="literal">Environment</code> folder. Do it the same way that we imported the tank.<div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>The files are <code class="literal">TankBattleCity.blend</code>, <code class="literal">brick_001.png</code>, <code class="literal">brick_002.png</code>, <code class="literal">brick_003.png</code>, <code class="literal">dirt_001.png</code>, <code class="literal">dirt_003.png</code>, <code class="literal">pebbles_001.png</code>, <code class="literal">rocks_001.png</code>, <code class="literal">rubble_001.png</code>, and <code class="literal">water_002.png</code>.</p></div></div></li><li class="listitem">Because the city was unwrapped, Unity still created a single material for it. However, textures were never applied in any modeling program. So, the material is plain white. We have several extra textures, so we are going to need more than that one material for the whole city. Creating a new material is simple; it is done just as with creating a new script. Right-click on the <code class="literal">Materials</code> folder inside the <code class="literal">Environment</code> folder, and select <strong>Create</strong> followed by <strong>Material</strong>, which is about halfway down the menu.</li><li class="listitem">This will create a new material in the folder and immediately allow us to name it. Name the material, <code class="literal">Pebbles</code>.<div><img src="img/2014OT_03_05.png.jpg" alt="Time for action – creating the city"/></div></li><li class="listitem">With your new material selected, take a look at the <strong>Inspector</strong> window. When we have a<a id="id233" class="indexterm"/> material selected, we get the options needed to change its look.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At the very top of the <strong>Inspector</strong> window, we have the material's name, followed by a <strong>Shader</strong> drop-down list. A shader is essentially a short script that tells the graphics card how to draw something on screen. You will use the <strong>Diffuse</strong> shader most often, so it is always selected by default. This is where you would select from your Bump-mapped shaders, specular, transparent, and a plethora of other options. If you were to create some custom shaders, they would also be found here.</li><li class="listitem" style="list-style-type: disc">The next little block will only be visible if Unity has something to warn you about. In this case, it is advising us to use a different shader for performance reasons. However, that is a discussion for <a class="link" href="ch09.html" title="Chapter 9. Optimization">Chapter 9</a>, <em>Optimization</em>, so we will ignore it for now.</li><li class="listitem" style="list-style-type: disc">Then, we have the <strong>Main Color</strong> value with a colored square next to it. By clicking on that square, the <strong>Color Picker</strong> window will open and let us select any color we want. This color value changes the tinting on the texture being drawn by the material. Because we don't have a texture yet, you will notice that it just changes the color of the ball in the <strong>Preview</strong> window.</li><li class="listitem" style="list-style-type: disc">The <strong>Base (RGB)</strong> value is under the <strong>Main Color</strong> value. This is the texture. The box on the right, with <strong>None (Texture)</strong> and a <strong>Select</strong> button<a id="id234" class="indexterm"/> in it, is a preview box for the texture being used by this material. To add a texture to the material, either drag one to this box from the <strong>Project</strong> window, or click on the <strong>Select</strong> button. The button opens a new window that holds the thumbnails of every texture that is currently in the project. You can scroll through or use the search bar to find the texture that you need and double-click to select it.</li><li class="listitem" style="list-style-type: disc">To the left of the box, we have our <strong>Tiling</strong> and <strong>Offset</strong> controls. The <strong>Tiling</strong> values dictate how many times the texture will repeat across the normalized UV space in the x and y directions. The <strong>Offset</strong> is how far off zero the texture starts in the normalized UV space. You can select the number fields and input values to modify them. Doing so, and paying attention to the <strong>Preview</strong> window below, you will see how they change the texture. Tiling textures are most commonly used for large surfaces where the texture is similar enough across the surface that it just repeats.</li><li class="listitem" style="list-style-type: disc">Our <strong>Preview</strong> window is at the bottom of the <strong>Inspector</strong> window. It functions just as the one we saw for our tank mesh. What makes this one special, though, is the two buttons in the top-right corner of this window. The one to the left scrolls through a set of preview shapes. By clicking on it you'll be able to see how the texture looks on a sphere, cube, cylinder, or torus. The other button toggles between the two types of lighting.</li></ul></div></li><li class="listitem">Add the <code class="literal">pebbles_001</code> texture to this material by dragging it from the <strong>Project</strong> window and dropping it on the <strong>Base (RGB)</strong> preview box.</li><li class="listitem">Use values of 30 for the material's <strong>Tiling</strong> and a light tan color for the <strong>Main Color</strong> option, so that the texture can be sized right and more pleasing to look at.</li><li class="listitem">To see our new material in action, first drag your city to the <strong>Hierarchy</strong> window, so that it is added to the <strong>Scene</strong> view. By right-clicking-and-dragging, you can look around in your <strong>Scene</strong> view. Look over at the streets of the city.</li><li class="listitem">Now, drag your new material from the <strong>Project</strong> window into your <strong>Scene</strong> view. While<a id="id235" class="indexterm"/> dragging the material around, you should see the meshes change to appear as if they are using the material. Once you are over the streets, let go of your left mouse button. The material is now applied to the mesh.</li><li class="listitem">However, we currently have a whole quarter of a city to texture. So, create more materials and use the remaining textures on the rest of the city. Create a new material for each extra texture, plus four extra of <code class="literal">brick_002</code>, so, we can have different colors for each building height.</li><li class="listitem">Apply your new materials to the city, either by comparison with the following figure or through your own artistic whim:<div><img src="img/2014OT_03_06.png.jpg" alt="Time for action – creating the city"/></div><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>When trying<a id="id236" class="indexterm"/> to get to the center fountain, if your tank is in the way, select your tank in the <strong>Hierarchy</strong> window and use the <strong>Gizmo</strong> option in the <strong>Scene</strong> view to drag it out of the way.</p></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you were to try to play the game now, you might notice that we have a couple of problems. For starters, we only have a quarter of a city; perhaps you have more if you made your own city. There is still no collision on the city, so we fall right through it when moving. Also, the tank is a little large for this city, and it is too dark to see where we are going. Turning on the lights is the quickest solution to fix this problem.</li></ul></div></li><li class="listitem">At the top of the Unity Editor, select <strong>GameObject</strong>, followed by <strong>Create Other</strong>, and finally <strong>Directional Light</strong>. This creates an object that emits light in a single direction. The next chapter explains lights and how to control them, so the details will be left for later.</li><li class="listitem">Changing the size of our tank is also pretty simple. Select it in the <strong>Hierarchy</strong> window and look for the <strong>Scale</strong> label in our <strong>Transform</strong> component. Changing the <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> values under <strong>Scale</strong> will change the size of our tank. Be sure to change them evenly or some weirdness will occur when we start rotating the tank. Values of 0.5 make the tank small enough to fit through the <a id="id237" class="indexterm"/>small streets.</li><li class="listitem">Next up is collision for the city. For the most part, we will be able to get away with simple collision shapes that are faster to process. However, the circular center of the city will require something special. Start by double-clicking on the walls of one of the square buildings in the <strong>Scene</strong> view.<div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>When dealing with prefabs, which the city still is, clicking on any object that makes up the prefab will select the root prefab object. Once a prefab is selected, clicking on any part of it will select that individual piece. Because this behavior is different from non-prefab objects, you need to be mindful of it when selecting objects in the <strong>Scene</strong> view.</p></div></div></li><li class="listitem">With a set of walls selected, go to the top of the Unity Editor and select <strong>Component</strong>, followed by <strong>Physics</strong>, and finally <strong>Box Collider</strong>.</li><li class="listitem">Because we are adding the collider to a specific mesh, Unity does its best to automatically fit the collider to the shape. For us, this means that the new <code class="literal">BoxCollider</code> component is already sized to fit the building. Continue by adding <code class="literal">BoxColliders</code> to the rest of the square buildings and the outer wall. Our streets are essentially just a plain, so a <code class="literal">BoxCollider</code> component will work just fine for them as well. Though pointed at the top, the obelisk in the center of the fountain is essentially just a box; so, another <code class="literal">BoxCollider</code> will suit it fine.</li><li class="listitem">We have one last building and the fountain ring to deal with. These are not boxes, spheres, or capsules. So, our simple colliders will not work. Select the walls of the last building, the one next to the center fountain. A few options down from where you were selecting <strong>Box Collider</strong>, there is a <strong>Mesh Collider</strong> option. This will add a <code class="literal">MeshCollider</code> component to our object. This component does what its name suggests; it takes a mesh and turns it into a collider. By adding it to a specific mesh, the <code class="literal">MeshCollider</code> component automatically selects that mesh to be collideable. You should also add <code class="literal">MeshColliders</code> to the short ledge around the center building and the ring wall around the fountain.</li><li class="listitem">The last problem to solve is the duplication of our city quarter. Start by selecting the root <code class="literal">city</code> object in your hierarchy, <code class="literal">TankBattleCity</code>, and remove the <code class="literal">Animator</code> component from it. The city is not going to animate, so it does not need this component.</li><li class="listitem">Now, right-click on the city in the <strong>Hierarchy</strong> window and select <strong>Duplicate</strong>. This creates a copy of the object that was selected.</li><li class="listitem">Duplicate the city quarter twice more and we will have the four parts of our city. The only problem is that they are all in the exact same position.</li><li class="listitem">We need to rotate three of the pieces to make a full city. Select one and set the <strong>Y Rotation</strong> value in the <strong>Transform</strong> component to <code class="literal">90</code>. This will rotate it 90 degrees around the vertical axis and give us half of a city.</li><li class="listitem">We will complete<a id="id238" class="indexterm"/> the city by setting one of the remaining pieces to <code class="literal">180</code> and another to <code class="literal">270</code>.</li><li class="listitem">That leaves one last thing to do. We have four center fountains. In three of the four city pieces, select the three meshes that make up the center fountain (the <code class="literal">Obelisk</code>, <code class="literal">Wall</code>, and <code class="literal">Water</code>) and click on the <em>Delete</em> key on your keyboard. Confirm that you want to break the prefab connection each time, and our city will be complete.<div><img src="img/2014OT_03_07.png.jpg" alt="Time for action – creating the city"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>
<em>What just happened?</em>
</h2></div></div></div><p>Try out the game now. We can drive around the city and rotate our turret. It is so much fun. We created materials<a id="id239" class="indexterm"/> and textured the city. After making it possible to collide with the buildings and road, we duplicated the section so that we could have a whole city.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Have a go hero – decorating the city</h2></div></div></div><p>Now that you have all the skills needed to import meshes and create materials, the challenge is to decorate the city. Create some rubble and tank traps and practice importing them to Unity and setting them up in the scene. If you really want to go above and beyond, try your hand at creating your own city. Choose something from the world, or choose something from your imagination. Once it is created, we can release the tanks in it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec48"/>Time for action – moving treads</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">There is just one thing left to do, and then we will be done with materials and can go on to make the game even more fun. Remember the <strong>Offset</strong> value of the materials? It turns out that we can actually control that with a script. Start by opening up the <code class="literal">ChassisControls</code> script.</li><li class="listitem">First, we need to add a few variables to the beginning of the script. The first two will hold references to our tank tread renderers, the part of the mesh object that keeps track of the material that is applied to the mesh and actually does the drawing. This is just like how the <code class="literal">characterControl</code> variable holds a reference to our <code class="literal">CharacterController</code> component.<div><pre class="programlisting">public Renderer rightTread;
public Renderer leftTread;</pre></div></li><li class="listitem">The second two variables will keep track of the amount of offset applied to each tread. We store it here because it is a faster reference than trying to look it up from the thread's material each frame.<div><pre class="programlisting">private float rightOffset = 0;
private float leftOffset = 0;</pre></div></li><li class="listitem">To make use of the new values, these lines need to be added to the end of the <code class="literal">MoveTank</code> function<a id="id240" class="indexterm"/>. The first line here adjusts the offset for the right tread as per our speed and keeps in time with our frame rate. The second line utilizes the material value of a <code class="literal">Renderer</code> component to find our tank tread material. The <code class="literal">mainTextureOffset</code> value of the material is the offset of the primary texture in the material. In the case of our diffuse materials, it is the only texture. Then, we have to set the offset to a new <code class="literal">Vector2</code> value that will contain our new offset value. <code class="literal">Vector2</code> is just like <code class="literal">Vector3</code> we used for moving, but works in 2D space instead of 3D space. A texture is flat, hence 2D space. The last two lines of the code do the same thing as the other two, but for the left tank tread.<div><pre class="programlisting">rightOffset += speed * Time.deltaTime;
rightTread.material.mainTextureOffset = new Vector2(rightOffset, 0);
leftOffset += speed * Time.deltaTime;
leftTread.material.mainTextureOffset = new Vector2(leftOffset, 0);</pre></div></li><li class="listitem">To make the connections to the <code class="literal">Renderer</code> components of our treads, do the same thing that we did for the pivot points: drag the tread meshes from the <strong>Hierarchy</strong> window to the corresponding value in the <strong>Inspector</strong> window. Once done, be sure to save it and try it out.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>
<em>What just happened?</em>
</h2></div></div></div><p>We updated our <code class="literal">ChassisControls</code> script to make the tank treads move. As the tank is driven around, the textures pan in the appropriate direction. This is the same type of functionality that is used to make waves in water and other textures that move.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Have a go hero – turning with the treads</h2></div></div></div><p>The movement of the material doesn't quite match the speed of the tank. Figure out how to add a speed value for the tank's treads. Also, it would be cool if they moved in opposite directions when the tank is rotating. Real tanks turn by making one tread go forward and the other back.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec49"/>Animations</h1></div></div></div><p>The next topic we will be covering is animation. As we explore animations in Unity, we will be creating some targets for our tank to shoot at. Much of the power of Unity's animation system, Mecanim, lies<a id="id241" class="indexterm"/> in working with humanoid characters. But, setting up and animating human type characters is a book unto itself, so it will not be covered here. However, there is still much we can learn and do with Mecanim.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Before we continue with the explanation of the animation import settings, we need an animated model to work with. We have one last set of assets to import to our project. Import the <code class="literal">Target.blend</code> and <code class="literal">Target.png</code> files into the <code class="literal">Targets</code> folder of our project. Once imported, adjust the <strong>Import Settings</strong> window on the <strong>Model</strong> page for the target, just as we did for the tank. Now switch to the <strong>Rig</strong> tab.<div><img src="img/2014OT_03_08.png.jpg" alt="Animations"/></div></li><li class="listitem" style="list-style-type: disc">The <strong>Animation Type</strong> attribute tells <a id="id242" class="indexterm"/>Unity what type of skeleton the current model is going to use when animating.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>Humanoid</strong> option adds many more buttons and switches to this page for working with human type characters. But again, it is too complex to cover here.</li><li class="listitem" style="list-style-type: disc">A <strong>Generic</strong> rig still uses Mecanim and many of its features. Really, this is just any animation skeleton that does not resemble a human in structure.</li><li class="listitem" style="list-style-type: disc">The third option, <strong>Legacy</strong>, utilizes Unity's old animation system. But, this system will be phased out over the next few versions of Unity, so it will not be covered either.</li><li class="listitem" style="list-style-type: disc">The last option, <strong>None</strong>, indicates that the object will not be animating. You could select this option for both the tank and the city, because it also keeps Unity from adding that <code class="literal">Animator</code> component and saves space in the final project size.</li><li class="listitem" style="list-style-type: disc">The <strong>Root Node</strong> value is a list of every object that is in the model file. Its purpose is to select the base object of your animation rig. For this target, select <strong>Bone_Arm_Upper</strong>, which is underneath the second <strong>Armature</strong> option.</li></ul></div><div><img src="img/2014OT_03_09.png.jpg" alt="Animations"/></div></li><li class="listitem" style="list-style-type: disc">The last page of the import settings, <strong>Animations</strong>, contains everything that we need to get the animations from our files into Unity. At the top of the <strong>Target Import Settings</strong> window, we have the <strong>Import Animation</strong> checkbox. If an object is not going to<a id="id243" class="indexterm"/> animate, it is a good idea to turn this option off. Doing so will also save space in your project.</li><li class="listitem" style="list-style-type: disc">The option below that, <strong>Bake Animations</strong>, is only used when your animations contain Kinematics and are from 3Ds Max or Maya. This target is from Blender, so the option is grayed out.</li><li class="listitem" style="list-style-type: disc">The next four options, <strong>Anim. Compression</strong>, <strong>Rotation Error</strong>, <strong>Position Error</strong>, and <strong>Scale Error</strong>, are primarily for smoothing jittery animations. Nearly all of the time, the defaults will suit just fine.</li><li class="listitem" style="list-style-type: disc">The <strong>Clips</strong> section is what we are really concerned about. This will be a list of every animation clip that is currently being imported from the model. On the left-hand side of the list, we have the name of the clip. On the right-hand side, we can see the start<a id="id244" class="indexterm"/> and end frames of the clip.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unity will add the <strong>Default Take</strong> animation clip to every new model. This is a clip generated from the default preview range of your modelling program, when the file was saved.</li><li class="listitem" style="list-style-type: disc">In Blender, it is also possible to create a series of actions for each rig. By default, they are imported by Unity as animation clips. In this case, the <strong>ArmatureAction</strong> clip is created.</li><li class="listitem" style="list-style-type: disc">Below and to the right-hand side of the clips, there is a little tab with <strong>+</strong> and <strong>-</strong> buttons. These two buttons add a clip to the end and remove the selected clip respectively.</li></ul></div><div><img src="img/2014OT_03_10.png.jpg" alt="Animations"/></div></li><li class="listitem" style="list-style-type: disc">When a clip is selected, the next section appears. It starts with a text field for changing the name<a id="id245" class="indexterm"/> of the clip.</li><li class="listitem" style="list-style-type: disc">Below the text field, there is a <strong>Source Take</strong> drop-down list. This list is the same as the default animations. Most of the time, you will just use <strong>Default Take</strong>; but if your animation is ever appearing wrong or is missing, try changing the <strong>Source Take</strong> drop-down list first.</li><li class="listitem" style="list-style-type: disc">Then, we have a small timeline, followed by input fields for the start and end frames of the animation clip. Clicking-and-dragging on the two blue flags in the timeline will change the numbers in the input fields.</li><li class="listitem" style="list-style-type: disc">Next we have <strong>Loop Pose</strong> and <strong>Cycle Offset</strong>. If we want our animation to repeat, check the box next to <strong>Loop Pose</strong>. <a id="id246" class="indexterm"/>When an animation is looping, <strong>Cycle Offset</strong> will become available. This value lets us adjust the frame that the looping animation starts on.</li><li class="listitem" style="list-style-type: disc">The next three small sections, <strong>Root Transform Rotation</strong>, <strong>Root Transform Position (Y)</strong>, and <strong>Root Transform Position (XZ)</strong>, allow us to control the movement of a character through the animation.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All three of these sections have a <strong>Bake into Pose</strong> option. If these are left unchecked, the movement of the root node (we selected it under the <strong>Rig</strong> page) within the animation is translated into movement of the whole object. Think of it like this: say you were to animate a character running to the right and inside of the animation program, you actually move them, rather than animating in place as normal. With Unity's old animation system, for the physical part of a character to move the collider, the <code class="literal">GameObject</code> had to be moved with code. So, if you were to use that animation, the character would appear as if it had moved, but it would have no collision. With this new system, the whole character will move when that animation is played. However, this requires a different and more complex setup to work completely. So, it was not chosen to be used on the tank, though we could have used it.</li><li class="listitem" style="list-style-type: disc">Each of the three sections also has a <strong>Based Upon</strong> drop-down option. The choice of this option dictates the object's center for each of the sections. There are more choices if you are working with humanoid characters, but for now we only have two.<p>A choice of <strong>Root Node</strong> means the pivot point of the root node object is the center.</p><p>A choice of <strong>Original</strong> means the origin as defined by the animation program is the center of the object.</p></li><li class="listitem" style="list-style-type: disc">There is also an <strong>Offset</strong> option for the first two of these sections that works to correct errors in the motion. When animating a walk cycle for a character, if the character is pulling to the side slightly, adjusting the <strong>Offset</strong> option under <strong>Root Transform Rotation</strong> will correct it.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The last option for our animation clip is a <strong>Transform Mask</strong> option<a id="id247" class="indexterm"/>. By clicking on the arrow to the left, you can expand a list of all objects in the model. Each object has a checkbox next to it. The objects that are not checked will not be animated when this clip is played. This is useful in the case of a hand-waving animation. Such an animation would only need to move the arm and hand, so we would uncheck all of the objects that might make up the body of the character. We could then layer animations, making our character capable of waving while standing, walking, or running, without the need to create three extra animations.</li><li class="listitem" style="list-style-type: disc">Finally, we<a id="id248" class="indexterm"/> have our <strong>Revert</strong> button, <strong>Apply</strong> button, and the <strong>Preview</strong> window at the bottom. Just as with all of our other import settings, we have to hit one of these buttons when changes are made. This <strong>Preview</strong> window is made special by the speed slider in the top-right corner and the big <strong>play</strong> button in the top-left corner. By clicking on this button, we can preview the selected animation. This lets us detect those errors in motion that we talked about earlier, and just generally make sure that the animation is what we want.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>The target's animations</h2></div></div></div><p>So, now that the description is all out of the way, let's actually make something with it. We start by setting up the animations for the target.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec50"/>Time for action – setting up target's animations</h1></div></div></div><p>Using the knowledge we just <a id="id249" class="indexterm"/>gained, we can now set up our target's animations.</p><div><ol class="orderedlist arabic"><li class="listitem">For starters, if you missed or skipped it earlier, be sure to import the <code class="literal">Target.blend</code> and <code class="literal">Target.png</code> files to the <code class="literal">Targets</code> folder. Also, on the <strong>Rig</strong> page of the import settings, set the <strong>Animation Type</strong> attribute to <strong>Generic</strong> and the <strong>Root Node</strong> attribute to <strong>Bone_Arm_Upper</strong>.</li><li class="listitem">We need a total of six animations. By clicking on the <strong>+</strong> button in the <strong>Clips</strong> section, you can add four more animations. If you have added too many, click on the <strong>-</strong> button to remove the extra clips.</li><li class="listitem">All of these clips should have a <strong>Source Take</strong> drop-down list of <strong>Default Take</strong> and all of the <strong>Bake into Pose</strong> options should be checked, because the target isn't going to be moving from its starting location.</li><li class="listitem">First, let's create our idle animations. Select the first clip and rename it to <code class="literal">Idle_Retract</code>. Because it is a mechanical object, we can get away with a really short animation; so short that we are just going to use the first frame. Set the starting frame to <code class="literal">0.9</code> and the ending frame to <code class="literal">1</code>.</li><li class="listitem">We also need to turn on <strong>Loop Pose</strong> because idle animations are of course looping.</li><li class="listitem">The extended idle animation is created in almost exactly the same manner. Select the second clip and rename it to <code class="literal">Idle_Extend</code>. The starting frame here is <code class="literal">14</code> and the ending frame is <code class="literal">14.1</code>. Also, this animation needs to loop.</li><li class="listitem">Our next two animations are for when the target extends and retracts. They are going to be called <code class="literal">Extend</code> and <code class="literal">Retract</code>, so rename the next two clips. The <code class="literal">Extend</code> animation will start at frame <code class="literal">1</code> and end at frame <code class="literal">13</code>. The <code class="literal">Retract</code> animation starts at frame <code class="literal">28</code> and ends at frame <code class="literal">40</code>. Neither of these will loop.</li><li class="listitem">The last two<a id="id250" class="indexterm"/> animations also will not loop. They are for when we shoot the targets. There is one for being shot in the front and one for being shot from behind. The <code class="literal">Hit_Front</code> animation will be from frame <code class="literal">57</code> to frame <code class="literal">87</code>. The <code class="literal">Hit_Back</code> animation will be from frame <code class="literal">98</code> to frame <code class="literal">128</code>.</li><li class="listitem">Once all of the changes are made, be sure to click on <strong>Apply</strong> or they will not be saved.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>
<em>What just happened?</em>
</h2></div></div></div><p>We set up the animations that will be used by our targets. There were six in total. They may not seem like much now, but the next section would be lost without them.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>State machines</h2></div></div></div><p>In order for us to control these new animations in Unity, we need to set up a state machine. A state machine is just a fancy object that keeps track of what an object can do, and how to transition between those things. Think of it in terms of a builder from a Real Time Strategy game. The builder has a walk state that is used when moving to the next construction site. When it gets there, it switches to a build state. If an enemy shows up, the builder will enter a run away state until the enemy is gone. Finally, there is an idle state for when the builder is doing nothing. In Unity, these are called Animator Controllers when working with animations and Mecanim.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec51"/>Time for action – creating the target state machine</h1></div></div></div><p>The use of a state machine<a id="id251" class="indexterm"/> allows us to focus more on what the target is doing, while letting Unity handle the <em>how it is going to do it</em> part.</p><div><ol class="orderedlist arabic"><li class="listitem">Creating an Animator Controller is simple and done just as we have been doing for our scripts and materials. The option is second from the bottom of the <strong>Create</strong> menu. Create one in the <code class="literal">Targets</code> folder and name it <code class="literal">TargetController</code>.</li><li class="listitem">Double-click on <code class="literal">TargetController</code> to open a new window.<div><img src="img/2014OT_03_11.png.jpg" alt="Time for action – creating the target state machine"/></div></li><li class="listitem">The <strong>Animator</strong> window is where we edit our state machines.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At the top-left corner of the window, there is a breadcrumb trail as you might<a id="id252" class="indexterm"/> find on a website that lets us see where we are in the state machine at a glance.</li><li class="listitem" style="list-style-type: disc">The <strong>Auto Live Link</strong> button<a id="id253" class="indexterm"/> in the top-right controls our ability to see the state machine's update in real time with the game. This is useful for debugging transitions and controls for the character.</li><li class="listitem" style="list-style-type: disc">Underneath the breadcrumb trail, there are a list of layers and a button for adding new layers. Every state machine will have at least the <strong>Base Layer</strong>. Adding additional layers would allow us to blend state machines. Say we have a character that walks around normal when at full health. When his health drops below half, he starts to limp. If the character has only ten percent of his health left, he starts to crawl. This would be achieved through the use of layers.</li><li class="listitem" style="list-style-type: disc">At the bottom-left corner of the window, there is the <strong>Parameters</strong> list. Clicking on the <strong>+</strong> button will add a new parameter to the list. These parameters can be Boolean, float, vector, and integer values. The transitions between states are most often triggered by changes in the parameters. Any scripts working with the state machine can modify these values.</li><li class="listitem" style="list-style-type: disc">Finally, that green box in the center with <strong>Any State</strong> on it that allows a character to transition from any action to a specific one. When a character's health drops below zero, we want them to go to the death state. The <strong>Any State</strong> box would hold this transition, and it would be able to pull the character out of any other state and put them in the death state.</li></ul></div></li><li class="listitem">To create a new<a id="id254" class="indexterm"/> state, right-click on the grid that is inside our <strong>Animator</strong> window. Mouse over <strong>Create State</strong> and select <strong>Empty</strong>. This creates a new empty state for our state machine. Normally new states are gray but, because this is the first state in our machine it is orange, which is the color of the default state.</li><li class="listitem">Every state machine will start in its default state. Click on the state to select it, and we can take a look at it in the <strong>Inspector</strong> window.<div><img src="img/2014OT_03_12.png.jpg" alt="Time for action – creating the target state machine"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At the top, there is a text field for changing the name of the state.</li><li class="listitem" style="list-style-type: disc">Below that, you can add a tag for organizational purposes.</li><li class="listitem" style="list-style-type: disc">Next, there is a <strong>Speed</strong> field. This field controls the speed of the animation.</li><li class="listitem" style="list-style-type: disc">The <strong>Motion</strong> field is where we will add connections to the animation clips that we created earlier.</li><li class="listitem" style="list-style-type: disc">The <strong>Foot IK</strong> option lets us decide if we want to let part of the animation be calculated with IK. We did not set up any IK for these animations, so we do not need to worry about this option.</li><li class="listitem" style="list-style-type: disc">The last option, <strong>Mirror</strong>, is used to flip the left and right (or x axis) of the<a id="id255" class="indexterm"/> animation. If you created a right-hand-waving animation, this option would let you change it to a left-hand-waving animation.</li><li class="listitem" style="list-style-type: disc">Below that, there is the list of transitions that go from this state to another state. These are transitions out of the state, not into it. As you will soon see, a transition in this list appears as the name of the current state with an arrow to the right, followed by the name of the state it is connected to.</li><li class="listitem" style="list-style-type: disc">Checkboxes also appear under the <strong>Solo</strong> and <strong>Mute</strong> labels on the right. These are for debugging transitions between states. Any number of the transitions can be muted at one time, but only one can be soloed at a time. When a transition has been muted, it means that the state machine will ignore it when deciding which transition to make. Checking the solo box is the same as muting all but one of the transitions. It is just a quick way of making it the only active transition.</li></ul></div></li><li class="listitem">We are going to need one state for each of our target's animations. So, create five more states and rename all six to match the names of the animation clips we created earlier. The default state, the orange one, should be named <code class="literal">Idle_Retract</code>.</li><li class="listitem">In the <strong>Project</strong> window, click on the little triangle to the left of the <strong>Target</strong> model.<div><img src="img/2014OT_03_13.png.jpg" alt="Time for action – creating the target state machine"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This expands the model, so that we can see all of the objects that make up that model in Unity. The first group, as indicated by the little thumbnails next to each object, is the raw mesh data. This is followed by an Avatar object; this is what keeps track of the <strong>Rig</strong> setup. Below that, there are the animation clip objects; these are what we are<a id="id256" class="indexterm"/> interested in right now. The objects that make up the model are at the bottom of the stack.</li></ul></div></li><li class="listitem">Select each state in your <strong>Animator</strong> window and pair it with the correct clip by dragging an animation clip from the <strong>Project</strong> window and dropping it on the <strong>Motion</strong> field in the <strong>Inspector</strong> window.<div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>The thumbnail for animation clips looks like a little play button.</p><div><img src="img/2014OT_03_14.png.jpg" alt="Time for action – creating the target state machine"/></div></div></div></li><li class="listitem">Before we can create our transitions, we need a few parameters. Click on the <strong>+</strong> button next to <strong>Parameters</strong> in the bottom-left corner of the window and select <strong>Float</strong> from the menu that appears. A new parameter should now appear in the list.</li><li class="listitem">The new field on the left is the name of the parameter; rename this one to <code class="literal">time</code>. The field on the right is the current value of this parameter. When debugging our state machine, we can modify these values here to trigger changes in the state machine. Any changes made by the scripts while the game is running will also appear here.</li><li class="listitem">We need two more parameters. Create two Boolean parameters and rename them to <code class="literal">wasHit</code> and <code class="literal">inTheFront</code>. These will trigger the machine to change to the getting hit states, while the <code class="literal">time</code> parameter will trigger the machine to utilize the <code class="literal">extend</code> and <code class="literal">retract</code> states.</li><li class="listitem">To create a new transition, right-click on a state and select <strong>Make Transition</strong> from the menu that pops up. A transition line is now connected from the state to your mouse. To complete the transition creation, click on the state that you wish to connect to. There is an arrow on the line, indicating the direction of the transition.<div><ol class="orderedlist arabic"><li class="listitem">We need a transition from <code class="literal">Idle_Retract</code> to <code class="literal">Extend</code>.</li><li class="listitem">We also need a transition from <code class="literal">Extend</code> to <code class="literal">Idle_Extend</code>.</li><li class="listitem"><code class="literal">Idle_Extend</code> needs three transitions, one each going to <code class="literal">Retract</code>, <code class="literal">Hit_Front</code>, and <code class="literal">Hit_Back</code>.</li><li class="listitem"><code class="literal">Retract</code>, <code class="literal">Hit_Front</code>, and <code class="literal">Hit_Back</code> need a transition going to <code class="literal">Idle_Retract</code>.<div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>Use the following diagram for reference. If you create a transition or state that you do not want, <a id="id257" class="indexterm"/>select it and click on the <em>Delete</em> key on your keyboard to remove it.</p><div><img src="img/2014OT_03_16.jpg" alt="Time for action – creating the target state machine"/></div></div></div></li></ol></div></li><li class="listitem">If you click on one of the transition lines, then we can take a look at its settings.<div><img src="img/2014OT_03_17.png.jpg" alt="Time for action – creating the target state machine"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At the top of the <strong>Inspector</strong> window, we have the same indicators of which states we are transitioning between that we had in the state, the name of the state the transition starts in followed by an arrow, and finally<a id="id258" class="indexterm"/> the name of the state the transition ends in.</li><li class="listitem" style="list-style-type: disc">Underneath the familiar <strong>Transitions</strong> list, there is a text field where we can give our transitions specific names. This would be useful if we had several different types of transitions between the same two states.</li><li class="listitem" style="list-style-type: disc">Directly under the field, there is a more exact path-based indication of which states the transition is between.</li><li class="listitem" style="list-style-type: disc">The <strong>Atomic</strong> checkbox allows us to decide whether or not a transition can be interrupted. If <strong>Atomic</strong> is checked, it cannot be interrupted.<p>In the example about the <strong>Any State</strong> option and the death state, perhaps we were shot while pulling out a sword, going from an idle state to an attack state. That transition cannot be atomic, if we are to avoid the weirdness of completing our sword draw before falling over dead.</p></li><li class="listitem" style="list-style-type: disc">Next is a timeline block that lets us preview the transition between animations. Dragging the little flag left and right, we can watch the transition in the <strong>Preview</strong> window below. The top half of this <a id="id259" class="indexterm"/>block holds wave forms that indicate the movement contained in an animation. The bottom half shows the states as boxes that overlap where the transition actually occurs. Either of these boxes can be dragged to change the length of the transition.<div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>Because our two idle animations are of negligible length, this can't be seen in our setup normally. If you temporarily create a transition between the <code class="literal">extend</code> and <code class="literal">retract</code> states, it would be visible.</p></div></div></li><li class="listitem" style="list-style-type: disc">Lastly, we have a <strong>Conditions</strong> list. Using the parameters we set up, we can create any number of conditions here that must be met before this transition can take place.<p>The default condition is <strong>Exit Time</strong>. This means that, when the first state reaches a certain percentage of the way through its animation, as defined by the float field to the right, it will start transitioning into the next state. For half of our transitions, this is what we want. The other half, namely anything that exits our idle states, need to be based on our parameters.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>There is also another <strong>Preview</strong> window at the bottom of the <strong>Inspector</strong> panel. It functions just like the one for the animation import settings page, but this one plays the transition between the two relevant animations.</p></div></div></li></ul></div></li><li class="listitem">Select the transition between the <code class="literal">Idle_Retract</code> state and <code class="literal">Extend</code> state. We want the targets to randomly pop up. This will be controlled by a script changing the <code class="literal">time</code> parameter.</li><li class="listitem">Click on <code class="literal">Exit Time</code> under the <strong>Conditions</strong> list to bring up the list of parameters and select time from the list.</li><li class="listitem">In order to turn a float value into a conditional statement, we need to compare it with another value. That is why we got a new drop-down button of comparison options when we selected the parameter. A float value will be either greater than or less than the value on the right. Our time will be counting down, so select <strong>Less</strong> from the list and leave the value at zero.</li><li class="listitem">Change the conditions for the transition between the <code class="literal">Idle_Extend</code> and <code class="literal">Retract</code> states to be the same.</li><li class="listitem">For the transition <a id="id260" class="indexterm"/>between the <code class="literal">Idle_Extend</code> state and <code class="literal">Hit_Front</code> state, we will use both of the Boolean parameters that were created. Select the transition and click on the <strong>+</strong> button under <strong>Conditions</strong> to add a second condition.</li><li class="listitem">For the first condition, select <strong>wasHit</strong> and select <strong>inTheFront</strong> for the second condition.</li><li class="listitem">A Boolean is either true or false. In the case of the transitions, it needs to know which of those values it is waiting for. For this transition, both should be left as true.</li><li class="listitem">Next, set up the conditions for the transition between <code class="literal">Idle_Extend</code> and <code class="literal">Hit_Back</code>, just as you did for the previous transition. The difference being that false needs to be selected from the drop-down list next to the <code class="literal">inTheFront</code> conditional.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a state machine that will be used by our targets. By linking each state to an animation and connecting them all with transitions, the target will be able to switch between animations. This transitioning is controlled through adding conditionals and parameters.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec52"/>Time for action – scripting the target</h1></div></div></div><p>We only need one more piece before we can finish putting the target together.</p><div><ol class="orderedlist arabic"><li class="listitem">That piece is a script. Create a new script in our <code class="literal">Scripts</code> folder and name it <code class="literal">Target</code>.</li><li class="listitem">First, in order to interact <a id="id261" class="indexterm"/>with our state machine, we need a reference to the <code class="literal">Animator</code> component. It is the component that you removed from the tank and the city. The <code class="literal">Animator</code> component is what ties all of the pieces of animation together.<div><pre class="programlisting">public Animator animator;</pre></div></li><li class="listitem">It is followed by two float values that will dictate the range of time, in seconds, that our targets will sit in their idle states.<div><pre class="programlisting">public float maxIdleTime = 10f;
public float minIdleTime = 3f;</pre></div></li><li class="listitem">Next, we have three values that will hold the ID numbers of the parameters that we need to change. It is technically possible to just use the names of the parameters to set them, but using the ID number is much faster.<div><pre class="programlisting">private int timeId = -1;
private int wasHitId = -1;
private int inTheFrontId = -1;</pre></div></li><li class="listitem">The last two variables<a id="id262" class="indexterm"/> will hold the ID numbers of the two idle states. We need these for checking which state we are in. All of the IDs are initially set to <code class="literal">-1</code> as a dummy value, we set them to their actual values with the following function:<div><pre class="programlisting">private int idleRetractId = -1;
private int idleExtendId = -1;</pre></div></li><li class="listitem">The <code class="literal">Awake</code> function<a id="id263" class="indexterm"/> is a special function in Unity that is called on every script at the beginning of the game. Its purpose is initialization before the game gets underway, perfect for initially setting our ID values. For each ID, we make a call to the <a id="id264" class="indexterm"/><code class="literal">Animator.StringToHash</code> function. This function calculates the ID number of the parameter or state that we give it the name of. The state names also need to be prefixed with <code class="literal">Base Layer</code>. This is because Unity wants us to be specific when it is possible to have several different layers with states that are named the same thing. It is also very important that the name here exactly matches the name in the <strong>Animator</strong> window. If it does not, IDs will not match, errors will occur, and the script will not function correctly.<div><pre class="programlisting">public void Awake() {
  timeId = Animator.StringToHash("time");
  wasHitId = Animator.StringToHash("wasHit");
  inTheFrontId = Animator.StringToHash("inTheFront");
  idleRetractId = Animator.StringToHash("Base Layer.Idle_Retract");
  idleExtendId = Animator.StringToHash("Base Layer.Idle_Extend");
}</pre></div></li><li class="listitem">To make use of all of these IDs, we turn to our very good friend—the <code class="literal">Update</code> function. At the beginning of the function, we use the <code class="literal">GetCurrentAnimatorStateInfo</code> function<a id="id265" class="indexterm"/> to figure out which state is the current one. We send it a zero because it wants to know the index of the layer we are inquiring about, of which we only have the one. The function returns an object with the info about the current state, and we grab the <code class="literal">nameHash</code> value (also known as the ID value) of this state right away and set our variable to it.<div><pre class="programlisting">public void Update() {
  int currentStateId = animator.GetCurrentAnimatorStateInfo(0).nameHash;</pre></div></li><li class="listitem">The next line of code is a comparison with our idle state IDs to figure out if we are in one of those states. If we are, we call upon the <code class="literal">SubtractTime</code> function<a id="id266" class="indexterm"/> (which we will write in a moment) to reduce the <code class="literal">time</code> parameter.<div><pre class="programlisting">  if(currentStateId == idleRetractId || currentStateId == idleExtendId) {
    SubtractTime();
  }</pre></div></li><li class="listitem">If the target is not<a id="id267" class="indexterm"/> currently in one of its idle states, we start by checking to see if we were hit. If so, the hit is cleared using the <code class="literal">ClearHit</code> function<a id="id268" class="indexterm"/> and the <code class="literal">time</code> parameter is reset using the <code class="literal">ResetTime</code> function<a id="id269" class="indexterm"/>. Both functions will also be written in a moment. Finally, we check to see if our timer had dropped below zero. If that is the case, we again reset the timer.<div><pre class="programlisting">  else {
    if(animator.GetBool(wasHitId)) {
      ClearHit();
      ResetTime();
    }

    if(animator.GetFloat(timeId) &lt; 0) {
      ResetTime();
    }
  }
}</pre></div></li><li class="listitem">In the <code class="literal">SubtractTime</code> function<a id="id270" class="indexterm"/> we use the <code class="literal">GetFloat</code> function of our <code class="literal">Animator</code> component to retrieve the value of a float parameter. By sending it our <code class="literal">timeId</code> variable, we can receive the current value of the <code class="literal">time</code> parameter. Like we did with the tank, we then use <code class="literal">Time.deltaTime</code> to keep in pace with our frame rate and subtract time from the timer. Once done, we need to give the state machine the new value, which is done with the <code class="literal">SetFloat</code> function. We tell it which parameter to change by giving it an ID value, and we tell it what to change it to by giving it our new time value.<div><pre class="programlisting">public void SubtractTime() {
  float curTime = animator.GetFloat(timeId);
  curTime -= Time.deltaTime;
  animator.SetFloat(timeId, curTime);
}</pre></div></li><li class="listitem">The next function to create is <code class="literal">ClearHit</code>. This function uses <code class="literal">SetBool</code> from the <code class="literal">Animator</code> component to set Boolean parameters. It functions just as the <code class="literal">SetFloat</code> function. We just give it an ID and a value. In this case, we are setting both of our <a id="id271" class="indexterm"/>Boolean parameters to false so that the state machine no longer thinks it has been hit.<div><pre class="programlisting">public void ClearHit() {
  animator.SetBool(wasHitId, false);
  animator.SetBool(inTheFrontId, false);
}</pre></div></li><li class="listitem">The last function for the script is <code class="literal">ResetTime</code>. This is another quick function. First, we use the <a id="id272" class="indexterm"/><code class="literal">Random.Range</code> function to get a random value. By passing it a minimum and maximum value, our new random number will be between them. Finally we use the <code class="literal">SetFloat</code> function to give the state machine the new value.<div><pre class="programlisting">public void ResetTime() {
  float newTime = Random.Range(minIdleTime, maxIdleTime);
  animator.SetFloat(timeId, newTime);
}</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a script to control the state machine of our target. For comparing states and setting parameters, we gathered and used IDs. For now, do not worry about when the hit states are activated. It will be made clear in the following section when we finally make the tank shoot.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Creating the prefab</h2></div></div></div><p>Now that we have the model, animations, state machine, and script, finally it is time to create the target and turn it into a prefab.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec53"/>Time for action – creating the target</h1></div></div></div><p>We have all the pieces; the<a id="id273" class="indexterm"/> next step is to put them together.</p><div><ol class="orderedlist arabic"><li class="listitem">Start by dragging the <strong>Target</strong> model from the <strong>Project</strong> window to the <strong>Hierarchy</strong> window. This creates a new instance of the <code class="literal">target</code> object.</li><li class="listitem">By selecting the new <code class="literal">target</code> object, we can see that it already has an <code class="literal">Animator</code> component attached; we just need to add a reference to <code class="literal">AnimatorController</code> that we created. Do this by dragging <code class="literal">TargetController</code> from the <strong>Project</strong> window and dropping it on the Animator component's <strong>Controller</strong> field, just as with all the other object references we have set up so far.</li><li class="listitem">Also, we need to add the <code class="literal">Target</code> script to the object and connect a reference to the <code class="literal">Animator</code> component in its relevant field.</li><li class="listitem">The last thing to do to the target object is to add a collider to actually receive our cannon shots. Unfortunately, because the <code class="literal">target</code> object uses bones and a rig to animate, it is not as simple as adding a collider directly to the mesh we will be shooting at. Instead, we need to create a new empty <code class="literal">GameObject</code>.</li><li class="listitem">Rename it <code class="literal">TargetCollider</code>, and make it a child of the target's <code class="literal">Bone_Target</code> bone.</li><li class="listitem">Add a <code class="literal">MeshCollider</code> component<a id="id274" class="indexterm"/> to the new <code class="literal">GameObject</code>.</li><li class="listitem">Now, we need to provide it with some mesh data. Find the <code class="literal">Target</code> mesh data in the <strong>Project</strong> window, underneath the <strong>Target</strong> model. Drag it to the <strong>Mesh</strong> value of the <code class="literal">MeshCollider</code> component. This causes a green cylinder to appear in the <strong>Scene</strong> view. This is our collision, but it is actually not on the target.<div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>The many objects in the <strong>Project</strong> window can be easily told apart by the little symbol that sits next to each. The symbol for a mesh is a gray and blue grid.</p><div><img src="img/1.jpg" alt="Time for action – creating the target"/></div></div></div></li><li class="listitem">Use the <strong>Transform</strong> component to set the GameObject's position to <code class="literal">4</code> for the <strong>X</strong> value and <code class="literal">0</code> for both <strong>Y</strong> and <strong>Z</strong>. The rotation needs to be changed to <code class="literal">0</code> for <strong>X</strong>, <code class="literal">-90</code> for <strong>Y</strong> and <code class="literal">90</code> for <strong>Z</strong>.</li><li class="listitem">As we made the changes, you probably noticed that the font of everything that was new or changed became bold. This is to indicate that something is different with this prefab instance when compared to the original. Remember, models are essentially prefabs; their problem is that we cannot directly make changes such as adding scripts. To make this target into a new prefab, simply drag it from the <strong>Hierarchy</strong> window and drop it on the <code class="literal">Prefabs</code> folder in the <strong>Project</strong> window.</li><li class="listitem">With this spiffy new prefab created, populate the city with it.</li><li class="listitem">In placing all of these targets, you probably noticed that they are a little large. Instead of editing each target individually or even all of them as a group, we only have to make a change to the original prefab. Select the <code class="literal">Target</code> prefab in the <strong>Project</strong> window. The <strong>Inspector</strong> window displays the same information for<a id="id275" class="indexterm"/> a root prefab object as it does for any other object in the scene. With our prefab selected, half the scale and all of the instances already in the scene will automatically be updated to match. We can also make changes to the min and max idle times and have it affect the whole scene.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just finished creating the targets for our tank. By making use of Unity's prefab system, we are also able to duplicate the target throughout our game and easily make changes that affect them all.</p><p>If you wanted one of the targets to be larger than all of the others, you could change it in the scene. Any changes made to a prefab instance are saved, and they take precedence over changes made to the root prefab object. Also, when looking at an instance in the <strong>Inspector</strong> window, there will be three new buttons at the top of the window. The <strong>Select</strong> button selects the root prefab object in the <strong>Project</strong> window. <strong>Revert</strong> will remove any unique changes made to this instance, whereas the <strong>Apply</strong> button updates the root object with all the changes that were made in this instance.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Have a go hero – more targets</h2></div></div></div><p>Using all that you have learned about animations and state machines, your challenge here is to create a second type of target. Play around with different movements and behaviors. Perhaps, create one that transitions from waving around to standing still.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec54"/>Ray tracing to shoot</h1></div></div></div><p>Play the game now; it is pretty cool. We have our drivable tank and textured city. We even have fancy animated targets. We are just missing one thing: how do we shoot? We need to make one more script and we can shoot targets to our heart's content.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec55"/>Time for action – simple shooting</h1></div></div></div><p>With the addition of one more object <a id="id276" class="indexterm"/>and a single script, we can start shooting at our targets.</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to add an empty <code class="literal">GameObject</code> to our tank. Rename it to <code class="literal">MuzzlePoint</code> and make it a child of the cannon's pivot point object. Once done, position it at the end of the cannon so the blue arrow points away from the tank, along the same direction as the cannon. This will be the point where our bullets will come from.</li><li class="listitem">We also need something to indicate where we are shooting. The explosions are covered in future chapters, so choose <strong>Sphere</strong> from the <strong>Create Other</strong> menu and rename it <code class="literal">TargetPoint</code>.</li><li class="listitem">Set the sphere's scale to <code class="literal">0.2</code> for each axis<a id="id277" class="indexterm"/> and give it a red material. This way it can be more easily seen, without being completely obtrusive.</li><li class="listitem">Remove the <code class="literal">SphereCollider</code> component from <code class="literal">TargetPoint</code>. The <code class="literal">SphereCollider</code> has to be removed because we don't want to shoot our own target indicator.</li><li class="listitem">Now, create a new script and call it <code class="literal">FireControls</code>.</li><li class="listitem">This should start to look familiar to you. We start with variables to hold references to our muzzle and targeting objects that we just created. They are followed by an <a id="id278" class="indexterm"/><code class="literal">OnGUI</code> function that draws a button in the bottom-right corner of the screen, just above where we drew the turret control buttons. If the button is pressed, we call upon the <code class="literal">Fire</code> function that we will create next.<div><pre class="programlisting">public Transform muzzlePoint;
public Transform targetPoint;

public void OnGUI() {
  Rect fire = new Rect(Screen.width – 70, Screen.height – 220, 50, 50);
  if(GUI.Button(fire, "Fire")) {
    Fire();
  }
}</pre></div></li><li class="listitem">The <code class="literal">Fire</code> function starts by defining a variable that will hold the detailed information about what was shot. It is followed by an <code class="literal">if</code> statement that checks the <code class="literal">Physics.Raycast</code> function. The <code class="literal">Raycast</code> function<a id="id279" class="indexterm"/> works just like shooting a gun. We start with a position (the muzzle point's position) pointing in a specific direction (forward relative to the muzzle point) and get out what was hit. If we hit something, the <code class="literal">if</code> statement evaluates to true; otherwise it is false and we would skip ahead. When we do hit something, we first move our target point to the point that was hit. We then use the <code class="literal">SendMessage</code> function to tell what we hit that it was hit. The <code class="literal">SendMessage</code> function<a id="id280" class="indexterm"/> is only available for <code class="literal">GameObjects</code> and <code class="literal">MonoBehaviours</code>, and our <code class="literal">Target</code> script is on the root object for the target, hence the <code class="literal">hit.transform.root.gameObject</code> in order to get at the <code class="literal">GameObject</code> that was hit. The <a id="id281" class="indexterm"/><code class="literal">SendMessage</code> function takes the name of a function and tries to find it on the <code class="literal">GameObject</code> to which the message was sent. We are also providing it with a value, <code class="literal">hit.point</code>, to give to the function that should be found. The <code class="literal">SendMessageOptions.DontRequireReceiver</code> part of the line keeps the function from throwing an error if it is unable to find the desired function. The last part of our <code class="literal">Fire</code> function <a id="id282" class="indexterm"/>occurs if we didn't hit anything. We send our target point back to the world origin, so the player can tell that they missed everything.<div><pre class="programlisting">public void Fire() {
  RaycastHit hit;
  if(Physics.Raycast(muzzlePoint.position, muzzlePoint.forward, out hit)) {
    targetPoint.position = hit.point;
    hit.transform.root.gameObject.SendMessage("Hit", hit.point, SendMessageOptions.DontRequireReceiver);
  }
  else {
    targetPoint.position = Vector3.zero;
  }
}</pre></div></li><li class="listitem">The last thing to do is to add the <code class="literal">Hit</code> function to the end of our <code class="literal">Target</code> script. We start the function by getting the current state ID, just as we did earlier in the script. However, this time we check only against our extended idle ID. If they do not match, we use return to exit the function early. We do this because we don't want to let the player shoot any targets that are down or in mid transition. If our state is correct, we continue by telling the animation that we were hit using the <code class="literal">SetBool</code> function<a id="id283" class="indexterm"/>.<div><pre class="programlisting">public void Hit(Vector3 point) {
  int currentStateId = animator.GetCurrentAnimatorStateInfo(0).nameHash;
  if(currentStateId != idleExtendId) return;
  animator.SetBool(wasHitId, true);</pre></div></li><li class="listitem">The rest of the <code class="literal">Hit</code> function figures out which side the target was hit on. To do this, we first had to convert the point that we received from world space into local space. The <code class="literal">InverseTransformPoint</code> function<a id="id284" class="indexterm"/> from our <strong>Transform</strong> component does this nicely. We then do a check to see where the shot came from. Because of the way the target is constructed, if the shot was positive on the x axis, it came from behind. Otherwise, it came from the front. Either way, we set the <code class="literal">inTheFront</code> parameter<a id="id285" class="indexterm"/> from our state machine to the proper value. Then we give the player some points by incrementing the static variable that we created on our <code class="literal">ScoreCounter</code> script, way back at the beginning of the chapter.<div><pre class="programlisting">Vector3 localPoint = transform.InverseTransformPoint(point);
  if(localPoint.x &gt; 0) {
    animator.SetBool(inTheFrontId, false);
    ScoreCounter.score += 5;
  }
  else {
    animator.SetBool(inTheFrontId, true);
    ScoreCounter.score += 10;
  }
}</pre></div></li><li class="listitem">Finally, be sure to add the<a id="id286" class="indexterm"/> new <code class="literal">FireControls</code> script to the tank. Also, you need to connect the references to the <code class="literal">MuzzelPoint</code> and <code class="literal">TargetPoint</code> objects.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a script that allows us to fire the cannon of our tank. The method of using ray tracing is the simplest and most widely used. In general, bullets fly too fast for us to see them. Ray tracing is like this, that is; it is instant. However, this method does not take gravity, or anything else that might change the direction of a bullet, into account.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Have a go hero – better GUI</h2></div></div></div><p>Now that all of the buttons and components are in place, make them look better. Use the skills you gained from the previous chapter to style the GUI and make it great. Perhaps you could even manage to create a directional pad for the movement.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec56"/>Summary</h1></div></div></div><p>And, that is it! The chapter was long and we learned a lot. We imported meshes and set up a tank. We created materials so that color could be added to a city. We also animated some targets and learned how to shoot them down. It was a lot and it is time for a break. Play the game, shoot some targets, and gather those points. The project is all done and ready to be built to your device of choice. The build process is the same as both of the previous projects, so have fun!</p><p>The next chapter is about special camera effects and lighting. We will be learning about lights and their types. Our Tank Battle game will expand through the addition of a skybox and several lights. We will also take a look at distance fog. With the addition of shadows and lightmaps, the city we will battle in really starts to become interesting and dynamic.</p></div></body></html>