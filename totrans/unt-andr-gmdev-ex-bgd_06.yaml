- en: Chapter 6. Specialties of the Mobile Device – Touch and Tilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about Pathfinding and AI. We expanded
    our Tank Battle game to include enemy tanks. We created points for them to spawn
    at, and made them shoot at the player. Utilizing Unity''s pathfinding system,
    we made the tanks chase the player. Also, the player was given the ability to
    destroy the tanks. Once destroyed, the player receives some points and a new enemy
    tank is spawned.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we start working on a new game as we explore some of the
    specialties of the mobile device. We will be creating a Space Fighter game. The
    player will take control of a space ship and blast enemy ships, mines, and asteroids
    for points. To steer their ship, the player will have to tilt the mobile device.
    To shoot, the player will touch the screen where they want their laser blast to
    hit.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Touch controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tilt controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be creating a new project for this chapter, so start up Unity and we
    will begin.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with every project, we need a little bit of preparation work in order to
    prepare our development environment. Don't worry, the setup for this chapter is
    simple and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started. The first step is, of course, to start Unity and create
    a new project. Naming the project `Ch6_SpaceFighter` will work well:'
  prefs: []
  type: TYPE_NORMAL
- en: Once Unity has finished initializing, this is a perfect opportunity to set our
    build settings. Open the **Build Settings** window, select **Android** from the
    list of platforms, and hit **Switch Platform** to change the target platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While at the **Build Settings** window, select **Player Settings** to open the
    player settings in the **Inspector**. Adjust the **Company Name**, **Product Name**,
    and especially the **Bundle Identifier**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a few folders to keep the project organized. The `Scripts`,
    `Models`, and `Prefabs` folders should be created in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to import the assets for this project. We are going to need a space
    ship for the player, an enemy space ship, an explosive mine, and some asteroids.
    Luckily, all of these have already been prepared and are available with the starting
    assets for this chapter. Import `PlayerShip.blend`, `PlayerShip.png`, `EnemyShip.blend`,
    `EnemyShip.png`, `Asteroid.blend`, `Asteroid.png`, `SpaceMine.blend`, and `SpaceMine.png`
    to the `Models` folder that you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just finished the setup for this chapter's project. Once again, a little
    bit of effort at the beginning of the project will save time and frustration later.
    Especially, as a project grows in size, the organization done at the beginning
    becomes most important.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling with tilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern mobile devices possess a broad variety of internal sensors for detecting
    and providing information about the surronding world. Though you may not have
    thought of them in such a way, you are certainly most familiar with the microphone
    and speaker that are required for making calls. There is a Wi-Fi receiver for
    connecting to the Internet and a camera for taking pictures. Your device almost
    certainly has a magnetometer to work with your GPS to provide directions.
  prefs: []
  type: TYPE_NORMAL
- en: The sensor we are interested in right now is the **gyroscope**. This sensor
    detects local rotation of the device. In general, it is used to determine the
    orientation of the device. We are going to use it to steer our ship. When the
    user tilts their device left and right, their space ship will turn to the side.
    When the device is tilted up and down, the ship will go up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – steering the space ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To steer our ship, we will need to create a single script and apply it to our
    ship:'
  prefs: []
  type: TYPE_NORMAL
- en: To start this off, create a new script and name it `TiltSteering`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with all of our other scripts, we will begin this one with a few variables.
    The first two variables control the speed with which the ship will rotate as the
    device is tilted. The second two are going to be used to limit the rotation of
    the ship. These will determine how tight a circle the player's ship can turn in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will make use of the `Update` function. We start out by creating a
    variable to store the ship's current rotation. Next, we have to adjust the rotation.
    When working with Euler rotations, Unity adjusts values to be between zero and
    360\. This way, the values are never negative. Anything below zero simply wraps
    around and starts counting down from 360; anything above 360 wraps back to start
    counting up from zero again. We need the negative values. So, if the parts of
    the rotation are above 180, we subtract 360 to determine their negative values.
    Also, we are not making adjustments to the z component because the ship will not
    be rotating around its forward axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we apply the accelerometer measurement. When the device is held horizontally,
    with the home button on the right and the screen towards the user, the x component
    holds the rotation of the device while it is facing the user. The z component
    holds the rotation of the screen being tilted up and down. The components are
    multiplied by their respective speeds and are added to the rotation. The y rotation
    controls pointing left and right while the x component controls pointing up and
    down. However, the z acceleration is the opposite of how the ship should rotate,
    so we take the negative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the acceleration is applied, we need to limit the rotations so that the
    ship is not rotated too far. We use the `Mathf.Clamp` function to limit the rotation
    components between the negative of the max and the max of the relevant values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we apply the rotation to the ship's transform and close off the function
    for the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to make use of our new script, we need to do some setup for the player's
    ship. Start by creating an empty **GameObject** and setting its position to zero.
    Rename it to `PlayerShipPivot`. This will allow us to control the movement and
    appearance of the player's ship independently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your `PlayerShip` model from the **Project** window and drop it on the
    pivot point we just created. Be sure to center your ship on the point and rotate
    it to face forward along the z axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now add the script to the pivot point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the point when it is especially important to have Unity Remote. With
    your device attached and Unity Remote running, you can hold it up and steer the
    ship. Feel free to adjust the rotation speeds and limits until you find the settings
    that feel natural to control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to be able to see past the ship, so that we can later shoot at
    targets we are flying towards. Adjust the position of the camera so the ship is
    centered horizontally and a little below center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scene also needs to be slightly lit. The light in deep space tends to be
    very general, so we can get away with just adjusting the ambient light. Click
    on **Edit** in the menu bar of Unity, and then click on **Render Settings**. By
    setting the **Ambient Light** to white, our scene will be bright enough to see
    everything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the settings are in place, be sure to save the scene. Name it `SpaceFighter`.![Time
    for action – steering the space ship](img/2014OT_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We made use of the accelerometer to provide steering control of a spaceship.
    By measuring how the player is tilting their device, we are able to rotate the
    ship accordingly. We did not make the ship actually move, but just rotated it
    in place. We will come to understand why in a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Making things move in space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your first instinct to make the ship move would be probably to just change the
    position of the ship. However, things get weird when objects are really far from
    the world origin. In programming, there are actually limits on the size of the
    number that a variable can hold. This limit causes the rendering system to begin
    failing when the vertex positions become too large, resulting in the model being
    distorted beyond recognition. Admittedly, we are talking about positional values
    in the hundreds of thousands and beyond. However, say the player were to just
    fly straight for a long time; eventually, they could reach this distance of distortion.
  prefs: []
  type: TYPE_NORMAL
- en: As a potential solution, we could force the player to turn, or stop their forward
    progress, or wrap their position so they continue flying from the opposite side
    of a finite space. However, it is so much more fun to fly through an infinite
    space. We can achieve this by leaving the player's ship in place and moving everything
    else around it. As a new space is entered, new enemies and objects can be spawned
    to fill the space. Old objects and enemies that are too far away can be destroyed
    by removing them where the player won't see. This would give the illusion of an
    infinite amount of space.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – flying asteroids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first objects we will be avoiding in our infinite space will be asteroids:'
  prefs: []
  type: TYPE_NORMAL
- en: To make the asteroids work, we will first need to make the player ship's rotation
    and speed available for the asteroids to use. To do this, we need to create a
    new script and call it `PlayerShip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, this script starts with a group of variables. The first is the speed
    of the player's ship. The asteroids and other objects in the space will use it
    to move around the player. The second variable will hold a reference to the `TiltSteering`
    script that we created earlier. This will give us access to the ship's rotational
    speed. The last variable is a static variable that will hold a reference to the
    instance of this script that exists in the scene. This will allow other scripts
    to access the information stored by this script. We call the `use` variable to
    indicate to other scripts that this is the instance they should access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we make use of the `Awake` function. This function is automatically called
    at the beginning of the game, making it perfect for initialization. We are using
    it to simply set the `use` variable that we created earlier to the current instance
    of the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next function is for providing other scripts with the player's current rotation.
    Being static, any script can call it at any time. The function first checks to
    see whether a reference is available to the current instance of the script. If
    it cannot be found, a neutral rotation, `Quaternion.identity`, is returned. Otherwise,
    the rotation of the transform that the script instance is attached to is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Rotate` function here is for faking the movement of the player. This function
    takes the transform that is passed to it and moves and rotates it to make it look
    like it is the player that has moved through space. As with the previous `GetRotation`
    function, it first checks for a reference to the player and does nothing if there
    isn't one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To rotate the asteroid, and anything else, around the player's position, its
    current position needs to be multiplied by the mirror of the player's current
    rotation. To do that, we need to adjust the rotation so that it can be mirrored
    properly. The Euler angles of the player's rotation are stored in a variable for
    manipulation. We then shift the values that are greater than 180, just as we did
    earlier. The rotation is then scaled by the player ship's rotation speed. Finally,
    it is multiplied by the frame speed to keep it in time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We turn the negative Euler rotation, which is the mirrored rotation, back into
    a Quaternion and store it in a variable for use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The mirrored rotation is then multiplied by the passed object's position, updating
    the position to be rotated around the player as if they were turning. The player's
    rotation is then multiplied by a forward-facing vector, the player's speed, and
    finally the frame speed. This is all subtracted from the object's current position
    in order to imitate the player's forward movement. Finally, the passed object's
    rotation is multiplied by the mirrored rotation to change its orientation. Altogether,
    this fakes the movement of the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the script to the `PlayerShipPivot` object that was created previously.
    Be sure to connect the `TiltSteering` reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to make use of that script by creating another. Name it `Asteroid`.
    This script will control an asteroid as it flies through space and the player
    is forced to avoid it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first two of the variables for this script are used for determining a random
    speed at which the asteroid will fly through space. The third variable will hold
    the random speed. The final variable will hold the random direction in which the
    asteroid is flying through space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we again make use of the `Awake` function for initialization. Any point
    that lies on the surface of a sphere with a radius of one is essentially a vector
    that points in a random direction. Therefore, we use `Random.onUnitSphere` to
    find a random direction for the asteroid to go. It is followed by the use of `Random.Range`
    and the first two variables to determine a random speed for the asteroid to travel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function for this script is `LateUpdate`. We need the asteroid to move
    after the player's ship has updated its rotation; that is why we use this function.
    The first line of the function uses the `GetRotation` function that we created
    for the `PlayerShip` script and stores it in a variable for use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we make a call to the `PlayerShip.Rotate` function, passing it the asteroid's
    transform, so that the asteroid can be moved to fake the player's movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next line of code rotates the asteroid's movement direction by the player's
    rotation, again making a change that fakes the player's movement. The position
    is again updated with the asteroid's own movement in the adjusted direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function and the script finishes with a check to see if the asteroid is
    too far away from the player. We do this by checking `sqrMagnitude` of the asteroid's
    position. The length of a vector is its magnitude. For positional vectors, this
    is the distance from the center point. The `sqrMagnitude` is the square of the
    vector's magnitude. This is much faster to calculate and just as easy for comparison.
    We just need to compare it to the square of the desired value. In this case a
    max distance of about 300, whose square is 100,000, will work well for our needs.
    If you remember from math class, 1e5 is the same as a one with five zeros behind
    it, which is 1 million. Finally, if the asteroid is too far away, it is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to test this script, we need an asteroid prefab. To create it, start
    off by adding the `Asteroid` model to the scene and deleting two of the three
    meshes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the script to the model and drag it to the `Prefabs` folder, turning it
    into a prefab.![Time for action – flying asteroids](img/2014OT_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created two scripts and a prefab. The first script is used by the player's
    ship to relay information about its rotation and speed to other scripts. The second
    script controls the motion of asteroids in the game world. Because of the weirdness
    in the model's behavior when subjected to extreme distances, the player never
    actually moves. The game world and all of the objects in it are instead moved
    around the player. Finally, we created an asteroid prefab. Try adding several
    prefabs to the scene and try them out. You can fly in, out, and around them even
    though your ship never actually moves.
  prefs: []
  type: TYPE_NORMAL
- en: Adding space collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flying around, you probably noticed that you can fly straight through the asteroids.
    To make it possible for the player to hit them, we need to add some collision
    to the player's ship and the asteroid. This is similar to what was done for the
    Tank Battle game. We will be going into more detail about how the collision works
    in the next chapter, but we will need to make use of the **Rigidbody** component.
    It provides access to Physics calculations and allows us to group colliders to
    make more complex collision shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add some collision capabilities to our space objects, so that they
    can crash into each other and be shot at properly:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by giving collision to the asteroid. Do this by first selecting
    the mesh for the asteroid and adding a **MeshCollider** component. This will later
    let us shoot at the asteroid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the same object that holds our `Asteroid` script component. Add
    a **SphereCollider** component to the object and adjust the **Radius** to be a
    little larger than the asteroid. This collider will detect when the asteroid has
    collided with the player.![Time for action – adding collisions](img/2014OT_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **SphereCollider** needs to have the **Is Trigger** checkbox checked. We
    are not checking the true collision, just an approximate one. With this checkbox
    checked, objects will no longer be stopped by the collider, but instead trigger
    an event in script when an object enters the collider volume. When the player
    enters the collider, it will be close enough that we can assume and act as if
    it has collided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are satisfied with the changes, be sure to apply them to the prefab.
    Otherwise, the other asteroids will not be updated and collidable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To detect when the player has entered the new trigger area, we need to add a
    short function to the `Asteroid` script. We add a `OnTriggerEnter` function to
    the end of the script. This function is automatically called by the Physics system
    when one collider enters another. The collider that is passed to it is the one
    that it collided with. However, the function only works if at least one of the
    objects has a **Rigidbody** component attached. We will be covering it in detail
    in [Chapter 7](ch07.html "Chapter 7. Throwing Your Weight Around – Physics and
    a 2D Camera"), *Throwing Your Weight Around – Physics and a 2D Camera*, but the
    Rigidbody component is what actually connects an object into Unity's Physics engine,
    giving our scripts access to the `OnTrigger` and `OnCollision` groups of functions.
    We will be adding this to the player's ship. When the function is called, it simply
    destroys the asteroid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to add collision to the the player's ship. Start by adding that
    **Rigidbody** component to the **PlayerShipPivot** GameObject that we created
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to check the **Is Kinematic** checkbox of the new component. This tells
    the Physics system that we want to control the object's motion through the script.
    If it was not checked, the ship would begin to fall as soon we start playing the
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the features of a **Rigidbody** component is that it treats all colliders
    on child objects in the **Hierarchy** as a part of a single collision shape. This
    way, we are able to build a complex collision shape using several simple and faster
    process colliders. By creating an empty **GameObject** and adding the simple colliders,
    we size and position them to cover the player's ship. Be sure to make the collider
    objects children of the ship's pivot point.![Time for action – adding collisions](img/2014OT_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added collision to the asteroids and the player's ship. This gives the player
    the ability to crash into and destroy the asteroids. We are utilizing a trigger
    collider to approximate collision with the asteroid. Also, we make use of the
    **Rigidbody** component, allowing our ship to collide with other things in the
    scene. Additionally, this gives us the advantage of being able to build a complex
    collision shape out of the simple colliders that are provided by Unity. Although
    it is technically possible to just use a **MeshCollider** to exactly match the
    shape of the ship, it is not recommended. The **Rigidbody** and **MeshCollider**
    components do not mix well. Also, several simple colliders are much faster for
    the computer to calculate than a single **MeshCollider**.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is great that we can make the player ship collide with the asteroids, but
    it doesn't mean much in terms of a game. There is no penalty for the collision.
    This challenge is for you to implement a scoring system similar to the one we
    used for the Tank Battle game from the previous chapters. When the player collides
    with asteroids, subtract points from the score. Use the `SendMessage` function
    on the other collider from the `OnTriggerEnter` function. Don't just subtract
    points when the trigger is entered, because (as you will find out later) the asteroids
    will not be colliding only with the player.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flying around space with a handful of asteroids is great, but it doesn't make
    for much of a fight. That is why we are going to add an enemy spaceship that will
    chase and shoot at the player. We have no mesh to use for pathfinding, so we cannot
    use the techniques we learned in the previous chapter. However, there are no buildings
    in space to navigate around, so the chasing of the player will be much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding an enemy ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our enemy ships, we will need a script to turn our enemy ship into
    a prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new script and call it `EnemyShip`.
    This script will control the movement and shooting of the enemy ships.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script starts off with several variables. The first two define the speed
    with which the ship moves forward and how fast it turns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next three variables are for controlling the shooting of the ship. First
    is the rate at which bullets are fired. It is followed by the range that the ship
    has to be within to fire at the player. Third is a holder for how long it has
    been since the last bullet was fired. This will work with the rate of fire to
    dictate when the ship can fire again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last two variables will hold a reference to the bullet prefab that will
    be fired and the point from which the bullet will be released. This is similar
    to how we made the enemy tanks shoot in the previous chapter. The difference is
    that space games tend to have a lot of laser blasts flying around that force the
    player to dodge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Update` function, we will do the work of actually shooting. It starts
    by tracking how long it has been since a bullet was last fired. Then we check
    to see if it has been long enough since the last firing in order to fire again,
    and exit the function if it is not. The third line of code in the function checks
    the range. This is done in exactly the same way as we checked to see if the asteroids
    moved too far away from the player. Next, we check to make sure the ship is pointed
    at the player. This is done in the same way as we did when the enemy tanks were
    to shoot at the player. A comparison of the forward direction is done with the
    direction to the player to check the angle. If it is pointing close enough at
    the player, the ship can start shooting. The shooting is done with a call to the
    `Instantiate` function. By passing it the `muzzlePoint` variable's position and
    rotation, the new bullet is automatically rotated. A separate script will be handling
    the movement of the bullet. Finally, the time since the ship last fired is reset
    to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next function is the `LateUpdate` function. We are going to use this function
    just as we did for the asteroid. The first line of code just calls out to the
    `PlayerShip` script to have the ship rotated and moved to fake the player's movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next line of code applies movement to the ship. The process is similar to
    how we made the enemy turrets rotate to face the player in the previous chapter.
    The `step` variable is used to dictate how fast the ship turns towards the player.
    We use the `Slerp` function to change the ship's current rotation towards the
    target rotation. In this case, the rotation is the one that looks at the player.
    Lastly, the ship is moved forward. Altogether, this results in movements similar
    to how a car turns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last code snippet for the function and the script is the check to see if
    the ship is too far away. It is exactly the same as the one used by the asteroid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can put our enemy ship together, we need to make one more short script.
    Create a new script and name it `Bullet`. As you might guess, this is the script
    that will control the movement of the enemy bullets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts with a single variable, that is, how fast the bullet will
    move through space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we make use of the `LateUpdate` function again. This function first uses
    `PlayerShip.Rotate` to reposition the bullet, just as with all the other objects
    in the game world. It then moves forward with speed. Last, it does the check for
    being out of range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function for the script, `OnTriggerEnter`, works just like the one
    for the asteroid. If the bullet makes contact with a ship, it will destroy itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have our scripts, the next step is to create the enemy ship and
    bullet prefabs. To create the bullet, start by navigating to **GameObject** |
    **Create Other** | **Sphere**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new sphere to `Bullet` and scale it to about half of its original
    size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the `Bullet` script to the object and be sure to check the **Is Trigger**
    checkbox in its **SphereCollider** component. Without that box checked, the bullet
    won't work properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, drag the object to the `Prefabs` folder to turn it into a prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to make the enemy ship. Start by creating an empty **GameObject**
    and renaming it to `EnemyShipPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a copy of the `EnemyShip` model to the scene and make it a child of the
    pivot point we just created. Be sure to rotate it to face forward along the z
    axis, and position it to be centered on the pivot point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, use simple colliders and empty **GameObject** to create a collision shape
    for the ship. This is exactly like what we did for the player's ship. Be sure
    to make all of the colliders children of the enemy ship's pivot point.![Time for
    action – adding an enemy ship](img/2014OT_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a muzzle point and position it in front of the enemy ship.
    Do it just as we did for the tanks. Be sure to also make it a child of the ship's
    pivot point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add the `EnemyShip` script and a **Rigidbody** component to the pivot point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Almost done. Drag the muzzle point from the **Hierarchy** window and drop it
    on the appropriate slot in the script component in the **Inspector**. Also, drag-and-drop
    the **Bullet** prefab from the **Project** window to the waiting slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, make the ship into a prefab by dragging it from the **Hierarchy** window
    to the `Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a couple of extra ships to the scene and try it out.![Time for action –
    adding an enemy ship](img/2014OT_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an enemy space ship. The ships will fly after the player and begin
    shooting when within range. Like the asteroids, they move around the player to
    fake the player's movement. However, instead of moving in a random direction,
    the enemy ships turn towards the player. By slowing down how fast the ships can
    turn, they move in arcs rather than pivoting quickly in place. Also, because of
    the **Rigidbody** component attached to the enemy ships, they can collide with
    the asteroids that are in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – skybox and fog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have several objects flying around in space, it is a good idea to
    make the scene look a little better. For our Tank Battle game, we added a skybox
    to make the scene look like it is actually on a planet. However, we are flying
    around in space. The challenge is for you to find or make a skybox that looks
    like outer space. Also, adding some distant fog will obscure objects as they move
    too far away from the player. If the fog is black, it will look like the objects
    are swallowed by the blackness of deep space.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling with touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have several objects flying around in our space scene, including
    some that will shoot at the player, we should give the player the ability to do
    more than just dodge. One of the most obvious features of the modern mobile device
    is the touch screen. The devices use the electrical conductivity of the user's
    finger and many tiny contact points to determine the location that is being touched.
    Unity provides us with easy access to the touch inputs. By combining the input
    with ray casts, as we did for making the tanks fire, we can determine which object
    in the 3D space was touched by the user. For us, this means we can give the player
    the ability to shoot at and destroy the objects in space.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – touch to shoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For making use of the touch inputs, we will need to add a single script to
    our player''s ship:'
  prefs: []
  type: TYPE_NORMAL
- en: To give the player the ability to shoot, we need to first create a new script
    and call it `TouchShoot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script begins with a single variable. A `LayerMask` is used to selectively
    hit objects with a raycast. There are essentially a lot of layers that should
    be hit. This one will be used to determine what the player can or cannot shoot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Update` function is the only function in this script. It starts with a
    loop. The `Input` class provides us with the `touchCount` value, which is simply
    a counter for how many fingers are currently touching the device screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we progress through the loop, we use the `Input.GetTouch` function to access
    information about each touch. This line of code checks the phase of the touch.
    Every touch has five potential phases: **Began**, **Moved**, **Stationary**, **Ended**,
    and **Cancelled**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Began**: This phase of touch is when the user first touches the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moved**: This phase of touch is when the user moves his/her finger across
    the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stationary**: This phase of touch is the opposite of the previous phase;
    it is when the finger is not moving across the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ended**: This phase of touch is when the finger is lifted off the screen.
    This is the normal way for a touch to complete.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancelled**: This phase of touch is when an error occurs while tracking the
    touch. This phase tends to occur most often when a finger is touching the screen,
    but not moving for too long. The touch system is not perfect, so it assumes it
    missed the finger being lifted off the screen and just cancels it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we create a pair of variables. The first is a `Ray`, which is just a container
    for storing a point in space and a directional vector. The `ScreenPointToRay`
    function is specially provided by the camera for converting touch positions from
    the 2D space of the screen to the 3D space of the game world. As with our tanks,
    the second is a holder for what was hit by our raycast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last step for the function is to call the `Raycast` function. We pass the
    ray, and the tracking variable to the function. Next, we have to give it a distance,
    and finally the `LayerMask`. If an object is hit, it is destroyed. Also, there
    are several curly braces required to close off the if statements, loop, and function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To try the script out, simply add it to the **PlayerShipPivot** GameObject.
    Be careful. At this point, if you were to touch the player's ship while testing,
    it would be destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to fix this issue, we need to create a new layer. Start by going to
    the menu bar of Unity and clicking on **Edit** | **Project Settings** | **Tags**.
    This is just a second path to the same location where we created layers for the
    Tank Battle game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the right of **User Layer 8** and input `Player` in the field. This
    will create the new layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **PlayerShipPivot** object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-right corner of the **Inspector** window, select the layer we just
    created from the **Layers** drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Unity asks whether you want to change the children objects as well, confirm
    that you do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `TouchShoot` script, deselect the new layer from the **Touch Mask**
    list. This will allow the player to shoot everything but themselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one last thing we need to do. Go to the menu bar of Unity and click
    on **Edit** | **Project Settings** | **Physics**. This opens a new set of controls
    in the **Inspector** window that adjust how the Physics engine runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the moment, we only care about the **Raycasts Hit Triggers** checkbox. Uncheck
    it. If we don't, the players will hit the trigger volume that is around the asteroid
    when they shoot, rather than the asteroid itself. It is not so great an issue
    for the asteroids. But, if we were to create something, such as an explosive mine,
    the trigger volume would be much larger. That would make it very odd-looking for
    shooting at the mine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We gave the player the ability to shoot when they touch the screen. By looping
    through the list of touches, the player is able to use more than one finger for
    shooting at targets. The special `ScreenPointToRay` function provided by the camera
    allows us to change 2D screen touches into 3D game world interactions. By making
    use of the `LayerMask`, we also prevent the player from shooting and destroying
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – healthy ships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The challenge here is to give the enemy ships some health. When we created the
    enemy tanks in the previous chapter, we caused them to take a few shots from the
    player before they would be destroyed. Do the same thing here for the enemy ships.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning in space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have created a space game that allows the player to fly infinitely
    through space. The player never actually moves; instead, the objects in the scene
    move around it to fake the movement. We have asteroids that will fly in a random
    direction through space. We also created enemy spaceships that fly after the player
    and shoot at them. Finally, we have the ability to shoot at and destroy the objects
    in the scene. However, at this point we can quickly run out of things to shoot
    at. Either they get too far away, or we destroy them. To fix this, we will now
    create a system that will randomly spawn all that we have created around the player.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a space spawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our last script will populate our space and will be attached to the player''s
    ship, since it is the center of the game world:'
  prefs: []
  type: TYPE_NORMAL
- en: To fill our space with the objects, we need to create another script. Name it
    `SpaceSpawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start it out with two variables. These two define the space within which
    the new objects will be spawned. They will be created outside the minimum range
    but within the maximum range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we have two variables for controlling the frequency at which objects should
    be spawned. These will work the same as the ones we used for making the enemy
    ships shoot at the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final variable for this script, is an array. It is simply a list of all
    of the objects that can be spawned. We will be filling it in a little bit, when
    we return to Unity to set it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Update` is once again our function of choice for the script. We start it off
    by making sure that there is something in the list to be spawned. If there are
    no objects to be spawned, there is no point in continuing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we track how long it has been since the last spawn and check to see if
    it has been long enough to spawn once more. Again, this works just like the shooting
    of the enemy ships.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to figure out where to spawn the next object in space. To do this,
    we first use `Random.onUnitSphere` to find a random direction. Next, we find a
    random distance that lies within our min and max ranges. Finally, they are multiplied
    together to give us a position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To pick a random object, we use `Random.Range` and pass the length of the list
    of objects to it. This will give us the index of one of the slots of the list.
    The following line of code makes sure that there is an object in the slot. If
    there isn't, we cannot spawn it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we actually spawn the object using our good friend, the `Instantiate`
    function. We pass the object we randomly selected, the position we found, and
    finally, a random rotation to the `Instantiate` function. As a result, the object
    is created in the scene and set into place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we subtract the `frequency` variable from our time tracker to finish
    off the function and the script. This will cause a spawn to occur on every frequency
    tick without losing any time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now return to Unity to set up the script. Add it to the `PlayerShipPivot`
    object. It will work as well here as anywhere else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fill the list, just drag your prefabs from the **Project** window and drop
    them on **Spawn List** in the **Inspector** window. The little triangle to the
    left of the field will let you expand the list and see what is currently in it.
    If you want to adjust the chances of the various objects appearing, just change
    how many of them are in the list. There is nothing keeping you from putting nine
    references to the asteroid prefab into the list and a single reference to the
    enemy ship prefab, to give the ship a one in 10 chance of being spawned. Whatever
    you choose, use the list to set the object chances and include at least one of
    each obstacle we have created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, test it out. Hit play and fly around to see the objects spawn and fly
    around.![Time for action – creating a space spawn](img/2014OT_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a system for spawning objects randomly in space. First, we tracked
    time in the same way as we did for making the enemy ships shoot at the player.
    Next, we found a random direction and the range with which we determined a position.
    After that, the system selects a random object from the list and finally spawns
    it. In order to adjust the chances of any single object appearing, we just adjust
    how often it appears in the list of objects to be spawned, relative to the other
    objects in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – more to spawn and shoot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included in the starting assets for this chapter are two more asteroid meshes
    and a mine. Using these, you can create more objects to be spawned in the game.
    The mine can also be created with a much larger trigger volume. This would allow
    it to explode when ships get close, not just hit it. If you were additionally
    inclined, you could at least make the asteroids randomly pick a scale when they
    are spawned. This would give the appearance of even greater variety in the asteroids,
    even though there are only a few.
  prefs: []
  type: TYPE_NORMAL
- en: Also, try creating another ship or several other ships. Perhaps one is a transport
    ship and it flees from the player. A hard one would be a ship that splits into
    two smaller ships when destroyed. Or, just recreate your favorite space ships
    from your favorite sci-fi media. In this game, the universe is the limit.
  prefs: []
  type: TYPE_NORMAL
- en: For the Tank Battle game, we created a turbo boost button for getting the player
    across the city quickly. It is also useful for fleeing enemies. Implement it for
    the space fighter. It would be useful for catching enemies and dodging bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Pop Quiz – understanding Android components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern mobile devices have many parts that perform a huge variety of functions.
    Knowing what they are and how they work together is the first step towards being
    able to use them. Are the following statements true or false?
  prefs: []
  type: TYPE_NORMAL
- en: Q1\. The magnometer and accelerometer work together to give position on a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. The gyroscope detects rotation and movement of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. 2D positions on the touch screen can be translated into 3D positions in
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. What line of code will allow us to translate the user's touch to a 3D position
    in the game?
  prefs: []
  type: TYPE_NORMAL
- en: '`Camera.main.ScreenPointToRay(Input.GetTouch(0).position)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Input.GetMouseButton(0)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Camera.main.WorldToScreenPoint(Input.GetTouch(0).position)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q5\. What line of code will give us the device's acceleration?
  prefs: []
  type: TYPE_NORMAL
- en: '`Input.gyro`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Input.compass`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Input.acceleration`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the specialties of the modern mobile device.
    We created a Space Fighter game to try it out. We gained access to the device's
    accelerometer to detect when it is rotated. This gave our spaceship the ability
    to be steered. We also made use of the touch screen to give a player the ability
    to shoot enemies in the game. Because we wanted an infinite amount of space to
    fly through, we had to make it all without the player moving. Instead, everything
    else moves around the player, faking the player's movement. It also required a
    system that continuously spawned new enemies and obstacles around the player,
    allowing us to keep flying and finding new things to play with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a short break from our Space Fighter
    game. Almost certainly the most popular mobile game on the market, Angry Birds
    is a distinct and not uncommon type of game. In order to learn about Physics in
    Unity and the possibility of a 2D-style game, we will be making an Angry Birds
    clone. We will also take a look at Parallax scrolling to create a pleasing background.
    Before you know it, we will be creating all of the Angry Birds levels that you
    always wished you could play.
  prefs: []
  type: TYPE_NORMAL
