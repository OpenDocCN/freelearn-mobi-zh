- en: Chapter 6. Specialties of the Mobile Device – Touch and Tilt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 移动设备的特性 - 触摸和倾斜
- en: '*In the previous chapter, we learned about Pathfinding and AI. We expanded
    our Tank Battle game to include enemy tanks. We created points for them to spawn
    at, and made them shoot at the player. Utilizing Unity''s pathfinding system,
    we made the tanks chase the player. Also, the player was given the ability to
    destroy the tanks. Once destroyed, the player receives some points and a new enemy
    tank is spawned.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们学习了路径查找和人工智能。我们将坦克战斗游戏扩展到包括敌方坦克。我们为它们创建了出生点，并让它们向玩家开火。利用Unity的路径查找系统，我们让坦克追逐玩家。此外，玩家还被赋予了摧毁坦克的能力。一旦摧毁，玩家将获得一些分数，并生成一个新的敌方坦克。*'
- en: '*In this chapter, we start working on a new game as we explore some of the
    specialties of the mobile device. We will be creating a Space Fighter game. The
    player will take control of a space ship and blast enemy ships, mines, and asteroids
    for points. To steer their ship, the player will have to tilt the mobile device.
    To shoot, the player will touch the screen where they want their laser blast to
    hit.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们开始着手制作一个新游戏，同时探索移动设备的特性。我们将创建一个太空战斗机游戏。玩家将控制一艘太空船，摧毁敌方飞船、地雷和小行星以获得分数。为了控制他们的飞船，玩家必须倾斜移动设备。为了射击，玩家需要在屏幕上触摸他们希望激光束击中的位置。*'
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Touch controls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸控制
- en: Tilt controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾斜控制
- en: We will be creating a new project for this chapter, so start up Unity and we
    will begin.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本章创建一个新的项目，所以启动Unity，我们将开始。
- en: Setting up
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: As with every project, we need a little bit of preparation work in order to
    prepare our development environment. Don't worry, the setup for this chapter is
    simple and straightforward.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个项目一样，我们需要做一些准备工作来准备我们的开发环境。别担心，本章的设置简单直接。
- en: Time for action – creating the project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建项目
- en: 'Let''s get started. The first step is, of course, to start Unity and create
    a new project. Naming the project `Ch6_SpaceFighter` will work well:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。第一步当然是启动Unity并创建一个新的项目。将项目命名为`Ch6_SpaceFighter`将是一个不错的选择：
- en: Once Unity has finished initializing, this is a perfect opportunity to set our
    build settings. Open the **Build Settings** window, select **Android** from the
    list of platforms, and hit **Switch Platform** to change the target platform.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Unity完成初始化，这就是设置我们的构建设置的绝佳机会。打开**构建设置**窗口，从平台列表中选择**Android**，然后点击**切换平台**以更改目标平台。
- en: While at the **Build Settings** window, select **Player Settings** to open the
    player settings in the **Inspector**. Adjust the **Company Name**, **Product Name**,
    and especially the **Bundle Identifier**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建设置**窗口中，选择**玩家设置**以在**检查器**中打开玩家设置。调整**公司名称**、**产品名称**，尤其是**包标识符**。
- en: We need to create a few folders to keep the project organized. The `Scripts`,
    `Models`, and `Prefabs` folders should be created in the **Project** window.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建几个文件夹以保持项目有序。在**项目**窗口中创建`Scripts`、`Models`和`Prefabs`文件夹。
- en: We now need to import the assets for this project. We are going to need a space
    ship for the player, an enemy space ship, an explosive mine, and some asteroids.
    Luckily, all of these have already been prepared and are available with the starting
    assets for this chapter. Import `PlayerShip.blend`, `PlayerShip.png`, `EnemyShip.blend`,
    `EnemyShip.png`, `Asteroid.blend`, `Asteroid.png`, `SpaceMine.blend`, and `SpaceMine.png`
    to the `Models` folder that you just created.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要导入这个项目的资源。我们需要一个玩家飞船、一个敌方飞船、一个爆炸性地雷和一些小行星。幸运的是，所有这些都已经准备好，并且在本章的起始资源中可用。将`PlayerShip.blend`、`PlayerShip.png`、`EnemyShip.blend`、`EnemyShip.png`、`Asteroid.blend`、`Asteroid.png`、`SpaceMine.blend`和`SpaceMine.png`导入你刚刚创建的`Models`文件夹中。
- en: '*What just happened?*'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just finished the setup for this chapter's project. Once again, a little
    bit of effort at the beginning of the project will save time and frustration later.
    Especially, as a project grows in size, the organization done at the beginning
    becomes most important.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了本章项目的设置。再次强调，在项目开始时付出一点努力将节省时间和挫折。特别是，随着项目规模的扩大，最初的组织变得最为重要。
- en: Controlling with tilt
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倾斜控制
- en: Modern mobile devices possess a broad variety of internal sensors for detecting
    and providing information about the surronding world. Though you may not have
    thought of them in such a way, you are certainly most familiar with the microphone
    and speaker that are required for making calls. There is a Wi-Fi receiver for
    connecting to the Internet and a camera for taking pictures. Your device almost
    certainly has a magnetometer to work with your GPS to provide directions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现代移动设备拥有广泛的各种内部传感器，用于检测和提供有关周围世界的信息。尽管你可能没有这样想过，但你肯定最熟悉用于打电话的麦克风和扬声器。有一个Wi-Fi接收器用于连接互联网，还有一个相机用于拍照。你的设备几乎肯定有一个磁力计，与GPS一起工作以提供方向。
- en: The sensor we are interested in right now is the **gyroscope**. This sensor
    detects local rotation of the device. In general, it is used to determine the
    orientation of the device. We are going to use it to steer our ship. When the
    user tilts their device left and right, their space ship will turn to the side.
    When the device is tilted up and down, the ship will go up and down.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们感兴趣的是**陀螺仪**这个传感器。这个传感器可以检测设备的局部旋转。通常，它被用来确定设备的方向。我们将用它来控制我们的飞船。当用户左右倾斜设备时，他们的飞船将向侧面转动。当设备上下倾斜时，飞船将上下移动。
- en: Time for action – steering the space ship
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 控制飞船
- en: 'To steer our ship, we will need to create a single script and apply it to our
    ship:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们的飞船，我们需要创建一个单独的脚本并将其应用到我们的飞船上：
- en: To start this off, create a new script and name it `TiltSteering`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了开始这个过程，创建一个新的脚本并将其命名为`TiltSteering`。
- en: As with all of our other scripts, we will begin this one with a few variables.
    The first two variables control the speed with which the ship will rotate as the
    device is tilted. The second two are going to be used to limit the rotation of
    the ship. These will determine how tight a circle the player's ship can turn in.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们所有的其他脚本一样，我们将从这个脚本开始，设置几个变量。前两个变量控制飞船旋转的速度，当设备倾斜时。接下来的两个变量将被用来限制飞船的旋转。这些将决定玩家飞船可以转动的圆圈有多紧。
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will make use of the `Update` function. We start out by creating a
    variable to store the ship's current rotation. Next, we have to adjust the rotation.
    When working with Euler rotations, Unity adjusts values to be between zero and
    360\. This way, the values are never negative. Anything below zero simply wraps
    around and starts counting down from 360; anything above 360 wraps back to start
    counting up from zero again. We need the negative values. So, if the parts of
    the rotation are above 180, we subtract 360 to determine their negative values.
    Also, we are not making adjustments to the z component because the ship will not
    be rotating around its forward axis.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`Update`函数。我们首先创建一个变量来存储飞船当前的旋转。然后，我们必须调整旋转。当使用欧拉旋转时，Unity会将值调整为介于0到360之间。这样，值永远不会是负数。任何小于0的值都会简单地绕过并从360开始倒数；任何大于360的值都会回到起点，再次从0开始计数。我们需要负值。所以，如果旋转的部分超过180度，我们就减去360度来确定它们的负值。此外，我们不对z分量进行调整，因为飞船不会围绕其前进轴旋转。
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we apply the accelerometer measurement. When the device is held horizontally,
    with the home button on the right and the screen towards the user, the x component
    holds the rotation of the device while it is facing the user. The z component
    holds the rotation of the screen being tilted up and down. The components are
    multiplied by their respective speeds and are added to the rotation. The y rotation
    controls pointing left and right while the x component controls pointing up and
    down. However, the z acceleration is the opposite of how the ship should rotate,
    so we take the negative.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应用加速度计的测量值。当设备水平持有时，主页按钮在右侧，屏幕朝向用户，x分量保持设备面向用户时的旋转。z分量保持屏幕上下倾斜时的旋转。这些分量乘以它们各自的速度并加到旋转上。y旋转控制左右指向，而x分量控制上下指向。然而，z加速度与飞船应该旋转的方向相反，所以我们取其负值。
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the acceleration is applied, we need to limit the rotations so that the
    ship is not rotated too far. We use the `Mathf.Clamp` function to limit the rotation
    components between the negative of the max and the max of the relevant values.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用加速度之后，我们需要限制旋转，以便飞船不会旋转得太远。我们使用`Mathf.Clamp`函数来限制旋转分量在最大值的负数和最大相关值之间。
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we apply the rotation to the ship's transform and close off the function
    for the script.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将旋转应用到飞船的变换上，并关闭脚本的函数。
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to make use of our new script, we need to do some setup for the player's
    ship. Start by creating an empty **GameObject** and setting its position to zero.
    Rename it to `PlayerShipPivot`. This will allow us to control the movement and
    appearance of the player's ship independently.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用我们新的脚本，我们需要为玩家的飞船做一些设置。首先创建一个空的**GameObject**，并将其位置设置为零。将其重命名为`PlayerShipPivot`。这将使我们能够独立控制玩家的飞船的运动和外观。
- en: Drag your `PlayerShip` model from the **Project** window and drop it on the
    pivot point we just created. Be sure to center your ship on the point and rotate
    it to face forward along the z axis.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口拖动你的`PlayerShip`模型，并将其放在我们刚刚创建的支点上。确保你的船体在点上居中，并旋转它使其沿z轴朝前。
- en: You can now add the script to the pivot point.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以将脚本添加到支点。
- en: This is the point when it is especially important to have Unity Remote. With
    your device attached and Unity Remote running, you can hold it up and steer the
    ship. Feel free to adjust the rotation speeds and limits until you find the settings
    that feel natural to control.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这时，拥有Unity Remote尤为重要。将你的设备连接并运行Unity Remote后，你可以举起它并控制船体。随意调整旋转速度和限制，直到找到感觉自然的控制设置。
- en: We will need to be able to see past the ship, so that we can later shoot at
    targets we are flying towards. Adjust the position of the camera so the ship is
    centered horizontally and a little below center.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要能够看到船体之外，这样我们才能在飞向目标时射击。调整摄像机的位置，使船体在水平方向上居中，并且略低于中心。
- en: The scene also needs to be slightly lit. The light in deep space tends to be
    very general, so we can get away with just adjusting the ambient light. Click
    on **Edit** in the menu bar of Unity, and then click on **Render Settings**. By
    setting the **Ambient Light** to white, our scene will be bright enough to see
    everything.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景还需要稍微照亮。在太空中，光线通常非常普遍，所以我们只需调整环境光即可。点击Unity菜单栏中的**编辑**，然后点击**渲染设置**。通过将**环境光**设置为白色，我们的场景将足够明亮，可以看清一切。
- en: Once all the settings are in place, be sure to save the scene. Name it `SpaceFighter`.![Time
    for action – steering the space ship](img/2014OT_06_01.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切设置就绪后，务必保存场景。将其命名为`SpaceFighter`。![行动时间 – 驾驶太空船](img/2014OT_06_01.jpg)
- en: '*What just happened?*'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We made use of the accelerometer to provide steering control of a spaceship.
    By measuring how the player is tilting their device, we are able to rotate the
    ship accordingly. We did not make the ship actually move, but just rotated it
    in place. We will come to understand why in a little bit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用加速度计来提供太空船的转向控制。通过测量玩家如何倾斜他们的设备，我们能够相应地旋转船体。我们没有让船体实际移动，只是在原地旋转。我们很快就会明白为什么。
- en: Making things move in space
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在太空中移动物体
- en: Your first instinct to make the ship move would be probably to just change the
    position of the ship. However, things get weird when objects are really far from
    the world origin. In programming, there are actually limits on the size of the
    number that a variable can hold. This limit causes the rendering system to begin
    failing when the vertex positions become too large, resulting in the model being
    distorted beyond recognition. Admittedly, we are talking about positional values
    in the hundreds of thousands and beyond. However, say the player were to just
    fly straight for a long time; eventually, they could reach this distance of distortion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能的第一反应是直接改变船体的位置。然而，当物体离世界原点非常远时，事情会变得奇怪。在编程中，实际上变量可以持有的数字大小是有限制的。这个限制导致当顶点位置变得过大时，渲染系统开始失败，导致模型扭曲到无法识别。诚然，我们谈论的是数以万计甚至更多的位置值。然而，假设玩家一直直线飞行很长时间，最终他们可能会达到这种扭曲的距离。
- en: As a potential solution, we could force the player to turn, or stop their forward
    progress, or wrap their position so they continue flying from the opposite side
    of a finite space. However, it is so much more fun to fly through an infinite
    space. We can achieve this by leaving the player's ship in place and moving everything
    else around it. As a new space is entered, new enemies and objects can be spawned
    to fill the space. Old objects and enemies that are too far away can be destroyed
    by removing them where the player won't see. This would give the illusion of an
    infinite amount of space.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种可能的解决方案，我们可以强制玩家转向，或停止他们的前进，或将他们的位置包裹起来，使他们从有限空间的另一侧继续飞行。然而，在无限空间中飞行要有趣得多。我们可以通过将玩家的飞船保持在原地，并移动它周围的一切来实现这一点。当进入一个新的空间时，可以生成新的敌人和物体来填充空间。远离的旧物体和敌人可以通过在玩家看不到的地方移除它们来销毁。这将给人一种无限空间的感觉。
- en: Time for action – flying asteroids
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 飞行小行星
- en: 'The first objects we will be avoiding in our infinite space will be asteroids:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的无限空间中，我们将首先避免的是小行星：
- en: To make the asteroids work, we will first need to make the player ship's rotation
    and speed available for the asteroids to use. To do this, we need to create a
    new script and call it `PlayerShip`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让小行星工作，我们首先需要让玩家飞船的旋转和速度对小行星可用。为此，我们需要创建一个新的脚本，并将其命名为`PlayerShip`。
- en: Again, this script starts with a group of variables. The first is the speed
    of the player's ship. The asteroids and other objects in the space will use it
    to move around the player. The second variable will hold a reference to the `TiltSteering`
    script that we created earlier. This will give us access to the ship's rotational
    speed. The last variable is a static variable that will hold a reference to the
    instance of this script that exists in the scene. This will allow other scripts
    to access the information stored by this script. We call the `use` variable to
    indicate to other scripts that this is the instance they should access.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，这个脚本从一组变量开始。第一个是玩家飞船的速度。空间中的小行星和其他物体将使用它来围绕玩家移动。第二个变量将保存对之前创建的`TiltSteering`脚本的引用。这将使我们能够访问飞船的旋转速度。最后一个变量是一个静态变量，它将保存对场景中存在的此脚本实例的引用。这将允许其他脚本访问此脚本存储的信息。我们使用`use`变量来指示其他脚本，这是他们应该访问的实例。
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we make use of the `Awake` function. This function is automatically called
    at the beginning of the game, making it perfect for initialization. We are using
    it to simply set the `use` variable that we created earlier to the current instance
    of the script.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Awake`函数。这个函数在游戏开始时自动调用，非常适合初始化。我们用它来简单地设置我们之前创建的`use`变量为脚本的当前实例。
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next function is for providing other scripts with the player's current rotation.
    Being static, any script can call it at any time. The function first checks to
    see whether a reference is available to the current instance of the script. If
    it cannot be found, a neutral rotation, `Quaternion.identity`, is returned. Otherwise,
    the rotation of the transform that the script instance is attached to is returned.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数是为了提供给其他脚本玩家当前旋转信息。由于它是静态的，任何脚本都可以在任何时候调用它。该函数首先检查是否有对脚本当前实例的引用。如果找不到，则返回一个中性旋转，`Quaternion.identity`。否则，返回脚本实例附加的变换的旋转。
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Rotate` function here is for faking the movement of the player. This function
    takes the transform that is passed to it and moves and rotates it to make it look
    like it is the player that has moved through space. As with the previous `GetRotation`
    function, it first checks for a reference to the player and does nothing if there
    isn't one.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的`Rotate`函数是用来模拟玩家移动的。这个函数接受传递给它的变换，并移动和旋转它，使其看起来像是玩家已经穿越了空间。与之前的`GetRotation`函数一样，它首先检查玩家的引用，如果没有找到，则不执行任何操作。
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To rotate the asteroid, and anything else, around the player's position, its
    current position needs to be multiplied by the mirror of the player's current
    rotation. To do that, we need to adjust the rotation so that it can be mirrored
    properly. The Euler angles of the player's rotation are stored in a variable for
    manipulation. We then shift the values that are greater than 180, just as we did
    earlier. The rotation is then scaled by the player ship's rotation speed. Finally,
    it is multiplied by the frame speed to keep it in time.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要围绕玩家的位置旋转小行星和其他任何东西，需要将当前的位置与玩家当前旋转的镜像相乘。为此，我们需要调整旋转以便正确地镜像。玩家的旋转的Euler角度被存储在变量中以供操作。然后我们将大于180的值进行移位，就像我们之前做的那样。然后旋转通过玩家飞船的旋转速度进行缩放。最后，它乘以帧速度以保持同步。
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We turn the negative Euler rotation, which is the mirrored rotation, back into
    a Quaternion and store it in a variable for use.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将负Euler旋转（即镜像旋转）转换回四元数，并将其存储在变量中以供使用。
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The mirrored rotation is then multiplied by the passed object's position, updating
    the position to be rotated around the player as if they were turning. The player's
    rotation is then multiplied by a forward-facing vector, the player's speed, and
    finally the frame speed. This is all subtracted from the object's current position
    in order to imitate the player's forward movement. Finally, the passed object's
    rotation is multiplied by the mirrored rotation to change its orientation. Altogether,
    this fakes the movement of the player.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将镜像旋转与传入对象的位置相乘，更新位置以使它围绕玩家旋转，就像他们正在转弯一样。然后玩家的旋转与一个面向前方的向量、玩家的速度以及最终帧速度相乘。所有这些从对象当前的位置中减去，以模仿玩家的前进运动。最后，传入对象的旋转与镜像旋转相乘以改变其方向。总的来说，这模拟了玩家的移动。
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Add the script to the `PlayerShipPivot` object that was created previously.
    Be sure to connect the `TiltSteering` reference.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本添加到之前创建的`PlayerShipPivot`对象上。确保连接`TiltSteering`引用。
- en: Next, we need to make use of that script by creating another. Name it `Asteroid`.
    This script will control an asteroid as it flies through space and the player
    is forced to avoid it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过创建另一个脚本来使用这个脚本。将其命名为`Asteroid`。这个脚本将控制小行星在太空中飞行，并迫使玩家避开它。
- en: The first two of the variables for this script are used for determining a random
    speed at which the asteroid will fly through space. The third variable will hold
    the random speed. The final variable will hold the random direction in which the
    asteroid is flying through space.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该脚本的变量前两个用于确定小行星在太空中飞行的随机速度。第三个变量将保存这个随机速度。最后一个变量将保存小行星在太空中飞行的随机方向。
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we again make use of the `Awake` function for initialization. Any point
    that lies on the surface of a sphere with a radius of one is essentially a vector
    that points in a random direction. Therefore, we use `Random.onUnitSphere` to
    find a random direction for the asteroid to go. It is followed by the use of `Random.Range`
    and the first two variables to determine a random speed for the asteroid to travel.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用`Awake`函数进行初始化。任何位于半径为1的球面上的点本质上是一个指向随机方向的向量。因此，我们使用`Random.onUnitSphere`来为小行星找到随机方向。随后使用`Random.Range`和前两个变量来确定小行星飞行的随机速度。
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last function for this script is `LateUpdate`. We need the asteroid to move
    after the player's ship has updated its rotation; that is why we use this function.
    The first line of the function uses the `GetRotation` function that we created
    for the `PlayerShip` script and stores it in a variable for use.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该脚本的最后一个函数是`LateUpdate`。我们需要在小行星在玩家飞船更新其旋转之后移动；这就是为什么我们使用这个函数。函数的第一行使用我们为`PlayerShip`脚本创建的`GetRotation`函数，并将其存储在变量中以供使用。
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we make a call to the `PlayerShip.Rotate` function, passing it the asteroid's
    transform, so that the asteroid can be moved to fake the player's movement.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用`PlayerShip.Rotate`函数，并传入小行星的变换，这样小行星就可以被移动以模拟玩家的移动。
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next line of code rotates the asteroid's movement direction by the player's
    rotation, again making a change that fakes the player's movement. The position
    is again updated with the asteroid's own movement in the adjusted direction.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码通过玩家的旋转来旋转小行星的运动方向，再次进行改变以模拟玩家的移动。位置再次通过调整方向后的小行星自身运动来更新。
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function and the script finishes with a check to see if the asteroid is
    too far away from the player. We do this by checking `sqrMagnitude` of the asteroid's
    position. The length of a vector is its magnitude. For positional vectors, this
    is the distance from the center point. The `sqrMagnitude` is the square of the
    vector's magnitude. This is much faster to calculate and just as easy for comparison.
    We just need to compare it to the square of the desired value. In this case a
    max distance of about 300, whose square is 100,000, will work well for our needs.
    If you remember from math class, 1e5 is the same as a one with five zeros behind
    it, which is 1 million. Finally, if the asteroid is too far away, it is destroyed.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数和脚本通过检查小行星是否离玩家太远来完成。我们通过检查小行星位置的`sqrMagnitude`来实现这一点。向量的长度是其大小。对于位置向量，这是从中心点的距离。`sqrMagnitude`是向量大小的平方。这比计算速度更快，并且比较起来也很容易。我们只需要将其与所需值的平方进行比较。在这种情况下，大约300的最大距离，其平方为100,000，将很好地满足我们的需求。如果你还记得数学课上的内容，1e5与一个后面有五个零的1相同，即1百万。最后，如果小行星离得太远，它将被销毁。
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In order to test this script, we need an asteroid prefab. To create it, start
    off by adding the `Asteroid` model to the scene and deleting two of the three
    meshes.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这个脚本，我们需要一个小行星预制件。要创建它，首先将`Asteroid`模型添加到场景中，并删除三个网格中的两个。
- en: Add the script to the model and drag it to the `Prefabs` folder, turning it
    into a prefab.![Time for action – flying asteroids](img/2014OT_06_02.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本添加到模型中，并将其拖动到`Prefabs`文件夹中，将其转换为预制件。![行动时间 – 飞行小行星](img/2014OT_06_02.jpg)
- en: '*What just happened?*'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created two scripts and a prefab. The first script is used by the player's
    ship to relay information about its rotation and speed to other scripts. The second
    script controls the motion of asteroids in the game world. Because of the weirdness
    in the model's behavior when subjected to extreme distances, the player never
    actually moves. The game world and all of the objects in it are instead moved
    around the player. Finally, we created an asteroid prefab. Try adding several
    prefabs to the scene and try them out. You can fly in, out, and around them even
    though your ship never actually moves.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个脚本和一个预制件。第一个脚本由玩家的飞船使用，用于将有关其旋转和速度的信息传递给其他脚本。第二个脚本控制游戏世界中小行星的运动。由于模型在极端距离下表现出的奇怪行为，玩家实际上从未移动。游戏世界及其中的所有对象都围绕着玩家移动。最后，我们创建了一个小行星预制件。尝试将几个预制件添加到场景中并尝试使用它们。尽管你的飞船实际上从未移动，但你仍然可以飞进、飞出并绕着它们飞行。
- en: Adding space collisions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加空间碰撞
- en: Flying around, you probably noticed that you can fly straight through the asteroids.
    To make it possible for the player to hit them, we need to add some collision
    to the player's ship and the asteroid. This is similar to what was done for the
    Tank Battle game. We will be going into more detail about how the collision works
    in the next chapter, but we will need to make use of the **Rigidbody** component.
    It provides access to Physics calculations and allows us to group colliders to
    make more complex collision shapes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在飞行过程中，你可能注意到你可以直接穿过小行星。为了让玩家能够击中它们，我们需要给玩家的飞船和小行星添加一些碰撞。这与坦克大战游戏中所做的是类似的。我们将在下一章中更详细地介绍碰撞的工作原理，但我们需要使用**Rigidbody**组件。它提供了对物理计算的访问权限，并允许我们将碰撞器分组以创建更复杂的碰撞形状。
- en: Time for action – adding collisions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加碰撞
- en: 'We need to add some collision capabilities to our space objects, so that they
    can crash into each other and be shot at properly:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要给我们的太空对象添加一些碰撞能力，以便它们可以相互碰撞并被正确射击：
- en: Let's start by giving collision to the asteroid. Do this by first selecting
    the mesh for the asteroid and adding a **MeshCollider** component. This will later
    let us shoot at the asteroid.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从给小行星添加碰撞开始。首先选择小行星的网格，并添加一个**MeshCollider**组件。这将使我们能够向小行星射击。
- en: Next, select the same object that holds our `Asteroid` script component. Add
    a **SphereCollider** component to the object and adjust the **Radius** to be a
    little larger than the asteroid. This collider will detect when the asteroid has
    collided with the player.![Time for action – adding collisions](img/2014OT_06_03.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择包含我们的`Asteroid`脚本组件的相同对象。向对象添加一个**SphereCollider**组件，并将**半径**调整为略大于小行星。这个碰撞器将检测小行星是否与玩家相撞。![行动时间
    – 添加碰撞](img/2014OT_06_03.jpg)
- en: The **SphereCollider** needs to have the **Is Trigger** checkbox checked. We
    are not checking the true collision, just an approximate one. With this checkbox
    checked, objects will no longer be stopped by the collider, but instead trigger
    an event in script when an object enters the collider volume. When the player
    enters the collider, it will be close enough that we can assume and act as if
    it has collided.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SphereCollider**需要勾选**Is Trigger**复选框。我们不是检查真正的碰撞，而是一个近似的碰撞。勾选此复选框后，对象将不再被碰撞体阻止，而是在对象进入碰撞体体积时在脚本中触发一个事件。当玩家进入碰撞体时，它将足够近，我们可以假设并作为它已经发生碰撞来行动。'
- en: When you are satisfied with the changes, be sure to apply them to the prefab.
    Otherwise, the other asteroids will not be updated and collidable.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你对更改满意时，一定要将它们应用到预制件上。否则，其他小行星将不会更新并且不可碰撞。
- en: To detect when the player has entered the new trigger area, we need to add a
    short function to the `Asteroid` script. We add a `OnTriggerEnter` function to
    the end of the script. This function is automatically called by the Physics system
    when one collider enters another. The collider that is passed to it is the one
    that it collided with. However, the function only works if at least one of the
    objects has a **Rigidbody** component attached. We will be covering it in detail
    in [Chapter 7](ch07.html "Chapter 7. Throwing Your Weight Around – Physics and
    a 2D Camera"), *Throwing Your Weight Around – Physics and a 2D Camera*, but the
    Rigidbody component is what actually connects an object into Unity's Physics engine,
    giving our scripts access to the `OnTrigger` and `OnCollision` groups of functions.
    We will be adding this to the player's ship. When the function is called, it simply
    destroys the asteroid.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检测玩家何时进入新的触发区域，我们需要在`Asteroid`脚本中添加一个简短的功能。我们在脚本的末尾添加一个`OnTriggerEnter`函数。当其中一个碰撞体进入另一个碰撞体时，物理系统会自动调用此函数。传递给它的碰撞体是与之发生碰撞的那个。然而，此函数仅在至少有一个对象附加了**Rigidbody**组件时才有效。我们将在[第7章](ch07.html
    "第7章。抛掷你的重量——物理和2D相机")中详细讲解，*抛掷你的重量——物理和2D相机*，但Rigidbody组件实际上是连接对象到Unity物理引擎的，使我们的脚本能够访问`OnTrigger`和`OnCollision`函数组。我们将将其添加到玩家的飞船上。当函数被调用时，它只是简单地销毁小行星。
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we need to add collision to the the player's ship. Start by adding that
    **Rigidbody** component to the **PlayerShipPivot** GameObject that we created
    earlier.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为玩家的飞船添加碰撞。首先，将**Rigidbody**组件添加到我们之前创建的**PlayerShipPivot**GameObject中。
- en: Be sure to check the **Is Kinematic** checkbox of the new component. This tells
    the Physics system that we want to control the object's motion through the script.
    If it was not checked, the ship would begin to fall as soon we start playing the
    game.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一定要检查新组件的**Is Kinematic**复选框。这告诉物理系统我们希望通过脚本控制对象的运动。如果没有勾选，飞船会在游戏开始时开始下落。
- en: One of the features of a **Rigidbody** component is that it treats all colliders
    on child objects in the **Hierarchy** as a part of a single collision shape. This
    way, we are able to build a complex collision shape using several simple and faster
    process colliders. By creating an empty **GameObject** and adding the simple colliders,
    we size and position them to cover the player's ship. Be sure to make the collider
    objects children of the ship's pivot point.![Time for action – adding collisions](img/2014OT_06_04.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Rigidbody**组件的一个特性是它将**Hierarchy**中子对象的全部碰撞体视为单个碰撞形状的一部分。这样，我们能够使用几个简单且快速的碰撞体构建一个复杂的碰撞形状。通过创建一个空的**GameObject**并添加简单的碰撞体，我们将它们的大小和位置调整到覆盖玩家的飞船。务必确保将碰撞体对象设置为飞船的枢轴点的子对象。![行动时间
    - 添加碰撞](img/2014OT_06_04.jpg)'
- en: '*What just happened?*'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We added collision to the asteroids and the player's ship. This gives the player
    the ability to crash into and destroy the asteroids. We are utilizing a trigger
    collider to approximate collision with the asteroid. Also, we make use of the
    **Rigidbody** component, allowing our ship to collide with other things in the
    scene. Additionally, this gives us the advantage of being able to build a complex
    collision shape out of the simple colliders that are provided by Unity. Although
    it is technically possible to just use a **MeshCollider** to exactly match the
    shape of the ship, it is not recommended. The **Rigidbody** and **MeshCollider**
    components do not mix well. Also, several simple colliders are much faster for
    the computer to calculate than a single **MeshCollider**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为小行星和玩家的飞船添加了碰撞。这给了玩家撞击并摧毁小行星的能力。我们利用触发碰撞体来近似小行星的碰撞。此外，我们还使用了 **Rigidbody**
    组件，允许我们的飞船与其他场景中的物体相撞。此外，这还使我们能够利用Unity提供的简单碰撞体构建一个复杂的碰撞形状。虽然技术上可以使用 **MeshCollider**
    来精确匹配飞船的形状，但这并不推荐。**Rigidbody** 和 **MeshCollider** 组件不太兼容。此外，几个简单的碰撞体比单个 **MeshCollider**
    对计算机的计算要快得多。
- en: Have a go hero – adding points
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 – 添加分数
- en: It is great that we can make the player ship collide with the asteroids, but
    it doesn't mean much in terms of a game. There is no penalty for the collision.
    This challenge is for you to implement a scoring system similar to the one we
    used for the Tank Battle game from the previous chapters. When the player collides
    with asteroids, subtract points from the score. Use the `SendMessage` function
    on the other collider from the `OnTriggerEnter` function. Don't just subtract
    points when the trigger is entered, because (as you will find out later) the asteroids
    will not be colliding only with the player.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 能够让玩家飞船与小行星相撞是件好事，但从游戏的角度来看，这并没有什么意义。碰撞没有惩罚。这个挑战是让你实现一个类似于我们在上一章中使用的坦克大战游戏的计分系统。当玩家与小行星相撞时，从分数中减去一些分数。在
    `OnTriggerEnter` 函数中使用其他碰撞体的 `SendMessage` 函数。不要仅仅在触发器进入时减分，因为（你稍后会发现）小行星不会只与玩家相撞。
- en: Creating the enemy
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建敌船
- en: Flying around space with a handful of asteroids is great, but it doesn't make
    for much of a fight. That is why we are going to add an enemy spaceship that will
    chase and shoot at the player. We have no mesh to use for pathfinding, so we cannot
    use the techniques we learned in the previous chapter. However, there are no buildings
    in space to navigate around, so the chasing of the player will be much simpler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在空间中飞来飞去，只有几颗小行星是很不错的，但这并不能构成一场战斗。这就是为什么我们要添加一个敌船，它会追逐并射击玩家。我们没有用于路径查找的网格，所以不能使用我们在上一章中学到的技术。然而，在太空中没有建筑物可以导航，所以追逐玩家将会简单得多。
- en: Time for action – adding an enemy ship
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加敌船
- en: 'To make our enemy ships, we will need a script to turn our enemy ship into
    a prefab:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作我们的敌船，我们需要一个脚本将敌船转换成预制体：
- en: The first thing we need to do is create a new script and call it `EnemyShip`.
    This script will control the movement and shooting of the enemy ships.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新的脚本，并将其命名为 `EnemyShip`。这个脚本将控制敌船的运动和射击。
- en: The script starts off with several variables. The first two define the speed
    with which the ship moves forward and how fast it turns.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本开始时包含几个变量。前两个定义了飞船前进的速度和旋转的速度。
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The next three variables are for controlling the shooting of the ship. First
    is the rate at which bullets are fired. It is followed by the range that the ship
    has to be within to fire at the player. Third is a holder for how long it has
    been since the last bullet was fired. This will work with the rate of fire to
    dictate when the ship can fire again.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的三个变量用于控制飞船的射击。首先是子弹发射的频率。其次是飞船必须处于的射程内才能射击玩家。第三个是一个用于存储自上次发射子弹以来经过时间的变量。这将与射击频率一起决定飞船何时可以再次射击。
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last two variables will hold a reference to the bullet prefab that will
    be fired and the point from which the bullet will be released. This is similar
    to how we made the enemy tanks shoot in the previous chapter. The difference is
    that space games tend to have a lot of laser blasts flying around that force the
    player to dodge.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个变量将保存要发射的子弹预制体和子弹发射点的引用。这与我们在上一章中制作敌坦克射击的方式类似。区别在于太空游戏往往有很多激光束在飞行，迫使玩家躲避。
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `Update` function, we will do the work of actually shooting. It starts
    by tracking how long it has been since a bullet was last fired. Then we check
    to see if it has been long enough since the last firing in order to fire again,
    and exit the function if it is not. The third line of code in the function checks
    the range. This is done in exactly the same way as we checked to see if the asteroids
    moved too far away from the player. Next, we check to make sure the ship is pointed
    at the player. This is done in the same way as we did when the enemy tanks were
    to shoot at the player. A comparison of the forward direction is done with the
    direction to the player to check the angle. If it is pointing close enough at
    the player, the ship can start shooting. The shooting is done with a call to the
    `Instantiate` function. By passing it the `muzzlePoint` variable's position and
    rotation, the new bullet is automatically rotated. A separate script will be handling
    the movement of the bullet. Finally, the time since the ship last fired is reset
    to zero.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`函数中，我们将执行实际射击的工作。它首先跟踪自上次发射子弹以来经过的时间。然后检查是否已经足够长的时间以来可以再次射击，如果不是，则退出函数。函数中的第三行代码检查范围。这完全是以我们检查小行星是否远离玩家的方式进行的。接下来，我们检查确保飞船指向玩家。这是以我们使敌舰坦克射击玩家的相同方式进行。通过比较前进方向与指向玩家的方向来检查角度。如果它足够接近地指向玩家，飞船就可以开始射击。射击是通过调用`Instantiate`函数来完成的。通过传递`muzzlePoint`变量的位置和旋转，新的子弹会自动旋转。将有一个单独的脚本处理子弹的运动。最后，将飞船上次射击的时间重置为零。
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The next function is the `LateUpdate` function. We are going to use this function
    just as we did for the asteroid. The first line of code just calls out to the
    `PlayerShip` script to have the ship rotated and moved to fake the player's movement.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数是`LateUpdate`函数。我们将像对小行星那样使用这个函数。代码的第一行只是调用`PlayerShip`脚本以旋转和移动飞船，以模拟玩家的移动。
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next line of code applies movement to the ship. The process is similar to
    how we made the enemy turrets rotate to face the player in the previous chapter.
    The `step` variable is used to dictate how fast the ship turns towards the player.
    We use the `Slerp` function to change the ship's current rotation towards the
    target rotation. In this case, the rotation is the one that looks at the player.
    Lastly, the ship is moved forward. Altogether, this results in movements similar
    to how a car turns.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码应用于飞船的运动。这个过程与我们如何在上一章中使敌舰炮塔旋转面对玩家相似。`step`变量用于指定飞船转向玩家的速度。我们使用`Slerp`函数改变飞船当前旋转以指向目标旋转。在这种情况下，旋转是朝向玩家的旋转。最后，飞船向前移动。总的来说，这会产生类似于汽车转向的运动。
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The last code snippet for the function and the script is the check to see if
    the ship is too far away. It is exactly the same as the one used by the asteroid.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数和脚本的最后一个代码片段是检查飞船是否太远的检查。它与用于小行星的检查完全相同。
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Before we can put our enemy ship together, we need to make one more short script.
    Create a new script and name it `Bullet`. As you might guess, this is the script
    that will control the movement of the enemy bullets.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以组装我们的敌舰之前，我们需要编写一个更短的脚本。创建一个新的脚本并将其命名为`Bullet`。正如你可能猜到的，这是控制敌舰子弹运动的脚本。
- en: This script starts with a single variable, that is, how fast the bullet will
    move through space.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本从单个变量开始，即子弹在空间中移动的速度。
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we make use of the `LateUpdate` function again. This function first uses
    `PlayerShip.Rotate` to reposition the bullet, just as with all the other objects
    in the game world. It then moves forward with speed. Last, it does the check for
    being out of range.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用`LateUpdate`函数。这个函数首先使用`PlayerShip.Rotate`重新定位子弹，就像在游戏世界中所有其他对象一样。然后它以速度前进。最后，它检查是否超出范围。
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last function for the script, `OnTriggerEnter`, works just like the one
    for the asteroid. If the bullet makes contact with a ship, it will destroy itself.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本中的最后一个函数`OnTriggerEnter`与用于小行星的函数一样。如果子弹与飞船接触，它将自我销毁。
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we have our scripts, the next step is to create the enemy ship and
    bullet prefabs. To create the bullet, start by navigating to **GameObject** |
    **Create Other** | **Sphere**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了脚本，下一步是创建敌舰和子弹预制体。要创建子弹，首先导航到**GameObject** | **Create Other** | **Sphere**。
- en: Rename the new sphere to `Bullet` and scale it to about half of its original
    size.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新球体重命名为`Bullet`并将其缩放至原始大小的一半。
- en: Next, add the `Bullet` script to the object and be sure to check the **Is Trigger**
    checkbox in its **SphereCollider** component. Without that box checked, the bullet
    won't work properly.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Bullet`脚本添加到对象中，并确保在它的**SphereCollider**组件中勾选**Is Trigger**复选框。如果没有勾选该框，子弹将无法正常工作。
- en: Finally, drag the object to the `Prefabs` folder to turn it into a prefab.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将对象拖动到`Prefabs`文件夹以将其转换为预制体。
- en: Next, we need to make the enemy ship. Start by creating an empty **GameObject**
    and renaming it to `EnemyShipPivot`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建敌对飞船。首先创建一个空的**GameObject**并将其重命名为`EnemyShipPivot`。
- en: Add a copy of the `EnemyShip` model to the scene and make it a child of the
    pivot point we just created. Be sure to rotate it to face forward along the z
    axis, and position it to be centered on the pivot point.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`EnemyShip`模型的副本添加到场景中，并使其成为我们刚刚创建的枢轴点的子项。确保将其旋转以沿着z轴面向前方，并将其定位在枢轴点的中心。
- en: Next, use simple colliders and empty **GameObject** to create a collision shape
    for the ship. This is exactly like what we did for the player's ship. Be sure
    to make all of the colliders children of the enemy ship's pivot point.![Time for
    action – adding an enemy ship](img/2014OT_06_05.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用简单的碰撞体和空的**GameObject**为飞船创建一个碰撞形状。这与我们为玩家飞船所做的是一样的。确保将所有碰撞体作为敌对飞船的枢轴点的子项。
- en: We need to create a muzzle point and position it in front of the enemy ship.
    Do it just as we did for the tanks. Be sure to also make it a child of the ship's
    pivot point.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个炮口点并将其放置在敌对飞船的前面。就像我们为坦克所做的那样做。确保也将其作为船的枢轴点的子项。
- en: Now, add the `EnemyShip` script and a **Rigidbody** component to the pivot point.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`EnemyShip`脚本和一个**Rigidbody**组件添加到枢轴点。
- en: Almost done. Drag the muzzle point from the **Hierarchy** window and drop it
    on the appropriate slot in the script component in the **Inspector**. Also, drag-and-drop
    the **Bullet** prefab from the **Project** window to the waiting slot.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几乎完成了。从**Hierarchy**窗口拖动炮口点并将其放置在**Inspector**中脚本组件的适当槽位。同时，从**Project**窗口拖动**Bullet**预制体到等待槽位。
- en: Finally, make the ship into a prefab by dragging it from the **Hierarchy** window
    to the `Prefabs` folder.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将飞船拖动到**Hierarchy**窗口并将其放入`Prefabs`文件夹，使其成为一个预制体。
- en: Add a couple of extra ships to the scene and try it out.![Time for action –
    adding an enemy ship](img/2014OT_06_06.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加几艘额外的飞船并尝试一下。![行动时间 – 添加敌对飞船](img/2014OT_06_06.jpg)
- en: '*What just happened?*'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created an enemy space ship. The ships will fly after the player and begin
    shooting when within range. Like the asteroids, they move around the player to
    fake the player's movement. However, instead of moving in a random direction,
    the enemy ships turn towards the player. By slowing down how fast the ships can
    turn, they move in arcs rather than pivoting quickly in place. Also, because of
    the **Rigidbody** component attached to the enemy ships, they can collide with
    the asteroids that are in the scene.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一艘敌对飞船。飞船将在玩家之后飞行，并在进入射程时开始射击。就像小行星一样，它们围绕着玩家移动以模拟玩家的移动。然而，与随机方向移动不同，敌对飞船会转向玩家。通过减缓飞船转向的速度，它们以弧形移动而不是快速原地旋转。此外，由于敌对飞船附带的**Rigidbody**组件，它们可以与场景中的小行星相撞。
- en: Have a go hero – skybox and fog
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼——天空盒和雾
- en: Now that we have several objects flying around in space, it is a good idea to
    make the scene look a little better. For our Tank Battle game, we added a skybox
    to make the scene look like it is actually on a planet. However, we are flying
    around in space. The challenge is for you to find or make a skybox that looks
    like outer space. Also, adding some distant fog will obscure objects as they move
    too far away from the player. If the fog is black, it will look like the objects
    are swallowed by the blackness of deep space.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有几个物体在太空中飞行，让场景看起来更好是个不错的主意。对于我们的坦克大战游戏，我们添加了一个天空盒，使场景看起来就像真的在一个星球上。然而，我们正在太空中飞行。挑战在于你找到或制作一个看起来像外太空的天空盒。此外，添加一些远处的雾气会在物体远离玩家时使其变得模糊。如果雾气是黑色的，它将看起来像物体被深空的黑暗吞噬。
- en: Controlling with touch
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸控制
- en: Now that we have several objects flying around in our space scene, including
    some that will shoot at the player, we should give the player the ability to do
    more than just dodge. One of the most obvious features of the modern mobile device
    is the touch screen. The devices use the electrical conductivity of the user's
    finger and many tiny contact points to determine the location that is being touched.
    Unity provides us with easy access to the touch inputs. By combining the input
    with ray casts, as we did for making the tanks fire, we can determine which object
    in the 3D space was touched by the user. For us, this means we can give the player
    the ability to shoot at and destroy the objects in space.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的空间场景中有几个物体在飞行，包括一些会射击玩家的物体，我们应该给玩家提供除了躲避之外的能力。现代移动设备最明显的特征之一就是触摸屏。这些设备使用用户的指尖的电导性和许多微小的接触点来确定被触摸的位置。Unity为我们提供了访问触摸输入的便捷方式。通过将输入与射线投射相结合，就像我们为坦克射击所做的那样，我们可以确定用户在3D空间中触摸了哪个物体。对我们来说，这意味着我们可以给玩家提供射击并摧毁空间中物体的能力。
- en: Time for action – touch to shoot
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 触摸射击
- en: 'For making use of the touch inputs, we will need to add a single script to
    our player''s ship:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用触摸输入，我们需要在我们的玩家的飞船上添加一个单独的脚本：
- en: To give the player the ability to shoot, we need to first create a new script
    and call it `TouchShoot`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给玩家提供射击的能力，我们首先需要创建一个新的脚本，并将其命名为`TouchShoot`。
- en: This script begins with a single variable. A `LayerMask` is used to selectively
    hit objects with a raycast. There are essentially a lot of layers that should
    be hit. This one will be used to determine what the player can or cannot shoot.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从单个变量开始。一个`LayerMask`用于选择性地用射线投射击中物体。实际上有很多层应该被击中。这个将用来确定玩家可以或不可以射击。
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Update` function is the only function in this script. It starts with a
    loop. The `Input` class provides us with the `touchCount` value, which is simply
    a counter for how many fingers are currently touching the device screen.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update`函数是这个脚本中唯一的函数。它从一个循环开始。`Input`类为我们提供了`touchCount`值，它只是一个计数器，用于计算当前有多少手指正在触摸设备屏幕。'
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we progress through the loop, we use the `Input.GetTouch` function to access
    information about each touch. This line of code checks the phase of the touch.
    Every touch has five potential phases: **Began**, **Moved**, **Stationary**, **Ended**,
    and **Cancelled**:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们通过循环，我们使用`Input.GetTouch`函数来访问有关每个触摸的信息。这一行代码检查触摸的阶段。每个触摸有五个潜在的阶段：**开始**、**移动**、**静止**、**结束**和**取消**：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Began**: This phase of touch is when the user first touches the screen.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**：这个触摸阶段是当用户第一次触摸屏幕时。'
- en: '**Moved**: This phase of touch is when the user moves his/her finger across
    the screen.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**：这个触摸阶段是当用户在屏幕上移动他的/她的手指时。'
- en: '**Stationary**: This phase of touch is the opposite of the previous phase;
    it is when the finger is not moving across the screen.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静止**：这个触摸阶段是前一个阶段的相反；这是手指没有在屏幕上移动的时候。'
- en: '**Ended**: This phase of touch is when the finger is lifted off the screen.
    This is the normal way for a touch to complete.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束**：这个触摸阶段是指手指从屏幕上抬起。这是触摸完成的正常方式。'
- en: '**Cancelled**: This phase of touch is when an error occurs while tracking the
    touch. This phase tends to occur most often when a finger is touching the screen,
    but not moving for too long. The touch system is not perfect, so it assumes it
    missed the finger being lifted off the screen and just cancels it.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消**：这个触摸阶段是在跟踪触摸时发生错误时。这个阶段通常发生在手指触摸屏幕但长时间不移动的情况下。触摸系统并不完美，所以它假设它错过了手指从屏幕上抬起，并取消了这个触摸。'
- en: Next, we create a pair of variables. The first is a `Ray`, which is just a container
    for storing a point in space and a directional vector. The `ScreenPointToRay`
    function is specially provided by the camera for converting touch positions from
    the 2D space of the screen to the 3D space of the game world. As with our tanks,
    the second is a holder for what was hit by our raycast.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一对变量。第一个是一个`Ray`，它只是一个用于存储空间中的一个点和方向向量的容器。`ScreenPointToRay`函数是相机专门提供的，用于将触摸位置从屏幕的2D空间转换为游戏世界的3D空间。就像我们的坦克一样，第二个是一个用于存储我们的射线投射所击中的物体的容器。
- en: '[PRE32]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The last step for the function is to call the `Raycast` function. We pass the
    ray, and the tracking variable to the function. Next, we have to give it a distance,
    and finally the `LayerMask`. If an object is hit, it is destroyed. Also, there
    are several curly braces required to close off the if statements, loop, and function.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的最后一步是调用`Raycast`函数。我们将射线和跟踪变量传递给函数。接下来，我们必须给它一个距离，最后是`LayerMask`。如果击中对象，它将被摧毁。此外，还需要几个花括号来关闭if语句、循环和函数。
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To try the script out, simply add it to the **PlayerShipPivot** GameObject.
    Be careful. At this point, if you were to touch the player's ship while testing,
    it would be destroyed.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要尝试脚本，只需将其添加到**PlayerShipPivot**游戏对象中。小心。在此阶段，如果你在测试时触摸玩家的船，它将被摧毁。
- en: In order to fix this issue, we need to create a new layer. Start by going to
    the menu bar of Unity and clicking on **Edit** | **Project Settings** | **Tags**.
    This is just a second path to the same location where we created layers for the
    Tank Battle game.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要创建一个新的层。首先，转到Unity的菜单栏，点击**编辑** | **项目设置** | **标签**。这是到达我们为坦克大战游戏创建层的同一位置的另一条路径。
- en: Click on the right of **User Layer 8** and input `Player` in the field. This
    will create the new layer.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**用户层8**的右侧，并在字段中输入`Player`。这将创建新的层。
- en: Select the **PlayerShipPivot** object in the **Hierarchy** window.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**PlayerShipPivot**对象。
- en: In the top-right corner of the **Inspector** window, select the layer we just
    created from the **Layers** drop-down list.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的右上角，从**层**下拉列表中选择我们刚刚创建的层。
- en: When Unity asks whether you want to change the children objects as well, confirm
    that you do.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Unity询问你是否要更改子对象时，确认你要这样做。
- en: For the `TouchShoot` script, deselect the new layer from the **Touch Mask**
    list. This will allow the player to shoot everything but themselves.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`TouchShoot`脚本，从**触摸掩码**列表中取消选择新的层。这将允许玩家射击除自己之外的一切。
- en: There is one last thing we need to do. Go to the menu bar of Unity and click
    on **Edit** | **Project Settings** | **Physics**. This opens a new set of controls
    in the **Inspector** window that adjust how the Physics engine runs.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要做最后一件事。转到Unity的菜单栏，点击**编辑** | **项目设置** | **物理**。这将在**检查器**窗口中打开一组新的控件，用于调整物理引擎的运行方式。
- en: At the moment, we only care about the **Raycasts Hit Triggers** checkbox. Uncheck
    it. If we don't, the players will hit the trigger volume that is around the asteroid
    when they shoot, rather than the asteroid itself. It is not so great an issue
    for the asteroids. But, if we were to create something, such as an explosive mine,
    the trigger volume would be much larger. That would make it very odd-looking for
    shooting at the mine.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们只关心**Raycasts Hit Triggers**复选框。取消选中它。如果不这样做，当玩家射击时，他们会击中围绕小行星的触发体积，而不是小行星本身。这对小行星来说不是一个大问题。但是，如果我们要创建某种东西，比如一个爆炸性地雷，触发体积会大得多。这将使射击地雷看起来非常奇怪。
- en: '*What just happened?*'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We gave the player the ability to shoot when they touch the screen. By looping
    through the list of touches, the player is able to use more than one finger for
    shooting at targets. The special `ScreenPointToRay` function provided by the camera
    allows us to change 2D screen touches into 3D game world interactions. By making
    use of the `LayerMask`, we also prevent the player from shooting and destroying
    themselves.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给了玩家在触摸屏幕时射击的能力。通过遍历触摸列表，玩家可以使用多个手指射击目标。相机提供的特殊`ScreenPointToRay`函数使我们能够将2D屏幕触摸转换为3D游戏世界交互。通过使用`LayerMask`，我们还防止玩家射击并摧毁自己。
- en: Have a go hero – healthy ships
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 健康的船只
- en: The challenge here is to give the enemy ships some health. When we created the
    enemy tanks in the previous chapter, we caused them to take a few shots from the
    player before they would be destroyed. Do the same thing here for the enemy ships.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战是给敌舰一些健康值。在我们上一章创建敌坦克时，我们让它们在被摧毁之前承受玩家的几发射击。在这里对敌舰做同样的事情。
- en: Spawning in space
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间生成
- en: So far, we have created a space game that allows the player to fly infinitely
    through space. The player never actually moves; instead, the objects in the scene
    move around it to fake the movement. We have asteroids that will fly in a random
    direction through space. We also created enemy spaceships that fly after the player
    and shoot at them. Finally, we have the ability to shoot at and destroy the objects
    in the scene. However, at this point we can quickly run out of things to shoot
    at. Either they get too far away, or we destroy them. To fix this, we will now
    create a system that will randomly spawn all that we have created around the player.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个允许玩家无限穿越空间的空间游戏。玩家实际上从未移动过；相反，场景中的对象围绕它移动，以模拟移动。我们有会随机在空间中飞行的陨石。我们还创建了追逐玩家并射击它们的敌舰。最后，我们有了射击并摧毁场景中对象的能力。然而，在这个阶段，我们很快就会用完可以射击的东西。要么它们离得太远，要么我们摧毁了它们。为了解决这个问题，我们现在将创建一个系统，它将在玩家周围随机生成所有这些对象。
- en: Time for action – creating a space spawn
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建一个空间生成器
- en: 'Our last script will populate our space and will be attached to the player''s
    ship, since it is the center of the game world:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的脚本将填充我们的空间，并将附加到玩家的飞船上，因为它是游戏世界的中心：
- en: To fill our space with the objects, we need to create another script. Name it
    `SpaceSpawn`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了用对象填充我们的空间，我们需要创建另一个脚本。将其命名为 `SpaceSpawn`。
- en: We start it out with two variables. These two define the space within which
    the new objects will be spawned. They will be created outside the minimum range
    but within the maximum range.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始时有两个变量。这两个变量定义了新对象将被生成的空间。它们将在最小范围之外但最大范围之内创建。
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, we have two variables for controlling the frequency at which objects should
    be spawned. These will work the same as the ones we used for making the enemy
    ships shoot at the player.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有两个变量用于控制对象生成的频率。这些将与我们用于使敌舰向玩家射击的变量一样工作。
- en: '[PRE35]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The final variable for this script, is an array. It is simply a list of all
    of the objects that can be spawned. We will be filling it in a little bit, when
    we return to Unity to set it up.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本的最后一个是数组。它只是一个可以生成的所有对象的列表。当我们返回 Unity 来设置它时，我们将稍后填充它。
- en: '[PRE36]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Update` is once again our function of choice for the script. We start it off
    by making sure that there is something in the list to be spawned. If there are
    no objects to be spawned, there is no point in continuing.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update` 再次成为我们脚本的首选函数。我们首先确保列表中有要生成的东西。如果没有要生成的对象，就没有继续的必要。'
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we track how long it has been since the last spawn and check to see if
    it has been long enough to spawn once more. Again, this works just like the shooting
    of the enemy ships.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们追踪自上次生成以来经过的时间，并检查是否已经足够长，可以再次生成。同样，这就像射击敌舰一样工作。
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we need to figure out where to spawn the next object in space. To do this,
    we first use `Random.onUnitSphere` to find a random direction. Next, we find a
    random distance that lies within our min and max ranges. Finally, they are multiplied
    together to give us a position.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要确定在空间中生成下一个对象的位置。为此，我们首先使用 `Random.onUnitSphere` 来找到一个随机方向。然后，我们找到一个位于我们的最小和最大范围之间的随机距离。最后，它们被相乘，给我们一个位置。
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To pick a random object, we use `Random.Range` and pass the length of the list
    of objects to it. This will give us the index of one of the slots of the list.
    The following line of code makes sure that there is an object in the slot. If
    there isn't, we cannot spawn it.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了选择一个随机对象，我们使用 `Random.Range` 并将其传递给对象的列表长度。这将给我们列表中的一个槽位的索引。下一行代码确保槽位中有对象。如果没有，我们无法生成它。
- en: '[PRE40]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, we actually spawn the object using our good friend, the `Instantiate`
    function. We pass the object we randomly selected, the position we found, and
    finally, a random rotation to the `Instantiate` function. As a result, the object
    is created in the scene and set into place.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实际上使用我们的好朋友 `Instantiate` 函数来生成对象。我们将随机选择的对象、找到的位置以及最终的随机旋转传递给 `Instantiate`
    函数。结果，对象在场景中被创建并放置到位。
- en: '[PRE41]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, we subtract the `frequency` variable from our time tracker to finish
    off the function and the script. This will cause a spawn to occur on every frequency
    tick without losing any time.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从时间跟踪器中减去 `frequency` 变量，以完成函数和脚本的编写。这将导致在每次频率滴答时发生生成，而不会丢失任何时间。
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We now return to Unity to set up the script. Add it to the `PlayerShipPivot`
    object. It will work as well here as anywhere else.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在回到Unity中设置脚本。将其添加到`PlayerShipPivot`对象中。它在这里和其他任何地方一样都能正常工作。
- en: To fill the list, just drag your prefabs from the **Project** window and drop
    them on **Spawn List** in the **Inspector** window. The little triangle to the
    left of the field will let you expand the list and see what is currently in it.
    If you want to adjust the chances of the various objects appearing, just change
    how many of them are in the list. There is nothing keeping you from putting nine
    references to the asteroid prefab into the list and a single reference to the
    enemy ship prefab, to give the ship a one in 10 chance of being spawned. Whatever
    you choose, use the list to set the object chances and include at least one of
    each obstacle we have created.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要填充列表，只需从**项目**窗口拖动你的预制体，并将其拖放到**检查器**窗口中的**Spawn List**上。字段左侧的小三角形将允许你展开列表并查看其中当前的内容。如果你想调整各种对象出现的概率，只需更改列表中它们的出现次数。没有任何东西阻止你将九个关于小行星预制体的引用放入列表中，而只有一个关于敌方飞船预制体的引用，这样飞船就有10%的概率被生成。无论你选择什么，都要使用列表来设置对象概率，并至少包含我们创建的每个障碍物。
- en: Finally, test it out. Hit play and fly around to see the objects spawn and fly
    around.![Time for action – creating a space spawn](img/2014OT_06_07.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试一下。按播放并飞来飞去，看看对象是如何生成并飞来飞去的。![行动时间 - 创建空间生成](img/2014OT_06_07.jpg)
- en: '*What just happened?*'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a system for spawning objects randomly in space. First, we tracked
    time in the same way as we did for making the enemy ships shoot at the player.
    Next, we found a random direction and the range with which we determined a position.
    After that, the system selects a random object from the list and finally spawns
    it. In order to adjust the chances of any single object appearing, we just adjust
    how often it appears in the list of objects to be spawned, relative to the other
    objects in the list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个系统，用于在太空中随机生成对象。首先，我们跟踪时间的方式与制作敌方飞船向玩家开火的方式相同。接下来，我们找到了一个随机方向和范围，以确定位置。之后，系统从列表中随机选择一个对象，并最终生成它。为了调整单个对象出现的概率，我们只需调整它在要生成的对象列表中出现的频率，相对于列表中的其他对象。
- en: Have a go hero – more to spawn and shoot
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 - 更多生成和射击
- en: Included in the starting assets for this chapter are two more asteroid meshes
    and a mine. Using these, you can create more objects to be spawned in the game.
    The mine can also be created with a much larger trigger volume. This would allow
    it to explode when ships get close, not just hit it. If you were additionally
    inclined, you could at least make the asteroids randomly pick a scale when they
    are spawned. This would give the appearance of even greater variety in the asteroids,
    even though there are only a few.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始资产中还包括了两个更多的小行星网格和一个矿。使用这些，你可以创建更多要在游戏中生成的对象。矿也可以创建一个更大的触发体积。这将允许它在船只靠近时爆炸，而不仅仅是撞击它。如果你还有其他想法，至少可以让小行星在生成时随机选择一个比例。这将使小行星看起来更加多样化，尽管实际上只有几个。
- en: Also, try creating another ship or several other ships. Perhaps one is a transport
    ship and it flees from the player. A hard one would be a ship that splits into
    two smaller ships when destroyed. Or, just recreate your favorite space ships
    from your favorite sci-fi media. In this game, the universe is the limit.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尝试创建另一艘或几艘船。也许其中一艘是运输船，它会逃离玩家。一个难度较高的例子是，当被摧毁时，船会分裂成两艘更小的船。或者，只需重新创建你最喜欢的科幻媒体中的宇宙飞船。在这个游戏中，宇宙是你的极限。
- en: For the Tank Battle game, we created a turbo boost button for getting the player
    across the city quickly. It is also useful for fleeing enemies. Implement it for
    the space fighter. It would be useful for catching enemies and dodging bullets.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于坦克战游戏，我们为玩家快速穿越城市创建了一个涡轮增压按钮。它对于逃离敌人也很有用。为太空战斗机实现它。这将有助于捕捉敌人和躲避子弹。
- en: Pop Quiz – understanding Android components
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 - 理解Android组件
- en: Modern mobile devices have many parts that perform a huge variety of functions.
    Knowing what they are and how they work together is the first step towards being
    able to use them. Are the following statements true or false?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现代移动设备有许多部分，它们执行着各种各样的功能。了解它们是什么以及它们是如何协同工作的，是能够使用它们的第一步。以下陈述是真的还是假的？
- en: Q1\. The magnometer and accelerometer work together to give position on a map.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 磁力计和加速度计协同工作，在地图上给出位置。
- en: 'True'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: Q2\. The gyroscope detects rotation and movement of the device.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 陀螺仪检测设备的旋转和移动。
- en: 'True'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: Q3\. 2D positions on the touch screen can be translated into 3D positions in
    the game.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 触摸屏上的2D位置可以转换成游戏中的3D位置。
- en: 'True'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: Q4\. What line of code will allow us to translate the user's touch to a 3D position
    in the game?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 哪一行代码能够将用户的触摸转换成游戏中的3D位置？
- en: '`Camera.main.ScreenPointToRay(Input.GetTouch(0).position)`'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Camera.main.ScreenPointToRay(Input.GetTouch(0).position)`'
- en: '`Input.GetMouseButton(0)`'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.GetMouseButton(0)`'
- en: '`Camera.main.WorldToScreenPoint(Input.GetTouch(0).position)`'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Camera.main.WorldToScreenPoint(Input.GetTouch(0).position)`'
- en: Q5\. What line of code will give us the device's acceleration?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Q5. 哪一行代码能够给出设备的加速度？
- en: '`Input.gyro`'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.gyro`'
- en: '`Input.compass`'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.compass`'
- en: '`Input.acceleration`'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.acceleration`'
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the specialties of the modern mobile device.
    We created a Space Fighter game to try it out. We gained access to the device's
    accelerometer to detect when it is rotated. This gave our spaceship the ability
    to be steered. We also made use of the touch screen to give a player the ability
    to shoot enemies in the game. Because we wanted an infinite amount of space to
    fly through, we had to make it all without the player moving. Instead, everything
    else moves around the player, faking the player's movement. It also required a
    system that continuously spawned new enemies and obstacles around the player,
    allowing us to keep flying and finding new things to play with.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了现代移动设备的特性。我们创建了一个太空战斗机游戏来尝试这些特性。我们获得了访问设备的加速度计，以检测设备何时旋转。这使得我们的宇宙飞船能够被操控。我们还利用触摸屏，让玩家能够在游戏中射击敌人。因为我们想要无限的空间来飞行，所以我们不得不让玩家不动，而是让其他所有东西围绕玩家移动，以模拟玩家的移动。这也需要一个系统，能够持续在玩家周围生成新的敌人和障碍物，让我们能够继续飞行并找到新的东西来玩耍。
- en: In the next chapter, we will be taking a short break from our Space Fighter
    game. Almost certainly the most popular mobile game on the market, Angry Birds
    is a distinct and not uncommon type of game. In order to learn about Physics in
    Unity and the possibility of a 2D-style game, we will be making an Angry Birds
    clone. We will also take a look at Parallax scrolling to create a pleasing background.
    Before you know it, we will be creating all of the Angry Birds levels that you
    always wished you could play.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时从太空战斗机游戏中休息一下。几乎可以肯定，市场上最受欢迎的移动游戏之一，愤怒的小鸟，是一种独特且不常见的游戏类型。为了学习Unity中的物理和2D风格游戏的可能性，我们将制作一个愤怒的小鸟克隆版。我们还将研究视差滚动来创建令人愉悦的背景。很快，我们将创建所有你一直希望能够玩到的愤怒的小鸟关卡。
