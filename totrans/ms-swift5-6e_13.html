<html><head></head><body>
  <div id="_idContainer080">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-227" class="chapterTitle">Custom Subscripting</h1>
    <p class="normal">Custom subscripts were added to Objective-C in 2012. At that time, Chris Lattner was already two years into developing Swift and, like other good features, subscripts were added to the Swift language. I have not used custom subscripts in many other languages; however, I do find myself using subscripts extensively when I am developing in Swift. The syntax for using subscripts seems like a natural part of the language, possibly because they were part of the language when it was released and not added in later. Once you start using them, you may find them indispensable.</p>
    <p class="normal">In this chapter, we will cover the following topics: </p>
    <ul>
      <li class="bullet">What are custom subscripts?</li>
      <li class="bullet">Adding custom subscripts to classes, structures, or enumerations </li>
      <li class="bullet">Creating read/write and read-only subscripts</li>
      <li class="bullet">Using external names without custom subscripts </li>
      <li class="bullet">Using multidimensional subscripts</li>
    </ul>
    <h1 id="_idParaDest-228" class="title">Introducing subscripts</h1>
    <p class="normal">Subscripts, in the Swift language, are used as shortcuts for accessing elements of a collection, list, or sequence. We can use them in our custom types to set or retrieve the values by <a id="_idIndexMarker538"/>index rather than by using getter and setter methods. Subscripts, if used correctly, can significantly enhance the usability and readability of our custom types.</p>
    <p class="normal">We can define multiple subscripts for a single type. When types have multiple subscripts, the appropriate subscript will be chosen based on the type of index passed in with the subscript. We can also set external parameter names for our subscripts that can help distinguish between subscripts that have the same types.</p>
    <p class="normal">We use custom subscripts just like we use subscripts for arrays and dictionaries. For example, to access an element in an array, we use the <code class="Code-In-Text--PACKT-">Array[index]</code> syntax. When we define a custom subscript for our custom types, we also access them with the same <code class="Code-In-Text--PACKT-">ourType[key]</code> syntax.</p>
    <p class="normal">When creating custom subscripts, we should try to make them feel like a natural part of the class, structure, or enumeration. As mentioned previously, subscripts can significantly enhance the usability and readability of our code, but if we try to overuse them, they will not <a id="_idIndexMarker539"/>feel natural and will be hard to use and understand.</p>
    <p class="normal">In this chapter, we will look at several examples of how we can create and use custom subscripts. However, before we see how to use custom subscripts, let's review how subscripts are used with Swift arrays to understand how subscripts are used within the Swift language itself. We should use subscripts in a similar manner to how Apple uses them within the language to make our custom subscripts easy to understand and use.</p>
    <h1 id="_idParaDest-229" class="title">Subscripts with Swift arrays</h1>
    <p class="normal">The following <a id="_idIndexMarker540"/>example shows how to use subscripts to access <a id="_idIndexMarker541"/>and change the values of an array:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> arrayOne = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
<span class="hljs-built_i">print</span>(arrayOne[<span class="hljs-number">3</span>])  <span class="hljs-comment">//Displays '4'</span>
arrayOne[<span class="hljs-number">3</span>] = <span class="hljs-number">10</span>
<span class="hljs-built_i">print</span>(arrayOne[<span class="hljs-number">3</span>])  <span class="hljs-comment">//Displays '10'</span>
</code></pre>
    <p class="normal">In the preceding example, we create an array of integers and then use the subscript syntax to display and change the element at index three. Subscripts are mainly used to set or retrieve information from a collection. We generally do not use subscripts when specific logic needs to be applied to determine which item to select. As an example, we would not want to use subscripts to append an item to the end of the array or to retrieve the number of items in the array. To append an item to the end of an array, or to get the number of items in an array, we use functions or properties, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">arrayOne.append(<span class="hljs-number">7</span>)  <span class="hljs-comment">//append 7 to the end of the array</span>
arrayOne.<span class="hljs-built_i">count</span>  <span class="hljs-comment">//returns the number of items in an array</span>
</code></pre>
    <p class="normal">Subscripts in our custom types should follow the same standard set by the Swift language itself, so other developers that use our types are not confused by the implementation. The key to knowing when to use subscripts, and when not to, is to understand how they will be used.</p>
    <h2 id="_idParaDest-230" class="title">Creating and using custom subscripts</h2>
    <p class="normal">Let's look at how to define a subscript that is used to read and write to a backend array. Reading <a id="_idIndexMarker542"/>and writing to a backend storage class is one of the most common uses of custom subscripts. However, as we will see in this chapter, we do not need <a id="_idIndexMarker543"/>to have a backend storage class. The following code shows how to use a subscript to read and write to an array:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyNames</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> names = [<span class="hljs-string">"Jon"</span>, <span class="hljs-string">"Kailey"</span>, <span class="hljs-string">"Kara"</span>] 
    <span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> names[index]
        }
        <span class="hljs-keyword">set</span> {
            names[index] = newValue
        }
    }
}
</code></pre>
    <p class="normal">As we can see, the syntax for subscripts is similar to how we define properties within a class using the <code class="Code-In-Text--PACKT-">get</code> and <code class="Code-In-Text--PACKT-">set</code> keywords. The difference is that we declare the <code class="Code-In-Text--PACKT-">subscript</code> using the <code class="Code-In-Text--PACKT-">subscript</code> keyword. We then specify one or more inputs and the return type.</p>
    <p class="normal">We can now use the custom subscript just like we used subscripts with arrays and dictionaries. The following code shows how to use the subscript in the preceding example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> nam = <span class="hljs-type">MyNames</span>()
<span class="hljs-built_i">print</span>(nam[<span class="hljs-number">0</span>])  <span class="hljs-comment">//Displays 'Jon'</span>
nam[<span class="hljs-number">0</span>] = <span class="hljs-string">"Buddy"</span>
<span class="hljs-built_i">print</span>(nam[<span class="hljs-number">0</span>])  <span class="hljs-comment">//Displays 'Buddy'</span>
</code></pre>
    <p class="normal">In the preceding code, we create an instance of the <code class="Code-In-Text--PACKT-">MyNames</code> class and display the original name at index <code class="Code-In-Text--PACKT-">0</code>. We then change the name at index <code class="Code-In-Text--PACKT-">0</code> and redisplay it. In this example, we use the subscript that is defined in the <code class="Code-In-Text--PACKT-">MyNames</code> class to retrieve and set elements of the <code class="Code-In-Text--PACKT-">names</code> array within the class.</p>
    <p class="normal">While we could make the <code class="Code-In-Text--PACKT-">names</code> array available for external code to access directly, this would lock our code into using an array to store the data. In the future, if we wanted to change the backend storage mechanism to a dictionary object, or even an SQLite database, we would have a difficult time doing so because all of the external code would also have to be changed. Subscripts are very good at hiding how we store information within our custom types; therefore, external code that uses these custom types does not rely on specific storage implementations.</p>
    <p class="normal">If we gave <a id="_idIndexMarker544"/>direct access to the <code class="Code-In-Text--PACKT-">names</code> array, we would also be unable to verify that the external code was inserting valid information into the array. With subscripts, we can <a id="_idIndexMarker545"/>add validation to our setters to verify that the data being passed in is correct before adding it to the array. As an example, in the previous example, we could have added in a validation to verify that the names only contain alpha characters and certain special characters that are valid in names. This can be very useful when we are creating a framework or a library.</p>
    <h2 id="_idParaDest-231" class="title">Read-only custom subscripts</h2>
    <p class="normal">We can <a id="_idIndexMarker546"/>also make the subscript read-only by either not declaring a setter method within the subscript or by not implicitly declaring the getter and setter methods. The following code shows how to declare a read-only property by not declaring a getter or setter method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">//No getter/setters implicitly declared</span>
<span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-keyword">return</span> names[index]
}
</code></pre>
    <p class="normal">The following example shows how to declare a read-only property by only declaring a getter method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">//Declaring only a getter</span>
<span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-keyword">get</span> {
        <span class="hljs-keyword">return</span> names[index]
    }
}
</code></pre>
    <p class="normal">In the first example, we do not define either a getter or setter method; therefore, Swift sets the subscript as read-only, and the code acts as if it were in a getter definition. In the second example, we specifically set the code in a getter definition. Both examples are valid read-only subscripts. One thing to note is that write-only subscripts are not valid <a id="_idIndexMarker547"/>in Swift.</p>
    <h2 id="_idParaDest-232" class="title">Calculated subscripts</h2>
    <p class="normal">While the <a id="_idIndexMarker548"/>preceding example is very similar to using stored properties in a class or structure, we can also use subscripts in a similar manner to computed properties. Let's look at how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MathTable</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> num: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> { 
        <span class="hljs-keyword">return</span> num * index
    }
}
</code></pre>
    <p class="normal">In the preceding example, we used an array as the backend storage mechanism for the subscript. In this example, we use the value of the subscript to calculate the return value. We would use this subscript as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> table = <span class="hljs-type">MathTable</span>(num: <span class="hljs-number">5</span>)
<span class="hljs-built_i">print</span>(table[<span class="hljs-number">4</span>])
</code></pre>
    <p class="normal">This example displays the calculated value of <code class="Code-In-Text--PACKT-">5</code> (the number defined in the initialization) multiplied by <code class="Code-In-Text--PACKT-">4</code> (the subscript value), which is equal to 20.</p>
    <h2 id="_idParaDest-233" class="title">Subscript values</h2>
    <p class="normal">In the preceding subscript examples, all of the subscripts accepted integers as the value for the <a id="_idIndexMarker549"/>subscript; however, we are not limited to integers. In the following example, we will use a <code class="Code-In-Text--PACKT-">String</code> type as the value for the subscript. The <code class="Code-In-Text--PACKT-">subscript</code> keyword will also return a <code class="Code-In-Text--PACKT-">String</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Hello</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">subscript</span> (name: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> { 
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello \(name)"</span>
    }
}
</code></pre>
    <p class="normal">In this example, the subscript takes a string as the value within the subscript and returns a message saying <code class="Code-In-Text--PACKT-">Hello</code>. Let's look at how to use this subscript:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> greeting = <span class="hljs-type">Hello</span>["<span class="hljs-type">Jon</span>"]
</code></pre>
    <p class="normal">In the previous code, the <code class="Code-In-Text--PACKT-">greeting</code> constant would contain the string <code class="Code-In-Text--PACKT-">Hello Jon</code>.</p>
    <h2 id="_idParaDest-234" class="title">Static subscripts</h2>
    <p class="normal">Static subscripts were introduced in Swift 5.1 with SE-0254. This functionality enables us to use <a id="_idIndexMarker550"/>the subscript without having to create an instance of the type. Let's see how this works:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Hello</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">subscript</span> (name: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> { 
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello \(name)"</span>
    }
}
</code></pre>
    <p class="normal">In the previous code, we create a structure named <code class="Code-In-Text--PACKT-">Hello</code> and within this structure we define a <code class="Code-In-Text--PACKT-">subscript</code>. The thing to note is the <code class="Code-In-Text--PACKT-">static</code> keyword prior to the subscript declaration. We are now able to use this subscript as shown in the next line of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> greeting = <span class="hljs-type">Hello</span>["<span class="hljs-type">Jon</span>"]
</code></pre>
    <p class="normal">In the previous code, the <code class="Code-In-Text--PACKT-">greeting</code> constant would contain the string <code class="Code-In-Text--PACKT-">Hello Jon</code>. Note that we did not have to create an instance of the <code class="Code-In-Text--PACKT-">Hello</code> structure to use the subscript. </p>
    <h2 id="_idParaDest-235" class="title">External names for subscripts</h2>
    <p class="normal">As mentioned earlier in this chapter, we can have multiple subscript signatures for our custom types. The appropriate subscript will be chosen based on the type of index passed into <a id="_idIndexMarker551"/>the subscript. However, there are times when we may wish to define multiple subscripts that have the same type. For this, we could use external names in a similar way to how we define external names for the parameters of a function.</p>
    <p class="normal">Let's rewrite the original <code class="Code-In-Text--PACKT-">MathTable</code> structure to include two subscripts that each accept an integer as the subscript type. However, one will perform a multiplication operation, and the other will perform an addition operation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MathTable</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> num: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">subscript</span>(multiply index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> { 
        <span class="hljs-keyword">return</span> num * index
    }
    <span class="hljs-keyword">subscript</span>(add index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> { 
        <span class="hljs-keyword">return</span> num + index
    }
}
</code></pre>
    <p class="normal">As we can see, in this example we define two subscripts, and each subscript accepts an integer type. The difference between the two subscripts is the external name within the definition. In the first subscript, we define an external name, <code class="Code-In-Text--PACKT-">multiply</code>, because we multiply the value of the subscript by the <code class="Code-In-Text--PACKT-">num</code> property within this subscript. In the second <code class="Code-In-Text--PACKT-">subscript</code>, we define an external name, <code class="Code-In-Text--PACKT-">add</code>, because we add the value of the subscript to the <code class="Code-In-Text--PACKT-">num</code> property within the subscript.</p>
    <p class="normal">Let's look at how to use these two subscripts:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> table = <span class="hljs-type">MathTable</span>(num: <span class="hljs-number">5</span>)
<span class="hljs-built_i">print</span>(table[multiply: <span class="hljs-number">4</span>])  <span class="hljs-comment">//Displays 20 because 5*4=20</span>
<span class="hljs-built_i">print</span>(table[add: <span class="hljs-number">4</span>])  <span class="hljs-comment">//Displays 9 because 5+4=9</span>
</code></pre>
    <p class="normal">If we run <a id="_idIndexMarker552"/>this example, we will see that the correct subscript is used, based on the external name within the subscript.</p>
    <p class="normal">Using external names within our subscript is very useful if we need multiple subscripts of the same type. I would not recommend using external names unless they are needed to distinguish between multiple subscripts.</p>
    <h2 id="_idParaDest-236" class="title">Multidimensional subscripts</h2>
    <p class="normal">While the most common subscripts are those that take a single parameter, subscripts are not <a id="_idIndexMarker553"/>limited to single parameters. They can take any number of input parameters, and these parameters can be of any type.</p>
    <p class="normal">Let's look at how we could use a multidimensional subscript to implement a Tic-Tac-Toe board. A Tic-Tac-Toe board looks similar to the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B16683_13_01.png" alt="A picture containing clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 13.1: Empty Tic-Tac-Toe board</p>
    <p class="normal">The board can be represented by a two-dimensional array, where each dimension has three elements. The upper-left box of the board would be represented by the coordinates 0,0, while the lower-right box of the board would be represented by the coordinates 2,2. The middle box would have the coordinates 1,1. Each player will take turns placing their pieces (typically <code class="Code-In-Text--PACKT-">x</code> or <code class="Code-In-Text--PACKT-">o</code>) onto the board until one player has three pieces in a line or the board is full.</p>
    <p class="normal">Let's look <a id="_idIndexMarker554"/>at how we could implement a Tic-Tac-Toe board using a multidimensional array and multidimensional subscripts:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">TicTacToe</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> board = [[<span class="hljs-string">""</span>,<span class="hljs-string">""</span>,<span class="hljs-string">""</span>],[<span class="hljs-string">""</span>,<span class="hljs-string">""</span>,<span class="hljs-string">""</span>],[<span class="hljs-string">""</span>,<span class="hljs-string">""</span>,<span class="hljs-string">""</span>]]
    <span class="hljs-keyword">subscript</span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> { 
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> board[x][y]
        }
        <span class="hljs-keyword">set</span> {
            board[x][y] = newValue
        }
    }
}
</code></pre>
    <p class="normal">We start the <code class="Code-In-Text--PACKT-">TicTacToe</code> structure by defining a <code class="Code-In-Text--PACKT-">3×3</code> array, also known as a matrix, which will represent the game board. We then define a subscript that can be used to set and retrieve player pieces on the board. The subscript will accept two integer values. We define multiple parameters for our subscripts by putting the parameters between parentheses. In this example, we are defining the subscript with the parameters <code class="Code-In-Text--PACKT-">(x: Int, y: Int)</code>. We can then use the <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> variable names within our subscripts to access the values that are passed in.</p>
    <p class="normal">Let's look at how to use this subscript to set the user's pieces on the board:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> board = <span class="hljs-type">TicTacToe</span>()
board[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] = <span class="hljs-string">"x"</span>
board[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = <span class="hljs-string">"o"</span>
</code></pre>
    <p class="normal">If we run this code, we will see that we added the <code class="Code-In-Text--PACKT-">x</code> piece to the center square and the <code class="Code-In-Text--PACKT-">o</code> piece to the upper-left square, so our game board will look similar to the following:</p>
    <figure class="mediaobject"><img src="../Images/B16683_13_02.png" alt="A picture containing clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 13.2: Tic-Tac-Toe board with two player pieces</p>
    <p class="normal">We are not limited to using only one type for our multidimensional subscripts. For example, we could have a subscript of <code class="Code-In-Text--PACKT-">(x: Int, y: Double, z: String)</code>.</p>
    <p class="normal">We can also <a id="_idIndexMarker555"/>add external names for our multidimensional subscript types to help identify what values are used for and to distinguish between subscripts that have the same types. Let's take a look at how to use multiple types and external names with subscripts by creating a subscript that will return an array of string instances based on the values of the subscript:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">SayHello</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">subscript</span>(messageText message: <span class="hljs-type">String</span>, messageName name: <span class="hljs-type">String</span>, number: <span class="hljs-type">Int</span>) -&gt; [<span class="hljs-type">String</span>]{
        <span class="hljs-keyword">var</span> retArray: [<span class="hljs-type">String</span>] = []
        <span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;number {
            retArray.append(<span class="hljs-string">"\(message) \(name)"</span>)
        }
        <span class="hljs-keyword">return</span> retArray
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">SayHello</code> structure, we define our subscript as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">subscript</span>(messageText message: <span class="hljs-type">String</span>, messageName name: <span class="hljs-type">String</span>, number: <span class="hljs-type">Int</span>) -&gt; [<span class="hljs-type">String</span>]
</code></pre>
    <p class="normal">This defines a subscript with three elements. Each element has an external name (<code class="Code-In-Text--PACKT-">messageText</code>, <code class="Code-In-Text--PACKT-">messageName</code>, and <code class="Code-In-Text--PACKT-">number</code>) and an internal name (<code class="Code-In-Text--PACKT-">message</code>, <code class="Code-In-Text--PACKT-">name</code>, and <code class="Code-In-Text--PACKT-">number</code>). The first two elements are of the <code class="Code-In-Text--PACKT-">String</code> type and the last one is an <code class="Code-In-Text--PACKT-">Integer</code> type. We use the first two elements to create a message for the user that will repeat the number of times defined by the last (<code class="Code-In-Text--PACKT-">number</code>) element. We will use this subscript as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> message = <span class="hljs-type">SayHello</span>()
<span class="hljs-keyword">var</span> ret = message[messageText:<span class="hljs-string">"Bonjour"</span>, messageName:<span class="hljs-string">"Jon"</span>, number:<span class="hljs-number">5</span>]
</code></pre>
    <p class="normal">If we <a id="_idIndexMarker556"/>run this code, we will see that the <code class="Code-In-Text--PACKT-">ret</code> variable contains an array of five strings, where each string equals <code class="Code-In-Text--PACKT-">Bonjour Jon</code>. Now let's look at one of the most controversial new additions to the Swift language – dynamic member lookup.</p>
    <h1 id="_idParaDest-237" class="title">Dynamic member lookup</h1>
    <p class="normal">Dynamic member lookup enables a call to a property that will be dynamically resolved at runtime. This <a id="_idIndexMarker557"/>may not make a lot of sense without seeing an example, so let's look at one. Let's say that we had a structure that represented a baseball team. This structure has a property that represents the city the team was from and another property that represents the nickname of the team. The following code shows this structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">BaseballTeam</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">let</span> city: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> nickName: <span class="hljs-type">String</span>
}
</code></pre>
    <p class="normal">In this structure, if we wanted to retrieve the full name of the baseball team, including the <code class="Code-In-Text--PACKT-">city</code> and <code class="Code-In-Text--PACKT-">nickname</code>, we could easily create a method as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">fullname</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">String</span> { 
    <span class="hljs-keyword">return</span> <span class="hljs-string">"\(city) \(nickName)"</span>
}
</code></pre>
    <p class="normal">This is how you would do it in most object-oriented programming languages. However, in our code, which uses the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure, we would retrieve the city and nickname as properties with the dot notation and the full name as a method. The following code shows how we would use both the <code class="Code-In-Text--PACKT-">city</code> property and the <code class="Code-In-Text--PACKT-">fullname</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> redsox = <span class="hljs-type">BaseballTeam</span>(city: <span class="hljs-string">"Boston"</span>, nickName: <span class="hljs-string">"Red Sox"</span>) 
<span class="hljs-keyword">let</span> city = redsox.city
<span class="hljs-keyword">let</span> fullname = redsox.fullname()
</code></pre>
    <p class="normal">We can create a much cleaner interface using dynamic member lookups. To use dynamic member lookups, the first thing we need to do is to add the <code class="Code-In-Text--PACKT-">@dynamicMemberLookup</code> attribute when we define the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dynamicMemberLookup</span>
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">BaseballTeam</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">let</span> city: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> nickName: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> wins: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> losses: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> year: <span class="hljs-type">Int</span>
}
</code></pre>
    <p class="normal">Now we <a id="_idIndexMarker558"/>will need to add the lookup to the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure. This is done by implementing the <code class="Code-In-Text--PACKT-">subscript(dynamicMember: )</code> subscript. The following code shows how we would create a lookup to retrieve both the full name and the winning percentage for the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">subscript</span>(dynamicMember key: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> { 
    <span class="hljs-keyword">switch</span> key {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"fullname"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"\(city) \(nickName)"</span> 
    <span class="hljs-keyword">case</span> <span class="hljs-string">"percent"</span>:
        <span class="hljs-keyword">let</span> per = wins/(wins+losses) <span class="hljs-keyword">return</span> <span class="hljs-type">String</span>(per)
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Unknown request"</span>
    }
}
</code></pre>
    <p class="normal">This code will retrieve the key passed in and uses a <code class="Code-In-Text--PACKT-">switch</code> statement, using that key, to determine what information to return from the subscript. With this code added to the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure, we can use the lookup as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> redsox = <span class="hljs-type">BaseballTeam</span>(city: <span class="hljs-string">"Boston"</span>, nickName: <span class="hljs-string">"Red Sox"</span>, wins: <span class="hljs-number">108</span>, losses: <span class="hljs-number">54</span>, year: <span class="hljs-number">2018</span>)
<span class="hljs-built_i">print</span>(<span class="hljs-string">"The \(redsox.fullname) won \(redsox.percent) of their games in \(redsox.year)"</span>)
</code></pre>
    <p class="normal">Notice how we are able to access both <code class="Code-In-Text--PACKT-">fullname</code> and <code class="Code-In-Text--PACKT-">percent</code> from the instance of the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure as if they were normal properties. This makes our code much cleaner and easier to read. However, there is one thing to keep in mind when using lookups like this: there is no way to control what keys are passed into the lookup.</p>
    <p class="normal">In the previous example, we called <code class="Code-In-Text--PACKT-">fullname</code> and <code class="Code-In-Text--PACKT-">percent</code>; however, we could just as easily have called flower or dog with no warning from the compiler. This is why there is a lot of controversy attached to dynamic member lookup, because there is no compile-time warning if you do something wrong.</p>
    <p class="normal">If you use <a id="_idIndexMarker559"/>dynamic member lookup, make sure you verify the key and handle any instances when something unexpected is sent, as we did with the previous example using the default case of the <code class="Code-In-Text--PACKT-">switch</code> statement.</p>
    <p class="normal">Now that we have seen how to use subscripts, let's take a quick look at when not to use custom subscripts.</p>
    <h1 id="_idParaDest-238" class="title">When not to use a custom subscript</h1>
    <p class="normal">As we have seen in this chapter, creating custom subscripts can really enhance our code. However, we should <a id="_idIndexMarker560"/>avoid overusing them or using them in a way that is not consistent with standard subscript usage. The way to avoid overusing subscripts is to examine how subscripts are used in Swift's standard libraries.</p>
    <p class="normal">Let's look at the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyNames</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> names:[<span class="hljs-type">String</span>] = [<span class="hljs-string">"Jon"</span>, <span class="hljs-string">"Kailey"</span>, <span class="hljs-string">"Kara"</span>] 
    <span class="hljs-keyword">var</span> number: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> names.<span class="hljs-built_i">count</span>
        }
    }
<span class="hljs-keyword">    subscript</span>(add name: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> { 
        names.append(name)
            <span class="hljs-keyword">return</span> name
    }
    <span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> { 
        <span class="hljs-keyword">get</span> { 
            <span class="hljs-keyword">return</span> names[index]
        }
        <span class="hljs-keyword">set</span> {
            names[index] = newValue
        }
    }
}
</code></pre>
    <p class="normal">In the preceding example, within the <code class="Code-In-Text--PACKT-">MyNames</code> class, we define an array of names that are used within our application. As an example, let's say that within our application we display this list of names and allow users to add names to it. Within the <code class="Code-In-Text--PACKT-">MyNames</code> class, we then define the following subscript, which allows us to append a new name to the array:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">subscript</span>(add name: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> { 
    names.append(name)
    <span class="hljs-keyword">return</span> name
}
</code></pre>
    <p class="normal">This would be a poor use of subscripts because its usage is not consistent with how subscripts are <a id="_idIndexMarker561"/>used within the Swift language itself—we are using it to accept a parameter and add that value. This might cause confusion when the class is used. It would be more appropriate to rewrite this subscript as a function, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">append</span><span class="hljs-params">(name: String)</span> { 
    names.append(name)
}
</code></pre>
    <p class="normal">Remember, when you are using custom subscripts, make sure that you are using them appropriately.</p>
    <h1 id="_idParaDest-239" class="title">Summary</h1>
    <p class="normal">As we saw in this chapter, adding support for subscripts to our custom types can greatly enhance their readability and usability. We saw that subscripts can be used to add an abstraction layer between our backend storage class and external code. Subscripts can also be used in a similar manner to computed properties, where the subscript is used to calculate a value. As we noted, the key with subscripts is to use them appropriately and in a manner that is consistent with subscripts in the Swift language.</p>
    <p class="normal">In the next chapter, we will look at what closures are and how to use them.</p>
  </div>
</body></html>