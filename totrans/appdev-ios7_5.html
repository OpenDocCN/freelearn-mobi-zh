<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Creating and Saving User Data</h1></div></div></div><p>In this chapter, we will start by adjusting the style of our navigation bar to match the navigation style of iOS 7. Next, we will create our buttons in the navigation bar and hook them up to the proper methods. Once we adjust our storyboard, we can start writing the code to allow a user to take or pick an image, give the item a title, and then back up the data to disk for later use. On completing this chapter, our application will have all the functionality required for users to save new food items!</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Picking up where we left off</h1></div></div></div><p>In the last chapter, we created all our files and then connected them to our storyboard. We then added all of the required elements (labels, image views, and so on) to each view controller. Last, we created outlets and connected them to our storyboard elements. The purpose of this chapter, along with that of the following chapter, is to finish building the application. We will be implementing one portion of the core functionality, which is the ability to take or select a photo, add a name, and then save the data. Once we complete this, we can start using some of the new features of iOS 7 to add additional visual appeal to our application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>The navigation bar style</h1></div></div></div><p>Before we move on, let's go ahead and alter some of the navigation bar style options<a id="id110" class="indexterm"/>. Our application will have the same navigation bar style in every view, so our best approach is to use the appearance proxy on <code class="literal">UINavigationBar</code> in our <code class="literal">AppDelegate</code> object. This will allow us to write the code only once, and the navigation bars in the entire application will abide by these styles.</p><p>Switch to <code class="literal">AppDelegate.m</code> and scroll down to the <code class="literal">applicationDidFinishLaunchingWithOptions</code> method<a id="id111" class="indexterm"/>. We are going to set the color of the navigation bar, the font for the title label, and the navigation bar tint color (this will change the color of the bar button items on the navigation bar). Additionally, our application will have text-based bar button items, so we want to set the appearance proxy on <code class="literal">UIBarButtonItem</code> to match our application style. Copy and paste the following code into <code class="literal">applicationDidFinishLaunchingWithOptions</code>:</p><div><pre class="programlisting">[[UINavigationBar appearance] setBarTintColor:[UIColor colorWithRed:200.0//255 green:0.0/255 blue:23.0/255 alpha:1.0f]];
[[UINavigationBar appearance] setTitleTextAttributes: @{NSForegroundColorAttributeName: [UIColor whiteColor],
                                                            NSFontAttributeName: [UIFont fontWithName:@"HelveticaNeue" size:19.0f] }];

[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];

[[UIBarButtonItem appearance] setTitleTextAttributes:@{NSFontAttributeName:[UIFont fontWithName:@"HelveticaNeue-Light" size:18.0f]} forState:UIControlStateNormal];</pre></div><p>First, we set the color of the navigation bar base to dark red. Next, we set the title text font color to white and set<a id="id112" class="indexterm"/> its font to a specific font. You can replace this font with any font you wish; I just like the way this font looks. To match our title text, all navigation bar buttons should also be white, so we set the <code class="literal">navigationTintColor</code> method<a id="id113" class="indexterm"/> (do not get confused with the <a id="id114" class="indexterm"/>
<code class="literal">navigationBarTintColor</code> method<a id="id115" class="indexterm"/>, which will change the color of the navigation bar itself and not the navigation items) to white. Last, we alter the font of our <code class="literal">UIBarButtonItem</code> objects to match our navigation bar title style.</p><p>Now that our navigation bar is styled, let's add some code to our <code class="literal">MenuViewController</code> to finalize the style of our application. Switch to <code class="literal">MenuViewController.m</code> and scroll down to the <code class="literal">viewDidLoad</code> method. First, let's adjust the background color of the menu buttons. Previously, we set the<a id="id116" class="indexterm"/> <code class="literal">backgroundColor</code> property<a id="id117" class="indexterm"/> to white, but let's change this to match our dark red navigation bar. Replace the previous background color code with the following code snippet:</p><div><pre class="programlisting">bottomBarBG.backgroundColor = [UIColor colorWithRed:200.0/255 green:0.0/255 blue:23.0/255 alpha:0.7f];</pre></div><p>Last, write the following<a id="id118" class="indexterm"/> code into the<a id="id119" class="indexterm"/> <code class="literal">viewDidLoad</code> method:</p><div><pre class="programlisting">// Set this in every view controller so that the back button displays back instead of the root view controller name
self.navigationItem.backBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@" " style:UIBarButtonItemStylePlain target:nil action:nil];</pre></div><p>This is a very handy piece of code to use. By default, when a <a id="id120" class="indexterm"/>
<code class="literal">viewController</code> method<a id="id121" class="indexterm"/> is pushed onto the navigation stack, it will display a back button (less-than sign) and text. The text is based on the previous view controller's title. We want to only display the <code class="literal">&lt;</code> symbol, so we add the previous line of code. We are basically telling the application that for every back button, the text should be equal to <code class="literal">@""</code>, or an empty string. It is worth noting that this can be changed by setting the back button property of the navigation item in our storyboard. The following <a id="id122" class="indexterm"/>screenshot is an example of our application before and after introducing an empty string:</p><div><img src="img/InsertImage_0319OS_05_01.jpg" alt="The navigation bar style"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Adding our button action</h1></div></div></div><p>Our next step is to add the code to be called when the <strong>Add New</strong> button<a id="id123" class="indexterm"/> is pressed. In our previous chapter, we created an action called <code class="literal">addNewPressed</code> and connected it to our <strong>Add New</strong> button. Let's go<a id="id124" class="indexterm"/> ahead and write the code to present the proper view controller when this button is pressed. First, switch to <code class="literal">MenuViewController.h</code>, and directly underneath the standard <code class="literal">#import</code> for UIKit, let's import our view controllers as shown in the following code snippet:</p><div><pre class="programlisting">#import &lt;UIKit/UIKit.h&gt;
#import "AddNewViewController.h"
#import "MyFoodsViewController.h"

#define ADD_NEW_VIEW_CONTROLLER @"AddNew"</pre></div><p>We have also defined a string literal for our storyboard ID for good practice. We have named it <code class="literal">ADD_NEW_VIEW_CONTROLLER</code> so that we know what it contains. Switch back to <code class="literal">MenuViewController.m</code> and scroll down to our <code class="literal">addNewPressed</code> method. As we will be presenting this view controller (dragging it onto the screen from the bottom), we need to also create a navigation controller to hold the <code class="literal">AddNewViewController</code> object. The following is the code for adding a button action:</p><div><pre class="programlisting">- (IBAction)addNewPressed:(UIButton *)sender {

// Present the addNewFoodViewController
AddNewViewController *vc = [self.storyboard instantiateViewControllerWithIdentifier: ADD_NEW_VIEW_CONTROLLER ];"];
UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:vc];

[self.navigationController presentViewController:nav animated:YES completion:nil];

}</pre></div><p>This code is pretty straightforward. We allocate our <code class="literal">AddNewViewController</code> object<a id="id125" class="indexterm"/> by initializing it from our storyboard.<a id="id126" class="indexterm"/> Make sure that <code class="literal">AddNewViewController</code> in our storyboard has the property for our storyboard ID set to <code class="literal">AddNew</code> so that it matches our string literal defined earlier. Under certain circumstances, it is recommended to preinitialize the view controller before presenting it if there is a noticeable lag between the button press and the view being presented. Next, we create a navigation controller and assign our newly created <code class="literal">AddNewViewController</code> as its root view controller. Last, we tell the current navigation controller to present the new one. Go ahead and run the application and test the functionality. The <code class="literal">AddNewViewController</code> object inside of a navigation controller should slide onto the screen.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Adding buttons to our navigation bar</h1></div></div></div><p>You may have noticed that when presenting our <code class="literal">AddNewViewController</code> object, we have no way to dismiss the view<a id="id127" class="indexterm"/> to get back to the menu. Let's add this functionality now. We will be creating two bar button items that will be text-only items. The<a id="id128" class="indexterm"/> first button, <strong>Cancel</strong>, will dismiss the view while the second, <strong>Save</strong>, will save the new food entry.</p><p>Switch to <code class="literal">AddNewViewController.m</code> and scroll down to <code class="literal">viewDidLoad</code>. Add the following code at the top of <code class="literal">viewDidLoad</code>:</p><div><pre class="programlisting">// Add our bar button items
    UIBarButtonItem *cancelButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCancel target:self action:@selector(cancelButtonPressed:)];
    UIBarButtonItem *saveButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemSave target:self action:@selector(saveButtonPressed:)];

// Assign the bar buttons to the navigation controller
[self.navigationItem setLeftBarButtonItem:cancelButton];
[self.navigationItem setRightBarButtonItem:saveButton];</pre></div><p>Here, we create both bar button items using the built-in <strong>Cancel</strong> and <strong>Save</strong> bar button items provided by iOS. Each button also has its own selector (or method) that we will code in a moment. Next, we assign each bar button to the navigation bar. I chose to place <strong>Cancel</strong> on the left-hand side and <strong>Save</strong> on the right-hand side of the bar; however, this order is entirely up to you. If we run<a id="id129" class="indexterm"/> our application and click on the <strong>Add New</strong> button, our view will slide into place, and you will see <strong>Cancel</strong> on the left-hand side and <strong>Save</strong> on the right-hand side. Our appearance proxies defined in the app delegate should also be<a id="id130" class="indexterm"/> reflected in the font and text color. Next, let's actually add the <strong>Cancel</strong> button functionality.</p><p>Switch back to <code class="literal">AddNewViewController.m</code> and scroll down to the bottom of <code class="literal">viewDidLoad</code>. We want to allow the user to cancel adding a food item, so let's write the <code class="literal">cancelButtonPressed</code> method<a id="id131" class="indexterm"/> that we earlier assigned to our cancel button. Directly below <code class="literal">viewDidLoad</code>, add the following code:</p><div><pre class="programlisting">- (void)cancelButtonPressed:(UIButton *)sender {
    
    // Dismiss the view
    [self.presentingViewController dismissViewControllerAnimated:YES completion:nil];
    
}

- (void)saveButtonPressed:(UIButton *)sender {
    
    
}</pre></div><p>We have defined both our <code class="literal">cancelButtonPressed</code> and <code class="literal">saveButtonPressed</code> methods here (<code class="literal">saveButtonPressed</code> has been intentionally left blank until later in the chapter). In <code class="literal">cancelButtonPressed</code>, we simply tell the view controller to dismiss itself and set the animated view controller to <code class="literal">YES</code>. Run the application and test this functionality.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Adjusting our storyboard view</h1></div></div></div><p>Now that we have some of our code<a id="id132" class="indexterm"/> implemented, we need to finish arranging our view in <code class="literal">Main.storyboard</code>. Previously, we only added the required elements and did not position or size them correctly. Switch to <code class="literal">Main.storyboard</code> and scroll down to the <code class="literal">AddNewViewController</code> object.</p><p>We have three items to position and size here, starting with the two image views. Select the first image view, and in the <strong>Utilities</strong> pane, select the <strong>Size Inspector</strong> submenu. Set the width and height to 180 pixels to create a perfect square. Position this image view horizontally in the center of the view and slightly higher than the vertical center of the view. Do not worry about being precise, and feel free to position the image view where you think it looks best!</p><p>Repeat this process for the other image view, making it an identical size and in exactly the same position. For this image view, switch to the <strong>Attributes Inspector</strong> submenu (in the <strong>Utilities</strong> pane on the right-hand side) and set its image to <code class="literal">placeholder_image</code> for <code class="literal">placeholderImageView</code>. Using the documents outline, make sure that this image view is positioned <em>below</em> the other image view. We will be using two image views to assist in save validation. When a user selects or takes an image, it will be set to the top image view (the empty one) and cover the placeholder image view beneath it. This allows us to check if the top image view<a id="id133" class="indexterm"/> contains an image. If it does not, it means the user has not added an image and that the placeholder is still visible. In this case, we will alert the user to let him/her know that he/she must include a photo.</p><p>Last, we need to adjust the settings of our <code class="literal">UITextField</code> object that will be used to type in the name of our food entry. Select the text field and reopen the <strong>Size Inspector</strong> submenu from the <strong>Utilities</strong> pane. Set the height to 38 pixels and the width to 280 pixels. Position the text field horizontally centered and slightly above the image views.</p><p>Select the <strong>Attributes Inspector</strong> from the <strong>Utilities</strong> pane and change the following settings:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Alignment</strong>: Select the Center icon</li><li class="listitem" style="list-style-type: disc"><strong>Placeholder</strong>: <code class="literal">Type The Food Name</code></li><li class="listitem" style="list-style-type: disc"><strong>Border Style</strong>: This field should be set to none (the first of the four buttons)</li><li class="listitem" style="list-style-type: disc"><strong>Capitalization</strong>: Select Words</li></ul></div><p>The final result should look something like the following screenshot:</p><div><img src="img/InsertImage_0319OS_05_02.jpg" alt="Adjusting our storyboard view"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Adding our delegates</h1></div></div></div><p>Now that<a id="id134" class="indexterm"/> our view is completely set up, we can start coding the desired functionality. Before we <a id="id135" class="indexterm"/>can move on, we need to specify some delegates that our view controller will require to work. We will work with a text field, image picker, navigation controller, and action sheet, all of which have their own custom delegates. Switch to <code class="literal">AddNewViewController.h</code> and replace the line of code after <code class="literal">#import</code> with the following code:</p><div><pre class="programlisting">@interface AddNewViewController : UIViewController &lt;UITextFieldDelegate, UIActionSheetDelegate, UIImagePickerControllerDelegate, UINavigationControllerDelegate&gt;</pre></div><p>Here, we are simply specifying the protocols that our class will conform to in the code.<a id="id136" class="indexterm"/> With this final step, we can now start coding our functionality into the application!</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Using a tap gesture</h1></div></div></div><p>For our application, a user can tap on the placeholder image in order to take or select a photo. To do this, we will add a <a id="id137" class="indexterm"/>tap gesture recognizer directly to the placeholder image view. Switch to <code class="literal">AddNewViewController.m</code> and scroll down to <code class="literal">viewDidLoad</code>. Add the following code at the bottom of the <code class="literal">viewDidLoad</code> file:</p><div><pre class="programlisting">// Add a border around our image view
[self.placeholderImageView.layer setBorderWidth:6.0f];
[self.placeholderImageView.layer setBorderColor:[UIColor colorWithRed:129.0/255.0 green:129.0/255.0 blue:130.0/255.0 alpha:1.0].CGColor];
    
UITapGestureRecognizer *imageViewTapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(imageViewTapped:)];
[imageViewTapGesture setNumberOfTapsRequired:1];];
    
[self.placeholderImageView setUserInteractionEnabled:YES];
[self.placeholderImageView addGestureRecognizer:imageViewTapGesture];</pre></div><p>First, we add a border and a corner radius to our image view for visual effect. Next, we create a tap gesture recognizer and assign it a method. We also set the property <code class="literal">numberOfTapsRequired</code> to <code class="literal">1</code>. The last step is to set the user interaction enabled on our placeholder image view to <code class="literal">YES</code> and then add our gesture recognizer to it. Now, our image view will keep listening for a single tap and call our <code class="literal">imageViewTapped</code> method when a tap is detected.</p><p>When the image is tapped, we want to give the user an option to either select an image from their library or take a new one using the camera. The best way to do this is using an action sheet. Let's create the <code class="literal">imageViewTapped</code> method<a id="id138" class="indexterm"/>, have it display an action sheet, and then respond to the users' selection accordingly. Below the <code class="literal">ButtonPressed</code> methods, add the following code:</p><div><pre class="programlisting">#pragma mark - User Interaction Methods

- (void)imageViewTapped:(id)sender {
    
    [[[UIActionSheet alloc] initWithTitle:nil
                                 delegate:self
                        cancelButtonTitle:@"Cancel"
                   destructiveButtonTitle:nil
                        otherButtonTitles:@"Take Picture", @"Choose From Library", nil]
     showInView:self.view];
    
}</pre></div><p>With this code, when the user taps on the image view, we create an action sheet and display it in the current view. We only need the <strong>Cancel</strong> button and two additional buttons, one for <strong>Take Picture</strong> and another for <strong>Choose From Library</strong>.<strong> </strong>In order for us to respond accordingly to the<a id="id139" class="indexterm"/> selected action sheet button, we need to implement the action sheet delegate method. Below the <code class="literal">imageViewTapped</code> method<a id="id140" class="indexterm"/>, add the following code:</p><div><pre class="programlisting">#pragma mark - Action Sheet Delegate

-(void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex {
    
    if (buttonIndex == actionSheet.cancelButtonIndex) {
        return;
    }
    
    if (buttonIndex == 0 &amp;&amp; [UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {
        // Take Picture Selected
        UIImagePickerController *imagePicker = [[UIImagePickerController alloc] init];
        imagePicker.delegate = self;
        imagePicker.allowsEditing = YES;
        [imagePicker setSourceType:UIImagePickerControllerSourceTypeCamera];
        
        [self.navigationController presentViewController:imagePicker animated:YES completion:nil];
        
    }
    
    if (buttonIndex == 1) {
        // Choose Photo From Library
        UIImagePickerController *imagePicker = [[UIImagePickerController alloc] init];
        imagePicker.delegate = self;
        imagePicker.allowsEditing = YES;
        [imagePicker setSourceType:UIImagePickerControllerSourceTypePhotoLibrary];
        
        [self.navigationController presentViewController:imagePicker animated:YES completion:nil];
        
    }
    
}</pre></div><p>In this method, we first check if the selected button is the <strong>Cancel</strong> button, and if so, we return to end the execution of this method, which will also hide the action sheet for us. Next, we check if the button index is equal to <code class="literal">0</code>, or <code class="literal">Take Picture</code>. If so, we create an instance of <code class="literal">UIImagePickerController</code>. We set the delegate to <code class="literal">self</code> and also allow editing (this will allow the user<a id="id141" class="indexterm"/> to crop the image into a perfect square, which is ideal for our application), and then we set the source type to camera.</p><p>If the button index is <code class="literal">1</code>, or <code class="literal">Choose From Library</code>, we use exactly the same code with one exception. For this block, set the source type to photo library to display the phone's camera library. Save our code and run the application. Everything should work as expected.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Getting the image from UIImagePickerController</h1></div></div></div><p>Now that a user can take a photo<a id="id142" class="indexterm"/> or select from their phone's photo library, we need to grab that image and display it. In order to do so, we need to implement<a id="id143" class="indexterm"/> the image picker's delegate method, the <code class="literal">didFinishPickingMediaWithInfo</code> method<a id="id144" class="indexterm"/>. Below our action sheet delegate method, add the following code:</p><div><pre class="programlisting">#pragma mark - UIImagePicker Delegate

-(void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info {
    
    UIImage *pic;
    
    //Grab the stored image
    if ([info objectForKey:UIImagePickerControllerEditedImage]) {
        pic = [info objectForKey:UIImagePickerControllerEditedImage];

    [self.finalImageView setImage:pic];
    [self.placeholderImageView setHidden:YES];

    }
    
    
    
    [self.presentingViewController dismissViewControllerAnimated:YES completion:nil];
    
    
}</pre></div><p>In this method, we create an instance of <code class="literal">UIImage</code> and assign it using the info dictionary provided by the image picker. Because we want our users to edit the image, we want to grab the edited version instead of the original (which can be accessed using <code class="literal">UIImagePickerControllerOriginalImage</code>). Now that we have our final image, we assign it to our final<a id="id145" class="indexterm"/> image view and then hide the placeholder image view. Last, we need to tell the image picker controller to dismiss itself to bring us back to our <code class="literal">AddNewViewController</code>.</p><p>Save everything and run<a id="id146" class="indexterm"/> the code to test it out. If you wish to actually take a picture with the camera, you must run this on an actual device.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Adding the text field delegate</h1></div></div></div><p>Now that we have our image, we need to set up the text field delegate<a id="id147" class="indexterm"/>. This is probably the simplest of all delegate methods because we only need to tell the application what to do when the <em>return</em> key is pressed. For our application, we simply want to hide the keyboard. Below our image picker delegate method, add the following code:</p><div><pre class="programlisting">#pragma mark - Text Field Delegate

- (BOOL)textFieldShouldReturn:(UITextField *)textField {
    
    [textField resignFirstResponder];
    return NO;
}</pre></div><p>This method simply tells the text view to resign first responder (hide the keyboard) when the <em>return</em> key is pressed. A user can type in a name, press the <em>return</em> key, and hide the keyboard. Make sure that the text fields delegate property has been set to <code class="literal">AddNewViewController</code> (self) either in the storyboard or in <code class="literal">viewDidLoad</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Saving the data</h1></div></div></div><p>We now have everything we need from the user to create a new food entry. In order to save the data, we will need to follow multiple steps so that we can access it again later in the app. The save data method we created earlier will be quite long once complete, so we will cover it piece by piece for simplicity, starting with a custom date helper method.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec18"/>Getting the date string</h2></div></div></div><p>For our application, we will be creating a <code class="literal">.plist</code> file that will store the food entry's name, date created, and the file path to the image. The image itself will be saved separately in the documents directory. When saving any file to the documents directory, you must specify a filename.<a id="id148" class="indexterm"/> In order to save multiple images, we need to make sure that every single image file saved has a different filename. One of the best (and most popular) ways to accomplish this is using a date.</p><p>Each device keeps track of the<a id="id149" class="indexterm"/> current date down to the millisecond. This means that at any given millisecond, the date will be completely different from every date before and every date after. This gives a great way to create a unique identifier for each image based on when it was created. What we will do is grab the current date, set the date format, and convert it to a string that we will then tack onto the end of each filename. This way, every single image will have a unique filename that will be stored in our <code class="literal">.plist</code> file to be accessed later.</p><p>I have created a simple helper method that returns the current date as a string value that we can use for the filename, so let's add it to our code. Scroll down to the end of the last method and add the following code:</p><div><pre class="programlisting">#pragma mark - Date Helper Method

-(NSString*)stringForCurrentDateTime
{
    NSDateFormatter *format = [[NSDateFormatter alloc] init];
    [format setDateFormat:@"yyyyMMddHHmmss"];
    
    
    NSDate *now = [NSDate date];
    NSString *dateString = [format stringFromDate:now];
    
    return dateString;
}</pre></div><p>With this code, we first create a date formatter that takes the year, month, day, hour, minute, and second values of a date and pushes them together. Next, we create a date object and set it to the current date and time. Finally, we create a string using our date formatter and return it. Now that <a id="id150" class="indexterm"/>we have our helper method, let's add <a id="id151" class="indexterm"/>the code to save the data!</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec19"/>Adding validation</h2></div></div></div><p>We are now ready to<a id="id152" class="indexterm"/> implement the <code class="literal">saveButtonPressed</code> method. Before we write any of the code to actually save the date, we first need to check that the user has <a id="id153" class="indexterm"/>actually selected an image and added a name.<a id="id154" class="indexterm"/> This will prevent us from having any errors and will guarantee that we have the required data. Scroll down to the empty <code class="literal">saveButtonPressed</code> method we created earlier and add the following code:</p><div><pre class="programlisting">- (void)saveButtonPressed:(UIButton *)sender {
    
// Check if the image and title have been saved
// If so, save the image to the documents directory and dismiss the view
    
    if (self.finalImageView.image &amp;&amp; self.nameTextField.text.length &gt; 0) {
        // Image and name have been set, so we can save
        
        
        
        
    } else {
        
        [[[UIAlertView alloc] initWithTitle:@"Missing Data"
                                    message:@"A title and image are both required to save."
                                   delegate:nil
                          cancelButtonTitle:@"Ok"
                          otherButtonTitles:nil]
         show];
        
    }
    
}</pre></div><p>This validation is very simple but effective. Here, we put to use having multiple image views by checking whether the final image view is nil. We also check to make sure that a user has actually added text to the text field by checking that the text property's length is greater than zero. If either of these two conditions is false, we display an alert view telling the user that both a title and an image are required to be saved. If both are true, we can proceed with our saving process. It is recommended that you use a data model to maintain data in an application; however, for our application, this will do fine.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec20"/>Saving the image</h2></div></div></div><p>The first step in the saving<a id="id155" class="indexterm"/> process is to save the image itself to the documents directory. Inside the first <code class="literal">if</code> statement block, add the following code:</p><div><pre class="programlisting">// get paths from root direcory and the main documents directory
    NSArray *paths = NSSearchPathForDirectoriesInDomains (NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsPath = [paths firstObject];
        

// Set up and save our image to the documents directory
    NSString *imagePath = [documentsPath stringByAppendingPathComponent:[NSString stringWithFormat:@"image-%@", [self stringFromCurrentDateTime]]];
        
    NSData* data = UIImagePNGRepresentation(self.finalImageView.image);
    [data writeToFile:imagePath atomically:YES];</pre></div><p>First, we grab the first<a id="id156" class="indexterm"/> element (which will always be the path to the documents directory) from the list of directories in the file system. We then create a new path for our image by adding a filename to the end of the documents path. The filename is how we access the image later in our app. Using our date helper method, we set the filename to image, and the returned date string is separated by a hyphen. Now every image will be found in the documents directly with a unique filename. Last, we create an instance of <code class="literal">NSData</code>, assign the user's final image to it as data using <code class="literal">UIImagePNGRepresentation</code>, and then save the date to the image path created previously.</p><p>Now that our image has been saved, we can save the rest of our data.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec21"/>Creating versus loading the .plist file</h2></div></div></div><p>In order to save the users' data, we will be creating a dictionary that contains all relevant data for each food entry. We will then<a id="id157" class="indexterm"/> add this dictionary to a <code class="literal">.plist</code> file and save the <code class="literal">.plist</code> file to the documents directory. To make sure we don't save over our <a id="id158" class="indexterm"/>previous data, we must first check to see<a id="id159" class="indexterm"/> if our <code class="literal">.plist</code> file already exists. Below the previous code for saving the image, add the following code:</p><div><pre class="programlisting">// Get the path to our Data/plist file and where we will be saving our images
NSString *plistPath = [documentsPath stringByAppendingPathComponent:@"Data.plist"];
        
// Forward reference of our array
NSMutableArray *plistDataArray;
        
// Call the file manager to check if the file exists
NSFileManager *defaultManager = [NSFileManager defaultManager];
if ([defaultManager fileExistsAtPath:plistPath])
{
    // Assign the data
    // Get the current data from the plist file if it exists
    plistDataArray = [NSMutableArray arrayWithContentsOfFile:plistPath];
            
}
else
{
    //create empty file
    NSMutableArray *array = [NSMutableArray array];
    [array writeToFile:plistPath atomically:YES];
    plistDataArray = [NSMutableArray arrayWithContentsOfFile:plistPath];
            
}</pre></div><p>First, we create another path by adding <code class="literal">Data.plist</code> to the end of the documents directory created earlier (this name can be anything you wish as long as it ends in <code class="literal">.plist</code>). Next, we create an empty array to hold the final <code class="literal">.plist</code> data and allow us to append more data to the<a id="id160" class="indexterm"/> end of the file. We create an instance of <code class="literal">NSFileManager</code> and<a id="id161" class="indexterm"/> use it to check if the file at the newly<a id="id162" class="indexterm"/> created path exists. If so, we set the contents of our <code class="literal">.plist</code> file to the <code class="literal">plistDataArray</code> method.</p><p>If the <code class="literal">.plist</code> file does not exist, we instead create another empty array, save the array as a <code class="literal">.plist</code> file, and then set the <code class="literal">plistDataArray</code> method<a id="id163" class="indexterm"/> to the content of the newly created (but empty) <code class="literal">.plist</code> file. Now we can add more data.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec22"/>Adding a new entry</h2></div></div></div><p>Now, we will grab the user data <a id="id164" class="indexterm"/>and turn it into a dictionary so that we can add it to our data array. Then, we can save it to the documents directory. Add the following code after the previous code:</p><div><pre class="programlisting">// Create a new food item
NSMutableDictionary *foodItem = [[NSMutableDictionary alloc] init];
[foodItem setValue:self.nameTextField.text forKey:@"name"];
[foodItem setValue:imagePath forKey:@"image_filepath"];
[foodItem setValue:[NSDate date] forKey:@"date"];
        
[plistDataArray addObject:foodItem];
[plistDataArray writeToFile:plistPath atomically:YES];
        
        
[self dismissViewControllerAnimated:YES completion:nil];</pre></div><p>Here, we create a new empty mutable dictionary. The dictionary is then filled with the user-entered name, the image path used earlier, and the current date and time. We then add this dictionary to our <code class="literal">plistDataArray</code> method and tell it to save (write) the file. Last, we dismiss<a id="id165" class="indexterm"/> the view controller to bring us back to the menu where we started, and our data has been saved!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we built the most important component of our application, the ability to create new food entries. Now that all of this data has been saved, we can retrieve it and start displaying it to our user. Because everything is saved directly to the device, we are able to manipulate this data instantly and use it as we please.</p><p>In the next chapter, we will build the final piece of our application's core functionality: viewing the user-created data both in a table view and in a detail view.</p></div></body></html>