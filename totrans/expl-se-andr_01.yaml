- en: Chapter 1. Linux Access Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 Linux访问控制
- en: Android is an operating system composed of two distinct components. The first
    component is a forked mainline Linux kernel and shares almost everything in common
    with Linux. The second component, which will be discussed later, is the user space
    portion, which is very custom and Android specific. Since the Linux kernel underpins
    this system and is responsible for the majority of access control decisions, it
    is the logical place to begin a detailed look at Android.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android 是由两个不同组件组成的操作系统。第一个组件是一个分支的主线 Linux 内核，与 Linux 几乎共享所有共同点。第二个组件，稍后将会讨论，是用户空间部分，这部分非常定制且具有
    Android 特性。由于 Linux 内核支撑这个系统并负责大多数访问控制决策，因此这是开始详细研究 Android 的合乎逻辑的地方。
- en: 'In this chapter we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Examine the basics of Discretionary Access Control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查离散访问控制的基本知识
- en: Introduce Linux permissions flags and capabilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Linux 权限标志和能力
- en: Trace syscalls as we validate access policies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证访问策略时跟踪系统调用
- en: Make the case for more robust access control technology
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更健壮的访问控制技术辩护
- en: Discuss Android exploits that leverage problems with Discretionary Access Control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论利用离散访问控制问题的 Android 漏洞
- en: Linux's default and familiar access control mechanism is called **Discretionary
    Access Control** (**DAC**). This is just a term that means permissions regarding
    access to an object are at the discretion of its creator/owner.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的默认和熟悉的访问控制机制被称为 **离散访问控制** (**DAC**)。这只是一个表示关于对象访问权限由其创建者/所有者决定的术语。
- en: In Linux, when a process invokes most system calls, a permission check is performed.
    As an example, a process wishing to open a file would invoke the `open()` syscall.
    When this syscall is invoked, a context switch is performed, and the operating
    system code is executed. The OS has the ability to determine whether a file descriptor
    should be returned to the requesting process or not. During this decision-making
    process, the OS checks the access permissions of both the requesting process and
    the target file it wishes to obtain the file descriptor to. Either the file descriptor
    or EPERM is returned, dependent on whether the permission checks pass or fail
    respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，当进程调用大多数系统调用时，会执行权限检查。例如，一个希望打开文件的进程会调用 `open()` 系统调用。当这个系统调用被调用时，会执行上下文切换，操作系统代码被执行。操作系统有能力确定是否应该将文件描述符返回给请求的进程。在决策过程中，操作系统会检查请求进程和目标文件（它希望获取文件描述符）的访问权限。根据权限检查是否通过，返回文件描述符或
    EPERM。
- en: 'Linux maintains data structures in the kernel for managing these permission
    fields, which are accessible from user space, and ones that should be familiar
    to Linux and *NIX users alike. The first set of access control metadata belongs
    to the process, and forms a portion of its credential set. The common credentials
    are user and group. In general, we use the term group to mean both primary group
    and possible secondary group(s). You can view these permissions by running the
    `ps` command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 在内核中维护数据结构来管理这些权限字段，这些字段可以从用户空间访问，并且对于 Linux 和 *NIX 用户来说应该是熟悉的。第一组访问控制元数据属于进程，并构成了其凭证集的一部分。常见的凭证是用户和组。一般来说，我们使用“组”一词来指代主要组以及可能的次要组。您可以通过运行
    `ps` 命令来查看这些权限：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we have processes running as the users `root` and `bookuser`.
    You can also see that their primary group is only one part of the equation. Processes
    also have a secondary set of groups called supplementary groups. This set might
    be empty, indicated by the dash in the `SUPGRP` field.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在以用户 `root` 和 `bookuser` 运行进程。您还可以看到，它们的主要组只是方程的一部分。进程还有一个称为补充组的次要组集。这个集合可能是空的，这在
    `SUPGRP` 字段中的破折号表示。
- en: The file we wish to open, referred to as the target object, target, or object
    also maintains a set of permissions. The object maintains `USER` and `GROUP`,
    as well as a set of permission bits. In the context of the target object, `USER`
    can be referred to as *owner* or *creator*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望打开的文件，称为目标对象、目标或对象，也维护了一组权限。对象维护 `USER` 和 `GROUP`，以及一组权限位。在目标对象的上下文中，`USER`
    可以被称为 *所有者* 或 *创建者*。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we look at the preceding command''s output, we can see that `hello.txt`
    has a `USER` of `bookuser` and `GROUP` as `bookuser`. We can also see the permission
    bits or flags on the left-hand side of the output. There are seven fields to consider
    as well. Each empty field is denoted with a dash. When printed with `ls`, the
    first fields can get convoluted by semantics. For this reason, let''s use `stat`
    to investigate the file permissions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前一个命令的输出，我们可以看到`hello.txt`的`USER`是`bookuser`，`GROUP`也是`bookuser`。我们还可以看到输出左边的权限位或标志。同时，我们还需要考虑七个字段。每个空字段都用破折号表示。使用`ls`打印时，第一个字段可能会因为语义而变得复杂。因此，让我们使用`stat`来调查文件权限：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first access line is the most compelling. It contains all the important
    information for the access controls. The second line is just a timestamp letting
    us know when the file was last accessed. As we can see, `USER` or `UID` of the
    object is `bookuser`, and `GROUP` is `bookuser` as well. The permission flags,
    (`0664/-rw-rw-r--`), identify the two ways that permission flags are represented.
    The first, the octal form `0664`, condenses each three-flag field into one of
    the three base-8 (octal) digits. The second is the friendly form, `-rw-rw-r--`,
    equivalent to the octal form but easier to interpret visually. In either case,
    we can see the leftmost field is 0, and the rest of our discussions will ignore
    it. That field is for `setuid` and `setgid` capabilities, which is not important
    for this discussion. If we convert the remaining octal digits, 664, to binary,
    we get 110 110 100\. This binary representation directly relates to the friendly
    form. Each triple maps to read, write, and execute permissions. Often you will
    see this permission triple represented as `RWX`. The first triple are the permissions
    given to `USER`, the second are the permissions given to `GROUP`, and the third
    is what is given to `OTHERS`. Translating to conventional English would yield,
    "The user, `bookuser`, has permission to read from and write to `hello.txt`. The
    group, `bookuser`, has permission to read from and write to `hello.txt`, and everyone
    else has permission only to read from `hello.txt`." Let's test this with some
    real-world examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条访问行是最有说服力的。它包含了访问控制的所有重要信息。第二条行只是一个时间戳，告诉我们文件最后一次被访问的时间。正如我们所见，对象的`USER`或`UID`是`bookuser`，`GROUP`也是`bookuser`。权限标志（`0664/-rw-rw-r--`）标识了权限标志的两种表示方式。第一种是八进制形式`0664`，将每个三位标志字段压缩成三个基数8（八进制）数字中的一个。第二种是友好形式，`-rw-rw-r--`，与八进制形式等效，但更容易直观理解。在任何情况下，我们都可以看到最左边的字段是0，我们接下来的讨论将忽略它。该字段用于`setuid`和`setgid`功能，对于这次讨论并不重要。如果我们将剩余的八进制数字664转换为二进制，我们得到110
    110 100。这种二进制表示直接与友好形式相关。每个三元组对应于读取、写入和执行权限。通常你会看到这个权限三元组表示为`RWX`。第一个三元组是赋予`USER`的权限，第二个是赋予`GROUP`的权限，第三个是赋予`OTHERS`的权限。用常规英语翻译就是，“用户`bookuser`有权从`hello.txt`读取和写入。组`bookuser`有权从`hello.txt`读取和写入，而其他人只有权从`hello.txt`读取。”让我们用一些现实世界的例子来测试这一点。
- en: Changing permission bits
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改权限位
- en: 'Let''s test the access controls in the example running processes as user `bookuser`.
    Most processes run in the context of the user that invoked them (excluding `setuid`
    and `getuid` programs), so any command we invoke should inherit our user''s permissions.
    We can view it by issuing:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以`bookuser`用户身份运行的示例进程中测试访问控制。大多数进程都是在调用它们的用户上下文中运行的（不包括`setuid`和`getuid`程序），因此我们调用的任何命令都应该继承我们用户的权限。我们可以通过以下命令查看：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: My user, `bookuser`, is `USER bookuser`, `GROUP bookuser` and `SUPGRP sudo`
    and `fuse`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我的用户`bookuser`是`USER bookuser`，`GROUP bookuser`，`SUPGRP sudo`和`fuse`。
- en: 'To test for read access, we can use the `cat` command, which opens the file
    and prints its content to `stdout`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试读取访问，我们可以使用`cat`命令，该命令打开文件并将内容打印到`stdout`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can introspect the syscalls executed by running the `strace` command and
    viewing the output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`strace`命令并查看输出来检查系统调用：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output can be quite verbose, so I am only showing the relevant parts. We
    can see that `cat` invoked the `open` syscall and obtained the file descriptor
    `3`. We can use that descriptor to find other accesses via other syscalls. Later
    we will see a read occurring on file descriptor `3`, which returns `365`, the
    number of bytes read. If we didn't have permission to read from `hello.txt`, the
    open would fail, and we would never have a valid file descriptor for the file.
    We would additionally see the failure in the `strace` output.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能非常冗长，所以我只显示相关部分。我们可以看到`cat`调用了`open`系统调用并获得了文件描述符`3`。我们可以使用该描述符通过其他系统调用找到其他访问。稍后我们将看到在文件描述符`3`上发生读取操作，它返回`365`，这是读取的字节数。如果我们没有权限从`hello.txt`读取，打开操作将失败，我们永远不会为该文件获得有效的文件描述符。我们还会在`strace`输出中看到失败。
- en: Now that read permission is verified, let's try write. One simple way to do
    this is to write a simple program that writes something to the existing file.
    In this case, we will write the line `my new text\n` (refer to `write.c`.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在读取权限已验证，让我们尝试写入。一种简单的方法是编写一个简单的程序，将某些内容写入现有文件。在这种情况下，我们将写入行`my new text\n`（参考`write.c`）。
- en: 'Compile the program using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译程序：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now run using the newly compiled program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用新编译的程序运行：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On verification, you will see:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 验证后，您将看到：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the write succeeded and returned `12`, the number of bytes written
    to `hello.txt`. No errors were reported, so the permissions seem in check so far.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，写入操作成功并返回`12`，这是写入`hello.txt`的字节数。没有报告错误，所以到目前为止权限似乎没问题。
- en: 'Now let''s attempt to execute `hello.txt` and see what happens. We are expecting
    to see an error. Let''s execute it like a normal command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试执行`hello.txt`并看看会发生什么。我们预计会看到一个错误。让我们像正常命令一样执行它：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is exactly what we expected, but let''s invoke it with `strace` to gain
    a deeper understanding of what failed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们预期的，但让我们用`strace`来调用它，以深入了解失败的原因：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `execve` system call, which launches processes, failed with `EACCESS`. This
    is just the sort of thing one would hope for when no execute permission is given.
    The Linux access controls worked as expected!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 启动进程的`execve`系统调用因`EACCESS`失败。这就是在没有执行权限时人们希望看到的情况。Linux访问控制按预期工作！
- en: 'Let''s test the access controls in the context of another user. First, we''ll
    create a new user called `testuser` using the `adduser` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在另一个用户的上下文中测试访问控制。首先，我们将使用`adduser`命令创建一个名为`testuser`的新用户：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Verify the `USER`, `GROUP`, and `SUPGRP` of `testuser`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 验证`testuser`的`USER`、`GROUP`和`SUPGRP`：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since the `USER` and `GROUP` do not match any of the permissions on `a.S`, all
    accesses will be subject to the `OTHERS` permissions checks, which if you recall,
    is read only (`0664`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`USER`和`GROUP`与`a.S`上的任何权限都不匹配，所有访问都将受到`OTHERS`权限检查的影响，如果您还记得，这是只读的（`0664`）。
- en: 'Start by temporarily working as `testuser`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先临时以`testuser`的身份工作：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we are still in bookuser's home directory, but the current user
    has been changed to `testuser`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们仍然在`bookuser`的主目录中，但当前用户已更改为`testuser`。
- en: 'We will start by testing `read` with the `cat` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`cat`命令测试`read`：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar to the earlier example, `testuser` can read the data just fine, as expected.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期示例类似，`testuser`可以很好地读取数据，正如预期的那样。
- en: 'Now let''s move on to write. The expectation is that this will fail without
    appropriate access:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续编写。预期的是，如果没有适当的访问权限，这将失败：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As expected, the syscall operation failed. When we attempt to execute `hello.txt`
    as `testuser`, this should fail as well:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，系统调用操作失败了。当我们尝试以`testuser`身份执行`hello.txt`时，这也应该会失败：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to test the group access permissions. We can do this by adding
    a supplementary group to `testuser`. To do this, we need to exit to `bookuser`,
    who has permissions to execute the `sudo` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要测试组访问权限。我们可以通过向`testuser`添加一个补充组来完成此操作。为此，我们需要退出到`bookuser`，他有权执行`sudo`命令：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s check the groups of `testuser`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查`testuser`的组：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a result of the previous `usermod` command `testuser` now belongs to two
    groups: `testuser` and `bookuser`. That means when `testuser` accesses a file
    or other object (such as a socket) with the group `bookuser`, the `GROUP` permissions,
    rather than `OTHERS`, will apply to it. In the context of `hello.txt`, `testuser`
    can now read from and write to the file, but not execute it.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前的`usermod`命令，`testuser`现在属于两个组：`testuser`和`bookuser`。这意味着当`testuser`使用`bookuser`组访问文件或其他对象（如套接字）时，将应用`GROUP`权限，而不是`OTHERS`权限。在`hello.txt`的上下文中，`testuser`现在可以读取和写入文件，但不能执行它。
- en: 'Switch to `testuser` by executing the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令切换到`testuser`：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Test `read` by executing the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令来测试`read`：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As before, `testuser` is able to read the file. The only difference is that
    it can now `read` the file through the access permissions of `OTHERS` and `GROUP`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`testuser`能够读取文件。唯一的区别是它现在可以通过`OTHERS`和`GROUP`的访问权限来`read`文件。
- en: 'Test `write` by executing the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令测试`write`：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time, `testuser` was able to write the file as well, instead of failing
    with the `EACCESS` permission error shown before.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`testuser`能够写入文件，而不是像之前那样因为`EACCESS`权限错误而失败。
- en: 'Attempting to execute the file should still fail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试执行文件应该仍然失败：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These concepts are the foundation of Linux access control permission bits, users
    and groups.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念是Linux访问控制权限位、用户和组的基础。
- en: Changing owners and groups
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改所有者和组
- en: Using `hello.txt` for exploratory work in the previous sections, we have shown
    how the owner of an object can allow various forms of access by managing the permission
    bits of the object. Changing the permissions is accomplished using the `chmod`
    syscall. Changing the user and/or group is done with the `chown` syscall. In this
    section, we will investigate the details of these operations in action.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中使用`hello.txt`进行探索性工作，我们已经展示了对象的所有者如何通过管理对象的权限位来允许各种形式的访问。更改权限是通过使用`chmod`系统调用完成的。更改用户和/或组是通过使用`chown`系统调用完成的。在本节中，我们将调查这些操作的具体细节。
- en: Let's start by granting read and write permissions only to the owner of `hello.txt`
    file, `bookuser`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先仅授予`hello.txt`文件的所有者`bookuser`读取和写入权限。
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, the file permissions are now set to only allow read and write
    access for `bookuser`. A thorough reader could execute the commands from earlier
    sections in this chapter to verify that permissions work as expected.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，文件权限现在设置为仅允许`bookuser`读取和写入访问。一个彻底的读者可以执行本章早期部分的命令来验证权限是否按预期工作。
- en: 'Changing the group can be done in a similar fashion with `chown`. Let''s change
    the group to `testuser`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`chown`也可以以类似的方式更改组。让我们将组更改为`testuser`：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This did not work as we intended, but what is the issue? In Linux, only privileged
    processes can change the `USER` and `GROUP` fields of objects. The initial `USER`
    and `GROUP` fields are set during object creation from the effective `USER` and
    `GROUP`, which are checked when attempting to execute that process. Only processes
    create objects. Privileged processes come in two forms: those running as the almighty
    `root` and those that have their capabilities set. We will dive into the details
    of capabilities later. For now, let''s focus on the `root`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有按我们的意图工作，但问题是什么？在Linux中，只有特权进程可以更改对象的`USER`和`GROUP`字段。初始的`USER`和`GROUP`字段是在对象创建时从有效的`USER`和`GROUP`设置的，这些在尝试执行该进程时进行检查。只有进程可以创建对象。特权进程有两种形式：作为全能的`root`运行的进程和那些设置了其能力设置的进程。我们将在稍后深入了解能力。现在，让我们专注于`root`。
- en: 'Let''s change the user to `root` to ensure executing the `chown` command will
    change the group of that object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将用户更改为`root`以确保执行`chown`命令将更改该对象的组：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The case for more
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于更多
- en: You can see the `GROUP` (`GID`) is now `testuser`, and things seem reasonably
    secure because in order to change the user and group of an object, you need to
    be privileged. You can only change the permission bits on an object if you own
    it, with the exception of the `root` user. This means that if you're running as
    `root`, you can do whatever you like to the system, even without permission. This
    absolute authority is why a successful attack or an error on a root running process
    can cause grave damage to the system. Also, a successful attack on a non-root
    process could also cause damage by inadvertently changing the permissions bits.
    For example, suppose there is an unintended `chmod 0666` command on your SSH private
    key. This would expose your secret key to all users on the system, which is almost
    certainly something you would never want to happen. The root limitation is partially
    addressed by the capabilities model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`GROUP`（`GID`）现在是`testuser`，看起来相当安全，因为要更改对象的用户和组，你需要有特权。你只能在拥有对象的情况下更改对象的权限位，除非是`root`用户。这意味着如果你以`root`身份运行，你可以对系统做任何你想做的事情，即使没有权限。这种绝对权力是为什么在`root`运行的进程上的成功攻击或错误可能导致系统严重损坏。此外，对非`root`进程的成功攻击也可能通过意外更改权限位造成损害。例如，假设你的SSH私钥上有未预期的`chmod
    0666`命令。这将使你的秘密密钥暴露给系统上的所有用户，这几乎肯定不是你希望发生的事情。能力模型部分解决了根限制的问题。
- en: Capabilities model
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 能力模型
- en: For many operations on Linux, the object permission model doesn't quite fit.
    For instance, changing `UID` and `GID` requires some magical `USER` known as `root`.
    Suppose you have a long running service that needs to utilize some of these capabilities.
    Perhaps this service listens to kernel events and creates the device nodes for
    you? Such a service exists, and it's called `ueventd` or user event daemon. This
    daemon traditionally runs as `root`, which means if it is compromised, it could
    potentially read your private keys from your home directory and send them back
    to the attacker. This might be an extraordinary example, but it's meant to showcase
    that running processes as `root` can be dangerous. Suppose you could start a service
    as the `root` user and have the process change its `UID` and `GID` to something
    not privileged, but retain some smaller set of privileged capabilities to do its
    job? This is exactly what the capabilities model in Linux is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux上的许多操作，对象权限模型并不完全适用。例如，更改`UID`和`GID`需要一些被称为`root`的神奇`USER`。假设你有一个需要利用这些功能的长运行服务。也许这个服务会监听内核事件并为你创建设备节点？这样的服务是存在的，它被称为`ueventd`或用户事件守护进程。这个守护进程传统上以`root`身份运行，这意味着如果它被入侵，它可能会从你的家目录中读取你的私钥并将其发送给攻击者。这或许是一个非凡的例子，但它的目的是展示以`root`身份运行进程可能会很危险。假设你可以以`root`用户启动一个服务，并且进程可以将其`UID`和`GID`更改为非特权值，但保留执行其工作所需的一小部分特权能力？这正是Linux中能力模型的目的。
- en: The capabilities model in Linux is an attempt to break down the set of permissions
    that `root` has into smaller subsets. This way, processes can be confined to the
    set of minimum privileges they need to perform their intended function. This is
    known as least privilege, a key ideology when securing systems that minimizes
    the amount of damage a successful attack can do. In some instances, it can even
    prevent a successful attack from occurring by blocking an otherwise open attack
    vector.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的能力模型是尝试将`root`拥有的权限集分解成更小的子集。这样，进程可以被限制在执行其预期功能所需的最小权限集。这被称为最小权限，是确保系统安全的关键理念，它最大限度地减少了成功攻击可能造成的损害。在某些情况下，它甚至可以通过阻止其他情况下开放的攻击向量来防止成功攻击的发生。
- en: 'There are many capabilities. The man page for capabilities is the de facto
    documentation. Let''s take a look at the `CAP_SYS_BOOT` capability:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多能力。关于能力的man页是事实上的文档。让我们看看`CAP_SYS_BOOT`能力：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This means a process running with this capability can reboot the system. However,
    that process can''t arbitrarily change `USERS` and `GROUP` as it could if it was
    running as `root` or with `CAP_DAC_READ_SEARCH`. This limits what an attacker
    can do:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着具有这种能力的进程可以重新启动系统。然而，该进程不能像作为`root`或带有`CAP_DAC_READ_SEARCH`运行时那样任意更改`USERS`和`GROUP`。这限制了攻击者能做的事情：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now suppose the case where our restart process runs with `CAP_CHOWN`. Let's
    say it uses this capability to ensure that when a restart request is received,
    it backs up a file from each user's home directory to a server before restarting.
    Let's say this file is `~/backup`, the permissions are 0600, and `USER` and `GROUP`
    are the respective user of that home directory. In this case, we have minimized
    the permissions as best we can, but the process could still access the users SSH
    keys and upload those either by error or attack. Another approach to this would
    be to set the group to `backup` and run the process with `GROUP backup`. However,
    this has limitations. Suppose you want to share this file with another user. That
    user would require a supplementary group of `backup`, but now the user can read
    *all* of the backup files, not just the ones intended. An astute reader might
    think about the `bind` mounts, however the process doing the `bind` mounts and
    file permissions also runs with some capability, and thus suffers from this granularity
    problem as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们的重启过程以`CAP_CHOWN`运行。假设它使用这种能力在收到重启请求之前，将每个用户的家目录中的文件备份到服务器上，然后再重启。假设这个文件是`~/backup`，权限为0600，`USER`和`GROUP`分别是该家目录的相应用户。在这种情况下，我们已经尽可能地最小化了权限，但进程仍然可以访问用户的SSH密钥，并可能由于错误或攻击而上传这些密钥。另一种方法是设置组为`backup`，并以`GROUP
    backup`运行进程。然而，这也有局限性。假设你想与另一个用户共享这个文件。那个用户需要`backup`的附加组，但现在该用户可以读取*所有*的备份文件，而不仅仅是那些预期的文件。一个敏锐的读者可能会想到`bind`挂载，然而执行`bind`挂载和文件权限的进程也运行在某些能力下，因此也受到这种粒度问题的困扰。
- en: The major issue, and the case for another access control system can be summarized
    by one word, *granularity*. The DAC model doesn't have the granularity required
    to safely handle complex access control models or to minimize the amount of damage
    a process can do. This is particularly important on Android, where the entire
    isolation system is dependent on this control, and a rogue root process can compromise
    the whole system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题，以及另一个访问控制系统的案例可以总结为一个词，*粒度*。DAC模型没有所需的粒度来安全地处理复杂的访问控制模型或最小化进程可能造成的损害。这在Android上尤为重要，因为整个隔离系统都依赖于这种控制，而一个恶意root进程可以破坏整个系统。
- en: Android's use of DAC
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android对DAC的使用
- en: In the Android sandbox model, every application runs as its own `UID`. This
    means that each app can separate its stored data from one another. The user and
    group are set to the `UID` and `GID` of that application, so no app can access
    the private files of an application without the application explicitly performing
    `chmod` on its objects. Also, applications in Android cannot have capabilities,
    so we don't have to worry about capabilities such as `CAP_SYS_PTRACE`, which is
    the ability to debug another application. In Android, in a perfect world, only
    system components run with privileges, and applications don't accidentally `chmod`
    private files for all to read. This issue was not corrected by the current AOSP
    SELinux policy due to app compatibility, but could be closed with SELinux. The
    proper way to share data between applications on Android is via binder, and sharing
    file descriptors. For smaller amounts of data, the provider model suffices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android沙箱模型中，每个应用程序都以自己的`UID`运行。这意味着每个应用程序都可以将其存储的数据与其他应用程序分开。用户和组被设置为该应用程序的`UID`和`GID`，因此没有应用程序可以访问另一个应用程序的私有文件，除非该应用程序明确对其对象执行`chmod`。此外，Android中的应用程序不能具有能力，所以我们不必担心像`CAP_SYS_PTRACE`这样的能力，这是调试另一个应用程序的能力。在Android中，在理想的世界里，只有系统组件运行有权限，应用程序不会意外地将私有文件`chmod`为所有用户可读。由于应用程序兼容性问题，当前AOSP
    SELinux策略没有解决这个问题，但可以通过SELinux来解决。在Android上，在应用程序之间共享数据的正确方式是通过binder和共享文件描述符。对于较小的数据量，提供者模型就足够了。
- en: Glancing at Android vulnerabilities
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速浏览Android漏洞
- en: With our newly found understanding of the DAC permission model and some of its
    limitations, let's look at some Android exploits against it. We will cover only
    a few exploits to understand how the DAC model failed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对DAC权限模型及其一些限制的新理解基础上，让我们看看一些针对它的Android漏洞。我们将只涵盖几个漏洞，以了解DAC模型是如何失败的。
- en: Skype vulnerability
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Skype漏洞
- en: CVE-2011-1717 was released in 2011\. In this exploit, the Skype application
    left a SQLite3 database world readable (something analogous to 0666 permissions).
    This database contained usernames and chat logs, and personal data such as name
    and e-mail. An application called Skypwned was able to demonstrate this capability.
    This is an example of how being able to change the permissions on your objects
    could be bad, especially when the case opens `READ` to `OTHERS`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2011-1717 于 2011 年发布。在这个漏洞利用中，Skype 应用程序留下了一个 SQLite3 数据库是可读的（类似于 0666 权限）。这个数据库包含用户名和聊天记录，以及姓名和电子邮件等个人信息。一个名为
    Skypwned 的应用程序能够展示这种能力。这是一个例子，说明了能够更改对象权限可能会很糟糕，尤其是当情况允许 `READ` 权限给 `OTHERS` 时。
- en: GingerBreak
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GingerBreak
- en: CVE-2011-1823 showcases a root attack on Android. The volume management daemon
    (vold) on Android is responsible for the mounting and unmounting of the external
    SD card. The daemon listens for messages over a NETLINK socket. The daemon never
    checked where the messages were sourced from, and any application could open and
    create a NETLINK socket to send messages to vold. Once the attacker opened the
    NETLINK socket, they sent a very carefully crafted message to bypass a sanity
    check. The check tested a signed integer for a maximum bound, but never checked
    it for negativity. It was then used to index an array. This negative access would
    lead to memory corruption and, with a proper message, could result in the execution
    of arbitrary code. The GingerBreak implementation resulted in an arbitrary user
    gaining root privileges, a textbook privilege execution attack. Once rooted, the
    device's sandboxes were no longer valid.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2011-1823 展示了对 Android 的根攻击。Android 上的卷管理守护进程（vold）负责外部 SD 卡的挂载和卸载。守护进程通过
    NETLINK 套接字监听消息。守护进程从未检查消息的来源，任何应用程序都可以打开并创建一个 NETLINK 套接字向 vold 发送消息。一旦攻击者打开了
    NETLINK 套接字，他们就会发送一个精心设计的消息来绕过健全性检查。该检查测试了一个有符号整数是否超出最大界限，但从未检查它是否为负数。然后它被用来索引一个数组。这种负访问会导致内存损坏，并且通过适当的消息，可能会导致任意代码的执行。GingerBreak
    实现导致任意用户获得 root 权限，这是一个教科书式的权限执行攻击。一旦获得 root 权限，设备的沙盒就不再有效。
- en: Rage against the cage
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 愤怒的笼子
- en: CVE-2010-EASY is a `setuid` exhaustion via fork bomb attack. It successfully
    attacks the `adb` daemon on Android, which starts life as root and downgrades
    its permissions if root is not needed. This attack keeps `adb` as `root` and returns
    a root shell to the user. In Linux kernel 2.6, the `setuid` system call returns
    an error when the number of running processes `RLIMIT_NPROC` is met. The `adb`
    daemon code does not check the return of `setuid`, which leaves a small race window
    open for the attacker. The attacker needs to fork enough processes to reach `RLIMIT_NPROC`
    and then kill the daemon. The `adb` daemon downgrades to shell `UID` and the attacker
    runs the program as shell `USER`, thus the kill will work. At this point, the
    `adb` service is respawned, and if `RLIMIT_NPROC` is maxed out, `setuid` will
    fail and `adb` will stay running as root. Then, running `adb` shell from a host
    returns a nice root shell to the user.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2010-EASY 是一种通过 fork bomb 攻击的 `setuid` 耗尽攻击。它成功攻击了 Android 上的 `adb` 守护进程，该守护进程以
    root 权限启动，如果不需要 root 权限，则降低其权限。这种攻击使 `adb` 保持 `root` 权限，并将 root shell 返回给用户。在
    Linux 内核 2.6 中，当达到运行进程数 `RLIMIT_NPROC` 时，`setuid` 系统调用返回错误。`adb` 守护进程代码没有检查 `setuid`
    的返回值，这为攻击者留下了一个小的竞争窗口。攻击者需要足够多的进程来达到 `RLIMIT_NPROC` 并杀死守护进程。`adb` 守护进程降级到 shell
    `UID`，攻击者以 shell `USER` 运行程序，因此杀死操作将成功。此时，`adb` 服务将被重新启动，如果 `RLIMIT_NPROC` 达到最大值，`setuid`
    将失败，`adb` 将以 root 权限保持运行。然后，从主机运行 `adb` shell 将返回一个漂亮的 root shell 给用户。
- en: MotoChopper
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MotoChopper
- en: CVE-2013-2596 is a vulnerability in the `mmap` functionality of a Qualcomm video
    driver. Access to the GPU is provided by apps to do advanced graphics rendering
    such as in the case of OpenGL calls. The vulnerability in `mmap` allows the attacker
    to `mmap` kernel address space, at which point the attacker is able to directly
    change their kernel credential structure. This exploit is an example where the
    DAC model was not at fault. In reality, outside of patching the code or removing
    direct graphics access, nothing but programming checks of the `mmap` bounds could
    have prevented this attack.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2013-2596 是高通视频驱动程序 `mmap` 功能中的一个漏洞。应用程序通过提供对 GPU 的访问来执行高级图形渲染，例如 OpenGL
    调用的情况。`mmap` 中的漏洞允许攻击者 `mmap` 内核地址空间，此时攻击者能够直接更改他们的内核凭证结构。这个漏洞利用是一个 DAC 模型没有错误的例子。实际上，除了修补代码或移除直接图形访问之外，没有其他方法可以防止这种攻击。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The DAC model is extremely powerful, but its lack of fine granularity and use
    of an extraordinarily powerful `root` user leaves something to be desired. With
    the increasing sensitivity of mobile handset use, the case to increase the security
    of the system is well-founded. Thankfully, Android is built on Linux and thus
    benefits from a large ecosystem of engineers and researchers. Since the Linux
    Kernel 2.6, a new access control model called **Mandatory Access Controls (MAC)**
    was added. This is a framework by which modules can be loaded into the kernel
    to provide a new form of access control model. The very first module was called
    SELinux. It is used by Red Hat and others to secure sensitive government systems.
    Thus, a solution was found to enable such access controls for Android.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: DAC模型非常强大，但其缺乏精细粒度和使用极其强大的`root`用户权限仍有待改进。随着移动电话使用的日益敏感，提高系统安全性的理由充分。幸运的是，Android是基于Linux构建的，因此受益于庞大的工程师和研究人员生态系统。自Linux内核2.6以来，增加了一个名为**强制访问控制（MAC）**的新访问控制模型。这是一个框架，通过它可以加载模块到内核中，以提供一种新的访问控制模型。第一个模块被称为SELinux。它被Red
    Hat和其他公司用于保护敏感的政府系统。因此，找到了一种方法，可以为Android启用此类访问控制。
