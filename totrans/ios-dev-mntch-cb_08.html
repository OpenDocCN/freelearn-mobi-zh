<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Integrating iOS Features"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Integrating iOS Features</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Starting phone calls</li><li class="listitem" style="list-style-type: disc">Sending text messages and e-mails</li><li class="listitem" style="list-style-type: disc">Using text messaging in our application</li><li class="listitem" style="list-style-type: disc">Using e-mail messaging in our application</li><li class="listitem" style="list-style-type: disc">Managing the address book</li><li class="listitem" style="list-style-type: disc">Displaying contacts</li><li class="listitem" style="list-style-type: disc">Managing the calendar</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Introduction</h1></div></div></div><p>Mobile devices offer a handful of features to the user. Creating an application that interacts with those features to provide a complete experience to users can surely be considered as an advantage.</p><p>In this chapter, we will discuss some of the most common features of iOS and how to integrate some or all of their functionality to our applications. We will see how to offer the user the ability to make telephone calls and send SMS and e-mails, either by using the native platform applications, or by integrating the native user interface in our projects. Also, we will discuss the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MFMessageComposeViewController:</code> This controller is suitable for sending text (SMS) messages<a id="id625" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MFMailComposeViewController:</code> This is the controller for sending e-mails with or without attachments<a id="id626" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ABAddressBook:</code> This is the class that provides us access to the address book database<a id="id627" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ABPersonViewController:</code> This is the controller that displays and/or edits contact information from the address book<a id="id628" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">EKEventStore:</code> This is the class that is responsible for managing calendar events<a id="id629" class="indexterm"/></li></ul></div><p>Furthermore, we will learn how to read and save contact information, how to display contact details, and interact with the device calendar.</p><p>Note that some of the examples in this chapter will require a device. For example, the simulator does not contain the messaging application. To deploy to a device, you will need to enroll as an iOS Developer through Apple's Developer Portal and obtain a commercial license of MonoTouch.</p></div></div>
<div class="section" title="Starting phone calls"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Starting phone calls</h1></div></div></div><p>In this recipe, we will learn how to invoke the native phone application to allow the user to place a call.<a id="id630" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec01"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> PhoneCallApp</code>.<a id="id631" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"/>Note</h3><p>The native phone application is not available on the simulator. It is only available on an iPhone device.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec02"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add a button on the view of<code class="literal"> MainController</code>, and override the<code class="literal"> ViewDidLoad</code> method. Implement it with the following code. Replace the number with a real phone number, if you actually want the call to be placed:<div class="informalexample"><pre class="programlisting">this.buttonCall.TouchUpInside += delegate {
NSUrl url = new NSUrl("tel:+123456789012");
if (UIApplication.SharedApplication.CanOpenUrl(url)){
UIApplication.SharedApplication.OpenUrl(url);
} else{
Console.WriteLine("Cannot open url: {0}", url.AbsoluteString);
}
} ;
</pre></div></li><li class="listitem"> Compile and run the application on the device. Tap the<span class="strong"><strong> Call!</strong></span> button to start the call. The following screenshot shows the phone application placing a call:</li></ol></div><div class="mediaobject"><img src="graphics/1468EXP_08_01.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec03"/>How it works...</h2></div></div></div><p>Through the<code class="literal"> UIApplication.SharedApplication</code> static property, we have access to the application's<code class="literal"> UIApplication</code> object. We can use its<code class="literal"> OpenUrl</code> method, which accepts an<code class="literal"> NSUrl</code> variable to initiate a call:<a id="id632" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">UIApplication.SharedApplication.OpenUrl(url);
</pre></div><p>Since not all iOS devices support the native phone application, it would be useful to check for availability first:</p><div class="informalexample"><pre class="programlisting">if (UIApplication.SharedApplication.CanOpenUrl(url))
</pre></div><p>When the<code class="literal"> OpenUrl</code> method is called, the native phone application will be executed, and it will start calling the number immediately. Note that the<code class="literal"> tel:</code> prefix is needed to initiate the call.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec04"/>There's more...</h2></div></div></div><p>MonoTouch also supports the<code class="literal"> CoreTelephony</code> framework, through the<code class="literal"> MonoTouch.CoreTelephony</code> namespace. This is a simple framework that provides information on call state, connection, carrier info, and so on. Note that when a call starts, the native phone application enters into the foreground, causing the application to be suspended. The following is a simple usage of the<code class="literal"> CoreTelephony</code> framework:<a id="id633" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">CTCallCenter callCenter = new CTCallCenter();
callCenter.CallEventHandler = delegate(CTCall call) {
Console.WriteLine(call.CallState);
} ;
</pre></div><p>Note that the handler is assigned with an equals sign (=) instead of the common plus-equals (+=) combination. This is because<code class="literal"> CallEventHandler</code> is a property and not an event. When the application enters into the background, events are not distributed to it. Only the last occured event will be distributed when the application returns to the foreground.<a id="id634" class="indexterm"/>
</p><div class="section" title="More info on OpenUrl"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec01"/>More info on OpenUrl</h3></div></div></div><p>The<code class="literal"> OpenUrl</code> method can be used to open various native and non-native applications. For example, to open a web page in Safari, just create an<code class="literal"> NSUrl</code> object with the following link:<a id="id635" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">NSUrl url = new NSUrl("http://www.packtpub.com");
</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec05"/>See also</h2></div></div></div><p>In this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Sending text messages and e-mails</em></span></li></ul></div></div></div>
<div class="section" title="Sending text messages and e-mails"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec03"/>Sending text messages and e-mails</h1></div></div></div><p>In this recipe, we will learn how to invoke the native mail and messaging applications within our own application.<a id="id636" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec06"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> SendTextApp</code>.<a id="id637" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec07"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add two buttons on the main view of<code class="literal"> MainController</code>. Override the<code class="literal"> ViewDidLoad</code> method of the<code class="literal"> MainController</code> class, and implement it with the following code:<div class="informalexample"><pre class="programlisting">this.buttonSendText.TouchUpInside += delegate {
NSUrl textUrl = new NSUrl("sms:");
if (UIApplication.SharedApplication.CanOpenUrl(textUrl)){
UIApplication.SharedApplication.OpenUrl(textUrl);
} else{
Console.WriteLine("Cannot send text message!");
}
} ;
this.buttonSendEmail.TouchUpInside += delegate {
NSUrl emailUrl = new NSUrl("mailto:");
if (UIApplication.SharedApplication.CanOpenUrl(emailUrl)){
UIApplication.SharedApplication.OpenUrl(emailUrl);
} else{
Console.WriteLine("Cannot send e-mail message!");
}
} ;
</pre></div></li><li class="listitem"> Compile and run the application on the device. Tap on one of the buttons to open the corresponding application.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec08"/>How it works...</h2></div></div></div><p>Once again, using the<code class="literal"> OpenUrl</code> method, we can send text or e-mail messages. In this example code, just using the<code class="literal"> sms:</code> prefix will open the native text messaging application. Adding a cell phone number after the<code class="literal"> sms:</code> prefix will open the native messaging application:<a id="id638" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">UIApplication.SharedApplication.OpenUrl(new NSUrl("sms:+123456789012"));
</pre></div><div class="mediaobject"><img src="graphics/1468EXP_08_02.jpg" alt="How it works..."/></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"/>Note</h3><p>Apart from the recipient number, there is no other data that can be set before the native text message application is displayed.</p></div><p>For opening the native e-mail application, the process is similar. Passing the<code class="literal"> mailto:</code> prefix opens the edit mail controller.</p><div class="informalexample"><pre class="programlisting">UIApplication.SharedApplication.OpenUrl(new NSUrl("mailto:"));
</pre></div><div class="mediaobject"><img src="graphics/1468EXP_08_03.jpg" alt="How it works..."/></div><p>The<code class="literal"> mailto:</code> url scheme supports various parameters for customizing an e-mail message. These parameters allows us to enter sender address, subject, and message:<a id="id639" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">UIApplication.SharedApplication.OpenUrl("mailto:recipient@example.com?subject=Email%20with%20MonoTouch!&amp;body=This%20is%20the%20message%20body!");
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec09"/>There's more...</h2></div></div></div><p>Although iOS provides access to opening the native messaging applications, pre-defining message content in the case of e-mails, this is where the control from inside the application stops. There is no way of actually sending the message through code. It is the user that will decide whether to send the message or not.</p><div class="section" title="More info on opening external applications"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec02"/>More info on opening external applications</h3></div></div></div><p>The<code class="literal"> OpenUrl</code> method provides an interface for opening the native messaging applications. Opening external applications has one drawback: the application that calls the<code class="literal"> OpenUrl</code> method transitions to the background. Up to iOS version 3.*, this was the only way of providing messaging through an application. Since iOS version 4.0, Apple has provided the messaging controllers to the SDK. The following recipes discuss their usage.<a id="id640" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec10"/>See also</h2></div></div></div><p>In this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Starting phone calls</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using text messaging in our application</em></span></li></ul></div></div></div>
<div class="section" title="Using text messaging in our application"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Using text messaging in our application</h1></div></div></div><p>In this recipe, we will learn how to provide text messaging functionality within our application using the native messaging user interface.<a id="id641" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec11"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> TextMessageApp</code>.<a id="id642" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec12"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add a button on the view of<code class="literal"> MainController</code>. Enter the following using directive in the<code class="literal"> MainController.cs</code> file:<div class="informalexample"><pre class="programlisting">using MonoTouch.MessageUI;
</pre></div></li><li class="listitem"> Implement the<code class="literal"> ViewDidLoad</code> method with the following code, changing the recipient number and/or the message body at your discretion:<div class="informalexample"><pre class="programlisting">private MFMessageComposeViewController messageController;
public override void ViewDidLoad (){
base.ViewDidLoad ();
this.buttonSendMessage.TouchUpInside += delegate {
if (MFMessageComposeViewController.CanSendText){
this.messageController = new MFMessageComposeViewController();
this.messageController.Recipients = new string[] { "+123456789012" };
this.messageController.Body = "Text from MonoTouch";
this.messageController.MessageComposeDelegate = new MessageComposerDelegate();
this.PresentModalViewController( this.messageController, true);
} else{
Console.WriteLine("Cannot send text message!");
}
} ;
}
</pre></div></li><li class="listitem"> Add the following nested class:<a id="id643" class="indexterm"/><div class="informalexample"><pre class="programlisting">private class MessageComposerDelegate : MFMessageComposeViewControllerDelegate{
public override void Finished (MFMessageComposeViewController controller, MessageComposeResult result){
switch (result){
case MessageComposeResult.Sent:
Console.WriteLine("Message sent!");
break;
case MessageComposeResult.Cancelled:
Console.WriteLine("Message cancelled!");
break;
default:
Console.WriteLine("Message sending failed!");
break;
}
controller.DismissModalViewControllerAnimated(true);
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the<span class="strong"><strong> Send message</strong></span> button to open the message controller. Tap the<span class="strong"><strong> Send</strong></span> button to send the message, or the<span class="strong"><strong> Cancel</strong></span> button to return to the application.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec13"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.MessageUI</code> namespace contains the necessary UI elements that allow us to implement messaging in an iOS application. For text messaging (SMS), we need the<code class="literal"> MFMessageComposeViewController</code> class.<a id="id644" class="indexterm"/>
</p><p>Only the iPhone is capable of sending text messages out of the box. With iOS 5, both the iPod and the iPad can send text messages, but the user might not have enabled this feature on the device. For this reason, checking for availability is the best practice. The<code class="literal"> MFMessageComposeViewController</code> class contains a static method, named<code class="literal"> CanSendText</code>, which returns a boolean value indicating whether we can use this functionality. The important thing in this case is that we should check if sending text messages is available prior to initializing the controller. This is because when you try to initialize the controller on a device that does not support text messaging, or the simulator, you will get the following message on the screen:<a id="id645" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1468EXP_08_04.jpg" alt="How it works..."/></div><p>To determine when the user has taken action in the message UI, we implement a<code class="literal"> Delegate</code> object and override the<code class="literal"> Finished</code> method:<a id="id646" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">private class MessageComposerDelegate : MFMessageComposeViewControllerDelegate
</pre></div><p>Another option, provided by MonoTouch, is to subscribe to the<code class="literal"> Finished</code> event of the<code class="literal"> MFMessageComposeViewController</code> class.<a id="id647" class="indexterm"/>
</p><p>Inside the<code class="literal"> Finished</code> method, we can provide functionality according to the<code class="literal"> MessageComposeResult</code> parameter. Its value can be one of the following three:<a id="id648" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><code class="literal"> Sent:</code> This value indicates that the message was sent successfully.</li><li class="listitem"><code class="literal"> Cancelled:</code> This value indicates that the user has tapped the<span class="strong"><strong> Cancel</strong></span> button, and the message will not be sent.</li><li class="listitem"><code class="literal"> Failed:</code> This value indicates that message sending failed.</li></ol></div><p>The last thing to do is to dismiss the message controller, which is done as follows:<a id="id649" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">controller.DismissModalViewControllerAnimated(true);
</pre></div><p>After initializing the controller, we can set the recipients and body message to the appropriate properties:</p><div class="informalexample"><pre class="programlisting">this.messageController.Recipients = new string[] { "+123456789012" };
this.messageController.Body = "Text from MonoTouch";
</pre></div><p>The<code class="literal"> Recipients</code> property accepts a string array that allows for multiple recipient numbers.<a id="id650" class="indexterm"/>
</p><p>You may have noticed that the<code class="literal"> Delegate</code> object for the message controller is set to its<code class="literal"> MessageComposeDelegate</code> property, instead of the common<code class="literal"> Delegate</code>. This is because the<code class="literal"> MFMessageComposeViewController</code> class directly inherits from the<code class="literal"> UINavigationController</code> class, so the<code class="literal"> Delegate</code> property accepts values of the type<code class="literal"> UINavigationControllerDelegate</code>.<a id="id651" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec14"/>There's more...</h2></div></div></div><p>The fact that the SDK provides the user interface to send text messages does not mean that it is customizable. Just like invoking the native messaging application, it is the user who will decide whether to send the message or discard it. In fact, after the controller is presented on the screen, any attempts to change the actual object or any of its properties will simply fail. Furthermore, the user can change or delete both the recipient and the message body. The real benefit though is that the messaging user interface is displayed within our application, instead of running separately.</p><div class="section" title="SMS only"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec03"/>SMS only</h3></div></div></div><p>The<code class="literal"> MFMessageComposeViewController</code> can only be used for sending<span class="strong"><strong> Short Message Service  (SMS)</strong></span> messages and not<span class="strong"><strong> Multimedia Messaging Service (MMS)</strong></span> .<a id="id652" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Using e-mail messaging in our application"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec05"/>Using e-mail messaging in our application</h1></div></div></div><p>In this recipe, we will learn how to use the e-mail messaging interface within an application.<a id="id653" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec15"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> EmailMessageApp</code>.<a id="id654" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec16"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add a button on the view of<code class="literal"> MainController</code> and the<code class="literal"> MonoTouch.MessageUI</code> namespace in the<code class="literal"> MainController.cs</code> file.</li><li class="listitem"> Enter the following code in the<code class="literal"> ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.buttonSendEmail.TouchUpInside += delegate {
this.mailController = new MFMailComposeViewController();
this.mailController.SetToRecipients(new string[] { "recipient@example.com" });
this.mailController.SetSubject("Email from MonoTouch!");
this.mailController.SetMessageBody("This is the message body!", false);
this.mailController.Finished += this.MailController_Finished;
if (MFMailComposeViewController.CanSendMail){
this.PresentModalViewController(this.mailController, true);
} else{
Console.WriteLine("Cannot send email!");
}
} ;
</pre></div></li><li class="listitem"> Add the following method:<div class="informalexample"><pre class="programlisting">private void MailController_Finished (object sender, MFComposeResultEventArgs e){
switch (e.Result){
case MFMailComposeResult.Sent:
Console.WriteLine("Email sent!");
break;
case MFMailComposeResult.Saved:
Console.WriteLine("Email saved!");
break;
case MFMailComposeResult.Cancelled:
Console.WriteLine("Email sending cancelled!");
break;
case MFMailComposeResult.Failed:
Console.WriteLine("Email sending failed!");
if (null != e.Error){
Console.WriteLine("Error message: {0}", e.Error.LocalizedDescription);
}
break;
}
e.Controller.DismissModalViewControllerAnimated(true);
}
</pre></div></li><li class="listitem"> Compile and run the application either on the simulator or on the device.</li><li class="listitem"> Tap the<span class="strong"><strong> Send email</strong></span> button to display the mail user interface. Send or cancel the message. The application will work on the simulator and behave just like the native mail application on devices, except for the fact that messages will not actually be sent or saved.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec17"/>How it works...</h2></div></div></div><p>The<code class="literal"> MFMailComposeViewController</code> class provides the native mail composing interface. To determine whether the device is capable of sending e-mails, we first check its<code class="literal"> CanSendMail</code> property.<a id="id655" class="indexterm"/>
</p><p>Like the<code class="literal"> MFMessageComposeViewController</code>, it contains a<code class="literal"> Finished</code> event, which we use to respond to user actions, without having to implement a<code class="literal"> Delegate</code> object. We do this inside the<code class="literal"> MailController_Finished</code> method, based on the<code class="literal"> MFComposeResultEventArgs.Result</code> property, which is of the type<code class="literal"> MFMailComposeResult</code>. Its possible values will be one of the following:<a id="id656" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Sent:</code> This value indicates that the e-mail message is queued for sending<a id="id657" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Saved:</code> This value indicates that the user tapped the<span class="strong"><strong> Cancel</strong></span> button, and the<span class="strong"><strong> Save Draft</strong></span> option of the action sheet automatically appeared<a id="id658" class="indexterm"/></li></ul></div><div class="mediaobject"><img src="graphics/1468EXP_08_05.jpg" alt="How it works..."/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Cancelled:</code> This value indicates that the user tapped the<span class="strong"><strong> Cancel</strong></span> button on the controller and selected the<span class="strong"><strong> Delete Draft</strong></span> option on the action sheet<a id="id659" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Failed:</code> This value indicates that e-mail message sending failed<a id="id660" class="indexterm"/></li></ul></div><p>After initializing the object, we can assign a recipient list, subject, and message body through the corresponding set of<code class="literal"> Set</code> prefixed methods:<a id="id661" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">this.mailController.SetToRecipients(new string[] { "recipient@example.com" });
this.mailController.SetSubject("Email from MonoTouch!");
this.mailController.SetMessageBody("This is the message body!", false);
</pre></div><p>The second parameter of the<code class="literal"> SetMessageBody</code> message, if set to<code class="literal"> true</code>, informs the controller that the message should be treated as HTML.<a id="id662" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec18"/>There's more...</h2></div></div></div><p>Apart from simple or HTML-formatted text, we can also send attachments. We can do this with the<code class="literal"> AddAttachmentData</code> method:<a id="id663" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">this.mailController.AddAttachmentData(UIImage.FromFile("image.jpg"). AsJPEG(), "image/jpg", "image.jpg");
</pre></div><p>The first parameter is of the type<code class="literal"> NSData</code> and should contain the contents of the attachment. In this case, we attach an image through the<code class="literal"> UIImage.AsJPEG()</code> method, which returns the image contents inside an<code class="literal"> NSData</code> object. The second parameter represents the<span class="strong"><strong> Multipurpose Internet Mail Extensions (MIME)</strong></span>  type of the attachment, and the third parameter its file name. The project's source code contains a full and commented example.<a id="id664" class="indexterm"/>
</p><div class="section" title="Action sheet for drafts"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec04"/>Action sheet for drafts</h3></div></div></div><p>The action sheet displayed when the user taps the<span class="strong"><strong> Cancel</strong></span> button is automatically handled by the<code class="literal"> MFMailComposeViewController</code>.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec19"/>See also</h2></div></div></div><p>In this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using text messaging in our application</em></span></li></ul></div></div></div>
<div class="section" title="Managing the address book"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec06"/>Managing the address book</h1></div></div></div><p>In this recipe, we will discuss how to access and manage the user's stored contacts in the device's address book.<a id="id665" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec20"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> AddressBookApp</code>.<a id="id666" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec21"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add a button on the view of<code class="literal"> MainController</code>. Enter the following<code class="literal"> using</code> directive in the<code class="literal"> MainController.cs</code> file:<div class="informalexample"><pre class="programlisting">using MonoTouch.AddressBook;
</pre></div></li><li class="listitem"> Override the<code class="literal"> ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.buttonGetContacts.TouchUpInside += delegate {
ABAddressBook addressBook = new ABAddressBook();
ABPerson[] contacts = addressBook.GetPeople();
foreach (ABPerson eachPerson in contacts){
Console.WriteLine(string.Format("{0} {1}", eachPerson.LastName, eachPerson.FirstName));
}
} ;
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap the<span class="strong"><strong> Get contacts</strong></span> button, and watch the contact's names displayed in MonoDevelop's<span class="strong"><strong> Application Output</strong></span> pad.</li></ol></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"/>Note</h3><p>After installation of the iOS SDK, the simulator does not contain any contacts. You can add contacts the same way you can do it on the device.</p></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec22"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.AddressBook</code> namespace contains all the classes that allow us to manage the device's address book. To access the data directly, we need an instance of the<code class="literal"> ABAddressBook</code> class:<a id="id667" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">ABAddressBook addressBook = new ABAddressBook();
</pre></div><p>To get all the contacts stored in the address book, we call its<code class="literal"> GetPeople()</code> method:<a id="id668" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">ABPerson[] contacts = addressBook.GetPeople();
</pre></div><p>This method returns an array of<code class="literal"> ABPerson</code> objects, which contains all the information of individual contacts. To read the contacts' details, we iterate over the<code class="literal"> ABPerson</code> array and get each contact's first and last names with the<code class="literal"> FirstName</code> and<code class="literal"> LastName</code> properties respectively:<a id="id669" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Console.WriteLine(string.Format("{0} {1}", eachPerson.LastName, eachPerson.FirstName));
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec23"/>There's more...</h2></div></div></div><p>To get a contact's stored phone number(s), call the<code class="literal"> GetPhones()</code> method:<a id="id670" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">ABMultiValue&lt;string&gt; phones = eachPerson.GetPhones();
Console.WriteLine(phones[0].Value);
</pre></div><p>It returns an object of type<code class="literal"> ABMultiValue&lt;string&gt;. ABMultiValue&lt;T&gt;</code> is a generic collection, especially designed for multiple address book values.</p><div class="section" title="Adding a phone number to a contact"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec05"/>Adding a phone number to a contact</h3></div></div></div><p>To add a phone number to a contact, we can use the<code class="literal"> ABPerson</code> class'<code class="literal"> SetPhones</code> method. It accepts an<code class="literal"> ABMultiValue&lt;string&gt;</code> object as its parameter, but we cannot add new values to<code class="literal"> ABMultiValue</code> objects. We can, however, write values to an<code class="literal"> ABMutableMultiValue&lt;T&gt;</code> object:<a id="id671" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">ABMutableMultiValue&lt;string&gt; newPhones = phones.ToMutableMultiValue();
</pre></div><p>This line of code creates a new instance of<code class="literal"> ABMutableMultiValue&lt;string&gt;</code> object, which we then use to add the phone number(s) we want:</p><div class="informalexample"><pre class="programlisting">newPhones.Add("+120987654321", ABPersonPhoneLabel.iPhone);
eachPerson.SetPhones(newPhones);
addressBook.Save();
</pre></div><p>The second parameter of the<code class="literal"> Add</code> method is the label the phone number will have when it is saved to the contact. It is important to call the<code class="literal"> ABAddressBook.Save()</code> method, or else the changes will not be saved.<a id="id672" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Displaying contacts"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec07"/>Displaying contacts</h1></div></div></div><p>In this recipe, we will learn how to use the native address book user interface to display contact information.<a id="id673" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec24"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> DisplayContactApp</code>. Add a button on the view of<code class="literal"> MainController</code>.<a id="id674" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec25"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Create a field in the<code class="literal"> AppDelegate</code> class for a<code class="literal"> UINavigationController:</code><a id="id675" class="indexterm"/><div class="informalexample"><pre class="programlisting">UINavigationController navController;
</pre></div></li><li class="listitem"> Instantiate the navigation controller, passing as its root controller an instance of the<code class="literal"> MainController:</code><div class="informalexample"><pre class="programlisting">this.navController = new UINavigationController(new MainController());
</pre></div></li><li class="listitem"> Set the navigation controller as the window's root view controller:<div class="informalexample"><pre class="programlisting">window.RootViewController = this.navController;
</pre></div></li><li class="listitem"> Add the namespaces<code class="literal"> MonoTouch.AddressBook</code> and<code class="literal"> MonoTouch.AddressBookUI</code> in the<code class="literal"> MainController.cs</code> file.</li><li class="listitem"> Override the<code class="literal"> ViewDidLoad</code> method of the<code class="literal"> MainController</code> class, and implement it with the following code:<div class="informalexample"><pre class="programlisting">ABAddressBook addressBook = new ABAddressBook();
ABPerson[] contacts = addressBook.GetPeople();
ABPersonViewController personController = new ABPersonViewController();
personController.DisplayedPerson = contacts[0];
this.buttonDisplayContact.TouchUpInside += delegate {
this.NavigationController.PushViewController( personController, true);
} ;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator or the device.</li><li class="listitem"> Tap the<span class="strong"><strong> Display first contact</strong></span> button to display the contact details.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec26"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.AddressBookUI</code> namespace contains the controllers that the native<code class="literal"> Contacts</code> application uses to allow the user to display and manage contacts. Each contact's details can be viewed with the<code class="literal"> ABPersonViewController</code>. This controller must be presented through a<code class="literal"> UINavigationController</code>, or else it will not display correctly.<a id="id676" class="indexterm"/>
</p><p>After initializing it, we set the<code class="literal"> ABPerson</code> object we want to be displayed to its<code class="literal"> DisplayedPerson</code> property:<a id="id677" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">ABPersonViewController personController = new ABPersonViewController();
personController.DisplayedPerson = contacts[0];
</pre></div><p>Then, we push it to the navigation controller's stack:<a id="id678" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">this.NavigationController.PushViewController(personController, true);
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec27"/>There's more...</h2></div></div></div><p>The<code class="literal"> ABPersonViewController</code> can also be used for editing. To do this, set the<code class="literal"> AllowsEditing</code> property to<code class="literal"> true:</code>
<a id="id679" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">personController.AllowsEditing = true;
</pre></div><p>The result will be exactly the same as the native<code class="literal"> Contacts</code> application:</p><div class="mediaobject"><img src="graphics/1468EXP_08_06.jpg" alt="There's more..."/></div><p>Note that changes are saved normally through the<code class="literal"> ABPersonViewController</code>.</p><div class="section" title="Other address book controllers"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec06"/>Other address book controllers</h3></div></div></div><p>The<code class="literal"> MonoTouch.AddressBookUI</code> namespace contains all the controllers we need to create our own custom contacts application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ABPeoplePickerNavigationController:</code> This is a navigation controller that displays the saved contacts. The user can select a contact from the list.<a id="id680" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ABPersonViewController</code> : This controller is described in the previous example.<a id="id681" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ABNewPersonViewController:</code> This is the controller that creates a new contact.<a id="id682" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ABUnknownPersonViewController:</code> This is the controller that is displayed with partial data for creating a new contact. This is similar to the controller that is displayed when we tap on an unknown number in the list of recent calls on the device.<a id="id683" class="indexterm"/></li></ul></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec28"/>See also</h2></div></div></div><p>In this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Managing the address book</em></span></li></ul></div></div></div>
<div class="section" title="Managing the calendar"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec08"/>Managing the calendar</h1></div></div></div><p>In this recipe, we will learn how to create an event and save it to the device's calendar database.<a id="id684" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec29"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> CalendarEventsApp</code>.<a id="id685" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"/>Note</h3><p>This project must be executed on a device. The native<code class="literal"> Calendar</code> application is not installed on the simulator.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec30"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add a button on the main view of the<code class="literal"> MainController</code>. Add the namespace<code class="literal"> MonoTouch.EventKit</code> in the<code class="literal"> MainController.cs</code> file.<a id="id686" class="indexterm"/></li><li class="listitem"> Finally, enter the following code in the<code class="literal"> ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.buttonDisplayEvents.TouchUpInside += delegate {
EKEventStore evStore = new EKEventStore();
NSPredicate evPredicate = evStore.PredicateForEvents( DateTime.Now, DateTime.Now.AddDays(30), evStore.Calendars);
evStore.EnumerateEvents(
evPredicate, delegate(EKEvent calEvent, ref bool stop) {
if (null != calEvent){
stop = false;
Console.WriteLine("Event title: {0}\nEvent start date: {1}", calEvent.Title, calEvent.StartDate);
}
} );
} ;
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the<span class="strong"><strong> Display events</strong></span> button to output the calendar events of the next 30 days in the<span class="strong"><strong> Application Output</strong></span> pad.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec31"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.EventKit</code> namespace is responsible for managing the calendar events. To read the stored events, we first initialize an<code class="literal"> EKEventStore</code> object:<a id="id687" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">EKEventStore evStore = new EKEventStore();
</pre></div><p>The<code class="literal"> EKEventStore</code> class provides us access to the stored events. To retrieve the calendar events, we need a predicate of the type<code class="literal"> NSPredicate</code>. We can create an instance through the<code class="literal"> PredicateForEvents</code> method of the<code class="literal"> EKEventStore</code> class:<a id="id688" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">NSPredicate evPredicate = evStore.PredicateForEvents(DateTime.Now, DateTime.Now.AddDays(30), evStore.Calendars);
</pre></div><p>The two first parameters are of the type<code class="literal"> NSDate</code> (which can be implicitly converted to<code class="literal"> DateTime)</code> and represent the start and end dates for which to search events. The third parameter is of the type<code class="literal"> EKCalendar[]</code>, and it is an array of the calendars to search into. To search in all the available calendars, we pass the<code class="literal"> EKEventStore.Calendars</code> property.</p><p>Finally, we call the<code class="literal"> EnumerateEvents</code> method:<a id="id689" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">evStore.EnumerateEvents(evPredicate, delegate(EKEvent calEvent, ref bool stop) {
//...
</pre></div><p>We pass the predicate we created earlier to the first parameter. The second parameter is a delegate of type<code class="literal"> EKEventSearchCallback</code>. To read each event's data, we use its<code class="literal"> EKEvent</code> object. Note that the process of enumerating calendar events is similar to the one that is used for enumerating assets from the assets library, as discussed in the previous chapter.<a id="id690" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec32"/>There's more...</h2></div></div></div><p>As well as enumerating events, the<code class="literal"> EKEventStore</code> allows us to create new ones. The following example creates and saves a new calendar event:</p><div class="informalexample"><pre class="programlisting">EKEvent newEvent = EKEvent.FromStore(evStore);
newEvent.StartDate = DateTime.Now.AddDays(1);
newEvent.EndDate = DateTime.Now.AddDays(1.1);
newEvent.Title = "MonoTouch event!";
newEvent.Calendar = evStore.DefaultCalendarForNewEvents;
NSError error = null;
evStore.SaveEvent(newEvent, EKSpan.ThisEvent, out error);
</pre></div><p>For creating a new<code class="literal"> EKEvent</code> instance, we use the<code class="literal"> EKEvent.FromStore</code> static method. We then set a start and end date, a title, and the calendar to which the event will be stored. Here, we use the default calendar that we can get with the<code class="literal"> DefaultCalendarForNewEvents</code> property of<code class="literal"> EKEventStore</code>. When we have everything set up, we call the<code class="literal"> SaveEvent</code> method to save it.</p><div class="section" title="Info on calendars"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec07"/>Info on calendars</h3></div></div></div><p>By default, the device has two calendars set up:<code class="literal"> Home</code> and<code class="literal"> Work</code>. Although we cannot create new calendars on the device, new calendars that are created on the computer that we use to synchronize the device are automatically added when syncing.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec33"/>See also</h2></div></div></div><p>In this book:</p><p>
<a class="link" href="ch07.html" title="Chapter 7. Multimedia Resources">Chapter 7</a>,Multimedia Resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Managing album items directly</em></span></li></ul></div></div></div></body></html>