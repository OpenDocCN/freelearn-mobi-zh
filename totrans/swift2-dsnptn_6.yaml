- en: Chapter 6. Behavioral Patterns – Chain of Responsibility and Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue to explore the behavioral patterns—the **chain
    of responsibility** and **command** patterns. Both of these patterns are concerned
    with passing requests to appropriate objects that will then execute the action.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between these two patterns is the way that the requests
    are passed between objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The chain of responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain of responsibility pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write an application, it may be that an event generated by an object
    needs to be handled by another object. You may also want the handle to be inaccessible
    by another object.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will notice that the chain of responsibility pattern creates
    a chain of objects in such a way that if an object of this chain cannot handle
    the request, it sends the request to the next object, the successor, until one
    of them can handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern allows an object to send a request without knowing which object
    will receive and handle it. The request is sent from one object to another, making
    them parts of a chain. Each object of this chain can handle the request, pass
    it to its successor, or do both.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to use this pattern when:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to decouple the sender of a request to its receiver, allowing other
    objects to handle the request too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects that can handle the request are part of a chain of work, the request
    passes from one object to another until at least one of these objects can handle
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to allow objects that can process requests to be ordered in a preferential
    sequence that can be reordered, without having any impact on the calling component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the generic representation of the chain of
    responsibility pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/B04852_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern has three participants, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractHandler`: This defines the interface of the requests and implements
    the association of the chain of responsibility pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteHandlers`: These objects can handle requests that they are responsible
    for. If it cannot handle the request, it passes the request to its successor or
    stops the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: The client sends the request to the first object of the chain that
    may handle the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following sequence diagram illustrates the collaboration between objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collaboration](img/B04852_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The client sends the request to the first object of the chain. Then, this request
    is propagated throughout the chain until at least one of the objects of the chain
    can handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose that you are supervising the development of a mobile application, and
    you want to handle some log messages differently, depending on the priority of
    the logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'You define three types of priority, which means three levels of loggers: `DEBUG`,
    `INFO`, and `ERROR`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the level of the log messages, you can handle it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the level (or priority) is `DEBUG`, then this will be handled by the standard
    output logger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the level is `INFO`, then we will use the standard output logger and e-mail
    logger that will send an e-mail with the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the level is `ERROR`, then all the three loggers will handle the message:
    the standard output logger, e-mail logger, and error logger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see here, we need to define a chain of objects in the following order:
    `StdOutLogger`, `EmailLogger`, and `ErrorLogger`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client will then only call the first concrete handler, the class that may
    handle the request: `StdOutLogger`.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement our pattern, we will need to prepare our abstract class first.
    Remember that with Swift, an abstract class does not really exist. We will write
    our abstract class as a class, but methods that need to be overridden will have
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, if the code of the abstract class is called instead of the one
    available in the derived class, an exception similar to the following will be
    raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now begin with the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: First, open the `ChainOfResponsibilityPattern` project that you will find in
    the `Chapter 6` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is organized with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's nothing complex here; we will define our chain and make a call to the
    `main.swift` file. The abstract class is defined in the `Logger.swift` file, and
    our three `concreteHandlers` classes have their own respective Swift files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define the abstract class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We define three static variables that will represent our different levels of
    logs: `ERROR`, `INFO`, and `DEBUG`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have two other variables that are declared, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mask**: This variable is intrinsic to the object and will be set during the
    initialization of the handler. This variable will be used to compare its value
    against the level of the received request, which means that if the mask is less
    than or equal to the level, the object will be able to handle the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next**: This variable is also intrinsic to the object and this permits the
    chaining. This variable contains the next `ConcreteHandler` where the request
    will be passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func nextHandler(…)`: This is a function that allows you to assign the next
    concrete handler to the `next` variable. Note that this function returns a logger.
    This is called `nextLogger`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if we write the following statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, `l1` is an `EmailLogger` instance and not a `StdOutLogger`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`func message(…)`: This is the main function that has the responsibility (or
    not) to process the request and/or pass it to the next object of the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeMessage(…)`: This function is called by the `message(…)`function to simulate
    the work applied on the request. Here, we will only display a message that is
    linked to the current concrete handler object. Since we are in an abstract class,
    we add a `preconditionfailure(…)` statement that will inform us that `this` function
    must be overridden in the derived class. If the code is executed and the derived
    class does not override `this` method, a fatal error will be raised, which is
    explained in the *Implementation* section of this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prepareDefaultChain(…)`: This is a class function that encapsulates the creation
    of our default chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our abstract class is now ready; we have only to write our derived classes.
    Remember that the `writeMessage(…)` function must be overridden, and we need to
    initialize the mask of our concrete handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `StdOutLogger` concrete handler, which is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `EmailLogger` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we have the `ErrLogger` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All of our concrete handlers are now ready. It is time for us to write our test
    in the `main.swift` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first prepare our chain using the `Logger` class function, `prepareDefaultChain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we send a request (a string message with a logger type) to the first
    object of the chain (`l` is `StdOutLogger`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will build and run the project. You will see the following result on
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The console output is very clear. The first handler has handled the first request
    only, and the second request has been handled by the `StdOutLogger` class and
    the `EmailLogger` class. The third request has been handled by all three handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept behind this pattern is to transform a request into an object in
    order to facilitate some actions, such as undo/redo, insertion into a queue, or
    tracking of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command pattern creates distance between the client that requests an operation
    and the object that can perform it. The request is encapsulated into an object.
    This object contains a reference to the receiver who will effectively execute
    the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The real operation is managed by the receiver and the command is like an order;
    it only contains a reference to the invoker, the object that will perform the
    action and an execute function will call the real operation on the worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern allows the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending requests to different receivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queuing, logging, and rejecting requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undoable actions (the `execute` method can memorize the state and allows you
    to go back to that state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulate a request in an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the parameterization of clients with different requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generic diagram class is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/B04852_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classes participating in this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Command`: This declares the interface for executing an operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteCommand`: This implements the `Command` interface with the `execute`
    method by invoking the corresponding operations on `Receiver`. It defines a link
    between the `Receiver` class and the action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: This creates a `ConcreteCommand` object and sets its receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoker`: This asks the command to carry out the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Receiver`: This knows how to perform the operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following sequence diagram defines the collaboration between all objects
    participating in the command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collaboration](img/B04852_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss the preceding diagram in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The client asks for a command to be executed and specifies its receivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client then sends the command to the invoker that stores it (or places it
    in a queue system if some actions needs to be performed before execution of the
    command) in order to execute it later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The invoker is then called to launch the command by invoking the execute function
    on the appropriate command object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concrete command asks the receiver to execute the appropriate operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that your company is working on a new universal controller that can
    manage up to four commands. This controller has four slots where we can add two
    commands to each of them. Near each slot, we have two buttons: the "On" and "Off"
    buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your team has already two objects and their specifications that allow a remote
    control to manipulate them:'
  prefs: []
  type: TYPE_NORMAL
- en: The objects that we will work with are a light and audio player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The light can only be turned on and off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The audio player can be turned on or off, and we can play or stop the music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your job is to conceptualize commands that will be stored in the universal remote
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: When we press the on or off button of a slot, the appropriate command should
    be sent to the appropriate device (the audio player or the light).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we will not implement the undo/redo action. We will show you
    another pattern that is dedicated to this situation in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the Xcode project called `CommandPattern.xcodeproj`. Here is the organization
    of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The structure of our project reflects the class diagram that we have seen in
    the *Design* section of the command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: We have the `Invoker` folder that contains our `UniversalRemoteController` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Receiver` folder contains two devices that will be able to receive commands
    to execute the appropriate operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Interface` folder contains the definition of a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConcreteCommand` folder contains all the commands that we want to use with
    our universal remote controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the `main.swift` file contains the code that will allow us to see the
    demo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement this example, let's begin with defining our `Command` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need an `execute()` method to execute the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we write our concrete command objects, let''s see how our `Light` and
    `AudioPlayer` objects are implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is quite simple; the `on()` function will turn on the light and the `off()`
    function will turn it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the `AudioPlayer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This object is more complex. We have the same `on()` and `off()`methods, but
    we also have the `playCD()` and `StopCD()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: We see that this object has an internal state. The state changes depending on
    the function called and the state is also used to control if the asked function
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the necessary information, we can start writing our commands.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the light. What we want is to be able to use our universal
    remote controller to turn a light on or off, depending on the button pushed near
    the slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can first write our `LightOnCommand` concrete command object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created an object called `LightOnCommand` that implements the `ICommand`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command needs to know what the receiver object is, so we pass an argument
    to it during the initialization of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, the `execute` method encapsulates the call to the `on()` function of the
    `Light` object to effectively process the command.
  prefs: []
  type: TYPE_NORMAL
- en: That's all; your `LightOnCommand` object is now ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do the same with the `LightOffCommand` class and make changes wherever it
    is appropriate in order to use the `off()` function of the `Light` object instead
    of `on()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our commands to control lights are both ready. Let's now see what we will do
    for the audio player. What we want is to be able to turn on or off the audio player,
    play, or stop music. These commands are similar to what we have already done with
    the light.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AudioPlayerOnCommand` class is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AudioPlayerOffCommand` class is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AudioPlayerPlayCdCommand` class is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AudioPlayerStopCDCommand` class is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At this point, all the commands needed are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use our remote controller that has only four slots, as shown in
    the following diagram. With the remote controller, we want to be able to manipulate
    two lights: one in the bedroom, one in the hall, and an audio player to play and
    stop music:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why not create a command that will turn on the audio player and play the music
    in the same command object? Indeed, using our remote controller to execute only
    the on or off command is useless. What we want is to play or stop the music.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you want to be able to turn on the audio player and play the CD
    only by pressing one button; in the same way, you want to be able to stop the
    CD player and turn off the audio player only by pressing one button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, we only have to encapsulate appropriate functions of the
    audio player object on the execute function of the command. When our remote controller
    will invoke the `execute` method, we will first call the `on` function of the
    `audioPlayer` class and then the `playCD()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we proceed with our `StopMusicAndSetOff` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our devices are ready to accept commands and command objects are ready. Before
    we start writing our demo code, let''s see how the remote controller works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the remote controller is initialized, the four slots have a `NoCommand`
    object that is assigned. This object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, if we do not use the `addCommandToSlot(…)` function, each button will call
    the `execute` function of the `NoCommand` object, which means that there is nothing
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: The remote controller has two buttons near each slot. Depending on the button
    and slot, `buttonOnIsPushedOnSlot(…)` or `buttonOffIsPushedOnSlot` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'As commands are stored in the `onCommands` and `offCommands` arrays, when `addCommandToSlot`
    is called, we call the `execute` command of the appropriate object. To execute
    the on command of a slot, we will run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the off command of the same slot we will also run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `slot` is the index of the button slot. Now, it is time to implement our
    demo code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our remote controller, create our `audioPlayer`, and create
    our two lights: the bedroom light and hall light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create all our command objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our commands are ready, we can assign them to the remote controller using
    the `addCommandToSlot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing that is needed for the demo is to simulate the press on each
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, note that we have not added the concurrency protection. If the command
    is used by several components, we should make sure that the concurrency protection
    is added.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we need to create a queue that will receive all the commands, execute
    them in a synchronous way, and have the first command receive in the queue, being
    the first command executed (first in first out). To see how to implement concurrency
    protection, you can check the implementation of the mediator pattern in [Chapter
    7](ch07.html "Chapter 7. Behavioral Patterns – Iterator, Mediator, and Observer"),
    *Behavioral Patterns – Iterator, Mediator, and Observer* and the note about concurrency
    protection available in the same chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Click on build and run the demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now see the following result on the console, corresponding to each
    button pressed on the universal remote controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparison between the chain of responsibility and command patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between the two patterns is the way in which the request is decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: In the chain of responsibility pattern, the request is passed to potential receivers,
    whereas the command pattern uses a command object that encapsulates a request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the difference between the chain of responsibility
    and command patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Chain of responsibility | Command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Client creates | Handler objects | Command objects |'
  prefs: []
  type: TYPE_TB
- en: '| Different kinds of | Handler classes at different levels | Command classes
    and receiver classes |'
  prefs: []
  type: TYPE_TB
- en: '| Client can work with | Multiple handlers | Different receivers |'
  prefs: []
  type: TYPE_TB
- en: '| Client calls | Handler objects | Receiver objects |'
  prefs: []
  type: TYPE_TB
- en: '| Work is done in | `HandleRequest` in a handler | `ActionToPerform` in a receiver
    |'
  prefs: []
  type: TYPE_TB
- en: '| Decision based on | Mask in handlers | Routing in commands |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope this chapter was interesting. In this chapter, we learned how to decouple
    senders and receivers in both the chain of responsibility and command patterns,
    thus improving the layering and reusability of a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore three new patterns: the iterator, mediator,
    and observer patterns that are dedicated to the communication between objects
    while maintaining their independence.'
  prefs: []
  type: TYPE_NORMAL
