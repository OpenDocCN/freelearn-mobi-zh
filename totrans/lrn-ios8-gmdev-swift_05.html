<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Animation and Particles</h1></div></div></div><p>In the previous chapter, we created a basic game. In this chapter, we will make the game more lively and the characters a little more believable. Instead of just static images, we will add animation. We will also look at SpriteKit's inbuilt particle effects creator.</p><p>For character animation, we will look at how SpriteKit creates animations and also at an external tool called <strong>Texture Packer</strong><a id="id421" class="indexterm"/>, developed by Code'n'Web. We will see how it simplifies the process of animation. We will also be covering a concept called<a id="id422" class="indexterm"/> <strong>sprite sheets</strong>, which is fundamental and is used to optimize a game's performance.</p><p>We will first look at how SpriteKit gets an inbuilt sprite sheet generator and makes the animation process simpler. Then we will look at Texture Packer, which simplifies the process even further. So let's see what a sprite sheet is.</p><p>The topics covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sprite sheet animation</li><li class="listitem" style="list-style-type: disc">Basic SpriteKit animation</li><li class="listitem" style="list-style-type: disc">Texture Packer</li><li class="listitem" style="list-style-type: disc">Creating a hero sprite sheet</li><li class="listitem" style="list-style-type: disc">Animating the hero</li><li class="listitem" style="list-style-type: disc">Particle systems</li><li class="listitem" style="list-style-type: disc">The particle designer</li><li class="listitem" style="list-style-type: disc">Creating a particle effect</li><li class="listitem" style="list-style-type: disc">Adding a particle system to the game</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Sprite sheet animation</h1></div></div></div><p>Until now, what we were<a id="id423" class="indexterm"/> doing was using a single file for the player, enemy, rocket, and bullet. Every time we create a new rocket, the game goes and gets the memory, and finds and retrieves the image. The process is repeated every time a bullet is created. This is okay for a simple game such as ours, but later, when we start creating more complex games with a lot more enemies and bullet types, the process will become very taxing on the device, and the performance of the game will be affected.</p><p>To solve this problem, sprite <a id="id424" class="indexterm"/>sheets are used. A sprite sheet contains all the images that we will use in the game in a single file, instead of 10 images sitting at 10 different memory locations. The sprite sheet image file will also be accompanied by a data file, which will contain the location and size of each of the images located in the sprite sheet. At the start of the game, the sprite sheet image and data file are loaded into the cache once. Then, every time the rocket or the bullet is called, the game knows where the sprite sheet is and simply loads the image from it.</p><p>The sprite sheet file needs to be as compact as possible, so images might be rotated to make it more compact. The data file will keep track of this, and when creating the frames in game, it will make the image upright again.</p><div><img src="img/B04014_05_01.jpg" alt="Sprite sheet animation"/></div><p>When animating in the game, each of the frames for the corresponding animation will be stored in an array and made to loop at a particular predefined speed.</p><p>Fortunately, in SpriteKit, all you have to do is provide the frames. At runtime, SpriteKit automatically creates a sprite sheet, which we can use in the game. We will use SpriteKit's inbuilt sprite<a id="id425" class="indexterm"/> sheet creator to create the enemy animation. Later, we will create the player animation using Texture Packer.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Basic SpriteKit animation</h1></div></div></div><p>To create the enemy animation, we <a id="id426" class="indexterm"/>first have to give the images to SpriteKit. Since we have to provide <strong>1x</strong> and <strong>2x</strong> images for each frame, we could create four image sets; name them <code class="literal">enemy1</code>, <code class="literal">enemy2</code>, <code class="literal">enemy3</code>, and <code class="literal">enemy4</code>; and then drag <strong>1x</strong> and <strong>2x</strong> for each set. Although it is absolutely possible to do it this way, it is highly tedious. There is an alternate, less tedious way of doing it. While naming each frame, for the <strong>1x</strong> image of a frame you can add the numbers <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>, and <code class="literal">4</code> at the end of the file to show the frame names. For the <strong>2x</strong> version of a frame, you need to add <code class="literal">@2x</code> at the end to tell SpriteKit that this file is twice the size of the original version of the image. So, for the first frame, the <strong>1x</strong> file will be <code class="literal">enemy_1.png</code>, and the filename for the <strong>2x</strong> version of the frame will be <code class="literal">enemy_1@2x.png</code> (here, I am using an underscore because the regular enemy image we used in the previous chapter was already named <code class="literal">enemy1.png</code>).</p><p>The <code class="literal">@2x</code> bit is a keyword, so make sure that you don't name your image regularly with <code class="literal">@2x</code>, as it will cause some unexpected outcomes. This naming convention should be used only if you have a <strong>1x</strong> version of an image. To tell SpriteKit which image is the <strong>2x</strong>, version you add <code class="literal">@2x</code> at the end of the file to show that this image is twice the size of the other one.</p><p>So, for creating the enemy animation, we will have four frames of animation. Thus, we will have an image for each frame. Additionally, for the <strong>2x</strong> version, we will need four more images that are twice the size, with the filename ending with <code class="literal">@2x</code>.</p><p>The frames for enemy animation are provided in this chapter's <code class="literal">Resources</code> folder. Get all the images and place them in a new folder on the desktop. Now, to tell Xcode that a sprite sheet has to be created from the images provided, click on the folder in which all the images are present and rename it to <code class="literal">enemyAnim.atlas</code>. This is very important; if you don't do this, then the sprite sheet won't be created. The folder should appear as shown in the following screenshot:</p><div><img src="img/B04014_05_02.jpg" alt="Basic SpriteKit animation"/></div><p>Drag and drop the folder<a id="id427" class="indexterm"/> into the project folder. When the window opens up, as shown in the following screenshot, make sure that the <strong>Copy items if needed</strong> box is checked and the current project is the target:</p><p> </p><div><img src="img/B04014_05_03.jpg" alt="Basic SpriteKit animation"/></div><p>
</p><p>Click on <strong>Finish</strong> to continue. Now the folder will be inside the project, and we can start adding the code to animate the enemy character. Instead of using a static image when the enemy is created, we will change the <code class="literal">addEnemy</code> function, as follows.</p><p>First, let's check whether what I said earlier is correct. If we replace the enemy variable with the name of the image of the first frame, the game should still work. So, in the place where we create an enemy, instead of passing the enemy image set, we will pass the first frame of the animation to the <code class="literal">enemyNode</code> variable. Change the line for creating the enemy node to the following in the <code class="literal">addEnemy</code> function:</p><div><pre class="programlisting">var enemyNode:SKSpriteNode = SKSpriteNode(imageNamed: "enemy_1")</pre></div><p>This won't animate the character because it is still taking only the first frame of the animation and displaying it. But at least, we can be sure that the frame is loading properly. You don't have to add the extension when passing the name, so <code class="literal">.png</code> is not required. Neither do you have to say <code class="literal">@2x</code> to load the image for a higher resolution, as SpriteKit will automatically take the absence of <code class="literal">@2x</code> to mean the <strong>1x</strong> resolution, and get the <code class="literal">@2</code> image file's name for <strong>2x</strong> resolutions.</p><p>Now let's go ahead and <a id="id428" class="indexterm"/>load the other frames so that we can animate the enemy. After the <code class="literal">addChild(enemyNode)</code> line, add the following lines of code in the <code class="literal">addEnemy</code> function:</p><div><pre class="programlisting">let textureAtlas = SKTextureAtlas(named: "enemyAnim.atlas")
var textureArray:[SKTexture] = []
        
for(var i: Int = 1; i &lt;= 4; i++){
        
    textureArray.append(textureAtlas.textureNamed("enemy_\(i)"))

}
    
let animation = SKAction.animateWithTextures(textureArray, timePerFrame: 0.2)
let animate = SKAction.repeatActionForever(animation)        
               
enemyNode.runAction(animate)</pre></div><p>First, we load the sprite sheet in a constant called <code class="literal">textureAtlas</code> using the <strong>texture atlas</strong><a id="id429" class="indexterm"/> class in SpriteKit. Wait! What is a texture atlas? Well, it is just another name for a sprite sheet. You can call it either, but they mean the same thing.</p><p>After loading the sprite sheet, we create an array to store all the textures, or the frames of the animation.</p><p>Since we have four animation frames to load, namely <code class="literal">enemy_1</code>, <code class="literal">enemy_2</code>, <code class="literal">enemy_3</code>, and <code class="literal">enemy_4</code>, we create a <code class="literal">for</code> loop and iterate from <code class="literal">1</code> to <code class="literal">4</code>. Like any array, we append the four files to the <code class="literal">textureArray</code> variable we created. We assign each texture using the <code class="literal">textureNamed</code> function of the <code class="literal">SkTextureAtlas</code> class. Similar to how we log things on the screen or change text dynamically, we use the <code class="literal">\()</code> operator to provide the names of the four files. Once the images are stored in the array, we create an action so that we can run through the frames at a certain speed. The <code class="literal">animateWithTextures</code> function of SKAction takes in an array of textures and a duration for which each frame should be displayed on the screen. So here, we give the <code class="literal">textureArray</code> variable storing all the textures, and give 0.2 or 200 milliseconds as the time for which each frame will be displayed. However, this will run the animation only once. For the animation to run again and again, we use the <code class="literal">repeatForever</code> action. So, we create a new constant called <code class="literal">animate</code> and store the <code class="literal">repeatForever</code> action in it by passing the animation to it. Finally, we run the action on the <code class="literal">enemyNode</code> variable. Now you can build and run to see the enemy character getting animated.</p><p>That's all pretty good, but<a id="id430" class="indexterm"/> there is an easier way so that we don't have to create separate sets of frames for the <strong>1x</strong> and <strong>2x</strong> resolutions for the game. Moreover, while creating the array of textures, we need to know beforehand how many frames need to be looped through in the animation. In the case of the enemy, we know that there are four frames in the animation, so we looped from <code class="literal">1</code> to <code class="literal">4</code>. What if we are not aware of this information? It may lead to errors or the animation looking clunky if we loop less or more than the total number of frames of the animation.</p><p>Therefore, to animate the player, we will be using the Texture Packer way of animating.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Exploring Texture Packer</h1></div></div></div><p>Texture Packer<a id="id431" class="indexterm"/> is a very popular piece of software that is used by industry professionals such as Disney, Zynga, and WG Games to create sprite sheets. You can <a id="id432" class="indexterm"/>download it from <a class="ulink" href="https://www.codeandweb.com/">https://www.codeandweb.com/</a>.</p><div><img src="img/B04014_05_04.jpg" alt="Exploring Texture Packer"/></div><p>This is similar to how<a id="id433" class="indexterm"/> we created the images earlier when creating enemy animations. To create sprite sheet animation using Texture Packer, you also have to create the individual frames in Photoshop or Illustrator first. I have already made them and have each of the images for the individual frames ready.</p><p>You can use the trial version of Texture Packer to follow along the tutorial. When downloading, choose the version that is suitable for your operating system. Fortunately, Texture Packer is available for all major operating systems, including Linux.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Once you have downloaded Texture Packer, you get three options: you can click to try the full version for a week, purchase the license, or click on <strong>Essential version</strong> to use a trial version. In the trial version, some professional features are disabled, so I recommend trying the professional features for a week.</p></div></div><p>Once you click on the option, you should see the interface, as shown in the following screenshot:</p><div><img src="img/B04014_05_05.jpg" alt="Exploring Texture Packer"/></div><p>Here, you can either<a id="id434" class="indexterm"/> open an existing project by clicking on the <strong>Open Project</strong> button in the bottom-left corner of the screen, or select the framework for which you wish to create the sprite sheet.</p><p>As you can see, Texture Packer supports a wide range of frameworks and formats, including Cocos2d, Unity, Corona, Swift, and many more. We need to select <strong>Swift</strong> from the list and click on <strong>Create Project</strong>.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Texture Packer has three panels; let's start from the left. The left panel will display the names of all the images that you have selected to create the sprite sheet. Here, you can drag and drop individual images or full folders containing your assets. The middle panel is a preview window. It shows you how the images are packed. The right panel gives you options to choose where you would like to store the packed texture and data file to be published, and what the format of the packed image should be. The layout section gives a lot of flexibility to set up individual images in the texture packer. Finally, we have different modes for optimizing the sprite sheets.</p></div></div><p>Let's look at some of the key items in the settings panel<a id="id435" class="indexterm"/> on the <a id="id436" class="indexterm"/>right:</p><div><img src="img/B04014_05_06.jpg" alt="Exploring Texture Packer"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Data</h2></div></div></div><p>Under <strong>Data</strong>, we define all of the information<a id="id437" class="indexterm"/> regarding the data file to be exported. This includes <strong>Data Format</strong>, <strong>Atlas Bundle</strong>, and <strong>Swift Class file</strong>. The explanation of each of these fields is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Data Format</strong>: As we saw earlier, each exported file creates a sprite sheet that has a collection of images and a data file that keeps track of the positions on that sprite sheet. The data format usually changes depending on the framework or the engine you selected. Since we selected SpriteKit initially and selected <strong>Swift</strong> as the language, the format is of type <code class="literal">swift</code>. Suppose we were using the Objective-C language. Then there is a separate option for that as well. So, be mindful while selecting the format, otherwise you will have to start over if you wish to develop the sprite sheet for another format.</li><li class="listitem" style="list-style-type: disc"><strong>Atlas Bundle</strong>: This is the location where you want the exported image and data file to be saved. So, you will get a <code class="literal">.png</code> image file and a <code class="literal">.plist</code> data file containing information about the sprite sheet once the file is published.</li><li class="listitem" style="list-style-type: disc"><strong>Swift Class file</strong>: Along<a id="id438" class="indexterm"/> with the image and the data file, Texture Packer will also create a helper class containing information that will be imported along with the image and data file to make the animation code even simpler.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Texture</h2></div></div></div><p>In the <strong>Texture</strong> section, we will specify the <a id="id439" class="indexterm"/>sprite sheet image's file details. This includes details regarding <strong>Texture Format</strong>, <strong>Png Opt Level</strong>, and <strong>Pixel format</strong>. The<a id="id440" class="indexterm"/> explanation of these fields is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Texture Format</strong>: The default is set to <code class="literal">.png</code>, but other formats are also supported. Apart from PNG, you can also use the PVR format. This format is used for data protections because it is easier to copy data from regular PNG files. Also, PVR formats provide superior image compression. However, be aware that it can be used only on Apple devices.</li><li class="listitem" style="list-style-type: disc"><strong>Png Opt Level</strong>: This is used to set the quality of the PNG file.</li><li class="listitem" style="list-style-type: disc"><strong>Pixel format</strong>: This sets the RGB format to be used. Usually, you would want this to be set at the default value.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Layout</h2></div></div></div><p>Here, we specify the layout of the sprite<a id="id441" class="indexterm"/> sheet image. The following fields can be seen in the <strong>Layout</strong> section:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Max Size</strong>: You can specify the maximum width and height of the sprite sheet, depending on the framework. Usually, all frameworks allow up to 4092 x 4092, but this mostly depends on the framework, so check the maximum size the framework allows before creating the sprite sheet.</li><li class="listitem" style="list-style-type: disc"><strong>Size constraints</strong>: Some frameworks prefer the sprite sheets to be in the POT format (or the powers of 2), that is, 32 x 32, 64 x 64, 256 x 256, and so on. If this is the case, then you need to select accordingly. Otherwise, you can choose <strong>Anysize</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Scaling variants</strong>: This is used for scaling up or scaling down the image. If you are going to be creating images for different resolutions, such as <strong>1x</strong>, <strong>2x</strong> and <strong>3x</strong>, then this option allows you to create resources, depending on the different resolutions you are developing the game for. Moreover, there will be no need to go into the graphics software, shrink the images, and pack them again for all the resolutions individually.</li><li class="listitem" style="list-style-type: disc"><strong>Algorithm</strong>: This is the code logic that will be used to create sprite sheets, and it will make sure that the images are packed in the most efficient manner. In the Basic version, you will have to use <strong>Basic</strong> from the drop-down menu, unlike the Pro version, where you can choose <strong>MaxRects</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Multipack</strong>: If the PNG <a id="id442" class="indexterm"/>image file exceeds the maximum size, then Texture Packer will automatically create an additional sprite sheet and data files for the images that it wasn't able to incorporate into the previous sprite sheet.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Sprites</h2></div></div></div><p>Here, we specify any special treatment<a id="id443" class="indexterm"/> for individual sprites in the sprite sheet. There is one field in this section:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Trim mode</strong>: Removes the extra alpha surrounding each image making the sprite sheet more compact and thereby deceasing file size even further.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Creating the hero spritesheet</h1></div></div></div><p>There is a folder <a id="id444" class="indexterm"/>called <code class="literal">heroAnim</code> in the <code class="literal">Resources</code> folder for this chapter. This folder contains another folder, which contains the individual frames for the hero's idle animations. Drag and drop the <code class="literal">heroAnim</code> folder into the left panel of Texture Packer.</p><p>You will see the folder structure of the <code class="literal">heroAnim</code> folder here. Under it, you will see the <code class="literal">idle</code> folder where you will see the individual files for the frames. In the preview pane, you will see the preview of the sprite sheet that will be created from the images provided.</p><p>In the <strong>Layout</strong> section, click on the <strong>Scaling variants</strong> button. From the drop-down list in the pre-sets, select <strong>SpriteKit @2x/@1x</strong>. This will automatically create sprite sheets for both <strong>2x</strong> and <strong>1x</strong> resolutions by scaling down the image by 50 percent and saving it for the <strong>1x</strong> mode.</p><div><img src="img/B04014_05_07.jpg" alt="Creating the hero spritesheet"/></div><p>Next, under the<a id="id445" class="indexterm"/> data heading, select the location where you want the sprite sheet image and data file to be saved. The files will be saved in the location inside a folder with the <code class="literal">.atlasc</code> extension, and this folder will contain the image and data files. Next, select the location for the class file to be saved. You can save it to whichever location you want, but make sure that you remember where you have saved it because it will be required later.</p><p>Also make sure that you save the current file at some location so that if you want to make some changes to the file later, you will be able to open it and make the changes with ease. One thing to note is that if you change the location of the <code class="literal">heroAnim</code> folder, then the reference will be lost and you will have to reimport the image. Keep the images, sprite sheet, class, and Texture Packer file in a separate folder so that all of the relevant data for the file is in the same directory.</p><p>Finally, to create the <a id="id446" class="indexterm"/>sprite sheet, click on the <strong>Publish Sprite Sheet</strong> button at the top. Now we can animate the hero.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Animating the hero</h1></div></div></div><p>To animate the hero in<a id="id447" class="indexterm"/> the game, drag the <code class="literal">.atlasc</code> folder and the Swift class file into the project. Then, in the <code class="literal">init</code> function, add the following code right after adding the hero to the scene:</p><div><pre class="programlisting">let heroAtlas = heroAnim()
let heroIdleAnimArray = heroAtlas.hero_Idle_()
let animaiton = SKAction.animateWithTextures(heroIdleAnimArray, timePerFrame: 0.2)
let animate = SKAction.repeatActionForever(animaiton)
hero.runAction(animate)</pre></div><p>And that's all! You can build and run the game to see the hero getting animated.</p><p>Here, we first create a reference to the Swift class that was created in Texture Packer. Next, we create a constant called <code class="literal">heroIdleArray</code> and assign the array for the idle animation that is already created in the <code class="literal">heroAnim.swift</code> class. If this wasn't there, then we would have had to manually create an array and store the frames, as we did for the enemy. The next three steps are exactly the same as how we created the animation for the enemy. We create an animation constant, pass the array and the delay that we want for each frame, then create another action to repeat the animation over and over, and finally run the animation of the hero.</p><p>So, we see that we didn't have to create two sets of images, as Texture Packer created them for us, and we didn't have to create an array for the idle animation either. This becomes even more important if we later have to create a run, walk, jump, or attack animation. We can't be creating an array each time. In fact, in other frameworks, that's what needs to be done if we want to create different animations.  This process is so much easier using Texture Packer for SpriteKit.</p><p>Let's look at the Swift class created by Texture Packer so that you can get a better understanding of what is happening and how the array is created. So, open the <code class="literal">heroAnim.swift</code> file:</p><div><pre class="programlisting">// Sprite definitions for 'heroAnim'
// Generated with TexturePacker 3.6.0
//
// http://www.codeandweb.com/texturepacker
// ---------------------------------------

import SpriteKit


class heroAnim {

    // sprite names
    let HERO_IDLE_1 = "hero_Idle_1"
    let HERO_IDLE_2 = "hero_Idle_2"
    let HERO_IDLE_3 = "hero_Idle_3"
    let HERO_IDLE_4 = "hero_Idle_4"


    // load texture atlas
    let textureAtlas = SKTextureAtlas(named: "heroAnim")


    // individual texture objects
    func hero_Idle_1() -&gt; SKTexture { return textureAtlas.textureNamed(HERO_IDLE_1) }
    func hero_Idle_2() -&gt; SKTexture { return textureAtlas.textureNamed(HERO_IDLE_2) }
    func hero_Idle_3() -&gt; SKTexture { return textureAtlas.textureNamed(HERO_IDLE_3) }
    func hero_Idle_4() -&gt; SKTexture { return textureAtlas.textureNamed(HERO_IDLE_4) }


    // texture arrays for animations
    func hero_Idle_() -&gt; [SKTexture] {
        return [
            hero_Idle_1(),
            hero_Idle_2(),
            hero_Idle_3(),
            hero_Idle_4()
        ]
    }


}</pre></div><p>I named the <a id="id448" class="indexterm"/>class <code class="literal">heroAnim</code> while creating the file in Texture Packer, so that is why the name of the class is the same as what I named it. Secondly, you will notice that the four images that we used to create the sprite sheet are named <code class="literal">hero_idle_1</code>, <code class="literal">hero_idle_2</code>, <code class="literal">hero_idle_3</code>, and <code class="literal">hero_idle_4</code>. So, at the start of the class, it automatically creates constants for the four filenames equal to the string names.</p><p>Then the class creates an <code class="literal">SKTextureAtlas</code> constant called <code class="literal">textureAtlas</code>. This texture atlas is created from the <code class="literal">heroAnim.atlasc</code> folder. So, although the name is the same as that of the class, this is the sprite sheet file; don't get confused.</p><p>After getting the texture atlas, four functions are created to get the four images stored in the texture atlas with the constant names defined earlier. Then a new function is finally created, which adds the four images into an array and returns the array. This function is named similar to how we named the image files that were used to create the animation. This makes it convenient to know the name of the function to call when assigning the array while creating the animation action. Also remember that all of this is done automatically in Texture Packer.</p><p>Apart from the idle animation, if we have two images for the run cycle and call them <code class="literal">heroRun1.png</code> and <code class="literal">heroRun2.png</code>, then the function that will return the <code class="literal">run</code> array will be called <code class="literal">heroRun()</code>. An easy way to remember this would be to replace any number with open and closed brackets to get the function name and the array of frames.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>It is also important to note this: while naming your images required for creating the frames for animation, make sure you use the same naming convention for all the frames, just like the case of naming the frames. For example, while naming frames for animation, I usually name the files in the form of <code class="literal">name_action_number</code>. It can also be like <code class="literal">nameActionNumber</code>, as we named the run animation example, but make sure you are consistent.</p></div></div><p>It is also important to make sure that the numbering of the files is in the order in which you want the animation to be played. This is because when the animation is played, frame 1 will be played first, then frame 2, then frame 3, and so on. If your image is incorrectly numbered, the animation will be played in that order and it might look a little funny when it gets played.</p><p>These are the only things that you need to be careful about. If you are consistent in naming and numbering your files, then correctly creating animations in Texture Packer is a breeze. Texture Packer does most of the dirty work for you and leaves no room for error as it mostly <a id="id449" class="indexterm"/>automates the process for you.</p><p>Now let's look at how to create particles in a game.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Particle systems</h1></div></div></div><p>A <strong>particle system</strong><a id="id450" class="indexterm"/> is a collection of sprites or particles. Each particle system has an emitter from where the particles will be created. A particle system also determines the behavior of the particles in the system. Hence it can be said that a particle is the smallest entity that creates the particle system.</p><p>A very easy example of a particle system is Rain. <strong>Rain</strong> <a id="id451" class="indexterm"/>is a particle system in which each rain drop is a particle and a cloud has a lot of emitters from where the droplets, or particles, are created.</p><p>We create a particle system instead of creating individual particles because with a particle system, we can create different kinds of effects using the same particle. For example, we saw Rain, which is a particle system. What if we wanted another effect, such as water coming out of the faucet? Here, the particle is the same—a water droplet—but a rain droplet behaves differently. When water is falling from the faucet, each drop falls with a force and is created with a single emitter—the faucet outlet. So, we can change the particle system to have one emitter and give the particles an initial downward force. In this way, we will have the same particle behaving differently, instead of coding the system from scratch again.</p><p>In SpriteKit, as in any other framework, each particle is an image that is controlled by a particle system that has one or more emitters. An <strong>emitter</strong><a id="id452" class="indexterm"/> controls the spawning, movement, and destruction of the particle system.</p><p>For rendering the particle system, a <strong>SpriteKit particle file</strong> (<code class="literal">.sks</code>)<a id="id453" class="indexterm"/> is created. It can contain a particle system of any size, and allows for rotation and scaling of the entire particle system.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Designing particles</h2></div></div></div><p>SpriteKit has an inbuilt <a id="id454" class="indexterm"/>particle designer. This designer has a pretty good user interface that can be used to create your own particle systems. SpriteKit also includes a number of default particle systems that are already included and can be created by selecting the particle system that you want for your game from the drop-down menu.</p><p>To create a new particle system, go to <strong>File</strong> and select <strong>New File</strong>. You can also create a new file by right-clicking on the root folder of your project. In the <strong>iOS</strong> panel on the left, select <strong>Resource</strong>, then select <strong>SpriteKit Particle File</strong>, and click on <strong>Next</strong>.</p><div><img src="img/B04014_05_08.jpg" alt="Designing particles"/></div><p>Now, from the drop-down <a id="id455" class="indexterm"/>menu, you can select from the eight default particle systems that come included in SpriteKit. You can select from <strong>Bokeh</strong>, <strong>Fire</strong>, <strong>Fireflies</strong>, <strong>Magic</strong>, <strong>Rain</strong>, <strong>Smoke</strong>, <strong>Snow</strong>, and <strong>Spark</strong>:</p><div><img src="img/B04014_05_09.jpg" alt="Designing particles"/></div><p>For this example, I selected <strong>Fire</strong>. Once you have selected the particle system of your choice, click on <strong>Next</strong>. We will have to give the particle system a filename that we can call it by later when we want to create that effect in the game, so I named it <code class="literal">fireParticle</code>.</p><div><img src="img/B04014_05_10.jpg" alt="Designing particles"/></div><p>Once you're done, you <a id="id456" class="indexterm"/>will see a <code class="literal">fireParticle.sks</code> file created in your project and the fire particle burning bright in the editor panel. By default, it is created in the center of the screen. Click anywhere in the editor panel and the fire particle system will be moved to that location. You can also click and move the mouse around to see that the particle system moves along with the mouse arrow.</p><p>You will also see that the <strong>Utilities</strong> panel has changed and a whole bunch of variables with changeable parameters have appeared. You can change these parameters to create your own custom particle system.</p><p>Let's go through each of these basic parameters so that you can understand what each of these variables do and how, by changing each of the parameters, the behavior of the particle system can be changed.</p><div><img src="img/B04014_05_11.jpg" alt="Designing particles"/></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec18"/>Name</h3></div></div></div><p>If we want to refer to the particle<a id="id457" class="indexterm"/> system by name in code, we can give a name here so that we can refer to it later. Similar to how we gave a name to the <code class="literal">enemyNode</code> to check whether the node passed to the <code class="literal">movingSprite</code> class was the enemy, and then we perform a certain function based on that information.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Background</h3></div></div></div><p>The <strong>Background</strong> parameter sets the color of the <a id="id458" class="indexterm"/>background. Changing it doesn't affect the particle. It is purely for the purpose of visibility. If your particles are black, you can change the background to white so that you can see clearly how the particle looks and behaves.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec20"/>Particle Texture</h3></div></div></div><p>The <strong>Particle Texture</strong> parameter is the texture <a id="id459" class="indexterm"/>or image that will be displayed for each particle. Currently <code class="literal">spark.png</code> is used as the texture. You can change this to the enemy, bullet, rocket, or hero image if you want to.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec21"/>Particles</h3></div></div></div><p>The <strong>Particles</strong> parameter controls the<a id="id460" class="indexterm"/> rate at which particles are emitted and the number of particles you want the emitter to emit. To control the rate, you can increase or decrease the birth rate parameter. We can decrease the rate of emission to decrease the value of the birth rate, or if we want the particles to be emitted faster, we can increase it. To cap the number of particles, we change the maximum value to the number of particles we want the emitter to emit. If we want the emitter to continuously emit particles, we keep the value at 0.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec22"/>Lifetime</h3></div></div></div><p>When a particle is created, <strong>Lifetime</strong> decides<a id="id461" class="indexterm"/> for how long it stays on the screen before getting deleted. Here, every particle stays on the screen for 2.5 seconds. <strong>Range</strong> is used to bring in some randomness in the particles' behavior. Suppose we change this range value to 1. Then some particles will be on the screen for 2.0 seconds while others will be there for 3.0 seconds, before getting deleted. So, the random value created is plus or minus half of the range value in addition to the initial value.</p><p>This is how <strong>Range</strong> works: it takes the first value then gets a value by either adding or subtracting half of the range value from it so that it will look as if each particle has a different lifetime, as in life, not all particles behave in the same way.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec23"/>Position Range</h3></div></div></div><p>The default position at the beginning<a id="id462" class="indexterm"/> is the center of the screen. By looking at the <strong>Position Range</strong> keyword in the name of the variable, you might have guessed that the value that we are inputting is range value. Here, the <code class="literal">x</code> value is <code class="literal">55.65</code>, which means that when a particle is being spawned, it spawns anywhere between <code class="literal">-27.825</code> to <code class="literal">+27.825</code> in the <em>x</em> direction from the center. The emission point is denoted by a small green dot on the editor view. The <code class="literal">y</code> value is <code class="literal">5</code>, which means that from the center, the particle will be generated anywhere between <code class="literal">-2.5</code> and <code class="literal">+2.5</code> in the <em>y</em> direction. If you change the <code class="literal">X</code> and <code class="literal">Y</code> values to <code class="literal">0</code>, you will see all particles getting emitted from the green dot.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Angle</h3></div></div></div><p>The <strong>Angle</strong> parameter determines the <a id="id463" class="indexterm"/>angle at which the particles are created. Since we want the flames to start moving up in this case, the angle is approximately 90 degrees. You can change this value to <code class="literal">45</code> as well, which will make it look as if there was some wind acting on the fire. To add some randomness to the initial angle, the range is kept at <code class="literal">20</code>. Otherwise, all particles will be going straight up, which will look very unnatural.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec25"/>Speed</h3></div></div></div><p>This is the speed at which the <a id="id464" class="indexterm"/>particles will start moving when created. Here, they start moving at an average speed of 100. There is a range of 50, which means that some will move at the minimum speed of 75 and others will move at the maximum of 125.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec26"/>Acceleration</h3></div></div></div><p>We can accelerate a particle in<a id="id465" class="indexterm"/> the <em>x</em> and <em>y</em> directions, for example, in the case of a jet engine or a comet. To create this effect, you have to change the <code class="literal">X</code> position's range to <code class="literal">5</code> and increase the <code class="literal">Y</code> acceleration to around <code class="literal">500</code>.</p><div><img src="img/B04014_05_12.jpg" alt="Acceleration"/></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec27"/>Alpha</h3></div></div></div><p>This defines the level of opacity or<a id="id466" class="indexterm"/> transparency of each particle. If the value of <strong>Alpha</strong> is zero, then the particle will be completely transparent, while <code class="literal">1</code> means that it will be completely visible. There is also a <strong>Range</strong> value that you can specify. The <strong>Speed</strong> parameter determines the rate at which the <strong>Alpha</strong> value of each particle changes per second. So, it starts visible as soon as it is created, and over a period of time, it becomes transparent as the value of <strong>Alpha</strong> is reduced.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec28"/>Scale</h3></div></div></div><p>Similar to <strong>Alpha</strong>, the <strong>Scale</strong> value ranges<a id="id467" class="indexterm"/> from <code class="literal">0</code> to <code class="literal">1</code>. At <code class="literal">0</code>, the image is completely invisible; and at <code class="literal">1</code>, it is at its original size. Thus, at <code class="literal">0.5</code> the object will be half the size; and at <code class="literal">2.0</code>, it will be double the size in both the <code class="literal">x</code> and <code class="literal">y</code> directions. Here, the object has a start value of 0.5 and a range of 0.4. So, the initial start size of any particle will be between <code class="literal">0.3</code> and <code class="literal">0.7</code>. Since <strong>Speed</strong> is <code class="literal">-0.5</code>, it will slowly become smaller over a period of time after it has spawned.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec29"/>Rotation</h3></div></div></div><p>As soon as a particle is created, we can make<a id="id468" class="indexterm"/> it rotate by giving it a start value and a range to generate random speeds of rotation. We can also increase or decrease the speed of rotation over a period of time by changing the <strong>Speed</strong> parameter.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec30"/>Color Blend</h3></div></div></div><p>Color Blend is used to blend <a id="id469" class="indexterm"/>one color with another. Here, the initial factor is <code class="literal">1</code> and <strong>Range</strong> is <code class="literal">0</code>, so we are using the original color that is assigned. Since we are not color blending, we have kept the <strong>Speed</strong> value as <code class="literal">0</code>. We can change the speed to <code class="literal">-0.125</code> to see that the color slowly blends to white, and the colors become lighter at the end of the particle's life cycle.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec31"/>Color Ramp</h3></div></div></div><p>Here, we can specify the color<a id="id470" class="indexterm"/> of the particle to be generated. The particle texture image is always kept white so that we have the liberty to change the color of the object in code whenever we want. So here, even though the texture or image color is white, the color of the flame is orange.</p><p>We can also assign different colors to the particle at different stages of its life.</p><div><img src="img/B04014_05_13.jpg" alt="Color Ramp"/></div><p>The other four variables—<strong>Blend Mode</strong>, <strong>Field Mask</strong>, <strong>Custom Shader</strong>, and <strong>Custom Shader Uniform</strong>—pertain to shaders and shader programming, which is beyond the scope of this book. Using shaders, you can create custom effects and behavior for the particles.</p><p>You can play around<a id="id471" class="indexterm"/> with <strong>Blend Mode</strong> a little if you know how it works, as it is very similar to what you see in Photoshop. If you know Photoshop, you will be familiar with <strong>Add</strong>, <strong>Subtract</strong>, <strong>Multiply</strong>, <strong>Screen</strong>, <strong>Replace</strong>, and <strong>Alpha</strong>. You can select each of these and see the effect it has on the particle system.</p><p>That is all of the information required for now for designing our own particle system for the game. Let's now create the particle system that we will be using in the game.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Creating particle effects</h1></div></div></div><p>For the game, we will be <a id="id472" class="indexterm"/>creating a very simple explosion particle system, and it will be shown every time the hero fires a rocket. We will be using our own custom sprite for the image. So, go to the resources folder for the chapter and drag and drop the <code class="literal">smoke.png</code> image into the project. Don't forget to add it as a copy, and make sure that the current game is the target.</p><p>Now create a new particle system, name the file <code class="literal">explosionParticle</code>, and save it to your project. You can use fire, smoke, or any of the default particle systems. It doesn't matter, as we will be changing the values to our specification anyway.</p><div><img src="img/B04014_05_14.jpg" alt="Creating particle effects"/></div><p>In the preceding screenshot, you<a id="id473" class="indexterm"/> can see the parameters of the particle system I created using the default particle as a base.</p><p>I named it <code class="literal">explosionParticle</code> just in case I have to refer to the particle system in code. Then I kept the background as default, as I was still able to see the particle quite clearly.</p><p>I changed the texture to the smoke image file that was imported earlier, and replaced the default image with it. For <strong>Birthrate</strong>, I kept the value at approximately <code class="literal">65</code>; you can change it as per your needs. I kept the maximum number of particles at <code class="literal">12</code> so that after creating 12 particles, the emitter will stop creating any new particles.</p><p>The <strong>Lifetime</strong> parameter is kept at around <code class="literal">8</code> and <strong>Range</strong> at around <code class="literal">16</code>. You might say that some particles might be destroyed as soon as they are created. Well, that is true and it is also true about smoke particles in general. There are some particles in smoke that we don't even get to see when a gun is fired, so the behavior will be realistic even though it looks cartoony.</p><p>The <strong>Position Range</strong> parameter is approximately <code class="literal">4</code> along the <code class="literal">x</code> direction and <code class="literal">9</code> along the <code class="literal">y</code> direction. This is just to create the particle at a random position around the initial position specified so that all particles don't look as if they were emerging from the same point.</p><p>The <strong>Angle</strong> parameter is kept between <code class="literal">0</code> and <code class="literal">360</code>, as we want the smoke particles to move in all directions around the point at which they were created.</p><p>The <strong>Speed</strong> parameter of each particle at the start is kept at approximately <code class="literal">48</code>, and the <strong>Range</strong> is about <code class="literal">90</code>. This will make some particles move slower and others a lot faster. In fact, some particles may not move at all or move very slowly, making the behavior more realistic once again.</p><p>The <strong>Acceleration</strong> <a id="id474" class="indexterm"/>parameter is kept at <code class="literal">0</code> for both the <strong>X</strong> and <strong>Y</strong> directions, as it is not required, but you can tinker with these values to see whether you like the effect.</p><p>As we want the smoke particle to fade slowly, we assign an initial value and range, and reduce the value of the alpha by slowly reducing its value by increasing the <strong>Speed</strong> parameter to <code class="literal">-1</code>. Since the size of the image is huge, I scaled it to <code class="literal">0.25</code> to make it smaller and gave it a range so that the size is randomized. I changed the speed value to <code class="literal">-0.125</code> so that the size of each particle slowly reduces over a period of time.</p><p>The particle needs to rotate as soon as it is created, so I gave it an initial value and <strong>Range</strong>. I increased the <strong>Speed</strong> parameter so that the particle rotates faster over a period of time.</p><p>As I am not color blending, I kept the factor at <code class="literal">1</code> and the range and speed at <code class="literal">0</code>. I changed the color of the particle to a shade of light blue to make it look cartoony. Black would have been a little too dark and more realistic.</p><p>Finally, I changed <strong>Blend Mode</strong> to <strong>Alpha</strong> because I didn't want additive blend mode. You can make the required changes to<a id="id475" class="indexterm"/> your particle file and press <em>command</em> + <em>S</em> to save the file.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Adding a particle system to the game</h1></div></div></div><p>The file particle<a id="id476" class="indexterm"/> system is now ready to be called in to the game. So, open<a id="id477" class="indexterm"/> the <code class="literal">GameplayScene.swift</code> file and, in the <code class="literal">addRocket</code> function, add the following code right after where we added the rocket to the scene:</p><div><pre class="programlisting">let explosionParticle = SKEmitterNode(fileNamed: "explosionParticle")

explosionParticle.position = CGPoint(x: hero.position.x + hero.size.width/2 + 10, y: hero.position.y - 5)

self.addChild(explosionParticle)   </pre></div><p>Here, we create a new constant called <code class="literal">explosionParticle</code> of the <code class="literal">SKEmitterNode</code> type, and pass the filename for the particle system we created earlier. Whenever you want to create a particle system, you will have to use <code class="literal">SKEmitterNode</code>.</p><p>Next, we place the particle system at the nozzle of the hero's bazooka. This is similar to how we placed the hero's rockets. Finally, we add the particle to the scene.</p><p>We don't have to worry about removing each particle, as the particle system will take care of that automatically. As each particle reaches the end of its lifetime, it is automatically removed from the scene.</p><p>You can build and run the game now, but you will see that the particle system takes a bit of time to create the particles. To make it look as if it is getting created instantaneously, we will add the following highlighted code after adding the particle to the scene:</p><div><pre class="programlisting">self.addChild(explosionParticle)   
<strong>explosionParticle.advanceSimulationTime(0.25)</strong>
</pre></div><p>This line will fast forward the simulation to 0.25 seconds after creating the particle so that it looks as if the particles are getting created instantaneously. Build and run the game again to see the particles in action.</p><div><img src="img/B04014_05_15.jpg" alt="Adding a particle system to the game"/></div><p>There are some <a id="id478" class="indexterm"/>additional parameters and properties present in the <a id="id479" class="indexterm"/>particle designer, such as <code class="literal">advanceSimuationTime</code>, that can be called and modified only in code. But it is better to design the majority of the particle through the designer and fine-tune it in code later when it is added to the scene.</p><p>Now, if you want, you can create the particle system using code and define the parameters individually through the code, as shown in the following snippet, which will give the same result:</p><div><pre class="programlisting">let explosionParticle = SKEmitterNode()
explosionParticle.particleTexture = SKTexture(imageNamed: "smoke")
explosionParticle.particleBirthRate = 65.5
explosionParticle.numParticlesToEmit = 12
explosionParticle.particleLifetime = 8.841
explosionParticle.particleLifetimeRange = 16
explosionParticle.particlePositionRange = CGVector(dx:5.0, dy: 9.0)
explosionParticle.emissionAngle = 0
explosionParticle.emissionAngleRange = 360
explosionParticle.particleSpeed = 48
explosionParticle.particleSpeedRange = 90
explosionParticle.xAcceleration = 0
explosionParticle.yAcceleration = 0
explosionParticle.particleAlpha = 1.0
explosionParticle.particleAlphaRange = 0.2
explosionParticle.particleAlphaSpeed = -1.0
explosionParticle.particleScale = 0.25
explosionParticle.particleScaleRange = 0.125
explosionParticle.particleScaleSpeed = -0.125
explosionParticle.particleRotation = 60
explosionParticle.particleRotationRange = 60
explosionParticle.particleRotationSpeed = 5.0
explosionParticle.particleColorBlendFactor = 1.0
explosionParticle.particleColorBlendFactorRange = 0
explosionParticle.particleColorBlendFactorSpeed = 0
explosionParticle.particleColor = UIColor(red: 0.455, green: 0.784, blue: 0.835, alpha: 1.0)
explosionParticle.particleBlendMode = SKBlendMode.Alpha
        
explosionParticle.position = CGPoint(x: hero.position.x + hero.size.width/2 + 10,
            y: hero.position.y - 5);
self.addChild(explosionParticle)
        
explosionParticle.advanceSimulationTime(0.25)</pre></div><p>These are literally<a id="id480" class="indexterm"/> the same variables and parameters. The only <a id="id481" class="indexterm"/>difference is that here, it is in code format. Obviously, creating the particles using the designer is more convenient.</p><p>There are additional commands that can be used on the particle system that are available for your convenience at Apple's developer portal. You might want to go through it and experiment if you are interested.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Summary</h1></div></div></div><p>In this chapter, we saw how to use actions and sprite sheets to create animation in the game. We looked at SpriteKit's inbuilt sprite sheet generator, and we used a professional tool called Texture Packer to create a sprite sheet. We also saw how easy it is to generate sprite sheets and animations using this professional tool.</p><p>In addition to that, we saw an introduction to SpriteKit's particle designer, and created and implemented a particle system in the game.</p><p>There is still something missing in the game, however, and that is sound and font customization. We will be looking at this in the next chapter, which includes how to add the final touches to the game.</p></div></body></html>