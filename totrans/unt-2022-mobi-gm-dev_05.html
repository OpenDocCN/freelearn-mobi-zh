<html><head></head><body>
		<div><h1 id="_idParaDest-73" class="chapter-number"><a id="_idTextAnchor195"/>5</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor196"/>Advanced Mobile UI</h1>
			<p>In the last chapter, we were introduced to the Unity UI system and how to build resolution-independent UI elements, which are useful for all game projects that utilize different aspect ratios and resolutions. In this chapter, we will be exploring some mobile-specific aspects of working on a UI, such as requiring on-screen controls and adapting our UI to fit devices with notches.</p>
			<p>This chapter will be split into a number of topics. The chapter is a simple step-by-step process from beginning to end. The following is the outline of our tasks:</p>
			<ul>
				<li>Adding a pause screen button</li>
				<li>Implementing an on-screen joystick</li>
				<li>Adapting GUIs for notch devices</li>
			</ul>
			<p>Over the course of this chapter, we will take the pause screen that we implemented in the previous chapter and adapt it to work on a mobile device. We will then implement an on-screen joystick as an additional movement option, and lastly, have our UI automatically adapt to fit mobile devices that have notches.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor197"/>Technical requirements</h1>
			<p>This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should work with minimal changes in future versions of the editor. If you would like to download the exact version used in this book, and there is a new version out, you can visit Unity’s download archive at <a href="https://unity3d.com/get-unity/download/archive">https://unity3d.com/get-unity/download/archive</a>. You can also find the system requirements for Unity at <a href="https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html">https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html</a> in the <strong class="bold">Unity Editor system </strong><strong class="bold">requirements</strong><strong class="bold"> </strong>section.</p>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor198"/>Adding a pause screen button</h1>
			<p>While many mobile games do <a id="_idIndexMarker386"/>support controllers through Bluetooth, most, if not all, of them allow the users to control the game via just the device. Increasingly, many mobile games will include on-screen buttons or analog sticks that players can use to control their avatars. In this section, we will see just how we can implement that if we wish.</p>
			<p>To start off, let’s build a pause menu button:</p>
			<ol>
				<li>Since we are going to be creating multiple types of on-screen controls, let’s create a panel to hold them all. From the <code>On Screen Controls</code>. From the <strong class="bold">Inspector</strong> view, remove or disable the <strong class="bold">Image</strong> component, as we don’t need to see the image.</li>
			</ol>
			<p>For this version of our controls, we will be using some 2D sprites to make it easier to tell what the various UI elements are. The sprites are included in the example code for this book if you’d like to use the exact ones I’m using.</p>
			<ol>
				<li value="2">From the <code>Sprites</code> and drag and drop the image files into the newly added folder. Since our project is a 3D one, Unity assumes we want them to be textures, but we want to use them with Unity’s UI system. With that in mind, select all three sprites. From the <strong class="bold">Inspector</strong>, change <strong class="bold">Texture Type</strong> to <strong class="bold">Sprite (2D and UI)</strong>, then scroll all the way down, and then hit the <strong class="bold">Apply</strong> button.</li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">The sprites used here are from <em class="italic">Kenney’s Onscreen Controls</em> pack. There are seven other possible styles that you could use, which are available from <a href="https://kenney.nl/assets/onscreen-controls">https://kenney.nl/assets/onscreen-controls</a>.</p>
			<ol>
				<li value="3">Now that we have the sprites, let’s build our first UI element, a pause button. From the <strong class="bold">Hierarchy </strong>view, right-click on the <strong class="bold">On Screen Controls </strong>object and select <strong class="bold">UI </strong>| <strong class="bold">Button - </strong><strong class="bold">TextMeshPro</strong>.</li>
				<li>Rename the new object <code>Show Pause Button</code> and use the <strong class="bold">Anchor Presets </strong>menu to place the object at the bottom right of the screen (use <em class="italic">Alt</em><strong class="bold"> </strong>+ <em class="italic">Shift</em><strong class="bold"> </strong>to set <strong class="bold">Pivot </strong>and <strong class="bold">Position </strong>as well).</li>
			</ol>
			<div><div><img src="img/B18868_05_01.jpg" alt="Figure 5.1 – Bottom-right option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Bottom-right option</p>
			<ol>
				<li value="5">Then, from the <strong class="bold">Image </strong>component, drag and drop our <strong class="bold">pauseButton</strong> sprite into the <strong class="bold">Source Image</strong> property. You’ll notice it’s<a id="_idIndexMarker387"/> stretched out, so click on the <strong class="bold">Set Native Size</strong> button to have the sprite automatically resize itself for us.</li>
				<li>We don’t actually need the text object included, so select the <strong class="bold">Text (TMP) </strong>object and hit the <em class="italic">Delete</em> key.</li>
			</ol>
			<div><div><img src="img/B18868_05_02.jpg" alt="Figure 5.2 – Creating the pause button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Creating the pause button</p>
			<ol>
				<li value="7">Go back and select the <code>pause</code>.</li>
				<li>Go back to <strong class="bold">Resume Button </strong>and add another event to its button to turn the <strong class="bold">Show Pause Menu </strong>button back on when we leave.</li>
			</ol>
			<div><div><img src="img/B18868_05_03.jpg" alt="Figure 5.3 – Creating the Resume Button click action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Creating the Resume Button click action</p>
			<p>Now, we want to <a id="_idIndexMarker389"/>remove our on-screen controls whenever we pause the game. This can be done through <strong class="bold">Inspector</strong>, but we can also do this through code.</p>
			<ol>
				<li value="9">Open the <code>PauseScreenBehaviour</code> script and add the following property to the script:<pre class="source-code">
[Tooltip("Reference to the on screen controls menu")]
public GameObject onScreenControls;</pre></li>
				<li>Afterward, update the <strong class="bold">SetPauseMenu</strong> function to have the following new line:<pre class="source-code">
/// &lt;summary&gt;
/// Will turn our pause menu on or off
/// &lt;/summary&gt;
/// &lt;param name="isPaused"&gt;is the game currently
    paused&lt;/param&gt;
public void SetPauseMenu(bool isPaused)
{
    paused = isPaused;
    /* If the game is paused, timeScale is 0,
       otherwise 1 */
    Time.timeScale = (paused) ? 0 : 1;
    pauseMenu.SetActive(paused);
    <strong class="bold">onScreenControls.SetActive(!paused);</strong>
}</pre></li>
			</ol>
			<p>Note that we are using <code>!paused</code> and not <code>paused</code> like in the previous line. The <code>!</code> operator will take something that is <code>true</code> and make it <code>false</code>, and vice versa. This will cause the <code>onScreenControls</code> window to turn on when the game is not paused and off when it is.</p>
			<p>Since we are already in the code editor, we can also use this time to fix something that will <a id="_idIndexMarker390"/>come up later: as mentioned previously, one problem that won’t be apparent now unless you restart the level is the fact that <code>static</code> variables will keep their values each time we reload the game. In our case, we set <code>paused</code>, which turns <code>Time.timeScale</code> to <code>0</code>. Thankfully, we can fix this fairly easily.</p>
			<ol>
				<li value="11">Open the <code>PauseScreenBehaviour</code> script and update the <code>Start</code> function to have the following, replacing the original line:<pre class="source-code">
void Start()
{
    /* Must be reset in Start or else game will be
        paused upon
     * restart */
    <strong class="bold">SetPauseMenu(false);</strong>
}</pre></li>
				<li>Return to Unity <a id="_idIndexMarker391"/>and go to the <strong class="bold">Pause Screen Handler</strong> object. From the <strong class="bold">Pause Screen Behaviour</strong> script, set the <strong class="bold">On Screen Controls</strong> property to our <strong class="bold">On Screen </strong><strong class="bold">Controls</strong> object.</li>
			</ol>
			<div><div><img src="img/B18868_05_04.jpg" alt="Figure 5.4 – Updating Pause Screen Behaviour"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Updating Pause Screen Behaviour</p>
			<ol>
				<li value="13">Save your script and the scene, and then play the game:</li>
			</ol>
			<div><div><img src="img/B18868_05_05.jpg" alt="Figure 5.5 – The current state of the game"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The current state of the game</p>
			<p>The pause menu now <a id="_idIndexMarker392"/>works correctly. This is a simple way to add on-screen controls to the screen. A more advanced version would be an analog stick that we can use to control the player’s movement. Let’s tackle that next.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor199"/>Implementing an on-screen joystick</h1>
			<p>To implement this on-screen<a id="_idIndexMarker393"/> joystick, we will utilize two images: a background image and then a joystick image placed on top of it. We will then write code to allow the player to simulate that they are physically moving the joystick. Later, we learn how we can have the simulated joystick actually affect the game properly:</p>
			<ol>
				<li>Right-click on the <code>Joystick Background</code>.</li>
				<li>From the <code>analogStickBackground</code> sprite and click on the <strong class="bold">Set Native </strong><strong class="bold">Size</strong> button.</li>
				<li>From the <strong class="bold">Rect Transform</strong> component, hold down <em class="italic">Alt</em><strong class="bold"> + </strong><em class="italic">Shift</em> and use the <strong class="bold">Anchor Presets</strong> menu to move <strong class="bold">Joystick Background</strong> to the bottom-left option.</li>
				<li>Next, right-click on the <code>Joystick</code>.</li>
				<li> From the <code>analogStick</code> sprite and click on the <strong class="bold">Set Native </strong><strong class="bold">Size</strong> button.</li>
			</ol>
			<div><div><img src="img/B18868_05_06.jpg" alt="Figure 5.6 – Creating the Joystick UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Creating the Joystick UI</p>
			<ol>
				<li value="6">We want this joystick to move, so to do that, we will create a new script. From the <code>Scripts</code> folder and create a new C# script called <code>MobileJoystick</code>. Then, attach the <code>MobileJoystick</code> script to the <code>Joystick</code> object.</li>
				<li>Open your code editor to the <code>MobileJoystick</code> script and add the following properties and initialization of those properties in the <code>Start</code> function:<pre class="source-code">
/// &lt;summary&gt;
/// A reference to this object's RectTransform
/// component
/// &lt;/summary&gt;
RectTransform rt;
/// &lt;summary&gt;
/// The original position of the stick used to
/// calculate the offset of movement
/// &lt;/summary&gt;
Vector2 originalAnchored;
// Start is called before the first frame update
void Start()
{
    rt = GetComponent&lt;RectTransform&gt;();
    originalAnchored = rt.anchoredPosition;
}</pre></li>
				<li>To have the joystick do something when we are dragging it, we can add an interface to our<a id="_idIndexMarker395"/> script for when we are dragging and when we stop. To do so, we need to add the following <code>using</code> statement to the top of our script:<pre class="source-code">
using UnityEngine.EventSystems; /* IDragHandler, IEndDragHandler */</pre></li>
				<li>After that, we add the following bold code to the class definition:<pre class="source-code">
public class MobileJoystick : MonoBehaviour, <strong class="bold">IDragHandler</strong>, <strong class="bold">IEndDragHandler</strong></pre></li>
				<li>Now, we will get some <a id="_idIndexMarker396"/>errors because we haven’t actually defined the functions given in the interfaces, let’s do that now:<pre class="source-code">
   /// &lt;summary&gt;
   /// Will allow the user to move the joystick
   /// &lt;/summary&gt;
   /// &lt;param name="eventData"&gt;Information about the
   /// movement, we are only
   /// using the position&lt;/param&gt;
   public void OnDrag(PointerEventData eventData)
   {
       /* We use our parent's info since the joystick
          moves */
       var parent =
           rt.parent.GetComponent&lt;RectTransform&gt;();
       var parentSize = parent.rect.size;
       var parentPoint =
           eventData.position - parentSize;
       /* Calculate the point relative to the
          parent's local space */
       Vector2 localPoint =
           parent.InverseTransformPoint(parentPoint);
       /* Calculates what the new anchor point should
          be */
       Vector2 newAnchorPos =
           localPoint - originalAnchored;
       /* Prevent the analog stick from moving too
          far */
       newAnchorPos = Vector2.ClampMagnitude(
           newAnchorPos, parentSize.x/2);
       rt.anchoredPosition = newAnchorPos;
   }
   /// &lt;summary&gt;
   /// Will be called when the player lets go of the
   /// stick
   /// &lt;/summary&gt;
   /// &lt;param name="eventData"&gt;Information about the
   /// movement, unused&lt;/param&gt;
   public void OnEndDrag(PointerEventData eventData)
   {
       /* Reset the stick to it's original position
       */
       rt.anchoredPosition = Vector3.zero;
   }</pre></li>
				<li>Save your script<a id="_idIndexMarker397"/> and return to the Unity editor. Play the game and try to click and drag the analog sticks:</li>
			</ol>
			<div><div><img src="img/B18868_05_07.jpg" alt="Figure 5.7 – Joysticks can now be moved"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Joysticks can now be moved</p>
			<ol>
				<li value="12">Now that they functionally work, let’s have them actually affect the game. We need to have some way to communicate the information that <code>MobileJoystick</code> has. To do this, let’s add a new property:<pre class="source-code">
    /// &lt;summary&gt;
    /// Gets the value of the joystick in a -1 to 1
    /// manner in the same way that Input.GetAxis does
    /// &lt;/summary&gt;
    public Vector2 axisValue;</pre></li>
				<li>Next, add the following line to the <code>OnDrag</code> function:<pre class="source-code">
// Update the axis value to the new position
axisValue = newAnchorPos / (parentSize.x / 2);</pre></li>
				<li>Then, add the following line to the <code>OnEndDrag</code> function:<pre class="source-code">
axisValue = Vector2.zero;</pre></li>
				<li>Now we need to <a id="_idIndexMarker398"/>go to the <code>PlayerBehaviour</code> script. From there, we will add a new variable to tell us whether we have a <code>MobileJoystick</code> or not:<pre class="source-code">
    <strong class="bold">private MobileJoystick joystick;</strong>
    // Start is called before the first frame update
    public void Start()
    {
        // Get access to our Rigidbody component
        rb = GetComponent&lt;Rigidbody&gt;();
        minSwipeDistancePixels = minSwipeDistance *
            Screen.dpi;
        <strong class="bold">joystick = GameObject.FindObjectOfType</strong>
<strong class="bold">            &lt;MobileJoystick&gt;();</strong>
    }</pre></li>
				<li>This way, if the player has turned off <code>MobileJoystick</code>, we still want the game to work.</li>
				<li>Next, we will need to update the <code>FixedUpdate</code> function to have the following changes:<pre class="source-code">
/// &lt;summary&gt;
/// FixedUpdate is a prime place to put physics
/// calculations
/// happening over a period of time.
/// &lt;/summary&gt;
void FixedUpdate()
{
    /* If the game is paused, don't do anything */
    if (PauseScreenBehaviour.paused)
    {
        return;
    }
    // Check if we're moving to the side
    var horizontalSpeed = Input.GetAxis("Horizontal")
        * dodgeSpeed;
    /* If the joystick is active and the player is
       moving the joystick, override the value */
    if (joystick &amp;&amp; joystick.axisValue.x != 0)
    {
        horizontalSpeed = joystick.axisValue.x *
            dodgeSpeed;
    }
    /* Check if we are running either in the Unity
       editor or in a standalone build.*/
    #if UNITY_STANDALONE || UNITY_WEBPLAYER ||
        UNITY_EDITOR
        /* If the mouse is held down (or the screen is
           tapped on Mobile */
        if (Input.GetMouseButton(0))
        {
            if(!joystick)
            {
                var screenPos = Input.mousePosition;
                horizontalSpeed =
                    CalculateMovement(screenPos);
            }
        }
    /* Check if we are running on a mobile device */
    #elif UNITY_IOS || UNITY_ANDROID
        switch (horizMovement)
        {
            case MobileHorizMovement.Accelerometer:
                /* Move player based on accelerometer
                   direction */
                horizontalSpeed = Input.acceleration.x
                    * dodgeSpeed;
                break;
            case MobileHorizMovement.ScreenTouch:
                /* Check if Input registered more than
                   zero touches */
                if (!joystick &amp;&amp; Input.touchCount &gt; 0)
                {
                    /* Store the first touch detected
                    */
                    var firstTouch = Input.touches[0];
                    var screenPos =
                        firstTouch.position;
                    horizontalSpeed =
                        CalculateMovement(screenPos);
                }
                break;
        }
    #endif
    rb.AddForce(horizontalSpeed, 0, rollSpeed);
}</pre></li>
				<li>Save your scripts <a id="_idIndexMarker399"/>and return to the Unity editor. Save your scene and then play the game:</li>
			</ol>
			<div><div><img src="img/B18868_05_08.jpg" alt="Figure 5.8 – Joystick moving the player"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Joystick moving the player</p>
			<p>In this way, if we have the joystick enabled when the game starts, the game will use it to move the player. Alternatively, you can disable the joystick and your game will work in the same way as before.</p>
			<p>At this point, our UI should work for the vast majority of cell phones. However, there are certain phones that contain “notches.” W<a id="_idTextAnchor200"/>e will see how to adjust our UI for that in the next sec<a id="_idTextAnchor201"/>tion.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor202"/>Adapting GUIs for notch devices</h1>
			<p>Since the first edition of this book, there <a id="_idIndexMarker400"/>have been many phones that <a id="_idIndexMarker401"/>have come out with sensor housings, more<a id="_idIndexMarker402"/> commonly known as “notches.” Made popular with the iPhone X, this has grown to be a part of many phones that are out right now. While some people online state that entire-screen displays are the future, iOS devices, Android devices running 9.0 and above, and Unity have added support for notches built into devices, and we can use the <code>Screen.safeArea</code><strong class="bold"> </strong>property in Unity to ensure that all of our content is visible.</p>
			<p>To get started, we will first go to the<a id="_idIndexMarker403"/> main menu to tweak the menu text:</p>
			<ol>
				<li>Go to the <code>MainMenu</code> Scene in the <code>Scenes </code>folder. In the <em class="italic">Adding a pause menu</em><strong class="bold"> </strong>section, we saw how we can use the <strong class="bold">Panel </strong>object in order to hold the contents we want to display. We will use this concept to account for the safe area.</li>
				<li>With the level opened, go to the <strong class="bold">Hierarchy </strong>view and create a child panel for our title screen to be inside by right-clicking on the <strong class="bold">Canvas - Scale w/Screen </strong>object and selecting <strong class="bold">UI | </strong><strong class="bold">Panel</strong>.</li>
				<li>Afterward, make <strong class="bold">Title Text </strong>a child of the newly created panel by dragging and dropping the <a id="_idIndexMarker405"/>object on top of the newly created <strong class="bold">Panel </strong>object:</li>
			</ol>
			<div><div><img src="img/B18868_05_09.jpg" alt="Figure 5.9 – SafeArea setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – SafeArea setup</p>
			<ol>
				<li value="4">From the <code>Scripts</code><code>UISafeAreaHandler</code>. Double-click on it to open your code editor and use the following code:<pre class="source-code">
using UnityEngine;
public class UISafeAreaHandler : MonoBehaviour
{
    RectTransform panel;
    // Start is called before the first frame update
    void Start()
    {
        panel = GetComponent&lt;RectTransform&gt;();
    }
    // Update is called once per frame
    void Update()
    {
        Rect area = Screen.safeArea;
        /* Pixel size in screen space of the whole
           screen */
        Vector2 screenSize = new Vector2(Screen.width,
            Screen.height);
        /* Set anchors to percentages of the screen
           used. */
        panel.anchorMin = area.position / screenSize;
        panel.anchorMax = (area.position + area.size)
            / screenSize;
    }
}</pre></li>
			</ol>
			<p>The <code>Screen.safeArea</code> property returns a variable of the <code>Rect</code> type, which contains an X and Y position and a<a id="_idIndexMarker407"/> width and height, just<a id="_idIndexMarker408"/> like the <code>Screen.safeArea</code> will just return <code>Rect(0, 0, Screen.width, Screen.height)</code>, which will work due to the lack of a notch.</p>
			<p><code>Screen.safeArea</code><code>Update</code> function to do modifications.</p>
			<p>We previously saw that anchors can <a id="_idIndexMarker409"/>be used to specify the size of a panel. Anchors work in viewport space, which is to say that the values go from <code>(0, 0)</code> to <code>(1, 1)</code>. Since the <code>Rect</code><code>Screen.safeArea</code><strong class="bold"> </strong>is in screen (pixel) space, we <a id="_idIndexMarker410"/>divide by the screen size in pixels to convert to the points to viewport space.</p>
			<p>Save the script and return to the Unity Editor. Then, attach the <strong class="bold">UI Safe Area Handler </strong>component to the <strong class="bold">Panel </strong>object that we just created.</p>
			<ol>
				<li value="5">Return to the Unity editor and transition to the <code>Screen.safeArea</code> property, you should notice the panel tweak its size appropriately to fit everything within our screen:</li>
			</ol>
			<div><div><img src="img/B18868_05_10.jpg" alt="Figure 5.10 – Adjusting the notch value"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Adjusting the notch value</p>
			<p>The <strong class="bold">Device Simulator</strong> is a tool that <a id="_idIndexMarker411"/>aims to allow developers to see what<a id="_idIndexMarker412"/> their game will look like on many devices. For more information on it, check out <a href="https://docs.unity3d.com/Manual/device-simulator-view.html">https://docs.unity3d.com/Manual/device-simulator-view.html</a>.</p>
			<p>In portrait mode, the top portion of the screen is cut off for the notch and the bottom is cut off for the home button. We can also click on the buttons next to the <strong class="bold">Rotate</strong> text to see how our game will look on the device facing the other direction:</p>
			<div><div><img src="img/B18868_05_11.jpg" alt="Figure 5.11 – Landscape mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Landscape mode</p>
			<p>Switching to landscape <a id="_idIndexMarker413"/>mode, we lose the left/right side for the<a id="_idIndexMarker414"/> notch, and on iOS, it cuts off the other side as well. Just as in portrait mode, the top is cut off for the home button.</p>
			<p>With this, we see that the menu adjusts itself correctly! However, there is a chance that the <strong class="bold">Play </strong>button no longer works. This is because both of our <strong class="bold">Canvas</strong> objects are drawn in the same sorting order, which means either can be on top of the other, similar to the concept of Z-fighting that you may know of if you’ve worked on 2D games in the past. Thankfully, we can fix that pretty easily.</p>
			<ol>
				<li value="6">Select the <code>-1</code>. The button with a <code>0</code> will always be on top of the contents of this Canvas.</li>
			</ol>
			<p>While the semi-transparent white panel is useful in illustrating the concept, we don’t actually want our users to see it when the game is being played. With that in mind, let’s turn off the image.</p>
			<ol>
				<li value="7">Select the <strong class="bold">Panel </strong>object. From the <strong class="bold">Image </strong>component, uncheck the checkbox to the left of the component’s name to disable it.</li>
			</ol>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you wanted to still have the image visible and have the button still work, you can instead uncheck the <strong class="bold">Raycast </strong><strong class="bold">Target </strong>property.</p>
			<p>Now that the first Canvas<a id="_idIndexMarker415"/> is completed, we can now do the same actions for the other <a id="_idIndexMarker416"/>one:</p>
			<ol>
				<li>Go to the <strong class="bold">Canvas - Scale Physical </strong>component and create another <strong class="bold">Panel </strong>object with the <strong class="bold">UI Safe Area Handler </strong>component attached to it, making sure to disable the <strong class="bold">Image </strong>component. Next, make the <strong class="bold">Play </strong>button a child of it:</li>
			</ol>
			<div><div><img src="img/B18868_05_12.jpg" alt="Figure 5.12 – Adjusting the﻿ Safe Area Handler"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Adjusting the<a id="_idTextAnchor203"/> Safe Area Handler</p>
			<ol>
				<li value="2">Save your Scene. Now that we<a id="_idIndexMarker417"/> have the main menu completed, we can<a id="_idIndexMarker418"/> tweak the <code>Gameplay </code>Scene as well.</li>
				<li>Open the <code>Gameplay </code>Scene, select the <strong class="bold">On Screen Controls</strong> object, and then just add the <strong class="bold">UI Safe Area Handler </strong>component to it:</li>
			</ol>
			<div><div><img src="img/B18868_05_13.jpg" alt="Figure 5.13 – Making the On Screen Controls use the UI Safe Area"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – Making the On Screen Controls use the UI Safe Area</p>
			<ol>
				<li value="4">To adjust the <strong class="bold">Pause Menu</strong>, we don’t want to change the <strong class="bold">Pause Menu </strong>object as we want the black screen even in the notch areas. We have previously created a panel to hold the contents of the pause menu, but that object is using the <strong class="bold">Aspect Ratio Fitter</strong>, which will overwrite any anchor changes we would make in the code. To keep this functionality as well as <strong class="bold">Content Size Fitters</strong> in the child objects, we can just create a parent panel to act as a holder.</li>
				<li>Make the <strong class="bold">Pause Menu </strong>object active again by selecting it in the <strong class="bold">Hierarchy </strong>window and then clicking on the <a id="_idIndexMarker419"/>checkbox by its name in the <strong class="bold">Inspector </strong>window. Right-click<a id="_idIndexMarker420"/> on the <strong class="bold">Panel </strong>object and create a <strong class="bold">Panel </strong>object by right-clicking and selecting <strong class="bold">UI | Panel</strong>. In the new panel, add the <strong class="bold">UI Safe Area Handler </strong>component and disable the <strong class="bold">Image </strong>component:</li>
			</ol>
			<div><div><img src="img/B18868_05_14.jpg" alt="Figure 5.14 – Adjusting the Pause Menu to work with notches"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Adjusting the Pause Menu to work with notches</p>
			<ol>
				<li value="6">Finally, since we are not working with the <strong class="bold">Pause Menu </strong>object anymore, select the <strong class="bold">Pause Menu </strong>object from the <strong class="bold">Hierarchy </strong>window, and in the <strong class="bold">Inspector </strong>window, uncheck the checkbox by the name to disable the object.</li>
				<li>Save your Scene and play the game:</li>
			</ol>
			<div><div><img src="img/B18868_05_15.jpg" alt="Figure 5.15 – UI now responds correctly to notches"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – UI now responds correctly to notches</p>
			<p>As you can see, if we <a id="_idIndexMarker421"/>hold down the spacebar, we can see both menu<a id="_idTextAnchor204"/>s <a id="_idIndexMarker422"/>working correctly!</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor205"/>Summary</h1>
			<p>In this chapter, we integrated the pause menu into our game itself and made it work with everything in our project. We then saw how we could create on-screen controls to give players another way to interact with the game using mobile devices. Finally, we saw how to have our game automatically adapt to fit within the allotted safe areas to handle the notches on phones. We will be exploring the previous concepts more deeply in later chapters, so keep these explanations in mind.</p>
			<p>In the next chapter, we will dive into monetization and take a look at just how we can add Unity ads to our project.</p>
		</div>
	</body></html>