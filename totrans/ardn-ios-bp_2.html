<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Bluetooth Pet Door Locker</h1></div></div></div><p>This project is about a pet door controller that, by measuring external light and temperature, locks or unlocks your house's pet door. Through an iOS device you can check the status of the door (locked or unlocked) and overrun the logic implemented on Arduino for manually locking the door.</p><p>In this project, you will learn how to work with analog sensors, switches, 1-Wire sensors (to measure temperatures) and control a servo motor wired to Arduino. Moreover, you will wire a Bluetooth 4.0 board to Arduino to communicate with your iOS device.</p><p>Then, you will learn how to write a Bluetooth iOS application to send and receive data from Arduino.</p><p>Towards the end of this chapter, we will discuss different types of sensors and their communication protocols with Arduino, in order to learn how to manage the most used technologies to measure quantities.</p><p>This project requires some DIY skills in order to mount the locker to the pet door and to link it to the servo motor.</p><p>The chapter is organized into the following sections:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Door locker requirements</strong>: We will briefly recap the project requirements</li><li class="listitem"><strong>Hardware</strong>: We will describe the hardware and the electronic circuit needed for the project</li><li class="listitem"><strong>Arduino code</strong>: We will write the code for Arduino to control the latch and communicate with the iOS device</li><li class="listitem"><strong>iOS code</strong>: We will write the code for the iOS device</li><li class="listitem"><strong>How to go further</strong>: More ideas to improve the project and learn more</li><li class="listitem"><strong>Different types of sensors</strong>: A quick overview of analog and digital sensors, low-level communication protocols, and their pros and cons</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Door locker requirements</h1></div></div></div><p>We are <a id="id51" class="indexterm"/>going to build an automatic system that allows you to lock the pet door in the following different scenarios:</p><div><ul class="itemizedlist"><li class="listitem">At night, when the outside light is less luminous than a predefined threshold</li><li class="listitem">When the external temperature is too low or too high for your beloved pet, that is, when the temperature is below a predefined threshold or above a predefined threshold</li></ul></div><p>Moreover, we need to see the external temperature on our iOS device, we also need to know if the pet door is locked or unlocked, and override the automatic behavior, manually locking the door.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Hardware</h1></div></div></div><p>In this <a id="id52" class="indexterm"/>project, we have to build an electro-mechanical<a id="id53" class="indexterm"/> device, based on a latch and a servo motor to lock/unlock the pet door. Moreover, we need to build a simple electronic circuit to read sensors.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Required materials and electronics components</h2></div></div></div><p>To <a id="id54" class="indexterm"/>build the locker you need little hardware that will be available at your local hardware store:</p><div><ul class="itemizedlist"><li class="listitem">A <a id="id55" class="indexterm"/>small door latch, which is best if flat and without any notch. Since it has to be operated by a servo motor it has to slide very smoothly.</li><li class="listitem">Some nuts and bolts to mount the latch to the door.</li><li class="listitem">A few centimeters of metal wire (diameter of 2 mm or so).</li></ul></div><p>Other required components are:</p><div><ul class="itemizedlist"><li class="listitem">Mini servo motor powered at 5V.</li><li class="listitem">Normally closed magnetic switch and a small magnet.</li><li class="listitem">A photoresistor.</li><li class="listitem">Resistors: 2 × 10K, 1 × 4.7K.</li><li class="listitem">A digital DS18B20 temperature sensor. It's more expensive than analog sensors (like TMP 35), but it's much more precise and the readings are almost insensitive to the voltage fluctuations and electric noise.</li><li class="listitem">Adafruit<a id="id56" class="indexterm"/> Bluefruit LE nRF8001 breakout (<a class="ulink" href="http://www.adafruit.com/product/1697">http://www.adafruit.com/product/1697</a>).</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Assembly latch and servo motor</h2></div></div></div><p>To<a id="id57" class="indexterm"/> assemble the latch, you can refer to the following<a id="id58" class="indexterm"/> picture.</p><div><img src="img/image00160.jpeg" alt="Assembly latch and servo motor"/></div><p style="clear:both; height: 1em;"> </p><p>The small magnet is glued on the latch, so that when it is completely retracted, the magnetic switch is open.</p><p>The photoresistor and the temperature sensor have to be placed outside the house and wired to Arduino. They need to be protected from humidity and dust, so it's better to set them inside a small plastic box. The box has to be drilled so that the air can freely circulate to help the temperature sensor to measure correctly. Moreover, the photoresistor should not be exposed to direct light to avoid blinding. A small plastic tube can do the job.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Electronic circuit</h2></div></div></div><p>The <a id="id59" class="indexterm"/>following picture shows the electric diagram of the electronic circuit that we need for the project:</p><div><img src="img/image00161.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>The<a id="id60" class="indexterm"/> following picture shows how to mount the circuit on a breadboard:</p><div><img src="img/image00162.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>For quick <a id="id61" class="indexterm"/>reference, the following list recaps the<a id="id62" class="indexterm"/> <strong>nRF8001</strong> wiring:</p><div><ul class="itemizedlist"><li class="listitem">SCK to digital pin 13</li><li class="listitem">MISO to digital pin 12</li><li class="listitem">MOSI to digital pin 11</li><li class="listitem">REQ to digital pin 10</li><li class="listitem">RST to digital pin 9</li><li class="listitem">RDY to digital pin 2</li></ul></div><p>If you are<a id="id63" class="indexterm"/> using <strong>Arduino MEGA</strong> instead of <strong>UNO</strong>, the wiring of <strong>nRF8001</strong> board has to be changed as follows:</p><div><ul class="itemizedlist"><li class="listitem">SCK to digital pin 52</li><li class="listitem">MISO to digital pin 50</li><li class="listitem">MOSI to digital pin 51</li><li class="listitem">REQ to digital pin 10</li><li class="listitem">RST to digital pin 9</li><li class="listitem">RDY to digital pin 2</li></ul></div><p>Light is<a id="id64" class="indexterm"/> measured using the photoresistor and an analog input of Arduino (A0). A photoresistor is a device whose resistance decreases with the increasing of the incident light intensity. In the circuit, the photoresistor is in a voltage divider with R1. Voltage across R1 increases if the light on the photoresistor increases, and it's measured using the analog pin A0 of Arduino.</p><div><h3 class="title"><a id="note02"/>Note</h3><p>R1 forces to ground the Arduino input when the photoresistor is not lighted and its resistance is very high.</p><p>In the Arduino code, you can get the value of the voltage at an analog pin using the <code class="literal">analogRead</code> function. It returns a value in the range 0-1023 which is proportional to the voltage applied to the analog pin.</p></div><p>The latch position is determined using a magnetic switch and a digital input of Arduino (D4). The magnetic switch closes when the magnet on the latch is close to it. The switch is in a voltage divider with R2. The voltage across R2 is almost 5V when the switch is closed, or about 0V when the switch is open.</p><div><img src="img/image00163.jpeg" alt="Electronic circuit"/><div><p>Voltage divider</p></div></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip09"/>Tip</h3><p>The voltage divider is a simple circuit made of two resistors. Assuming that the current that flows outside the circuit is negligible, V2 is approximately <em>V1*R2/(R1+R2)</em>.</p></div><p>Using an Arduino digital input you can determine if the switch is open or closed.</p><div><h3 class="title"><a id="note03"/>Note</h3><p>In the Arduino code, you can get the value of a digital pin using the <code class="literal">digitalRead</code> function.</p></div><p>The temperature sensor is a digital sensor that uses the 1-Wire protocol, and it is read using a digital pin.</p><div><h3 class="title"><a id="note04"/>Note</h3><p>To read the value of the temperature sensor you have to use the <code class="literal">OneWire</code> library and the <code class="literal">DallasTemperature</code> library through which a function directly returns the temperature in Celsius.</p></div><p>The servo<a id="id65" class="indexterm"/> motor requires a PWM signal to be controlled. Pulse width modulation is a technique for getting analog results with digital means. It is a square wave with a period of 2 ms. The width of the positive pulse determines the rotation of the servo (for example, a 1.5 ms pulse will make the motor turn to the 90-degree position). Fortunately, the servo library (already included in the IDE) hides the complexity and we can move the motor by just calling a function with the desired motor position.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Arduino code</h1></div></div></div><p>The full <a id="id66" class="indexterm"/>code of this project can be downloaded from here:</p><p>
<a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>
</p><p>For a <a id="id67" class="indexterm"/>better understanding of the explanations <a id="id68" class="indexterm"/>in the next paragraphs, you should open the downloaded code while reading.</p><p>Each Arduino program almost always has the following structure.</p><div><pre class="programlisting">#include &lt;library_1.h&gt;
#include &lt;library_2.h&gt;

#define SOMETHING A_VALUE


// Function prototypes

void callback_1();


// Global variables

boolean  var_1;


// Called only once at power on or reset

void setup() {

...
}

// Called over and over again

void loop() {
...
}

// Callbacks 

void callback_1() {
...
}

// Additional functions

void function_1() {
...
}</pre></div><p>The<a id="id69" class="indexterm"/> instruction <code class="literal">#include &lt;library_1.h&gt;</code> tells the compiler to use a library and the instruction <code class="literal">#define SOMETHING A_VALUE</code> tells the compiler to replace <code class="literal">SOMETHING</code> with <code class="literal">A_VALUE</code> all over the program. It's easier to make changes if you use defined values. If you need to replace <code class="literal">A_VALUE</code> with something else, you can do it at a single place instead of in all instances in the code. </p><p>Function prototypes are generally used for functions, which are used during the code but their bodies are put at the end of the program source. Global variables are variables whose values have to be preserved across the execution of the program. The function <code class="literal">setup</code> is used for initializing libraries and variables; it's called only once, at the board's power up or reset. The function <code class="literal">loop</code> instead is called over and over again. Variables defined in the loop function lose their value across calls; this is why we need global variables. Callback functions are called from libraries when an event happens, or data are available for processing. Instead, functions that are called from the loop help to make the code easier to read, maintain, and debug.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Installing additional required libraries</h2></div></div></div><p>For this <a id="id70" class="indexterm"/>project we need some libraries. Some are already available in the Arduino IDE and others have to be added ( for example, <code class="literal">OneWire</code>, <code class="literal">DallasTemperature</code>, and <code class="literal">Adafruit_BLE_UART</code>).</p><p>To add them, follow this simple procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the menu item <strong>Sketch</strong> | <strong>Include Library</strong> | <strong>Manage Libraries</strong>.</li><li class="listitem">In the search field enter <code class="literal">OneWire</code>.</li><li class="listitem">Select the row with <strong>OneWire</strong> and click <strong>Install</strong> (see picture below).</li><li class="listitem">Enter <code class="literal">DallasTemp</code> in the search field, click on <strong>MAX31850</strong> and then <strong>Install</strong>.</li><li class="listitem">Enter <code class="literal">nRF8001</code> in the search field, click <strong>Adafruit nRF8001</strong> and then <strong>Install</strong>.<div><img src="img/image00164.jpeg" alt="Installing additional required libraries"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Initializing global variables and libraries</h2></div></div></div><p>The <a id="id71" class="indexterm"/>temperature sensor uses the 1-Wire protocol for <a id="id72" class="indexterm"/>communicating with Arduino, so we need the <code class="literal">OneWire</code> library. Fortunately another library (<code class="literal">DallasTemperature</code>) is available to make temperature readings very easy. We need to create global variables for the two libraries:</p><div><pre class="programlisting">OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&amp;oneWire);</pre></div><p>And one for storing the sensor address:</p><div><pre class="programlisting">DeviceAddress temperatureSensorAddress;</pre></div><p>The global variables for the nRF8001 library are in a line:</p><div><pre class="programlisting">Adafruit_BLE_UART uart = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);</pre></div><div><h3 class="title"><a id="note05"/>Note</h3><p>If you change the pins used in the previous line, you have to also change them in the circuit wiring.</p></div><p>To<a id="id73" class="indexterm"/> control the servo motor we need another global<a id="id74" class="indexterm"/> variable:</p><div><pre class="programlisting">Servo myservo;</pre></div><p>We also need two more global Boolean variables:</p><div><pre class="programlisting">boolean  iOSConnected;
boolean  manuallyLocked;</pre></div><p>The first is true when the iOS device is connected to Arduino, the second is true when the user needs to keep the pet door closed regardless of the light and temperature values.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Setup code</h2></div></div></div><p>We start<a id="id75" class="indexterm"/> setting up the Serial communication library:</p><div><pre class="programlisting">Serial.begin(9600);
while (!Serial); // Leonardo/Micro should wait for serial init</pre></div><p>This is not strictly necessary but it is required for writing to the console, which may be useful for debugging purposes.</p><p>Then we initialize the sensor library:</p><div><pre class="programlisting">sensors.begin();</pre></div><p>We also read the address of the device number 0 (the only one present in our circuit):</p><div><pre class="programlisting">if (!sensors.getAddress(temperatureSensorAddress, 0)) 
    Serial.println("Unable to find address for Device 0");</pre></div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>
<strong>The 1-Wire address</strong>
</p><p>Each 1-Wire device has its own address defined at time of production and it cannot be changed. To perform any operation on the device you have to know its address. The <code class="literal">getAddress</code> and <code class="literal">search</code> library functions can help you to find the address of your devices.</p></div><p>The sensor can provide readings with different levels of precision, but the more precision we ask for, the more the device is slow to answer. For our purposes, we don't need a high precision, so we can set the precision to 9 bits:</p><div><pre class="programlisting">sensors.setResolution(temperatureSensorAddress, 9);</pre></div><p>The library <a id="id76" class="indexterm"/>has to know the pin where the servo motor is wired on:</p><div><pre class="programlisting">myservo.attach(SERVOPIN);</pre></div><p>Both the pins used for the photoresistor and the switch need to be configured as input:</p><div><pre class="programlisting">pinMode(PHOTORESISTORPIN, INPUT);
pinMode(SWITCHPIN, INPUT);</pre></div><p>For communicating with the nRF8001 board we need to set up a couple of callback functions; one, to know when the iOS device is connected or disconnected:</p><div><pre class="programlisting">uart.setACIcallback(aciCallback);</pre></div><p>The other callback function is for receiving data that are transmitted by the iOS device:</p><div><pre class="programlisting">uart.setRXcallback(rxCallback);</pre></div><p>The nRF8001 library calls the <code class="literal">rxCallback</code> when data from the iOS device are available for processing.</p><p>We are now ready to take a look at the main part of the code, which implements the algorithm to control the pet door and the iOS communication.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Main program</h2></div></div></div><p>From <a id="id77" class="indexterm"/>the project's requirements, we conclude that the Arduino program has to implement a simple logic:</p><div><ul class="itemizedlist"><li class="listitem">Read light intensity</li><li class="listitem">Read temperature</li><li class="listitem">If the light intensity is above <code class="literal">LIGHT_THRESHOLD</code>, at a temperature between <code class="literal">LOW_TEMPERATURE_THRESHOLD</code> and <code class="literal">HIGH_TEMPERATURE_THRESHOLD</code>, the servo motor has to move to the <code class="literal">UNLOCK_POSITION</code> (180 degree), otherwise to the <code class="literal">LOCK_POSITION</code> (65 degree)</li></ul></div><p>Moreover, when the iOS device is connected, it has to receive information about the latch position (opened or closed) and the external temperature.</p><p>In the main loop function we read the light intensity with:</p><div><pre class="programlisting">unsigned int light = analogRead(PHOTORESISTORPIN);</pre></div><p>The temperature with:</p><div><pre class="programlisting">boolean lacthIsOpened = digitalRead(SWITCHPIN);</pre></div><p>And the latch position with:</p><div><pre class="programlisting">sensors.requestTemperatures();
float temperature = sensors.getTempC(temperatureSensorAddress);</pre></div><p>Light is<a id="id78" class="indexterm"/> a value in the range 0-1023 (2<sup>10</sup>) proportional to the light intensity, if the latch is opened, the <code class="literal">latchIsOpened</code> has value true (1), and <code class="literal">temperature</code> is the temperature measured by the sensor.</p><div><h3 class="title"><a id="tip11"/>Tip</h3><p>
<strong>Voltage at the analog pin</strong>:</p><p>The <strong>analog to digital converter</strong> (<strong>ADC</strong>) inside Arduino, attached to an analog pin, transforms<a id="id79" class="indexterm"/> the voltage at the pin into an integer value using 10 bits, which is an integer value in the range 0-1023 (2<sup>10</sup> values).</p><p>Since the voltage at the analog pin can be between 0 V and 5 V (the power voltage) each bit has a value that is 5 / 1024, then you can calculate the voltage at the analog pin using this formula:</p><p>
<em>voltage = analogRead(&lt;ANALOG PIN&gt;) * 5/1024</em>
</p><p>If you power on Arduino through the USB port of your computer, the power voltage is never exactly 5V but usually less. To get a better reading, you should measure the power voltage with a digital multimeter, and replace 5 with the actual power voltage in the previous formula.</p></div><p>In the loop function it's necessary to call the <code class="literal">pollACI</code> function so that the communication library can take the control for handling incoming data from the iOS connected device.</p><div><h3 class="title"><a id="tip12"/>Tip</h3><p>
<strong>poolACI</strong>
</p><p>If you <a id="id80" class="indexterm"/>have a long and complex program, you may need to add many <code class="literal">poolACI</code> calls across the code in order to frequently allow the library to take control to handle communication. Otherwise, you can experience data loss.</p></div><p>The core algorithm is in the following lines:</p><div><pre class="programlisting">if (!manuallyLocked) {

    if (aboveThreshold(light, LIGHT_THRESHOLD, 30) &amp;&amp; betweenThresholds(temperature, LOW_TEMPERATURE_THRESHOLD, HIGH_TEMPERATURE_THRESHOLD)) {
      Serial.println("Unlocked");
      myservo.write(UNLOCKED_POSITION);
    }  

    if (belowThreshold(light, LIGHT_THRESHOLD, 30) || !betweenThresholds(temperature, LOW_TEMPERATURE_THRESHOLD, HIGH_TEMPERATURE_THRESHOLD)) {
      Serial.println("Locked");
      myservo.write(LOCKED_POSITION);
    }
    
  }</pre></div><p>If the<a id="id81" class="indexterm"/> door has not been manually locked, the light is above the <code class="literal">LIGHT_THRESHOLD</code>, the temperature is between <code class="literal">LOW_TEMPERATURE_THRESHOLD</code> and <code class="literal">HIGH_TEMPERATURE_THRESHOLD</code>, the servo motor can be moved to the <code class="literal">UNLOCKED_POSITION</code> with the instruction:</p><div><pre class="programlisting">myservo.write(UNLOCKED_POSITION);</pre></div><p>Otherwise, it is moved to the <code class="literal">LOCKED_POSITION</code>:</p><div><pre class="programlisting">myservo.write(LOCKED_POSITION);</pre></div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>
<strong>DeMorgan's theorem</strong>
</p><p>This <a id="id82" class="indexterm"/>theorem is very useful for coding if-then-else statements in any programming language. Don't ever forget it!</p><p>not (A or B) = not A and not B</p><p>or</p><p>not (A and B) = not A or not B</p><p>The opposite condition of "A or B" is "not A <strong>and</strong> not B", the opposite condition of "A and B" is "not A <strong>or</strong> not B.</p></div><p>The following two functions are quite self-explanatory:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">aboveThreshold</code>(…)</li><li class="listitem"><code class="literal">betweenThresholds</code>(….)</li></ul></div><p>Take a look at the downloaded code for more details.</p><p>If <code class="literal">manuallyLocked</code> is true, light and temperature readings are ignored. This variable is set by a message received from the iOS device in the <code class="literal">rxCallback</code> function:</p><div><pre class="programlisting">void rxCallback(uint8_t *buffer, uint8_t len) {

  if (len &gt; 0) {
    
    // Data received from the iOS device
    // Received only one byte which has value 48 (character 0) or 49 (character 1)
    
    manuallyLocked = buffer[0] - '0';
    if (manuallyLocked) {
      Serial.println("Manual Lock");
      myservo.write(LOCKED_POSITION);
    }

  }
}</pre></div><p>Remember <a id="id83" class="indexterm"/>that the nRF8001 library automatically calls the <code class="literal">rxCallback</code> function when data sent from the iOS device are ready for processing.</p><p>The iOS device sends only one byte with the ASCII character 1 if the door has to be locked, or the ASCII character 0 otherwise.</p><p>The ASCII character 0 has code 48, so to transform it to a Boolean value false (0) you need to subtract 48 (or the character '0' which is the same). Subtracting 48 from the ASCII character 1, we get the Boolean value true (1).</p><p>Back to the main function. If <code class="literal">iOSConnected</code> is true, an iOS device is connected to Arduino, and some data has to be transferred to it.</p><p>Data are sent to iOS with the following format:</p><div><pre class="programlisting">s:latch_position;t:temperature</pre></div><p>Here, <code class="literal">latch_position</code> informs the iOS device if the latch is opened or closed, whereas <code class="literal">temperature</code> is the external temperature.</p><p>To send data to iOS we use the following code:</p><div><pre class="programlisting">if (iOSConnected) {

    // When the iOS device is connected some data are transferred to it
    
    char buffer[32];
    char tempBuffer[6];

    // Data sent to iOS
    // s:latch_position;t:temperature

    dtostrf(temperature, 0, 2, tempBuffer);

    snprintf(buffer, 32, "s:%d;t:%s", lacthIsOpened, tempBuffer);
    uart.write((uint8_t *)buffer, strlen(buffer));
  }</pre></div><p>The <a id="id84" class="indexterm"/>function <code class="literal">snprintf</code> creates a buffer formatted as required, which is then sent to iOS with the function <code class="literal">uart.write((uint8_t *)buffer, strlen(buffer))</code>.</p><div><h3 class="title"><a id="tip14"/>Tip</h3><p>
<strong>snprintf</strong>
</p><p>This<a id="id85" class="indexterm"/> function never writes more characters than that indicated by the second parameter. This is very important to write safe code. In fact, if you write more characters than the buffer size, it is likely that you write somewhere in a memory location which is used for other purposes causing a microprocessor crash. After a crash, the microprocessor restarts the program execution <a id="id86" class="indexterm"/>from the setup function. For more details, visit <a class="ulink" href="http://bit.ly/1E021no">http://bit.ly/1E021no</a> and <a class="ulink" href="http://bit.ly/1LijDx5">http://bit.ly/1LijDx5</a>.</p><p>
<strong>dtostrf</strong>
</p><p>Unfortunately, on<a id="id87" class="indexterm"/> Arduino, <code class="literal">snprintf</code> doesn't work with floating numbers, so we need to use <code class="literal">dtostrf</code> to transform the temperature (which is a float) to a string and then using it in the <code class="literal">snprintf</code>. The second parameter of <code class="literal">dtostrf</code> is the <a id="id88" class="indexterm"/>number of decimal digits to use in the conversion. For more details, visit: <a class="ulink" href="http://bit.ly/1fmj9HV">http://bit.ly/1fmj9HV</a>.</p></div><p>The last thing that we have to code is managing connections and disconnections of the iOS device. This is done in the <code class="literal">aciCallback</code> function. The nRF8001 library calls this function each time one of the following events happen: the device starts advertizing itself in order to be discovered by other Bluetooth devices, an external device connects, or a connected device disconnects.</p><div><pre class="programlisting">void aciCallback(aci_evt_opcode_t event) {

  if (event == ACI_EVT_DEVICE_STARTED)
    Serial.println(F("Advertising started"));
    
  if (event == ACI_EVT_CONNECTED) {
    
    iOSConnected = true;
    
    char buffer[16];
    snprintf(buffer, 16, "m:%d", manuallyLocked);
    uart.write((uint8_t *)buffer, strlen(buffer));
  }

  if (event == ACI_EVT_DISCONNECTED) {
    iOSConnected = false;
  }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Testing and tuning the Arduino side</h2></div></div></div><p>Once<a id="id89" class="indexterm"/> you have uploaded the code to Arduino (for more <a id="id90" class="indexterm"/>details: <a class="ulink" href="http://bit.ly/1JPNAn3">http://bit.ly/1JPNAn3</a> or <a class="ulink" href="http://bit.ly/1KsUhqv">http://bit.ly/1KsUhqv</a>), you can start testing it.</p><p>If enough <a id="id91" class="indexterm"/>light reaches the photoresistor and the temperature is between 2 degree Celsius and 33 degree Celsius, the servo should move to the open position and the latch should be completely retracted.</p><p>Then, when you cover the photoresistor, the latch should close. In order to test the temperature sensor you can use a hairdryer to get the temperature over 3 degree Celsius and an ice pack to get it below 2 degree Celsius. In both cases the latch should close.</p><p>You can easily change the temperature thresholds by changing these defines:</p><div><pre class="programlisting">#define LOW_TEMPERATURE_THRESHOLD    2
#define HIGH_TEMPERATURE_THRESHOLD   33</pre></div><p>The light threshold likely requires some more tuning, since the values read by the photoresistor highly depend on the photoresistor characteristics, the mounting positioning and orientation. Anyway, change:</p><div><pre class="programlisting">#define LIGHT_THRESHOLD             700</pre></div><p>You should be able to find the value that is right for your needs.</p><p>You may also need to adjust the servo motor positions for opening and closing the latch because of the way you have assembled everything. To adjust the positions you can change:</p><div><pre class="programlisting">#define LOCKED_POSITION             180
#define UNLOCKED_POSITION            65</pre></div><p>This represents the position in degrees of the motor.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>iOS code</h1></div></div></div><p>In this <a id="id92" class="indexterm"/>chapter, we are going to write <a id="id93" class="indexterm"/>the iOS application through which we can connect to the Arduino, know if the pet door is locked or not, read the external temperature, and eventually manually lock it.</p><p>The full <a id="id94" class="indexterm"/>code of this project can be downloaded from here:</p><p>
<a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>
</p><p>To better understand the explanations in the next paragraphs, you should open the downloaded code while reading.</p><p>The<a id="id95" class="indexterm"/> main tool for writing the application is Xcode provided by Apple. We can start it from Launchpad or entering the <strong>Applications</strong> folder in <strong>Finder</strong>.</p><div><h3 class="title"><a id="tip15"/>Tip</h3><p>
<strong>Start developing iOS apps today</strong>
</p><p>A<a id="id96" class="indexterm"/> useful guide to iOS developing provided by Apple<a id="id97" class="indexterm"/> can be found at this link: <a class="ulink" href="http://apple.co/MtP2Aq">http://apple.co/MtP2Aq</a>.</p><p>
<strong>Objective-C</strong>
</p><p>The<a id="id98" class="indexterm"/> language used for developing iOS applications is Objective-C. It is similar to C++ and <a id="id99" class="indexterm"/>you can find an introduction to this language at the following link: <a class="ulink" href="http://apple.co/19FWxfQ">http://apple.co/19FWxfQ</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Creating the Xcode project</h2></div></div></div><p>The <a id="id100" class="indexterm"/>first step is to create a new project. Xcode provides many different project templates; we are going to use the Tabbed Application, which has two tabs. We<a id="id101" class="indexterm"/> are going to use the first tab as the main application panel, and the second to scan the nRF8001 device. This operation is required only once, when the application is started for the first time.</p><div><h3 class="title"><a id="tip16"/>Tip</h3><p>
<strong>Xcode overview</strong>
</p><p>You can find <a id="id102" class="indexterm"/>everything you need to work with Xcode at the following link: <a class="ulink" href="http://apple.co/1UQnMtS">http://apple.co/1UQnMtS</a>.</p></div><p>To create the new project we can follow these steps (see the following screenshots):</p><div><ol class="orderedlist arabic"><li class="listitem">Go to <strong>File</strong> | <strong>New</strong> | <strong>Project …</strong>.</li><li class="listitem">In the left panel, select <strong>iOS</strong> | <strong>Application</strong>.</li><li class="listitem">In the right panel, select <strong>Tabbed Application</strong> and then click on <strong>Next</strong>.<div><img src="img/image00165.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">In the <a id="id103" class="indexterm"/>next screen, enter the required information:<div><ul class="itemizedlist"><li class="listitem"><strong>Product Name</strong>: <code class="literal">PetDoorLocker</code></li><li class="listitem"><strong>Organization Name</strong>: <code class="literal">Your Name</code></li><li class="listitem"><strong>Organization Identifier</strong>: <code class="literal">yourname</code> (this information is relevant only for publishing the application to the iTunes Store and selling it. It can be ignored)</li><li class="listitem"><strong>Language</strong>: <strong>Objective-C</strong></li><li class="listitem"><strong>Devices</strong>: <strong>Universal</strong> (we are going to create an application that can run on an iPhone and iPad)</li></ul></div><div><img src="img/image00166.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Click <a id="id104" class="indexterm"/>on the <strong>Next</strong> button.</li><li class="listitem">Select a folder where you want to store the project (leave Source Control unchecked).</li></ol><div></div><p>That's all!</p><p>We are now ready to start writing the new application. The first thing to do is rename the two view controllers (FirstViewController and SecondViewController).</p><div><ol class="orderedlist arabic"><li class="listitem">Select <code class="literal">FirstViewController.h</code> in the left panel, this will open the file in the right panel.</li><li class="listitem">Select <code class="literal">FirstViewController</code> in the line <code class="literal">@interface FirstViewController : UIViewController</code>, by double clicking on <code class="literal">FirstViewController</code>.</li><li class="listitem">Right Click and select <strong>Refactor</strong> | <strong>Rename …</strong>.</li><li class="listitem">Enter the new name of the view controller: <code class="literal">PetDoorLockerViewController</code>.</li><li class="listitem">Click preview and then save.</li><li class="listitem">Select <code class="literal">SecondViewController.h</code>, and with the same procedure rename it as <code class="literal">BLEConnectionViewController</code>.</li></ol><div></div><p>What's a View Controller? The Apple documentation says:</p><div><blockquote class="blockquote"><p><em>View controllers are a vital link between an app's data and its visual appearance. Whenever an iOS app displays a user interface, the displayed content is managed by a view controller or a group of view controllers coordinating with each other. Therefore, view controllers provide the skeletal framework on which you build your apps.</em></p></blockquote></div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>
<strong>Design Patterns</strong>
</p><p>Before <a id="id105" class="indexterm"/>going any further, we suggest you <a id="id106" class="indexterm"/>read the information on the following link: <a class="ulink" href="http://apple.co/1hkUDbU">http://apple.co/1hkUDbU</a>.</p></div><p>Now we are ready to design the GUI of the new application.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Designing the application user interface for BLEConnectionViewController</h2></div></div></div><p>To <a id="id107" class="indexterm"/>design the app user interface, let's open the <code class="literal">Main.storyboard</code>. This file contains everything about the GUI. Once opened, you should see something as shown in the following screenshot:</p><div><img src="img/image00167.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Let's start from <a id="id108" class="indexterm"/>the <code class="literal">BLEConnectionViewController</code>, which will be used for scanning the nRF8001 device.</p><div><ol class="orderedlist arabic"><li class="listitem">Double click on the view controller to select it.</li><li class="listitem">Click on the label <strong>Second View</strong> and delete it, then select <strong>Loaded by the SecondViewController</strong> and delete it.</li><li class="listitem">Open the Utilities panel on the right: <strong>View</strong> | <strong>Utilities</strong> | <strong>Show Utilities</strong>. (To open this panel you can also use the green circled icon in the following screenshot).</li><li class="listitem">Select <strong>Label</strong> in the Tool Navigator and drop it to the free area (see the following screenshot).<div><img src="img/image00168.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Rename the label, by <a id="id109" class="indexterm"/>double clicking <strong>Label</strong> and entering <code class="literal">Device</code>.</li><li class="listitem">Now we have to set the Auto Layout constraints that will lock the label in the desired position:<div><ol class="orderedlist arabic"><li class="listitem">Click on the Auto Layout Pin icon (it's circled in red in the previous screenshot).</li><li class="listitem">Enter <code class="literal">20</code> for the Leading Space from Superview, and <code class="literal">30</code> for Top Space to Superview as shown in the following screenshot.</li><li class="listitem">Enter <code class="literal">53</code> as <strong>Width</strong>.</li><li class="listitem">Click on <strong>Add 3 Constraints</strong>.</li></ol><div></div><div><img src="img/image00169.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Drop a new instance<a id="id110" class="indexterm"/> of <strong>Label</strong> next to the previous and add Auto Layout Constraints to it:<div><ol class="orderedlist arabic"><li class="listitem">Select both labels (clicking on them with the <em>Command</em> button pressed).</li><li class="listitem">Click on the Align icon (it's circled in green in the previous screenshot).</li><li class="listitem">Select <strong>Vertical Centers</strong> and then <strong>Add 1 Constraint</strong>.</li><li class="listitem">Select only the new label and click on the Auto Layout Pin.</li><li class="listitem">Enter <code class="literal">20</code> for both the Leading Space and Trailing Space.</li><li class="listitem">For <strong>Update Frames</strong>, select <strong>All frames in Container</strong>.</li><li class="listitem">Click on <strong>Add 2 Constraints</strong>.</li><li class="listitem">Select the new label again, and select <strong>View</strong> | <strong>Utilities</strong> | <strong>Show Attributes Inspector</strong> (or click on the icon circled in red in the next screenshot).</li><li class="listitem">Change the font size to <code class="literal">13</code> and <strong>Alignment</strong> to center (see area circled green in the next screenshot).</li></ol><div></div><div><img src="img/image00170.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p><p>The new label will show the UUID of the nRF8001 once detected. Now we have to add a button to start scanning for nRF8001 devices nearby.</p></li><li class="listitem">Drag a button into the<a id="id111" class="indexterm"/> container, double click on it, and enter <code class="literal">Scan</code>:<div><ol class="orderedlist arabic"><li class="listitem">Select the button and click on the Auto Layout Pin.</li><li class="listitem">Enter <code class="literal">45</code> for <strong>To Space</strong> and click on <strong>Add 1 Constraint</strong>.</li><li class="listitem">Select the button, click on the Align icon, select Horizontal Center in the Container, for <strong>Update Frames</strong>, select <strong>All frames in Container</strong>, and then click on <strong>Add 1 Constraint</strong>.</li></ol><div></div><p>Now we have to link the GUI components with the code in order to manipulate them programmatically.</p></li><li class="listitem">Select the <strong>BLEConnectionViewController</strong>.</li><li class="listitem">Click on <strong>View</strong> | <strong>Assistant Editor</strong>. A new panel opens with the <code class="literal">BLEConnectionViewController.h</code>.</li><li class="listitem">Close the Utilities panel to<a id="id112" class="indexterm"/> have more space (click on <strong>View</strong> | <strong>Utilities</strong> | <strong>Hide Utilities</strong>).</li><li class="listitem">Make sure that in the red circled area of the following screenshot, you read <strong>BLEConnectionViewController.m</strong>, otherwise click on it and change to the desired file.</li><li class="listitem">Select the label <strong>Label</strong> and keeping the <em>Command</em> button pressed, drag the label to the code on the right between <code class="literal">@interface BLEConnectionViewController ()</code> and <code class="literal">@end</code> (see picture below).<div><img src="img/image00171.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">When a dialog appears, enter the <strong>Name</strong> as <code class="literal">deviceUUIDLabel</code> (see picture below) and then click <strong>Connect</strong>.<div><img src="img/image00172.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p><p>This creates a property (<code class="literal">deviceUUIDLabel</code>), which <a id="id113" class="indexterm"/>can be used for changing the label properties, such as its text.</p><div><h3 class="title"><a id="tip18"/>Tip</h3><p>
<strong>ARC and strong versus weak</strong>
</p><p>The <code class="literal">strong</code> attribute indicates to the compiler that the memory associated to the property <a id="id114" class="indexterm"/>has to be kept allocated until the class in which it is defined is allocated. Properties that are not defined strong (but weak) are automatically deallocated<a id="id115" class="indexterm"/> as soon as the code block in which they are defined is completed. In short, as long as there is a strong reference pointer to the object, that object will not be deallocated. Memory management under iOS has been simplified since the introduction of <strong>Automatic Counting Reference</strong> (<strong>ARC</strong>) but is still an issue for<a id="id116" class="indexterm"/> most people. A good introduction can be found here: <a class="ulink" href="http://apple.co/1MvuNgw">http://apple.co/1MvuNgw</a>. It is for Swift (the last programming language that Apple has made available) but it is worth reading.</p></div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>
<strong>Atomic versus nonatomic</strong>
</p><p>The <code class="literal">atomic</code> attribute will ensure that a whole value is always returned from the getter <a id="id117" class="indexterm"/>or set by the setter of the property, regardless of setter activity on any other thread. That is, if thread A is in the middle of the getter while thread B calls the setter, an actual viable value will be returned to the caller in A.</p><p>The Apple documentation says: <em>Property atomicity is not synonymous with an object's thread safety</em>.</p><p>Accessing a<a id="id118" class="indexterm"/> strong property is slower than accessing a nonatomic one. More details here: <a class="ulink" href="http://apple.co/1JeBIdb">http://apple.co/1JeBIdb</a>.</p></div><p>We now link the <strong>Scan</strong> button to <a id="id119" class="indexterm"/>have a method that is called when the button is tapped:</p></li><li class="listitem">Select the <strong>Scan</strong> button and, keeping <em>Control</em> pressed, drop it to the right pane.</li><li class="listitem">Enter <code class="literal">startScanning</code> as the name and select <strong>UIButton</strong> for <strong>Type</strong> (see picture below). This creates a new method, which is called when the button is pressed.<div><img src="img/image00173.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p><p>To complete the design, we have to set the name of the view controller, which appears in the toolbar:</p></li><li class="listitem">Open the Tool Navigator again (<strong>View</strong> | <strong>Utilities</strong> | <strong>Show Utilities</strong>).</li><li class="listitem">Select the icon at the bottom side of the container (a small square with second label under it).</li><li class="listitem">Show Attribute Inspector (<strong>View</strong> | <strong>Utilities</strong> | <strong>Attribute Inspector</strong>).</li><li class="listitem">In the <strong>Title</strong> field, enter <code class="literal">Configuration</code>.</li></ol><div></div><div><h3 class="title"><a id="note06"/>Note</h3><p>You could also choose an icon from the Image list box. To do that, you should add the icon to the project, dropping it into the Supporting Files group in the left panel. The icon should be 32 × 32 pixels.</p></div><p>At the very end, your View Controller<a id="id120" class="indexterm"/> should look like the next picture.</p><div><img src="img/image00174.jpeg" alt="Designing the application user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Designing the application user interface for PetDoorLockerViewController</h2></div></div></div><p>In this <a id="id121" class="indexterm"/>section we will design the interface for the first view controller (PetDoorLockerViewController). We will only describe how to add components not shown in the previous chapter. Refer to the next picture for the global layout of the view.</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label, rename it as <code class="literal">Door Status</code> and add to it the Auto Layout constraints.</li><li class="listitem">Enter <code class="literal">UIView</code> in the search field of the right panel and drop the view near the label. You can resize the view dragging the small white squares on its borders. In the Attribute Inspector, select a light gray color for the background.</li><li class="listitem">Select both the label and the view and click on Align icon. Select <strong>Vertical Centers</strong> and click on <strong>Add 1 Constraint</strong>.</li><li class="listitem">Select the view and click on the Align icon. Select <strong>Horizontal Center</strong> in the <strong>Container</strong> and click on <strong>Add 1 Constraint</strong>.</li><li class="listitem">Select the Pin icon, enter <code class="literal">48</code> for height and width, for <strong>Update Frames</strong>, select <strong>All frames in Container</strong> and then click on <strong>Add 2 Constraints</strong>.</li><li class="listitem">Add a new label <code class="literal">Temperature</code>, and add to it the Auto Layout constraints.</li><li class="listitem">Add another label near <strong>Temperature</strong> and the Auto Layout constraints to vertically center it with <strong>Temperature</strong> and horizontally center it in the container's view.</li><li class="listitem">Then add a label, <code class="literal">Lock</code>, and add Auto Layout constraints.</li><li class="listitem">Add a switch near <strong>Lock</strong> and the Auto Layout constraints to vertically center it with <strong>Lock</strong> and horizontally center it in the container's view.</li><li class="listitem">At the bottom of the container, add a button (called <strong>Connect</strong>) and the Auto Layout constraints to vertically center it with <strong>Lock</strong> and horizontally center it in the container's view.</li></ol><div></div><p>You should end with something like what is shown in the following picture. The <strong>Connect</strong> button is useful in case you lose connection to the nRF8001 device, and you need to manually reconnect to it.</p><div><img src="img/image00174.jpeg" alt="Designing the application user interface for PetDoorLockerViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Once all the components have <a id="id122" class="indexterm"/>been added, you can link them to the code finishing with:</p><div><pre class="programlisting">@interface PetDoorLockerViewController ()

@property (strong, nonatomic) IBOutlet UIView       *doorStatus;
@property (strong, nonatomic) IBOutlet UILabel      *temperature;
@property (strong, nonatomic) IBOutlet UISwitch     *manualLockSwitch;


@end</pre></div><p>And with the function <code class="literal">reconnect</code> to intercept when the <strong>Connect</strong> button is tapped.</p><p>In case of doubts, you can use the downloaded code as reference.</p><p>We are eventually ready to write the code for both the view controllers.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Writing code for BLEConnectionViewController</h2></div></div></div><p>The purpose of this controller is to <a id="id123" class="indexterm"/>get the unique identifier of the nRF8001 device, so that it can be used to connect to the device as needed.</p><p>To handle communication with a Bluetooth 4.0 device, we need to use the class <code class="literal">CBCentralManager</code> that we add to the interface of the view controller:</p><div><pre class="programlisting">@interface BLEConnectionViewController ()

@property (strong, nonatomic) IBOutlet UILabel  *deviceUUIDLabel;

@property (strong, nonatomic) CBCentralManager  *centralManager;


@end</pre></div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>
<strong>Xcode class reference</strong>
</p><p>If you <a id="id124" class="indexterm"/>need to know more about a class, you can press <em>Option</em> + click the class name for direct access to the documentation. Conversely, <em>Command</em> + click will bring you to the source file.</p></div><p>The instantiation of the class is in the <code class="literal">viewDidAppear</code> method, which is called every time the view associated with the view controller is shown on the device screen.</p><div><pre class="programlisting">-(void)viewDidAppear:(BOOL)animated {
    
    _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];
}</pre></div><p>To work with <code class="literal">CBCentralManager</code>, we need to implement a few delegate methods, but first we have to instruct the controller about that; we open the <code class="literal">BLEConnectionViewController.h</code> file and we change it as follows:</p><div><pre class="programlisting">#import &lt;UIKit/UIKit.h&gt;
#import &lt;CoreBluetooth/CoreBluetooth.h&gt;

@interface BLEConnectionViewController : UIViewController &lt;CBCentralManagerDelegate&gt;


@end</pre></div><p>Then we are ready to write two delegate methods:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">centralManagerDidUpdateState</code>: This method is called when the state of the iOS<a id="id125" class="indexterm"/> Bluetooth subsystem changes. This method has only an informative purpose in this view controller, but it is very useful in more complex projects where the status of the Bluetooth subsystem needs to be monitored. See the downloaded code to get<a id="id126" class="indexterm"/> more details about this method.</li><li class="listitem"><code class="literal">didDiscoverPeripheral</code>: This method <a id="id127" class="indexterm"/>is called when a new peripheral is discovered:<div><pre class="programlisting">- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI {
    
    [_scanningTimer invalidate];
    _deviceUUIDLabel.text = peripheral.identifier.UUIDString;
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    
    [userDefaults setObject:peripheral.identifier.UUIDString
                     forKey:@"PetDoorLockerDevice"];
    
    [userDefaults synchronize];
}</pre></div></li></ul></div><p>Each time a new Bluetooth peripheral is discovered (the nRF8001 board hooked up to Arduino in our case) the method is called providing information on the peripheral. We will show the identifier of the peripheral on the screen:</p><div><pre class="programlisting">_deviceUUIDLabel.text = peripheral.identifier.UUIDString;</pre></div><p>And we store it in <code class="literal">userDefaults</code> with the key <code class="literal">PetDoorLockerDevice</code> so that we can retrieve it as needed.</p><div><h3 class="title"><a id="tip21"/>Tip</h3><p>
<strong>User preferences</strong>
</p><p>Preferences <a id="id128" class="indexterm"/>are information that you store persistently, and use to configure your app. They can be accessed using the <code class="literal">NSUserDefaults</code> class. More details can be found here: <a class="ulink" href="http://apple.co/1qRYb3o">http://apple.co/1qRYb3o</a>.</p></div><p>Later on, we'll get back to explaining:</p><div><pre class="programlisting">[_scanningTimer invalidate];</pre></div><p>The <strong>Scan</strong> button activates the method <code class="literal">startScanning</code> when the user needs to detect the available device.</p><div><pre class="programlisting">- (IBAction)startScanning:(UIButton *)sender {
    
    if (_centralManager.state != CBCentralManagerStatePoweredOn)
        return;
    
     [_centralManager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:NRF8001BB_SERVICE_UUID]] options:nil];
    
    _deviceUUIDLabel.text = @"Scanning...";
    
    _scanningTimer = [NSTimer scheduledTimerWithTimeInterval:(float)5.0 target:self selector:@selector(scanningTimedOut:) userInfo:nil repeats:NO];
}</pre></div><p>If the state of the <code class="literal">centralManager</code> is <a id="id129" class="indexterm"/>not <code class="literal">CBCentralManagerStatePoweredOn</code> nothing can be done. Otherwise the scanning is started by calling <code class="literal">scanForPeripheralsWithServices</code>.</p><p>Each Bluetooth 4.0 device has one or more services uniquely identified; we look for the service identifier of the nRF8001 board (NRF8001BB_SERVICE_UUID).</p><div><h3 class="title"><a id="tip22"/>Tip</h3><p>
<strong>nRF8001 service and characteristics</strong>
</p><p>A <a id="id130" class="indexterm"/>Bluetooth peripheral can provide more services and, for each service, more characteristics that the user can read and/or write. The nRF8001 board has only one service (UUID: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E), one characteristic to receive data (UUID: 6E400002-B5A3-F393-E0A9-E50E24DCCA9E) and one for sending data (UUID: 6E400003-B5A3-F393-E0A9-E50E24DCCA9E).</p></div><p>The value NRF8001BB_SERVICE_UUID is defined at the beginning of the view controller's code: <code class="literal">#define NRF8001BB_SERVICE_UUID @"6E400001-B5A3-F393-E0A9-E50E24DCCA9E"</code>.</p><p>Once a device with that service has been found, the iOS calls <code class="literal">didDiscoverPeripheral</code> and the iOS device stops scanning. Unfortunately, the scanning process runs until a device is found. So in case the peripheral has not been found, the iOS device keeps draining the batteries. To overcome this issue, we need a timer. It is defined into the view controller interface:</p><div><pre class="programlisting">@interface BLEConnectionViewController ()

@property (strong, nonatomic) IBOutlet UILabel      *deviceUUIDLabel;

@property (strong, nonatomic) CBCentralManager      *centralManager;
@property (strong, nonatomic) NSTimer               *scanningTimer;

@end</pre></div><p>And instantiated with:</p><div><pre class="programlisting">_scanningTimer = [NSTimer scheduledTimerWithTimeInterval:(float)5.0 target:self selector:@selector(scanningTimedOut:) userInfo:nil repeats:NO];</pre></div><p>If not halted, the timer will call the <a id="id131" class="indexterm"/>method <code class="literal">scanningTimedOut</code> after 5 seconds. In this method we can stop <code class="literal">centralManager</code> from scanning and draining the batteries:</p><div><pre class="programlisting">-(void) scanningTimedOut:(NSTimer *)timer {
    
    [_centralManager stopScan];
    _deviceUUIDLabel.text = @"No device in range";
}</pre></div><p>If a peripheral, with the desired service, is found, the iOS calls the <code class="literal">didDiscoverPeripheral</code> method:</p><div><pre class="programlisting">- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI {
    
    [_scanningTimer invalidate];
    _deviceUUIDLabel.text = peripheral.identifier.UUIDString;
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    
    [userDefaults setObject:peripheral.identifier.UUIDString
                     forKey:@"PetDoorLockerDevice"];
    
    [userDefaults synchronize];
}</pre></div><p>We have to halt the <code class="literal">scanningTimer</code> that is the purpose of this line <code class="literal">[_scanningTimer invalidate];</code> and save the UUID of the peripheral in User Defaults.</p><p>Now it's time to run the app on your device.</p><div><h3 class="title"><a id="tip23"/>Tip</h3><p>
<strong>Run your app</strong>
</p><p>All <a id="id132" class="indexterm"/>the information for running your app both on the simulator<a id="id133" class="indexterm"/> and on the physical device can be found here: <a class="ulink" href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html">https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html</a>.</p></div><p>Power on the Arduino board and start<a id="id134" class="indexterm"/> the app, then tap on the configuration tab and then on the <strong>Scan</strong> button. In a few seconds you should see a long string of letters and numbers near the device label. That is the UUID of the nRF8001 device. The setup configuration has been completed!</p><p>If something goes wrong, the message <strong>no device is in range</strong> appears. In that case, double check the following:</p><div><ol class="orderedlist arabic"><li class="listitem">The nRF8001 is properly wired to Arduino.</li><li class="listitem">You have uploaded the correct code to Arduino.</li><li class="listitem">The Arduino board is powered up.</li><li class="listitem">The IDE console shows the messages <strong>Setup Completed</strong> and <strong>Advertising started</strong>.</li><li class="listitem">Bluetooth is activated on your iOS device (tap Settings and then Bluetooth to activate it).</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Writing code for PetDoorLockerViewController</h2></div></div></div><p>In <a id="id135" class="indexterm"/>this section, we will write the main part of the application, which allows you to monitor if the pet door is locked or unlocked, read the external temperature, and lock the pet door if you need it.</p><div><h3 class="title"><a id="note07"/>Note</h3><p>Since the code of this view controller is more complex and we want to save space for other subjects, we are going to explain the entire code but we are not going to guide you on writing it step-by-step. Please, refer to the downloaded code to see the code in its entirety.</p></div><p>We need three defines and some additional properties in the view controller's interface:</p><div><pre class="programlisting">#define NRF8001BB_SERVICE_UUID                      @"6E400001-B5A3-F393-E0A9-E50E24DCCA9E"
#define NRF8001BB_CHAR_TX_UUID                      @"6E400002-B5A3-F393-E0A9-E50E24DCCA9E"
#define NRF8001BB_CHAR_RX_UUID                      @"6E400003-B5A3-F393-E0A9-E50E24DCCA9E"

@interface PetDoorLockerViewController ()

…

@property (strong, nonatomic) CBCentralManager      *centralManager;
@property (strong, nonatomic) CBPeripheral          *arduinoDevice;
@property (strong, nonatomic) CBCharacteristic      *sendCharacteristic;

@end</pre></div><p>We <a id="id136" class="indexterm"/>also need to add a delegate <code class="literal">@interface PetDoorLockerViewController : UIViewController &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt;</code> in the <code class="literal">PetDoorLockerViewController.h</code>.</p><p>Setting up the <code class="literal">CBCentralManager</code> instance is exactly like we did in the previous controller.</p><p>The method <code class="literal">centralManagerDidUpdateState</code> is quite different:</p><div><pre class="programlisting">- (void)centralManagerDidUpdateState:(CBCentralManager *)central {
    
    NSLog(@"Status of CoreBluetooth central manager changed %ld (%s)", central.state, [self centralManagerStateToString:central.state]);
    
    if (central.state == CBCentralManagerStatePoweredOn) {
        
        [self connect];
    }
}</pre></div><p>As soon as the Bluetooth subsystem is ready (its state is <code class="literal">CBCentralManagerStatePoweredOn</code>) the app starts trying to connect to the nRF8001 board, calling <code class="literal">[self connect]</code> which is a method that we'll show you very soon.</p><p>The connection is also started from <code class="literal">viewDidAppear</code> each time the view controller is shown on the screen:</p><div><pre class="programlisting">-(void)viewDidAppear:(BOOL)animated {
    
    [super viewDidAppear:animated];

    [self connect];
}</pre></div><p>The connection is closed as soon as the view disappears from the screen to reduce draining of the batteries:</p><div><pre class="programlisting">-(void)viewDidDisappear:(BOOL)animated {
    
    [super viewDidDisappear:animated];

    [self disconnect];
}</pre></div><p>Now let's<a id="id137" class="indexterm"/> take a closer look at the connection method.</p><div><pre class="programlisting">-(void)connect {
    
    if (_arduinoDevice == nil) {
        
        // We need to retrieve the Arduino peripheral
        
        NSString *deviceIdentifier = [[NSUserDefaults standardUserDefaults] objectForKey:@"PetDoorLockerDevice"];
        
        if (deviceIdentifier!=nil) {
            
            NSArray *devices = [_centralManager retrievePeripheralsWithIdentifiers:@[[CBUUID UUIDWithString:deviceIdentifier]]];
            _arduinoDevice = devices[0];
<strong>            _arduinoDevice.delegate = self;</strong>
        }
        else {
            
            
            …
            …
            
            return;
        }
    }
    
    [_centralManager connectPeripheral:_arduinoDevice options:nil];
}</pre></div><p>If <code class="literal">arduinoDevice</code> is not initialized, we retrieve it using the UUID that has been stored in the user preferences during the scanning phase. It's important that the peripheral delegate is set, because we have to discover the peripheral's characteristics and they are returned through delegate methods. The method <code class="literal">connectPeripheral</code> actually connects to the peripheral. If the connection is successful, the delegate method <code class="literal">didConnectPeripheral</code> is<a id="id138" class="indexterm"/> called, and we can start discovering the service that the device provides:</p><div><pre class="programlisting">- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral {
    
    [peripheral discoverServices:@[[CBUUID UUIDWithString:NRF8001BB_SERVICE_UUID]]];

}</pre></div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>
<strong>Discovering all services</strong>
</p><p>In <a id="id139" class="indexterm"/>certain cases you may need to discover all the services that a peripheral provides. To do that, you use: <code class="literal">[peripheral discoverServices:nil];</code>.</p></div><p>Once iOS discovers the peripheral's service, it calls the method <code class="literal">didDiscoverServices</code> and we can start discovering the characteristics of the service:</p><div><pre class="programlisting">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error {
    
    …

    for (int i=0; i &lt; peripheral.services.count; i++) {
        
        CBService *s = [peripheral.services objectAtIndex:i];
        [peripheral discoverCharacteristics:nil forService:s];
    }
}</pre></div><p>For each service provided, the iOS calls the method <code class="literal">didDiscoverCharacteristicsForService</code> (please see downloaded code). In this method we store the characteristic for sending data to the nRF8001 device in the property <code class="literal">sendCharacteristic</code>, and we call this method:</p><div><pre class="programlisting">[peripheral setNotifyValue:YES forCharacteristic:characteristic];</pre></div><p>Now, we'll use the characteristic for receiving data as parameter. Now each time the characteristic changes (data are sent from the nRF80001 device), the method <code class="literal">didUpdateValueForCharacteristic</code> is called and the available data are received (please, see downloaded code).</p><p>When incoming data are available, the <code class="literal">dataReceived</code> method is called and received data can be processed:</p><div><pre class="programlisting">-(void)dataReceived:(NSString *)content {
    
    // Messages has the following formats:
    //
    //  1) m:0|1
    //
    //  2) s:0|1;t:temperature
    
    NSArray *messages = [content componentsSeparatedByString:@";"];
    
    for (int i=0; i&lt;messages.count; i++) {
        
        NSArray *components = [messages[i] componentsSeparatedByString:@":"];
        
        NSString *command = components[0];
        NSString *value   = components[1];
        
        if ([command isEqualToString:@"m"]) {
            _manualLockSwitch.on = [value boolValue];
        }
        
        if ([command isEqualToString:@"s"]) {
            
            BOOL doorUnlocked = [value boolValue];
            
            if (doorUnlocked) {
                
                _doorStatus.backgroundColor = [UIColor greenColor];
            }
            else {
                
                _doorStatus.backgroundColor = [UIColor redColor];
            }
        }
        
        if ([command isEqualToString:@"t"]) {
            _temperature.text = value;
        }
    }
}</pre></div><p>We can receive two kinds of messages:</p><div><ul class="itemizedlist"><li class="listitem">m:0|1</li><li class="listitem">s:0|1; t:temperature</li></ul></div><p>When the iOS device connects to Arduino, it receives the first message, which informs you if the door has been manually locked (m:1) or not (m:0). With this information we can set the position of the manual switch:</p><div><pre class="programlisting">_manualLockSwitch.on = [value boolValue];</pre></div><p>The <a id="id140" class="indexterm"/>second message contains two types of information: if the latch is open (s:1) or closed (s:0) and the external temperature. The first is used to change the background color of the <code class="literal">doorStatus</code> view:</p><div><pre class="programlisting">BOOL doorUnlocked = [value boolValue];
            
if (doorUnlocked) {
                
    _doorStatus.backgroundColor = [UIColor greenColor];
}
else {
                
    _doorStatus.backgroundColor = [UIColor redColor];
}</pre></div><p>The temperature information is used to set the value of the <code class="literal">temperature</code> label:</p><div><pre class="programlisting">if ([command isEqualToString:@"t"]) {
    _temperature.text = value;
}</pre></div><p>When the switch <code class="literal">manualLockSwitch</code> is tapped, the method <code class="literal">switchChanged</code> is called and there we can transmit data to Arduino:</p><div><pre class="programlisting">- (IBAction)switchChanged:(UISwitch *)sender {
    
    NSData* data;
    
    if (sender.on)
        data=[@"1" dataUsingEncoding:NSUTF8StringEncoding];
    else
        data=[@"0" dataUsingEncoding:NSUTF8StringEncoding];
    
    [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];

}</pre></div><p>To send data to a Bluetooth device, we write to the appropriate characteristic using the method <code class="literal">writeValue</code>. Since it accepts <code class="literal">NSData</code> values, we have to convert the string <code class="literal">"0"</code> or <code class="literal">"1"</code> to <code class="literal">NSData</code> using the method <code class="literal">dataUsingEncoding</code>.</p><p>We have almost completed the application. Once the iOS application is connected to Arduino, we need that it disconnects when it is sent to the background (for saving batteries). When it is brought to the foreground again, it automatically reconnects to Arduino.</p><p>To <a id="id141" class="indexterm"/>do that we make the <code class="literal">connect</code> method public and we write a new <code class="literal">disconnect</code> public method. To make the methods public we add a couple of lines to <code class="literal">PetDoorLockerViewController.h</code>:</p><div><pre class="programlisting">-(void)connect;
-(void)disconnect;</pre></div><p>The <code class="literal">disconnect</code> method is very simple:</p><div><pre class="programlisting">-(void)disconnect {
    
    if (_arduinoDevice != nil) {
        [_centralManager cancelPeripheralConnection:_arduinoDevice];
        _doorStatus.backgroundColor = [UIColor lightGrayColor];
    }
}</pre></div><p>Setting the background color of the <code class="literal">doorStatus</code> view to light gray, we can visually know if the iOS is connected to Arduino or not.</p><p>The very last method we have to write is <code class="literal">reconnect</code>, which doesn't require any explanation:</p><div><pre class="programlisting">- (IBAction)reconnect:(UIButton *)sender {
    
    [self disconnect];
    [self connect];
}</pre></div><p>In the <code class="literal">AppDelegate.m</code> file there are two methods, which are respectively called when the app enters in the background or gets back to the foreground:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">applicationDidEnterBackground</code></li><li class="listitem"><code class="literal">applicationWillEnterForeground</code></li></ul></div><p>In these methods we need a reference to the <code class="literal">PetDoorLockerViewController</code>. We can get it through the main application window.</p><div><pre class="programlisting">- (void)applicationDidEnterBackground:(UIApplication *)application {

    UITabBarController *tabController = (UITabBarController *)_window.rootViewController;
    PetDoorLockerViewController *petDorLockerController = tabController.viewControllers[0];
    
    [petDorLockerController disconnect];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
    
    
    UITabBarController *tabController = (UITabBarController *)_window.rootViewController;
    PetDoorLockerViewController *petDorLockerController = tabController.viewControllers[0];
    
    [petDorLockerController connect];
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Testing the iOS app</h2></div></div></div><p>Now the<a id="id142" class="indexterm"/> application is completed and we can run it again on our iOS device. As soon as it starts, it should connect to Arduino and the door status indicator should turn to red if the door is locked, or to green if it is unlocked and you should see the temperature measured from the Arduino sensor.</p><p>When you tap on the lock switch, the door should immediately close and ignore light and temperature.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>How to go further</h1></div></div></div><p>The <a id="id143" class="indexterm"/>application we have developed can be improved in many ways; these are some suggested improvements that you can try yourself:</p><div><ul class="itemizedlist"><li class="listitem">Checking the presence of your pet in the house by counting door openings and their directions. A couple of magnetic switches should do the job of detecting the opening direction of the pet door.</li><li class="listitem">Detect your own pet using an RFID tag attached to their collar to avoid other pets being able to get into your house.</li><li class="listitem">Setting light threshold and temperature thresholds directly from the iOS device using a slider (UISliderView).</li><li class="listitem">Replace the temperature numeric indication with a more appealing graphical indicator like a gauge or a thermometer.</li><li class="listitem">Notify<a id="id144" class="indexterm"/> you when your pet goes through the pet door.</li><li class="listitem">Show temperature in Celsius and Fahrenheit.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Different types of sensors</h1></div></div></div><p>Before ending this chapter we would like to give an overview of the existing type of sensors, their<a id="id145" class="indexterm"/> communication protocols with Arduino, and the pros <a id="id146" class="indexterm"/>and cons of using them.</p><p>Sensors can be categorized into two major families (analog and digital) based on the kind of signal they provide. An <a id="id147" class="indexterm"/>analog sensor usually provides a voltage, which is proportional to the quantity it is measuring. This voltage has to be converted in a number using an ADC. Arduino provides six analog pins and each of them has its own ADC. The photoresistor that we are using in our project is a typical analog sensor. Conversely, a digital sensor directly provides a numeric representation of the measured quantity, which can be directly used. The temperature sensor, which we are using in this project, is an example of a digital sensor.</p><p>Analog sensors are easier to use and cheaper, but they are very sensitive to power voltage fluctuations and electrical noise in the circuit. For these reasons the readings change a lot and it is usually needed to implement digital filters in code to smooth out the readings.</p><p>Digital sensors<a id="id148" class="indexterm"/> instead provide very stable readings and they are usually more precise. Unfortunately, they communicate with the microprocessor using different low-level protocols, which are more complex to handle. In the majority of the cases, protocol complexities are hidden by software libraries specialized for each type of sensor, but this makes coding more complex and libraries usually lead to a greater memory consumption which is a very precious resource on a microprocessor.</p><p>The most <a id="id149" class="indexterm"/>used <a id="id150" class="indexterm"/>low-level protocols are <strong>Serial Peripheral Interface</strong> (<strong>SPI</strong>) and <strong>Inter-integrated Circuit</strong> (<strong>I2C</strong>). Another low-level protocol largely used for temperature sensors is the 1-Wire, which has been adopted for this project.</p><p>A complete comparison between these protocols is out of the scope of this project, but you can<a id="id151" class="indexterm"/> get an idea of them by referring to the following table.</p><div><table border="1"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Protocol</p>
</th><th valign="bottom">
<p>Architecture</p>
</th><th valign="bottom">
<p>Signals needed</p>
</th><th valign="bottom">
<p>Multi- master </p>
</th><th valign="bottom">
<p>Data rate</p>
</th><th valign="bottom">
<p>Full duplex</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>SPI</p>
</td><td valign="top">
<p>Two<a id="id152" class="indexterm"/> shared uni-directional data signals and a shared clock </p>
</td><td valign="top">
<p>SCK, MISO, MOSI, and one CS for each device on the board</p>
</td><td valign="top">
<p>Possible, but not standard</p>
</td><td valign="top">
<p>1 Mbps</p>
</td><td valign="top">
<p>Yes</p>
</td></tr><tr><td valign="top">
<p>I2C</p>
</td><td valign="top">
<p>Shared<a id="id153" class="indexterm"/> data signal and a shared clock signal</p>
</td><td valign="top">
<p>SDA<a id="id154" class="indexterm"/> and SCL</p>
</td><td valign="top">
<p>Yes</p>
</td><td valign="top">
<p>100<a id="id155" class="indexterm"/> kbps, 400 kbps, and 3.2 Mbps</p>
</td><td valign="top">
<p>No</p>
</td></tr><tr><td valign="top">
<p>1-Wire</p>
</td><td valign="top">
<p>One data signal</p>
</td><td valign="top">
<p>Data</p>
</td><td valign="top">
<p>No</p>
</td><td valign="top">
<p>15 kbps</p>
</td><td valign="top">
<p>No</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>Well done! You made it to the end of the chapter and you have built a project from scratch!</p><p>You have built the hardware, along with the electronic circuit, and written the software for both Arduino and iOS.</p><p>On Arduino, you have learned how to use analog and digital sensors (1-Wire), how to write the code for reading them, how to control a servo motor, and how to handle the communication with the iOS devices.</p><p>On iOS, you have learned how to write an application with a simple user interface and that the application's communication with Arduino via Bluetooth 4.0.</p><p>We eventually discussed analog and digital sensors and some of the most used low-level communication protocols for exchanging data with Arduino.</p><p>In the next chapter, we will build another project, which uses Wi-Fi instead of Bluetooth to transfer data. In that project, Arduino will accept different commands and react to it. The iOS application will have a table view, which is one of the most useful components provided by the UIKit.</p></div></body></html>