["```swift\n#import \"Box2D.h\"\n#import \"GLES-Render.h\"\n//32 pixels = 1 meter\n#define PTM_RATIO 32\n@implementation Ch4_BasicSetup\n-(CCLayer*) runRecipe {\n[super runRecipe];\n/* Box2D Initialization */\n//Set gravity\nb2Vec2 gravity;\ngravity.Set(0.0f, -10.0f);\n//Initialize world\nbool doSleep = YES;\nworld = new b2World(gravity, doSleep);\nworld->SetContinuousPhysics(YES);\n//Initialize debug drawing\nm_debugDraw = new GLESDebugDraw( PTM_RATIO );\nworld->SetDebugDraw(m_debugDraw);\nuint32 flags = 0;\nflags += b2DebugDraw::e_shapeBit;\nm_debugDraw->SetFlags(flags);\n//Create level boundaries\n[self addLevelBoundaries];\n//Add batch node for block creation\nCCSpriteBatchNode *batch = [CCSpriteBatchNode batchNodeWithFile:@\"blocks.png\" capacity:150];\n[self addChild:batch z:0 tag:0];\n//Add a new block\nCGSize screenSize = [CCDirector sharedDirector].winSize;\n[self addNewSpriteWithCoords:ccp(screenSize.width/2, screenSize.height/2)];\n//Schedule step method\nBox2D setupsteps[self schedule:@selector(step:)];\nreturn self;\n}\n/* Adds a polygonal box around the screen */\n-(void) addLevelBoundaries {\nCGSize screenSize = [CCDirector sharedDirector].winSize;\n//Create the body\nb2BodyDef groundBodyDef;\ngroundBodyDef.position.Set(0, 0);\nb2Body *body = world->CreateBody(&groundBodyDef);\n//Create a polygon shape\nb2PolygonShape groundBox;\n//Add four fixtures each with a single edge\ngroundBox.SetAsEdge(b2Vec2(0,0), b2Vec2(screenSize.width/PTM_RATIO,0));\nbody->CreateFixture(&groundBox,0);\ngroundBox.SetAsEdge(b2Vec2(0,screenSize.height/PTM_RATIO), b2Vec2(screenSize.width/PTM_RATIO,screenSize.height/PTM_RATIO));\nbody->CreateFixture(&groundBox,0);\ngroundBox.SetAsEdge(b2Vec2(0,screenSize.height/PTM_RATIO), b2Vec2(0,0));\nbody->CreateFixture(&groundBox,0);\ngroundBox.SetAsEdge(b2Vec2(screenSize.width/PTM_RATIO,screenSize.height/PTM_RATIO), b2Vec2(screenSize.width/PTM_RATIO,0));\nbody->CreateFixture(&groundBox,0);\n}\n/* Adds a textured block */\n-(void) addNewSpriteWithCoords:(CGPoint)p {\nCCSpriteBatchNode *batch = (CCSpriteBatchNode*) [self getChildByTag:0];\n//Add randomly textured block\nint idx = (CCRANDOM_0_1() > .5 ? 0:1);\nint idy = (CCRANDOM_0_1() > .5 ? 0:1);\nCCSprite *sprite = [CCSprite spriteWithBatchNode:batch rect:CGRectMake(32 * idx,32 * idy,32,32)];\n[batch addChild:sprite];\nsprite.position = ccp( p.x, p.y);\n//Define body definition and create body\nb2BodyDef bodyDef;\nbodyDef.type = b2_dynamicBody;\nbodyDef.position.Set(p.x/PTM_RATIO, p.y/PTM_RATIO);\nbodyDef.userData = sprite;\nb2Body *body = world->CreateBody(&bodyDef);\n//Define another box shape for our dynamic body.\nb2PolygonShape dynamicBox;\ndynamicBox.SetAsBox(.5f, .5f);//These are mid points for our 1m box\n//Define the dynamic body fixture.\nb2FixtureDef fixtureDef;\nfixtureDef.shape = &dynamicBox;\nfixtureDef.density = 1.0f;\nfixtureDef.friction = 0.3f;\nbody->CreateFixture(&fixtureDef);\n}\n/* Draw debug data */\n-(void) draw {\n//Disable textures\nglDisable(GL_TEXTURE_2D);\nglDisableClientState(GL_COLOR_ARRAY);\nglDisableClientState(GL_TEXTURE_COORD_ARRAY);\n//Draw debug data\nworld->DrawDebugData();\nBox2D setupsteps//Re-enable textures\nglEnable(GL_TEXTURE_2D);\nglEnableClientState(GL_COLOR_ARRAY);\nglEnableClientState(GL_TEXTURE_COORD_ARRAY);\n}\n/* Update graphical positions using physical positions */\n-(void) step: (ccTime) dt {\n//Set velocity and position iterations\nint32 velocityIterations = 8;\nint32 positionIterations = 3;\n//Steo the Box2D world\nworld->Step(dt, velocityIterations, positionIterations);\n//Update sprite position and rotation to fit physical bodies\nfor (b2Body* b = world->GetBodyList(); b; b = b->GetNext()) {\nif (b->GetUserData() != NULL) {\nCCSprite *obj = (CCSprite*)b->GetUserData();\nobj.position = CGPointMake( b->GetPosition().x * PTM_RATIO, b->GetPosition().y * PTM_RATIO);\nobj.rotation = -1 * CC_RADIANS_TO_DEGREES(b->GetAngle());\n}\n}\n}\n/* Tap to add a block */\n- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\nfor( UITouch *touch in touches ) {\nCGPoint location = [touch locationInView: [touch view]];\nlocation = [[CCDirector sharedDirector] convertToGL: location];\n[self addNewSpriteWithCoords: location];\n}\n}\n@end\n\n```", "```swift\n    void SetGravity(const b2Vec2& gravity);\n\n    ```", "```swift\n    b2BodyDef bodyDef;\n    bodyDef.position.Set(0, 0);\n    b2Body *body = world->CreateBody(&bodyDef);\n    b2PolygonShape poly;\n    poly.SetAsEdge(b2Vec2(0,0), b2Vec2(480/PTM_RATIO,0));\n    body->CreateFixture(&poly,0);\n\n    ```", "```swift\n    int32 velocityIterations = 8;\n    int32 positionIterations = 3;\n    world->Step(dt, velocityIterations, positionIterations);\n\n    ```", "```swift\n    for (b2Body* b = world->GetBodyList(); b; b = b->GetNext()) {\n    if (b->GetUserData() != NULL) {\n    CCSprite *obj = (CCSprite*)b->GetUserData();\n    obj.position = CGPointMake( b->GetPosition().x * PTM_RATIO, b->GetPosition().y * PTM_RATIO);\n    obj.rotation = -1 * CC_RADIANS_TO_DEGREES(b->GetAngle());\n    }\n    }\n\n    ```", "```swift\n/* GameObject.h */\n@interface GameObject : CCNode {\n@public\nGameArea2D *gameArea; b2Body *body; b2BodyDef *bodyDef;\nb2FixtureDef *fixtureDef; b2PolygonShape *polygonShape;\nb2CircleShape *circleShape; CCSprite *sprite;\nint typeTag; bool markedForDestruction;\n}\n/* GameSensor.h */\n@interface GameSensor : GameObject {}\n@property (readonly) int type;\n@end\n/* GameMisc.h */\n@interface GameMisc : GameObject {\n@public\nfloat life;\n}\n@property (readonly) int type;\n@property (readwrite, assign) float life;\n@end\ncollision response routinescreating/* BasicContactListener.h */\nclass basicContactListener : public b2ContactListener\n{\npublic:\nvoid BeginContact(b2Contact* contact);\n};\nvoid basicContactListener::BeginContact(b2Contact* contact)\n{\nb2Body *bodyA = contact->GetFixtureA()->GetBody();\nb2Body *bodyB = contact->GetFixtureB()->GetBody();\n//Handle collision using your custom routine\nif(bodyA and bodyB){\nGameObject *objA = (GameObject*)bodyA->GetUserData();\nGameObject *objB = (GameObject*)bodyB->GetUserData();\nGameArea2D *gameArea = (GameArea2D*)objA.gameArea;\n[gameArea handleCollisionWithObjA:objA withObjB:objB];\n}\n}\n/* GameArea2D.h */\n@implementation GameArea2D\n-(CCLayer*) runRecipe {\n/* CODE OMITTED */\n//Add contact filter and contact listener\nworld->SetContactListener(new basicContactListener);\n/* CODE OMITTED */\n//Add button to hide/show debug drawing\nCCMenuItemFont* swapDebugDrawMIF = [CCMenuItemFont itemFromString:@\"Debug Draw\" target:self selector:@selector(swapDebugDraw)];\nCCMenu *swapDebugDrawMenu = [CCMenu menuWithItems:swapDebugDrawMIF, nil];\nswapDebugDrawMenu.position = ccp( 260 , 20 );\n[self addChild:swapDebugDrawMenu z:5];\n//Schedule our every tick method call\n[self schedule:@selector(step:)];\nreturn self;\n}\n/* This is called from 'basicContactListener'. It will need to be overridden. */\n-(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB {\n/** ABSTRACT **/\n}\n/* Destroy the world upon exit */\n- (void) dealloc {\ndelete world; world = NULL;\ndelete m_debugDraw;\n[super dealloc];\n}\n/* Debug information is drawn over everything */\n-(void) initDebugDraw {\nDebugDrawNode * ddn = [DebugDrawNode createWithWorld:world];\n[ddn setPosition:ccp(0,0)];\n[gameNode addChild:ddn z:100000];\n}\n/* When we show debug draw we add a number of flags to show specific information */\n-(void) showDebugDraw {\ndebugDraw = YES;\nuint32 flags = 0;\nflags += b2DebugDraw::e_shapeBit;\nflags += b2DebugDraw::e_jointBit;\nflags += b2DebugDraw::e_aabbBit;\nflags += b2DebugDraw::e_pairBit;\nflags += b2DebugDraw::e_centerOfMassBit;\nm_debugDraw->SetFlags(flags);\ncollision response routinescreating}\n@end\n@implementation Ch4_CollisionResponse\n-(CCLayer*) runRecipe {\n/* CODE OMITTED */\n//Create circular GameSensor object\nGameSensor *gameObjSensor = [[GameSensor alloc] init];\ngameObjSensor.gameArea = self;\n//Create the body definition\ngameObjSensor.bodyDef->type = b2_staticBody;\ngameObjSensor.bodyDef->position.Set(240/PTM_RATIO,160/PTM_RATIO);\ngameObjSensor.bodyDef->userData = gameObjSensor;\n//Create the body\ngameObjSensor.body = world->CreateBody(gameObjSensor.bodyDef);\n//Create the shape and fixture\ngameObjSensor.circleShape = new b2CircleShape();\ngameObjSensor.circleShape->m_radius = 1.0f;\n//Create the fixture definition\ngameObjSensor.fixtureDef->shape = gameObjSensor.circleShape;\ngameObjSensor.fixtureDef->isSensor = YES;\n//Create the fixture\ngameObjSensor.body->CreateFixture(gameObjSensor.fixtureDef);\n//Create level boundaries\n[self addLevelBoundaries];\n//Add block batch sprite\nCCSpriteBatchNode *batch = [CCSpriteBatchNode batchNodeWithFile:@\"blocks.png\" capacity:150];\n[gameNode addChild:batch z:0 tag:0];\nreturn self;\ncollision response routinescreating}\n/* Our base collision handling routine */\n-(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB {\n//SENSOR to MISC collision\nif(objA.type == GO_TYPE_SENSOR && objB.type == GO_TYPE_MISC){\n[self handleCollisionWithSensor:(GameSensor*)objA withMisc:(GameMisc*)objB];\n}else if(objA.type == GO_TYPE_MISC && objB.type == GO_TYPE_SENSOR){\n[self handleCollisionWithSensor:(GameSensor*)objB withMisc:(GameMisc*)objA];\n}\n//MISC to MISC collision\nelse if(objA.type == GO_TYPE_MISC && objB.type == GO_TYPE_MISC){\n[self handleCollisionWithMisc:(GameMisc*)objA withMisc:(GameMisc*)objB];\n}\n}\n/* Handling collision between specific types of objects */\n-(void) handleCollisionWithSensor:(GameSensor*)sensor withMisc:(GameMisc*)misc {\n[message setString:@\"Box collided with sensor\"];\n[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:0.5f],\n[CCCallFunc actionWithTarget:self selector:@selector(resetMessage)], nil]];\n}\n-(void) handleCollisionWithMisc:(GameMisc*)a withMisc:(GameMisc*)b {\n[message setString:@\"Box collided with another box\"];\n[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:0.5f],\n[CCCallFunc actionWithTarget:self selector:@selector(resetMessage)], nil]];\n}\n/* Adding a new block */\n-(void) addNewObjectWithCoords:(CGPoint)p {\n/* CODE OMITTED */\n}\n- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\nfor( UITouch *touch in touches ) {\nCGPoint location = [touch locationInView: [touch view]];\nlocation = [[CCDirector sharedDirector] convertToGL: location];\n[self addNewObjectWithCoords: location];\n}\n}\n@end\n\n```", "```swift\n    void BeginContact(b2Contact* contact);\n    void EndContact(b2Contact* contact);\n    void PreSolve(b2Contact* contact, const b2Manifold* oldManifold);\n    void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse);\n\n    ```", "```swift\n    -(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB;\n\n    ```", "```swift\n@implementation Ch4_DifferentShapes\n/* Here add an object randomly chosen from a rectangle, square, circle, convex polygon and multi-fixture concave polygon. */\n-(void) addNewObjectWithCoords:(CGPoint)p\n{\n//Initialize the object\nGameMisc *obj = [[GameMisc alloc] init];\nobj.gameArea = self;\nobj.bodyDef->type = b2_dynamicBody;\nobj.bodyDef->position.Set(p.x/PTM_RATIO, p.y/PTM_RATIO);\nobj.bodyDef->userData = obj;\nobj.body = world->CreateBody(obj.bodyDef);\nobj.fixtureDef->density = 1.0f;\nobj.fixtureDef->friction = 0.3f;\nobj.fixtureDef->restitution = 0.2f;\n//Pick a random shape, size and texture\nint num = arc4random()%5;\nif(num == 0){\n/* Create square object */\n/* CODE OMITTED */\n//Create shape, add to fixture def and finally create the fixture\nobj.polygonShape = new b2PolygonShape();\nobj.polygonShape->SetAsBox(shapeSize/PTM_RATIO, shapeSize/PTM_RATIO);\nobj.fixtureDef->shape = obj.polygonShape;\nobj.body->CreateFixture(obj.fixtureDef);\n}else if(num == 1){\n/* Create circle object */\n/* CODE OMITTED */\n//Create shape, add to fixture def and finally create the fixture\nobj.circleShape = new b2CircleShape();\nobj.circleShape->m_radius = shapeSize/PTM_RATIO;\nobj.fixtureDef->shape = obj.circleShape;\nobj.fixtureDef->restitution = 0.9f;\nobj.body->CreateFixture(obj.fixtureDef);\n}else if(num == 2){\n/* Create rectangle object */\n/* CODE OMITTED */\n//Create shape, add to fixture def and finally create the fixture\nobj.polygonShape = new b2PolygonShape();\nobj.polygonShape->SetAsBox(shapeSize.x/PTM_RATIO, shapeSize.y/PTM_RATIO);\nobj.fixtureDef->shape = obj.polygonShape;\nobj.body->CreateFixture(obj.fixtureDef);\n}else if(num == 3){\n/* Create convex polygon object */\n/* CODE OMITTED */\nshapes, Box2Dcreating//Create shape, add to fixture def and finally create the fixture\nobj.polygonShape = new b2PolygonShape();\nobj.polygonShape->Set(vertices, numVerts);\nobj.fixtureDef->shape = obj.polygonShape;\nobj.body->CreateFixture(obj.fixtureDef);\n}else if(num == 4){\n/* Create concave multi-fixture polygon */\n/* CODE OMITTED */\n//Create two opposite rectangles\nfor(int i=0; i<2; i++){\nCGPoint shapeSize;\nif(i == 0){ shapeSize = ccp(2.0f, 0.4f);\n}else{ shapeSize = ccp(0.4f, 2.0f); }\nCGPoint vertexArr[] = { ccp(0,0), ccp(shapeSize.x,0), ccp(shapeSize.x,shapeSize.y), ccp(0,shapeSize.y) };\nint32 numVerts = 4;\nb2Vec2 vertices[4];\nNSMutableArray *vertexArray = [[[NSMutableArray alloc] init] autorelease];\nshapes, Box2Dcreating//Set vertices\nfor(int i=0; i<numVerts; i++){\nvertices[i].Set(vertexArr[i].x, vertexArr[i].y);\n[vertexArray addObject:[NSValue valueWithCGPoint:ccp(vertexArr[i].x *PTM_RATIO, vertexArr[i].y*PTM_RATIO)]];\n}\n//Create textured polygon\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST, GL_REPEAT,GL_REPEAT};\nCCSprite *sprite = [TexturedPolygon createWithFile:@\"box2.png\" withVertices:vertexArray];\n[sprite.texture setTexParameters:&params];\n[sprite setPosition:ccp(0,0)];\n[sprite setColor:color];\n[obj.sprite addChild:sprite];\n//Create shape, set shape and create fixture\nobj.polygonShape = new b2PolygonShape();\nobj.polygonShape->Set(vertices, numVerts);\nobj.fixtureDef->shape = obj.polygonShape;\nobj.body->CreateFixture(obj.fixtureDef);\n}\n}\n//Set a random color\n[obj.sprite setColor:ccc3(arc4random()%255, arc4random()%255, arc4random()%255)];\n}\n- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\nfor( UITouch *touch in touches ) {\nCGPoint location = [touch locationInView: [touch view]];\nlocation = [[CCDirector sharedDirector] convertToGL: location];\n[self addNewObjectWithCoords: location];\n}\n}\n@end\n\n```", "```swift\nenum { //Collision bits for filtering\nCB_GROUND = 1<<0,\nCB_FRUIT = 1<<2,\nCB_BOWL = 1<<4\n};\n@implementation Ch4_DraggingAndFiltering\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[message setString:@\"Pick up the fruit.\"];\n//Create level boundaries\n[self addLevelBoundaries];\ndragging featureusing//Add fruit bowl\n[self addFruitBasket];\n//Initialization of any variables\nfruitGrabbed = NO;\nreturn self;\n}\n/* Add basket and fruit objects */\n-(void) addFruitBasket {\n/* Add the basket */\n/* CODE OMITTED */\n//Add physical parts\nb2BodyDef bowlBodyDef;\nbowlBodyDef.position.Set(0, 0);\nbowlBodyDef.type = b2_staticBody;\nb2Body *body = world->CreateBody(&bowlBodyDef);\nb2PolygonShape bowlShape;\nb2FixtureDef bowlFixtureDef;\nbowlFixtureDef.restitution = 0.5f;\nbowlFixtureDef.filter.categoryBits = CB_BOWL;\nbowlFixtureDef.filter.maskBits = CB_FRUIT;\n//Rim left\nbowlShape.SetAsEdge(b2Vec2(120.0f/PTM_RATIO,120.0f/PTM_RATIO), b2Vec2(180.0f/PTM_RATIO,0.0f/PTM_RATIO));\nbowlFixtureDef.shape = &bowlShape;\nbody->CreateFixture(&bowlFixtureDef);\n/* CODE OMITTED */\ndragging featureusing/* Add fruit */\nfruitObjects = [[[NSMutableArray alloc] init] autorelease];\n[self addFruit:@\"fruit_banana.png\" position:ccp(210,200) shapeType:@\"rect\"];\n[self addFruit:@\"fruit_apple.png\" position:ccp(230,200) shapeType:@\"circle\"];\n[self addFruit:@\"fruit_grapes.png\" position:ccp(250,200) shapeType:@\"rect\"];\n[self addFruit:@\"fruit_orange.png\" position:ccp(270,200) shapeType:@\"circle\"];\n}\n/* Add a fruit object with circle physical properties */\n-(void) addFruit:(NSString*)spriteFrame position:(CGPoint)p shapeType:(NSString*)s {\n//Create GameMisc object\nGameMisc *fruit = [[GameMisc alloc] init];\nfruit.gameArea = self;\n//Define body def and create body\nfruit.bodyDef->type = b2_dynamicBody;\nfruit.bodyDef->position.Set(p.x/PTM_RATIO, p.y/PTM_RATIO);\nfruit.bodyDef->userData = fruit;\nfruit.body = world->CreateBody(fruit.bodyDef);\n//Create fixture def\nfruit.fixtureDef->density = 1.0f;\nfruit.fixtureDef->friction = 0.3f;\nfruit.fixtureDef->restitution = 0.4f;\nfruit.fixtureDef->filter.categoryBits = CB_FRUIT;\nfruit.fixtureDef->filter.maskBits = CB_GROUND | CB_BOWL; //Fruit does not collide with other fruit\n//Create sprite\nfruit.sprite = [CCSprite spriteWithSpriteFrameName:spriteFrame];\nfruit.sprite.position = ccp(p.x,p.y);\nif([s isEqualToString:@\"circle\"]){\n/* Set fixture shape and sprite scale */\nfloat textureSize = 160;\nfloat shapeSize = 40;\ndragging featureusingfruit.sprite.scale = shapeSize / textureSize * 2;\n[gameNode addChild:fruit.sprite z:2];\nfruit.circleShape = new b2CircleShape();\nfruit.circleShape->m_radius = shapeSize/PTM_RATIO;\nfruit.fixtureDef->shape = fruit.circleShape;\n}else if([s isEqualToString:@\"rect\"]){\n/* Set fixture shape and sprite scale */\nCGPoint textureSize = ccp(300,100);\nCGPoint shapeSize = ccp(60,20);\nfruit.sprite.scaleX = shapeSize.x / textureSize.x * 2;\nfruit.sprite.scaleY = shapeSize.y / textureSize.y * 2;\n[gameNode addChild:fruit.sprite z:2];\nfruit.polygonShape = new b2PolygonShape();\nfruit.polygonShape->SetAsBox(shapeSize.x/PTM_RATIO, shapeSize.y/PTM_RATIO);\nfruit.fixtureDef->shape = fruit.polygonShape;\n}\n//Finally create the fixture\nfruit.body->CreateFixture(fruit.fixtureDef);\n//Add object to container\n[fruitObjects addObject:fruit];\ngrabbedFruit = fruit;\n}\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n/* Grab the nearest fruit */\n//We first grab a fruit.\ndragging featureusing//Then, if another fruit is closer we grab that until we finally have the closest one.\nfloat grabbedDistance = distanceBetweenPoints(point, ccp(grabbedFruit.body->GetPosition().x*PTM_RATIO, grabbedFruit.body->GetPosition().y*PTM_RATIO));\nfor(int i=0; i<fruitObjects.count; i++){\nGameMisc *fruit = [fruitObjects objectAtIndex:i];\nfloat thisDistance = distanceBetweenPoints(ccp(fruit.body->GetPosition().x*PTM_RATIO, fruit.body->GetPosition().y*PTM_RATIO), point);\nif(thisDistance < grabbedDistance){\ngrabbedFruit = fruit;\ngrabbedDistance = thisDistance;\n}\n}\n//Set the fruit to 'grabbed'\nfruitGrabbed = YES;\n//Immediately move the fruit\n[self ccTouchesMoved:touches withEvent:event];\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n/* Reposition the grabbed fruit */\ngrabbedFruit.body->SetTransform(b2Vec2(point.x/PTM_RATIO, point.y/PTM_RATIO), grabbedFruit.body->GetAngle());\nb2Vec2 moveDistance = b2Vec2( (point.x/PTM_RATIO - grabbedFruit.sprite.position.x/PTM_RATIO), (point.y/PTM_RATIO - grabbedFruit.sprite.position.y/PTM_RATIO) );\nlastFruitVelocity = b2Vec2(moveDistance.x*20, moveDistance.y*20);\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* Release the fruit */\nfruitGrabbed = NO;\ndragging featureusinggrabbedFruit.body->SetLinearVelocity(lastFruitVelocity);\n}\n-(void) step: (ccTime) dt {\n[super step:dt];\n/* Suspend the fruit in mid-air while it is grabbed */\nif(fruitGrabbed){\ngrabbedFruit.body->SetLinearVelocity(b2Vec2_zero);\n}\n}\n@end\n\n```", "```swift\ngrabbedFruit.body->SetTransform(b2Vec2(point.x/PTM_RATIO, point.y/PTM_RATIO), grabbedFruit.body->GetAngle());\n\n```", "```swift\ngrabbedFruit.body->SetLinearVelocity(lastFruitVelocity);\n\n```", "```swift\n    enum {\n    CB_GROUND = 1<<0,\n    CB_FRUIT = 1<<2,\n    CB_BOWL = 1<<4\n    };\n    fruit.fixtureDef->filter.categoryBits = CB_FRUIT;\n    fruit.fixtureDef->filter.maskBits = CB_GROUND | CB_BOWL;\n\n    ```", "```swift\n@implementation Ch4_PhysicalProperties\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[message setString:@\"Friction and restitution\"];\n//Variable initialization\nmovableObjects = [[[NSMutableArray alloc] init] autorelease];\nobjectGrabbed = NO;\n//Create level boundaries\n[self addLevelBoundaries];\n/* Add a crate, a block of ice, bouncing balls and a ledge */\n//Crate with 0.4f friction\n[self addBlockWithSpriteFile:@\"crate2.png\" friction:0.4f textureSize:64.0f shapeSize:20.0f position:ccp(130,250)];\n//Ice block with 0.0f friction\n[self addBlockWithSpriteFile:@\"ice_block.png\" friction:0.0f textureSize:70.0f shapeSize:20.0f position:ccp(10,250)];\n//Ball with size 5.0f and restitution 0.9f\n[self addBallWithShapeSize:5.0f restitution:0.9f position:ccp(450,200) color:ccc3(255,0,0)];\n//Ball with size 10.0f and restitution 0.8f\n[self addBallWithShapeSize:10.0f restitution:0.8f position:ccp(400,200) color:ccc3(255,128,0)];\n//Ball with size 15.0f and restitution 0.7f\n[self addBallWithShapeSize:15.0f restitution:0.7f position:ccp(350,200) color:ccc3(255,255,0)];\n//Ball with size 20.0f and restitution 0.6f\n[self addBallWithShapeSize:20.0f restitution:0.6f position:ccp(300,200) color:ccc3(0,255,0)];\n//Add brick ledge\n[self addLedge];\nreturn self;\n}\n/* Add a block with a certain texture, size, position and friction */\n-(void) addBlockWithSpriteFile:(NSString*)file friction:(float)friction textureSize:(float)textureSize shapeSize:(float)shapeSize position:(CGPoint)p {\n/* CODE OMITTED */\n}\n/* Add a ball with a certain size, position, color and restitution */\n-(void) addBallWithShapeSize:(float)shapeSize restitution:(float)restitution position:(CGPoint)p color:(ccColor3B)color {\n/* CODE OMITTED */\n}\n/* Add a brick textured ledge polygon to show the blocks sliding down */\n-(void) addLedge {\nGameMisc *obj = [[GameMisc alloc] init];\nobj.gameArea = self;\nphysical propertiesmanipulatingobj.bodyDef->position.Set(0,100/PTM_RATIO);\nobj.body = world->CreateBody(obj.bodyDef);\nobj.fixtureDef->density = 1.0f;\nobj.fixtureDef->friction = 0.3f;\nobj.fixtureDef->restitution = 0.2f;\nfloat polygonSize = 4;\nCGPoint vertexArr[] = { ccp(0,0.8f), ccp(2,0.5f), ccp(2,0.7f), ccp(0,1) };\nint32 numVerts = 4;\nb2Vec2 vertices[4];\nNSMutableArray *vertexArray = [[[NSMutableArray alloc] init] autorelease];\nfor(int i=0; i<numVerts; i++){\nvertices[i].Set(vertexArr[i].x*polygonSize, vertexArr[i].y*polygonSize);\n[vertexArray addObject:[NSValue valueWithCGPoint:ccp(vertexArr[i].x*PTM_RATIO*polygonSize,\nvertexArr[i].y*PTM_RATIO*polygonSize)]];\n}\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};\nobj.sprite = [TexturedPolygon createWithFile:@\"bricks2.png\" withVertices:vertexArray];\n[obj.sprite.texture setTexParameters:&params];\n[obj.sprite setPosition:ccp(0,100)];\n[gameNode addChild:obj.sprite z:1];\nobj.polygonShape = new b2PolygonShape();\nobj.polygonShape->Set(vertices, numVerts);\nobj.fixtureDef->shape = obj.polygonShape;\nobj.body->CreateFixture(obj.fixtureDef);\n}\n@end\n\n```", "```swift\nenum { //Object type tags\nTYPE_OBJ_BASKETBALL = 0,\nTYPE_OBJ_SHOOTER = 1,\nTYPE_OBJ_NET_SENSOR = 2\n};\n@implementation Ch4_Impulses\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[message setString:@\"Shoot the ball in the hoop.\"];\n//Create level boundaries\n[self addLevelBoundaries];\n//Add level background\nCCSprite *bg = [CCSprite spriteWithFile:@\"bball_bg.png\"];\nbg.position = ccp(240,160);\n[gameNode addChild:bg z:0];\n//Add basketball\n[self addBasketball];\n//Add basketball net\n[self addBasketballNet];\n//Add shooter\n[self addShooter];\nreturn self;\nimpulsesapplying}\n/* Add a basketball net with a sensor */\n-(void) addBasketballNet {\n/* CODE OMITTED */\n//Add net sensor\nGameSensor *gameObjSensor = [[GameSensor alloc] init];\ngameObjSensor.typeTag = TYPE_OBJ_NET_SENSOR;\ngameObjSensor.gameArea = self;\ngameObjSensor.bodyDef->type = b2_staticBody;\ngameObjSensor.bodyDef->position.Set(0,0);\ngameObjSensor.bodyDef->userData = gameObjSensor;\ngameObjSensor.body = world->CreateBody(gameObjSensor.bodyDef);\ngameObjSensor.polygonShape = new b2PolygonShape();\ngameObjSensor.polygonShape->SetAsEdge(b2Vec2(370.0f/PTM_RATIO,200.0f/PTM_RATIO), b2Vec2(380.0f/PTM_RATIO,200.0f/PTM_RATIO));\ngameObjSensor.fixtureDef->shape = gameObjSensor.polygonShape;\ngameObjSensor.fixtureDef->isSensor = YES;\ngameObjSensor.body->CreateFixture(gameObjSensor.fixtureDef);\n}\n/* Add a basketball */\n-(void) addBasketball {\n/* CODE OMITTED */\n}\n/* Add a shooter with reverse karate chop action! */\n-(void) addShooter {\n/* CODE OMITTED */\nimpulsesapplying}\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n/* Apply an impulse when the user touches the screen */\nCGPoint vect = ccp(point.x - basketball.body->GetPosition().x*PTM_RATIO, point.y - basketball.body->GetPosition().y*PTM_RATIO);\nbasketball.body->ApplyLinearImpulse(b2Vec2(vect.x/20, vect.y/20) , basketball.body->GetPosition() );\n}\n/* Main collision handling routine */\n-(void) handleCollisionWithObjA:(GameObject*)objA withObjB:(GameObject*)objB {\n//SENSOR to MISC collision\nif(objA.type == GO_TYPE_SENSOR && objB.type == GO_TYPE_MISC){\n[self handleCollisionWithSensor:(GameSensor*)objA withMisc:(GameMisc*)objB];\n}else if(objA.type == GO_TYPE_MISC && objB.type == GO_TYPE_SENSOR){\n[self handleCollisionWithSensor:(GameSensor*)objB withMisc:(GameMisc*)objA];\n}\n}\n/* SENSOR to MISC collision */\n-(void) handleCollisionWithSensor:(GameSensor*)sensor withMisc:(GameMisc*)misc {\nif(misc.typeTag == TYPE_OBJ_BASKETBALL && sensor.typeTag == TYPE_OBJ_NET_SENSOR){\n//Animate the net when the shooter makes a basket\n/* CODE OMITTED */\n}else if(misc.typeTag == TYPE_OBJ_BASKETBALL && sensor.typeTag == TYPE_OBJ_SHOOTER){\n//Animate the shooter's arm and apply an impulse when he touches the ball */\nimpulsesapplying/* CODE OMITTED */\nbasketball.body->SetLinearVelocity(b2Vec2(0,0));\nbasketball.body->ApplyLinearImpulse(b2Vec2(3.5f, 7) , basketball.body->GetPosition() );\n}\n}\n@end\n\n```", "```swift\n    basketball.body->SetLinearVelocity(b2Vec2(0,0));\n    basketball.body->ApplyLinearImpulse(b2Vec2(3.5f, 7) , basketball.body->GetPosition() );\n\n    ```", "```swift\n@implementation Ch4_Forces\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Set our gravity to 0\nworld->SetGravity(b2Vec2(0,0));\n//Level background\nCCSprite *bg = [CCSprite spriteWithFile:@\"solar_system_bg.png\"];\nbg.position = ccp(240,160);\n[gameNode addChild:bg z:0];\n//Add Planets\nplanets = [[[NSMutableDictionary alloc] init] autorelease];\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@\"solar_system.plist\"];\nforcesapplying[self addPlanetWithSpriteFrameName:@\"sun.png\" position:ccp(240,160)];\n[self addPlanetWithSpriteFrameName:@\"mercury.png\" position:ccp(210,160)];\n[self addPlanetWithSpriteFrameName:@\"venus.png\" position:ccp(195,160)];\n[self addPlanetWithSpriteFrameName:@\"earth.png\" position:ccp(170,160)];\n[self addPlanetWithSpriteFrameName:@\"mars.png\" position:ccp(150,160)];\n[self addPlanetWithSpriteFrameName:@\"jupiter.png\" position:ccp(120,160)];\n[self addPlanetWithSpriteFrameName:@\"saturn.png\" position:ccp(90,160)];\n[self addPlanetWithSpriteFrameName:@\"uranus.png\" position:ccp(60,160)];\n[self addPlanetWithSpriteFrameName:@\"neptune.png\" position:ccp(30,160)];\n//Apply initial impulses to planets\n[[planets objectForKey:@\"mercury.png\"] body]->ApplyLinearImpulse(b2Vec2(0,0.075f), [[planets objectForKey:@\"mercury.png\"] body]->GetPosition());\n[[planets objectForKey:@\"venus.png\"] body]->ApplyLinearImpulse(b2Vec2(0,0.25f), [[planets objectForKey:@\"venus.png\"] body]->GetPosition());\n[[planets objectForKey:@\"earth.png\"] body]->ApplyLinearImpulse(b2Vec2(0,0.45f), [[planets objectForKey:@\"earth.png\"] body]->GetPosition());\n[[planets objectForKey:@\"mars.png\"] body]->ApplyLinearImpulse(b2Vec2(0,0.175f), [[planets objectForKey:@\"mars.png\"] body]->GetPosition());\n[[planets objectForKey:@\"jupiter.png\"] body]->ApplyLinearImpulse(b2Vec2(0,1.3f), [[planets objectForKey:@\"jupiter.png\"] body]->GetPosition());\n[[planets objectForKey:@\"saturn.png\"] body]->ApplyLinearImpulse(b2Vec2(0,4.5f), [[planets objectForKey:@\"saturn.png\"] body]->GetPosition());\n[[planets objectForKey:@\"uranus.png\"] body]->ApplyLinearImpulse(b2Vec2(0,0.6f), [[planets objectForKey:@\"uranus.png\"] body]->GetPosition());\n[[planets objectForKey:@\"neptune.png\"] body]->ApplyLinearImpulse(b2Vec2(0,0.8f), [[planets objectForKey:@\"neptune.png\"] body]->GetPosition());\n//Fast forward about 16 seconds to create realistic orbits from the start\nfor(int i=0; i<1000; i++){\n[self step:0.016666667f];\nforcesapplying}\nreturn self;\n}\n/* Every tick applies a force on each planet according to how large it is and how far it is from the sun. This simulates heavenly rotation. */\n-(void) step:(ccTime)dt {\n[super step:dt];\nGameMisc *sun = [planets objectForKey:@\"sun.png\"];\nfor(id key in planets){\nGameMisc *planet = [planets objectForKey:key];\nif(![key isEqualToString:@\"sun.png\"]){\nCGPoint vect = ccp(sun.body->GetPosition().x - planet.body->GetPosition().x, sun.body->GetPosition().y - planet.body->GetPosition().y);\nfloat planetSize = pow([planet.sprite contentSize].width,2);\nfloat dist = distanceBetweenPoints(ccp(sun.body->GetPosition().x, sun.body->GetPosition().y),\nccp(planet.body->GetPosition().x, planet.body->GetPosition().y));\nfloat mod = dist/planetSize*2000;\nplanet.body->ApplyForce(b2Vec2(vect.x/mod, vect.y/mod) , planet.body->GetPosition() );\n}\n}\n}\n/* Add a planet with a spriteFrame and a position. We determine the shape size from the texture size. */\n-(void) addPlanetWithSpriteFrameName:(NSString*)frameName position:(CGPoint)p {\n/* CODE OMITTED */\n}\n@end\n\n```", "```swift\n    planet.body->ApplyForce(b2Vec2(vect.x/mod, vect.y/mod) , planet.body->GetPosition() );\n\n    ```", "```swift\n@interface GameObjectCallback : NSObject {\n@public\nGameObject *gameObject;\nNSString *callback;\n}\n@end\n@interface QueuedAction : NSObject {\n@public\nGameObject* gameObject;\nCCAction* action;\n}\n@end\n@interface GameArea2D : Recipe {\nNSMutableArray *bodiesToDestroy;\nNSMutableArray *postDestructionCallbacks;\nNSMutableArray *bodiesToCreate;\nNSMutableArray *queuedActions;\n}\n@implementation GameArea2D\n-(void) step: (ccTime) dt {\n//Process body destruction/creation\n[self destroyBodies];\n[self createBodies];\n[self runQueuedActions];\n}\nasynchronous body destructionsteps/* Mark a body for destruction */\n-(void) markBodyForDestruction:(GameObject*)obj {\n[bodiesToDestroy addObject:[NSValue valueWithPointer:obj]];\n}\n/* Destroy queued bodies */\n-(void) destroyBodies {\nfor(NSValue *value in bodiesToDestroy){\nGameObject *obj = (GameObject*)[value pointerValue];\nif(obj && obj.body && !obj.markedForDestruction){\nobj.body->SetTransform(b2Vec2(0,0),0);\nworld->DestroyBody(obj.body);\nobj.markedForDestruction = YES;\n}\n}\n[bodiesToDestroy removeAllObjects];\n//Call all game object callbacks\nfor(NSValue *value in postDestructionCallbacks){\nGameObjectCallback *goc = (GameObjectCallback*)value;\n[goc.gameObject runAction:[CCCallFunc actionWithTarget:goc.gameObject selector:NSSelectorFromString(goc.callback)]];\n}\n[postDestructionCallbacks removeAllObjects];\n}\n/* Mark a body for creation */\n-(void) markBodyForCreation:(GameObject*)obj {\n[bodiesToCreate addObject:[NSValue valueWithPointer:obj]];\n}\nasynchronous body destructionsteps/* Create all queued bodies */\n-(void) createBodies {\nfor(NSValue *value in bodiesToCreate){\nGameObject *obj = (GameObject*)[value pointerValue];\nobj.body = world->CreateBody(obj.bodyDef);\nobj.body->CreateFixture(obj.fixtureDef);\n}\n[bodiesToCreate removeAllObjects];\n}\n/* Run any queued actions after creation/destruction */\n-(void) runQueuedActions {\nfor(NSValue *value in queuedActions){\nQueuedAction *qa = (QueuedAction*)[value pointerValue];\nGameObject *gameObject = (GameObject*)qa.gameObject;\nCCAction *action = (CCAction*)qa.action;\n[gameObject runAction:action];\n}\n[queuedActions removeAllObjects];\n}\n@end\n@implementation Ch4_AsyncBodyDestruction\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[message setString:@\"Tap to throw a grenade.\"];\n//Create level boundaries\n[self addLevelBoundaries];\nasynchronous body destructionsteps//Add gunman\n[self addGunman];\n//Initialize explosion animation\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@\"explosion5.plist\"];\n//Initialize grenade container\ngrenades = [[[NSMutableArray alloc] init] autorelease];\nreturn self;\n}\n-(void) step:(ccTime)delta {\n[super step:delta];\n//Grenade life cycle\nfor(id obj in grenades){\nGameMisc *grenade = (GameMisc*)obj;\ngrenade.life -= delta;\n//If a grenade is out of life we mark it for destruction, do cleanup and finally animate an explosion\nif(grenade.life < 0){\n[self markBodyForDestruction:grenade];\n[grenades removeObject:obj];\n[self explosionAt:grenade.sprite.position];\n[gameNode removeChild:grenade.sprite cleanup:NO];\n}\n}\n//Explosion life cycle\nfor(id obj in explosions){\nGameMisc *explosion = (GameMisc*)explosion;\nexplosion.life -= delta;\nif(explosion.life < 0){\n[explosions removeObject:explosion];\n[gameNode removeChild:explosion.sprite cleanup:YES];\n}\n}\n}\nasynchronous body destructionsteps/* Callback for throwing the arm. This involves animating the arm and creating a grenade */\n-(void) throwGrenade {\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n//Animate the arm\nCCAnimation *animation = [[CCAnimation alloc] initWithName:@\"gunmanStandRightArmEmpty\" delay:1.0f];\n[animation addFrame:[cache spriteFrameByName:@\"gunman_stand_right_arm_empty.png\"]];\n[gunmanArm runAction:[CCRepeatForever actionWithAction:[CCAnimate actionWithAnimation:animation]]];\n//Create and launch a grenade\nGameMisc *grenade = [[GameMisc alloc] init];\ngrenade.life = 5.0f;\ngrenade.gameArea = self;\nCGPoint grenadePosition = ccp(65,150);\ngrenade.bodyDef->type = b2_dynamicBody;\ngrenade.bodyDef->position.Set(grenadePosition.x/PTM_RATIO, grenadePosition.y/PTM_RATIO);\ngrenade.body = world->CreateBody(grenade.bodyDef);\ngrenade.body->SetTransform(b2Vec2(grenadePosition.x/PTM_RATIO, grenadePosition.y/PTM_RATIO),PI/2);\nCGPoint textureSize = ccp(16,16);\nCGPoint shapeSize = ccp(7,7);\ngrenade.sprite = [CCSprite spriteWithSpriteFrameName:@\"gunman_grenade.png\"];\ngrenade.sprite.position = ccp(grenadePosition.x,grenadePosition.y);\ngrenade.sprite.scaleX = shapeSize.x / textureSize.x * 2;\ngrenade.sprite.scaleY = shapeSize.y / textureSize.y * 2;\n[gameNode addChild:grenade.sprite z:1];\ngrenade.circleShape = new b2CircleShape();\ngrenade.circleShape->m_radius = shapeSize.x/PTM_RATIO;\ngrenade.fixtureDef->shape = grenade.circleShape;\ngrenade.body->CreateFixture(grenade.fixtureDef);\n[grenades addObject:grenade];\ngrenade.body->ApplyLinearImpulse(b2Vec2(1.0f,2.0f) , grenade.body->GetPosition() );\ngrenade.body->SetAngularVelocity(PI);\n}\n@end\n\n```", "```swift\n    -(void) markBodyForDestruction:(GameObject*)obj;\n    -(void) destroyBodies;\n    -(void) markBodyForCreation:(GameObject*)obj;\n    -(void) createBodies;\n    -(void) runQueuedActions;\n\n    ```", "```swift\n@implementation Ch4_Joints\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[message setString:@\"Drop the weight on the see-saw\"];\n//Initialization\nmovableObjects = [[[NSMutableArray alloc] init] autorelease];\nobjectGrabbed = NO;\n//Create level boundaries\n[self addLevelBoundaries];\n//Add objects\n[self addSeeSaw];\n[self addBoxWithPosition:ccp(130,120) file:@\"crate2.png\" density:1.0f];\n[self addBoxWithPosition:ccp(160,120) file:@\"crate2.png\" density:1.0f];\n[self addBoxWithPosition:ccp(145,150) file:@\"crate2.png\" density:1.0f];\n[self addBoxWithPosition:ccp(270,100) file:@\"weight.png\" density:15.0f];\nreturn self;\n}\n/* Create a complex see-saw object */\n-(void) addSeeSaw {\n/* The triangle is the static base of the see-saw */\nCGPoint trianglePosition = ccp(240,50);\nGameMisc *triangle = [[GameMisc alloc] init];\ntriangle.gameArea = self;\ntriangle.bodyDef->type = b2_staticBody;\ntriangle.bodyDef->position.Set(trianglePosition.x/PTM_RATIO, trianglePosition.y/PTM_RATIO);\ntriangle.body = world->CreateBody(triangle.bodyDef);\njointsusing//Our triangle polygon\nfloat polygonSize = 2.0f;\nCGPoint vertexArr[] = { ccp(0,0), ccp(1,0), ccp(0.5f,1) };\nint32 numVerts = 3;\nb2Vec2 vertices[3];\nNSMutableArray *vertexArray = [[[NSMutableArray alloc] init] autorelease];\nfor(int i=0; i<numVerts; i++){\nvertices[i].Set(vertexArr[i].x*polygonSize, vertexArr[i].y*polygonSize);\n[vertexArray addObject:[NSValue valueWithCGPoint:ccp(vertexArr[i].x*PTM_RATIO*polygonSize,\nvertexArr[i].y*PTM_RATIO*polygonSize)]];\n}\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};\ntriangle.sprite = [TexturedPolygon createWithFile:@\"box.png\" withVertices:vertexArray];\n[triangle.sprite.texture setTexParameters:&params];\n[triangle.sprite setPosition:ccp(trianglePosition.x,trianglePosition.y)];\n[gameNode addChild:triangle.sprite z:1];\ntriangle.polygonShape = new b2PolygonShape();\ntriangle.polygonShape->Set(vertices, numVerts);\ntriangle.fixtureDef->shape = triangle.polygonShape;\ntriangle.body->CreateFixture(triangle.fixtureDef);\n/* The plank is the dynamic part of the see-saw */\nCGPoint plankPosition = ccp(270,80);\nGameMisc *plank = [[GameMisc alloc] init];\nplank.gameArea = self;\nplank.bodyDef->type = b2_dynamicBody;\nplank.bodyDef->position.Set(plankPosition.x/PTM_RATIO, plankPosition.y/PTM_RATIO);\nplank.body = world->CreateBody(plank.bodyDef);\njointsusingplank.body->SetTransform(b2Vec2(plankPosition.x/PTM_RATIO, plankPosition.y/PTM_RATIO),PI/2);\nCGPoint textureSize = ccp(54,215);\nCGPoint shapeSize = ccp(12,180);\nplank.sprite = [CCSprite spriteWithFile:@\"column2.png\"];\nplank.sprite.position = ccp(plankPosition.x,plankPosition.y);\nplank.sprite.scaleX = shapeSize.x / textureSize.x * 2;\nplank.sprite.scaleY = shapeSize.y / textureSize.y * 2;\n[gameNode addChild:plank.sprite z:1];\nplank.polygonShape = new b2PolygonShape();\nplank.polygonShape->SetAsBox(shapeSize.x/PTM_RATIO, shapeSize.y/PTM_RATIO);\nplank.fixtureDef->shape = plank.polygonShape;\nplank.body->CreateFixture(plank.fixtureDef);\n/* We initialize a revolute joint linking the plank to the triangle */\nb2RevoluteJointDef rjd;\nb2RevoluteJoint* joint;\nrjd.Initialize(plank.body, triangle.body, b2Vec2(trianglePosition.x/PTM_RATIO + polygonSize/2, trianglePosition.y/PTM_RATIO + polygonSize/2));\njoint = (b2RevoluteJoint*)world->CreateJoint(&rjd);\n}\n\n```", "```swift\n    b2RevoluteJointDef rjd;\n    b2RevoluteJoint* joint;\n    rjd.Initialize(plank.body, triangle.body, b2Vec2(trianglePosition.x/PTM_RATIO + polygonSize/2, trianglePosition.y/PTM_RATIO + polygonSize/2));\n    joint = (b2RevoluteJoint*)world->CreateJoint(&rjd);\n\n    ```", "```swift\n@implementation Ch4_Vehicles\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[message setString:@\"Press and hold to drive car.\"];\n//Initialization\npressedLeft = NO;\npressedRight = NO;\n//Create level\n[self createLevel];\n//Add taxi\n[self addTaxi];\nreturn self;\n}\n-(void) createLevel {\n/* Create a sine wave road for our car */\nb2BodyDef groundBodyDef;\ngroundBodyDef.position.Set(0, 0);\nb2Body *body = world->CreateBody(&groundBodyDef);\nvehiclecreatingb2PolygonShape groundBox;\nb2FixtureDef groundFixtureDef;\ngroundFixtureDef.restitution = 0.0f;\ngroundFixtureDef.friction = 10.0f; //The road has a lot of friction\ngroundFixtureDef.filter.categoryBits = CB_GROUND;\ngroundFixtureDef.filter.maskBits = CB_CAR | CB_WHEEL;\ngroundBox.SetAsEdge(b2Vec2(-960/PTM_RATIO,0), b2Vec2(-960/PTM_RATIO,200/PTM_RATIO));\ngroundFixtureDef.shape = &groundBox;\nbody->CreateFixture(&groundFixtureDef);\ngroundBox.SetAsEdge(b2Vec2(960/PTM_RATIO,0), b2Vec2(960/PTM_RATIO,200/PTM_RATIO));\ngroundFixtureDef.shape = &groundBox;\nbody->CreateFixture(&groundFixtureDef);\nfloat32 x1; float32 y1;\nfor(int u = -1; u < 2; u++){\n//Add Edge Shapes\nx1 = -15.0f;\ny1 = 2.0f * cosf(x1 / 10.0f * b2_pi);\nfor (int32 i = 0; i < 60; ++i)\n{\nfloat32 x2 = x1 + 0.5f;\nfloat32 y2 = 2.0f * cosf(x2 / 10.0f * b2_pi);\nb2PolygonShape shape;\nshape.SetAsEdge(b2Vec2(x1 + u*960/PTM_RATIO, y1), b2Vec2(x2 + u*960/PTM_RATIO, y2));\nbody->CreateFixture(&shape, 0.0f);\nvehiclecreatingx1 = x2;\ny1 = y2;\n}\n//Add corresponding graphics\nCCSprite *bg = [CCSprite spriteWithFile:@\"road_bg.png\"];\nbg.position = ccp(u*960,70);\n[gameNode addChild:bg z:0];\nCCSprite *fg = [CCSprite spriteWithFile:@\"road_fg.png\"];\nfg.position = ccp(u*960,70);\n[gameNode addChild:fg z:2];\n}\n/* Add two bricks walls so you can't drive off the course */\n[self addBrickWallSpriteAtPosition:ccp(970,60)];\n[self addBrickWallSpriteAtPosition:ccp(-970,60)];\n}\n-(void) addTaxi {\n// NOTE: In b2Settings.h we increased the b2_maxPolygonVertices definition:\n// #define b2_maxPolygonVertices 16\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@\"taxi.plist\"];\nCGPoint taxiPosition = ccp(-960,80);\nfloat taxiScale = 0.2f;\ntaxi = [[GameMisc alloc] init];\ntaxi.gameArea = self;\ntaxi.bodyDef->type = b2_dynamicBody;\ntaxi.bodyDef->position.Set(taxiPosition.x/PTM_RATIO, taxiPosition.y/PTM_RATIO);\ntaxi.body = world->CreateBody(taxi.bodyDef);\ntaxi.fixtureDef->filter.categoryBits = CB_CAR;\ntaxi.fixtureDef->filter.maskBits = CB_GROUND;\ntaxi.fixtureDef->density = 0.5f;\ntaxi.fixtureDef->friction = 0.25f;\ntaxi.fixtureDef->restitution = 0.0f;\n//Polygon\n/* CODE OMITTED */\nvehiclecreating//Wheels\nCGPoint wheelPosition[] = { ccp(taxiPosition.x + 16, taxiPosition.y), ccp(taxiPosition.x + 43, taxiPosition.y) };\nfor(int i=0; i<2; i++){\nGameMisc *wheel = [[GameMisc alloc] init];\nif(i == 0){\nwheel1 = wheel;\n}else{\nwheel2 = wheel;\n}\nwheel.gameArea = self;\nwheel.bodyDef->type = b2_dynamicBody;\nwheel.bodyDef->position.Set(wheelPosition[i].x/PTM_RATIO, wheelPosition[i].y/PTM_RATIO);\nwheel.body = world->CreateBody(wheel.bodyDef);\nwheel.body->SetTransform(b2Vec2(wheelPosition[i].x/PTM_RATIO, wheelPosition[i].y/PTM_RATIO),PI/2);\nwheel.fixtureDef->filter.categoryBits = CB_WHEEL;\nwheel.fixtureDef->filter.maskBits = CB_GROUND;\nwheel.fixtureDef->density = 10.0f;\nwheel.fixtureDef->friction = 10.0f;\nwheel.fixtureDef->restitution = 0.0f;\nCGPoint textureSize = ccp(52,51);\nCGPoint shapeSize = ccp(9,9);\nwheel.sprite = [CCSprite spriteWithSpriteFrameName:@\"taxi_wheel.png\"];\nwheel.sprite.position = ccp(wheelPosition[i].x,wheelPosition[i].y);\nwheel.sprite.scaleX = shapeSize.x / textureSize.x * 2;\nwheel.sprite.scaleY = shapeSize.y / textureSize.y * 2;\n[gameNode addChild:wheel.sprite z:1];\nwheel.circleShape = new b2CircleShape();\nwheel.circleShape->m_radius = shapeSize.x/PTM_RATIO;\nwheel.fixtureDef->shape = wheel.circleShape;\nwheel.body->CreateFixture(wheel.fixtureDef);\nwheel.body->SetAngularDamping(1.0f);\n//Add Joint to connect wheel to the taxi\nvehiclecreatingb2RevoluteJointDef rjd;\nb2RevoluteJoint* joint;\nrjd.Initialize(wheel.body, taxi.body, b2Vec2(wheelPosition[i].x/PTM_RATIO, wheelPosition[i].y/PTM_RATIO));\njoint = (b2RevoluteJoint*)world->CreateJoint(&rjd);\n}\n}\n-(void) step: (ccTime) dt {\n[super step:dt];\ngameNode.position = ccp(-taxi.sprite.position.x + 240, -taxi.sprite.position.y + 160);\n//Front wheel drive\n//We apply some counter-torque to steady the car\nif(pressedRight){\nwheel2->body->ApplyTorque(-20.0f);\ntaxi->body->ApplyTorque(5.0f);\n}else if(pressedLeft){\nwheel1->body->ApplyTorque(20.0f);\ntaxi->body->ApplyTorque(-5.0f);\n}\n}\n@end\n\n```", "```swift\n    wheel2->body->ApplyTorque(-20.0f);\n    taxi->body->ApplyTorque(5.0f);\n\n    ```", "```swift\n    gameNode.position = ccp(-taxi.sprite.position.x + 240, -taxi.sprite.position.y + 160);\n\n    ```", "```swift\n    #define b2_maxPolygonVertices 16\n\n    ```", "```swift\n@implementation SideScrollerRecipe\n-(void) step:(ccTime)delta {\n[super step:delta];\n//Apply gunman running direction\nif(dPad.direction == DPAD_LEFT || dPad.direction == DPAD_UP_LEFT || dPad.direction == DPAD_DOWN_LEFT){\ngunmanDirection = DPAD_LEFT;\ngunman.body->ApplyForce(b2Vec2(-35.0f,0), gunman.body->GetPosition());\n((CCSprite*)[gunman.sprite getChildByTag:0]).flipX = YES;\n}else if(dPad.direction == DPAD_RIGHT || dPad.direction == DPAD_UP_RIGHT || dPad.direction == DPAD_DOWN_RIGHT){\ngunmanDirection = DPAD_RIGHT;\ngunman.body->ApplyForce(b2Vec2(35.0f,0), gunman.body->GetPosition());\n((CCSprite*)[gunman.sprite getChildByTag:0]).flipX = NO;\n}\n//Decrement jump counter\njumpCounter -= delta;\n//Did the gunman just hit the ground?\nif(!onGround){\nif((gunman.body->GetLinearVelocity().y - lastYVelocity) > 2 && lastYVelocity < -2){\ngunman.body->SetLinearVelocity(b2Vec2(gunman.body->GetLinearVelocity().x,0));\nonGround = YES;\n}else if(gunman.body->GetLinearVelocity().y == 0 && lastYVelocity == 0){\ngunman.body->SetLinearVelocity(b2Vec2(gunman.body->GetLinearVelocity().x,0));\nonGround = YES;\n}\n}\n//Did he just fall off the ground without jumping?\nif(onGround){\nif(gunman.body->GetLinearVelocity().y < -2.0f && lastYVelocity < -2.0f && (gunman.body->GetLinearVelocity().y < lastYVelocity)){\nonGround = NO;\ncharactermoving}\n}\n//Store last velocity\nlastYVelocity = gunman.body->GetLinearVelocity().y;\n//Keep him upright on the ground\nif(onGround){\ngunman.body->SetTransform(gunman.body->GetPosition(),0);\n}\n//Animate gunman if his speed changed significantly\nfloat speed = gunman.body->GetLinearVelocity().x;\nif(speed < 0){ speed *= -1; }\nif(speed > lastXSpeed*2){\n[[gunman.sprite getChildByTag:0] stopAllActions];\n[self animateGunman];\n}\n//Keep the gunman in the level\nb2Vec2 gunmanPos = gunman.body->GetPosition();\nif(gunmanPos.x > 530/PTM_RATIO || gunmanPos.x < (-50/PTM_RATIO) || gunmanPos.y < -100/PTM_RATIO){\ngunman.body->SetTransform(b2Vec2(2,10), gunman.body->GetAngle());\n}\n//Process input for the A button\nfor(id b in buttons){\nGameButton *button = (GameButton*)b;\nif(button.pressed && [button.name isEqualToString:@\"A\"]){\n[self processJump];\n}else{\njumpCounter = -10.0f;\n}\n}\n}\n/* Initialize gunman */\n-(void) initGunman {\ngunman = [[GameMisc alloc] init];\n/* CODE OMITTED */\ngunman.body->SetLinearDamping(2.0f);\n}\n/* Process jump */\n-(void) processJump {\nif(onGround && jumpCounter < 0){\n//Start a jump. Starting requires you to not be moving on the Y.\njumpCounter = 0.4f;\ngunman.body->ApplyLinearImpulse(b2Vec2(0,20.0f), gunman.body->GetPosition());\nonGround = NO;\n}else if(jumpCounter > 0){\n//Continue a jump\ngunman.body->ApplyForce(b2Vec2(0,65.0f), gunman.body->GetPosition());\n}\n}\n\n```", "```swift\n    gunman.body->ApplyForce(b2Vec2(35.0f,0), gunman.body->GetPosition());\n\n    ```", "```swift\n    gunman.body->SetLinearDamping(2.0f);\n\n    ```", "```swift\n    float lastYVelocity;\n    float jumpCounter;\n    bool onGround;\n\n    ```", "```swift\n@implementation Ch4_Bullets\n/* Fire the gun */\n-(void) fireGun {\n//Fire 10 bullets per second\nif(fireCount > 0){\nreturn;\n}\nfireCount = 0.2f;\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n//Fire bullet in the correct direction\nfloat gunAngle = -gunman.body->GetAngle() + PI/2;\nif(gunmanDirection == DPAD_LEFT){ gunAngle += PI; }\nCGPoint bulletVector = ccp( sin(gunAngle), cos(gunAngle) );\n//Create bullet and shell casing\nbulletssimulatingfor(int i=0; i<2; i++){\n//Create bullet or casing object\n//NOTE: It might be more efficient to re-use a group of bullet objects instead of creating new bullets each time\nGameMisc *bullet = [[GameMisc alloc] init];\nbullet.gameArea = self;\nbullet.typeTag = TYPE_OBJ_BULLET;\nif(i == 1){\nbullet.typeTag = TYPE_OBJ_SHELL;\n}\nbullet.life = 2.0f;\nif(i == 1){\nbullet.life = 5.0f;\n}\n//Calculate bullet/casing position as being slightly ahead of the gunman\nCGPoint bulletPosition = ccp( gunman.sprite.position.x + bulletVector.x*10, gunman.sprite.position.y + bulletVector.y*10 );\nif(i == 1){\nbulletPosition = ccp( gunman.sprite.position.x, gunman.sprite.position.y );\n}\n//Create body using body definition\nbullet.bodyDef->type = b2_dynamicBody;\nif(i == 0){\nbullet.bodyDef->bullet = YES;\n}\nbullet.bodyDef->position.Set(bulletPosition.x/PTM_RATIO, bulletPosition.y/PTM_RATIO);\nbullet.body = world->CreateBody(bullet.bodyDef);\n//Set the angle of the bullet/casing in the direction of the firing gun\nbullet.body->SetTransform(bullet.body->GetPosition(), gunAngle);\nCGPoint textureSize = ccp(17,17);\nCGPoint shapeSize = ccp(2,2);\n//Create the bullet sprite\nbulletssimulatingbullet.sprite = [CCSprite spriteWithFile:@\"bullet.png\"];\nbullet.sprite.position = ccp(bulletPosition.x,bulletPosition.y);\nbullet.sprite.scaleX = shapeSize.x / textureSize.x * 2.25f;\nbullet.sprite.scaleY = shapeSize.y / textureSize.y * 2.25f;\n//If this is a shell casing make it a golden color\nif(i == 1){ bullet.sprite.color = ccc3(255,200,0); }\n//Add object\n[gameNode addChild:bullet.sprite z:1];\n//Set bullet shape\nbullet.polygonShape = new b2PolygonShape();\nbullet.polygonShape->SetAsBox(shapeSize.x/PTM_RATIO/2, shapeSize.y/PTM_RATIO);\nbullet.fixtureDef->shape = bullet.polygonShape;\n//Create fixture and configure collision\nbullet.fixtureDef->density = 20.0f;\nbullet.fixtureDef->friction = 1.0f;\nbullet.fixtureDef->restitution = 0.0f;\nif(i == 0){\nbullet.fixtureDef->filter.categoryBits = CB_BULLET;\nbullet.fixtureDef->filter.maskBits = CB_OTHER;\n}else{\nbullet.fixtureDef->filter.categoryBits = CB_SHELL;\nbullet.fixtureDef->filter.maskBits = CB_OTHER | CB_SHELL;\n}\nbullet.body->CreateFixture(bullet.fixtureDef);\n//Add this bullet to our container\n[bullets addObject:bullet];\n//If this is a bullet, fire it. If its a shell, eject it.\nif(i == 0){\n//Fire the bullet by applying an impulse\nbullet.body->ApplyLinearImpulse(b2Vec2(bulletVector.x*50, bulletVector.y*50), bullet.body->GetPosition());\n}else{\n//Eject the shell\nfloat radians = vectorToRadians(bulletVector);\nradians += 1.85f * PI;\nCGPoint shellVector = radiansToVector(radians);\nif(shellVector.x > 0){ shellVector.y *= -1; }\nbullet.body->ApplyLinearImpulse(b2Vec2(shellVector.x, shellVector.y), bullet.body->GetPosition());\n}\n}\n}\n-(void) handleCollisionWithMisc:(GameMisc*)a withMisc:(GameMisc*)b {\n//If a bullet touches something we set life to 0 and process the impact on that object\nif(a.typeTag == TYPE_OBJ_BULLET && b.typeTag == TYPE_OBJ_BOX && a.life > 0){\na.life = 0;\n[self bulletImpactAt:a.sprite.position onObject:b];\n[message setString:@\"Bullet hit\"];\n}else if(b.typeTag == TYPE_OBJ_BULLET && a.typeTag == TYPE_OBJ_BOX && b.life > 0){\nb.life = 0;\n[self bulletImpactAt:b.sprite.position onObject:a];\n[message setString:@\"Bullet hit\"];\n}\n//Reset our message\n[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:5.0f],\n[CCCallFunc actionWithTarget:self selector:@selector(resetMessage)], nil]];\n}\n/* Process the bullet impact */\n-(void) bulletImpactAt:(CGPoint)p onObject:(GameMisc*)obj {\n//Here we use some trigonometry to determine exactly where the bullet impacted on the box.\nfloat dist = distanceBetweenPoints(p, obj.sprite.position); //Hypotenuse\nfloat xDist = obj.sprite.position.x - p.x; //Opposite side\nfloat yDist = obj.sprite.position.y - p.y; //Adjacent side\nbulletssimulatingfloat xAngle = asin(xDist/dist);\nfloat yAngle = acos(yDist/dist);\nfloat objSize = [obj.sprite contentSize].width/2 * obj.sprite.scale;\nfloat newXDist = xDist - sin(xAngle) * objSize;\nfloat newYDist = yDist - cos(yAngle) * objSize;\np = ccp( p.x + newXDist, p.y + newYDist );\n//Animate bullet impact\nfloat delay = 0.035f;\nfloat duration = 8 * delay;\nGameMisc *blastmark = [[GameMisc alloc] init];\nblastmark.sprite = [CCSprite spriteWithSpriteFrameName:@\"blastmark_0000.png\"];\nblastmark.life = duration;\nblastmark.sprite.position = p;\nblastmark.sprite.scale = 0.2f;\nblastmark.sprite.opacity = 100;\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\nCCAnimation *animation = [[CCAnimation alloc] initWithName:@\"blastmark\" delay:delay];\nfor(int i=0; i<8; i+=1){\n[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"blastmark_000%i.png\",i]]];\n}\n[blastmark.sprite stopAllActions];\n[blastmark.sprite runAction:\n[CCSpawn actions:\n[CCFadeOut actionWithDuration:duration],\n[CCAnimate actionWithAnimation:animation],\nnil\n]\n];\n[gameNode addChild:blastmark.sprite z:5];\n[explosions addObject:blastmark];\n//Decrement the box life\nobj.life -= 1.0f;\n}\n@end\n\n```", "```swift\n    bullet.bodyDef->bullet = YES;\n\n    ```", "```swift\n#import \"VRope.h\"\n@implementation Ch4_Rope\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[message setString:@\"Press B to fire a rope.\"];\n//Initialization\nonRope = NO;\nropeUseTimer = 0;\n//Move gunman to left\ngunman.body->SetTransform(b2Vec2(2,10), gunman.body->GetAngle());\n//Create buttons\n[self createButtonWithPosition:ccp(340,75) withUpFrame:@\"b_button_up.png\" withDownFrame:@\"b_button_down.png\" withName:@\"B\"];\n[self createButtonWithPosition:ccp(420,75) withUpFrame:@\"a_button_up.png\" withDownFrame:@\"a_button_down.png\" withName:@\"A\"];\n//Create ground\n/* CODE OMITTED */\n//Add invisible rope anchor\n[self addRopeAnchor];\nropesimulatingreturn self;\n}\n-(void) step:(ccTime)delta {\n[super step:delta];\n//Process button input\nfor(id b in buttons){\nGameButton *button = (GameButton*)b;\nif(button.pressed && [button.name isEqualToString:@\"B\"]){\nif(!onRope){\n[self useRope];\n}else{\n[self releaseRope];\n}\n}\nif(button.pressed && [button.name isEqualToString:@\"A\"]){\nif(onRope){\n[self releaseRope];\n}else{\n[self processJump];\n}\n}else if(!button.pressed && [button.name isEqualToString:@\"A\"]){\njumpCounter = -10.0f;\n}\n}\n//Update all ropes\nfor(id v in vRopes){\nVRope *rope = (VRope*)v;\n[rope update:delta];\n[rope updateSprites];\n}\n//Decrement our use timer\nropesimulatingropeUseTimer -= delta;\n}\n-(void) addRopeAnchor {\n//Add rope anchor body\nb2BodyDef anchorBodyDef;\nanchorBodyDef.position.Set(240/PTM_RATIO,350/PTM_RATIO); //center body on screen\nanchorBody = world->CreateBody(&anchorBodyDef);\n//Add rope spritesheet to layer\nropeSpriteSheet = [CCSpriteBatchNode batchNodeWithFile:@\"rope.png\" ];\n[self addChild:ropeSpriteSheet];\n//Init array that will hold references to all our ropes\nvRopes = [[[NSMutableArray alloc] init] autorelease];\n}\n-(void) useRope {\nif(ropeUseTimer > 0){\nreturn;\n}else{\nropeUseTimer = 0.2f;\n}\n//The rope joint goes from the anchor to the gunman\nb2RopeJointDef jd;\njd.bodyA = anchorBody;\njd.bodyB = gunman.body;\njd.localAnchorA = b2Vec2(0,0);\njd.localAnchorB = b2Vec2(0,0);\njd.maxLength= (gunman.body->GetPosition() - anchorBody->GetPosition()).Length();\nropesimulating//Create VRope with two b2bodies and pointer to spritesheet\nVRope *newRope = [[VRope alloc] init:anchorBody body2:gunman.body spriteSheet:ropeSpriteSheet];\n//Create joint\nnewRope.joint = world->CreateJoint(&jd);\n[vRopes addObject:newRope];\n//Keep track of 'onRope' state\nonRope = !onRope;\n}\n-(void) releaseRope {\nif(ropeUseTimer > 0){\nreturn;\n}else{\nropeUseTimer = 0.2f;\n}\n//Jump off the rope\n[self processJump];\n//Destroy the rope\nfor(id v in vRopes){\nVRope *rope = (VRope*)v;\nworld->DestroyJoint(rope.joint);\n[rope removeSprites];\n[rope release];\n}\n[vRopes removeAllObjects];\n//Keep track of 'onRope' state\nonRope = !onRope;\n}\n@end\n\n```", "```swift\n    b2RopeJointDef jd;\n    jd.bodyA = anchorBody;\n    jd.bodyB = gunman.body;\n    jd.localAnchorA = b2Vec2(0,0);\n    jd.localAnchorB = b2Vec2(0,0);\n\n    ```", "```swift\n    jd.maxLength= (gunman.body->GetPosition() - anchorBody->GetPosition()).Length();\n    newRope.joint = world->CreateJoint(&jd);\n\n    ```", "```swift\n    //Update all ropes\n    for(id v in vRopes){\n    VRope *rope = (VRope*)v;\n    [rope update:delta];\n    [rope updateSprites];\n    }\n\n    ```", "```swift\n@interface GameIsoObject : GameObject {\n@public\nfloat yModifier; //This is typically half the height of the object. It allows us to change the sprite y.\nfloat actualImageSize; //This is the actual size of the image (48x48, 96x96, etc)\nfloat inGameSize; //This is how large the object in the game is.\nfloat zModifier; //Changes the depth testing for this object.\nCCSprite *spriteShadow;\nVector3D *bounceCoefficient; //x, y, z, lower is bouncier for Z\nVector3D *rollCoefficient;\n}\n@end\n/* IsometricContactListener.h */\nclass isometricContactListener : public b2ContactListener\n{\npublic:\nvoid BeginContact(b2Contact* contact);\nvoid EndContact(b2Contact* contact);\nvoid PreSolve(b2Contact* contact, const b2Manifold* oldManifold);\n};\ntop-down isometric game enginecreatingvoid isometricContactListener::BeginContact(b2Contact* contact)\n{\nb2Body *bodyA = contact->GetFixtureA()->GetBody();\nb2Body *bodyB = contact->GetFixtureB()->GetBody();\nif(bodyA and bodyB){\nfloat lowerZSize;\nif(bodyA->GetZPosition() < bodyB->GetZPosition()){ lowerZSize = bodyA->GetZSize(); }\nelse{ lowerZSize = bodyB->GetZSize(); }\n//Check for Z Miss and disable collision if neccessary\nif( absoluteValue(bodyA->GetZPosition() - bodyB->GetZPosition()) > lowerZSize ) { //If distance is greater than the height of the bottom one\ncontact->SetEnabled(false);\nif(bodyA->GetHandleZMiss() || bodyB->GetHandleZMiss()){\nGameObject *gameObjectA = (GameObject*)bodyA->GetUserData();\nGameObject *gameObjectB = (GameObject*)bodyB->GetUserData();\n[gameObjectA->gameArea handleZMissWithObjA:gameObjectA withObjB:gameObjectB];\nbodyA->SetHandleZMiss(false);\nbodyB->SetHandleZMiss(false);\n}\n//If no Z Miss handle collision\n}else {\nGameObject *gameObjectA = (GameObject*)bodyA->GetUserData();\nGameObject *gameObjectB = (GameObject*)bodyB->GetUserData();\n[gameObjectA->gameArea handleCollisionWithObjA:gameObjectA withObjB:gameObjectB];\ntop-down isometric game enginecreating}\n}\n}\n/* END IsometricContactListener.h */\n@implementation Ch4_TopDownIsometric\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Iso debug drawing\nm_debugDraw = new IsoGLESDebugDraw( PTM_RATIO, PERSPECTIVE_RATIO, gameAreaSize );\nworld->SetDebugDraw(m_debugDraw);\n//Special isometric gravity, contact filter and contact listener\nworld->SetGravity(b2Vec2(0,0));\nworld->SetContactListener(new isometricContactListener);\nreturn self;\n}\n/* We override all physical calculations here */\n-(void) step: (ccTime) delta {\n//Update Physics\nint32 velocityIterations = 8;\nint32 positionIterations = 3;\nworld->Step(delta, velocityIterations, positionIterations);\nfloat deltaMod = delta/0.01666666667f;\nfor (b2Body* b = world->GetBodyList(); b; b = b->GetNext()) {\n//Z Miss handling allows us to know when an object passes over or under another object\nb->SetHandleZMiss(YES);\nif (b->GetUserData() != NULL) {\n//Synchronize the sprites position and rotation with the corresponding body\ntop-down isometric game enginecreatingGameIsoObject *gameObject = (GameIsoObject*)b->GetUserData();\nif(gameObject.sprite) {\nif(gameObject.bodyDef->type == b2_dynamicBody){\n//Process Z velocity and position\ngameObject.body->SetZVelocity( gameObject.body->GetZVelocity() - GRAVITY*deltaMod );\ngameObject.body->SetZPosition( gameObject.body->GetZPosition() + gameObject.body->GetZVelocity()*deltaMod );\n//Process object bouncing and rolling\nif(gameObject.body->GetZPosition() < (-0.01f)){\ngameObject.body->SetZPosition(0.01f);\ngameObject.body->SetZVelocity( gameObject.body->GetZVelocity() * -1 );\nb2Vec2 worldVector = gameObject.body->GetLinearVelocityFromLocalPoint(b2Vec2(0,0));\nif(absoluteValue(gameObject.body->GetZVelocity()) > 1.0f){\n[self handleCollisionWithGroundWithObj:gameObject];\ngameObject.body->ApplyLinearImpulse( b2Vec2( gameObject.bounceCoefficient.x*worldVector.x*-1, gameObject.bounceCoefficient.y*worldVector.y*-1 ), gameObject.body->GetPosition() );\ngameObject.body->SetZVelocity( gameObject.body->GetZVelocity() * (1-gameObject.bounceCoefficient.z) );\n}else{\ngameObject.body->ApplyLinearImpulse( b2Vec2( gameObject.rollCoefficient.x*worldVector.x*-1, gameObject.rollCoefficient.y*worldVector.y*-1 ), gameObject.body->GetPosition() );\ngameObject.body->SetZVelocity( gameObject.body->GetZVelocity() * (1-gameObject.rollCoefficient.z) );\n}\n}\n//Change sprite positions based on body positions\ngameObject.sprite.position = CGPointMake( convertPositionX(gameAreaSize, b->GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b->GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO) + gameObject.yModifier + gameObject.body->GetZPosition() * zHeightModifier * PERSPECTIVE_RATIO);\ngameObject.spriteShadow.position = CGPointMake( convertPositionX(gameAreaSize, b->GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b->GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO));\n//Modify sprite scale based on Z (height)\n[gameObject.sprite setScale:( gameObject.body->GetZPosition()*scaleHeightMultiplier + gameObject->inGameSize/gameObject->actualImageSize )];\ngameObject.spriteShadow.scale = gameObject.body->GetZPosition()/100;\nif(gameObject.spriteShadow.scale > 1){ gameObject.spriteShadow.scale = 1; }\n//Sprite depth testing based on Y (depth)\n[self setZOrderByBodyPosition:gameObject];\n}else if(gameObject.bodyDef->type == b2_staticBody){\n//Static bodies are only positioned and depth tested\ngameObject.sprite.position = CGPointMake( convertPositionX(gameAreaSize, b->GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b->GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO) + gameObject.yModifier + gameObject.body->GetZPosition() * zHeightModifier * PERSPECTIVE_RATIO);\n[self setZOrderByBodyPosition:gameObject];\ngameObject.spriteShadow.position = CGPointMake( convertPositionX(gameAreaSize, b->GetPosition().x * PTM_RATIO), convertPositionY(gameAreaSize, b->GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO));\n}\n}\n}\n}\n//Process body creation/destruction\n[self destroyBodies];\n[self createBodies];\n[self runQueuedActions];\n//Follow gunman with camera\ngameNode.position = ccp((-gunman.spriteShadow.position.x)*cameraZoom + 240, (-gunman.spriteShadow.position.y)*cameraZoom + 160);\n}\ntop-down isometric game enginecreating/* Fire a bouncy ball */\n-(void) fireBall {\nif(fireCount < 0){\nGameIsoObject *ball = [self addBallAtPoint:ccp(gunman.body->GetPosition().x*PTM_RATIO + lastPressedVector.x*20.0f, gunman.body->GetPosition().y*PTM_RATIO*PERSPECTIVE_RATIO + lastPressedVector.y*20.0f)];\nball.body->ApplyLinearImpulse(b2Vec2(lastPressedVector.x*1.75f, lastPressedVector.y*1.75f), ball.body->GetPosition());\nball.body->SetZVelocity( gunman.body->GetZVelocity()*5.0f + 10.0f );\nball.body->SetZPosition( gunman.body->GetZPosition() + 40.0f);\nfireCount = 10;\n}else{\nfireCount--;\n}\n}\n/* Process a jump */\n-(void) processJump {\n//You can only jump if you are standing or running. You also need to be on the ground.\nif(gunman.body->GetZPosition() > 1.0f){\nreturn;\n}\n//Make him jump\n[[gunman.sprite getChildByTag:0] stopAllActions];\ngunman.body->SetZVelocity(7.5f);\n}\n/* Convert a body position to a world position */\n-(CGPoint) getWorldPosition:(GameIsoObject*)g {\nreturn CGPointMake(g.body->GetPosition().x * PTM_RATIO, g.body->GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO);\n}\n/* A camera bound limiting routine */\n- (bool) checkCameraBoundsWithFailPosition:(CGPoint*)failPosition {\nCGSize screenSize = [CCDirector sharedDirector].winSize;\nbool passed = true;\ntop-down isometric game enginecreatingfloat fsx = (gameAreaSize.x/2)*cameraZoom;\nfloat fsy = (gameAreaSize.y/2)*cameraZoom;\nfloat ssx = screenSize.width;\nfloat ssy = screenSize.height;\nif( [gameNode position].y < -(fsy - ssy) ) {\n(*failPosition).y = -(fsy - ssy);\npassed = false;\n}else if( [gameNode position].y > fsy) {\n(*failPosition).y = fsy;\npassed = false;\n}else{ //Passed\n(*failPosition).y = [gameNode position].y;\n}\nif( [gameNode position].x < -(fsx - ssx) ) {\n(*failPosition).x = -(fsx - ssx);\npassed = false;\n}else if( [gameNode position].x > fsx) {\n(*failPosition).x = fsx;\npassed = false;\n}else { //Passed\n(*failPosition).x = [gameNode position].x;\n}\nreturn passed;\n}\n/* Depth testing */\n-(void) setZOrderByBodyPosition:(GameIsoObject*)g {\nfloat fixedPositionY = gameAreaSize.y - (g.body->GetPosition().y * PTM_RATIO * PERSPECTIVE_RATIO) + g.zModifier;\n[g.sprite.parent reorderChild:g.sprite z:fixedPositionY];\n}\n/* Add a tree object */\n-(void) addTreeAtPoint:(CGPoint)treePosition {\nGameIsoObject *tree = [[GameIsoObject alloc] init];\n/* CODE OMITTED */\n}\n/* Add a ball with a random size at a position */\n-(GameIsoObject*) addBallAtPoint:(CGPoint)ballPosition {\nGameIsoObject *ball = [[GameIsoObject alloc] init];\n//Bounce and roll coefficients determine how high the ball boucnes and how fast the ball rolls\nball.bounceCoefficient = [Vector3D x:0.05f y:0.05f z:0.1f*scaleMod];\ntop-down isometric game enginecreatingball.rollCoefficient = [Vector3D x:0.0005f y:0.0005f z:0.5f];\n/* CODE OMITTED */\nreturn ball;\n}\n@end\n\n```", "```swift\n    float32 m_zPosition;\n    float32 m_zSize;\n    float32 m_zVelocity;\n    bool m_handleZMiss;\n\n    ```", "```swift\n    contact->SetEnabled(false);\n\n    ```", "```swift\n    -(void) handleZMissWithObjA:(GameObject*)objA withObjB:(GameObject*)objB;\n\n    ```", "```swift\n    ball.bounceCoefficient = [Vector3D x:0.05f y:0.05f z:0.1f*scaleMod];\n    ball.rollCoefficient = [Vector3D x:0.0005f y:0.0005f z:0.5f];\n\n    ```", "```swift\n    - (bool) checkCameraBoundsWithFailPosition:(CGPoint*)failPosition;\n\n    ```"]