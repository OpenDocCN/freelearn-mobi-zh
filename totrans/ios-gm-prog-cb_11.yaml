- en: Chapter 11. Getting Started with Multiplayer Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be focusing on the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of multiplayer games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup for a multiplayer game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning roles to players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in the book, we have done a lot of cool game-related stuff, such as
    SpriteKit, parallax scrolling background, physics simulation with autonomous moving
    agents, three-dimensional game programming using OpenGL, and much more. All these
    were done to make a single-player game, meaning only one person can play it at
    a time. But now, we will be moving forward to make a multiplayer game, which engages
    more than one person at the same time. Multiplayer is, in itself, more engaging
    and fun for the user, as live competition gets into the picture, making the gaming
    experience a lot more enjoyable for the users. So, it''s time to understand things
    related to multiplayer games. In [Chapter 12](part0069_split_000.html#page "Chapter 12. Implementing
    Multiplayer Games"), *Implementing Multiplayer Games*, we will be creating a multiplayer
    game. For taking a tour of multiplayer game development, the overall agenda will
    be divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample multiplayer game to understand the anatomy and various states
    of a multiplayer game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doing the setup for the same multiplayer game using SpriteKit and Apple's Multipeer
    Connectivity framework. After that, handshaking or connection establishment between
    players using `MCBrowserViewController` of the same framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assigning roles to players by sending and receiving network packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anatomy of multiplayer games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a single-player game, there is only one player, so talking about the game
    as an object that maintains all of the game behavior, whereas if we understand
    the anatomy of multiplayer games, we'll see that it's totally different. In multiplayer
    games, there are multiple players playing the same game, so technically for every
    device, there is a player who is actively driving the game on that device. This
    is called the local player, and all other players are treated as remotes players
    for that device. The local player's activities should ideally be updated on the
    remote players' devices, which is the foremost challenge in multiplayer development.
    The update of the local player is called syncing the game on some other device,
    and is done by the game object that resides in the game. It's the responsibility
    of the game object (that is, the instance of game running on the device) to make
    the game look the same on all devices as a live game is played.
  prefs: []
  type: TYPE_NORMAL
- en: So, moving further in this section, we will be creating a fresh multiplayer
    game, called TankRace, using SpriteKit, in which game sessions will be instantiated.
    We will incorporate multiplayer game states with their explanation and essentiality.
    All the session and multiplayer related processes will be done using the Multipeer
    Connectivity framework introduced in iOS 7, which was a part of GameKit in iOS
    6.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To develop the TankRace multiplayer game using SpriteKit, start by creating
    a new project. Open Xcode and go to **File** | **New** | **Project** | **iOS**
    | **Application** | **SpriteKit Game**. In the pop-up, type the **Product Name**
    as `TankRace`, go to **Devices** | **iPhone**, and click on **Next**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Next** and save the project on your hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is saved, you should be able to see the project settings. On
    the project settings page, just check in the **Portrait** from the **Device Orientation**
    section and uncheck all others, as we are supporting only the portrait mode for
    this game. Also set the deployment target to 7.0 so that a range of devices can
    be supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer view at what structure SpriteKit has provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `viewDidLoad` method of `GameViewController` a piece of code is written
    that converts its view to `SKView` and a scene that is, `GameScene` is presented
    on the `SKView` as shown below. The `unarchiveFromFile` method is implemented
    by the project itself to fetch the `GameScene.sks` file, which we can see in the
    project created. For not showing the FPS and nodes, comment both the lines as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting with the multiplayer code we should make the game ready for
    it. First, go in to the `GameScene` class and remove the sample `SKLabelNode`
    addition code in the overridden method `didMoveToView` of `GameScene` where we
    usually set up the scene. Secondly, remove the `for` loop of touches from the
    `touchesBegan:withEvent` method, which does the addition of `SKSpriteNode` and
    its action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project is now ready to start with the multiplayer. Multiplayer games can
    be developed in several ways. They can be either played using Bluetooth, Wifi,
    Internet, or GameCenter. All these techniques allow us to interconnect devices
    and share data across devices. This allows us to show the movement of players
    in real time. You might have seen the responsiveness in multiplayer games. They
    are really seamless. In this section we will explore more about multiplayer games
    and their implementation in iOS. Here we will be instantiating a session (that
    is, MCSession) for the local player, which will further connect to another player
    in this recipe. Also, to instruct the user to touch we will add an info label
    saying `Tap to connect` and further will implement the delegates of MCSession
    following with the explanation of Multiplayer Game States. Stated below are the
    steps to accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GameScene.m` file, and create an interface with properties of `InfoLabel`
    and all related session stuff. Also make `GameScene` follow `MCSessionDelegate`
    and the interface will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `gameSession` is the session that will be created for playing a multiplayer
    game, `gamePeerID` is the unique ID for the local player of this `gameSession`,
    which will be in future acting as the unique ID of the remote player to whom this
    device will be connected to. This is why it is called peerID. `ServiceType` is
    the unique ID assigned particularly to the game; here, the service type will be
    TankRace and advertiser is a class that handles all incoming invitations to the
    user and handles all user responses. A `gameInfoLabel` property is declared, which
    will be created to instruct the user to connect with other players.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a method called `addGameInfoLabelWithText`, which can be used to show any
    GameInfo with `pragma` mark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare hash defines for different GameInfo texts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Call `addGameInfoLabelWithText` from the `didMoveToView` method of `GameScene`.
    With text hash define `kConnectingDevicesText` and `pragma` mark as depicted below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an `enum`, `GameState`, and a property corresponding to it in the private
    interface of `GameScene`. Also, set the initial state of game as `kGameStatePlayerToConnect`,
    as, to start a multiplayer game, players need to be connected first to play. Add
    these lines just above the hash defines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this property of `gameState` in the private interface of `GameScene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign `gameState` to `kGameStatePlayerToConnect` in `didMoveToView` of `GameScene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a method called `instantiateMCSession` and add the `pragma` mark as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement all delegates `MCSessionDelegate` with the `pragma` mark as shown
    below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These all are the delegate methods of `MCSession` implemented in the `GameScene`
    class, amongst which the former two are mostly used. The first one is used to
    determine the state of game changes, like, whether it is connected, connecting
    or not connected. And the latter one is used to receive data, hence to process
    that data under an operation queue block as shown in the above implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now add `instantiateMCSession` in `touchBegan:withEvent` according to `gameState`
    of `GameScene` with `pragma` mark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `touchesBegan` method if the state is `kGameStatePlayerToConnect` then
    it means that the user has touched to start the game that is, technically connecting
    of players to be done and in other states of game the handling would be done accordingly
    on touches.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After all these steps an initial session of game set up has been accomplished
    with an understanding of multiplayer games' architecture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding setup we used the Multipeer Connectivity framework for setting
    up a structure of a multiplayer game with an instance of `MCSession` to be there
    in every device that will be used to play the game. We also implemented all its
    delegate methods, which informs the `GameScene` about the changing of game states
    and will also be used for receiving data when incoming sections from some network
    packets are sent. For now, in this section, we have put a label `Tap to connect`
    and on clicking the screen a session is instantiated. Now build the project. First
    you will see the following launch screen and then the initial `GameScene` with
    a label **Tap to connect**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setup for a multiplayer game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will write the code for setting up our multiplayer game.
    All the configurations and session managers will be the part of this section.
    We will dig into the various concepts of creating and maintaining sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting this recipe, MCSession, MCPeerId, advertiser and service type
    terms of Multipeer Connectivity framework should be known to us. In this recipe
    we will be establishing the connection between players, thereby, they can communicate
    in future, making the players play a game, which we will be doing in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, on tapping the screen, a MCSession with a service type has been instantiated;
    we can use this session and service type to present a `MCBrowserViewController`
    and establish connection between players (that is, devices). `MCBrowserViewController`
    is fully equipped and designed for connecting multiple players for a session provided
    in the Multipeer Connectivity framework. These are the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a protocol of `GameScene` as `GameSceneDelegate` and its
    delegate object in `GameScene`, which will be set as `GameViewController` so that
    it uses its delegate method when the user touches the screen. `GameViewController`
    can be informed to present `MCBrowserViewController`. Declare the protocol code
    and `GameSceneDelegate` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the user touches the screen that has the `gameState` as `kGameStatePlayerToConnect`,
    where we are calling the method, `instantiateMCSession`, which also informs `gameSceneDelegate`
    to show `MCBrowserViewController` by passing `gameSession` that was created and
    the `serviceType` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The delegate method has to be called by `GameViewController`, and on the same
    controller, `MCBrowserViewController` has to be presented, which will also have
    its own delegate methods. Now, it''s time to declare the private interface of
    `GameViewController` and follow both `MCBrowserViewControllerDelegate` and `GameSceneDelegate`
    as shown in this snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `viewDidLoad` of `GameViewController`, replace the local scene object with
    `self.gameScene` and assign the `gameSceneDelegate` property of the `GameScene`
    object as the `GameViewController`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the delegate method of `GameSceneDelegate`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, `MCBrowserViewController` is presented on `GameViewController`
    with its delegate set and restricted the peers to `2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add two public methods to `GameScene`, to be called the cancel and done actions
    of `MCBrowserViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `GameScene.h`, declare the public methods, as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In `GameScene.m`, define the public methods, like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will add two public methods in the `GameScene` file. These methods will
    be invoked on the cancel and done actions of `MCBrowserViewControllerDelegate`
    respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In both the delegate methods, first the `MCBrowserViewController` is dismissed
    and `GameScene` is informed to change accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now when both the device players click on the screen, `MCBrowserViewController`
    opens and the players try to connect to each other using the default behavior
    provided by this controller, and when done we show the appropriate text to the
    player. Hence this entire implementation accomplishes our starter kit of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will understand how the connection using the `MCBrowserViewController`
    is established in the following steps (in the snapshots shown below, the left
    side is the simulator device and right side is iPhone 5s):'
  prefs: []
  type: TYPE_NORMAL
- en: Both the players click on the screen and `MCBrowserViewController` opens, searching
    for peers nearby, with cancel and done buttons placed on the navigation bar. Here
    the done button is disabled, as initially no one is connected to the device.![How
    it works](img/00169.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a peer is detected, it shows the name of the devices in the list.![How
    it works](img/00170.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that both the players press the device name with which they want to connect
    and the search of peers stop. Hence following this selection of device a request
    is sent to connect to it.![How it works](img/00171.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the reply of the other user the status of the peer at the right
    text of table row is updated; it can be **Connecting**, **Connected**. And when
    the devices are connected the status is changed to **Connected** and the **Done**
    button is enabled.![How it works](img/00172.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the player selects **Done** or **Cancel**, we show them the appropriate
    text, **Devices Connected** on clicking on the **Done** button and **Tap to connect**
    on clicking the **Cancel** button. Now, the devices are logically connected to
    each other and are sharing the same session. This session will be used further
    in the multiplayer game by the user to play.![How it works](img/00173.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, in all this process, we will see some network lagging also, so if the
    devices are not connecting, try to reconnect by cancelling the controller and
    again clicking on the screen to refresh the controller again.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning roles to players
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take our game template to the next step by assigning
    the roles to our players. This means we will be logically dividing the users and
    assigning roles to them. This will provide an individual identity to the players.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting with assigning or as we can also call it, an allotment of players
    identity (which is first player and second player), we should be familiar with
    the Multipeer Connectivity framework. We must also have a basic knowledge of network
    packet sending and receiving. In this section we will be assigning the first and
    second player identities to the players once they are connected using the `MCBrowserViewController`
    having just described it in the preceding recipe by pressing the **Done** button.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish the assignment of players, following are the steps to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a set up purpose for this add some enums, hash define constants and properties
    as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare an `enum` called `NetworkPacketCode` in which we add only the `KNetworkPacketCodePlayerAllotment`
    packet code for now, and in the future more packet codes can be added for sending
    and receiving packets from the game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Add texts to be shown to players when the player roles are being decided.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Add the max packet size constant and some properties like `gamePacketNumber`,
    `gameUniqueIdForPlayerAllocation` in `GameScene.m` to be used while sending packets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now to send data from one device to another, we have an encapsulated data container,
    which is called a packet. Now this packet is sent over the network and the other
    player's device will update the view and position accordingly. For this, create
    a method to send the packet with a header `NetworkPacketCode` and data specifying
    `peerId` to which the data packet has to be sent and whether the packet should
    be sent with a reliable service or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `networkPacket` is created with a header and data. A variable `pIntData`
    is declared, which is the header containing the `NetworkPacketCode` and a `gamePacketNumber`
    so that a unique number is assigned to a packet to serialize the network packets
    to be used to sync or update the game properly. Once the packet is created, a
    method called `sendData` of `MCSession` is called with the packet to be sent,
    `peerID` to which the packet has to be sent, the mode, which can be `MCSessionSendDataUnreliable`
    or `MCSessionSendDataReliable` and `error` to check whether an error has occurred
    while sending the packet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This method will be reused everywhere in the game to send packets to peers of
    the same game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generate a random number and store it in the variable `gameUniqueIdForPlayerAllocation`
    declared above, which will help to decide which will be the first and second player.
    Add this line in the `didMoveToView` method of `GameScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to receiving data delegate method of `MCSession` for
    handling of received packets based on their `NetworkPacketCode` as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While receiving the data, it should be processed on a `mainQueue` operation
    block. In this block, we will remove the header in the `pIntData` pointer variable
    and get the `NetworkPacketCode` sent in the packet. In this code, we will check
    the type of packet which is sent. Then we will parse the packet based on its type.
    In this, a player allotment packet type named `KNetworkPacketCodePlayerAllotment`
    is passed, hence the data retrieved is `gameUniqueId`. As discussed above, in
    `didMoveToView`, we assigned a random number to a variable named `gameUniqueIdForPlayerAllocation`
    for both the devices. Hence for both devices, different numbers are generated
    & while sending the allotment packet from both devices, this is passed as the
    data (the allotment packet to be sent would be discussed in next point). Finally
    to decide which is first and second player, the local value of `gameUniqueIdForPlayerAllocation`
    would be compared with the value sent in the packet, on this comparison one would
    be assigned as the first player and other as the second player, informing the
    users by changing appropriate text of `gameInfoLabel` as shown in the delegate
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remove the following written line from the public method `startGame` of `GameScene`
    as now, the `gameInfoLabel` will be set according to the packet received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All these earlier processes start when the user clicks on the done button.
    This button is an indication that the players have been connected and a delegate
    method `didChangeState` of `MCSession` will be called with a `MCSessionState`
    called `MCSessionStateConnected`, and as a checking protocol is already in-built
    in this method of connected state, add the following code in the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, in this method, set all properties that come from the method, as it is
    the remote player information, and set the game state to `kGameStatePlayerAllotment`
    locally. Then, we send the packet of the allotment of the player to `peerID`,
    for which the connection has been established with a `NetworkPacketCode` and a
    data part, which would be received at the remote end as discussed previously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we are done with connecting two players for a multiplayer game and
    assigning them a unique identity for further identification to build the game.
    This recipe acts as the solution kit for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entire assignment of players depends on what action and data the packet
    is sent with, and how it is parsed at the receiver's end according to the convention
    set by the sender. To accomplish the allotment of the player's identity, we used
    a random number variable, which is locally generated and passed in the allotment
    packet. At the receiving end, the logic of allotment is written, checking the
    locally set and remotely passed random number. Based on this comparison, the first
    and second players are decided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some text is shown on both the devices, informing the players about their identity,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding section, we have used the Multipeer Connectivity framework.
    We can also use the GameKit framework. For more information on this take a look
    at [https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For better understanding and learning the Multipeer Connectivity framework,
    visit [https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html](https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html).
  prefs: []
  type: TYPE_NORMAL
