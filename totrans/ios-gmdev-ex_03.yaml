- en: Chapter 3. Sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we set up our first scene, learned about the rendering
    of nodes in a scene, added multiple scenes in a project, and learned about doing
    transitions from one scene to another.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about sprites. A sprite is a two-dimensional
    image, integrated into scene. A collection of sprites is called **sprite sheet**.
    Here we will learn about how to add sprites in a game, positioning a sprite, texture
    atlases, and how to transform a sprite in our game.
  prefs: []
  type: TYPE_NORMAL
- en: In Sprite Kit, a game is based on the node tree hierarchy. Scene acts as a root
    node and other nodes added to it are child nodes. Once all nodes are rendered
    into scene, we get the view. Sprites are also added to a game as a node; Sprite
    Kit provide us `SKSpriteNode` class for this purpose. In the previous chapter,
    we added background sprite and play button sprite by making the `SKSpriteNode`
    reference and adding it to the respective scenes. Now we will discover more about
    what Sprite Kit provided us in the `SKSpriteNode` class, and what else we can
    do with it.
  prefs: []
  type: TYPE_NORMAL
- en: SKSpriteNode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SKSpriteNode` class is a root node class which is used to draw texture
    images with many customizations; it is inherited from the `SKNode` class. We can
    simply draw an image, or we can add some effects, such as custom shader or shadows
    to it. For this, we have to first know about the `SKSpriteNode` class and the
    functionality it offers.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a sprite in a game, we have to make an instance of the `SKSpriteNode`
    class. Sprite Kit provides us with many ways to initialize an instance of the
    `SKSpriteNode` class. Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In Swift, one has to initialize a class by making an object of structure. There
    are two initializers provided for this purpose, that is, designated initializers
    and convenience initializers.
  prefs: []
  type: TYPE_NORMAL
- en: Designated initializers perform actual initialization for class properties.
    Now the question arises, "why convenience initializers are required?" During programming,
    sometimes, convenience initializers are very useful as they require less input
    parameters, and hand over actual initialization to designated initializers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of initializers in Swift are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`convenience init(color color:UIColor!, size size: CGSize)`: This is used to
    initialize a colored sprite. If you want to make a sprite without using any texture
    and only by color, you can use this. It takes color and size as a parameter and
    returns a newly initialized sprite object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convenience init(imageNamed name: String)`: This initializer assigns texture
    to sprites. A sprite will be assigned texture from image name, which initializes
    the color of a sprite to white.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convenience init(texture texture: SKTexture!)`: This initializer takes an
    existing texture sprite and returns a newly initialized sprite. The size of the
    sprite is set to the dimensions of the texture, and the color of the sprite is
    set to white `(1.0, 1.0, 1.0)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init(texture texture: SKTexture!,color color: UIColor!,size size: CGSize)`:
    As explained earlier, this initializer requires convenience initializers as its
    parameter, so this is a designated initializer. Now, our *Platformer* game sprite
    will be initialized to the desired texture, color, and size. It returns a newly
    initialized sprite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convenience init(texture texture: SKTexture!,size size: CGSize)`: This takes
    texture and size as parameters and returns a newly initialized sprite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convenience init(imageNamed name: String, normalMapped generateNormalMap:
    Bool)`: This takes an image name and a Boolean value as a parameter and returns
    a newly initialized object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convenience init(texture texture: SKTexture!,normalMap normalMap: SKTexture?)`:
    This takes two textures as parameters, one for sprite drawing and another for
    adding lighting behavior to the sprite. It returns a newly initialized sprite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After learning about initialization of `SKSpriteNode`, now it is time to get
    ourselves familiar with some physical properties of `SKSpriteNode`, such as `size`,
    `anchorPoint`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The properties of SKSpriteNode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us discuss the properties of `SKSpriteNode` in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Physical
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at some physical properties of `SKSpriteNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size`: This property determines the size of a sprite in points. In our `GameScene`
    and `MenuScene` classes, we use this property in the background sprite to cover
    the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnchorPoint`: An anchor point is a point of co-ordinate related to sprite.
    Say, for example, co-ordinates for each corner of a sprite are `(0,0)`, `(1,0)`,
    `(0,1)`, and `(1,1)` representing corners bottom left, bottom right, top left,
    and top right respectively. These points of reference can be assigned as anchor
    points to draw a sprite on screen in respect. An assigned anchor point will position
    a sprite on screen, accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, assume that our anchor point for a sprite is `(0,0)`. If we position
    this sprite on screen, it will place itself from co-ordinate `(0,0)`, that is,
    bottom left. To position a sprite from the centre, we need to assign the anchor
    point co-ordinate `(0.5, 0.5)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But to add another node to this sprite, co-ordinate `(0,0)` of that node will
    be on the sprite's anchor point. What happens when we add scene to the view is
    that, co-ordinate `(0,0)` of scene, becomes the default anchor point.
  prefs: []
  type: TYPE_NORMAL
- en: Physical properties of a sprite were well discussed under `size` and `anchorPoint`.
    Now it is time to discuss some properties which are related to texture in a sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is an optional property in the `SKSpriteNode` class; that means it can be
    nil or will have texture. If it is nil, then the sprite will be drawn by using
    its `color` property in a rectangular shape, otherwise the sprite will be drawn
    using this texture.
  prefs: []
  type: TYPE_NORMAL
- en: centerRect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This property is a very useful tool for creating rectangular buttons or any
    other fixed size elements in scene. When you use the `centerRect` property, you
    are actually controlling the scaling factor of texture for a rectangular portion
    specified by coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the rectangle covers the whole texture; that's why entire texture
    is stretched. But if this rectangle covers only a portion of the texture, then
    the texture could be visualized in a `3 * 3` grid, accounting this rectangle in
    the middle of the grid and drawing a line from its every edge on each side.
  prefs: []
  type: TYPE_NORMAL
- en: '![centerRect](img/4201_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Original image
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to stretch the texture in both directions, then it will follow the
    rules given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The middle portion of the grid will stretch on each side, horizontally and vertically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All 4 corner portions of the grid will not be stretched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The upper and lower middle parts of the grid will be stretched horizontally![centerRect](img/4201_03_05.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image stretched horizontally from the centre
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The left and right middle parts of the grid will be stretched vertically![centerRect](img/4201_03_04.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image stretched vertically from the centre
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And, the following is another case where the image is stretched both vertically
    and horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![centerRect](img/4201_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image stretched both vertically and horizontally from the centre
  prefs: []
  type: TYPE_NORMAL
- en: This is a very useful property to achieve some specific behavior of texture,
    such as making a health bar in the game, where we don't want to stretch the corner
    side of the texture, so that if they are rounded, they should not be deformed.
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SKSpriteNode` has some color properties too. Let''s read in detail about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This property is used to give color to a sprite. For example, you
    need to change the color of your sprite when the health bar is reduced to 50 percent,
    25 percent, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorBlendFactor`: This is used to control the color blending with the sprite
    texture. It can have a value between `0.0` to `1.0` (inclusive); `0.0` is default.
    If the value is `0.0,` that means the `color` property is ignored and texture
    values are used unmodified. If you increase the value, more color will be added
    to the sprite. For example, we can use this property to blend more color in our
    character with an increasing number of hits to the character:![Color](img/4201_03_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color effects due to change in value for colorBlendFactor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`blendMode`: This property is used to blend sprites according to scene. Every
    pixel color of a sprite and the color of the corresponding scene pixel under it,
    is compared by Sprite Kit renderer to assign a resulting color to the sprite.
    This property is very useful when you add a lighting effect or flash effect to
    your scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In iOS 8, some lighting properties were added to generate a light and shadow
    effect on the sprites. Let''s have a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lightingBitMask`: This property is used to show a lighting effect on the sprite,
    and is tested against light''s `categoryBitMask` property by a logical AND operation.
    If the value is nonzero, the sprite will light up, or else it will remain unaffected
    by the light. Its default value is `0x00000000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shadowedBitMask`: This determines whether the sprite will be affected by the
    shadow generated by the light or not. This property is tested against light''s
    `categoryBitMask` property by a logical AND operation. If the value is nonzero,
    the sprite will the drawn using a shadowed effect, or else it will remain unaffected
    by the light. Its default value is `0x00000000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shadowCastBitMask`: This determines whether or not the sprite will block the
    light and cast the shadow. This property is tested against light''s `categoryBitMask`
    property by a logical AND operation. If the value is nonzero, the sprite will
    cast a shadow past itself, or else it will remain unaffected by the light. Its
    default value is `0x00000000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normalTexture`: A normal map texture is used when a sprite is lit, giving
    it a more realistic look with shadows and spectacular highlights. The texture
    must be a normal map texture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with the lighting property, with iOS 8, the shader property was also introduced
    to customize the rendering effects.
  prefs: []
  type: TYPE_NORMAL
- en: Shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The shader property is exclusively discussed in [Chapter 7](ch07.html "Chapter 7. Particle
    Effects and Shaders"), *Particle Effects and Shaders*.
  prefs: []
  type: TYPE_NORMAL
- en: These are `SKSpriteNode` properties, by which we can use sprites by customizing
    them as we desire. The majority of a game consists of sprites, so it is important
    to know these properties and how we can use them. Now, it is time to use these
    properties in our game and see what effects they produce.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sprite without using textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mostly in a game, we add texture to our sprite, but we can also make a sprite
    without using textures. A texture property is an optional property in the `SKSpriteNode`
    class. If texture is nil, that means we have no texture to stretch, so the contract
    parameter is ignored. Let''s open our `GameScene.swift` file and make a variable
    of `SKSpriteNode`, just below the `backgroundNode` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the preceding declaration, we have declared `spriteWithoutTexture`
    as optional. Since we have declared it optional, texture need not require a value.
    Now under `didMoveToView`, add following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, call this function inside `didMoveToView()`, below the `addBackGround()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now tap on play and see what happens. In our `GameScene` there is no change.
    Well that''s not what we desire. Actually, we missed the `z` position of our texture.
    That''s why it is rendering behind the background and not showing to us. Add this
    line in our `addSpriteWithoutTexture()` function, before `addChild(spriteWithoutTexture!)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run it. You will see a red square in the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The code is self-explanatory. We made an instance of `SKSpriteNode` by instantiating
    it. We are passing nil as parameter for texture, meaning we don't want texture
    for this sprite. As we have made this sprite reference optional, we will have
    to unwrap it before using any `SKSpriteNode` properties, and we do so by using
    the `!` mark after `spriteWithoutTexture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also initialize in another way. Delete the `texture` parameter from
    the initialization part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding initialization part as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run the code and it will produce the same result as the previous one. It automatically
    assigns nil to texture, and initializes a sprite with a color and the specified
    bounds. Let's do something interesting with it.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the color property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use `color` property to change color when a user taps on this
    sprite. For this, first give a name to `spriteWithoutTexture`, so that we can
    recognize a tap on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function in the `GameScene.swift` file to change color, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use the `touchesBegan` function to detect touch by a user (as it was
    used previously in the `MenuScene` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, after running Xcode, click on the colorful area in `GameScene`. You will
    see that area changing its color.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, when a user taps on the sprite, it will add a value to the current
    one and call the `changeColor()` function. In the `changeColor()` function, we
    have taken a `switch` case to determine the color property of `spriteWithoutTexture`.
    In Swift, `switch` case is used as in many other languages. We don't have to use
    the `break` statement. Every `switch` statement must be *exhaustive*. That means,
    we have to make every single case check for switch case. Hence, we have to write
    a `default` value for every switch case.
  prefs: []
  type: TYPE_NORMAL
- en: If our texture is not nil, we can use the `colorBlendFactor` property to colorize
    the texture. We can use it for a tinting effect, such as damage taken in the game;
    `colorBlendFactor` is ignored if texture is nil. Its default value is `0.0`, which
    means that the texture should remain unmodified. When we increase the value, texture
    color is replaced with the blended color.
  prefs: []
  type: TYPE_NORMAL
- en: Changing colorBlendFactor in MenuScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a tint to our play button. Open `MenuScene` and define a variable
    named `tintChanger` inside the `MenuScene` class as optional `Float`, so that
    we won''t need to assign a value to it in the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function in the `MenuScene` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Call it from the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now run Xcode. You will see the **Play** button appearing and disappearing respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we just make a `Float` type variable. In our `tintPlayButton`
    function, we check if the value of its `colorBlendFactor` property is between
    `1` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s give it a color, inside the `addChildToScene` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run it and you will see the **Play** button changing its color from the original
    one to reddish. Now, it's time to see the position property in action.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the position of a sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, have a look at the `position` property of `SKSpriteNode`. Let''s open
    `GameScene` again, as we are going to see the `spriteWithoutTexture.position`
    property and the ways we can set it. Add this function below `changeColor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And call it just below the `changeColor()` call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now if you will run it and tap inside your game scene, you will see `spriteWithoutTexture`
    changing its position and toggling between them.
  prefs: []
  type: TYPE_NORMAL
- en: The most part of the code is the same as in `changecolor(),` except the position.
    In `case 0`, we set its position to `CGPointZero`. Position is measured in the
    `CGPoint` unit. `CGPointZero` is equivalent to `CGPointMake(0, 0)`. The position
    of a sprite depends on its `anchorPoint` as well as its parent `anchorPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: As we define `GameScene` `anchorPoint` to `(0.5 , 0.5)`, it means any other
    node which will be added to `GameScene` will have the starting `position(0,0)`,
    from the middle of the screen. That's why the background and `spriteWithoutTexture
    (0,0)` co-ordinate will be in middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we specified the `anchorPoint` of `spriteWithoutTexture`, it will take
    its default value of `(0.5,0.5)`. This means that its `anchorPoint` will be in
    the center of it. Hence, in `case 0`, it is rendering in the middle of the screen
    symmetrically. In `case 1` and `case 2`, we just moved it to the right middle
    corner and left middle corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to change `anchorPoint` and see what happens. Add this line inside
    `addSpriteWithoutTexture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now run it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the position of a sprite](img/4201_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before tap
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the position of a sprite](img/4201_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After tap
  prefs: []
  type: TYPE_NORMAL
- en: You will see that all the positions are not as they were before. Can you guess
    the reason for this?
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code line, we assigned the new value `(0,0)` to `spriteWithoutTexture`,
    which will remove its default value `(0.5,0.5)`. This means that its `anchorPoint`
    will not start from its middle. It will start from the bottom left of this. To
    visualize it, consider your sprite's top right corner as `1,1`, and bottom left
    corner as `0,0`. Now if you will set `anchorPoint` to `0,0`,it will be at the
    bottom left of the sprite. If you will take it to `0,1`, it will be at the top
    left. For `1,1`, it will at the top right and for `1,0`, it will at the bottom
    right. You can change it to whatever value you like, such as negative `(-1,-2)`
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can see that setting `anchorPoint` becomes easy once we are familiar
    with co-ordinate numbers on the screen. So, let''s test ourselves by setting the
    `spriteWithoutTexture` position to what it was before, using `0,0` as `anchorPoint`.
    Replace the `changePosition` function from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line inside the `addSpriteWithoutTexture()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now run it. You will see the same result as before, in your `GameScene`.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we made a little adjustment. We want `spriteWithoutTexture` to
    be positioned in the center. As its `anchorPoint` is `(0,0)`, its bottom left
    corner will be in the middle of the screen. So, to show it in the middle of the
    screen, we have to set its position by subtracting half of each width and height
    with the middle screen points, which are `0,0`. Same goes for the left and right
    position of the `sprite`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just try to set `MenuScene anchorPoint` to `(1,1)`, inside the `GameViewController.swift`
    file, and try to adjust the button and background position by yourself. If you
    are unable to do so, just add the following code inside the `addChildToScene`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run this code, you will notice the same result as before. After
    positioning, let's talk about resizing a sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing a sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the `SKSpriteNode` class is inherited from the `SKNode` class, it also inherits
    `xScale` and `yScale` properties from the `SKNode` class. In our scene, we have
    given the background the same width as our view. We will achieve the same result
    as before, if we use its original size and scale its width and height. Open the
    `GameScene` class and update the `addBackGround` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have modified the function, `addBackGround()`. to enable our game to detect
    the screen dimensions of our device. This gives portability to our game (for example,
    the iPhone 5 and iPhone 6 have different screen dimensions). Now this function
    will return two float values as the ratio of screen size and background size in
    both width and height. After setting those to `backgroundNode.xScale` and `backgroundNode.yScale`,
    if you run this code, you will get the same result as before.
  prefs: []
  type: TYPE_NORMAL
- en: Working with texture objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a sprite is created, Sprite Kit creates a texture also. But sometime we
    require texture to do some complex work, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the same texture between multiple sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a node tree into a texture like a screen shot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make this simple, Sprite Kit provides us the `SKTexture` class. We can make
    an object of this class and use it as we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `MenuScene.swift` file and make a reference of `SKTexture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a function call, `generateTestTexture`, and call it from `didMoveToView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run it and you will see many play textures in a sequence. We have made these
    using only one texture. Earlier, we were making the `SKSpriteNode` object from
    an image name, allowing Sprite Kit to create texture. Now we are assigning a texture
    to the `SKNode` object, which was created by us. Now, as we have done many customizations
    with sprites, let's have a look at the texture atlas.
  prefs: []
  type: TYPE_NORMAL
- en: What is a texture atlas?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A game's performance is dependent on the number of sprites used in it. The fewer
    the number of sprites, the more performance it gives. For this purpose, Sprite
    Kit provides texture atlases, which pack our image files automatically into one
    or more large images.
  prefs: []
  type: TYPE_NORMAL
- en: It provides us with a way to improve the performance of our game by drawing
    multiple images with a single draw call. When the game is in the development phase,
    compiler goes through every folder to find the folders with the `*.atlas` format.
    When those folders are identified, all of the images inside them are combined
    into one or more large image files. So, if you want to use this, place your images
    inside a folder and then rename it by suffixing `.atlas` to its name.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to add a player to `GameScene`. Let's take the player's all
    idle state images to a folder, and name it `idle.atlas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in Xcode, in **Project Navigator**, right-click on your project and select
    **Add to Project**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a texture atlas?](img/4201_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select the directory (not the files) and click on **Add**. Defaults should be
    OK, but make sure it's set to copy.
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a texture atlas?](img/4201_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we are going to add a player to our `GameScene`. Open `GameScene` and create
    the function, `addPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Comment on the `addSpriteWithoutTexture` function and call the `addPlayer`
    function. Your function will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert to comment tap part from `touchesBegan` in the code. So that we don''t
    get stuck if a touch occurs; otherwise the image of the player may obstruct the
    touch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, run it and see. You will see the player in the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we made a `SKSpriteNode` instance by passing an image name inside
    it. It will search for the Atlas for that image. But if we have an identically
    named image inside our project, this image will be loaded instead of the texture
    atlas. You have to use whatever the name of your image is.
  prefs: []
  type: TYPE_NORMAL
- en: When we put images inside a folder with `.atlas` extension, Xcode generates
    one or more big images by combining all the images into one.
  prefs: []
  type: TYPE_NORMAL
- en: To see that packed image, go to your `Products` folder in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `.app` file there and click on **Show in Finder**, so that
    we can go to its directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the `.app` file and select **Show Package Contents**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, go to **Contents** | **Resources** | `*.atlasc`. Here you will see
    two files, an image, and a plist. If you will look at the image, you will find
    that images are combined into a texture, which has its height and width in the
    power of 2\. If you will open the plist, you will see that it contains the position
    of images inside the packed texture, so that we can access them directly using
    Texture Atlas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can access texture atlas also. Let''s use `TextureAtlas` and do something
    on tap:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all make a texture atlas reference in `GameScene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, make a player reference outside of function so that we can use
    it in another function too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now edit the `addPlayer` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the function, `changeSpriteFromTextureAtlas()`, and call it from `touchesBegan`.
    Now, it should look like the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run and tap on the player. You will see that the player changes its sprite
    on tap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created the `SKTextureAtlas` reference. We named it as `atlas` file
    and added it to project. Now we can fetch the image from the texture atlas file.
    This is the way through which we can directly access the texture atlas. Texture
    atlases are very useful to make animation sequences or level generations from
    tiles. We will talk about animation in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we are using textures to make sprites, sometimes we might need to preload
    textures into memory. Let's discuss this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Preloading textures into memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprite Kit performs memory management very well. When a texture is needed to
    be rendered in scene, but is not prepared, Sprite Kit loads it into memory, and
    uploads it to the graphics hardware by converting it to a usable form. If many
    unloaded textures are needed at once, it might slow down the game. To avoid this,
    we need to preload textures before using them, especially in larger or more complex
    games.
  prefs: []
  type: TYPE_NORMAL
- en: This problem may arise when a user has to go from the level screen to the game
    screen. As the game screen may have many textures, it will need to load and might
    be slow due to the loading of texture. To avoid this, we can use the `SKTexture
    class preloadTextures(_:withCompletionHandler:)` function. It takes an array of
    SKTexture and a block, which is called after all the texture is loaded. So, we
    can use this block to load a scene.
  prefs: []
  type: TYPE_NORMAL
- en: For a small game, we can load all the textures at once, at game launch time.
    For a larger game, we will need to split the textures into different levels according
    to scene and other such criteria. The textures which are not useful to a level
    are discarded to save memory. And if the game is too big, we will need to load
    textures dynamically as the game runs.
  prefs: []
  type: TYPE_NORMAL
- en: As we load textures, we also need to remove the unnecessary textures from memory
    too. When a texture is loaded into memory, it stays there until its reference
    `SKTexture` object is deleted. To delete an `SKTexture` object, we have to remove
    the reference from it; this will make the texture unload from the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we read about sprites in detail. We learned about how to initialize
    a sprite, and about the sizing and positioning of a sprite. We also learned about
    the various color properties of the sprite. The lighting and shader properties
    were also discussed. Finally, we discussed about the `Texture` object, usage of
    the texture atlas, and preloading of the texture into memory.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning about nodes and various other concepts
    of the tree node structure.
  prefs: []
  type: TYPE_NORMAL
