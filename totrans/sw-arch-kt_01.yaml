- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Essence of Software Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构的本质
- en: '**Software architecture** is the blueprint of a software system. It may not
    contain a single line of code but it describes how different structures work together
    so that systematic behaviors emerge from these structures, and thus the system
    serves its intended functions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件架构**是软件系统的蓝图。它可能不包含一行代码，但它描述了不同结构如何协同工作，从而使系统从这些结构中产生系统行为，从而系统实现其预期功能。'
- en: 'This is a book for those who wish to boost their architectural knowledge and
    mindset to solve daily engineering problems. In this chapter, we will discuss
    the essential values of software architecture and its position in an organization.
    We are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是为那些希望提高他们的架构知识和思维方式以解决日常工程问题的人准备的。在本章中，我们将讨论软件架构的基本价值和它在组织中的位置。我们将涵盖以下主题：
- en: The importance of software architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构的重要性
- en: The role of an architect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构师的角色
- en: Conway’s law
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 康威定律
- en: Choosing a framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择框架
- en: Documentation and diagrams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档和图表
- en: The importance of software architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构的重要性
- en: Why should we bother with software architecture? In theory, a good engineer
    can simply jump into coding. Given time and effort, a software system can be produced
    to start functioning. This is a typical example of jumping to the result without
    extracting the value from the process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要关心软件架构呢？从理论上讲，一个好的工程师可以直接开始编码。给定时间和努力，可以生产出一个软件系统以开始运行。这是一个典型的跳到结果而不从过程中提取价值的例子。
- en: A software system is a living entity that needs to adapt to the changes in the
    environment. Let us use a real-life example to illustrate this concept.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统是一个需要适应环境变化的活生生的实体。让我们用一个现实生活中的例子来说明这个概念。
- en: Real-life use case – community service exchange as a contract
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际应用案例 - 社区服务交换作为合同
- en: In a village community, every household offers help to each other. One household’s
    members have certain skills lacking in another household. A member in household
    A is good at plumbing but not good at making clothes, while a member in household
    B is a tailor but the household needs pipes fixing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个村庄社区中，每个家庭都互相提供帮助。一个家庭的成员在另一个家庭缺少某些技能。家庭A的成员擅长管道工但不会做衣服，而家庭B的裁缝需要修理管道。
- en: So, household A offers to fix the pipes of household B in exchange for household
    B making clothes for a newborn baby in household A.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，家庭A提出为家庭B修理管道，以换取家庭B为家庭A的新生儿制作衣服。
- en: Each household uses bookkeeping software to keep records of the exchange of
    services in each household’s file. Each copy of the software in each household
    does not communicate with the other.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个家庭使用记账软件来记录每个家庭文件中的服务交换。每个家庭中的软件副本之间不进行通信。
- en: It works well for a while until some households have a dispute over what was
    agreed in their exchange of services. Both households claimed their records were
    correct in the software; however, the records in each copy of the software are
    slightly different. Since each copy of software does not communicate with the
    other, the dispute cannot be easily resolved.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它在一开始工作得很好，直到一些家庭在服务交换中发生争议。双方都声称他们的记录在软件中是正确的；然而，软件每个副本中的记录略有不同。由于软件的每个副本之间不进行通信，因此争议无法轻易解决。
- en: One of the possible enhancements of the bookkeeping software would be to keep
    the records in a central data store so that households can view and agree on the
    details of the exchange of services before carrying out their services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 记账软件可能的改进之一是将记录保存在中央数据存储中，以便家庭在执行服务之前可以查看并同意服务交换的细节。
- en: However, the bookkeeping software was written without architecture. All we have
    are lines and lines of codes, scattered in multiple files, and with some duplicated
    logic in multiple places. The code itself may be well-written and organized, but
    the original engineer has left the village, and the new engineer does not understand
    the rationale behind the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记账软件是在没有架构的情况下编写的。我们只有一行又一行的代码，散布在多个文件中，并且在多个地方存在一些重复的逻辑。代码本身可能写得很好且组织有序，但原始工程师已经离开了团队，而新工程师并不理解代码背后的逻辑。
- en: Software architecture as a means of communication
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构作为沟通手段
- en: Software architecture is fundamentally a way of communication. Firstly, it defines
    what problems it solves in an abstract manner that stakeholders from non-engineering
    backgrounds can understand and reason about the software system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构本质上是一种沟通方式。首先，它以抽象的方式定义了它解决的问题，使得来自非工程背景的利益相关者可以理解和推理软件系统。
- en: Stakeholders use specific terms in describing the problem. Sometimes, different
    stakeholders use different terms that mean the same thing, or they might use the
    same term but mean different things. Engineers will also need to align with the
    terms and usage in the engineering structures. Software architecture acts as a
    common language and understanding so that all stakeholders and engineers can communicate
    with well-defined terms.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者会使用特定的术语来描述问题。有时，不同的利益相关者可能会使用不同的术语来表示相同的意思，或者他们可能会使用相同的术语但有不同的含义。工程师也需要与工程结构中的术语和用法保持一致。软件架构作为一种共同的语言和理解，使得所有利益相关者和工程师都可以使用明确的术语进行沟通。
- en: Usually, stakeholders make use of software architecture to integrate with their
    operation workflows. They may have other systems to interact with, or they need
    teams of people to work in various parts of the system. Software architecture
    becomes a visualization of the automated part of the workflow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，利益相关者会利用软件架构来整合他们的操作工作流程。他们可能需要与其他系统进行交互，或者需要团队在系统的不同部分工作。软件架构成为工作流程自动化部分的可视化。
- en: Software architecture as training materials
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构作为培训材料
- en: Secondly, software architecture provides an abstract view of how different structures
    work together and focuses on certain concerns at a time. A new engineer joining
    the team usually has a lot to learn to understand how the current system works.
    Source code is the ultimate source of truth; however, it could be laborious and
    time-consuming to read it all. Source code is usually cluttered with language
    syntax and layers of function invocations. Building up an understanding of the
    system from the code bottom-up is certainly possible, but it would take a long
    time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，软件架构提供了一个不同结构如何协同工作的抽象视图，并专注于某一方面的关注点。新加入团队的工程师通常有很多东西要学，才能理解当前系统的工作方式。源代码是真理的最终来源；然而，阅读所有内容可能会很费力且耗时。源代码通常充满了语言语法和多层函数调用的混乱。从代码底部向上建立对系统的理解当然是可能的，但这需要很长时间。
- en: Learning is much more effective with architectural documents that guide new
    members directly to the areas they care about. It is less overwhelming than source
    code, and it avoids engineers treating the bugs in code as the correct behaviors.
    New engineers can learn one aspect of the system at a time, with the aid of architectural
    documents.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有引导新成员直接关注他们所关心领域的架构文档的帮助下，学习效果会更好。它比源代码更不令人感到压倒，并且避免了工程师将代码中的错误视为正确行为。新工程师可以在架构文档的帮助下一次学习系统的某个方面。
- en: Software architecture to manifest system quality attributes
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构来体现系统质量属性
- en: System quality attributes, also known as system non-functional attributes, are
    the characteristics of a software system that define its overall behaviors, and
    operational and performance aspects. They are non-functional in that they are
    agnostic to the functional or business problems the system solves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 系统质量属性，也称为系统非功能性属性，是定义软件系统整体行为、操作和性能方面的特征。它们是非功能性的，因为它们与系统解决的功能或业务问题无关。
- en: System quality attributes, such as availability, scalability, security, testability,
    extendability, and maintainability, are difficult to measure with only code. Software
    architecture provides at least one view to manifest each of these attributes so
    we can tune the system accordingly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 系统质量属性，例如可用性、可伸缩性、安全性、可测试性、可扩展性和可维护性，仅凭代码难以衡量。软件架构至少提供了一个视图来体现这些属性中的每一个，以便我们可以相应地调整系统。
- en: In the given example, the software could be lacking redundancy in the sense
    that each copy of the software stores the data in its own local storage and does
    not communicate with any other. If a copy has stopped working, the household would
    lose all data. Also, because each copy does not communicate with the other, there
    is no reliable way to guarantee that two households who exchanged services have
    the same records in their own software copies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定示例中，软件可能在冗余方面存在不足，即每个软件副本都将其数据存储在其自己的本地存储中，并且不与任何其他副本通信。如果一个副本停止工作，家庭将丢失所有数据。此外，由于每个副本不与其他副本通信，没有可靠的方法来保证交换服务的两个家庭在自己的软件副本中有相同的记录。
- en: By having software architecture to describe the system attributes, engineers
    will be able to identify the issue and design a change to improve the given attributes.
    Moreover, it enables us to measure and monitor how these attributes change over
    time and correlate them with software changes. We are even able to project and
    predict these attributes when we plan a change to the current software architecture.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过软件架构来描述系统属性，工程师将能够识别问题并设计变更以改善给定的属性。此外，它使我们能够衡量和监控这些属性随时间的变化，并将它们与软件变更相关联。当我们计划对当前软件架构进行变更时，我们甚至能够预测这些属性。
- en: Software architecture as a change management tool
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构作为变更管理工具
- en: Usually, problems change and evolve over time. In the example, separated records
    of the exchange of services in each copy of the software were sufficient, as there
    was not a dispute. Software architecture provides a foundation for changes and
    enhancements. In many cases, different stakeholders have different priorities
    in their minds. Software architecture facilitates the discussion of how the system
    could evolve and at what cost, so the enhancement can be prioritized in order.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，问题会随着时间的推移而变化和演变。在示例中，软件副本中服务交换的分离记录是足够的，因为没有争议。软件架构为变更和增强提供了基础。在许多情况下，不同的利益相关者心中有不同的优先级。软件架构促进了关于系统如何演变以及成本的讨论，以便可以按顺序优先考虑增强。
- en: Also, with system attributes being described in software architecture, we can
    identify and mitigate risks since we understand which part of the architecture
    is being changed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于系统属性在软件架构中得到了描述，我们可以识别和减轻风险，因为我们了解架构的哪个部分正在被更改。
- en: Software architecture as records of reusable solutions
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构作为可重用解决方案的记录
- en: Software architecture documents a series of concerns raised and decisions made.
    In the example of the bookkeeping software, since the original engineer has left
    the village, no one really knows the thinking process and why certain design choices
    were made at the time. It becomes very risky to enhance the system as no one knows
    the impact of changing one line of code. The idea of a central data store was
    planned and we are just one step behind it, or it was never designed to share
    data. We simply do not know.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构记录了一系列提出的问题和做出的决策。在账务软件的示例中，由于原始工程师已经离开村庄，没有人真正了解思维过程以及为什么当时做出了某些设计选择。增强系统变得非常危险，因为没有人知道更改一行代码的影响。中央数据存储的想法已经计划好了，我们只是落后一步，或者它从未被设计为共享数据。我们根本不知道。
- en: This leaves us unable to safely improve the software, or even just to fix a
    bug. We might end up making the same mistake. We might misunderstand the original
    intent of the software and even create a bug. It becomes difficult to continue
    using the software if the problem evolves like the given example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们无法安全地改进软件，甚至无法修复一个错误。我们可能会犯同样的错误。我们可能会误解软件的原始意图，甚至创建一个错误。如果问题像给定示例那样发展，继续使用软件变得困难。
- en: Software architecture acts as a set of records of decisions made to solve the
    problem. It explains the rationale of what drove the decisions and what factors
    were considered to make the choice. It also records any alternatives considered
    and why they were not eventually chosen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构充当了解决问题的决策记录集。它解释了驱动决策的理由以及考虑了哪些因素来做出选择。它还记录了任何考虑过的替代方案以及为什么最终没有选择它们。
- en: Software architecture also identifies any constraint the system is bound to.
    It is important to include constraints because any new technological advancement
    may eliminate such constraints, such as new frameworks, and thus create new opportunities
    for improvement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构还确定了系统所受的任何约束。包括约束很重要，因为任何新的技术进步都可能消除这些约束，例如新的框架，从而为改进创造新的机会。
- en: All this information provides solid ground if, one day, we decide to start a
    new system from scratch to solve the problem. We will not need to start from zero.
    We can start from what we have learned and the journey behind it. We can reuse
    a lot of the concepts from previous architecture if the context is applicable.
    We can significantly improve the next system with fewer constraints imposed on
    the previous system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息为我们提供了一个坚实的基础，如果有一天我们决定从头开始构建一个新的系统来解决问题，我们不需要从头开始。我们可以从我们所学的知识和背后的旅程开始。如果适用，我们可以重用之前架构中的许多概念。我们可以通过在之前系统上施加更少的约束，显著改善下一个系统。
- en: The role of a software architect
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构师的角色
- en: It may seem obvious that a software architect (the *architect*) is someone who
    creates software architecture. However, software architecture is the result of
    multi-dimensional thought processes that involve a lot of people. There is no
    single architect who would produce architecture alone and require no input from
    others.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师（*架构师*）似乎是一个创建软件架构的人，这似乎是显而易见的。然而，软件架构是多维思维过程的结果，涉及很多人。没有哪个架构师会单独产生架构，并且不需要从其他人那里获取输入。
- en: It is important to point out that, although a software architect can be a job
    title in some organizations, the role of a software architect is not restricted
    to only someone who has the title.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，尽管在某些组织中软件架构师可能是一个职位名称，但软件架构师的角色并不局限于只有拥有该头衔的人。
- en: Interface between engineers and stakeholders
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工程师与利益相关者之间的接口
- en: Software architects align and translate the language used by engineers and non-technical
    people (the *stakeholders*). They facilitate communication using documentation
    and diagrams to illustrate key topics in the software system for discussion. There
    are variations in how the interface works between engineers and different stakeholders
    with the facilitation of software architects. We are going to explore these variations
    now.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师协调并翻译工程师和非技术人员（*利益相关者*）使用的语言。他们通过使用文档和图表来阐述软件系统中的关键主题，以促进沟通。在软件架构师的协助下，工程师和不同利益相关者之间的接口工作方式存在差异。我们现在将探讨这些差异。
- en: Engineers and product managers
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工程师和产品经理
- en: Software architects translate product requirements into technical designs. Engineers
    can do the same, but software architects apply a broader view in the sense of
    how certain implementations may impact system quality attributes. Software architects
    do not dictate the choice of implementation; however, they define non-functional
    requirements that predict system quality attributes. The non-functional requirements
    provide directions and constraints on the implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师将产品需求转化为技术设计。工程师也可以做到这一点，但软件架构师在如何某些实现可能影响系统质量属性方面具有更广阔的视角。软件架构师不会指定实现的选择；然而，他们定义非功能性需求，这些需求可以预测系统质量属性。非功能性需求为实施提供了方向和约束。
- en: In the example given previously, if a software architect were involved in the
    technical design process, they could have required the records of the exchange
    of service between neighbors to be replicated in both software copies and thus
    could have avoided the dispute of inconsistent records.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面给出的例子中，如果软件架构师参与了技术设计过程，他们可以要求邻居之间的服务交换记录在两个软件副本中复制，从而可以避免不一致记录的争议。
- en: Software architects also take part in translating technical constraints, bugs,
    and implementations into information that product managers can digest and engage
    in. Software architects provide an abstract view of the code implementation to
    facilitate communication with product managers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师还参与将技术约束、错误和实现转化为产品经理可以消化并参与的信息。软件架构师提供代码实现的抽象视图，以促进与产品经理的沟通。
- en: Imagine there is a new framework that facilitates two software copies to synchronize
    records of service exchange between neighbors, which permanently solves the dispute
    problem. Software architects can document this new approach and abstract the interaction
    to provide a foundation to discuss with product managers how this improves user
    experience.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个新的框架，它促进了两个软件副本同步邻居之间的服务交换记录，从而永久解决了争议问题。软件架构师可以记录这种新的方法，并抽象出交互，为与产品经理讨论如何改善用户体验提供基础。
- en: Engineers and delivery managers
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工程师和交付经理
- en: There is often tension when it comes to engineers developing features and delivery
    managers managing the timeline for when those features can be released. It is
    common for engineers to not deliver the full features in time. Software architects
    can facilitate the discussion of how the features may be delivered in phases and
    still be operational. In each phase, software architects determine the impact
    on system quality attributes and how users can operate in the meantime.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师开发功能而交付经理管理这些功能发布的时间表时，常常会出现紧张关系。工程师未能及时交付完整功能是常见的情况。软件架构师可以促进讨论如何分阶段交付功能，同时保持系统的运行。在每个阶段，软件架构师确定对系统质量属性的影响以及用户在此期间如何操作。
- en: This is just an example of how software architects are involved when full features
    will not be available in time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是软件架构师在完整功能无法及时提供时参与的例子。
- en: Regulators and compliance
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监管机构和合规性
- en: Software systems, particularly in regulated industries, must address compliance
    concerns. The range is wide, and it may include the processing of personal data,
    auditing of persisted data, or complying with regulatory procedures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统，尤其是在受监管的行业中，必须解决合规性问题。范围很广，可能包括个人数据处理、持久数据的审计或遵守监管程序。
- en: Software architects are not only involved in designing an architecture that
    complies with regulations but also in illustrating how it was implemented. Regulatory
    bodies will examine technical documents, including architecture diagrams, as part
    of their due diligence process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师不仅参与设计符合规定的架构，还参与说明其实现方式。监管机构将审查技术文件，包括架构图，作为其尽职调查过程的一部分。
- en: Security professionals
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全专业人士
- en: People who specialize in the fields of information security or cybersecurity
    work with software architects in multiple areas.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于信息安全或网络安全领域的人士与软件架构师在多个领域合作。
- en: They provide security requirements in line with security policies, procedures,
    and guidelines. The requirements might include authentication, access control,
    and even the choice of encryption algorithms.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 他们根据安全政策、程序和指南提供安全需求。这些需求可能包括身份验证、访问控制和甚至加密算法的选择。
- en: Software architects work with security analysts to perform threat modeling and
    risk assessment. They analyze the system architecture, identify vulnerabilities
    and risks, and discover potential attacks. The likeliness and impact of threats
    drive architectural choices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师与安全分析师合作，进行威胁建模和风险评估。他们分析系统架构，识别漏洞和风险，并发现潜在的攻击。威胁的可能性和影响驱动着架构选择。
- en: Software architects may also work with penetration testers or ethical hackers
    to discover security holes and potential fixes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师还可能与渗透测试人员或道德黑客合作，以发现安全漏洞和潜在修复方案。
- en: Security architects collaborate with software architects to identify and choose
    the approach to address identified risks and meet security requirements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 安全架构师与软件架构师合作，确定和选择解决已识别风险和满足安全要求的方法。
- en: Stakeholders
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利益相关者
- en: Stakeholders usually come from multiple departments of the organization, and
    they are likely to have different requirements and priorities for how the system
    is required to work. Software architects can navigate these tangled requirements
    and ensure that the system can fulfill these requirements in an agreed priority
    order.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者通常来自组织的多个部门，他们可能对系统如何运行有不同的需求和优先级。软件架构师可以导航这些错综复杂的需求，并确保系统能够按照商定的优先级顺序满足这些需求。
- en: Software architects also play the part of extracting common terms from multiple
    domain experts and stakeholders so the terms can be used in the architecture documents
    in a clear and unambiguous manner.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师还扮演着从多个领域专家和利益相关者中提取通用术语的角色，以便这些术语可以在架构文档中以清晰和明确的方式使用。
- en: Balancing appropriate architecture and budget
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平衡适当的架构和预算
- en: While some software architects might be keen on having the most state-of-the-art
    technology and the latest and the fastest, realistically, they are more balanced
    with the budget the organization can afford.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些软件架构师可能热衷于拥有最先进的技术和最新、最快的，但现实中，他们更倾向于与组织能够承担的预算保持平衡。
- en: Financial constraints on technology choice do not necessarily result in bad
    architecture; on the contrary, they encourage software architects to find more
    cost-effective ways to solve problems, and they could lead to a leaner and simpler
    architecture. If two architectures can address an identical set of concerns, the
    simpler and cheaper one is always better.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 技术选择上的财务限制并不一定导致糟糕的架构；相反，它们鼓励软件架构师寻找更经济有效的方法来解决问题，并可能导致更精简、更简单的架构。如果两个架构可以解决相同的一组问题，那么更简单、更便宜的那个总是更好的。
- en: The decision of whether to buy or build is often affected by multiple factors,
    and the technical factor is only one of them. Although software architects may
    not have the power to decide which way to go, they provide technical and operational
    analysis so the organization can make an informed choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 是否购买或构建的决定通常受多个因素的影响，技术因素只是其中之一。尽管软件架构师可能没有决定走哪条路的权力，但他们提供技术和运营分析，以便组织可以做出明智的选择。
- en: When the organization cannot afford the most technically sound system or service,
    software architects are there to bring out compromise, trade-offs, and impact
    analysis for the “second-class solution.” It may seem not ideal initially, but
    software architects can design the system in a way that leaves room for enhancement
    and expansion in the future.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当组织负担不起最技术先进的服务或系统时，软件架构师会提出折衷方案、权衡利弊和影响分析，以提供“次级解决方案”。起初这可能看起来并不理想，但软件架构师可以设计系统，使其在未来有改进和扩展的空间。
- en: Vision and roadmap to technical evolution
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术演变的愿景和路线图
- en: '**Legacy systems** are outdated software systems that are still in use by the
    organization. They are legacy because their technology has very little room for
    improvement, and it is likely at least a few years backward.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统系统**是组织仍在使用的过时软件系统。它们之所以成为传统系统，是因为它们的技术改进空间非常有限，并且可能至少落后几年。'
- en: There are systems that became legacy due to external factors such as discontinued
    technology support and severe limitations. And there are no feasible or cost-effective
    ways to evolve.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有些系统由于外部因素（如技术支持中断和严重限制）而成为传统系统，并且没有可行或成本效益的方法来演进。
- en: Legacy systems can also be the result of the lack of technical vision and roadmaps,
    in which software architects are heavily involved. Some small start-ups may not
    have someone taking the role of software architect, or there is no one championing
    software architecture continuously. These can all be reasons for systems to become
    legacy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 传统系统也可能是缺乏技术愿景和路线图的结果，其中软件架构师参与度很高。一些小型初创公司可能没有软件架构师的角色，或者没有人持续倡导软件架构。这些都可能是系统成为传统系统的原因。
- en: However, software architects can still jump in at any point to modernize the
    current architecture. They start by understanding what the current system does
    and what the organization really needs. Then, they decompose the system into autonomous
    parts, modernize them individually, and recombine them in a separate way so the
    whole technical ecosystem can be up to date again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，软件架构师仍然可以在任何时刻介入，对当前的架构进行现代化改造。他们首先了解当前系统做什么以及组织真正需要什么。然后，他们将系统分解成自主的部分，分别对其进行现代化改造，并以不同的方式重新组合，以便整个技术生态系统再次更新。
- en: Usually, a technical vision includes inspiration in achieving a software architecture
    that manifests certain system quality attributes, such as highly available and
    scalable systems. While a technical roadmap includes small steps to achieve short-
    to medium-term goals, and some more dramatic changes to long-term goals, it requires
    meticulous planning and thought toward how the system evolves. Also, the technical
    roadmap must interact with the external technological evolution to pivot and adapt
    to a better alternative.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，技术愿景包括实现具有某些系统质量属性（如高度可用和可扩展的系统）的软件架构的灵感。而技术路线图包括实现短期到中期目标的微小步骤，以及一些对长期目标的更重大变化，它需要细致的计划和思考，以了解系统的演变。此外，技术路线图必须与外部技术演变互动，以便转向和适应更好的替代方案。
- en: Cross-cutting concerns in a technical ecosystem
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术生态系统中的横切关注点
- en: Cross-cutting concerns are typically the concerns that require multiple software
    components to work together to derive the desired outcome.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 横切关注点通常是那些需要多个软件组件协同工作以产生预期结果的关注点。
- en: One example can be standardizing logging messages so they can facilitate cross-service
    log searches.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以是标准化日志消息，以便它们可以促进跨服务的日志搜索。
- en: Engineers are often divided into teams and each team looks after a certain area
    of business. They do not necessarily have the bandwidth to ensure that services
    in other teams conform to the same convention to achieve cross-cutting outcomes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师通常被分成团队，每个团队负责一定的业务领域。他们不一定有足够的带宽来确保其他团队的服务遵守相同的约定以实现跨领域的成果。
- en: Software architects engage these cross-cutting concerns in a holistic manner.
    They consult, engage, and discuss with multiple teams to form a consensus or convention
    so cross-cutting concerns can be addressed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师以整体的方式处理这些跨领域问题。他们与多个团队进行咨询、参与和讨论，以形成共识或约定，从而使跨领域问题得以解决。
- en: Software architects also drive common infrastructures, frameworks, and tooling
    to address these cross-cutting concerns. These concerns are closely related to
    the system quality attributes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师还推动共同的基础设施、框架和工具来解决这些跨领域问题。这些问题与系统的质量属性密切相关。
- en: Let us say there are multiple services that need to communicate with each other,
    and REST endpoints are chosen to be the way of communication. However, without
    establishing standards among teams, the system quickly falls into a collection
    of inconsistent APIs. The URI resource hierarchy can be inconsistent, as can the
    error response payload. All these impact the maintainability and reusability of
    the system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有多个服务需要相互通信，并且选择了REST端点作为通信方式。然而，如果没有在团队之间建立标准，系统很快就会陷入不一致的API集合。URI资源层次结构可能不一致，错误响应有效载荷也可能不一致。所有这些都会影响系统的可维护性和可重用性。
- en: 'Software architects can be involved in understanding each team’s requirements
    and their concerns about using REST endpoints. Then, a guideline of REST endpoints
    can be created so that there is a pattern that engineers align with. A typical
    example would be to define a general payload structure for error responses to
    contain information in addition to the HTTP response status:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师可以参与理解每个团队的需求以及他们对使用REST端点的担忧。然后，可以创建REST端点的指南，以便工程师遵循一定的模式。一个典型的例子是为错误响应定义一个通用有效载荷结构，以包含除HTTP响应状态之外的信息：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This sample payload represents an error of an address input; it contains general
    fields such as `resource`, `shortMessage`, and `longMessage` that every service
    can conform to, while also having a `details` section to be customized by each
    service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有效载荷代表了一个地址输入的错误；它包含诸如`resource`、`shortMessage`和`longMessage`等通用字段，每个服务都可以遵守，同时还有一个`details`部分，可以由每个服务自定义。
- en: By having this standard, we can achieve overall observability of these errors
    and persist them in a universal format for audit purposes. Engineers can reuse
    this structure to reduce the time needed to develop a new REST endpoint. Engineers
    will also find it easier to maintain a REST endpoint even if it was developed
    by other engineers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个标准，我们可以实现这些错误的总体可观察性，并以通用格式持久化，以便审计。工程师可以重用这个结构来减少开发新的REST端点所需的时间。即使是由其他工程师开发的REST端点，工程师也会发现维护它更容易。
- en: In a sense, standardizing the REST error payload has addressed the cross-cutting
    concerns of observability, auditability, maintainability, and reusability in the
    whole technical ecosystem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，标准化REST错误有效载荷解决了整个技术生态系统中可观察性、可审计性、可维护性和可重用性的跨领域问题。
- en: Conway’s law
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 康威定律
- en: '**Conway’s law** is an observation that the system design of an organization
    mirrors the organizational structure. A computer programmer called Melvin Conway
    introduced this idea in 1967, and his original wording is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**康威定律**是一个观察，即组织的系统设计反映了组织结构。计算机程序员梅尔文·康威在1967年提出了这个想法，他的原始措辞如下：'
- en: “Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization’s communication structure.”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “任何设计系统（广义上）的组织都会产生一个结构，其结构与组织的沟通结构相匹配。”
- en: 'In the context of software systems, software architecture mirrors the organization
    structure. The classic example can be illustrated in this diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件系统的背景下，软件架构反映了组织结构。经典的例子可以通过以下图表说明：
- en: '![Figure 1.1 – A company organized by skill set](img/1.1.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 按技能集组织的企业](img/1.1.jpg)'
- en: Figure 1.1 – A company organized by skill set
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 按技能集组织的企业
- en: The company has a **backend engineering** (**BE**) team, a **frontend engineering**
    (**BE**) team, and a **database engineering** (**DE**) team. This organization
    groups people by their skill set. Everyone in a team is responsible for all business
    functions. This structure is likely to produce a monolithic system, which usually
    manifests in a single source code repository or one single logical process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 公司有一个**后端工程**（**BE**）团队、一个**前端工程**（**FE**）团队和一个**数据库工程**（**DE**）团队。这种组织根据技能集分组人员。团队中的每个人都负责所有业务功能。这种结构可能产生一个单体系统，通常表现为单个源代码库或一个单一的逻辑过程。
- en: '![Figure 1.2 – A company organized by business functions](img/1.2.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 按业务功能组织的公司](img/1.2.jpg)'
- en: Figure 1.2 – A company organized by business functions
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 按业务功能组织的公司
- en: The organization in *Figure 1**.2* groups people by their business functions.
    So, everyone in a team is responsible for a designated business function, but
    each member may not have the same skill set. This structure is likely to produce
    a modular system, which contains multiple logical processes that interact with
    each other. Usually, there are dedicated source code repositories for each team.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2中的组织根据业务功能分组人员。因此，团队中的每个人都负责一个指定的业务功能，但每个成员可能并不具备相同的技能集。这种结构可能产生一个模块化系统，其中包含多个相互交互的逻辑过程。通常，每个团队都有自己的源代码库。
- en: 'Systems scale better when the team size is small because the number of communication
    channels required for people to talk to each other is *n (n – 1) / 2* so it is
    exponentially scaled up. Jeff Bezos from Amazon proposed his two-pizza rule:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队规模较小时，系统扩展性更好，因为人们相互交流所需的信息通道数量是 *n (n – 1) / 2*，因此它是指数级扩展的。亚马逊的杰夫·贝索斯提出了他的“两个披萨规则”：
- en: “If you can’t feed your team with two large pizzas in a meeting, you’re in trouble.”
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: “如果你在会议中不能用两个大披萨喂饱你的团队，那你就麻烦了。”
- en: So, if teams cannot be too big to scale the organization as well as the system,
    then it usually ends up with many teams. This resonates a lot with the architectural
    concepts we will cover very soon.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果团队不能太大，以至于无法扩展组织和系统，那么通常会有很多团队。这与我们很快将要讨论的架构概念非常吻合。
- en: On the other hand, despite best efforts in modernizing the architecture of a
    legacy system, if the organization structure refuses to align with it, it is likely
    that the new architecture will eventually fall back to its old habitual structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，尽管在现代化遗留系统架构方面做出了最大努力，但如果组织结构拒绝与之对齐，那么新的架构最终很可能会回归到其旧的习惯结构。
- en: This is something that should be solved by engineering management and upward.
    It is beyond what software architects can solve. However, it is worth understanding
    this phenomenon so the issue can be escalated as soon as possible.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由工程管理和向上解决的事情。这超出了软件架构师可以解决的问题。然而，了解这一现象是值得的，这样问题可以尽快升级。
- en: Some big organizations found it extremely difficult to change their structures.
    And they even created start-up companies to run with modern organization structures
    alongside modern software architecture.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些大型组织发现改变他们的结构极其困难。他们甚至创建了初创公司，以现代组织结构和现代软件架构一起运行。
- en: Choosing a software framework
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择软件框架
- en: A software framework (a *framework*), or a software development framework, is
    a standardized set of tools that aim to solve certain problems by consistent approaches.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 软件框架（一个 *框架*），或软件开发框架，是一套标准化的工具，旨在通过一致的方法解决某些问题。
- en: A software system typically needs quite a few frameworks, so that they can focus
    on the business functions instead of lower-level concerns such as logging, JSON
    transformation, and configuration management. These frameworks provide a proven
    way to achieve the target software architecture. Choosing a framework is a part
    of architectural decision-making.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个软件系统通常需要相当多的框架，这样它们可以专注于业务功能，而不是像日志记录、JSON转换和配置管理这样的底层关注点。这些框架提供了一种经过验证的方式来实现目标软件架构。选择框架是架构决策的一部分。
- en: It is rare that organizations build every framework themselves these days. The
    major reason is that most of the frameworks are open-sourced and supported by
    the community. It would take a lot of justifications for an organization to decide
    to develop its own framework while there are similar competing frameworks that
    can be used for free.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组织自己构建所有框架的情况很少见。主要原因在于大多数框架都是开源的，并由社区支持。当存在可以免费使用的类似竞争框架时，组织决定开发自己的框架需要很多正当理由。
- en: Some technology companies develop their own frameworks when there are no existing
    ones that suit their needs. Some companies develop their own frameworks with the
    intent to compete with the other frameworks, and to potentially monetize from
    consulting business or to cross-sell their other products. It would take a lot
    of research effort and talent to achieve that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些科技公司会在没有现成的框架满足其需求时开发自己的框架。一些公司开发自己的框架是为了与其他框架竞争，并可能从咨询服务业务或交叉销售其他产品中获利。要实现这一点，需要大量的研究努力和人才。
- en: The other option would be to choose a framework that already exists in the market,
    commercial or open-sourced.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是选择市场上已经存在的框架，无论是商业的还是开源的。
- en: The new framework paradox
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新框架悖论
- en: New frameworks are released every month with the intent to solve the age-old
    problems of existing frameworks. Usually, there are one or two popular frameworks
    on the market, and the new frameworks advertise that they solved the old ones
    with an approach that everyone has always wanted.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个月都会发布新的框架，旨在解决现有框架的陈旧问题。通常，市场上有一到两个流行的框架，新的框架会宣传它们通过一种大家都一直想要的方法解决了旧框架。
- en: Of course, there are true paradigm-shifting new frameworks that made engineers
    more productive and really have moved the industry forward with an innovative
    approach. For example, **Ruby on Rails** has transformed the repetitive and boilerplate
    code configuration of web development into inference and conventions, hence vastly
    reducing the number of lines of code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些真正的范式转变型新框架，使工程师更加高效，并通过创新的方法真正推动了行业的发展。例如，**Ruby on Rails**将Web开发的重复性和样板代码配置转换成了推断和约定，从而大大减少了代码行数。
- en: But there are also a lot of cases where the new frameworks started with innovative
    approaches that did not go too well. And here comes the new framework paradox.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有很多情况是新框架以创新的方法开始，但并没有取得很好的效果。这就是新框架悖论。
- en: If a new framework aims to replace a framework that has been around for many
    years, the new framework will need to cover a lot of areas and keep the “new approach”
    in each area. This is a huge undertaking for the contributors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个新框架旨在取代存在多年的框架，那么新框架将需要覆盖很多领域，并在每个领域保持“新方法”。这对贡献者来说是一项巨大的任务。
- en: For example, the **Spring frameworks** were created in 2002 to simplify dependencies
    of code by using **Dependency Injection** (**DI**) and **Inversion of Control**
    (**IOC**). But now, the frameworks have evolved to cover an extensive range of
    features, such as web, messaging, security, persistence, and so on. A next-generation
    framework to replace Spring frameworks would have to cover over 20 years of development,
    with a very comprehensive coverage of technical areas.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**Spring框架**于2002年创建，旨在通过使用**依赖注入**（**DI**）和**控制反转**（**IOC**）来简化代码的依赖关系。但现在，这些框架已经发展到涵盖广泛的特性，如Web、消息传递、安全、持久性等。要取代Spring框架的下一代框架将需要覆盖超过20年的发展，对技术领域的覆盖非常全面。
- en: The most significant risk is that the new framework may have solved one of the
    longest-standing problems of a framework but it falls short of the areas that
    are fundamental and essential. It traps the engineers who adopt the new framework
    and makes them face the dilemma of whether to fix the new framework or return
    to the old one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的风险是新框架可能解决了框架长期存在的问题之一，但它却不足以覆盖基本和必要的领域。它将采用新框架的工程师困住，使他们面临是否修复新框架或返回旧框架的困境。
- en: Another risk is that the community may not agree on what the “new approach”
    should be, and therefore, multiple new frameworks are created to solve the same
    age-old problem of the old framework. Engineers who want to try a new framework
    face the choice overload problem. And sometimes, it becomes a choice paralysis
    as there is no single definitively better choice to choose from.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个风险是，社区可能无法就“新方法”达成一致，因此，为了解决旧框架的陈旧问题，可能会创建多个新的框架。想要尝试新框架的工程师面临着选择过载的问题。有时，这甚至变成了选择瘫痪，因为没有单一的明确更好的选择可供选择。
- en: Let us say your team has chosen a framework and everyone is quite happy with
    it. However, for whatever reason, the major contributor has decided to not work
    on this project anymore. Then, your team is at risk of the framework not being
    kept up to date with the fixes and planned enhancements. Not to mention that most
    open-sourced frameworks are contributed by normal engineers who spend their personal
    time for free on this.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的团队已经选择了一个框架，并且每个人都对它非常满意。然而，无论出于什么原因，主要贡献者已经决定不再参与这个项目。那么，你的团队就面临了框架无法及时更新修复和计划改进的风险。更不用说大多数开源框架都是由普通工程师无偿投入个人时间贡献的。
- en: How to compare and decide between software frameworks
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何比较和决定软件框架
- en: However, in a real situation, the team would still need to choose some frameworks
    to move forward. An example situation would be a framework for logging messages
    for a Java application. Do we use the **Java Logging** framework that comes with
    the standard **Java Development Kit** (**JDK**), **Apache Log4J**, or **Logback**?
    How could we make the most sensible choice? Unfortunately, there are no golden
    rules that guarantee the best choice, but there are several aspects that the team
    should consider before making the decision.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际情况下，团队仍然需要选择一些框架来继续前进。一个例子是，为Java应用程序记录消息的框架。我们使用随标准**Java开发工具包**（**JDK**）一起提供的**Java
    Logging**框架，**Apache Log4J**，还是**Logback**？我们如何做出最明智的选择？不幸的是，没有保证最佳选择的黄金法则，但在做出决定之前，团队应该考虑以下几个方面的几个方面。
- en: Community
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 社区
- en: '**Community** is the most crucial factor in your consideration. People are
    the reasons the framework is created, used, and maintained. Without people, the
    framework will not continue. There are at least three areas of the community for
    the framework to look for:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**社区**是你在考虑中的最重要的因素。人们是框架被创建、使用和维护的原因。没有人们，框架将无法继续。对于框架来说，至少有三个社区领域需要关注：'
- en: Firstly, the bigger the community, the more likely the framework will have someone
    to continuously support and enhance the framework. A framework should be like
    a living being, powered by the people in the community. Also, reasons for having
    a large community for a framework are likely that the framework is universally
    applicable and of acceptable quality for general usage.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，社区越大，框架就越有可能有人持续支持和改进框架。一个框架应该像是一个有生命的实体，由社区中的人们提供动力。此外，一个框架拥有大社区的原因可能是因为它具有普遍适用性，并且对于一般使用来说是可接受的。
- en: Secondly, we need to look at how well the framework is supported by the community.
    It could be as simple as getting help from another user on how to use the framework.
    It could also be the quality and quantity of technical blogs written by the members
    of the community to share their tips on how to apply the framework to problems.
    It could be measured by suggestions the community made for new features and enhancements.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们需要看看社区对框架的支持情况如何。这可能是从另一个用户那里获得如何使用框架的帮助。也可能是社区成员撰写的关于如何将框架应用于问题的技术博客的质量和数量。这可以通过社区为新功能和改进提出的建议来衡量。
- en: Thirdly, we need to see how the members of the community communicate with each
    other. Do they have a Slack channel, a Discord server, an email distribution list,
    or any instant messaging platform? How responsive are the members of the community
    when people post their questions out there? Are the people helpful and positive
    in receiving feedback?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，我们需要看看社区成员之间的沟通方式。他们是否有Slack频道、Discord服务器、电子邮件分发列表，或者任何即时通讯平台？当人们提出问题的时候，社区成员的反应有多快？人们是否乐于并积极接受反馈？
- en: Contribution
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贡献
- en: Every commit to the source code repository made up the framework the way it
    is now. It is worth checking some statistics to understand how actively the framework
    is being maintained.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每次提交到源代码存储库都构成了现在框架的样子。值得检查一些统计数据，以了解框架的维护活动有多积极。
- en: When was the last commit? Was it recently updated? How many commits have been
    made so far? Also, we can check the number of commits in the last month, the last
    6 months, or the last year. Moreover, we can look at the variety of contributors.
    A good sign is that the commits are done by a variety of contributors, not only
    the usual ones. It indicates a diverse and healthy growth from contributors putting
    their efforts into the framework.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次提交是什么时候？它是最近更新的吗？到目前为止已经提交了多少次？此外，我们可以查看上个月、上六个月或上一年内的提交次数。此外，我们可以查看贡献者的多样性。一个好的迹象是提交是由各种贡献者完成的，而不仅仅是那些常见的贡献者。这表明来自贡献者的多样化和健康增长。
- en: How many forks and branches are there? Bigger numbers usually indicate healthy
    growth that either some members of the community are working on a change or there
    could be a variant of the framework soon. It is likely that there are useful features
    already in the code base that people are willing to spend their effort on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少分支和版本？较大的数字通常表明健康的增长，这可能意味着社区的一些成员正在努力进行更改，或者很快可能会有框架的变体。很可能代码库中已经存在一些有用的功能，人们愿意投入精力。
- en: The number of tags indicates historical releases and may give a hint about the
    evolution and growth of the framework. However, be careful of versions under 1.0
    (e.g., 0.67), or simply just build numbers. The contributors in this case may
    not want to commit to the current shape of the framework, and there may be breaking
    changes in the future.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的数量表示历史版本，可能对框架的演变和增长提供一些线索。然而，要注意低于1.0的版本（例如，0.67），或者仅仅是构建号。在这种情况下，贡献者可能不想承诺长期运行框架，未来可能会有破坏性的更改。
- en: Versions under 1.0 also could mean contributors may not have confirmed their
    commitment to keep the framework running for long yet. Extra caution must be taken
    if you intend to put a *0.x* library dependency in your production system. It
    is going to be difficult if the library discontinues or introduces breaking changes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 低于1.0的版本也可能意味着贡献者可能还没有确认他们承诺长期运行框架。如果你打算在生产系统中放置*0.x*库依赖项，必须格外小心。如果库停止服务或引入破坏性更改，这将变得困难。
- en: We should also look at the source code and get an impression of the code’s quality
    and test cases. We should glance at the test coverage to understand how deep and
    broad the code was tested. This would help us predict the reliability and stability
    of the framework.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该查看源代码，并了解代码的质量和测试用例。我们应该快速查看测试覆盖率，以了解代码被测试的深度和广度。这将帮助我们预测框架的可靠性和稳定性。
- en: Tooling and documentation
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具和文档
- en: We should also consider whether the framework uses mature tooling to manage
    itself. It may include an issue tracking system that members of the community
    can submit bugs and track how long it takes for a bug to go from reported to fixed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑框架是否使用成熟的工具来自我管理。这可能包括一个问题跟踪系统，社区成员可以提交错误并跟踪错误从报告到修复所需的时间。
- en: The framework may also use an established **Continuous Integration** (**CI**)
    system. This is also a good sign of a healthy, long-running, and mature framework
    since there is a need to automate builds to handle the number of commits, control
    the quality, and release the framework.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 框架也可能使用一个已建立的**持续集成**（**CI**）系统。这也是一个健康、长期运行和成熟的框架的好迹象，因为需要自动化构建来处理提交的数量、控制质量并发布框架。
- en: '**Documentation** is a key factor to consider since this is where engineers
    learn how to use the framework. The documentation does not necessarily need to
    be polished or automatically generated. It is the quality of the content that
    matters. And diagrams would be nice if they help engineers understand the concepts.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档**是一个需要考虑的关键因素，因为工程师在这里学习如何使用框架。文档不一定是经过抛光的或自动生成的。内容的质量才是关键。如果图表有助于工程师理解概念，那么它们将是很好的。'
- en: Interoperability with other frameworks
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与其他框架的互操作性
- en: Many frameworks were designed to work with other frameworks, and some of them
    have innate dependencies on other frameworks. This is common and not a bad sign;
    however, caution must be taken on the impact.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架被设计成与其他框架协同工作，其中一些框架对其他框架有内在的依赖。这是常见的，并不是一个坏信号；然而，必须谨慎对待其影响。
- en: Adopting a framework that uses or works with another framework implies we are
    also indirectly adopting the other framework. Is the other framework compatible
    with the engineering approach the team has taken? Do we allow engineers in the
    team to use the transitive dependencies directly in the code?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 采用使用或与另一个框架一起工作的框架意味着我们也在间接地采用另一个框架。这个其他框架与团队采取的工程方法兼容吗？我们是否允许团队中的工程师直接在代码中使用传递依赖？
- en: Even if we are OK with the other framework, we still need to ensure that the
    versions are compatible. For example, framework A may have used the Apache Commons
    IO library, version 2.14.0, and our project currently uses 1.4\. Importing framework
    A to our project would bring version 2.14.0 as a dependency to the project. Luckily,
    build frameworks such as Gradle and Maven provide a graceful way to explicitly
    specify a version and exclude a particular version from the transitive dependency.
    In this example, we will upgrade our dependency on Apache Commons IO to 2.14.0
    from 1.4 to use framework A.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们对其他框架没有问题，我们仍然需要确保版本兼容。例如，框架A可能使用了Apache Commons IO库，版本2.14.0，而我们的项目目前使用的是1.4。将框架A导入我们的项目会将版本2.14.0作为一个依赖项引入项目。幸运的是，构建框架如Gradle和Maven提供了一种优雅的方式来显式指定版本并排除特定的版本从传递依赖中。在这个例子中，我们将升级我们对Apache
    Commons IO的依赖，从1.4升级到2.14.0以使用框架A。
- en: Building instead of choosing a framework
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立而不是选择框架
- en: Engineers might want to build their own framework instead of choosing an existing
    one. Under certain conditions, this could be beneficial.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师可能想要构建自己的框架而不是选择现有的框架。在特定条件下，这样做可能是有益的。
- en: If the software has unique requirements that cannot be met by existing frameworks,
    then it would justify building a bespoke framework. It could be a very specific
    domain, or it could have very strict non-functional requirements. For instance,
    engineers for **High-Frequency Trading** (**HFT**) software might write their
    own framework to meet ultra-low-latency requirements.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件有现有框架无法满足的独特需求，那么构建定制的框架就是合理的。这可能是一个非常具体的领域，或者它可能有非常严格的非功能性需求。例如，**高频交易**（**HFT**）软件的工程师可能编写自己的框架以满足超低延迟的要求。
- en: Building a bespoke proprietary framework might also be justified if the organization
    treats it as a competitive advantage in the market with cutting-edge technology.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组织将其视为具有尖端技术的市场竞争优势，那么构建定制的专有框架也可能是合理的。
- en: It may also be the start of a new open-sourced framework in the community if
    no such framework has existed before. In this case, it may be beneficial to gather
    engineering talents among the communities and collaborate.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前社区中不存在这样的框架，这也可能是社区中一个新的开源框架的开始。在这种情况下，从社区中聚集工程人才并合作可能是有益的。
- en: What if we made the wrong choice?
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果我们做出了错误的选择怎么办？
- en: Despite all our best efforts, we might still have chosen the wrong framework.
    The framework may not have delivered the intended behaviors. The contributors
    may have given up on the project. The framework may have taken a novel approach
    that no longer suits our needs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尽了最大努力，我们可能仍然选择了错误的框架。该框架可能没有实现预期的行为。贡献者可能已经放弃了这个项目。该框架可能采取了一种不再适合我们需求的新颖方法。
- en: The adoption of the wrong framework becomes technical debt. Unfortunately, we
    need to source a replacement framework and plan the refactoring works to remove
    this dependency.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 错误框架的采用变成了技术债务。不幸的是，我们需要寻找替代框架并计划重构工作以消除这种依赖。
- en: The technique of refactoring is beyond the scope of this book, though. And it
    is not always possible to avoid choosing the wrong framework. All we can do is
    exercise our due diligence in the process of decision. If appropriate, we can
    also create interfaces so that only minimal classes in the code base have direct
    reference to the framework, while the framework usage to the rest of the code
    base is transparent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管重构技术超出了本书的范围，但并非总是可以避免选择错误的框架。我们所能做的就是在这个过程中进行尽职调查。如果适当的话，我们还可以创建接口，以便只有代码库中的最小类直接引用框架，而框架对其他代码库的使用是透明的。
- en: Documentation and diagrams
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档和图表
- en: Software architecture as a blueprint of the system is captured in documentation
    and diagrams. Some of them could be captured in configuration files and templates,
    but when software architects need to present the system or communicate with stakeholders,
    documentation and diagrams are still the most used formats. Some of these diagrams
    will be used in upcoming chapters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构作为系统的蓝图，在文档和图表中得到了体现。其中一些可能被记录在配置文件和模板中，但当软件架构师需要展示系统或与利益相关者沟通时，文档和图表仍然是使用最广泛的格式。其中一些图表将在接下来的章节中使用。
- en: Business Process Model and Notation
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务流程模型与符号
- en: Software systems, at a high level, can be seen as automated business processes
    that can be visualized in diagrams. **Business Process Model and Notation** (**BPMN**)
    standardizes graphical notations and provides a common language for modeling business
    processes. It is commonly used among engineers and stakeholders for communication
    and documentation purposes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统在高级别上可以看作是自动化的业务流程，这些流程可以通过图表进行可视化。**业务流程模型与符号**（**BPMN**）标准化了图形符号，并为建模业务流程提供了一个共同的语言。它通常被工程师和利益相关者用于沟通和文档目的。
- en: 'Taking the example of two households coming to a mutual agreement on the contract
    of services they exchange (the *service contract*), the business process could
    be modeled as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以两个家庭就他们交换的服务合同达成协议的例子（*服务合同*），业务流程可以建模如下：
- en: '![Figure 1.3 – Example of a BPMN diagram](img/1.3.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – BPMN图例](img/1.3.jpg)'
- en: Figure 1.3 – Example of a BPMN diagram
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – BPMN图例
- en: '**Household A** and **Household B** have their own swimlanes to illustrate
    the process on each side. **Household A** submits a draft of the service contract
    and **Household B** receives it. **Household B** reviews the draft and submits
    its decision. If **Household B** rejects the service contract, then both processes
    at **Household A** and **Household B** end. Otherwise, **Household B** waits for
    **Household A**’s response; meanwhile, **Household A** records the service contract,
    and the process ends. Finally, **Household B** receives the service contract from
    **Household A** and records the service contract, and the process ends.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**家庭A**和**家庭B**有自己的游泳道来展示各自的过程。**家庭A**提交服务合同的草案，**家庭B**接收它。**家庭B**审查草案并提交其决定。如果**家庭B**拒绝服务合同，那么**家庭A**和**家庭B**的流程都将结束。否则，**家庭B**等待**家庭A**的回应；同时，**家庭A**记录服务合同，流程结束。最后，**家庭B**从**家庭A**那里收到服务合同并记录服务合同，流程结束。'
- en: BPMN has a rich collection of notations to describe business processes. They
    can be categorized into four groups.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: BPMN拥有丰富的符号集合来描述业务流程。它们可以分为四组。
- en: Flow objects – activities, events, and gateways
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流对象——活动、事件和网关
- en: '**Activities** can be tasks and sub-processes that happen in the business process.
    **Events** are outcomes that have happened. **Gateways** are the points where
    a decision is made or the process splits into branches.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动**可以是业务流程中发生的任务和子流程。**事件**是已经发生的结果。**网关**是做出决策或流程分支的点。'
- en: Connecting objects – sequences and associations
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接对象——序列和关联
- en: '**Sequences** illustrate the flow of control and the messages communicated
    among flow objects. **Associations** describe the relationship among objects,
    such as inputs, outputs, or dependencies.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列**展示了控制流的流程以及流程对象之间的消息传递。**关联**描述了对象之间的关系，例如输入、输出或依赖关系。'
- en: Swimlanes
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游泳道
- en: '**Swimlanes** are the groupings of flow and connecting objects based on the
    roles and responsibilities of participants involved in the business process.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**游泳道**是根据参与业务流程的参与者的角色和责任对流程和连接对象进行分组。'
- en: Artifacts
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 艺术品
- en: '**Artifacts** are additional information to the diagrams, and they provide
    context such as the data objects involved or simply free-text annotations.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**艺术品**是图表的附加信息，它们提供了上下文，例如涉及的数据对象或简单的自由文本注释。'
- en: Architecture decision record
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构决策记录
- en: Software architecture can be seen as a journey from problem discovery to solution
    implementation. Along the journey, there are a lot of decisions made to move the
    system forward. An **Architecture Decision Record** (**ADR**) is a document that
    captures the decision made based on the context at that time and the consequences
    coming with it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构可以看作是从问题发现到解决方案实施的过程。在这个过程中，会做出许多决策以推动系统前进。**架构决策记录**（**ADR**）是一份文档，它记录了基于当时情境所做的决策及其带来的后果。
- en: There are many ADR templates available on the internet, which conceptually cover
    the following sections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多ADR模板，从概念上讲，涵盖了以下部分。
- en: Status
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态
- en: 'This is typically just a single word to describe the current state of the ADR
    in the process. Here is an example of the ADR process:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常只是一个单词，用来描述过程中ADR（抽象设计请求）的当前状态。以下是一个ADR过程的示例：
- en: '![Figure 1.4 – An example of the ADR process](img/1.4.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – ADR过程的示例](img/1.4.jpg)'
- en: Figure 1.4 – An example of the ADR process
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – ADR过程的示例
- en: The basic possible states are **Proposed**, **Accepted**, and **Rejected**.
    In this example, there are other states, such as **Under Review** and **Changes
    Required**. It varies from one organization to another.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基本可能的状态是**提议的**、**接受的**和**拒绝的**。在这个例子中，还有其他状态，例如**正在审查**和**需要更改**。这因组织而异。
- en: Context
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景
- en: This section should introduce the background where the discussions started.
    A good introduction would bring the needs of the change to the current situation
    e.g., pain points of the current operations, organization restructuring, business
    expansion, etc.).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节应介绍讨论开始的背景。一个好的介绍会将更改的需求带到当前情况，例如，当前运营的痛点、组织结构调整、业务扩张等）。
- en: It also introduces the terms that are used throughout the discussion so they
    can be easily referred to without ambiguity. A bit of the current organizational
    structure and technical infrastructure would also be helpful.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它还介绍了讨论中使用的术语，以便可以轻松引用而不会产生歧义。一些当前的组织结构和技术基础设施的信息也会有所帮助。
- en: If applicable, this section can mention the current system quality attributes
    and why we want to change them. For instance, if our system can only handle 100
    concurrent logins and the company wants to support 10,000 in the new technical
    design, then scalability is the system attribute this ADR proposes to change.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适用，本节可以提及当前系统的质量属性以及我们为什么要更改它们。例如，如果我们的系统只能处理100个并发登录，而公司希望在新的技术设计中支持10,000个，那么可扩展性就是本ADR提议要更改的系统属性。
- en: It should also mention the desired outcomes. This sets up a target state we
    want our change to achieve. The motivation here should refer to the problems mentioned
    previously and elaborate on how the outcome could improve business results.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它还应提及期望的结果。这设定了我们希望我们的更改实现的目标状态。这里的动机应参考之前提到的问题，并详细说明结果如何改善业务成果。
- en: Decision
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决策
- en: This section describes the proposed change in detail. It should focus on how
    the change would produce the desired outcome described in the previous section.
    It may also mention the concerns raised and how the decision was driven by the
    discussion.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细描述了提议的更改。它应侧重于更改如何产生上一节中描述的期望结果。它还可以提及提出的问题以及决策是如何由讨论驱动的。
- en: In some cases, alternative changes are mentioned. If they are mentioned, there
    should be a comparison between the proposed change and the alternatives. One way
    to compare is to list the pros and cons of each option. Another way could be to
    compare each option against a list of factors and conclude why an option is proposed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，会提到替代更改。如果提到了，应该对提议的更改和替代方案进行比较。一种比较的方法是列出每个选项的优缺点。另一种方法可能是将每个选项与一系列因素进行比较，并得出为什么提出该选项的结论。
- en: Consequences
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后果
- en: This section describes the impact of choosing the proposed change. Does it change
    the way the team operates? Which system attribute would it change and how? Does
    it optimize one aspect of the system but sacrifice another aspect? Which part
    of the system may become obsolete?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了选择提议的更改的影响。它是否改变了团队的操作方式？它会改变哪个系统属性以及如何改变？它是否优化了系统的一个方面但牺牲了另一个方面？系统的哪个部分可能会变得过时？
- en: Request for Comments
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评论请求
- en: '**Request for Comments** (**RFC**) is a series of documents in which standards,
    protocols, procedures, and guidelines are proposed, discussed, agreed, and defined.
    **Internet Engineering Task Force** (**IETF**), a **standard development organization**
    (**SDO**), defined the numerous significant standards for the internet via the
    RFC processes, such as **Internet Protocol** (**IP**) version 4 (RFC 791) and
    6 (RFC 2460), and **Hypertext Transfer Protocol** (**HTTP**) version 1.1 (RFC
    2616).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**评论请求**（**RFC**）是一系列文档，其中提出了标准、协议、程序和指南，进行了讨论、达成一致并定义。**互联网工程任务组**（**IETF**），一个**标准开发组织**（**SDO**），通过RFC流程定义了众多对互联网具有重大意义的标准，例如**互联网协议**（**IP**）版本4（RFC
    791）和6（RFC 2460），以及**超文本传输协议**（**HTTP**）版本1.1（RFC 2616）。'
- en: RFCs can be submitted by anyone, and anyone is allowed to comment on existing
    RFCs. They go through an iterative review and feedback process in an open and
    transparent manner. They are usually initiated by subject experts but are maintained
    by the wider community. The outcome of an RFC can be standards and protocols adopted
    by the industry, which are useful for framework extension, further research, or
    the basis for the next RFC.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以提交RFC，任何人都可以对现有的RFC进行评论。它们以公开和透明的方式经过迭代审查和反馈过程。它们通常由主题专家发起，但由更广泛的社区维护。RFC的结果可能是被行业采纳的标准和协议，这对于框架扩展、进一步研究或作为下一个RFC的基础都是有用的。
- en: The format of an RFC document varies among organizations. In general, the document
    should cover the following sections.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: RFC文档的格式在不同组织之间有所不同。一般来说，文档应涵盖以下部分。
- en: Status
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态
- en: 'There are several possible statuses: **Drafted**, **Collecting Feedback**,
    **Accepted**, **Rejected**, and **Abandoned**.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种可能的状态：**草稿**、**收集反馈**、**接受**、**拒绝**和**废弃**。
- en: '![Figure 1.5 – An example of the RFC process](img/1.5.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – RFC流程的示例](img/1.5.jpg)'
- en: Figure 1.5 – An example of the RFC process
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – RFC流程的示例
- en: Once an RFC is drafted, it goes through a review and feedback iterative process.
    The RFC exits the iteration when it is either accepted, rejected, or abandoned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦RFC被起草，它将经过审查和反馈的迭代过程。RFC在以下情况下退出迭代：被接受、拒绝或废弃。
- en: Context
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景
- en: This section explains the need to submit this RFC. An example may be presented
    to illustrate the need for standardization or the problems caused by the lack
    of consistent protocols.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释提交此RFC的需要。可以提供一个示例来说明标准化的需要或缺乏一致协议引起的问题。
- en: Approach
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: This section explains the approach agreed with the community after the review-feedback
    process. It should be as detailed as possible to capture the consensus of the
    approach.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释在审查反馈过程之后与社区达成一致的方法。它应该尽可能详细，以捕捉方法的一致意见。
- en: Pros and cons
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: The benefits and drawbacks of the approach should be covered in detail so that
    it is clear to the community whether there should be another round of feedback
    collection, or at least the community is informed about the consequences of the
    approach.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 应该详细说明该方法的优点和缺点，以便社区清楚是否应该进行另一轮反馈收集，或者至少让社区了解该方法的后果。
- en: Alternatives
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方案
- en: This section mentions any alternative approach that was considered and discussed,
    but not adopted.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提及了任何考虑过和讨论过但未采纳的替代方法。
- en: References
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: This section includes any previous RFCs mentioned, an academic paper, or any
    additional materials that give more context to the discussion.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括任何提到的先前RFC、学术论文或任何其他提供更多讨论背景的材料。
- en: Update log
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新日志
- en: As an RFC is likely to result in a lengthy review-feedback process, an update
    log is useful in keeping each meaningful change of the RFC in chronological order.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RFC可能引发漫长的审查反馈过程，更新日志有助于按时间顺序记录RFC的每个有意义的变化。
- en: RFC and ADR
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RFC和ADR
- en: RFC and ADR share many similarities in their document formats, but they are
    also different in terms of usage. RFC focuses on industry standards and protocols
    among large communities, while ADR focuses on conventions within an organization.
    RFC tends to be closer to best practices, while ADR tends to be closer to solutions
    and code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: RFC和ADR在文档格式上有很多相似之处，但在使用方面也存在差异。RFC侧重于大型社区中的行业标准和协议，而ADR侧重于组织内部的惯例。RFC倾向于接近最佳实践，而ADR则倾向于接近解决方案和代码。
- en: Despite the difference, RFC and ADR can work in collaboration. For topics that
    require consensus, expect long discussion, or have significant impacts, an RFC
    can be written first to come to an agreement on the approach. Then, an ADR can
    be written as a record of the decision and as a detailed technical specification
    of the approach.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在差异，RFC和ADR可以协作工作。对于需要达成共识、预期将进行长时间讨论或具有重大影响的话题，可以先编写RFC来就方法达成一致。然后，可以编写ADR作为决策的记录和方法的详细技术规范。
- en: UML diagrams
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UML图
- en: '**Unified Modeling Language** (**UML**) is a software modeling language standardized
    from different modeling languages and notations since 1994\. UML 1.0 was adopted
    as a standard by an international standards consortium called the **Object Management
    Group** (**OMG**) in 1997.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一建模语言**（**UML**）自1994年以来从不同的建模语言和符号中标准化而来。UML 1.0于1997年被一个名为**对象管理组**（**OMG**）的国际标准联盟采纳为标准。'
- en: UML has a diverse collection of well-defined software elements that can form
    various diagrams that help engineers model business problems in a structural and
    visual manner. There are 14 UML diagrams, grouped into two categories.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: UML 拥有一系列定义良好的软件元素，可以形成各种图表，帮助工程师以结构和视觉方式建模业务问题。共有 14 种 UML 图表，分为两大类。
- en: Structural diagrams
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构图
- en: 'Structural diagrams represent the static structure of a system. They focus
    on elements such as classes, objects, components, and packages. They emphasize
    how these elements are organized and connected with each other in a system. The
    following diagram is an example of a class diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 结构图表示系统的静态结构。它们关注诸如类、对象、组件和包等元素。它们强调这些元素在系统中的组织和相互连接方式。以下是一个类图的示例：
- en: '![Figure 1.6 – An example of a UML class diagram](img/1.6.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – UML 类图的示例](img/1.6.jpg)'
- en: Figure 1.6 – An example of a UML class diagram
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – UML 类图的示例
- en: 'A class diagram usually contains classes and interfaces. Each class can contain
    a few attributes and a few functions. For example, the `ServiceContract` class
    has three attributes: `agreedDate`, `received`, and `provided`. The class also
    has one function, `isContractConcluded`, that returns a `boolean` value. The `received`
    and `provided` fields of the `ServiceContract` class references the other class,
    `Service`. We could say the multiplicity of the `ServiceContract` class to the
    `Service` class is one-to-two, as depicted in the diagram.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类图通常包含类和接口。每个类可以包含一些属性和一些函数。例如，`ServiceContract` 类有三个属性：`agreedDate`、`received`
    和 `provided`。该类还有一个函数 `isContractConcluded`，返回一个 `boolean` 值。`ServiceContract`
    类的 `received` 和 `provided` 字段引用了另一个类 `Service`。我们可以说 `ServiceContract` 类到 `Service`
    类的多重性是一对二，如图所示。
- en: 'From the business perspective, a `ServiceContract` class is a contract of exchanged
    services modeled as two instances of the `Service` class: one is a `received`
    service and the other is a `provided` service. If the contract is mutually agreed,
    then the `agreedDate` field should capture the time when it was agreed.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从业务角度来看，`ServiceContract` 类是作为 `Service` 类的两个实例建模的服务交换合同：一个是“接收”服务，另一个是“提供”服务。如果合同是双方同意的，那么
    `agreedDate` 字段应该记录合同达成的时间。
- en: 'There are seven UML structural diagrams, and there is a specific use for each,
    depending on which element is under the spotlight:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有七个 UML 结构图，每个图都有特定的用途，具体取决于关注的元素：
- en: '**Class diagrams**, as illustrated, depict the static structure of classes,
    and their attributes, functions, and relationships with other classes.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类图**，如图所示，描述了类的静态结构，以及它们的属性、函数和与其他类的关联。'
- en: '**Object diagrams** visualize the instances of classes and their relationships
    at a point in time, usually from a real-life example, to represent a snapshot
    of the system runtime structure.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象图**可视化类在某一时间点的实例及其关系，通常从一个现实生活中的例子出发，以表示系统运行时结构的快照。'
- en: '**Package diagrams** show how classes and components are organized into packages
    and the relationship among packages.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包图**显示了类和组件如何组织到包中，以及包之间的关系。'
- en: '**Component diagrams** represent the high-level logical or physical components
    that make up a system and their relationships.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件图**表示构成系统的较高层次的逻辑或物理组件及其关系。'
- en: '**Deployment diagrams** depict the software components physically deployed
    to hardware infrastructure and their connections to other physical nodes.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署图**描述了软件组件在硬件基础设施上的物理部署以及它们与其他物理节点之间的连接。'
- en: '**Composite structure diagrams** describe the internal structure of a class
    or a component, with a focus on how the internal fields and functions collaborate.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合结构图**描述了一个类或组件的内部结构，重点关注内部字段和函数之间的协作。'
- en: '**Profile diagrams** are extensible and customized diagrams that combine other
    UML diagrams. They facilitate UML language being extended to be domain-specific.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件图**是可扩展和自定义的图表，它结合了其他 UML 图表。它们促进了 UML 语言扩展到特定领域。'
- en: Behavioral diagrams
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行为图
- en: 'Behavioral diagrams represent the dynamic interactions of a system. They include
    elements such as actors, messages, activities, states, and transitions. The key
    focus in these diagrams is how the system’s behavior emerges from the flow of
    control, interactions, or state transitions. The following is an example of a
    state diagram:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 行为图表示系统的动态交互。它们包括参与者、消息、活动、状态和转换等元素。这些图的关键重点是系统行为如何从控制流、交互或状态转换中产生。以下是一个状态图的示例：
- en: ','
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: '![Figure 1.7 – Example of a UML state machine diagram](img/1.7.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – UML状态机图的示例](img/1.7.jpg)'
- en: Figure 1.7 – Example of a UML state machine diagram
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – UML状态机图的示例
- en: This state machine diagram describes the life cycle of a service contract between
    two households. It begins with the submission of a service contract drafted by
    one household. Then, while the service contract is under review, the service contract
    can be amended by either household, until it is either rejected or mutually agreed.
    Afterward, the service contract may still be withdrawn. Otherwise, the households
    involved exercise the services in the contract until both services are exercised
    and the service contract reaches the end of the life cycle.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此状态机图描述了两个家庭之间服务合同的生命周期。它始于一个家庭起草的服务合同的提交。然后，在服务合同处于审查期间，任一家族都可以修改服务合同，直到它被拒绝或双方同意。之后，服务合同仍然可以被撤回。否则，涉及的家族将行使合同中的服务，直到双方都行使了服务，服务合同达到生命周期的终点。
- en: 'There are seven UML behavioral diagrams. It is technically possible to use
    any of them to describe the same system behavior. The difference is the aspect
    of the behaviors shown in the diagram:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有七个UML行为图。技术上可以使用它们中的任何一个来描述相同系统的行为。区别在于图中展示的行为方面：
- en: '**State machine diagrams**, as visualized, model how the system responds differently
    in each state and how the state transitions from one to another.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态机图**，如图所示，模型化系统在每个状态下的不同响应以及状态如何从一个转换到另一个。'
- en: '**Communication diagrams**, also known as **collaboration diagrams**, emphasize
    the messages exchanged between objects or components.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信图**，也称为**协作图**，强调对象或组件之间交换的消息。'
- en: '**Activity diagrams** represent a business or operational workflow of a component
    in a system as a sequence.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动图**表示系统组件中的业务或操作流程作为序列。'
- en: '**Interaction overview diagrams** represent a business or operational workflow
    of a component in a system, with a focus on interactions among components in a
    system.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互概览图**表示系统组件中的业务或操作流程，重点关注系统组件之间的交互。'
- en: '**Sequence diagrams** visualize the messages exchanged between objects and
    components in chronological order.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列图**按时间顺序可视化对象和组件之间交换的消息。'
- en: '**Timing diagrams** visualize the messages exchanged between objects and components
    within a period with a focus on time constraints and the ordering of events.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时序图**在一个时间段内可视化对象和组件之间交换的消息，重点关注时间约束和事件排序。'
- en: '**Use case diagrams** capture the interactions between actors and the system.
    Actors can be users or external systems, so actors can achieve their goals through
    the functions of the system.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例图**捕捉了参与者与系统之间的交互。参与者可以是用户或外部系统，因此参与者可以通过系统的功能来实现他们的目标。'
- en: The C4 model
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C4模型
- en: '**The C4 model** is a visual modeling approach developed in the 2010s. This
    approach originated from the observation that many software architecture diagrams
    were either lacking details (too high level) or overwhelmed with details (too
    low level). This approach aims to provide a set of guidelines and conventions
    to document architectures at the right level of abstraction.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**C4模型**是在2010年代开发的一种视觉建模方法。这种方法源于观察许多软件架构图要么缺乏细节（过于高级）要么细节过多（过于低级）。这种方法旨在提供一套指南和约定，以在适当的抽象级别上记录架构。'
- en: It gained popularity over time among software architects and engineers who wanted
    a simple and effective way to document their systems. The **Structurizr** tool
    was developed by the C4 model creator, Simon Brown, to allow the creation of architecture
    models as code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，它在希望以简单有效的方式记录其系统的软件架构师和工程师中获得了流行。**Structurizr**工具由C4模型创建者Simon Brown开发，允许以代码的形式创建架构模型。
- en: 'The C4 model can be described using the metaphor of maps: from a street view,
    where we could see pedestrians and cars on the roads, then zoom out to see a city
    map of how the main roads are connected in the city, then zoom out to see a country
    map, where we see the main cities and towns of the country, then to the world
    map, where we see the Earth.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: C4 模型可以用地图的隐喻来描述：从街景视图，我们可以看到道路上的行人和汽车，然后放大到看到城市地图，了解城市中主要道路的连接，然后放大到看到国家地图，我们看到国家的主要城市和城镇，然后到世界地图，我们看到地球。
- en: The C4 model has four levels of abstraction. Each level helps different people
    to communicate and collaborate with the subject in question highlighted. It is
    helpful to bring up the right diagram in a meeting or workshop to start a conversation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: C4 模型有四个抽象级别。每个级别帮助不同的人与所讨论的主题进行沟通和协作，突出显示的主题。在会议或研讨会上提出正确的图示以开始对话是有帮助的。
- en: Level 1 – System context diagram
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别 1 – 系统上下文图
- en: The **system context diagram** is the “big picture” diagram, and the major focus
    is the “system.” The diagram should be centered around the system, and it interacts
    with actors, business operations, and external systems. This diagram is particularly
    useful for communication with non-technical stakeholders and external organizations.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统上下文图**是“整体图”，主要关注“系统”。该图应围绕系统中心，并与参与者、业务操作和外部系统交互。此图对于与非技术利益相关者和外部组织的沟通特别有用。'
- en: '![Figure 1.8 – An example of a system context diagram (C4 level 1)](img/1.8.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 系统上下文图示例（C4 级别 1）](img/1.8.jpg)'
- en: Figure 1.8 – An example of a system context diagram (C4 level 1)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 系统上下文图示例（C4 级别 1）
- en: The Community Service Exchange software is a standalone software installed as
    an isolated copy in each household. The copies of the software do not communicate
    with each other.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 社区服务交换软件是作为每个家庭中独立副本安装的独立软件。软件的副本之间不相互通信。
- en: Level 2 – Container diagram
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别 2 – 容器图
- en: The **container diagram** zooms in on the “system” and focuses on how multiple
    containers inside the system work together. Each container here refers to a deployable
    process and has its own role, responsibility, and boundary in the system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器图**聚焦于“系统”，关注系统内部多个容器如何协同工作。这里的每个容器都指一个可部署的过程，并在系统中拥有自己的角色、责任和边界。'
- en: The container diagram can also be used to illustrate any middleware or infrastructure
    used in the system, such as messaging brokers, data stores, or filesystems.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 容器图也可以用来说明系统使用的任何中间件或基础设施，例如消息代理、数据存储或文件系统。
- en: This diagram is useful for communication with technical stakeholders such as
    platform engineers, database administrators, network engineers, or security engineers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此图对于与平台工程师、数据库管理员、网络工程师或安全工程师等技术利益相关者的沟通很有用。
- en: '![Figure 1.9 – An example of a container diagram (C4 level 2)](img/1.9.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 容器图示例（C4 级别 2）](img/1.9.jpg)'
- en: Figure 1.9 – An example of a container diagram (C4 level 2)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 容器图示例（C4 级别 2）
- en: The Community Service Exchange software contains a module to organize all the
    static content such as images and fonts. There is an application module to validate
    data and run checks. The application module uses the relational database to persist
    the data required. The application module also retrieves report data from the
    relational database and exports it to the filesystem. The household can read the
    report file from the filesystem.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 社区服务交换软件包含一个模块来组织所有静态内容，如图像和字体。有一个应用程序模块来验证数据和运行检查。应用程序模块使用关系数据库来持久化所需数据。应用程序模块还从关系数据库检索报告数据并将其导出到文件系统。家庭可以从文件系统中读取报告文件。
- en: Level 3 – Component diagram
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别 3 – 组件图
- en: The **component diagram** zooms in a container and provides a view of how different
    components constitute a container.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件图**聚焦于容器，提供了不同组件如何构成容器的视图。'
- en: It describes the input to the component (e.g., REST endpoints, message consumers,
    or a scheduler) and the output from the component (e.g., events, response to a
    request, etc.).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 它描述了组件的输入（例如，REST 端点、消息消费者或调度器）和组件的输出（例如，事件、对请求的响应等）。
- en: Another important function of this diagram is to demonstrate the logical packages
    inside the container that serve business operations. They typically load, transform,
    combine, and compute functions on multiple representations of entities modeled
    for the business purpose.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此图的另一个重要功能是展示容器内用于业务操作的逻辑包。它们通常在为业务目的建模的实体多个表示形式上加载、转换、组合和计算功能。
- en: This diagram is closer to the software engineers, so they understand the context
    where they write code and scripts.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此图更接近软件工程师，因此他们可以理解他们编写代码和脚本的上下文。
- en: '![Figure 1.10 – An example of a component diagram (C4 level 3)](img/1.10.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 组件图示例（C4 级别 3）](img/1.10.jpg)'
- en: Figure 1.10 – An example of a component diagram (C4 level 3)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 组件图示例（C4 级别 3）
- en: The application module of the Community Service Exchange software has a service
    exchange controller that operates a service contract (the “contract”) between
    two households. It is business logic that manages the life cycle of a contract
    from the beginning till the end. It passes the contracts to the service exchange
    repository for persistence logic such as translating the contract entities into
    database tables and columns.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 社区服务交换软件的应用模块有一个服务交换控制器，它操作两个家庭之间的服务合同（即“合同”）。这是从开始到结束管理合同生命周期的业务逻辑。它将合同传递到服务交换存储库，以进行持久化逻辑，例如将合同实体转换为数据库表和列。
- en: On the other hand, the file export controller serves a request from the household
    to generate a report of the contracts the household was involved in. The file
    export controller validates the request and generates the file ready to be available
    in the filesystem, which is outside of this application module. There is part
    of the statistical data on the contracts, and the calculations are done by the
    service statistic calculator.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，文件导出控制器响应家庭生成其参与合同的报告的请求。文件导出控制器验证请求并生成文件，使其可在文件系统中可用，而该文件系统位于此应用模块之外。合同部分包含统计数据，计算由服务统计计算器完成。
- en: Level 4 – Code diagram
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别 4 – 代码图
- en: Finally, we come to the lowest level of abstraction – the **code diagram**.
    This is a microscopic view of a component for engineers to understand the design
    patterns used, and how source code is represented in an abstract view in relation
    to other source files.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了抽象层次最低的一层——**代码图**。这是工程师理解所使用的设计模式和源代码如何在抽象视图中相对于其他源文件表示的微观视图。
- en: We could describe the entities modeled in the component and the relationship
    among them. That can be translated into a relational database schema.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以描述组件中建模的实体及其之间的关系。这可以转换为关系数据库模式。
- en: We could be describing a process that involves multiple classes in the object-oriented
    style. We could demonstrate the fields captured in each class and how classes
    interact with each other.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以描述一个涉及多个类的面向对象风格的过程。我们可以展示每个类中捕获的字段以及类如何相互交互。
- en: It is not mandatory to have a code diagram for every part of the system because
    simple logic can be expressed directly in the source code. Typically, code diagrams
    are used to capture more complex interactions so engineers can be mindful when
    they are coding. This is also where you will see UML diagrams.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 并非系统每个部分都必须有代码图，因为简单的逻辑可以直接在源代码中表达。通常，代码图用于捕获更复杂的交互，以便工程师在编码时能够留心。这也是您会看到 UML
    图的地方。
- en: '![Figure 1.11 – An example of a code diagram (C4 level 4)](img/1.11.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 代码图示例（C4 级别 4）](img/1.11.jpg)'
- en: Figure 1.11 – An example of a code diagram (C4 level 4)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 代码图示例（C4 级别 4）
- en: Inside `ServiceExchangeController`, there is a data class called `Household`
    that contains a list of `HouseholdMember` objects. The `HouseholdMember` data
    class models a household member who has the skills to execute a contract.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ServiceExchangeController` 中，有一个名为 `Household` 的数据类，它包含一个 `HouseholdMember`
    对象的列表。`HouseholdMember` 数据类模拟了一个具有执行合同技能的家庭成员。
- en: There is a `Service` class that captures the execution details of a contract
    from a household. It provides an `isExecuted` function that returns a Boolean
    value of `true` if its `executedBy` and `executedAt` fields are both not null.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `Service` 类，它捕获家庭执行合同的执行细节。它提供了一个 `isExecuted` 函数，如果其 `executedBy` 和 `executedAt`
    字段都不为空，则返回 `true` 的布尔值。
- en: The `ServiceContract` class models a service contract between two `Service`
    objects. It captures the date when the contract was agreed by both households.
    The receiver and the provider of the contract is a `Service` object. It provides
    an `isContractConcluded` function that returns a Boolean value of `true` if the
    result of the `isExecuted` function from both objects returns `true`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceContract` 类模拟了两个 `Service` 对象之间的服务合同。它记录了双方家庭达成合同的具体日期。合同的接收者和提供者都是一个
    `Service` 对象。它提供了一个 `isContractConcluded` 函数，如果两个对象的 `isExecuted` 函数的结果都返回 `true`，则该函数返回一个布尔值
    `true`。'
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered the importance of software architecture with a real-world example.
    We discussed how software architecture plays a role in communication, training,
    budgeting, defining visions, and addressing cross-cutting concerns in the technology
    ecosystems.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个现实世界的例子阐述了软件架构的重要性。我们讨论了软件架构在沟通、培训、预算、定义愿景以及在技术生态系统中解决跨领域关注点中的作用。
- en: We have discussed Conway’s law and how the structure of an organization affects
    the architecture of systems.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了康威定律以及组织的结构如何影响系统架构。
- en: We have navigated the topic of choosing a software framework in multiple scenarios
    with pros and cons.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在多个场景中探讨了选择软件框架的话题，并分析了其优缺点。
- en: We have also covered the documentation and diagrams that are often used in software
    architecture, such as ADRs, RFC, UML diagrams, and the C4 model.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了在软件架构中经常使用的文档和图表，例如 ADRs、RFC、UML 图和 C4 模型。
- en: In the next chapter, we will introduce some fundamental architectural principles
    that drive modern software architecture. We will break down and combine multiple
    concepts and illustrate them with the same real-world example.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些推动现代软件架构的基本架构原则。我们将分解和组合多个概念，并通过相同的现实世界例子进行说明。
