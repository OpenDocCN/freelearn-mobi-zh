<html><head></head><body><div><div><div><h1 id="_idParaDest-83" class="chapter-number"><a id="_idTextAnchor092"/>7</h1>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor093"/>Navigating within Your App</h1>
			<p>The apps we make need to move from one screen to the other, showing different content on these screens. So far, we have been making apps with only one screen. In this chapter, we will learn how to move from one screen to the other. We will learn how to use the <strong class="bold">Jetpack Compose Navigation</strong> library to navigate to different Jetpack Compose screens within our app. We will learn the tips and best practices for using this library. Also, we will cover how to pass arguments as we navigate to screens. Lastly, we will build on what we learned in <a href="B19779_04.xhtml#_idTextAnchor055"><em class="italic">Chapter 4</em></a>, by handling navigation on large screens and foldables.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Jetpack Navigation overview</li>
				<li>Navigating to Compose destinations</li>
				<li>Passing arguments to destinations</li>
				<li>Navigation in foldables and large screens</li>
			</ul>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven</a>.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor095"/>Jetpack Navigation overview</h1>
			<p>The Jetpack Navigation library <a id="_idIndexMarker300"/>provides an API for handling <strong class="bold">complex navigation</strong> with ease while also following the principles of Android Jetpack. The library is available for both the old view system, which uses XML (<a href="https://developer.android.com/guide/navigation">https://developer.android.com/guide/navigation</a>), and Jetpack Compose (<a href="https://developer.android.com/jetpack/compose/navigation">https://developer.android.com/jetpack/compose/navigation</a>). We will be learning about the latter in this chapter.</p>
			<p>Still building on<a id="_idIndexMarker301"/> the Pets app we used in the previous chapter, we are going to navigate to a details screen that has a back button to the previous screen. We will also be passing data to the details screen.</p>
			<p>To start with, we need to add the Jetpack Navigation Compose dependency to our project. Let’s add the following library inside the <code>versions</code> section in our <code>libs.versions.toml</code> file:</p>
			<pre class="source-code">
compose-navigation = "androidx.navigation:navigation-compose:2.7.2"</pre>			<p>Next, we need to add the dependency to our app module’s <code>build.gradle.kts</code> file:</p>
			<pre class="source-code">
implementation(libs.compose.navigation)</pre>			<p>Do a Gradle sync to add the library to our project. The next step is to create <code>NavController</code> and <code>NavHost</code>. <code>NavController</code> is a class that manages app navigation within <code>NavHost</code>. <code>NavHost</code> is a container that hosts composables and handles navigation between them. Let’s create a new package called <code>navigation</code> and create a new sealed class called <code>Screens.kt</code>. Inside the file, let us add the following code:</p>
			<pre class="source-code">
sealed class Screens(val route: String) {
    object PetsScreen : Screens("pets")
    object PetDetailsScreen : Screens("petDetails")
}</pre>			<p>This is a sealed class that has two objects. A <a id="_idIndexMarker302"/>sealed class is used to represent restricted class hierarchies wherein the object or value can only have a value among one of the types defined in the sealed class. The first object is <code>PetsScreen</code>, which will be the first screen we will see when we launch the app. The second object is <code>PetDetailsScreen</code>, which will be the screen we will navigate to when we click on a pet item in <code>PetsScreen</code>. Every time we need to add a new destination screen, we will add a new object to the sealed class.</p>
			<p>Next, let us <a id="_idIndexMarker303"/>create a new file inside the <code>navigation</code> package called <code>AppNavigation.kt</code>. Inside the file, let us add the following code:</p>
			<pre class="source-code">
@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        startDestination =  Screens.PetsScreen.route
    ){
        composable(Screens.PetsScreen.route){
            PetsScreen()
        }
    }
}</pre>			<p>Let’s explain the preceding code:</p>
			<ul>
				<li>We create <code>NavController</code> using the <code>rememberNavController()</code> function. This function is used to create <code>NavController</code> that will be remembered across recompositions. This is important because we need to be able to navigate to different screens in our app.</li>
				<li>We create a <code>NavHost</code> composable that takes in <code>navController</code> and <code>startDestination</code>. <code>startDestination</code> is the first screen we want to see when we launch the app. In our case, it is <code>PetsScreen</code>.</li>
				<li>We add the <code>PetsScreen</code> composable. This composable has an error because we have <a id="_idIndexMarker304"/>not created it yet. We will do that shortly.</li>
			</ul>
			<div><div><img src="img/B19779_07_01.jpg" alt="Figure 7.1 – PetsScreen error" width="691" height="291"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – PetsScreen error</p>
			<p>As seen in the preceding screenshot, the <code>PetsScreen</code> composable is highlighted in red because we have not created the composable yet. We will refactor our code a bit. Let us create a new file called <code>PetsScreen.kt</code>. Inside the file, let’s add the following code:</p>
			<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetsScreen(onPetClicked: (Cat) -&gt; Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pets")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                )
            )
        },
        content =  { paddingValues -&gt;
            PetList(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                onPetClicked = onPetClicked
            )
        }
    )
}</pre>			<p>The <code>PetsScreen</code> composable <a id="_idIndexMarker305"/>displays a list of pets. We have added a <code>Scaffold</code> composable as the root element. Inside the <code>Scaffold</code> composable, we have added a <code>TopAppBar</code> composable. We have also added a <code>PetList</code> composable as the content of the <code>Scaffold</code> composable. We have added a new <code>onPetClicked</code> callback to the <code>PetList</code> composable. We will be using this callback to navigate to <code>PetDetailsScreen</code> when we click on a pet item in the list.</p>
			<p>With this, our navigation graph is ready. We can now add the <code>AppNavigation</code> composable to our <code>MainActivity.kt</code> file. Let’s replace all the code inside the <code>ChapterSevenTheme</code> block with the following:</p>
			<pre class="source-code">
ChapterSevenTheme {
    AppNavigation()
}</pre>			<p>Build and run the <a id="_idIndexMarker306"/>app. The app still displays a list of cute pets as before, but now we are using the Jetpack Navigation library to handle our navigation.</p>
			<div><div><img src="img/B19779_07_02.jpg" alt="Figure 7.2 – Pets" width="509" height="1098"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Pets</p>
			<p>In the next section, let us learn how to navigate to a details screen when we click on a pet item in the list.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor096"/>Navigating to Compose destinations</h1>
			<p>In this <a id="_idIndexMarker307"/>section, we will learn how to navigate to a details screen when we click on a pet item in the list. First, we need to create a new composable for <code>PetDetailsScreen</code>. Let us create a new file called <code>PetDetailsScreen.kt</code> and create the <code>PetDetailsScreenContent</code> composable as <a id="_idIndexMarker308"/>follows:</p>
			<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetDetailsScreenContent(modifier: Modifier) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/rV1MVEh0Af2Bm4O0",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        FlowRow(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
        ) {
            repeat(2) {
                SuggestionChip(
                    modifier = Modifier
                        .padding(start = 3.dp, end = 3.dp),
                    onClick = { },
                    label = {
                        Text(text = "Tag $it")
                    }
                )
            }
        }
    }
}</pre>			<p>Here, we<a id="_idIndexMarker309"/> created a composable that has <code>Column</code> as the root element. Inside the <code>Column</code> element, we added an <code>AsyncImage</code> composable that displays a cat image. We also added a <code>FlowRow</code> composable to flow items to the next line when space runs out, which cannot be achieved with rows. <code>FlowRow</code> displays two <code>SuggestionChip</code> composables. We will use this composable to display the details of a pet. Notice we are using hardcoded cat IDs and tags for now. We will pass this data from the <code>PetList</code> composable in the next section. Next, let us create the <code>PetDetailsScreen</code> composable as follows:</p>
			<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetDetailsScreen(onBackPressed: () -&gt; Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pet Details")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                ),
                navigationIcon = {
                    IconButton(
                        onClick = onBackPressed,
                        content = {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "Back"
                            )
                        }
                    )
                }
            )
        },
        content = { paddingValues -&gt;
            PetDetailsScreenContent(
                modifier = Modifier
                    .padding(paddingValues)
            )
        }
    )
}</pre>			<p>The <code>PetDetailsScreen</code> composable<a id="_idIndexMarker310"/> displays the details of a pet. We have added a <code>Scaffold</code> composable as the root element. Inside the <code>Scaffold</code> composable, we have added a <code>TopAppBar</code> composable. We have also used the <code>PetDetailsScreenContent</code> composable we created earlier as the content of the <code>Scaffold</code> composable. We have added a new <code>onBackPressed</code> callback to the <code>PetDetailsScreen</code> composable. We will be using this callback to navigate back to the previous screen when we click on the back button in <code>TopAppBar</code>.</p>
			<p>Our next step is to add a composable for <code>PetDetailsScreen</code> to our <code>AppNavigation.kt</code> file. Let us add the following code to our <code>NavHost</code> below the composable for <code>PetsScreen</code>:</p>
			<pre class="source-code">
composable(Screens.PetDetailsScreen.route){
    PetDetailsScreen(
        onBackPressed = {
            navController.popBackStack()
        }
    )
}</pre>			<p>Here, we have added a composable for <code>PetDetailsScreen</code>. We passed in the route for the screen and the <code>PetDetailsScreen</code> composable as the content. <code>PetDetailsScreen</code> has the <code>onBackPressed</code> argument. The argument handles the situation where a user taps the back arrow icon, which is normally at the top left. We use <code>navController.popBackStack()</code> inside the <code>onBackPressed</code> argument. This method attempts to pop the current destination off the back stack and navigates to the previous destination.</p>
			<p>Now we <a id="_idIndexMarker311"/>need to do the actual navigation to <code>PetDetailsScreen</code> when we click on a pet item in the list. Let us head over to the <code>PetListItem</code> composable. We will add a new <code>onPetClicked</code> callback to the <code>PetListItem</code> composable. The modified composable should look like this:</p>
			<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(cat: Cat, onPetClicked: (Cat) -&gt; Unit) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
                .clickable {
                    onPetClicked(cat)
                }
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
              repeat(cat.tags.size) {
                  SuggestionChip(
                      modifier = Modifier
                          .padding(start = 3.dp, end = 3.dp),
                      onClick = { },
                      label = {
                          Text(text = cat.tags[it])
                      }
                  )
              }
            }
        }
    }
}</pre>			<p>In the preceding code, we have added a new <code>onPetClicked</code> callback to the composable. We have added the <code>clickable</code> modifier to <code>Column</code> and called the <code>onPetClicked</code> callback inside the modifier. We pass in the <code>cat</code> object to the callback. Next, we<a id="_idIndexMarker312"/> need to add the <code>onPetClicked</code> callback to the <code>PetList</code> composable, as follows:</p>
			<pre class="source-code">
@Composable
fun PetList(modifier: Modifier, onPetClicked: (Cat) -&gt; Unit) {
    // other code
}</pre>			<p>Next, we need to pass this callback where we use our <code>PetListItem</code> composable. The modified <code>PetListItem</code> composable at the call site inside the items block should look like this:</p>
			<pre class="source-code">
PetListItem(
    cat = pet,
    onPetClicked = onPetClicked
)</pre>			<p>Lastly, we need to modify the <code>AppNavigation</code> composable to pass the <code>onPetClicked</code> callback to the <code>PetsScreen</code> composable. The modified <code>AppNavigation</code> composable should look like this:</p>
			<pre class="source-code">
PetsScreen(
    onPetClicked = {
        navController.navigate(Screens.PetDetailsScreen.route)
    }
)</pre>			<p>Here, we pass the <code>onPetClicked</code> callback to the <code>PetsScreen</code> composable. Inside the callback, we call the <code>navigate()</code> function on <code>navController</code> and pass in the route for <code>PetDetailsScreen</code>. This will navigate to <code>PetDetailsScreen</code> when we click on a<a id="_idIndexMarker313"/> pet item in the list.</p>
			<p>Build and run the app. Click on a pet item in the list. You will see that the app navigates to <code>PetDetailsScreen</code>.</p>
			<div><div><img src="img/B19779_07_03.jpg" alt="Figure 7.3 – Pet Details screen" width="503" height="1033"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Pet Details screen</p>
			<p>We can see a cute <a id="_idIndexMarker314"/>cat image and some tags. Additionally, if we press the back button in <code>TopAppBar</code>, we will be able to navigate back to <code>PetsScreen</code>.</p>
			<p>So far, we have been able to navigate from <code>PetsScreen</code> to <code>PetDetailsScreen</code>. However, we are not passing any data to <code>PetDetailsScreen</code>. In the next section, we will learn how to pass data to <code>PetDetailsScreen</code>.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor097"/>Passing arguments to destinations</h1>
			<p>In our <code>PetDetailsScreen</code>, we need to remove the hardcoded cat IDs and tags and pass them<a id="_idIndexMarker315"/> from the <code>PetList</code> composable. Follow these steps:</p>
			<ol>
				<li>Let us head <a id="_idIndexMarker316"/>over to the <code>PetDetailsScreenContent</code> composable inside the <code>PetDetailsScreen.kt</code> file and modify it as follows:<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetDetailsScreenContent(modifier: Modifier, cat: Cat) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/${cat.id}",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        FlowRow(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
        ) {
            repeat(cat.tags.size) {
                SuggestionChip(
                    modifier = Modifier
                        .padding(start = 3.dp, end = 3.dp),
                    onClick = { },
                    label = {
                        Text(text = cat.tags[it])
                    }
                )
            }
        }
    }
}</pre><p class="list-inset">We have <a id="_idIndexMarker317"/>added a new <code>cat</code> parameter<a id="_idIndexMarker318"/> to the composable. We have used the <code>cat</code> object to display the cat image and tags.</p></li>				<li>Next, let us head over to the <code>PetDetailsScreen</code> composable and modify it as follows:<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetDetailsScreen(onBackPressed: () -&gt; Unit, cat: Cat) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pet Details")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                ),
                navigationIcon = {
                    IconButton(
                        onClick = onBackPressed,
                        content = {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "Back"
                            )
                        }
                    )
                }
            )
        },
        content = { paddingValues -&gt;
            PetDetailsScreenContent(
                modifier = Modifier
                    .padding(paddingValues),
                cat = cat
            )
        }
    )
}</pre><p class="list-inset">Here, we<a id="_idIndexMarker319"/> have added a new <code>cat</code> parameter to the composable. We have passed the <code>cat</code> object to the <code>PetDetailsScreenContent</code> composable.</p></li>				<li>Next, let<a id="_idIndexMarker320"/> us head over to the <code>AppNavigation</code> composable and add the logic for passing the <code>cat</code> object to <code>PetDetailsScreen</code>. We need to first modify the composable for <code>PetDetailsScreen</code>, as follows:<pre class="source-code">
composable(
    route = "${Screens.PetDetailsScreen.route}/{cat}",
    arguments = listOf(
        navArgument("cat") {
            type = NavType.StringType
        }
    )
){
    PetDetailsScreen(
        onBackPressed = {
            navController.popBackStack()
        },
        cat = Json.decodeFromString(it.arguments?.getString("cat") ?: "")
    )
}</pre><p class="list-inset">Let’s<a id="_idIndexMarker321"/> explain the changes:</p><ul><li>On the <a id="_idIndexMarker322"/>route, we have added a new parameter called <code>cat</code>. This is the parameter we will use to pass the <code>cat</code> object to <code>PetDetailsScreen</code>.</li><li>We have added a new <code>arguments</code> parameter. This parameter is used to pass arguments to the destination screen. We have added <code>navArgument</code> for the <code>cat</code> parameter. We have set the type to be <code>String</code>. This is because we will be passing a string representation of the <code>cat</code> object.</li><li>We pass the <code>cat</code> object to the <code>PetDetailsScreen</code> composable. We have used <code>Json.decodeFromString()</code> from the Kotlinx Serialization library that we learned about in <a href="B19779_06.xhtml#_idTextAnchor084"><em class="italic">Chapter 6</em></a> to convert the string value of the <code>cat</code> object into a <code>Cat</code> object. We have used the <code>arguments</code> property of <code>NavBackStackEntry</code> to get the string value of the <code>cat</code> object. We have used the Elvis operator to return an empty string if the <code>arguments</code> property is null.</li></ul></li>				<li>Lastly, we need to modify the <code>onPetClicked</code> callback of <code>PetsScreen</code> in the <code>AppNavigation</code> composable, as follows:<pre class="source-code">
composable(Screens.PetsScreen.route) {
    PetsScreen(
        onPetClicked = { cat -&gt;
            navController.navigate(
                "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
            )
        }
    )
}</pre><p class="list-inset">We have <a id="_idIndexMarker323"/>modified the <code>navigate()</code> function <a id="_idIndexMarker324"/>to pass the <code>Cat</code> object as a string. We also used <code>Json.encodeToString()</code> from the Kotlinx Serialization library to convert the <code>Cat</code> object into a string. This will be passed as an argument to <code>PetDetailsScreen</code> when we click on a pet item in the list.</p></li>				<li>Build and run the app. Click on any cute cat picture from the list and now the details screen will display the cat image and tag of the cute cat that we selected:</li>
			</ol>
			<div><div><img src="img/B19779_07_04.jpg" alt="Figure 7.4 – Pet Details" width="503" height="1037"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Pet Details</p>
			<p>We have<a id="_idIndexMarker325"/> now been able to pass data to <code>PetDetailsScreen</code>. We <a id="_idIndexMarker326"/>have learned how to navigate to a compose destination and pass data to the details screen. In the next section, we will learn how to handle navigation in foldables and large screens.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor098"/>Navigation in foldables and large screens</h1>
			<p>In the <em class="italic">Designing UIs for large screens and foldables</em> section of <a href="B19779_04.xhtml#_idTextAnchor055"><em class="italic">Chapter 4</em></a>, we learned<a id="_idIndexMarker327"/> about the <code>WindowSize</code> class and how we can make our apps responsive in foldable devices and large screens. In this section, we are going to make our Pets app responsive in foldable devices and<a id="_idIndexMarker328"/> large screens. We are going to make several changes, as follows:</p>
			<ul>
				<li>Add a bottom bar to <code>PetsScreen</code>, which will have several options.</li>
				<li>Add <code>NavigationRail</code> and <code>NavigationDrawer</code>, which will be used depending on the screen size.</li>
				<li>Observe the device’s foldable state and change the layout of the app depending on the foldable state.</li>
				<li>Depending on the screen size, we will also change the content type. On large screens, we will display the list of cats and the details of the selected cat side by side. On small screens, we will display the list of cats and the details of the selected cat on different screens.</li>
			</ul>
			<p>Quite a lot of <a id="_idIndexMarker329"/>changes are required. The good thing is that I have already made the changes and you can find the final version in the <code>chapterseven</code> folder in the project’s repository. Let us go through the changes one by one:</p>
			<ol>
				<li>We will start by creating a <code>sealed interface</code> named <code>NavigationType</code> that represents the different types of navigation we will be using in our app. Let us create a new file inside the <code>navigation</code> package called <code>NavigationType.kt</code> and add the following code:<pre class="source-code">
sealed interface NavigationType {
    object BottomNavigation : NavigationType
    object NavigationDrawer : NavigationType
    object NavigationRail : NavigationType
}</pre><p class="list-inset">We are using a sealed interface instead of a sealed class here. This is because we do not need to hold any state in our <code>NavigationType</code>. We also do not need to pass properties to any of the <code>NavigationTypes</code>. We have three options: <code>BottomNavigation</code>, <code>NavigationDrawer</code>, and <code>NavigationRail</code>. We will be using these options to change the navigation type depending on the screen size.</p></li>				<li>Next, let us<a id="_idIndexMarker330"/> create yet another sealed interface called <code>ContentType</code>. This interface will be used to change the content display type depending on the screen size. Let us create a new file called <code>ContentType.kt</code> still inside the <code>navigation</code> package and add the following code:<pre class="source-code">
sealed interface ContentType {
    object List : ContentType
    object ListAndDetail : ContentType
}</pre><p class="list-inset">This <a id="_idIndexMarker331"/>represents the two modes in which we can display our content depending on the screen size. We have the <code>List</code> mode, which displays the list of cats only. We also have the <code>ListAndDetail</code> mode, which displays the list of cats and the details of the selected cat side by side.</p></li>				<li>Next, in our <code>Screens.kt</code> file, we have to add a new destination screen called <code>FavoritesScreen</code>. The final code for the file should look like this:<pre class="source-code">
sealed class Screens(val route: String) {
    object PetsScreen : Screens("pets")
    object PetDetailsScreen : Screens("petDetails")
    object FavoritePetsScreen : Screens("favoritePets")
}</pre><p class="list-inset">We now have three destinations for our app.</p></li>				<li>Next, let us add the <code>WindowSize</code> dependencies to the libraries section in the <code>libs.versions.toml</code> file:<pre class="source-code">
compose-window-size = "androidx.compose.material3:material3-window-size-class:1.2.0-alpha07"
androidx-window = "androidx.window:window:1.1.0"</pre></li>				<li>We also<a id="_idIndexMarker332"/> need to add the dependencies to our app module’s <code>build.gradle.kts</code> file:<pre class="source-code">
implementation(libs.compose.window.size)
implementation(libs.androidx.window)</pre><p class="list-inset">Do a Gradle sync to be able to add the dependencies to our project.</p></li>				<li>Next, we <a id="_idIndexMarker333"/>need to create the composables for <code>NavigationRail</code>, <code>NavigationDrawer</code>, and <code>BottomNavigation</code>. Let us create a new file called <code>PetsNavigationRail.kt</code> inside the <code>view</code> package and add the following code:<pre class="source-code">
@Composable
fun PetsNavigationRail(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    onDrawerClicked: () -&gt; Unit
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    NavigationRail(
        modifier = Modifier
            .fillMaxHeight()
    ) {
        NavigationRailItem(
            selected = false,
            onClick = onDrawerClicked,
            icon = {
                Icon(
                    imageVector = Icons.Default.Menu,
                    contentDescription = "Menu Icon"
                )
            }
        )
        NavigationRailItem(
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationRailItem(
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="list-inset">In the preceding code, we created the <code>PetsNavigationRail()</code> composable, which has three parameters: <code>onFavoriteClicked</code>, <code>onHomeClicked</code>, and <code>onDrawerClicked</code>. The first two are callbacks that will be used to navigate to the different screens. We use the <code>onDrawerClicked</code> callback to close or open the drawer when the user interacts <a id="_idIndexMarker334"/>with it. At the top, we<a id="_idIndexMarker335"/> have the <code>items</code> variable, which holds a list of all our screens, and the <code>selectedItem</code> variable, which holds the currently selected screen. We use the <code>NavigationRail</code> composable from the Material 3 library to display the navigation rail. To add items to <code>NavigationRail</code>, we use the <code>NavigationRailItem</code> composable. We pass in the selected state of the item, the <code>onClick</code> callback, and the icon to display.</p></li>				<li>Next, let us create the <code>PetsBottomNavigationBar</code> composable. Let us create a new file called <code>PetsBottomNavigationBar.kt</code> inside the <code>view</code> package and add the following code:<pre class="source-code">
@Composable
fun PetsBottomNavigationBar(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    NavigationBar(
        modifier = Modifier
            .fillMaxWidth(),
        containerColor = MaterialTheme.colorScheme.background
    ) {
        NavigationBarItem(
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationBarItem(
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="list-inset">The <code>PetsBottomNavigationBar</code> composable is similar to the<code> PetsNavigationRail</code> composable. The only difference is that we are using the <code>NavigationBar</code> composable instead of the <code>NavigationRail</code> composable. We have the home and favorite items. We use the <code>NavigationBarItem</code> composable to add items to <code>NavigationBar</code>. We pass in the<a id="_idIndexMarker336"/> selected state of the item, the <code>onClick</code> callback, and the icon to display.</p></li>				<li>Next, let<a id="_idIndexMarker337"/> us create the <code>PetsNavigationDrawer</code> composable. Let us create a new file called <code>PetsNavigationDrawer.kt</code> inside the <code>view</code> package and add the following code:<pre class="source-code">
@Composable
fun PetsNavigationDrawer(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    onDrawerClicked: () -&gt; Unit = {}
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    Column(
        modifier = Modifier
            .wrapContentWidth()
            .fillMaxHeight()
            .background(MaterialTheme.colorScheme.inverseOnSurface)
            .padding(16.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "Chapter Seven",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.primary
            )
            IconButton(
                onClick = onDrawerClicked
            ) {
                Icon(
                    imageVector = Icons.Default.Menu,
                    contentDescription = "Navigation Drawer Icon"
                )
            }
        }
        NavigationDrawerItem(
            label = { Text(text = "Pets") },
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationDrawerItem(
            label = { Text(text = "Favorites") },
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="list-inset">We used the <code>NavigationDrawer</code> composable from the Material 3 library to display the navigation drawer. We used the <code>NavigationDrawerItem</code> composable to add items to <code>NavigationDrawer</code>. We passed in the label, the selected<a id="_idIndexMarker338"/> state of the item, the <code>onClick</code> callback, and the icon to display.</p></li>				<li>Since <a id="_idIndexMarker339"/>our <code>PetsNavigationDrawer</code>, <code>PetsNavigationRail</code>, and <code>PetsBottomNavigationBar</code> composables have <code>FavoritesScreen</code>, let us create a new file called <code>FavoritePetsScreen.kt</code> inside the view package and add the following code:<pre class="source-code">
@Composable
fun FavoritePetsScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Favorite Pets")
    }
}</pre><p class="list-inset">This is a simple composable that displays the text <code>"Favorite Pets"</code>. We will use this composable as the content of <code>FavoritesScreen</code>. We also need to refactor our <code>AppNavigation()</code> composable to make it ready to handle the different navigation and content types. The final modified composable should look like this:</p><pre class="source-code">@Composable
fun AppNavigation(
    contentType: ContentType,
    navHostController: NavHostController = rememberNavController()
) {
    NavHost(
        navController = navHostController,
        startDestination = Screens.PetsScreen.route
    ) {
        composable(Screens.PetsScreen.route) {
            PetsScreen(
                onPetClicked = { cat -&gt;
                    navHostController.navigate(
                        "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
                    )
                },
                contentType = contentType
            )
        }
        composable(
            route = "${Screens.PetDetailsScreen.route}/{cat}",
            arguments = listOf(
                navArgument("cat") {
                    type = NavType.StringType
                }
            )
        ) {
            PetDetailsScreen(
                onBackPressed = {
                    navHostController.popBackStack()
                },
                cat = Json.decodeFromString(it.arguments?.getString("cat") ?: "")
            )
        }
        composable(Screens.FavoritePetsScreen.route) {
            FavoritePetsScreen()
        }
    }
}</pre><p class="list-inset">Let’s <a id="_idIndexMarker340"/>highlight<a id="_idIndexMarker341"/> the changes:</p><ul><li>Our <code>AppNavigation()</code> composable now takes in a <code>contentType</code> parameter of type <code>ContentType</code>. This is the parameter we will use to change the content type depending on the screen size. We also pass in a <code>navHostController</code> parameter of type <code>NavHostController</code>. This is the parameter we will use to navigate to different screens in our app. Previously, <code>navHostController</code> was created inside the <code>AppNavigation()</code> composable. We have moved it to the call site so that we can be able to use the same <code>navHostController</code> in different composables.</li><li>We have used the new <code>PetsScreen()</code> composable, which takes in the <code>contentType</code> parameter. Same as before, we still pass <code>onPetClicked</code>, which navigates to <code>PetDetailsScreen</code>. Previously, we were using the <code>PetList</code> composable.</li><li>Lastly, we <a id="_idIndexMarker342"/>have added our new <code>FavoritePetsScreen</code> destination to the <code>NavHost</code> composable.</li></ul></li>				<li>Let us see<a id="_idIndexMarker343"/> what the new update <code>PetsScreen</code> composable looks like. Let us head over to the <code>PetsScreen.kt</code> file and modify the composable as follows:<pre class="source-code">
@Composable
fun PetsScreen(
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    PetsScreenContent(
        modifier = Modifier
            .fillMaxSize(),
        onPetClicked = onPetClicked,
        contentType = contentType,
        petsUIState = petsUIState
    )
}</pre><p class="list-inset">We have added a new <code>contentType</code> parameter to the composable. We have also added a new <code>petsUIState</code> parameter. This is the UI state of <code>PetsScreen</code>. We will use this state to display the list of cats.</p></li>				<li>Next, create<a id="_idIndexMarker344"/> a new file <a id="_idIndexMarker345"/>called <code>PetsScreenContent.kt</code> and add the following code:<pre class="source-code">
@Composable
fun PetsScreenContent(
    modifier: Modifier,
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
    petsUIState: PetsUIState
) {
    Column(
        modifier = modifier
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AnimatedVisibility(
            visible = petsUIState.isLoading
        ) {
            CircularProgressIndicator()
        }
        AnimatedVisibility(
            visible = petsUIState.pets.isNotEmpty()
        ) {
            if (contentType == ContentType.List) {
                PetList(
                    onPetClicked = onPetClicked,
                    pets = petsUIState.pets,
                    modifier = Modifier
                        .fillMaxWidth()
                )
            } else {
                PetListAndDetails(
                    pets = petsUIState.pets
                )
            }
        }
        AnimatedVisibility(
            visible = petsUIState.error != null
        ) {
            Text(text = petsUIState.error ?: "")
        }
    }
}</pre><p class="list-inset">Let’s explain the preceding code:</p><ul><li><code>PetsScreenContent</code> has a parent <code>Column</code> composable. Inside the <code>Colum</code>n composable, we have added three <code>AnimatedVisibility</code> composables. The first one is used to display <code>CircularProgressIndicator</code> when <code>petsUIState</code> is loading. The second one is used to display the list of cats when the <code>pets</code> variable from <code>petsUIState</code> is not empty. The third one is used to display an error message when <code>petsUIState</code> has an error.</li><li>When<a id="_idIndexMarker346"/> displaying the list of cats, we check <code>contentType</code>. If <code>contentType</code> is <code>List</code>, we display the <code>PetList</code> composable. If <code>contentType</code> is <code>ListAndDetail</code>, we display the <code>PetListAndDetails</code> composable. We will create the <code>PetListAndDetails</code> composable shortly. Note the <code>PetList</code> composable is also modified to take in the <code>pets</code> parameter. We will use this parameter to display the list of cats. We will see the changes shortly.</li><li>Lastly, we <a id="_idIndexMarker347"/>show the error message if <code>petsUIState</code> has an error.</li></ul><p class="list-inset">Our updated <code>PetList</code> composable should look like this:</p><pre class="source-code">@Composable
fun PetList(
    onPetClicked: (Cat) -&gt; Unit,
    pets: List&lt;Cat&gt;,
    modifier: Modifier
) {
    LazyColumn(
        modifier = modifier
    ) {
        items(pets) { pet -&gt;
            PetListItem(
                cat = pet,
                onPetClicked = onPetClicked
            )
        }
    }
}</pre><p class="list-inset">No major<a id="_idIndexMarker348"/> changes here: we have just added the <code>pets</code> parameter. We use this parameter to display the list of cats in our <code>LazyColumn</code>. With this update, it is time to create the <code>PetListAndDetails</code> composable.</p></li>				<li>Let us <a id="_idIndexMarker349"/>create a new file called <code>PetListAndDetails.kt</code> inside the view package and add the following code:<pre class="source-code">
@Composable
fun PetListAndDetails(pets: List&lt;Cat&gt;) {
    var currentPet by remember {
        mutableStateOf(pets.first())
    }
    Row(
        modifier = Modifier
            .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        PetList(
            onPetClicked = {
                currentPet = it
            },
            pets = pets,
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        )
        PetDetailsScreenContent(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
                .weight(1f),
            cat = currentPet
        )
    }
}</pre><p class="list-inset">This <a id="_idIndexMarker350"/>composable has a <code>Row</code>, which has two items each with a weight of <code>1f</code>. We have used the updated <code>PetListComposable</code> and <code>PetDetailsScreenContent</code> that we created earlier. We have also added a <code>currentPet</code> variable, which holds the currently selected cat. We use this variable to display the details of the selected cat. We also use this variable to update <code>currentPet</code> when we click on a pet item in the list. Make sure you also update <code>PetDetailsScreenContent</code> to take in the new modifier parameter.</p><p class="list-inset">With the<a id="_idIndexMarker351"/> modifications we have made, let us now create a new composable called <code>AppNavigationContent</code>, which has logic for displaying <code>NavigationRail</code> or <code>BottomNavigation</code> depending on <code>NavigationType</code>.</p></li>				<li>Let us <a id="_idIndexMarker352"/>create a new file called <code>AppNavigationContent.kt</code> inside the navigation package and add the following code:<pre class="source-code">
@Composable
fun AppNavigationContent(
    contentType: ContentType,
    navigationType: NavigationType,
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    navHostController: NavHostController,
    onDrawerClicked: () -&gt; Unit = {}
) {
    Row(
        modifier = Modifier
            .fillMaxSize(),
    ) {
        AnimatedVisibility(
            visible = navigationType == NavigationType.NavigationRail
        ) {
            PetsNavigationRail(
                onFavoriteClicked = onFavoriteClicked,
                onHomeClicked = onHomeClicked,
                onDrawerClicked = onDrawerClicked
            )
        }
        Scaffold(
            content = { paddingValues -&gt;
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                ) {
                    AppNavigation(
                        contentType = contentType,
                        navHostController = navHostController
                    )
                }
            },
            bottomBar = {
                AnimatedVisibility(
                    visible = navigationType == NavigationType.BottomNavigation
                ) {
                    PetsBottomNavigationBar(
                        onFavoriteClicked = onFavoriteClicked,
                        onHomeClicked = onHomeClicked
                    )
                }
            }
        )
    }
}</pre><p class="list-inset">Let’s <a id="_idIndexMarker353"/>explain the preceding code:</p><ul><li>The <code>AppNavigationContent</code> composable takes a number of parameters. The <code>contentType </code>parameter is used to display the content type. The <code>navigationType</code> parameter is used to toggle the navigation options. <code>onFavoriteClicked</code> and <code>onHomeClicked</code> are callbacks that will be <a id="_idIndexMarker354"/>used to navigate to the different screens. <code>navHostController</code> is an object that manages navigation within the <code>NavHost</code> <code>onDrawerClicked</code> is used to close or open the drawer when the user interacts with it.</li><li>We have <code>Row</code> as the root element. Inside <code>Row</code>, we have an <code>AnimatedVisibility</code> composable that displays the <code>PetsNavigationRail</code> composable when <code>navigationType</code> is <code>NavigationType</code>.<code>NavigationRail</code>. We have also added a <code>Scaffold</code> composable. We have used the <code>AppNavigation</code> composable as the content of <code>Scaffold</code>, passing in <code>contentType</code> and <code>navHostController</code>. We have also used the <code>PetsBottomNavigationBar</code> composable as the bottom bar of <code>Scaffold</code>. We have used the <code>AnimatedVisibility</code> composable to display the <code>PetsBottomNavigationBar</code> composable when <code>navigationType</code> is <code>NavigationType.BottomNavigation</code>.</li></ul></li>				<li>The last step<a id="_idIndexMarker355"/> is to refactor the <code>MainActivity.kt</code> file to use the new <code>AppNavigationContent</code> composable. We will walk through the changes step by step. There<a id="_idIndexMarker356"/> are several changes:<ol><li class="upper-roman">To begin with, we need to observe the device’s foldable state. This will enable us to change the content type and navigation type. Let us create a new file called <code>DeviceFoldPosture.kt</code> inside the <code>navigation</code> package and add the following code:</li></ol><pre class="source-code">
sealed interface DeviceFoldPosture {
    data class BookPosture(val hingePosition: Rect) : DeviceFoldPosture
    data class SeparatingPosture(
        val hingePosition: Rect,
        val orientation: FoldingFeature.Orientation
    ) : DeviceFoldPosture
    object NormalPosture : DeviceFoldPosture
}
@OptIn(ExperimentalContracts::class)
fun isBookPosture(foldFeature: FoldingFeature?): Boolean {
    contract { returns(true) implies (foldFeature != null) }
    return foldFeature?.state == FoldingFeature.State.HALF_OPENED &amp;&amp;
            foldFeature.orientation == FoldingFeature.Orientation.VERTICAL
}
@OptIn(ExperimentalContracts::class)
fun isSeparating(foldFeature: FoldingFeature?): Boolean {
    contract { returns(true) implies (foldFeature != null) }
    return foldFeature?.state == FoldingFeature.State.FLAT &amp;&amp; foldFeature.isSeparating
}</pre><p class="list-inset">In the<a id="_idIndexMarker357"/> preceding code, we have<a id="_idIndexMarker358"/> a sealed interface that represents the different postures a foldable device can be in. We have <code>BookPosture</code>, which represents the posture when the device is in portrait orientation and its fold state is half opened. We have <code>SeparatingPosture</code>, which represents the posture when the fold or hinge device creates two logical display areas. We also have <code>NormalPosture</code>, which represents the posture when the device is not folded. We have two utility functions, <code>isBookPosture()</code> and <code>isSeparating()</code>, which are used to check the posture of the device. We will use these functions to check the posture of<a id="_idIndexMarker359"/> the device and change the layout of the app depending on the posture.</p><ol><li class="upper-roman" value="2">Let us head over to the <code>MainActivity.kt</code> file and add the following code <a id="_idIndexMarker360"/>before the <code>setContent</code> block:</li></ol><pre class="source-code">val deviceFoldingPostureFlow = WindowInfoTracker.getOrCreate(this).windowLayoutInfo(this)
    .flowWithLifecycle(this.lifecycle)
    .map { layoutInfo -&gt;
        val foldingFeature =
            layoutInfo.displayFeatures
                .filterIsInstance&lt;FoldingFeature&gt;()
                .firstOrNull()
        when {
            isBookPosture(foldingFeature) -&gt;
                DeviceFoldPosture.BookPosture(foldingFeature.bounds)
            isSeparating(foldingFeature) -&gt;
                DeviceFoldPosture.SeparatingPosture(
                    foldingFeature.bounds,
                    foldingFeature.orientation
                )
            else -&gt; DeviceFoldPosture.NormalPosture
        }
    }
    .stateIn(
        scope = lifecycleScope,
        started = SharingStarted.Eagerly,
        initialValue = DeviceFoldPosture.NormalPosture
    )</pre><p class="list-inset">Here, we use <code>WindowInfoTracker</code> to get the window layout info. We use <code>flowWithLifecycle()</code> to make sure we only get the layout info when the activity is in <a id="_idIndexMarker361"/>the correct life cycle state. We then use the <code>map</code> operator to map the layout <a id="_idIndexMarker362"/>info to the different postures. We use the <code>stateIn()</code> operator, which converts a cold <code>Flow</code> into a hot <code>StateFlow</code> that is started in the given coroutine scope, sharing the most recently emitted value of device posture. We use <code>SharingStarted.Eagerly</code> to make sure we get the latest value of the posture when the activity is in the started state. We use the <code>initialValue</code> parameter to set the initial value of the posture to <code>DeviceFoldPosture.NormalPosture</code>. We will use this flow to observe the device’s posture and change the app’s layout depending on the posture.</p><ol><li class="upper-roman" value="3">Next, inside our <code>setcontent</code> block, we need to add the variables before the theme block:</li></ol><pre class="source-code">val devicePosture = deviceFoldingPostureFlow.collectAsStateWithLifecycle().value
val windowSizeClass = calculateWindowSizeClass(activity = this)
val scope = rememberCoroutineScope()
val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
val navController = rememberNavController()</pre><p class="list-inset">We have <a id="_idIndexMarker363"/>added the <code>devicePosture</code> variable, which holds the posture of the device. We have also added the <code>windowSizeClass</code> variable, which holds the window size class of the device; the <code>scope</code> variable, which holds <code>CoroutineScope</code>; the <code>drawerState</code> variable, which holds the state of the drawer; and the <code>navController</code> variable, which holds <code>NavHostController</code>. We will use this variable to navigate to different screens in our app.</p><ol><li class="upper-roman" value="4">Inside<a id="_idIndexMarker364"/> our <code>ChapterSevenTheme</code>, we need to add the following code:</li></ol><pre class="source-code">val navigationType: NavigationType
val contentType: ContentType
when (windowSizeClass.widthSizeClass) {
    WindowWidthSizeClass.Compact -&gt; {
        navigationType = NavigationType.BottomNavigation
        contentType = ContentType.List
    }
    WindowWidthSizeClass.Medium -&gt; {
        navigationType = NavigationType.NavigationRail
        contentType = if (devicePosture is DeviceFoldPosture.BookPosture
            || devicePosture is DeviceFoldPosture.SeparatingPosture
        ) {
            ContentType.ListAndDetail
        } else {
            ContentType.List
        }
    }
    WindowWidthSizeClass.Expanded -&gt; {
        navigationType = if (devicePosture is DeviceFoldPosture.BookPosture) {
            NavigationType.NavigationRail
        } else {
            NavigationType.NavigationDrawer
        }
        contentType = ContentType.ListAndDetail
    }
    else -&gt; {
        navigationType = NavigationType.BottomNavigation
        contentType = ContentType.List
    }
}</pre><p class="list-inset">Here, we<a id="_idIndexMarker365"/> have two <a id="_idIndexMarker366"/>variables: <code>navigationType</code> and <code>contentType</code>. We use <code>windowSizeClass</code> to get the width of our device and, depending on the width size, we assign the values for our <code>navigationType</code> and <code>contentType</code> variables:</p><ul><li>If the width size is <code>Compact</code>, we use <code>BottomNavigation</code> for <code>navigationType</code> and <code>List</code> for <code>contentType</code>.</li><li>If the width size is <code>Medium</code>, we use <code>NavigationRail</code> for <code>navigationType</code>. For <code>contentType</code>, we check <code>devicePosture</code>. If <code>devicePosture</code> is <code>DeviceFoldPosture.BookPosture</code> or <code>DeviceFoldPosture.SeparatingPosture</code>, we use <code>ListAndDetail</code> for <code>contentType</code>. If <code>devicePosture</code> is not <code>DeviceFoldPosture.BookPosture</code> or <code>DeviceFoldPosture.SeparatingPosture</code>, we use <code>List</code> for <code>contentType</code>.</li><li>If the <a id="_idIndexMarker367"/>width size is <code>Expanded</code>, we check <code>devicePosture</code>. If <code>devicePosture</code> is <code>DeviceFoldPosture.BookPosture</code>, we use <code>NavigationRail</code> for <code>navigationType</code>. If <code>devicePosture</code> is not <code>DeviceFoldPosture.BookPosture</code>, we use <code>NavigationDrawer</code> for <code>navigationType</code>. We use <code>ListAndDetail</code> for <code>contentType</code>.</li><li>Lastly, if the width size is anything else, we use <code>BottomNavigation</code> for <code>navigationType</code> and <code>List</code> for <code>contentType</code>.</li></ul><ol><li class="upper-roman" value="5">Below <a id="_idIndexMarker368"/>the preceding code, add this <code>if</code> statement:</li></ol><pre class="source-code">if (navigationType == NavigationType.NavigationDrawer) {
    PermanentNavigationDrawer(
        drawerContent = {
            PermanentDrawerSheet {
                PetsNavigationDrawer(
                    onFavoriteClicked = {
                        navController.navigate(Screens.FavoritePetsScreen.route)
                    },
                    onHomeClicked = {
                        navController.navigate(Screens.PetsScreen.route)
                    }
                )
            }
        }
    ) {
        AppNavigationContent(
            navigationType = navigationType,
            contentType = contentType,
            onFavoriteClicked = {
                navController.navigate(Screens.FavoritePetsScreen.route)
            },
            onHomeClicked = {
                navController.navigate(Screens.PetsScreen.route)
            },
            navHostController = navController
        )
    }
}</pre><p class="list-inset">The <a id="_idIndexMarker369"/>condition checks whether <code>navigationType</code> is <code>NavigationType.NavigationDrawer</code>. If it is, we use the <code>PermanentNavigationDrawer</code> composable from the Material 3 library. We use the <code>PetsNavigationDrawer</code> composable that we created for <code>drawerContent</code>. We use the <code>AppNavigationContent</code> composable as the content of <code>PermanentNavigationDrawer</code>. We pass in the <code>navigationType</code>, <code>contentType</code>, <code>onFavoriteClicked</code>, <code>onHomeClicked</code>, and <code>navHostController</code> parameters.</p><ol><li class="upper-roman" value="6">Next, let <a id="_idIndexMarker370"/>us add the <code>else</code> condition for our <code>if</code> statement:</li></ol><pre class="source-code">else {
  ModalNavigationDrawer(
      drawerContent = {
          ModalDrawerSheet {
              PetsNavigationDrawer(
                  onFavoriteClicked = {
                      navController.navigate(Screens.FavoritePetsScreen.route)
                  },
                  onHomeClicked = {
                      navController.navigate(Screens.PetsScreen.route)
                  },
                  onDrawerClicked = {
                      scope.launch {
                          drawerState.close()
                      }
                  }
              )
          }
      },
      drawerState = drawerState
  ) {
      AppNavigationContent(
          navigationType = navigationType,
          contentType = contentType,
          onFavoriteClicked = {
              navController.navigate(Screens.FavoritePetsScreen.route)
          },
          onHomeClicked = {
              navController.navigate(Screens.PetsScreen.route)
          },
          navHostController = navController,
          onDrawerClicked = {
              scope.launch {
                  drawerState.open()
              }
          }
      )
  }
}</pre><p class="list-inset">Here, when <code>navigationType</code> is not <code>NavigationType.NavigationDrawer</code>, we use the <code>ModalNavigationDrawer</code> composable from the Material 3 library. We use the <code>PetsNavigationDrawer</code> composable for <code>drawerContent</code>. We use the <code>AppNavigationContent</code> composable as the content of <code>ModalNavigationDrawer</code>. We pass in the <code>navigationType</code>,<code> contentType</code>, <code>onFavoriteClicked</code>, <code>onHomeClicked</code>, and <code>navHostController</code> parameters. We also pass in the <code>drawerState</code> parameter. We use the <code>onDrawerClicked</code> callback to open or close the drawer when the user interacts with it.</p></li>			</ol>
			<p>Those <a id="_idIndexMarker371"/>were a<a id="_idIndexMarker372"/> lot of changes; great work on adding them! We now need to run these changes and see them into action. Luckily, we have a <strong class="bold">resizable emulator</strong> to help test these changes. We will be creating one and testing the app in the next subsection.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor099"/>Creating and using the resizable emulator</h2>
			<p>To create and <a id="_idIndexMarker373"/>use the resizable emulator, follow these steps:</p>
			<ol>
				<li>Open the <strong class="bold">Device Manager</strong> window<a id="_idIndexMarker374"/> from the right sidebar in Android Studio. If you cannot find it there, use the <strong class="bold">View</strong> menu option at the top and select <strong class="bold">Tool Windows</strong>; then, you will see the <strong class="bold">Device </strong><strong class="bold">Manager</strong> option.</li>
			</ol>
			<div><div><img src="img/B19779_07_05.jpg" alt="Figure 7.5 – Device Manager" width="770" height="494"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Device Manager</p>
			<ol>
				<li value="2">Select <a id="_idIndexMarker375"/>the <strong class="bold">Virtual</strong> devices tab and click on <strong class="bold">Create Device</strong>, which brings you this pop-up window:</li>
			</ol>
			<div><div><img src="img/B19779_07_06.jpg" alt="Figure 7.6 – New device configurations" width="1170" height="544"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – New device configurations</p>
			<p class="list-inset">The window enables you to customize the properties of the device you want to create. You can change the device category and you also select the device you want to create.</p>
			<ol>
				<li value="3">Let us <a id="_idIndexMarker376"/>select the <strong class="bold">Resizable (Experimental)</strong> option under the <strong class="bold">Phone</strong> category. This will enable us to create a resizable device. Click <strong class="bold">Next</strong> and you will see the following window:</li>
			</ol>
			<div><div><img src="img/B19779_07_07.jpg" alt="Figure 7.7 – System Image" width="1030" height="514"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – System Image</p>
			<ol>
				<li value="4">Here, you select the system image you want to use. Let us select the <strong class="bold">API 34</strong> system image. Click <strong class="bold">Next</strong> and you will see the following window:</li>
			</ol>
			<div><div><img src="img/B19779_07_08.jpg" alt="Figure 7.8 – Device information" width="1010" height="507"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Device information</p>
			<p class="list-inset">This is the <a id="_idIndexMarker377"/>last step where you confirm the device name and the device orientation. We will maintain the name generated and use portrait as the default orientation.</p>
			<ol>
				<li value="5">Click <strong class="bold">Finish</strong> and you will see the device has been added to your list of devices:</li>
			</ol>
			<div><div><img src="img/B19779_07_09.jpg" alt="Figure 7.9 – Devices list" width="748" height="259"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Devices list</p>
			<ol>
				<li value="6">Start the emulator and run the app.</li>
			</ol>
			<div><div><img src="img/B19779_07_10.jpg" alt="Figure 7.10 – Resizable emulator" width="592" height="1146"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Resizable emulator</p>
			<p>From the emulator, we<a id="_idIndexMarker378"/> can see we have two options highlighted. The first one allows us to change the device from a small/normal device to a foldable or tablet device. The second one allows us to change the options when we change to a foldable device. Let us change the device to a foldable device. The app now changes the navigation option to navigation rail and the screen has a list and details of the first cat opened too.</p>
			<div><div><img src="img/B19779_07_11.jpg" alt="Figure 7.11 – Foldable device navigation rail" width="880" height="1099"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Foldable device navigation rail</p>
			<p>On tapping the <strong class="bold">Foldable</strong> options, we <a id="_idIndexMarker379"/>can see the following options:</p>
			<div><div><img src="img/B19779_07_12.jpg" alt="Figure 7.12 – Foldable options" width="59" height="194"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Foldable options</p>
			<p>Selecting the<a id="_idIndexMarker380"/> second option in the foldables section brings us to the following screen:</p>
			<div><div><img src="img/B19779_07_13.jpg" alt="Figure 7.13 – Foldable device" width="880" height="1099"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Foldable device</p>
			<p>From the<a id="_idIndexMarker381"/> device size option, we can also switch to tablet view:</p>
			<div><div><img src="img/B19779_07_14.jpg" alt="Figure 7.14 – Tablet view" width="1100" height="688"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Tablet view</p>
			<p>You can see<a id="_idIndexMarker382"/> the app now has a permanent navigation drawer and the screen has a list and details of the first cat opened too. Tap a different cat and you will see the details of the cat displayed on the right side of the screen. We can also navigate to the <strong class="bold">Favorites</strong> screen and back to the <strong class="bold">Pets</strong> screen.</p>
			<div><div><img src="img/B19779_07_15.jpg" alt="Figure 7.15 – Favorite Pets screen" width="1084" height="488"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Favorite Pets screen</p>
			<p>We can also see <a id="_idIndexMarker383"/>the modal navigation drawer:</p>
			<div><div><img src="img/B19779_07_16.jpg" alt="Figure 7.16 – Modal navigation drawer" width="877" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Modal navigation drawer</p>
			<p>The resizable emulator<a id="_idIndexMarker384"/> is a great way for us to test our app across different device sizes, but it has its own limitations. The following are the limitations of resizable emulators:</p>
			<ul>
				<li><strong class="bold">Hinge simulation</strong>: While <a id="_idIndexMarker385"/>resizable emulators offer multi-window support and simulate various orientations, they might not accurately replicate the behavior of a physical hinge on foldable devices. The hinge’s physical characteristics and behavior may affect app layouts and interactions differently.</li>
				<li><strong class="bold">Hardware specifics</strong>: Emulators lack physical hardware components present in foldable devices, such as the actual hinge mechanism, flexible displays, sensors, and proprietary features, impacting the true emulation of foldable device behavior.</li>
				<li><strong class="bold">Performance variation</strong>: Emulators<a id="_idIndexMarker386"/> may not accurately represent the performance capabilities of real foldable devices, especially in terms of hardware-specific optimizations and performance characteristics.</li>
				<li><strong class="bold">Real-world testing environment</strong>: Foldable devices may have unique environmental factors that impact user experience, such as external lighting conditions affecting the flexible display. Emulators may not replicate these real-world scenarios accurately.</li>
				<li><strong class="bold">Software emulation versus hardware interaction</strong>: Certain foldable device behaviors, such as drag-and-drop interactions across screens or unique gestures, might not be fully emulated in software due to hardware-specific interactions.</li>
			</ul>
			<p>We have learned how to handle navigation in foldable devices and large screens and how to provide a great user experience as the user is switching between the different screen sizes. This ensures that our app is responsive to different devices and that we satisfactorily use the available screen sizes. The team at Google has published stories of companies that support large screens and foldables; you can have a look here: <a href="https://developer.android.com/large-screens/stories">https://developer.android.com/large-screens/stories</a>.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we have learned how to use the Jetpack Compose Navigation library to navigate to different Jetpack Compose screens within our app. We have also learned tips and best practices for using this library. Additionally, we have covered how to pass arguments as we navigate to screens. Lastly, we have built on what we learned in <a href="B19779_04.xhtml#_idTextAnchor055"><em class="italic">Chapter 4</em></a>, by handling navigation in large screens and foldables in detail.</p>
			<p>We have created <code>FavoritePetsScreen</code>, but as of now it only has a <code>Text</code> label. In the next chapter, we will be adding functionality to persist data locally and retrieve that data locally too without any internet access. We will learn how to save our cute cat photos to Room, another Jetpack library for offline storage, and also add pets to our favorites list.</p>
		</div>
	</div></div></body></html>