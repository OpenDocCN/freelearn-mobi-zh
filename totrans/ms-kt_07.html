<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer099">
			<h1 id="_idParaDest-83" class="chapter-number"><a id="_idTextAnchor092"/>7</h1>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor093"/>Navigating within Your App</h1>
			<p>The apps we make need to move from one screen to the other, showing different content on these screens. So far, we have been making apps with only one screen. In this chapter, we will learn how to move from one screen to the other. We will learn how to use the <strong class="bold">Jetpack Compose Navigation</strong> library to navigate to different Jetpack Compose screens within our app. We will learn the tips and best practices for using this library. Also, we will cover how to pass arguments as we navigate to screens. Lastly, we will build on what we learned in <a href="B19779_04.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, by handling navigation on large screens <span class="No-Break">and foldables.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Jetpack <span class="No-Break">Navigation overview</span></li>
				<li>Navigating to <span class="No-Break">Compose destinations</span></li>
				<li>Passing arguments <span class="No-Break">to destinations</span></li>
				<li>Navigation in foldables and <span class="No-Break">large screens</span></li>
			</ul>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio"><span class="No-Break">https://developer.android.com/studio</span></a><span class="No-Break">) downloaded.</span></p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor095"/>Jetpack Navigation overview</h1>
			<p>The Jetpack Navigation library <a id="_idIndexMarker300"/>provides an API for handling <strong class="bold">complex navigation</strong> with ease while also following the principles of Android Jetpack. The library is available for both the old view system, which uses XML (<a href="https://developer.android.com/guide/navigation">https://developer.android.com/guide/navigation</a>), and Jetpack Compose (<a href="https://developer.android.com/jetpack/compose/navigation">https://developer.android.com/jetpack/compose/navigation</a>). We will be learning about the latter in <span class="No-Break">this chapter.</span></p>
			<p>Still building on<a id="_idIndexMarker301"/> the Pets app we used in the previous chapter, we are going to navigate to a details screen that has a back button to the previous screen. We will also be passing data to the <span class="No-Break">details screen.</span></p>
			<p>To start with, we need to add the Jetpack Navigation Compose dependency to our project. Let’s add the following library inside the <strong class="source-inline">versions</strong> section in our <span class="No-Break"><strong class="source-inline">libs.versions.toml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
compose-navigation = "androidx.navigation:navigation-compose:2.7.2"</pre>			<p>Next, we need to add the dependency to our app module’s <span class="No-Break"><strong class="source-inline">build.gradle.kts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
implementation(libs.compose.navigation)</pre>			<p>Do a Gradle sync to add the library to our project. The next step is to create <strong class="source-inline">NavController</strong> and <strong class="source-inline">NavHost</strong>. <strong class="source-inline">NavController</strong> is a class that manages app navigation within <strong class="source-inline">NavHost</strong>. <strong class="source-inline">NavHost</strong> is a container that hosts composables and handles navigation between them. Let’s create a new package called <strong class="source-inline">navigation</strong> and create a new sealed class called <strong class="source-inline">Screens.kt</strong>. Inside the file, let us add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
sealed class Screens(val route: String) {
    object PetsScreen : Screens("pets")
    object PetDetailsScreen : Screens("petDetails")
}</pre>			<p>This is a sealed class that has two objects. A <a id="_idIndexMarker302"/>sealed class is used to represent restricted class hierarchies wherein the object or value can only have a value among one of the types defined in the sealed class. The first object is <strong class="source-inline">PetsScreen</strong>, which will be the first screen we will see when we launch the app. The second object is <strong class="source-inline">PetDetailsScreen</strong>, which will be the screen we will navigate to when we click on a pet item in <strong class="source-inline">PetsScreen</strong>. Every time we need to add a new destination screen, we will add a new object to the <span class="No-Break">sealed class.</span></p>
			<p>Next, let us <a id="_idIndexMarker303"/>create a new file inside the <strong class="source-inline">navigation</strong> package called <strong class="source-inline">AppNavigation.kt</strong>. Inside the file, let us add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        startDestination =  Screens.PetsScreen.route
    ){
        composable(Screens.PetsScreen.route){
            PetsScreen()
        }
    }
}</pre>			<p>Let’s explain the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li>We create <strong class="source-inline">NavController</strong> using the <strong class="source-inline">rememberNavController()</strong> function. This function is used to create <strong class="source-inline">NavController</strong> that will be remembered across recompositions. This is important because we need to be able to navigate to different screens in <span class="No-Break">our app.</span></li>
				<li>We create a <strong class="source-inline">NavHost</strong> composable that takes in <strong class="source-inline">navController</strong> and <strong class="source-inline">startDestination</strong>. <strong class="source-inline">startDestination</strong> is the first screen we want to see when we launch the app. In our case, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">PetsScreen</strong></span><span class="No-Break">.</span></li>
				<li>We add the <strong class="source-inline">PetsScreen</strong> composable. This composable has an error because we have <a id="_idIndexMarker304"/>not created it yet. We will do <span class="No-Break">that shortly.</span></li>
			</ul>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B19779_07_01.jpg" alt="Figure 7.1 – PetsScreen error" width="691" height="291"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – PetsScreen error</p>
			<p>As seen in the preceding screenshot, the <strong class="source-inline">PetsScreen</strong> composable is highlighted in red because we have not created the composable yet. We will refactor our code a bit. Let us create a new file called <strong class="source-inline">PetsScreen.kt</strong>. Inside the file, let’s add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetsScreen(onPetClicked: (Cat) -&gt; Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pets")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                )
            )
        },
        content =  { paddingValues -&gt;
            PetList(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                onPetClicked = onPetClicked
            )
        }
    )
}</pre>			<p>The <strong class="source-inline">PetsScreen</strong> composable <a id="_idIndexMarker305"/>displays a list of pets. We have added a <strong class="source-inline">Scaffold</strong> composable as the root element. Inside the <strong class="source-inline">Scaffold</strong> composable, we have added a <strong class="source-inline">TopAppBar</strong> composable. We have also added a <strong class="source-inline">PetList</strong> composable as the content of the <strong class="source-inline">Scaffold</strong> composable. We have added a new <strong class="source-inline">onPetClicked</strong> callback to the <strong class="source-inline">PetList</strong> composable. We will be using this callback to navigate to <strong class="source-inline">PetDetailsScreen</strong> when we click on a pet item in <span class="No-Break">the list.</span></p>
			<p>With this, our navigation graph is ready. We can now add the <strong class="source-inline">AppNavigation</strong> composable to our <strong class="source-inline">MainActivity.kt</strong> file. Let’s replace all the code inside the <strong class="source-inline">ChapterSevenTheme</strong> block with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
ChapterSevenTheme {
    AppNavigation()
}</pre>			<p>Build and run the <a id="_idIndexMarker306"/>app. The app still displays a list of cute pets as before, but now we are using the Jetpack Navigation library to handle <span class="No-Break">our navigation.</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B19779_07_02.jpg" alt="Figure 7.2 – Pets" width="509" height="1098"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Pets</p>
			<p>In the next section, let us learn how to navigate to a details screen when we click on a pet item in <span class="No-Break">the list.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor096"/>Navigating to Compose destinations</h1>
			<p>In this <a id="_idIndexMarker307"/>section, we will learn how to navigate to a details screen when we click on a pet item in the list. First, we need to create a new composable for <strong class="source-inline">PetDetailsScreen</strong>. Let us create a new file called <strong class="source-inline">PetDetailsScreen.kt</strong> and create the <strong class="source-inline">PetDetailsScreenContent</strong> composable <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker308"/></span><span class="No-Break">follows:</span></p>
			<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetDetailsScreenContent(modifier: Modifier) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/rV1MVEh0Af2Bm4O0",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        FlowRow(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
        ) {
            repeat(2) {
                SuggestionChip(
                    modifier = Modifier
                        .padding(start = 3.dp, end = 3.dp),
                    onClick = { },
                    label = {
                        Text(text = "Tag $it")
                    }
                )
            }
        }
    }
}</pre>			<p>Here, we<a id="_idIndexMarker309"/> created a composable that has <strong class="source-inline">Column</strong> as the root element. Inside the <strong class="source-inline">Column</strong> element, we added an <strong class="source-inline">AsyncImage</strong> composable that displays a cat image. We also added a <strong class="source-inline">FlowRow</strong> composable to flow items to the next line when space runs out, which cannot be achieved with rows. <strong class="source-inline">FlowRow</strong> displays two <strong class="source-inline">SuggestionChip</strong> composables. We will use this composable to display the details of a pet. Notice we are using hardcoded cat IDs and tags for now. We will pass this data from the <strong class="source-inline">PetList</strong> composable in the next section. Next, let us create the <strong class="source-inline">PetDetailsScreen</strong> composable <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetDetailsScreen(onBackPressed: () -&gt; Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pet Details")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                ),
                navigationIcon = {
                    IconButton(
                        onClick = onBackPressed,
                        content = {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "Back"
                            )
                        }
                    )
                }
            )
        },
        content = { paddingValues -&gt;
            PetDetailsScreenContent(
                modifier = Modifier
                    .padding(paddingValues)
            )
        }
    )
}</pre>			<p>The <strong class="source-inline">PetDetailsScreen</strong> composable<a id="_idIndexMarker310"/> displays the details of a pet. We have added a <strong class="source-inline">Scaffold</strong> composable as the root element. Inside the <strong class="source-inline">Scaffold</strong> composable, we have added a <strong class="source-inline">TopAppBar</strong> composable. We have also used the <strong class="source-inline">PetDetailsScreenContent</strong> composable we created earlier as the content of the <strong class="source-inline">Scaffold</strong> composable. We have added a new <strong class="source-inline">onBackPressed</strong> callback to the <strong class="source-inline">PetDetailsScreen</strong> composable. We will be using this callback to navigate back to the previous screen when we click on the back button <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">TopAppBar</strong></span><span class="No-Break">.</span></p>
			<p>Our next step is to add a composable for <strong class="source-inline">PetDetailsScreen</strong> to our <strong class="source-inline">AppNavigation.kt</strong> file. Let us add the following code to our <strong class="source-inline">NavHost</strong> below the composable <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">PetsScreen</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
composable(Screens.PetDetailsScreen.route){
    PetDetailsScreen(
        onBackPressed = {
            navController.popBackStack()
        }
    )
}</pre>			<p>Here, we have added a composable for <strong class="source-inline">PetDetailsScreen</strong>. We passed in the route for the screen and the <strong class="source-inline">PetDetailsScreen</strong> composable as the content. <strong class="source-inline">PetDetailsScreen</strong> has the <strong class="source-inline">onBackPressed</strong> argument. The argument handles the situation where a user taps the back arrow icon, which is normally at the top left. We use <strong class="source-inline">navController.popBackStack()</strong> inside the <strong class="source-inline">onBackPressed</strong> argument. This method attempts to pop the current destination off the back stack and navigates to the <span class="No-Break">previous destination.</span></p>
			<p>Now we <a id="_idIndexMarker311"/>need to do the actual navigation to <strong class="source-inline">PetDetailsScreen</strong> when we click on a pet item in the list. Let us head over to the <strong class="source-inline">PetListItem</strong> composable. We will add a new <strong class="source-inline">onPetClicked</strong> callback to the <strong class="source-inline">PetListItem</strong> composable. The modified composable should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(cat: Cat, onPetClicked: (Cat) -&gt; Unit) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
                .clickable {
                    onPetClicked(cat)
                }
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
              repeat(cat.tags.size) {
                  SuggestionChip(
                      modifier = Modifier
                          .padding(start = 3.dp, end = 3.dp),
                      onClick = { },
                      label = {
                          Text(text = cat.tags[it])
                      }
                  )
              }
            }
        }
    }
}</pre>			<p>In the preceding code, we have added a new <strong class="source-inline">onPetClicked</strong> callback to the composable. We have added the <strong class="source-inline">clickable</strong> modifier to <strong class="source-inline">Column</strong> and called the <strong class="source-inline">onPetClicked</strong> callback inside the modifier. We pass in the <strong class="source-inline">cat</strong> object to the callback. Next, we<a id="_idIndexMarker312"/> need to add the <strong class="source-inline">onPetClicked</strong> callback to the <strong class="source-inline">PetList</strong> composable, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@Composable
fun PetList(modifier: Modifier, onPetClicked: (Cat) -&gt; Unit) {
    // other code
}</pre>			<p>Next, we need to pass this callback where we use our <strong class="source-inline">PetListItem</strong> composable. The modified <strong class="source-inline">PetListItem</strong> composable at the call site inside the items block should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
PetListItem(
    cat = pet,
    onPetClicked = onPetClicked
)</pre>			<p>Lastly, we need to modify the <strong class="source-inline">AppNavigation</strong> composable to pass the <strong class="source-inline">onPetClicked</strong> callback to the <strong class="source-inline">PetsScreen</strong> composable. The modified <strong class="source-inline">AppNavigation</strong> composable should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
PetsScreen(
    onPetClicked = {
        navController.navigate(Screens.PetDetailsScreen.route)
    }
)</pre>			<p>Here, we pass the <strong class="source-inline">onPetClicked</strong> callback to the <strong class="source-inline">PetsScreen</strong> composable. Inside the callback, we call the <strong class="source-inline">navigate()</strong> function on <strong class="source-inline">navController</strong> and pass in the route for <strong class="source-inline">PetDetailsScreen</strong>. This will navigate to <strong class="source-inline">PetDetailsScreen</strong> when we click on a<a id="_idIndexMarker313"/> pet item in <span class="No-Break">the list.</span></p>
			<p>Build and run the app. Click on a pet item in the list. You will see that the app navigates <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PetDetailsScreen</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B19779_07_03.jpg" alt="Figure 7.3 – Pet Details screen" width="503" height="1033"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Pet Details screen</p>
			<p>We can see a cute <a id="_idIndexMarker314"/>cat image and some tags. Additionally, if we press the back button in <strong class="source-inline">TopAppBar</strong>, we will be able to navigate back <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PetsScreen</strong></span><span class="No-Break">.</span></p>
			<p>So far, we have been able to navigate from <strong class="source-inline">PetsScreen</strong> to <strong class="source-inline">PetDetailsScreen</strong>. However, we are not passing any data to <strong class="source-inline">PetDetailsScreen</strong>. In the next section, we will learn how to pass data <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PetDetailsScreen</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor097"/>Passing arguments to destinations</h1>
			<p>In our <strong class="source-inline">PetDetailsScreen</strong>, we need to remove the hardcoded cat IDs and tags and pass them<a id="_idIndexMarker315"/> from the <strong class="source-inline">PetList</strong> composable. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Let us head <a id="_idIndexMarker316"/>over to the <strong class="source-inline">PetDetailsScreenContent</strong> composable inside the <strong class="source-inline">PetDetailsScreen.kt</strong> file and modify it <span class="No-Break">as follows:</span><pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetDetailsScreenContent(modifier: Modifier, cat: Cat) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/${cat.id}",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        FlowRow(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
        ) {
            repeat(cat.tags.size) {
                SuggestionChip(
                    modifier = Modifier
                        .padding(start = 3.dp, end = 3.dp),
                    onClick = { },
                    label = {
                        Text(text = cat.tags[it])
                    }
                )
            }
        }
    }
}</pre><p class="list-inset">We have <a id="_idIndexMarker317"/>added a new <strong class="source-inline">cat</strong> parameter<a id="_idIndexMarker318"/> to the composable. We have used the <strong class="source-inline">cat</strong> object to display the cat image <span class="No-Break">and tags.</span></p></li>				<li>Next, let us head over to the <strong class="source-inline">PetDetailsScreen</strong> composable and modify it <span class="No-Break">as follows:</span><pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetDetailsScreen(onBackPressed: () -&gt; Unit, cat: Cat) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pet Details")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                ),
                navigationIcon = {
                    IconButton(
                        onClick = onBackPressed,
                        content = {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "Back"
                            )
                        }
                    )
                }
            )
        },
        content = { paddingValues -&gt;
            PetDetailsScreenContent(
                modifier = Modifier
                    .padding(paddingValues),
                cat = cat
            )
        }
    )
}</pre><p class="list-inset">Here, we<a id="_idIndexMarker319"/> have added a new <strong class="source-inline">cat</strong> parameter to the composable. We have passed the <strong class="source-inline">cat</strong> object to the <span class="No-Break"><strong class="source-inline">PetDetailsScreenContent</strong></span><span class="No-Break"> composable.</span></p></li>				<li>Next, let<a id="_idIndexMarker320"/> us head over to the <strong class="source-inline">AppNavigation</strong> composable and add the logic for passing the <strong class="source-inline">cat</strong> object to <strong class="source-inline">PetDetailsScreen</strong>. We need to first modify the composable for <strong class="source-inline">PetDetailsScreen</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
composable(
    route = "${Screens.PetDetailsScreen.route}/{cat}",
    arguments = listOf(
        navArgument("cat") {
            type = NavType.StringType
        }
    )
){
    PetDetailsScreen(
        onBackPressed = {
            navController.popBackStack()
        },
        cat = Json.decodeFromString(it.arguments?.getString("cat") ?: "")
    )
}</pre><p class="list-inset">Let’s<a id="_idIndexMarker321"/> explain <span class="No-Break">the changes:</span></p><ul><li>On the <a id="_idIndexMarker322"/>route, we have added a new parameter called <strong class="source-inline">cat</strong>. This is the parameter we will use to pass the <strong class="source-inline">cat</strong> object <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PetDetailsScreen</strong></span><span class="No-Break">.</span></li><li>We have added a new <strong class="source-inline">arguments</strong> parameter. This parameter is used to pass arguments to the destination screen. We have added <strong class="source-inline">navArgument</strong> for the <strong class="source-inline">cat</strong> parameter. We have set the type to be <strong class="source-inline">String</strong>. This is because we will be passing a string representation of the <span class="No-Break"><strong class="source-inline">cat</strong></span><span class="No-Break"> object.</span></li><li>We pass the <strong class="source-inline">cat</strong> object to the <strong class="source-inline">PetDetailsScreen</strong> composable. We have used <strong class="source-inline">Json.decodeFromString()</strong> from the Kotlinx Serialization library that we learned about in <a href="B19779_06.xhtml#_idTextAnchor084"><em class="italic">Chapter 6</em></a> to convert the string value of the <strong class="source-inline">cat</strong> object into a <strong class="source-inline">Cat</strong> object. We have used the <strong class="source-inline">arguments</strong> property of <strong class="source-inline">NavBackStackEntry</strong> to get the string value of the <strong class="source-inline">cat</strong> object. We have used the Elvis operator to return an empty string if the <strong class="source-inline">arguments</strong> property <span class="No-Break">is null.</span></li></ul></li>				<li>Lastly, we need to modify the <strong class="source-inline">onPetClicked</strong> callback of <strong class="source-inline">PetsScreen</strong> in the <strong class="source-inline">AppNavigation</strong> composable, <span class="No-Break">as follows:</span><pre class="source-code">
composable(Screens.PetsScreen.route) {
    PetsScreen(
        onPetClicked = { cat -&gt;
            navController.navigate(
                "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
            )
        }
    )
}</pre><p class="list-inset">We have <a id="_idIndexMarker323"/>modified the <strong class="source-inline">navigate()</strong> function <a id="_idIndexMarker324"/>to pass the <strong class="source-inline">Cat</strong> object as a string. We also used <strong class="source-inline">Json.encodeToString()</strong> from the Kotlinx Serialization library to convert the <strong class="source-inline">Cat</strong> object into a string. This will be passed as an argument to <strong class="source-inline">PetDetailsScreen</strong> when we click on a pet item in <span class="No-Break">the list.</span></p></li>				<li>Build and run the app. Click on any cute cat picture from the list and now the details screen will display the cat image and tag of the cute cat that <span class="No-Break">we selected:</span></li>
			</ol>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B19779_07_04.jpg" alt="Figure 7.4 – Pet Details" width="503" height="1037"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Pet Details</p>
			<p>We have<a id="_idIndexMarker325"/> now been able to pass data to <strong class="source-inline">PetDetailsScreen</strong>. We <a id="_idIndexMarker326"/>have learned how to navigate to a compose destination and pass data to the details screen. In the next section, we will learn how to handle navigation in foldables and <span class="No-Break">large screens.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor098"/>Navigation in foldables and large screens</h1>
			<p>In the <em class="italic">Designing UIs for large screens and foldables</em> section of <a href="B19779_04.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, we learned<a id="_idIndexMarker327"/> about the <strong class="source-inline">WindowSize</strong> class and how we can make our apps responsive in foldable devices and large screens. In this section, we are going to make our Pets app responsive in foldable devices and<a id="_idIndexMarker328"/> large screens. We are going to make several changes, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Add a bottom bar to <strong class="source-inline">PetsScreen</strong>, which will have <span class="No-Break">several options.</span></li>
				<li>Add <strong class="source-inline">NavigationRail</strong> and <strong class="source-inline">NavigationDrawer</strong>, which will be used depending on the <span class="No-Break">screen size.</span></li>
				<li>Observe the device’s foldable state and change the layout of the app depending on the <span class="No-Break">foldable state.</span></li>
				<li>Depending on the screen size, we will also change the content type. On large screens, we will display the list of cats and the details of the selected cat side by side. On small screens, we will display the list of cats and the details of the selected cat on <span class="No-Break">different screens.</span></li>
			</ul>
			<p>Quite a lot of <a id="_idIndexMarker329"/>changes are required. The good thing is that I have already made the changes and you can find the final version in the <strong class="source-inline">chapterseven</strong> folder in the project’s repository. Let us go through the changes one <span class="No-Break">by one:</span></p>
			<ol>
				<li>We will start by creating a <strong class="source-inline">sealed interface</strong> named <strong class="source-inline">NavigationType</strong> that represents the different types of navigation we will be using in our app. Let us create a new file inside the <strong class="source-inline">navigation</strong> package called <strong class="source-inline">NavigationType.kt</strong> and add the <span class="No-Break">following code:</span><pre class="source-code">
sealed interface NavigationType {
    object BottomNavigation : NavigationType
    object NavigationDrawer : NavigationType
    object NavigationRail : NavigationType
}</pre><p class="list-inset">We are using a sealed interface instead of a sealed class here. This is because we do not need to hold any state in our <strong class="source-inline">NavigationType</strong>. We also do not need to pass properties to any of the <strong class="source-inline">NavigationTypes</strong>. We have three options: <strong class="source-inline">BottomNavigation</strong>, <strong class="source-inline">NavigationDrawer</strong>, and <strong class="source-inline">NavigationRail</strong>. We will be using these options to change the navigation type depending on the <span class="No-Break">screen size.</span></p></li>				<li>Next, let us<a id="_idIndexMarker330"/> create yet another sealed interface called <strong class="source-inline">ContentType</strong>. This interface will be used to change the content display type depending on the screen size. Let us create a new file called <strong class="source-inline">ContentType.kt</strong> still inside the <strong class="source-inline">navigation</strong> package and add the <span class="No-Break">following code:</span><pre class="source-code">
sealed interface ContentType {
    object List : ContentType
    object ListAndDetail : ContentType
}</pre><p class="list-inset">This <a id="_idIndexMarker331"/>represents the two modes in which we can display our content depending on the screen size. We have the <strong class="source-inline">List</strong> mode, which displays the list of cats only. We also have the <strong class="source-inline">ListAndDetail</strong> mode, which displays the list of cats and the details of the selected cat side <span class="No-Break">by side.</span></p></li>				<li>Next, in our <strong class="source-inline">Screens.kt</strong> file, we have to add a new destination screen called <strong class="source-inline">FavoritesScreen</strong>. The final code for the file should look <span class="No-Break">like this:</span><pre class="source-code">
sealed class Screens(val route: String) {
    object PetsScreen : Screens("pets")
    object PetDetailsScreen : Screens("petDetails")
    object FavoritePetsScreen : Screens("favoritePets")
}</pre><p class="list-inset">We now have three destinations for <span class="No-Break">our app.</span></p></li>				<li>Next, let us add the <strong class="source-inline">WindowSize</strong> dependencies to the libraries section in the <span class="No-Break"><strong class="source-inline">libs.versions.toml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
compose-window-size = "androidx.compose.material3:material3-window-size-class:1.2.0-alpha07"
androidx-window = "androidx.window:window:1.1.0"</pre></li>				<li>We also<a id="_idIndexMarker332"/> need to add the dependencies to our app module’s <span class="No-Break"><strong class="source-inline">build.gradle.kts</strong></span><span class="No-Break"> file:</span><pre class="source-code">
implementation(libs.compose.window.size)
implementation(libs.androidx.window)</pre><p class="list-inset">Do a Gradle sync to be able to add the dependencies to <span class="No-Break">our project.</span></p></li>				<li>Next, we <a id="_idIndexMarker333"/>need to create the composables for <strong class="source-inline">NavigationRail</strong>, <strong class="source-inline">NavigationDrawer</strong>, and <strong class="source-inline">BottomNavigation</strong>. Let us create a new file called <strong class="source-inline">PetsNavigationRail.kt</strong> inside the <strong class="source-inline">view</strong> package and add the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun PetsNavigationRail(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    onDrawerClicked: () -&gt; Unit
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    NavigationRail(
        modifier = Modifier
            .fillMaxHeight()
    ) {
        NavigationRailItem(
            selected = false,
            onClick = onDrawerClicked,
            icon = {
                Icon(
                    imageVector = Icons.Default.Menu,
                    contentDescription = "Menu Icon"
                )
            }
        )
        NavigationRailItem(
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationRailItem(
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="list-inset">In the preceding code, we created the <strong class="source-inline">PetsNavigationRail()</strong> composable, which has three parameters: <strong class="source-inline">onFavoriteClicked</strong>, <strong class="source-inline">onHomeClicked</strong>, and <strong class="source-inline">onDrawerClicked</strong>. The first two are callbacks that will be used to navigate to the different screens. We use the <strong class="source-inline">onDrawerClicked</strong> callback to close or open the drawer when the user interacts <a id="_idIndexMarker334"/>with it. At the top, we<a id="_idIndexMarker335"/> have the <strong class="source-inline">items</strong> variable, which holds a list of all our screens, and the <strong class="source-inline">selectedItem</strong> variable, which holds the currently selected screen. We use the <strong class="source-inline">NavigationRail</strong> composable from the Material 3 library to display the navigation rail. To add items to <strong class="source-inline">NavigationRail</strong>, we use the <strong class="source-inline">NavigationRailItem</strong> composable. We pass in the selected state of the item, the <strong class="source-inline">onClick</strong> callback, and the icon <span class="No-Break">to display.</span></p></li>				<li>Next, let us create the <strong class="source-inline">PetsBottomNavigationBar</strong> composable. Let us create a new file called <strong class="source-inline">PetsBottomNavigationBar.kt</strong> inside the <strong class="source-inline">view</strong> package and add the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun PetsBottomNavigationBar(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    NavigationBar(
        modifier = Modifier
            .fillMaxWidth(),
        containerColor = MaterialTheme.colorScheme.background
    ) {
        NavigationBarItem(
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationBarItem(
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="list-inset">The <strong class="source-inline">PetsBottomNavigationBar</strong> composable is similar to the<strong class="source-inline"> PetsNavigationRail</strong> composable. The only difference is that we are using the <strong class="source-inline">NavigationBar</strong> composable instead of the <strong class="source-inline">NavigationRail</strong> composable. We have the home and favorite items. We use the <strong class="source-inline">NavigationBarItem</strong> composable to add items to <strong class="source-inline">NavigationBar</strong>. We pass in the<a id="_idIndexMarker336"/> selected state of the item, the <strong class="source-inline">onClick</strong> callback, and the icon <span class="No-Break">to display.</span></p></li>				<li>Next, let<a id="_idIndexMarker337"/> us create the <strong class="source-inline">PetsNavigationDrawer</strong> composable. Let us create a new file called <strong class="source-inline">PetsNavigationDrawer.kt</strong> inside the <strong class="source-inline">view</strong> package and add the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun PetsNavigationDrawer(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    onDrawerClicked: () -&gt; Unit = {}
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    Column(
        modifier = Modifier
            .wrapContentWidth()
            .fillMaxHeight()
            .background(MaterialTheme.colorScheme.inverseOnSurface)
            .padding(16.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "Chapter Seven",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.primary
            )
            IconButton(
                onClick = onDrawerClicked
            ) {
                Icon(
                    imageVector = Icons.Default.Menu,
                    contentDescription = "Navigation Drawer Icon"
                )
            }
        }
        NavigationDrawerItem(
            label = { Text(text = "Pets") },
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationDrawerItem(
            label = { Text(text = "Favorites") },
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="list-inset">We used the <strong class="source-inline">NavigationDrawer</strong> composable from the Material 3 library to display the navigation drawer. We used the <strong class="source-inline">NavigationDrawerItem</strong> composable to add items to <strong class="source-inline">NavigationDrawer</strong>. We passed in the label, the selected<a id="_idIndexMarker338"/> state of the item, the <strong class="source-inline">onClick</strong> callback, and the icon <span class="No-Break">to display.</span></p></li>				<li>Since <a id="_idIndexMarker339"/>our <strong class="source-inline">PetsNavigationDrawer</strong>, <strong class="source-inline">PetsNavigationRail</strong>, and <strong class="source-inline">PetsBottomNavigationBar</strong> composables have <strong class="source-inline">FavoritesScreen</strong>, let us create a new file called <strong class="source-inline">FavoritePetsScreen.kt</strong> inside the view package and add the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun FavoritePetsScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Favorite Pets")
    }
}</pre><p class="list-inset">This is a simple composable that displays the text <strong class="source-inline">"Favorite Pets"</strong>. We will use this composable as the content of <strong class="source-inline">FavoritesScreen</strong>. We also need to refactor our <strong class="source-inline">AppNavigation()</strong> composable to make it ready to handle the different navigation and content types. The final modified composable should look <span class="No-Break">like this:</span></p><pre class="source-code">@Composable
fun AppNavigation(
    contentType: ContentType,
    navHostController: NavHostController = rememberNavController()
) {
    NavHost(
        navController = navHostController,
        startDestination = Screens.PetsScreen.route
    ) {
        composable(Screens.PetsScreen.route) {
            PetsScreen(
                onPetClicked = { cat -&gt;
                    navHostController.navigate(
                        "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
                    )
                },
                contentType = contentType
            )
        }
        composable(
            route = "${Screens.PetDetailsScreen.route}/{cat}",
            arguments = listOf(
                navArgument("cat") {
                    type = NavType.StringType
                }
            )
        ) {
            PetDetailsScreen(
                onBackPressed = {
                    navHostController.popBackStack()
                },
                cat = Json.decodeFromString(it.arguments?.getString("cat") ?: "")
            )
        }
        composable(Screens.FavoritePetsScreen.route) {
            FavoritePetsScreen()
        }
    }
}</pre><p class="list-inset">Let’s <a id="_idIndexMarker340"/>highlight<a id="_idIndexMarker341"/> <span class="No-Break">the changes:</span></p><ul><li>Our <strong class="source-inline">AppNavigation()</strong> composable now takes in a <strong class="source-inline">contentType</strong> parameter of type <strong class="source-inline">ContentType</strong>. This is the parameter we will use to change the content type depending on the screen size. We also pass in a <strong class="source-inline">navHostController</strong> parameter of type <strong class="source-inline">NavHostController</strong>. This is the parameter we will use to navigate to different screens in our app. Previously, <strong class="source-inline">navHostController</strong> was created inside the <strong class="source-inline">AppNavigation()</strong> composable. We have moved it to the call site so that we can be able to use the same <strong class="source-inline">navHostController</strong> in <span class="No-Break">different composables.</span></li><li>We have used the new <strong class="source-inline">PetsScreen()</strong> composable, which takes in the <strong class="source-inline">contentType</strong> parameter. Same as before, we still pass <strong class="source-inline">onPetClicked</strong>, which navigates to <strong class="source-inline">PetDetailsScreen</strong>. Previously, we were using the <span class="No-Break"><strong class="source-inline">PetList</strong></span><span class="No-Break"> composable.</span></li><li>Lastly, we <a id="_idIndexMarker342"/>have added our new <strong class="source-inline">FavoritePetsScreen</strong> destination to the <span class="No-Break"><strong class="source-inline">NavHost</strong></span><span class="No-Break"> composable.</span></li></ul></li>				<li>Let us see<a id="_idIndexMarker343"/> what the new update <strong class="source-inline">PetsScreen</strong> composable looks like. Let us head over to the <strong class="source-inline">PetsScreen.kt</strong> file and modify the composable <span class="No-Break">as follows:</span><pre class="source-code">
@Composable
fun PetsScreen(
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    PetsScreenContent(
        modifier = Modifier
            .fillMaxSize(),
        onPetClicked = onPetClicked,
        contentType = contentType,
        petsUIState = petsUIState
    )
}</pre><p class="list-inset">We have added a new <strong class="source-inline">contentType</strong> parameter to the composable. We have also added a new <strong class="source-inline">petsUIState</strong> parameter. This is the UI state of <strong class="source-inline">PetsScreen</strong>. We will use this state to display the list <span class="No-Break">of cats.</span></p></li>				<li>Next, create<a id="_idIndexMarker344"/> a new file <a id="_idIndexMarker345"/>called <strong class="source-inline">PetsScreenContent.kt</strong> and add the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun PetsScreenContent(
    modifier: Modifier,
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
    petsUIState: PetsUIState
) {
    Column(
        modifier = modifier
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AnimatedVisibility(
            visible = petsUIState.isLoading
        ) {
            CircularProgressIndicator()
        }
        AnimatedVisibility(
            visible = petsUIState.pets.isNotEmpty()
        ) {
            if (contentType == ContentType.List) {
                PetList(
                    onPetClicked = onPetClicked,
                    pets = petsUIState.pets,
                    modifier = Modifier
                        .fillMaxWidth()
                )
            } else {
                PetListAndDetails(
                    pets = petsUIState.pets
                )
            }
        }
        AnimatedVisibility(
            visible = petsUIState.error != null
        ) {
            Text(text = petsUIState.error ?: "")
        }
    }
}</pre><p class="list-inset">Let’s explain the <span class="No-Break">preceding code:</span></p><ul><li><strong class="source-inline">PetsScreenContent</strong> has a parent <strong class="source-inline">Column</strong> composable. Inside the <strong class="source-inline">Colum</strong>n composable, we have added three <strong class="source-inline">AnimatedVisibility</strong> composables. The first one is used to display <strong class="source-inline">CircularProgressIndicator</strong> when <strong class="source-inline">petsUIState</strong> is loading. The second one is used to display the list of cats when the <strong class="source-inline">pets</strong> variable from <strong class="source-inline">petsUIState</strong> is not empty. The third one is used to display an error message when <strong class="source-inline">petsUIState</strong> has <span class="No-Break">an error.</span></li><li>When<a id="_idIndexMarker346"/> displaying the list of cats, we check <strong class="source-inline">contentType</strong>. If <strong class="source-inline">contentType</strong> is <strong class="source-inline">List</strong>, we display the <strong class="source-inline">PetList</strong> composable. If <strong class="source-inline">contentType</strong> is <strong class="source-inline">ListAndDetail</strong>, we display the <strong class="source-inline">PetListAndDetails</strong> composable. We will create the <strong class="source-inline">PetListAndDetails</strong> composable shortly. Note the <strong class="source-inline">PetList</strong> composable is also modified to take in the <strong class="source-inline">pets</strong> parameter. We will use this parameter to display the list of cats. We will see the <span class="No-Break">changes shortly.</span></li><li>Lastly, we <a id="_idIndexMarker347"/>show the error message if <strong class="source-inline">petsUIState</strong> has <span class="No-Break">an error.</span></li></ul><p class="list-inset">Our updated <strong class="source-inline">PetList</strong> composable should look <span class="No-Break">like this:</span></p><pre class="source-code">@Composable
fun PetList(
    onPetClicked: (Cat) -&gt; Unit,
    pets: List&lt;Cat&gt;,
    modifier: Modifier
) {
    LazyColumn(
        modifier = modifier
    ) {
        items(pets) { pet -&gt;
            PetListItem(
                cat = pet,
                onPetClicked = onPetClicked
            )
        }
    }
}</pre><p class="list-inset">No major<a id="_idIndexMarker348"/> changes here: we have just added the <strong class="source-inline">pets</strong> parameter. We use this parameter to display the list of cats in our <strong class="source-inline">LazyColumn</strong>. With this update, it is time to create the <span class="No-Break"><strong class="source-inline">PetListAndDetails</strong></span><span class="No-Break"> composable.</span></p></li>				<li>Let us <a id="_idIndexMarker349"/>create a new file called <strong class="source-inline">PetListAndDetails.kt</strong> inside the view package and add the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun PetListAndDetails(pets: List&lt;Cat&gt;) {
    var currentPet by remember {
        mutableStateOf(pets.first())
    }
    Row(
        modifier = Modifier
            .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        PetList(
            onPetClicked = {
                currentPet = it
            },
            pets = pets,
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        )
        PetDetailsScreenContent(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
                .weight(1f),
            cat = currentPet
        )
    }
}</pre><p class="list-inset">This <a id="_idIndexMarker350"/>composable has a <strong class="source-inline">Row</strong>, which has two items each with a weight of <strong class="source-inline">1f</strong>. We have used the updated <strong class="source-inline">PetListComposable</strong> and <strong class="source-inline">PetDetailsScreenContent</strong> that we created earlier. We have also added a <strong class="source-inline">currentPet</strong> variable, which holds the currently selected cat. We use this variable to display the details of the selected cat. We also use this variable to update <strong class="source-inline">currentPet</strong> when we click on a pet item in the list. Make sure you also update <strong class="source-inline">PetDetailsScreenContent</strong> to take in the new <span class="No-Break">modifier parameter.</span></p><p class="list-inset">With the<a id="_idIndexMarker351"/> modifications we have made, let us now create a new composable called <strong class="source-inline">AppNavigationContent</strong>, which has logic for displaying <strong class="source-inline">NavigationRail</strong> or <strong class="source-inline">BottomNavigation</strong> depending <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">NavigationType</strong></span><span class="No-Break">.</span></p></li>				<li>Let us <a id="_idIndexMarker352"/>create a new file called <strong class="source-inline">AppNavigationContent.kt</strong> inside the navigation package and add the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun AppNavigationContent(
    contentType: ContentType,
    navigationType: NavigationType,
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    navHostController: NavHostController,
    onDrawerClicked: () -&gt; Unit = {}
) {
    Row(
        modifier = Modifier
            .fillMaxSize(),
    ) {
        AnimatedVisibility(
            visible = navigationType == NavigationType.NavigationRail
        ) {
            PetsNavigationRail(
                onFavoriteClicked = onFavoriteClicked,
                onHomeClicked = onHomeClicked,
                onDrawerClicked = onDrawerClicked
            )
        }
        Scaffold(
            content = { paddingValues -&gt;
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                ) {
                    AppNavigation(
                        contentType = contentType,
                        navHostController = navHostController
                    )
                }
            },
            bottomBar = {
                AnimatedVisibility(
                    visible = navigationType == NavigationType.BottomNavigation
                ) {
                    PetsBottomNavigationBar(
                        onFavoriteClicked = onFavoriteClicked,
                        onHomeClicked = onHomeClicked
                    )
                }
            }
        )
    }
}</pre><p class="list-inset">Let’s <a id="_idIndexMarker353"/>explain the <span class="No-Break">preceding code:</span></p><ul><li>The <strong class="source-inline">AppNavigationContent</strong> composable takes a number of parameters. The <strong class="source-inline">contentType </strong>parameter is used to display the content type. The <strong class="source-inline">navigationType</strong> parameter is used to toggle the navigation options. <strong class="source-inline">onFavoriteClicked</strong> and <strong class="source-inline">onHomeClicked</strong> are callbacks that will be <a id="_idIndexMarker354"/>used to navigate to the different screens. <strong class="source-inline">navHostController</strong> is an object that manages navigation within the <strong class="source-inline">NavHost</strong> <strong class="source-inline">onDrawerClicked</strong> is used to close or open the drawer when the user interacts <span class="No-Break">with it.</span></li><li>We have <strong class="source-inline">Row</strong> as the root element. Inside <strong class="source-inline">Row</strong>, we have an <strong class="source-inline">AnimatedVisibility</strong> composable that displays the <strong class="source-inline">PetsNavigationRail</strong> composable when <strong class="source-inline">navigationType</strong> is <strong class="source-inline">NavigationType</strong>.<strong class="source-inline">NavigationRail</strong>. We have also added a <strong class="source-inline">Scaffold</strong> composable. We have used the <strong class="source-inline">AppNavigation</strong> composable as the content of <strong class="source-inline">Scaffold</strong>, passing in <strong class="source-inline">contentType</strong> and <strong class="source-inline">navHostController</strong>. We have also used the <strong class="source-inline">PetsBottomNavigationBar</strong> composable as the bottom bar of <strong class="source-inline">Scaffold</strong>. We have used the <strong class="source-inline">AnimatedVisibility</strong> composable to display the <strong class="source-inline">PetsBottomNavigationBar</strong> composable when <strong class="source-inline">navigationType</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">NavigationType.BottomNavigation</strong></span><span class="No-Break">.</span></li></ul></li>				<li>The last step<a id="_idIndexMarker355"/> is to refactor the <strong class="source-inline">MainActivity.kt</strong> file to use the new <strong class="source-inline">AppNavigationContent</strong> composable. We will walk through the changes step by step. There<a id="_idIndexMarker356"/> are <span class="No-Break">several changes:</span><ol><li class="upper-roman">To begin with, we need to observe the device’s foldable state. This will enable us to change the content type and navigation type. Let us create a new file called <strong class="source-inline">DeviceFoldPosture.kt</strong> inside the <strong class="source-inline">navigation</strong> package and add the <span class="No-Break">following code:</span></li></ol><pre class="source-code">
sealed interface DeviceFoldPosture {
    data class BookPosture(val hingePosition: Rect) : DeviceFoldPosture
    data class SeparatingPosture(
        val hingePosition: Rect,
        val orientation: FoldingFeature.Orientation
    ) : DeviceFoldPosture
    object NormalPosture : DeviceFoldPosture
}
@OptIn(ExperimentalContracts::class)
fun isBookPosture(foldFeature: FoldingFeature?): Boolean {
    contract { returns(true) implies (foldFeature != null) }
    return foldFeature?.state == FoldingFeature.State.HALF_OPENED &amp;&amp;
            foldFeature.orientation == FoldingFeature.Orientation.VERTICAL
}
@OptIn(ExperimentalContracts::class)
fun isSeparating(foldFeature: FoldingFeature?): Boolean {
    contract { returns(true) implies (foldFeature != null) }
    return foldFeature?.state == FoldingFeature.State.FLAT &amp;&amp; foldFeature.isSeparating
}</pre><p class="list-inset">In the<a id="_idIndexMarker357"/> preceding code, we have<a id="_idIndexMarker358"/> a sealed interface that represents the different postures a foldable device can be in. We have <strong class="source-inline">BookPosture</strong>, which represents the posture when the device is in portrait orientation and its fold state is half opened. We have <strong class="source-inline">SeparatingPosture</strong>, which represents the posture when the fold or hinge device creates two logical display areas. We also have <strong class="source-inline">NormalPosture</strong>, which represents the posture when the device is not folded. We have two utility functions, <strong class="source-inline">isBookPosture()</strong> and <strong class="source-inline">isSeparating()</strong>, which are used to check the posture of the device. We will use these functions to check the posture of<a id="_idIndexMarker359"/> the device and change the layout of the app depending on <span class="No-Break">the posture.</span></p><ol><li class="upper-roman" value="2">Let us head over to the <strong class="source-inline">MainActivity.kt</strong> file and add the following code <a id="_idIndexMarker360"/>before the <span class="No-Break"><strong class="source-inline">setContent</strong></span><span class="No-Break"> block:</span></li></ol><pre class="source-code">val deviceFoldingPostureFlow = WindowInfoTracker.getOrCreate(this).windowLayoutInfo(this)
    .flowWithLifecycle(this.lifecycle)
    .map { layoutInfo -&gt;
        val foldingFeature =
            layoutInfo.displayFeatures
                .filterIsInstance&lt;FoldingFeature&gt;()
                .firstOrNull()
        when {
            isBookPosture(foldingFeature) -&gt;
                DeviceFoldPosture.BookPosture(foldingFeature.bounds)
            isSeparating(foldingFeature) -&gt;
                DeviceFoldPosture.SeparatingPosture(
                    foldingFeature.bounds,
                    foldingFeature.orientation
                )
            else -&gt; DeviceFoldPosture.NormalPosture
        }
    }
    .stateIn(
        scope = lifecycleScope,
        started = SharingStarted.Eagerly,
        initialValue = DeviceFoldPosture.NormalPosture
    )</pre><p class="list-inset">Here, we use <strong class="source-inline">WindowInfoTracker</strong> to get the window layout info. We use <strong class="source-inline">flowWithLifecycle()</strong> to make sure we only get the layout info when the activity is in <a id="_idIndexMarker361"/>the correct life cycle state. We then use the <strong class="source-inline">map</strong> operator to map the layout <a id="_idIndexMarker362"/>info to the different postures. We use the <strong class="source-inline">stateIn()</strong> operator, which converts a cold <strong class="source-inline">Flow</strong> into a hot <strong class="source-inline">StateFlow</strong> that is started in the given coroutine scope, sharing the most recently emitted value of device posture. We use <strong class="source-inline">SharingStarted.Eagerly</strong> to make sure we get the latest value of the posture when the activity is in the started state. We use the <strong class="source-inline">initialValue</strong> parameter to set the initial value of the posture to <strong class="source-inline">DeviceFoldPosture.NormalPosture</strong>. We will use this flow to observe the device’s posture and change the app’s layout depending on <span class="No-Break">the posture.</span></p><ol><li class="upper-roman" value="3">Next, inside our <strong class="source-inline">setcontent</strong> block, we need to add the variables before the <span class="No-Break">theme block:</span></li></ol><pre class="source-code">val devicePosture = deviceFoldingPostureFlow.collectAsStateWithLifecycle().value
val windowSizeClass = calculateWindowSizeClass(activity = this)
val scope = rememberCoroutineScope()
val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
val navController = rememberNavController()</pre><p class="list-inset">We have <a id="_idIndexMarker363"/>added the <strong class="source-inline">devicePosture</strong> variable, which holds the posture of the device. We have also added the <strong class="source-inline">windowSizeClass</strong> variable, which holds the window size class of the device; the <strong class="source-inline">scope</strong> variable, which holds <strong class="source-inline">CoroutineScope</strong>; the <strong class="source-inline">drawerState</strong> variable, which holds the state of the drawer; and the <strong class="source-inline">navController</strong> variable, which holds <strong class="source-inline">NavHostController</strong>. We will use this variable to navigate to different screens in <span class="No-Break">our app.</span></p><ol><li class="upper-roman" value="4">Inside<a id="_idIndexMarker364"/> our <strong class="source-inline">ChapterSevenTheme</strong>, we need to add the <span class="No-Break">following code:</span></li></ol><pre class="source-code">val navigationType: NavigationType
val contentType: ContentType
when (windowSizeClass.widthSizeClass) {
    WindowWidthSizeClass.Compact -&gt; {
        navigationType = NavigationType.BottomNavigation
        contentType = ContentType.List
    }
    WindowWidthSizeClass.Medium -&gt; {
        navigationType = NavigationType.NavigationRail
        contentType = if (devicePosture is DeviceFoldPosture.BookPosture
            || devicePosture is DeviceFoldPosture.SeparatingPosture
        ) {
            ContentType.ListAndDetail
        } else {
            ContentType.List
        }
    }
    WindowWidthSizeClass.Expanded -&gt; {
        navigationType = if (devicePosture is DeviceFoldPosture.BookPosture) {
            NavigationType.NavigationRail
        } else {
            NavigationType.NavigationDrawer
        }
        contentType = ContentType.ListAndDetail
    }
    else -&gt; {
        navigationType = NavigationType.BottomNavigation
        contentType = ContentType.List
    }
}</pre><p class="list-inset">Here, we<a id="_idIndexMarker365"/> have two <a id="_idIndexMarker366"/>variables: <strong class="source-inline">navigationType</strong> and <strong class="source-inline">contentType</strong>. We use <strong class="source-inline">windowSizeClass</strong> to get the width of our device and, depending on the width size, we assign the values for our <strong class="source-inline">navigationType</strong> and <span class="No-Break"><strong class="source-inline">contentType</strong></span><span class="No-Break"> variables:</span></p><ul><li>If the width size is <strong class="source-inline">Compact</strong>, we use <strong class="source-inline">BottomNavigation</strong> for <strong class="source-inline">navigationType</strong> and <strong class="source-inline">List</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">contentType</strong></span><span class="No-Break">.</span></li><li>If the width size is <strong class="source-inline">Medium</strong>, we use <strong class="source-inline">NavigationRail</strong> for <strong class="source-inline">navigationType</strong>. For <strong class="source-inline">contentType</strong>, we check <strong class="source-inline">devicePosture</strong>. If <strong class="source-inline">devicePosture</strong> is <strong class="source-inline">DeviceFoldPosture.BookPosture</strong> or <strong class="source-inline">DeviceFoldPosture.SeparatingPosture</strong>, we use <strong class="source-inline">ListAndDetail</strong> for <strong class="source-inline">contentType</strong>. If <strong class="source-inline">devicePosture</strong> is not <strong class="source-inline">DeviceFoldPosture.BookPosture</strong> or <strong class="source-inline">DeviceFoldPosture.SeparatingPosture</strong>, we use <strong class="source-inline">List</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">contentType</strong></span><span class="No-Break">.</span></li><li>If the <a id="_idIndexMarker367"/>width size is <strong class="source-inline">Expanded</strong>, we check <strong class="source-inline">devicePosture</strong>. If <strong class="source-inline">devicePosture</strong> is <strong class="source-inline">DeviceFoldPosture.BookPosture</strong>, we use <strong class="source-inline">NavigationRail</strong> for <strong class="source-inline">navigationType</strong>. If <strong class="source-inline">devicePosture</strong> is not <strong class="source-inline">DeviceFoldPosture.BookPosture</strong>, we use <strong class="source-inline">NavigationDrawer</strong> for <strong class="source-inline">navigationType</strong>. We use <strong class="source-inline">ListAndDetail</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">contentType</strong></span><span class="No-Break">.</span></li><li>Lastly, if the width size is anything else, we use <strong class="source-inline">BottomNavigation</strong> for <strong class="source-inline">navigationType</strong> and <strong class="source-inline">List</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">contentType</strong></span><span class="No-Break">.</span></li></ul><ol><li class="upper-roman" value="5">Below <a id="_idIndexMarker368"/>the preceding code, add this <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statement:</span></li></ol><pre class="source-code">if (navigationType == NavigationType.NavigationDrawer) {
    PermanentNavigationDrawer(
        drawerContent = {
            PermanentDrawerSheet {
                PetsNavigationDrawer(
                    onFavoriteClicked = {
                        navController.navigate(Screens.FavoritePetsScreen.route)
                    },
                    onHomeClicked = {
                        navController.navigate(Screens.PetsScreen.route)
                    }
                )
            }
        }
    ) {
        AppNavigationContent(
            navigationType = navigationType,
            contentType = contentType,
            onFavoriteClicked = {
                navController.navigate(Screens.FavoritePetsScreen.route)
            },
            onHomeClicked = {
                navController.navigate(Screens.PetsScreen.route)
            },
            navHostController = navController
        )
    }
}</pre><p class="list-inset">The <a id="_idIndexMarker369"/>condition checks whether <strong class="source-inline">navigationType</strong> is <strong class="source-inline">NavigationType.NavigationDrawer</strong>. If it is, we use the <strong class="source-inline">PermanentNavigationDrawer</strong> composable from the Material 3 library. We use the <strong class="source-inline">PetsNavigationDrawer</strong> composable that we created for <strong class="source-inline">drawerContent</strong>. We use the <strong class="source-inline">AppNavigationContent</strong> composable as the content of <strong class="source-inline">PermanentNavigationDrawer</strong>. We pass in the <strong class="source-inline">navigationType</strong>, <strong class="source-inline">contentType</strong>, <strong class="source-inline">onFavoriteClicked</strong>, <strong class="source-inline">onHomeClicked</strong>, and <span class="No-Break"><strong class="source-inline">navHostController</strong></span><span class="No-Break"> parameters.</span></p><ol><li class="upper-roman" value="6">Next, let <a id="_idIndexMarker370"/>us add the <strong class="source-inline">else</strong> condition for our <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statement:</span></li></ol><pre class="source-code">else {
  ModalNavigationDrawer(
      drawerContent = {
          ModalDrawerSheet {
              PetsNavigationDrawer(
                  onFavoriteClicked = {
                      navController.navigate(Screens.FavoritePetsScreen.route)
                  },
                  onHomeClicked = {
                      navController.navigate(Screens.PetsScreen.route)
                  },
                  onDrawerClicked = {
                      scope.launch {
                          drawerState.close()
                      }
                  }
              )
          }
      },
      drawerState = drawerState
  ) {
      AppNavigationContent(
          navigationType = navigationType,
          contentType = contentType,
          onFavoriteClicked = {
              navController.navigate(Screens.FavoritePetsScreen.route)
          },
          onHomeClicked = {
              navController.navigate(Screens.PetsScreen.route)
          },
          navHostController = navController,
          onDrawerClicked = {
              scope.launch {
                  drawerState.open()
              }
          }
      )
  }
}</pre><p class="list-inset">Here, when <strong class="source-inline">navigationType</strong> is not <strong class="source-inline">NavigationType.NavigationDrawer</strong>, we use the <strong class="source-inline">ModalNavigationDrawer</strong> composable from the Material 3 library. We use the <strong class="source-inline">PetsNavigationDrawer</strong> composable for <strong class="source-inline">drawerContent</strong>. We use the <strong class="source-inline">AppNavigationContent</strong> composable as the content of <strong class="source-inline">ModalNavigationDrawer</strong>. We pass in the <strong class="source-inline">navigationType</strong>,<strong class="source-inline"> contentType</strong>, <strong class="source-inline">onFavoriteClicked</strong>, <strong class="source-inline">onHomeClicked</strong>, and <strong class="source-inline">navHostController</strong> parameters. We also pass in the <strong class="source-inline">drawerState</strong> parameter. We use the <strong class="source-inline">onDrawerClicked</strong> callback to open or close the drawer when the user interacts <span class="No-Break">with it.</span></p></li>			</ol>
			<p>Those <a id="_idIndexMarker371"/>were a<a id="_idIndexMarker372"/> lot of changes; great work on adding them! We now need to run these changes and see them into action. Luckily, we have a <strong class="bold">resizable emulator</strong> to help test these changes. We will be creating one and testing the app in the <span class="No-Break">next subsection.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor099"/>Creating and using the resizable emulator</h2>
			<p>To create and <a id="_idIndexMarker373"/>use the resizable emulator, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Open the <strong class="bold">Device Manager</strong> window<a id="_idIndexMarker374"/> from the right sidebar in Android Studio. If you cannot find it there, use the <strong class="bold">View</strong> menu option at the top and select <strong class="bold">Tool Windows</strong>; then, you will see the <strong class="bold">Device </strong><span class="No-Break"><strong class="bold">Manager</strong></span><span class="No-Break"> option.</span></li>
			</ol>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B19779_07_05.jpg" alt="Figure 7.5 – Device Manager" width="770" height="494"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Device Manager</p>
			<ol>
				<li value="2">Select <a id="_idIndexMarker375"/>the <strong class="bold">Virtual</strong> devices tab and click on <strong class="bold">Create Device</strong>, which brings you this <span class="No-Break">pop-up window:</span></li>
			</ol>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B19779_07_06.jpg" alt="Figure 7.6 – New device configurations" width="1170" height="544"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – New device configurations</p>
			<p class="list-inset">The window enables you to customize the properties of the device you want to create. You can change the device category and you also select the device you want <span class="No-Break">to create.</span></p>
			<ol>
				<li value="3">Let us <a id="_idIndexMarker376"/>select the <strong class="bold">Resizable (Experimental)</strong> option under the <strong class="bold">Phone</strong> category. This will enable us to create a resizable device. Click <strong class="bold">Next</strong> and you will see the <span class="No-Break">following window:</span></li>
			</ol>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B19779_07_07.jpg" alt="Figure 7.7 – System Image" width="1030" height="514"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – System Image</p>
			<ol>
				<li value="4">Here, you select the system image you want to use. Let us select the <strong class="bold">API 34</strong> system image. Click <strong class="bold">Next</strong> and you will see the <span class="No-Break">following window:</span></li>
			</ol>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B19779_07_08.jpg" alt="Figure 7.8 – Device information" width="1010" height="507"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Device information</p>
			<p class="list-inset">This is the <a id="_idIndexMarker377"/>last step where you confirm the device name and the device orientation. We will maintain the name generated and use portrait as the <span class="No-Break">default orientation.</span></p>
			<ol>
				<li value="5">Click <strong class="bold">Finish</strong> and you will see the device has been added to your list <span class="No-Break">of devices:</span></li>
			</ol>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B19779_07_09.jpg" alt="Figure 7.9 – Devices list" width="748" height="259"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Devices list</p>
			<ol>
				<li value="6">Start the emulator and run <span class="No-Break">the app.</span></li>
			</ol>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B19779_07_10.jpg" alt="Figure 7.10 – Resizable emulator" width="592" height="1146"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Resizable emulator</p>
			<p>From the emulator, we<a id="_idIndexMarker378"/> can see we have two options highlighted. The first one allows us to change the device from a small/normal device to a foldable or tablet device. The second one allows us to change the options when we change to a foldable device. Let us change the device to a foldable device. The app now changes the navigation option to navigation rail and the screen has a list and details of the first cat <span class="No-Break">opened too.</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B19779_07_11.jpg" alt="Figure 7.11 – Foldable device navigation rail" width="880" height="1099"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Foldable device navigation rail</p>
			<p>On tapping the <strong class="bold">Foldable</strong> options, we <a id="_idIndexMarker379"/>can see the <span class="No-Break">following options:</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B19779_07_12.jpg" alt="Figure 7.12 – Foldable options" width="59" height="194"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Foldable options</p>
			<p>Selecting the<a id="_idIndexMarker380"/> second option in the foldables section brings us to the <span class="No-Break">following screen:</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B19779_07_13.jpg" alt="Figure 7.13 – Foldable device" width="880" height="1099"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Foldable device</p>
			<p>From the<a id="_idIndexMarker381"/> device size option, we can also switch to <span class="No-Break">tablet view:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B19779_07_14.jpg" alt="Figure 7.14 – Tablet view" width="1100" height="688"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Tablet view</p>
			<p>You can see<a id="_idIndexMarker382"/> the app now has a permanent navigation drawer and the screen has a list and details of the first cat opened too. Tap a different cat and you will see the details of the cat displayed on the right side of the screen. We can also navigate to the <strong class="bold">Favorites</strong> screen and back to the <span class="No-Break"><strong class="bold">Pets</strong></span><span class="No-Break"> screen.</span></p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B19779_07_15.jpg" alt="Figure 7.15 – Favorite Pets screen" width="1084" height="488"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Favorite Pets screen</p>
			<p>We can also see <a id="_idIndexMarker383"/>the modal <span class="No-Break">navigation drawer:</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B19779_07_16.jpg" alt="Figure 7.16 – Modal navigation drawer" width="877" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Modal navigation drawer</p>
			<p>The resizable emulator<a id="_idIndexMarker384"/> is a great way for us to test our app across different device sizes, but it has its own limitations. The following are the limitations of <span class="No-Break">resizable emulators:</span></p>
			<ul>
				<li><strong class="bold">Hinge simulation</strong>: While <a id="_idIndexMarker385"/>resizable emulators offer multi-window support and simulate various orientations, they might not accurately replicate the behavior of a physical hinge on foldable devices. The hinge’s physical characteristics and behavior may affect app layouts and <span class="No-Break">interactions differently.</span></li>
				<li><strong class="bold">Hardware specifics</strong>: Emulators lack physical hardware components present in foldable devices, such as the actual hinge mechanism, flexible displays, sensors, and proprietary features, impacting the true emulation of foldable <span class="No-Break">device behavior.</span></li>
				<li><strong class="bold">Performance variation</strong>: Emulators<a id="_idIndexMarker386"/> may not accurately represent the performance capabilities of real foldable devices, especially in terms of hardware-specific optimizations and <span class="No-Break">performance characteristics.</span></li>
				<li><strong class="bold">Real-world testing environment</strong>: Foldable devices may have unique environmental factors that impact user experience, such as external lighting conditions affecting the flexible display. Emulators may not replicate these real-world <span class="No-Break">scenarios accurately.</span></li>
				<li><strong class="bold">Software emulation versus hardware interaction</strong>: Certain foldable device behaviors, such as drag-and-drop interactions across screens or unique gestures, might not be fully emulated in software due to <span class="No-Break">hardware-specific interactions.</span></li>
			</ul>
			<p>We have learned how to handle navigation in foldable devices and large screens and how to provide a great user experience as the user is switching between the different screen sizes. This ensures that our app is responsive to different devices and that we satisfactorily use the available screen sizes. The team at Google has published stories of companies that support large screens and foldables; you can have a look <span class="No-Break">here: </span><a href="https://developer.android.com/large-screens/stories"><span class="No-Break">https://developer.android.com/large-screens/stories</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we have learned how to use the Jetpack Compose Navigation library to navigate to different Jetpack Compose screens within our app. We have also learned tips and best practices for using this library. Additionally, we have covered how to pass arguments as we navigate to screens. Lastly, we have built on what we learned in <a href="B19779_04.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, by handling navigation in large screens and foldables <span class="No-Break">in detail.</span></p>
			<p>We have created <strong class="source-inline">FavoritePetsScreen</strong>, but as of now it only has a <strong class="source-inline">Text</strong> label. In the next chapter, we will be adding functionality to persist data locally and retrieve that data locally too without any internet access. We will learn how to save our cute cat photos to Room, another Jetpack library for offline storage, and also add pets to our <span class="No-Break">favorites list.</span></p>
		</div>
	</div></div></body></html>