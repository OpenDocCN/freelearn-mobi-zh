- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Adding Video and Editing Functionality to Packtagram
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Packtagram添加视频和编辑功能
- en: 'Having already mastered the art of capturing stunning photographs and applying
    mesmerizing filters with CameraX, it’s time to elevate our Packtagram app to new
    heights. Now, we will embark on an exciting new venture: diving into the world
    of video.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在已经掌握了捕捉令人惊叹的照片和用CameraX应用迷人滤镜的技艺之后，现在是时候将我们的Packtagram应用提升到新的高度了。现在，我们将开始一项激动人心的全新冒险：深入视频的世界。
- en: Videos are not just moving pictures; they are powerful storytelling tools that
    breathe life into our apps. They create dynamic interactions, keeping users engaged
    and offering them a canvas to express creativity. In this chapter, we’ll guide
    you through the process of integrating video capabilities into your app, akin
    to adding a new dimension to the Instagram-like experience we have been crafting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 视频不仅仅是移动的图片；它们是强大的叙事工具，为我们的应用注入生命。它们创造动态交互，保持用户的参与度，并为他们提供一个表达创造力的画布。在本章中，我们将引导你通过将视频功能集成到你的应用中的过程，就像为我们在构建的Instagram-like体验中添加一个新维度一样。
- en: We will start by exploring how to capture high-quality videos using the CameraX
    library, an extension of the skills you’ve already honed for photo capture. Then,
    we’ll delve into the world of **Fast Forward Moving Picture Expert Group** (**Ffmpeg**),
    a robust library for video processing, to add layers of creativity to your videos
    – from simple captions that convey messages to sophisticated filters that transform
    the visual mood.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何使用CameraX库（它是你已熟练掌握的用于照片捕捉技能的扩展）捕捉高质量的视频。然后，我们将深入**快速前进运动图像专家组**（**FFmpeg**）的世界，这是一个用于视频处理的强大库，为你的视频添加创意层次——从传达信息的简单字幕到改变视觉情绪的复杂滤镜。
- en: You’ll learn to not only capture and edit videos but also to efficiently upload
    them to Firebase Storage, ensuring that your app can handle large files seamlessly
    and provide a smooth user experience.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何不仅捕捉和编辑视频，而且高效地将它们上传到Firebase存储，确保你的应用能够无缝处理大文件并提供流畅的用户体验。
- en: By the end of this chapter, you will have added a significant feature to your
    app, making it not just a photo-sharing platform but a comprehensive multimedia
    experience.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将为你的应用添加一个显著的功能，使其不仅仅是一个照片分享平台，而是一个全面的多媒体体验。
- en: 'To accomplish that, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，在本章中，我们将涵盖以下主题：
- en: Adding video functionality to our app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用添加视频功能
- en: Getting to know FFmpeg
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解FFmpeg
- en: Adding a caption to a video with FFmpeg
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FFmpeg为视频添加字幕
- en: Adding a filter to a video with FFmpeg
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FFmpeg为视频添加滤镜
- en: Uploading the video
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传视频
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have installed Android Studio (or
    another editor of your preference).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，你需要安装Android Studio（或你偏好的其他编辑器）。
- en: 'You can find the complete code that we will be using in this chapter in this
    book’s GitHub repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-6](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-6).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章我们将使用的完整代码：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-6](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-6)。
- en: Adding video functionality to our app
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用添加视频功能
- en: In this section, we will extend the functionality of our Android app so that
    it includes video-capturing capabilities through CameraX. This powerful library
    not only simplifies the process of capturing photos but also provides an efficient
    way to record videos. We’ll start by adapting our existing CameraX setup, which
    is designed for capturing photos, to also handle video recording. The aim is to
    provide a seamless integration, maintaining the simplicity and robustness of CameraX.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将扩展我们的Android应用功能，使其包括通过CameraX的视频捕捉能力。这个强大的库不仅简化了捕捉照片的过程，还提供了一种高效记录视频的方法。我们将首先调整现有的CameraX设置，该设置是为捕捉照片设计的，使其也能处理视频录制。目标是提供无缝集成，保持CameraX的简单性和健壮性。
- en: 'First, we need to set up the preview for the video recording. In the previous
    chapter, we created a `CameraPreview` composable. We’ll reuse the same composable
    here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置视频录制的预览。在上一章中，我们创建了一个`CameraPreview`可组合组件。我们将在这里重用相同的组件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to create a new button composable to record images and sound from
    the preview (instead of just capturing the image):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的按钮组件，用于从预览中记录图像和声音（而不是仅仅捕获图像）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are creating a new composable called `CaptureVideoButton`. It is similar
    to the `CaptureButton` composable but with some modifications. For example, now,
    we’ll need to create a variable recording. The `Recording` class in CameraX is
    responsible for managing an active video recording session. It encapsulates the
    state and operations needed to start, pause, resume, and stop the recording. In
    our code, the `recording` variable will be used to manage the current recording
    session.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个新的名为`CaptureVideoButton`的组件。它与`CaptureButton`组件类似，但有一些修改。例如，现在我们需要创建一个可变录制。CameraX中的`Recording`类负责管理一个活动的视频录制会话。它封装了启动、暂停、恢复和停止录制所需的状态和操作。在我们的代码中，`recording`变量将用于管理当前的录制会话。
- en: Once the user clicks the button, we’ll configure the video capture use case,
    `cameraController.setEnabledUseCases(LifecycleCameraController.VIDEO_CAPTURE)`,
    so that `cameraController` can start and manage the video recording process, ensuring
    that the camera is correctly set up for capturing high-quality video and enabling
    the necessary configurations and resources for the recording session to proceed
    smoothly. Then, if a recording hasn’t been already initiated, we’ll start a new
    recording. If it has already been initiated, we’ll stop it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户点击按钮，我们将配置视频捕获用例`cameraController.setEnabledUseCases(LifecycleCameraController.VIDEO_CAPTURE)`，以便`cameraController`可以开始并管理视频录制过程，确保摄像头正确设置以捕获高质量视频，并启用录制会话顺利进行的必要配置和资源。然后，如果没有已经开始录制，我们将启动一个新的录制。如果已经启动，我们将停止它。
- en: The icon of the button will show a camera prior to the recording being initiated
    and a stop button if the recording is already in progress, to indicate to the
    user that they should click it to stop the recording.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始录制之前，按钮的图标将显示一个摄像头，如果录制已经开始，则显示一个停止按钮，以提示用户点击它来停止录制。
- en: 'To finish this recording functionality, we need to implement the `startRecording`
    function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此录制功能，我们需要实现`startRecording`函数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is marked with the `@SuppressLint("MissingPermission")` annotation,
    indicating an assumption that the necessary runtime permissions, such as access
    to the camera and microphone, have already been granted. We will handle these
    permissions the same way we did with the photo capture, so the annotation is safe
    to use here as the permissions would have already been granted.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能使用`@SuppressLint("MissingPermission")`注解标记，表示假设必要的运行时权限，如访问摄像头和麦克风，已经获得授权。我们将以与照片捕获相同的方式处理这些权限，因此在此处使用注解是安全的，因为权限已经获得授权。
- en: The function begins by defining the location and filename for the video recording.
    It uses the `File` class to create a reference to a `video_${System.currentTimeMillis()}.mp4`
    file, which is stored in the app-specific directory on the external storage. This
    approach to file storage is advantageous as it does not require additional permissions
    and ensures that the stored data is private to the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先定义视频录制的位置和文件名。它使用`File`类创建一个指向`video_${System.currentTimeMillis()}.mp4`文件的引用，该文件存储在外部存储的应用特定目录中。这种文件存储方法的优势在于它不需要额外的权限，并确保存储的数据对应用程序是私有的。
- en: 'Next, the code sets up `FileOutputOptions` using the previously defined file.
    This step is crucial as it configures how the recorded video data will be written
    to the filesystem. The `FileOutputOptions` class, part of the CameraX library,
    offers an intuitive API to set these parameters efficiently – for example, it
    allows us to specify the video location using `ContentResolver` (you can find
    additional information about `FileOutputOptions` here: [https://developer.android.com/reference/androidx/camera/video/FileOutputOptions](https://developer.android.com/reference/androidx/camera/video/FileOutputOptions)).
    Next, the audio configuration is created, in this case to allow audio using `AudioConfig.create(true)`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码使用之前定义的文件设置`FileOutputOptions`。这一步至关重要，因为它配置了记录的视频数据将如何写入文件系统。`FileOutputOptions`类是CameraX库的一部分，提供了一个直观的API来高效地设置这些参数
    - 例如，它允许我们使用`ContentResolver`指定视频位置（你可以在[https://developer.android.com/reference/androidx/camera/video/FileOutputOptions](https://developer.android.com/reference/androidx/camera/video/FileOutputOptions)找到有关`FileOutputOptions`的更多信息）。接下来，创建音频配置，在这种情况下，使用`AudioConfig.create(true)`允许音频。
- en: Then, an executor is created using `Executors.newSingleThreadExecutor()`, which
    facilitates the execution of tasks in a background thread, thereby keeping the
    UI thread unblocked and responsive. With these parameters defined (`fileOutputOptions`,
    `AudioConfig`, and `Executor`), we can execute the `cameraController.startRecording`
    function, which will initiate the recording.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`Executors.newSingleThreadExecutor()`创建了一个执行器，这有助于在后台线程中执行任务，从而保持UI线程不被阻塞并保持响应。定义了这些参数（`fileOutputOptions`、`AudioConfig`和`Executor`）之后，我们可以执行`cameraController.startRecording`函数，这将启动录制。
- en: Additionally, an event listener is defined using the `Consumer<VideoRecordEvent>`
    interface. This listener uses a `when` statement to handle different types of
    `VideoRecordEvent`, such as `VideoRecordEvent.Finalize`, which indicates the completion
    of the recording. The event listener also checks for errors during the recording
    process, ensuring robust error handling.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`Consumer<VideoRecordEvent>`接口定义了一个事件监听器。此监听器使用`when`语句来处理不同类型的`VideoRecordEvent`，例如`VideoRecordEvent.Finalize`，这表示录制的完成。事件监听器还检查录制过程中的错误，确保健壮的错误处理。
- en: Then, a `Recording` object is returned, representing the ongoing recording session.
    This recording object is crucial for the next step.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，返回一个`Recording`对象，代表正在进行的录制会话。这个录制对象对于下一步至关重要。
- en: 'Now, let’s implement the `stopRecording` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`stopRecording`函数：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this concise and straightforward function, we only have one line of code,
    but it does something essential. The function takes a single parameter, `recording`,
    which is our instance of the `Recording` class from the CameraX library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简洁明了的函数中，我们只有一行代码，但它做了一些基本的事情。该函数接受一个单一参数`recording`，这是我们来自CameraX库的`Recording`类的实例。
- en: The core action in this function is to invocate `stop()` on the `recording`
    object. When this method is called, it tells the `recording` instance to terminate
    the current video recording session. This involves stopping video frames from
    being captured and finalizing the video file that’s being recorded. The video
    file is then saved to the location that’s specified when the recording has finished.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的核心操作是在`recording`对象上调用`stop()`方法。当此方法被调用时，它告诉`recording`实例终止当前的视频录制会话。这涉及到停止捕获视频帧并最终化正在录制的视频文件。然后，视频文件被保存到录制完成后指定的位置。
- en: 'Now, we will include the new button in `CaptureModeContent`, which we built
    previously for the capture feature:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将新按钮包含到我们之前为捕获功能构建的`CaptureModeContent`中：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have added a `Row` composable to show both buttons horizontally side
    by side. We have also added a new Lambda (`onVideoCaptured`) that we will use
    to pass the video file path when the recording has finished.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`Row`可组合组件来显示两个按钮水平并排。我们还添加了一个新的Lambda（`onVideoCaptured`），我们将使用它来传递录制完成后视频文件的路径。
- en: 'With these changes, we should be able to see the newly implemented button:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，我们应该能够看到新实现的按钮：
- en: '![Figure 6.1: The video capture button already integrated into the StoryContent
    screen when the video is not being recorded](img/B19443_06_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：当视频未录制时，视频捕获按钮已集成到StoryContent屏幕中](img/B19443_06_01.jpg)'
- en: 'Figure 6.1: The video capture button already integrated into the StoryContent
    screen when the video is not being recorded'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：当视频未录制时，视频捕获按钮已集成到StoryContent屏幕中
- en: 'When we click the video capture button, we should see its icon change to the
    stop symbol:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击视频捕获按钮时，我们应该看到其图标变为停止符号：
- en: '![Figure 6.2: Video recording in progress](img/B19443_06_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：正在进行的视频录制](img/B19443_06_02.jpg)'
- en: 'Figure 6.2: Video recording in progress'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：正在进行的视频录制
- en: And with this, we are ready to record our videos using CameraX! Now, it is time
    for us to learn how to modify or edit the recorded videos. With these aspects
    in mind, let me introduce you to the FFmpeg library.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，有了这个，我们就准备好使用CameraX录制视频了！现在，是我们学习如何修改或编辑录制视频的时候了。考虑到这些方面，让我向您介绍FFmpeg库。
- en: Getting to know FFmpeg
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解FFmpeg
- en: '**FFmpeg** is an open-source multimedia framework that has become a cornerstone
    in the world of audio and video processing. Renowned for its versatility and power,
    FFmpeg offers a comprehensive suite of libraries and tools to handle video, audio,
    and other multimedia files and streams. At its core, FFmpeg is a command-line
    tool, enabling users to convert media files from one format into another, manipulate
    video and audio recordings, and perform a wide array of other multimedia processing
    tasks.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**FFmpeg**是一个开源的多媒体框架，已成为音频和视频处理领域的基石。以其多功能性和强大功能而闻名，FFmpeg提供了一套全面的库和工具，用于处理视频、音频和其他多媒体文件和流。在核心上，FFmpeg是一个命令行工具，使用户能够将媒体文件从一种格式转换为另一种格式，操纵视频和音频记录，并执行一系列其他多媒体处理任务。'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the official FFmpeg documentation here: [https://ffmpeg.org/](https://ffmpeg.org/).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到官方FFmpeg文档：[https://ffmpeg.org/](https://ffmpeg.org/)。
- en: Through the following subsections, we will learn what components are part of
    FFmpeg, its key features, and how to integrate this powerful library in our Android
    apps.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将学习FFmpeg的组成部分、其关键特性以及如何将其强大的库集成到我们的Android应用程序中。
- en: The components of FFmpeg
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FFmpeg的组件
- en: 'The FFmpeg project is composed of several components, each serving a specific
    role in multimedia processing:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: FFmpeg项目由几个组件组成，每个组件在多媒体处理中扮演着特定的角色：
- en: '**libavcodec**: A library containing decoders and encoders for audio/video
    codecs'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libavcodec**：一个包含音频/视频编解码器的库'
- en: '**libavformat**: This library deals with the container formats, managing the
    multiplexing and demultiplexing aspects of multimedia streams'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libavformat**：这个库处理容器格式，管理多媒体流的复用和解复用方面'
- en: '**libavutil**: A utility library that provides a range of helper functions
    and data structures'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libavutil**：一个提供各种辅助函数和数据结构的实用库'
- en: '**libavfilter**: Used for applying various audio and video filters'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libavfilter**：用于应用各种音频和视频过滤器'
- en: '**libswscale**: Dedicated to handling image scaling and color format conversions'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libswscale**：专门处理图像缩放和颜色格式转换'
- en: Together, these components provide a robust foundation for handling a wide array
    of multimedia processing tasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件共同为处理各种多媒体处理任务提供了一个坚实的基础。
- en: Key features of FFmpeg
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FFmpeg的关键特性
- en: 'FFmpeg stands out for its extensive range of capabilities. Some of its key
    features include the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: FFmpeg因其广泛的功能而脱颖而出。其关键特性包括以下内容：
- en: '**Format support**: FFmpeg supports a vast number of audio and video formats,
    both in terms of encoding and decoding, making it incredibly versatile for multimedia
    processing'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式支持**：FFmpeg支持大量的音频和视频格式，包括编码和解码，使其在多媒体处理方面具有极高的灵活性'
- en: '**Conversion**: It can convert media files between various formats with high
    efficiency, a feature that’s widely used in various applications and services'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：它能够以高效率在多种格式之间转换媒体文件，这一特性在各种应用程序和服务中得到广泛应用'
- en: '**Streaming**: FFmpeg excels in streaming capabilities, allowing for audio
    and video to be captured, encoded, and streamed in real time'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流媒体**：FFmpeg在流媒体能力方面表现出色，允许实时捕获、编码和流式传输音频和视频'
- en: '**Filtering**: With its powerful filtering capabilities, users can apply various
    transformations, overlays, and effects to their media'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：凭借其强大的过滤能力，用户可以对他们的媒体应用各种转换、叠加和效果'
- en: Integrating mobile-ffmpeg into our project
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将mobile-ffmpeg集成到我们的项目中
- en: In the context of Android development, FFmpeg can be used as a powerful tool
    for video editing functionalities, such as applying filters, transcoding, or even
    adding subtitles. However, integrating FFmpeg into Android applications while
    using C++ code requires using `mobile-ffmpeg`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发的背景下，FFmpeg可以作为视频编辑功能（如应用过滤器、转码或甚至添加字幕）的强大工具。然而，在使用C++代码的同时将FFmpeg集成到Android应用程序中，需要使用`mobile-ffmpeg`。
- en: '`mobile-ffmpeg` is a specialized port of Ffmpeg that’s designed for mobile
    platforms such as Android and iOS. It provides pre-built binaries, mobile-specific
    APIs, and optimizations tailored to the constraints of mobile hardware. This makes
    it easier to integrate FFmpeg’s powerful capabilities into mobile applications,
    allowing developers to leverage advanced multimedia processing features with less
    complexity.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobile-ffmpeg`是专门为移动平台（如Android和iOS）设计的FFmpeg的专用端口。它提供了预构建的二进制文件、针对移动特定的API和针对移动硬件限制的优化。这使得将FFmpeg的强大功能集成到移动应用程序中变得更容易，允许开发者以更少的复杂性利用高级多媒体处理功能。'
- en: 'To integrate the `mobile-ffmpeg` library into our project, we will start by
    opening our `libs.versions.toml` file. There, we will add the version and the
    library group and name:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `mobile-ffmpeg` 库集成到我们的项目中，我们首先需要打开我们的 `libs.versions.toml` 文件。在那里，我们将添加版本和库组以及名称：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have just added the latest `mobile-ffmpeg` version and the library
    reference to our version catalog.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们刚刚将最新的 `mobile-ffmpeg` 版本和库引用添加到我们的版本目录中。
- en: 'As always, to use it in any of our modules, we will have to add the dependency
    in the `build.gradle.kts` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，为了在任何模块中使用它，我们将在 `build.gradle.kts` 文件中添加依赖项：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once it’s added to our dependencies, we will have to sync our Gradle files so
    that it’s ready to be used in our code. But first, let’s learn how FFmpeg works
    and can be used.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它被添加到我们的依赖项中，我们就需要同步我们的 Gradle 文件，以便它可以在我们的代码中使用。但首先，让我们了解 FFmpeg 的工作原理以及如何使用它。
- en: Understanding the FFmpeg command-line syntax
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 FFmpeg 命令行语法
- en: As we have seen, FFmpeg is a powerful multimedia framework that’s capable of
    decoding, encoding, transcoding, multiplexing (joining, for example, audio and
    video in a single file), demultiplexing (separating audio and video in different
    files), streaming, filtering, and playing almost any type of media file. Understanding
    its command-line syntax is crucial for effective video processing, especially
    in Android environments.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，FFmpeg 是一个强大的多媒体框架，能够解码、编码、转码、复用（例如，将音频和视频合并到单个文件中）、解复用（在不同的文件中分离音频和视频）、流式传输、过滤和播放几乎任何类型的媒体文件。理解其命令行语法对于有效的视频处理至关重要，尤其是在
    Android 环境中。
- en: Keep in mind that we will not be executing these commands in a terminal, but
    the `mobile-ffmpeg` library uses the same syntax to allow us to execute them using
    a function called `FFmpeg.execute()`, as we will see now.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们不会在终端中执行这些命令，但 `mobile-ffmpeg` 库使用相同的语法，允许我们通过一个名为 `FFmpeg.execute()`
    的函数来执行它们，正如我们现在将要看到的。
- en: 'At its core, an FFmpeg command follows a basic structure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，一个 FFmpeg 命令遵循一个基本结构：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s take a closer look at the components of this syntax:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个语法的组成部分：
- en: '**global_options**: These are settings that can be applied throughout the command,
    such as configuring logging levels or overriding default configurations.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**global_options**: 这些是可以应用于整个命令的设置，例如配置日志级别或覆盖默认配置。'
- en: '**input_file_options**: These are options that specifically affect the input
    file, such as the format, codec, or frame rate.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input_file_options**: 这些是专门影响输入文件选项，例如格式、编解码器或帧率。'
- en: '**input_url**: The path to the input file.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input_url**: 输入文件的路径。'
- en: '**output_file_options**: These are similar to input file options but they affect
    the output file, such as the format, codec, or bitrate.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output_file_options**: 这些与输入文件选项类似，但影响输出文件，例如格式、编解码器或比特率。'
- en: '**output_url**: The path for the output file.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output_url**: 输出文件的路径。'
- en: '**options**/**flags**: These start with a dash (**-**) and modify how FFmpeg
    processes files. The most used options and flags are as follows:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options**/**flags**: 这些以破折号（**-**）开头，并修改 FFmpeg 处理文件的方式。最常用的选项和标志如下：'
- en: '**-i**: Specifies the input file'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i**: 指定输入文件'
- en: '**-c**: Indicates the codec; use **-c:v** for video and **-c:a** for audio'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-c**: 表示编解码器；使用 **-c:v** 用于视频，**-c:a** 用于音频'
- en: '**-b**: Sets the bitrate; **-b:v** for video and **-b:a** for audio'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-b**: 设置比特率；**-b:v** 用于视频，**-b:a** 用于音频'
- en: '**-s**: Defines the frame size (resolution)'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-s**: 定义帧大小（分辨率）'
- en: '**-r**: Sets the frame rate'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-r**: 设置帧率'
- en: '**-f**: Indicates the format'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-f**: 表示格式'
- en: Let’s see how we can use this syntax to complete some basic operations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个语法来完成一些基本操作。
- en: Basic conversion
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本转换
- en: 'Converting a video file from one format into another is a fundamental task
    in video editing. For example, converting an MP4 file into an AVI file can be
    done like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将视频文件从一种格式转换为另一种格式是视频编辑中的基本任务。例如，将 MP4 文件转换为 AVI 文件可以这样做：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command tells FFmpeg to take `input.mp4` and convert it into `output.avi`
    using the default settings for codecs and quality (the default values are used
    here because we didn’t specify any settings).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉 FFmpeg 将 `input.mp4` 转换为 `output.avi`，使用编解码器和质量的默认设置（这里使用默认值，因为我们没有指定任何设置）。
- en: Specifying codecs
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定编解码器
- en: '**Codecs** are algorithms that are used for encoding (compressing) or decoding
    (decompressing) video and audio streams. In FFmpeg, you can specify different
    codecs for the video and audio components of a file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**编解码器**是用于编码（压缩）或解码（解压缩）视频和音频流的算法。在 FFmpeg 中，您可以指定文件的视频和音频组件的不同编解码器：'
- en: '**Video codec**: A video codec processes the visual data in the file. Choosing
    the right video codec affects the video’s quality, size, and compatibility with
    different players and devices.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频编解码器**：视频编解码器处理文件中的视觉数据。选择正确的视频编解码器会影响视频的质量、大小以及与不同播放器和设备的兼容性。'
- en: '**Audio codec**: An audio codec deals with the sound component. It determines
    the audio quality, file size, and compatibility with audio playback systems.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频编解码器**：音频编解码器处理声音组件。它决定了音频质量、文件大小以及与音频播放系统的兼容性。'
- en: 'To specify codecs in FFmpeg, use the `-c` flag followed by a colon, then either
    `v` for video or `a` for audio, and then specify the codec’s name:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在FFmpeg中指定编解码器，使用`-c`标志后跟一个冒号，然后是`v`表示视频或`a`表示音频，接着指定编解码器的名称：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, for example, to specify the H.264 and AAC codecs, you can run the following
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要指定H.264和AAC编解码器，可以运行以下命令：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s understand what the values of this command mean:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个命令的值代表什么：
- en: '**-i**: This indicates that the next parameter is going to be the input file.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i**: 这表示下一个参数将是输入文件。'
- en: '**input.mp4**: This is the route to the input file.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input.mp4**: 这是输入文件的路径。'
- en: '**-c:v libx264**: This value sets the video codec to **libx264**, a popular
    codec for H.264 video encoding. It’s known for its efficiency and compatibility
    with most video platforms.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-c:v libx264**: 这个值将视频编解码器设置为**libx264**，这是一个流行的H.264视频编码编解码器。它以其效率和与大多数视频平台的兼容性而闻名。'
- en: '**-c:a aac**: This value sets the audio codec to **aac** (which stands for
    Advanced Audio Coded), known for good quality audio at lower bitrates, making
    it ideal for web videos.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-c:a aac**: 这个值将音频编解码器设置为**aac**（代表高级音频编码），在较低的比特率下提供良好的音频质量，使其非常适合网络视频。'
- en: '**output.mp4**: This indicates the route to the output file.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output.mp4**: 表示输出文件的路径。'
- en: Note that higher-quality codecs often result in larger file sizes – the balance
    between quality and file size can be key, depending on the use case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，高质量编解码器通常会导致更大的文件大小——质量和文件大小的平衡在特定用例中可能是关键。
- en: Also, it is important to know that some codecs require licensing for commercial
    use (for example, H.264), whereas others are open source and free (for example,
    VP9 and Opus).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要知道，某些编解码器需要商业使用许可（例如，H.264），而其他则是开源和免费的（例如，VP9和Opus）。
- en: Adjusting video quality
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整视频质量
- en: In video processing, one of the most crucial aspects to manage is the quality
    of the output video. The quality is often directly influenced by the bitrate.
    The **bitrate** is measured in **bits per second** (**bps**) and represents the
    amount of video or audio data that’s encoded for 1 second of playback. Higher
    bitrates generally mean better quality but also larger file sizes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频处理中，管理输出视频质量是最关键的因素之一。质量通常直接受比特率的影响。**比特率**以**每秒比特数**（**bps**）衡量，表示播放1秒视频或音频所编码的数据量。较高的比特率通常意味着更好的质量，但也意味着更大的文件大小。
- en: 'There are two types of bitrate:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率有两种类型：
- en: '**Constant bitrate** (**CBR**): This encodes the file at a consistent bitrate
    throughout, leading to predictable file sizes but potentially varying quality'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒定比特率**（**CBR**）：在整个文件中以一致的比特率进行编码，导致可预测的文件大小，但可能质量会有所变化'
- en: '**Variable bitrate** (**VBR**): This adjusts the bitrate according to the complexity
    of each part of the video, balancing quality and file size more effectively'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量比特率**（**VBR**）：这会根据视频每一部分的复杂性调整比特率，更有效地平衡质量和文件大小'
- en: 'To adjust the bitrate in FFmpeg, we can use the `-b:v` flag for video bitrate
    and `-b:a` for audio bitrate:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在FFmpeg中调整比特率，我们可以使用`-b:v`标志来指定视频比特率，使用`-b:a`来指定音频比特率：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, to set standard definition video with moderate quality, we can
    run the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要设置标准定义视频并具有适中的质量，我们可以运行以下命令：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s see what the values of this command mean:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个命令的值代表什么：
- en: '**-i**: This indicates that the next parameter is going to be the input file'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i**: 这表示下一个参数将是输入文件'
- en: '**input.mp4**: This is the route to the input file'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input.mp4**: 这是输入文件的路径'
- en: '**-b:v 1500k**: Sets the video bitrate to 1,500 kbps, which is suitable for
    standard-definition content'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-b:v 1500k**: 将视频比特率设置为1,500 kbps，这对于标准定义内容是合适的'
- en: '**-b:a 128k**: Sets the audio bitrate to 128 kbps, providing decent audio quality
    without excessive file size'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-b:a 128k**: 将音频比特率设置为128 kbps，提供不错的音频质量，而不会导致文件大小过大'
- en: '**output.mp4**: Indicates the route to the output file'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output.mp4**: 表示输出文件的路径'
- en: It’s worth noting that lower bitrates may lead to noticeable compression artifacts,
    especially in fast-moving or complex scenes. On the other hand, higher bitrates
    offer better quality but at the expense of larger file sizes, which might be an
    issue for online streaming or limited storage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，较低的比特率可能会导致明显的压缩伪影，尤其是在快速移动或复杂的场景中。另一方面，较高的比特率提供更好的质量，但代价是文件大小更大，这可能会成为在线流媒体或有限存储的问题。
- en: Resizing video
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整视频大小
- en: Resizing or scaling videos is a common task in video editing, whether it’s to
    fit different screen sizes, reduce file size, or conform to specific resolution
    requirements. FFmpeg offers powerful tools to resize videos with ease, but understanding
    the impact of these changes is crucial for maintaining quality.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频编辑中，调整或缩放视频是一个常见任务，无论是为了适应不同的屏幕尺寸、减小文件大小还是符合特定的分辨率要求。FFmpeg提供了强大的工具轻松调整视频大小，但了解这些更改的影响对于保持质量至关重要。
- en: But what are video resolution and aspect ratio?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但什么是视频分辨率和宽高比？
- en: '**Resolution**: The resolution of a video is the dimension in pixels, given
    as width x height. Standard resolutions include 480p (SD), 720p (HD), 1080p (Full
    HD), and 4K (Ultra HD).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：视频的分辨率是像素的维度，表示为宽度 x 高度。标准分辨率包括480p（标清）、720p（高清）、1080p（全高清）和4K（超高清）。'
- en: '**Aspect ratio**: This is the ratio of the width to the height of the video.
    Common aspect ratios are 16:9 (widescreen) and 4:3 (traditional).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽高比**：这是视频宽度和高度的比率。常见的宽高比包括16:9（宽屏）和4:3（传统）。'
- en: 'To resize videos in FFmpeg, the `-s` (size) flag is used. It sets the resolution:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在FFmpeg中调整视频大小，使用`-s`（大小）标志。它设置分辨率：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For example, to resize to 1080p, the command will be as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将分辨率调整为1080p，命令如下：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s see what the values of this command mean:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个命令的值代表什么：
- en: '**-i**: Indicates that the next parameter is going to be the input file'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i**：表示下一个参数将是输入文件'
- en: '**input.mp4**: The route to the input file'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input.mp4**：输入文件的路径'
- en: '**-s 1920x1080**: Resizes the video to full HD (1080p), which is suitable for
    high-quality presentations and large displays'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-s 1920x1080**：将视频调整到全高清（1080p），适合高质量演示和大型显示屏'
- en: '**output.mp4**: Indicates the route to the output file'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output.mp4**：表示输出文件的路径'
- en: 'There are some things to consider when resizing videos:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整视频大小时有一些需要考虑的事项：
- en: Choose the resolution based on where and how the video will be viewed. For instance,
    you should choose a high resolution for TV broadcasts and something lower for
    web or mobile use.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据视频将如何以及在哪里被观看来选择分辨率。例如，你应该为电视广播选择高分辨率，而对于网络或移动使用则选择较低的分辨率。
- en: Higher resolutions lead to larger files, which can be a concern for storage
    and streaming.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较高的分辨率会导致文件更大，这可能会对存储和流媒体传输造成影响。
- en: Always consider the quality of the source video. Upscaling low-quality footage
    might not yield desirable results.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是考虑源视频的质量。放大低质量素材可能不会产生理想的结果。
- en: Now that we are familiar with the basic features of FFmpeg, we will learn about
    the advanced ones.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了FFmpeg的基本功能，我们将学习高级功能。
- en: Advanced syntax and options in FFmpeg
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FFmpeg的高级语法和选项
- en: FFmpeg’s true power lies in its advanced options, allowing for sophisticated
    manipulation and processing of audio and video files. This section delves deeper
    into these advanced features, providing insights into how they can be leveraged
    for complex tasks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: FFmpeg的真正力量在于其高级选项，允许对音频和视频文件进行复杂的处理和操作。本节将深入探讨这些高级功能，并提供如何利用它们完成复杂任务的见解。
- en: Using filters for enhanced video and audio manipulation
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过滤器进行增强视频和音频处理
- en: FFmpeg comes equipped with an extensive range of filters for both video and
    audio. These can be applied to tasks such as cropping, rotating, adding watermarks,
    and adjusting brightness or contrast.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: FFmpeg配备了丰富的视频和音频过滤器。这些过滤器可以应用于裁剪、旋转、添加水印以及调整亮度或对比度等任务。
- en: 'To apply filters, you can use the `-vf` (video filters) or `-af` (audio filters)
    option. Here is the schema of how the filter syntax would work:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用过滤器，可以使用`-vf`（视频过滤器）或`-af`（音频过滤器）选项。以下是过滤器语法的工作模式：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For example, imagine a scenario where you need to crop a video and adjust its
    color properties. You can do this by running the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个场景，你需要裁剪视频并调整其颜色属性。你可以通过运行以下命令来完成：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s take a closer look at the values of this command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个命令的值：
- en: '**-i**: Indicates that the next parameter is going to be the input file.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i**：表示下一个参数将是输入文件。'
- en: '**input.mp4**: This is the route to the input file.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input.mp4**: 这是输入文件的路径。'
- en: '**-vf**: This stands for video filters, and allows you to apply one or more
    filters to the video stream.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-vf**: 这代表视频滤镜，允许你将一个或多个滤镜应用到视频流中。'
- en: '**crop=640:480:0:0**: This is the crop filter. It crops the video to a width
    of **640** pixels and a height of **480** pixels. The **0:0** value at the end
    specifies the *x* and *y* coordinates of the top-left corner of the crop area.
    In this case, it’s set to the top-left corner of the original video. So, this
    filter effectively crops the video to a 640x480 rectangle starting from the top-left
    corner.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**crop=640:480:0:0**: 这是裁剪滤镜。它将视频裁剪到640像素宽和480像素高。末尾的**0:0**值指定裁剪区域的左上角的x和y坐标。在这种情况下，它设置为原始视频的左上角。因此，此滤镜实际上从左上角裁剪视频至640x480矩形。'
- en: '**hue=h=60:s=1**: There are two parts to this code:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hue=h=60:s=1**: 该代码包含两部分：'
- en: '**h=60** adjusts the hue of the video. Hue is a color component that allows
    us to shift colors on a 360-degree color wheel. A value of 60 shifts the colors
    by 60 degrees. For example, blue might become green, red might become yellow,
    and so on.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**h=60**调整视频的色调。色调是允许我们在360度色轮上移动颜色的颜色成分。60度的值将颜色移动60度。例如，蓝色可能变成绿色，红色可能变成黄色，依此类推。'
- en: '**s=1** sets the saturation level. A saturation of **1** means that the colors
    are left as-is in terms of intensity. Decreasing this value would desaturate the
    colors, leading to a more grayscale image.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s=1**设置饱和度级别。饱和度为**1**意味着颜色在强度上保持不变。减小此值将使颜色去饱和，导致图像更偏向灰度。'
- en: '**-c:a**: Resizes the video to full HD (1080p).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-c:a**: 将视频调整至全高清（1080p）。'
- en: '**output.mp4**: Indicates the route to the output file.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output.mp4**: 指示输出文件的路径。'
- en: In summary, this FFmpeg command reads `input.mp4`, crops the video to a 640x480
    resolution starting from the top-left corner, shifts the hue of the video colors
    by 60 degrees on the color wheel, maintains the original saturation, copies the
    audio without re-encoding, and saves all these changes in `output.mp4`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这个FFmpeg命令读取`input.mp4`，从左上角裁剪视频至640x480分辨率，将视频颜色的色调在色轮上调整60度，保持原始饱和度，不重新编码复制音频，并将所有这些更改保存在`output.mp4`中。
- en: Using an overlay video filter
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用覆盖视频滤镜
- en: The overlay filter in FFmpeg is a versatile feature that allows users to superimpose
    one video or image over another. This is particularly useful for adding logos,
    watermarks, subtitles, picture-in-picture effects, or any additional visual elements
    to a video.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: FFmpeg中的覆盖滤镜是一个多功能特性，允许用户将一个视频或图像叠加到另一个视频上。这对于添加标志、水印、字幕、画中画效果或任何其他视觉元素到视频中特别有用。
- en: The overlay filter can be applied with the `-filter_complex` option in FFmpeg,
    which is used for more complex filtering that involves multiple input streams
    (such as combining two videos or adding an image to a video).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖滤镜可以通过FFmpeg中的`-filter_complex`选项应用，该选项用于涉及多个输入流（如合并两个视频或向视频中添加图像）的更复杂过滤。
- en: 'The basic syntax for the overlay filter is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖滤镜的基本语法如下：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `main_video.mp4` is our primary video, and `overlay.mp4` is the video
    or image we want to overlay. The `x` and `y` values in the overlay filter specify
    the position of the overlay image/video on the main video.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`main_video.mp4`是我们的主要视频，而`overlay.mp4`是我们想要叠加的视频或图像。覆盖滤镜中的`x`和`y`值指定覆盖图像/视频在主视频上的位置。
- en: 'As an example, let’s say we want to add a company logo to the bottom-right
    corner of a video. First, we must prepare the files. In this case, we have the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在视频的右下角添加公司标志。首先，我们必须准备文件。在这种情况下，我们有以下文件：
- en: The main video file will be **video.mp4**
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主视频文件将是**video.mp4**
- en: The logo image will be **logo.png** (preferably with a transparent background)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志图像将是**logo.png**（最好带有透明背景）
- en: Then, we will determine the logo’s position. The logo’s position will depend
    on the resolution of the main video. For example, if the video is 1920x1080 (full
    HD), and you want to place the logo 10 pixels from the bottom and right edges,
    the coordinates would be (x=1900, y=1060).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将确定标志的位置。标志的位置将取决于主视频的分辨率。例如，如果视频是1920x1080（全高清），并且你希望标志距离底部和右边框10像素，坐标将是（x=1900,
    y=1060）。
- en: 'With this in mind, we will have to execute the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们必须执行以下命令：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this command, we have the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，我们有以下内容：
- en: '**-i video.mp4**: Specifies the main video file.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i video.mp4**: 指定主视频文件。'
- en: '**-i logo.png**: Specifies the overlay file (logo).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i logo.png**: 指定覆盖层文件（标志）。'
- en: '**-filter_complex "overlay=1900:1060"**: Applies the overlay filter. The logo
    is positioned at (1900,1060), which is near the bottom-right corner.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-filter_complex "overlay=1900:1060"**: 应用覆盖层过滤器。标志位于（1900,1060），接近右下角。'
- en: '**-codec:a copy**: Copies the audio from the main video without re-encoding.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-codec:a copy**: 复制主视频中的音频，不进行重新编码。'
- en: '**output.mp4**: The output file with the logo overlaid on the video.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output.mp4**: 在视频上叠加标志的输出文件。'
- en: Is this all we can do with the overlay filter? No, there’s much more! For example,
    we can move this overlay dynamically.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能用覆盖层过滤器做到这些吗？不，还有更多！例如，我们可以动态地移动这个覆盖层。
- en: Dynamic positioning with the overlay filter in FFmpeg
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用FFmpeg的覆盖层过滤器进行动态定位
- en: The overlay filter in FFmpeg not only allows static placement of images or videos
    over a main video but also offers dynamic positioning capabilities. This advanced
    feature enables the overlay to move across the screen or change its appearance
    over time, adding a dynamic element to your videos.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: FFmpeg中的覆盖层过滤器不仅允许在主视频上静态放置图像或视频，还提供了动态定位功能。这个高级功能使得覆盖层可以在屏幕上移动或随时间改变其外观，为您的视频添加动态元素。
- en: First, let’s explore how to create the effect of moving an overlay across the
    screen. This technique is particularly effective for adding motion to logos, text,
    or other graphical elements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索如何在屏幕上创建移动覆盖层的效果。这种技术特别适用于为标志、文本或其他图形元素添加动态效果。
- en: Before we dive into the command, it’s important to understand how FFmpeg processes
    expressions for movement. These expressions allow the position of the overlay
    to change frame by frame, creating the illusion of motion.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入命令之前，了解FFmpeg如何处理运动表达式非常重要。这些表达式允许覆盖层的位置逐帧改变，从而产生运动错觉。
- en: 'The command for moving an overlay is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 移动覆盖层的命令如下：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this command, we have the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们有以下内容：
- en: '**x=''t*100''**: The horizontal position (**x**) of the overlay starts at 0
    and increases by 100 pixels every second. The **t** variable represents the current
    time in seconds.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x=''t*100''**: 覆盖层的水平位置（**x**）从0开始，每秒增加100像素。**t**变量代表当前时间（秒）。'
- en: '**y=50**: The vertical position (**y**) is fixed at **50** pixels from the
    top of the frame.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**y=50**: 垂直位置（**y**）固定在帧顶部的**50**像素处。'
- en: We can play with these values to introduce different effects in our video overlay.
    For example, if we create a complete video editor, we could allow the users to
    move an element over the video and change its position during the video playback.
    Then, we could map those different positions to the seconds where we want it to
    be moved using FFmpeg. However, we won’t be doing this as it would take another
    book entirely!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整这些值，在我们的视频覆盖层中引入不同的效果。例如，如果我们创建一个完整的视频编辑器，我们可以允许用户在视频上移动一个元素，并在视频播放期间改变其位置。然后，我们可以使用FFmpeg将这些不同的位置映射到我们希望它们移动到的秒数。然而，我们不会这样做，因为这需要另一本书的篇幅！
- en: 'If you are curious about this, here is the documentation for the `overlay`
    parameter: [https://ffmpeg.org/ffmpeg-filters.html#overlay-1](https://ffmpeg.org/ffmpeg-filters.html#overlay-1).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对此感兴趣，以下是`overlay`参数的文档：[https://ffmpeg.org/ffmpeg-filters.html#overlay-1](https://ffmpeg.org/ffmpeg-filters.html#overlay-1)。
- en: Another feature we can use is fade-in and fade-out effects, which we can apply
    to our overlay. Let’s see how it works.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用淡入和淡出效果，这些效果可以应用于我们的覆盖层。让我们看看它是如何工作的。
- en: Introducing the fade-in/out command
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍淡入/淡出命令
- en: 'To achieve a fade-in/out effect, we combine the overlay filter with the fade
    filter. Let’s break down the command to understand how it’s structured:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现淡入/淡出效果，我们将覆盖层过滤器与淡入/淡出过滤器结合使用。让我们分解这个命令，了解其结构：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s understand how this command is configured:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个命令是如何配置的：
- en: '**[1:v]fade=t=in:st=0:d=1**: Applies a fade-in effect to the overlay, starting
    at **0** seconds and lasting for **1** second'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[1:v]fade=t=in:st=0:d=1**: 将淡入效果应用于覆盖层，从**0**秒开始，持续**1**秒'
- en: '**fade=t=out:st=3:d=1[logo]**: Subsequently, a fade-out effect starts at **3**
    seconds and also lasts for **1** second'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fade=t=out:st=3:d=1[logo]**: 随后，从**3**秒开始，淡出效果持续**1**秒'
- en: '**overlay=10:10**: The overlay is placed at the coordinates (10,10) on the
    main video'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**overlay=10:10**: 覆盖层放置在主视频的坐标（10,10）处。'
- en: But there is more that we can do with FFmpeg, apart from using exposed filters.
    Let’s see how we can use the `mobile-ffmpeg` library that we’ve already integrated
    into our project to improve the videos we are already recording.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还可以使用FFmpeg做更多的事情，而不仅仅是使用公开的过滤器。让我们看看我们如何使用已经集成到我们项目中的`mobile-ffmpeg`库来改进我们正在记录的视频。
- en: Using mobile-ffmpeg to execute FFmpeg commands
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mobile-ffmpeg执行FFmpeg命令
- en: With `mobile-ffmpeg` integrated, executing FFmpeg commands in Android becomes
    a streamlined process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 集成`mobile-ffmpeg`后，在Android中执行FFmpeg命令变得流程化。
- en: The library’s `FFmpeg.execute()` method is the gateway to running FFmpeg commands.
    For instance, a command such as `-i input.mp4 -c:v libx264 output.mp4`, which
    converts an input video so that it uses the H.264 codec, is seamlessly executed
    within the Android environment. This function mirrors the command-line syntax
    of FFmpeg, maintaining familiarity for those accustomed to FFmpeg’s command-line
    interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 库的`FFmpeg.execute()`方法是运行FFmpeg命令的入口。例如，一个如`-i input.mp4 -c:v libx264 output.mp4`的命令，它将输入视频转换为使用H.264编解码器，可以在Android环境中无缝执行。此函数反映了FFmpeg的命令行语法，为熟悉FFmpeg命令行界面的人提供了便利。
- en: 'Here’s how it would work:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous code block, we are building a string with the `command` instruction
    and storing it in the `command` variable. Then, we are using the `FFmpeg.execute()`
    method to execute the command. Note that this execution will happen in the current
    thread, which could be undesirable performance-wise.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们正在构建一个包含`command`指令的字符串，并将其存储在`command`变量中。然后，我们使用`FFmpeg.execute()`方法来执行该命令。请注意，此执行将在当前线程中发生，这在性能方面可能是不理想的。
- en: Managing performance and user experience is crucial in Android, especially for
    resource-intensive tasks such as video processing. `mobile-ffmpeg` accommodates
    this by offering asynchronous execution of commands. Utilizing `FFmpeg.executeAsync()`
    ensures that longer operations do not block the main thread, thus maintaining
    the application’s responsiveness. This method becomes instrumental when handling
    complex transformations or filters, such as scaling a video.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，管理性能和用户体验至关重要，尤其是在处理像视频处理这样的资源密集型任务时。`mobile-ffmpeg`通过提供命令的异步执行来适应这一点。利用`FFmpeg.executeAsync()`确保长时间操作不会阻塞主线程，从而保持应用程序的响应性。当处理复杂的转换或过滤器，例如缩放视频时，这种方法变得非常有用。
- en: 'Here’s how we can use the `executeAsync` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以使用`executeAsync`函数的方式：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the `executeAsync()` method is called with the `FFmpeg` command
    in string format. This command is what we intend FFmpeg to execute, such as converting
    a video file, applying filters, or any other media processing task supported by
    FFmpeg. The execution of this command occurs in a separate thread, preventing
    any blocking of the main UI thread of the application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`executeAsync()`方法以字符串格式调用`FFmpeg`命令。这是我们打算让FFmpeg执行的命令，例如转换视频文件、应用过滤器或任何其他由FFmpeg支持的媒体处理任务。此命令的执行在一个单独的线程中发生，防止任何阻塞应用程序的主UI线程。
- en: 'When the command has finished executing, a Lambda function is triggered. This
    function is structured to receive two parameters: `executionId` and `returnCode`.
    The `executionId` parameter is a unique identifier for this particular execution
    instance of the `FFmpeg` command and can be useful for tracking or managing this
    specific operation, especially if our application handles multiple FFmpeg processes
    concurrently.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令执行完成后，会触发一个Lambda函数。此函数的结构是为了接收两个参数：`executionId`和`returnCode`。`executionId`参数是`FFmpeg`命令此特定执行实例的唯一标识符，可以用于跟踪或管理此特定操作，特别是如果我们的应用程序同时处理多个FFmpeg进程。
- en: 'The `returnCode` parameter is crucial as it indicates the outcome of the executed
    `FFmpeg` command. The different return codes and their implications are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnCode`参数至关重要，因为它指示了执行`FFmpeg`命令的结果。不同的返回代码及其含义如下：'
- en: '**Config.RETURN_CODE_SUCCESS**: This code signifies that the **FFmpeg** command
    was executed successfully without any errors. In the corresponding block of the
    **when** statement, you might want to implement functionality that deals with
    the successful completion of the media processing task. This could include updating
    the user interface, processing or displaying the output file, or triggering subsequent
    application logic.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Config.RETURN_CODE_SUCCESS**：这个代码表示 FFmpeg 命令成功执行，没有出现任何错误。在相应的 `when` 语句块中，您可能想要实现处理媒体处理任务成功完成的功能。这可能包括更新用户界面、处理或显示输出文件，或触发后续的应用程序逻辑。'
- en: '**Config.RETURN_CODE_CANCEL**: This return code indicates that the execution
    of the **FFmpeg** command was canceled. This can occur if the execution is programmatically
    aborted or if certain external conditions pre-emptively stop the command. The
    handling code block for this return code could involve notifying the user of the
    cancellation, cleaning up resources, or setting the stage for a potential retry
    of the operation.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Config.RETURN_CODE_CANCEL**：这个返回代码表示 FFmpeg 命令的执行被取消。这可能发生在执行程序被终止或某些外部条件预先停止命令的情况下。处理这个返回代码的代码块可能包括通知用户取消、清理资源或为操作的重试做准备。'
- en: '**else**: This block catches all other cases, which generally suggests that
    an error occurred during the execution of the **FFmpeg** command. Here, error-handling
    strategies come into play, such as logging the error for diagnostic purposes,
    informing the user of the failure, or attempting to retry the operation under
    certain conditions.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**else**：这个块捕获所有其他情况，通常表明在执行 FFmpeg 命令期间发生了错误。在这里，错误处理策略包括记录错误以进行诊断、通知用户失败，或在某些条件下尝试重试操作。'
- en: 'To further refine the integration, `mobile-ffmpeg` allows us to handle progress
    and log outputs. This is essential for debugging and enhancing the user experience.
    Here’s how it works:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步细化集成，`mobile-ffmpeg` 允许我们处理进度和日志输出。这对于调试和提升用户体验至关重要。以下是它的工作方式：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `LogCallback` complements the execution callback that we described before.
    FFmpeg is known for its verbose logging, providing a wealth of information about
    the ongoing operation. The `logMessage` parameter in this callback gives you access
    to these logs, enabling you to handle them as per your application’s needs. Whether
    it’s displaying these logs for debugging purposes, analyzing them for detailed
    error reporting, or simply directing them to a file for record-keeping, this callback
    plays a pivotal role in understanding and managing the intricacies of FFmpeg’s
    operations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`LogCallback` 补充了我们之前描述的执行回调。FFmpeg 以其详尽的日志记录而闻名，提供了关于正在进行的操作的大量信息。这个回调中的
    `logMessage` 参数让您可以访问这些日志，使您可以根据应用程序的需求处理它们。无论是为了调试目的显示这些日志、分析它们以进行详细的错误报告，还是简单地将它们定向到文件以进行记录，这个回调在理解和管理
    FFmpeg 操作的复杂性方面发挥着关键作用。
- en: Last but not least, `StatisticsCallback` opens the door to real-time monitoring
    of the FFmpeg process. This callback, through the `statistics` parameter, provides
    live data, such as the frame currently being processed, elapsed time, and bitrate,
    among others. Utilizing this data can significantly enhance the user experience,
    enabling you to implement dynamic features such as progress bars, estimated-time-to-completion
    indicators, or even detailed reports of the ongoing operation’s status.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`StatisticsCallback` 为实时监控 FFmpeg 进程打开了大门。这个回调通过 `statistics` 参数提供实时数据，例如当前正在处理的帧、已过时间、比特率等。利用这些数据可以显著提升用户体验，使您能够实现动态功能，如进度条、预计完成时间指示器，甚至详细报告当前操作的状态。
- en: Now that we know how to execute our FFmpeg commands in Android, let’s build
    something. We will start by adding a caption to the video.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在 Android 中执行 FFmpeg 命令，让我们开始构建一些东西。我们将从给视频添加字幕开始。
- en: Adding a caption to the video with FFmpeg
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FFmpeg 给视频添加字幕
- en: In this section, we will create all the components we’ll need to add a caption
    to a video using FFmpeg. We’ll start this new feature by creating a use case where
    the business logic of adding the caption to the video will be defined. We will
    call it `AddCaptionToVideoUseCase`, and its responsibility will be to add the
    caption to the video and return the new video file once it has been added.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建所有需要使用 FFmpeg 添加字幕到视频所需的组件。我们将从这个新功能开始，创建一个用例，其中定义了将字幕添加到视频的业务逻辑。我们将称之为
    `AddCaptionToVideoUseCase`，其职责是将字幕添加到视频中，并在添加后返回新的视频文件。
- en: 'This is how we can build `AddCaptionToVideoUseCase`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们构建 `AddCaptionToVideoUseCase` 的方法：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we start by creating a suspend function, `addCaption`,
    which is specifically designed to facilitate asynchronous execution via coroutines.
    As the action of adding a caption involves intensive tasks such as video processing,
    we should avoid executing this kind of logic in the main thread to prevent any
    lag or unresponsiveness in the application. The function takes two parameters:
    a `File` object representing the video file and a `String` containing the caption
    text to be added.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个挂起函数 `addCaption`，它专门设计用来通过协程促进异步执行。由于添加字幕涉及视频处理等密集型任务，我们应该避免在主线程中执行这类逻辑，以防止应用程序出现任何延迟或无响应。该函数接受两个参数：一个表示视频文件的
    `File` 对象和一个包含要添加的字幕文本的 `String`。
- en: Inside the `addCaption` function, the execution context is switched to the I/O
    dispatcher. This is done to optimize for I/O operations, ensuring that the file
    processing workload is handled appropriately without straining the main thread.
    The function proceeds to create an `outputFile` object. This object represents
    the new video file that will be generated post-captioning.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addCaption` 函数内部，执行上下文切换到 I/O 分派器。这样做是为了优化 I/O 操作，确保文件处理工作负载得到适当的处理，而不会对主线程造成压力。函数接着创建一个
    `outputFile` 对象。该对象代表添加字幕后生成的新的视频文件。
- en: 'The next segment in the function involves constructing a command string for
    FFmpeg. This command is carefully crafted to utilize FFmpeg’s `drawtext` filter,
    enabling the provided caption text to be overlaid on the video. Let’s analyze
    the command that we used in the previous code block:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分涉及构建 FFmpeg 的命令字符串。这个命令被精心设计，以利用 FFmpeg 的 `drawtext` 过滤器，使得提供的字幕文本可以叠加到视频上。让我们分析一下之前代码块中使用的命令：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s break this command down:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个命令：
- en: '**-i ${videoFile.absolutePath}**: This part of the command specifies the input
    file for FFmpeg to process. The **-i** flag is used for input files in FFmpeg
    and **${videoFile.absolutePath}** dynamically inserts the absolute path of the
    video file you’re processing.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i ${videoFile.absolutePath}**: 命令的这一部分指定了 FFmpeg 处理的输入文件。**-i** 标志用于 FFmpeg
    中的输入文件，而 **${videoFile.absolutePath}** 会动态插入正在处理的视频文件的绝对路径。'
- en: '**-vf drawtext=text=''$captionText'':...**: The **-vf** (video filter) flag
    is used to apply filters to the video. Here, the **drawtext** filter is used to
    add text to the video.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-vf drawtext=text=''$captionText'':...**: **-vf**（视频过滤器）标志用于应用过滤器到视频上。在这里，**drawtext**
    过滤器用于向视频中添加文本。'
- en: '**text=''$captionText''**: This specifies the text to be drawn. Here, **$captionText**
    is the variable holding the caption text, which is dynamically inserted into the
    command.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**text=''$captionText''**: 这指定了要绘制的文本。在这里，**$captionText** 是一个变量，用于存储字幕文本，它将被动态地插入到命令中。'
- en: '**fontcolor=white**: Sets the font color of the text to white.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fontcolor=white**: 设置文本的字体颜色为白色。'
- en: '**fontsize=24**: Defines the size of the font used for the text.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fontsize=24**: 定义用于文本的字体大小。'
- en: '**x=(w-text_w)/2**: This sets the horizontal position of the text. Here, **w**
    represents the width of the video, and **text_w** is the width of the text. By
    setting **x to (w-text_w)/2**, the text is horizontally centered.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x=(w-text_w)/2**: 这设置了文本的水平位置。在这里，**w** 代表视频的宽度，而 **text_w** 是文本的宽度。通过将 **x**
    设置为 **(w-text_w)/2**，文本在水平方向上居中。'
- en: '**y=(h-text_h)/2**: Similarly, this sets the vertical position of the text.
    Here, **h** is the height of the video, and **text_h** is the height of the text.
    This formula vertically centers the text within the video.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**y=(h-text_h)/2**: 类似地，这设置了文本的垂直位置。在这里，**h** 是视频的高度，而 **text_h** 是文本的高度。这个公式在视频内垂直居中文本。'
- en: '**-codec:a acc**: This part of the command instructs FFmpeg to use **acc**
    as the codec for audio streaming.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-codec:a acc**: 命令的这一部分指示 FFmpeg 使用 **acc** 作为音频流的编解码器。'
- en: '**-b:a=192k**: This part of the command sets the bitrate to 192k.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-b:a=192k**：命令的这一部分将比特率设置为192k。'
- en: '**${outputFile.absolutePath}**: The last part of the command specifies the
    output file’s path, where the processed video (with the caption added) will be
    saved.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**${outputFile.absolutePath}**：命令的最后部分指定了输出文件的路径，处理并添加了字幕的视频将保存在这里。'
- en: Executing this FFmpeg command is handled asynchronously with `FFmpeg.executeAsync()`.
    This method is pivotal for running the command in a non-blocking manner and is
    accompanied by a Lambda function for handling the execution result. The Lambda
    function evaluates `returnCode` from the FFmpeg execution. In the case of a non-successful
    execution (indicated by any return code other than `RETURN_CODE_SUCCESS`), the
    function constructs `Result.failure`, wrapping a custom `AddCaptionToVideoError`
    object. This custom error object, defined as a singleton, provides a specific
    error message indicating an issue with the captioning process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FFmpeg.executeAsync()`异步执行这个FFmpeg命令。这个方法对于以非阻塞方式运行命令至关重要，并伴随着一个Lambda函数来处理执行结果。Lambda函数评估FFmpeg执行中的`returnCode`。在非成功执行（由除`RETURN_CODE_SUCCESS`之外任何返回代码指示）的情况下，函数构建`Result.failure`，并包装一个自定义的`AddCaptionToVideoError`对象。这个自定义错误对象被定义为单例，提供了一个特定的错误消息，指示字幕处理过程中存在问题。
- en: On the flip side, successful command execution results in `Result.success`,
    passing along `outputFile`. This bifurcation in handling success and failure scenarios
    ensures robust error management and clear feedback regarding the outcome of the
    captioning process.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，成功执行命令会导致`Result.success`，并传递`outputFile`。这种处理成功和失败场景的分岔确保了健壮的错误管理和关于字幕处理过程结果的清晰反馈。
- en: 'Now, we can use `AddCaptionToVideoUseCase` in `StoryEditorViewModel`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`StoryEditorViewModel`中使用`AddCaptionToVideoUseCase`：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We start by injecting `AddCaptionToVideoUseCase` into `StoryEditorViewModel`
    using its constructor. Then, we declare a `videoFile` variable in `ViewModel`,
    which holds the video we’re working with – it’s nullable because there might be
    times when we don’t have a video to display or edit. In `videoFile`, we should
    have stored the view we have already recorded.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过构造函数将`AddCaptionToVideoUseCase`注入到`StoryEditorViewModel`中。然后，我们在`ViewModel`中声明一个`videoFile`变量，它持有我们正在处理的视频——它是可空的，因为可能有时我们没有视频来显示或编辑。在`videoFile`中，我们应该存储已经记录的视图。
- en: Next, the core function in this `ViewModel` is `addCaptionToVideo`. This function
    takes the caption text as input and uses the video file we have. First, it checks
    if `videoFile` isn’t `null`. If we have a video, it proceeds; if not, nothing
    happens.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这个`ViewModel`的核心函数是`addCaptionToVideo`。这个函数以字幕文本作为输入，并使用我们拥有的视频文件。首先，它会检查`videoFile`是否不是`null`。如果我们有视频，它就会继续进行；如果没有，则什么都不发生。
- en: Inside `addCaptionToVideo`, by launching a coroutine within `viewModelScope`,
    we ensure that our caption-adding process doesn’t freeze the UI. This is crucial
    for maintaining a smooth user experience.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addCaptionToVideo`函数内部，通过在`viewModelScope`中启动协程，我们确保我们的字幕添加过程不会冻结UI。这对于保持流畅的用户体验至关重要。
- en: The `addCaption` method of our use case is then called with the video file and
    caption text. Whatever comes back from this operation – success or failure – is
    stored in the result.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用视频文件和字幕文本调用我们的用例的`addCaption`方法。无论这个操作返回什么——成功或失败——都会存储在结果中。
- en: The `// Handle the result of the captioning process` comment is where you’d
    put our code to update the UI based on the result. This could mean displaying
    the captioned video, showing an error message, or whatever else makes sense for
    our app. For simplicity, we won’t be adding it here just yet, but we will learn
    more about video playback in the last three chapters of this book when we create
    a Netflix-esque app.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 处理字幕处理过程的结果`注释是放置我们根据结果更新UI的代码的地方。这可能意味着显示带有字幕的视频，显示错误消息，或者对我们应用有意义的任何其他操作。为了简单起见，我们暂时不会在这里添加它，但当我们创建类似Netflix的应用时，我们将在本书的最后三章中了解更多关于视频播放的内容。'
- en: 'But we can still test the effect in our video. We just have to look at the
    internal app files using Device Explorer in Android Studio. There, we’ll see two
    files – one of the original video, and the other a modified one with the `_captioned`
    suffix:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然可以在我们的视频中测试效果。我们只需使用Android Studio中的设备资源管理器查看内部应用文件。在那里，我们会看到两个文件——一个是原始视频，另一个是带有`_captioned`后缀的修改版：
- en: '![Figure 6.3: Device Explorer with video files in Android Studio](img/B19443_06_03.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：Android Studio中的设备资源管理器，包含视频文件](img/B19443_06_03.jpg)'
- en: 'Figure 6.3: Device Explorer with video files in Android Studio'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Android Studio中的设备资源管理器，包含视频文件
- en: 'If we download the captioned file video and play it, we should see that a caption
    has been added to the video:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们下载带有字幕的视频文件并播放，我们应该能看到视频已经添加了字幕：
- en: '![Figure 6.4: A video with caption text stating, “This is the caption text”](img/B19443_06_04.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：带有“这是字幕文本”文字的视频](img/B19443_06_04.jpg)'
- en: 'Figure 6.4: A video with caption text stating, “This is the caption text”'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：带有“这是字幕文本”文字的视频
- en: Now that we know how to apply a caption to our video, let’s see how we can apply
    a filter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何将字幕应用到我们的视频上，让我们看看如何应用过滤器。
- en: Adding a filter to a video with FFmpeg
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FFmpeg为视频添加过滤器
- en: In this section, we will learn how to add a filter to our video. A popular filter
    that is visually impactful is the “vignette” effect – this effect typically darkens
    the edges of the frame, drawing the viewer’s attention toward the center of the
    image or video, and can add a dramatic or cinematic quality to the footage. FFmpeg
    has the capability to apply this artistic filter to videos, so let’s try it out!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为我们的视频添加过滤器。一个视觉上影响显著的流行过滤器是“渐晕”效果——这种效果通常会使画面的边缘变暗，将观众的注意力引向图像或视频的中心，并可以为视频增添戏剧性或电影般的质感。FFmpeg具有应用这种艺术过滤器到视频的能力，所以让我们试试吧！
- en: 'As we did with the caption, we will start by creating the use case: `AddVignetteEffectUseCase`.
    The primary role of `AddVignetteEffectUseCase` is to execute the business logic
    for applying the vignette effect to a given video file by using `mobile-ffmpeg`.
    We will use a specific `FFmpeg` command, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对字幕所做的那样，我们将首先创建用例：`AddVignetteEffectUseCase`。`AddVignetteEffectUseCase`的主要作用是使用`mobile-ffmpeg`执行将渐晕效果应用到给定视频文件的业务逻辑。我们将使用特定的`FFmpeg`命令，如下所示：
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s walk through the code in `AddVignetteEffectUseCase`. Here, `addVignetteEffect`
    is a suspend function, meaning it’s designed to run asynchronously with Kotlin’s
    coroutines. In this function, we take the video file that needs the vignette effect
    and start by defining where to save the processed video. We keep the original
    video intact and create a new file for the output. The output’s filename keeps
    the original name but with `_vignetted` added to it so that it’s easy to track.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析`AddVignetteEffectUseCase`中的代码。在这里，`addVignetteEffect`是一个挂起函数，意味着它被设计为与Kotlin的协程异步运行。在这个函数中，我们获取需要渐晕效果的视频文件，并首先定义处理后的视频的保存位置。我们保留原始视频不变，并为输出创建一个新文件。输出文件的名称保留了原始名称，但添加了`_vignetted`以便于追踪。
- en: 'Next up, we build our FFmpeg command. This command tells FFmpeg to apply the
    vignette effect. Let’s see how this command (already present in the previous code
    block) works in detail:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建FFmpeg命令。这个命令告诉FFmpeg应用渐晕效果。让我们详细看看这个命令（已在之前的代码块中存在）是如何工作的：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command is composed of the following segments:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令由以下部分组成：
- en: '**-i ${videoFile.absolutePath}**: This part of the command specifies the input
    file for FFmpeg to process. The **-i** flag is used for input files in FFmpeg
    and **${videoFile.absolutePath}** dynamically inserts the absolute path of the
    video file you want to process. In simple terms, it tells FFmpeg, “Here’s the
    video I want you to work on.”'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i ${videoFile.absolutePath}**：这个命令部分指定了FFmpeg要处理的输入文件。**-i**标志用于FFmpeg中的输入文件，而**${videoFile.absolutePath}**动态插入要处理的视频文件的绝对路径。简单来说，它告诉FFmpeg，“这是我想要你处理的视频。”'
- en: '**-vf vignette=angle=PI/4**: This segment is where the vignette effect is applied.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-vf vignette=angle=PI/4**：这个部分是应用渐晕效果的地方。'
- en: '**-vf** stands for video filters and is a powerful feature in FFmpeg that allows
    you to apply various transformations or effects to your video.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-vf**代表视频过滤器，是FFmpeg中的一个强大功能，允许你将各种转换或效果应用到你的视频上。'
- en: '**vignette=angle=PI/4**: This is the specific filter and setting for the vignette
    effect. The vignette filter in FFmpeg is used to apply the vignette effect, which
    typically darkens the edges of the video to focus attention on the center. The
    **angle=PI/4** part is a parameter of the vignette filter that controls the angle
    of the effect. This specific setting, **PI/4**, is chosen to give a visually pleasing
    vignette. It’s a bit of a creative choice, balancing subtlety and impact.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vignette=angle=PI/4**：这是渐晕效果的特定过滤器和设置。FFmpeg中的渐晕过滤器用于应用渐晕效果，通常会使视频的边缘变暗，以聚焦于中心。**angle=PI/4**部分是渐晕过滤器的参数，用于控制效果的角度。这个特定的设置**PI/4**是为了提供一个视觉上令人愉悦的渐晕效果。这有点像是一种创意选择，平衡了微妙和影响。'
- en: '**${outputFile.absolutePath}**: The last part of the command specifies where
    to save the processed video. It takes the path where you want the new video (with
    the vignette effect applied) to be saved. By placing it here in the command, you’re
    telling FFmpeg, “Once you’re done adding the effect, save the new video here.”'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**${outputFile.absolutePath}**：命令的最后部分指定了处理后的视频的保存位置。它接受你想要保存新视频（应用了图章效果）的路径。通过将此路径放在命令中，你是在告诉FFmpeg，“一旦你添加了效果，就将新视频保存到这里。”'
- en: When it comes to running this command, we use `FFmpeg.executeAsync`. This method
    is great because it runs our command without blocking the app. The method also
    has a way to check if everything went as planned. If the command runs successfully,
    we return the path of our new vignette video. But if something goes wrong, we
    catch it and return an error. Here, `AddVignetteEffectError` is a custom error
    message we throw if the FFmpeg command doesn’t execute properly. It’s a simple
    way to know exactly what went wrong when we add our vignette effect. And with
    this, `AddVignetteUseCase` is ready.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此命令时，我们使用`FFmpeg.executeAsync`。这个方法很棒，因为它在运行我们的命令时不会阻塞应用程序。该方法还有一个检查是否一切按计划进行的方式。如果命令运行成功，我们返回新图章视频的路径。但如果出现问题，我们会捕获它并返回一个错误。在这里，`AddVignetteEffectError`是我们抛出的自定义错误消息，如果FFmpeg命令没有正确执行。这是一个简单的方法，在添加图章效果时，我们可以确切地知道出了什么问题。有了这个，`AddVignetteUseCase`就准备好了。
- en: 'Now, we can integrate this use case into `StoryEditorViewModel`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个用例集成到`StoryEditorViewModel`中：
- en: '[PRE29]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `StoryEditorViewModel` is structured to receive `AddVignetteEffectUseCase`
    as a dependency.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`StoryEditorViewModel`被设计为接收`AddVignetteEffectUseCase`作为依赖项。
- en: Within this ViewModel, we maintain a `videoFile` property, which holds a reference
    to the video file that the vignette effect will be applied to. The nullable nature
    of this property allows for scenarios where a video file may not be immediately
    available.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个ViewModel中，我们维护一个`videoFile`属性，它包含一个引用，指向将要应用图章效果的视频文件。这个属性的可以为空性允许存在视频文件可能无法立即可用的情况。
- en: The function to execute this functionality is `addVignetteEffectToVideo`. When
    invoked, this function checks whether `videoFile` is not null, ensuring that there
    is a valid file to process. If a video file is available, the function proceeds
    to launch a coroutine within `viewModelScope`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此功能的函数是`addVignetteEffectToVideo`。当调用此函数时，它会检查`videoFile`是否不为空，确保有一个有效的文件可以处理。如果可用视频文件，函数将继续在`viewModelScope`中启动一个协程。
- en: Inside the coroutine, the `addVignetteEffectUseCase.addVignetteEffect` method
    is called with the video file as its argument. This is where the vignette effect
    is applied to the video. The result of this operation is captured in a variable
    named `result`. This result could indicate either a successful application of
    the effect or a failure due to some error.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程内部，使用视频文件作为参数调用`addVignetteEffectUseCase.addVignetteEffect`方法。这是图章效果应用到视频上的地方。这个操作的结果被捕获在一个名为`result`的变量中。这个结果可能表明效果成功应用或由于某些错误而失败。
- en: The commented section within the function, `// Handle the result of the vignette
    effect process`, is where we would typically handle the outcome of the operation.
    Depending on whether the vignette effect was successfully applied or not, this
    section could include code for updating the UI to display the processed video
    or handling any errors that might have occurred during the process.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内的注释部分`// 处理图章效果处理的结果`是我们通常处理操作结果的地方。根据图章效果是否成功应用，这部分可能包括更新UI以显示处理后的视频或处理过程中可能发生的任何错误。
- en: 'As we mentioned when we discussed adding captions, we haven’t implemented video
    playback yet, but we can still test the effect in our video. Just like back in
    *Figure 6**.3*, we can see two files, but this time one of them has a `_vignetted`
    suffix to indicate it has been modified:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在讨论添加字幕时提到的，我们还没有实现视频播放，但我们仍然可以在我们的视频中测试效果。就像在*图6.3*中一样，我们可以看到两个文件，但这次其中一个文件有一个`_vignetted`后缀来表示它已经被修改：
- en: '![Figure 6.5: Device Explorer in Android Studio](img/B19443_06_05.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：Android Studio中的设备资源管理器](img/B19443_06_05.jpg)'
- en: 'Figure 6.5: Device Explorer in Android Studio'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：Android Studio中的设备资源管理器
- en: 'We can download and reproduce both videos to check and test the filter:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以下载并重新生成这两个视频来检查和测试过滤器：
- en: '![Figure 6.6: Video without (left) and with (right) the vignette filter effect
    applied](img/B19443_06_06.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6：应用图章过滤器效果前（左）和后（右）的视频](img/B19443_06_06.jpg)'
- en: 'Figure 6.6: Video without (left) and with (right) the vignette filter effect
    applied'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：应用了（右）和未应用（左）渐晕滤镜效果的视频
- en: Now that we know how to integrate FFmpeg and use its commands to edit the user’s
    videos, it is time to upload those videos so that they can be shared between their
    contacts.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何集成FFmpeg并使用其命令编辑用户的视频，是时候上传这些视频，以便它们可以在他们的联系人之间共享。
- en: Uploading the video
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传视频
- en: Now that our video is ready, it’s time to upload it to any service, from where
    it can be shared with the user contacts. We’re going to use Firebase Storage for
    this (to learn how to set up Firebase Storage, please refer to [*Chapter 3*](B19443_03.xhtml#_idTextAnchor060)).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在视频已经准备好了，是时候将其上传到任何服务，以便用户可以与他们的联系人共享。我们将使用Firebase存储来完成这项工作（有关如何设置Firebase存储的说明，请参阅[*第3章*](B19443_03.xhtml#_idTextAnchor060)）。
- en: 'We’ll start by creating a data source that will be responsible for uploading
    the video to Firebase Storage. We will call it `VideoStorageDataSource`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个数据源，负责将视频上传到Firebase存储。我们将称之为`VideoStorageDataSource`：
- en: '[PRE30]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Inside the `uploadVideo` function, we start indicating that we’ll execute the
    logic in the I/O dispatcher.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在`uploadVideo`函数内部，我们开始指示我们将执行I/O派发器的逻辑。
- en: Then, the heart of the function is where we use Firebase Storage. First, we
    obtain the reference of the storage using `FirebaseStorage.getInstance().reference`,
    after which we set up a reference to where we want our video to be stored in Firebase
    using `storageReference.child("videos/${videoFile.name}")`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数的核心部分是我们使用Firebase存储。首先，我们使用`FirebaseStorage.getInstance().reference`获取存储的引用，之后我们设置一个引用，用于在Firebase中存储我们的视频，使用`storageReference.child("videos/${videoFile.name}")`。
- en: Next, we start the upload itself. The `putFile` method is used to upload the
    video file. This is where `await()` comes into play. This `await()` is a suspending
    function that patiently waits for the upload to complete without blocking the
    thread. It’s part of Kotlin’s coroutines magic and is a game-changer for async
    operations.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始上传本身。使用`putFile`方法上传视频文件。这就是`await()`发挥作用的地方。这个`await()`是一个挂起函数，它耐心地等待上传完成，而不会阻塞线程。它是Kotlin协程魔法的一部分，是异步操作的一个变革者。
- en: Once the upload is done, we need to grab the URL of our video. So, we call `downloadUrl.await()`.
    Just like with the upload, `await()`suspends the operation until Firebase gives
    us the video’s URL.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上传完成，我们需要获取我们视频的URL。因此，我们调用`downloadUrl.await()`。就像上传一样，`await()`会挂起操作，直到Firebase给我们提供视频的URL。
- en: We’ve also got our error handling covered. The upload and URL retrieval process
    is wrapped in a `try-catch` block. If anything goes sideways during the upload
    or while fetching the URL, we catch the exception and wrap it up in `Result.failure(e)`.
    On the other hand, if all goes well, we return `Result.success(downloadUrl.toString())`,
    handing over the URL of the newly uploaded video.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还处理了错误处理。上传和URL检索过程被包裹在一个`try-catch`块中。如果在上传或获取URL的过程中出现任何问题，我们会捕获异常并将其包裹在`Result.failure(e)`中。另一方面，如果一切顺利，我们返回`Result.success(downloadUrl.toString())`，传递新上传视频的URL。
- en: 'Next, we will implement the repository that will be responsible for managing
    and connecting the data sources to the domain layer. We will call its interface
    `VideoRepository` and the implementation `VideoRepositoryImpl`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个负责管理并将数据源连接到领域层的仓库。我们将将其接口命名为`VideoRepository`，实现为`VideoRepositoryImpl`：
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'First up, we have our `VideoRepository` interface. This is a straightforward
    Kotlin interface with one key function: `uploadVideo`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的`VideoRepository`接口。这是一个简单的Kotlin接口，包含一个关键功能：`uploadVideo`。
- en: Next, we have the `VideoRepositoryImpl` class, which implements the `VideoRepository`
    interface. This class is where the action happens. It’s initialized with an instance
    of `VideoStorageDataSource`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`VideoRepositoryImpl`类，它实现了`VideoRepository`接口。这个类是动作发生的地方。它使用`VideoStorageDataSource`的实例进行初始化。
- en: Then, the `uploadVideo` function follows a `try-catch` pattern for robust error
    handling. Initially, it sets up a default `uploadResult` as a failure. This is
    a cautious approach, assuming things might go wrong, and we’ll update this only
    if the upload succeeds.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`uploadVideo`函数遵循`try-catch`模式以实现健壮的错误处理。最初，它设置一个默认的`uploadResult`为失败。这是一种谨慎的方法，假设事情可能会出错，并且我们只有在上传成功时才会更新它。
- en: Then, we call `uploadVideo` on `videoStorageDataSource`, passing the video file
    along with two Lambda functions for handling success and failure. If the upload
    is successful, the success Lambda updates `uploadResult` with the URL of the uploaded
    video. If there’s a failure, the failure Lambda updates `uploadResult` with the
    encountered exception.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`videoStorageDataSource`上调用`uploadVideo`方法，传递视频文件以及两个Lambda函数来处理成功和失败的情况。如果上传成功，成功Lambda将`uploadResult`更新为已上传视频的URL。如果出现失败，失败Lambda将`uploadResult`更新为遇到的异常。
- en: Finally, we return `uploadResult`. If all goes well, we’ll see the URL of the
    uploaded video. If not, we’ll see the error that occurred during the process.
    The `try-catch` block ensures that if there’s an unexpected exception anywhere
    in this process, we catch it and return it as a failure.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回`uploadResult`。如果一切顺利，我们将看到已上传视频的URL。如果不顺利，我们将看到在过程中发生的错误。`try-catch`块确保如果在整个过程中出现任何意外的异常，我们将捕获它并将其作为失败返回。
- en: 'Now, it’s time for us to implement `UploadVideoUseCase`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们实现`UploadVideoUseCase`的时候了：
- en: '[PRE32]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we are injecting `VideoRepository`. In the `uploadVideo` function, we
    call `videoRepository` and pass `videoFile` as a parameter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注入了`VideoRepository`。在`uploadVideo`函数中，我们调用`videoRepository`并传递`videoFile`作为参数。
- en: 'Finally, we will include `UploadVideoUseCase` in `StoryEditorViewModel` and
    use it from there:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`UploadVideoUseCase`包含在`StoryEditorViewModel`中，并从那里使用它：
- en: '[PRE33]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In `StoryEditorViewModel`, we add a function called `uploadVideo` that takes
    the video file and uses `uploadVideoUseCase` to upload it. The operation is performed
    within a coroutine to ensure it doesn’t block the UI thread.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StoryEditorViewModel`中，我们添加了一个名为`uploadVideo`的函数，它接受视频文件并使用`uploadVideoUseCase`来上传它。操作在协程中执行，以确保它不会阻塞UI线程。
- en: The `// Handle the result of the upload process` comment is where we would implement
    the logic based on the outcome of the upload. If the upload is successful, we
    might update the UI to show that the video has been uploaded or display the video
    URL. In case of failure, we would handle the error, perhaps by showing an error
    message to the user.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 处理上传过程的结果`注释处是我们根据上传结果实现逻辑的地方。如果上传成功，我们可能会更新UI以显示视频已上传或显示视频URL。在失败的情况下，我们会处理错误，可能通过向用户显示错误消息。'
- en: And with this change, we are ready to upload the video from our ViewModel. By
    doing this, we have completed this chapter, as well as our work on Packtagram!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次更改，我们准备好从我们的ViewModel上传视频。通过这样做，我们完成了这一章，以及Packtagram的工作！
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Wrapping up this chapter, you’ve significantly leveled up your Packtagram app’s
    video capabilities.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一章，你显著提升了Packtagram应用的视频功能。
- en: Starting with CameraX, we expanded its use from snapping photos to capturing
    high-quality videos, but this was just the beginning. Then, we dived into FFmpeg,
    an incredibly versatile tool for video editing. Here, you learned how to add a
    creative touch to videos, be it through captions that tell a story or filters
    that change the entire look and feel.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从CameraX开始，我们将它的用途从拍照扩展到捕捉高质量视频，但这只是个开始。随后，我们深入研究了FFmpeg，这是一个功能极其强大的视频编辑工具。在这里，你学习了如何为视频增添创意，无论是通过讲述故事的字幕还是通过改变整体外观和感觉的滤镜。
- en: But what’s a great video if it can’t be shared? We tackled that too by integrating
    Firebase Storage for seamless video uploads. This means your app is now adept
    at handling large files smoothly, ensuring users enjoy a hiccup-free experience.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果一部视频不能分享，那它又有什么伟大之处呢？我们也通过集成Firebase Storage解决了这个问题，以实现无缝的视频上传。这意味着你的应用现在能够平滑地处理大文件，确保用户享受无故障的体验。
- en: 'With this chapter, we have finished our work on Packtagram. Now, it’s time
    to learn about the project that will be implemented in the last three chapters:
    a video playback app so that you can view your favorite series and films!'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一章，我们完成了Packtagram的工作。现在，是时候学习将在最后三章中实现的项目了：一个视频播放应用，这样你就可以观看你最喜欢的电视剧和电影了！
