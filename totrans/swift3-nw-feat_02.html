<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Discovering New Territories &#x2013; Linux at Last!"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Discovering New Territories – Linux at Last!</h1></div></div></div><p>Until recently, developing for Swift meant you needed a Mac, loaded with the Xcode IDE. However, all of that changed when Apple open sourced the Swift programming language in December 2015. A brave new world has been opened to us as developers, as Swift can now run on Linux! In addition, you now have access to preview releases and have direct access to the development trunk from which you can download development snapshots (for example, non-official prebuilt binaries of Swift).</p><p>This is going to be a packed chapter, and I want to highlight what we will cover. My goal is to show you where to find the latest Swift source for both Mac and Linux. I will also provide instruction on how to use <span class="emphasis"><em>toolchains</em></span> and explain how the Swift package manager works. Last, we will develop our first program on Linux.</p><div class="section" title="Downloading Swift"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Downloading Swift</h1></div></div></div><p>In order to get started working with Swift 3, you need to download either a prebuilt binary (also known as a <span class="emphasis"><em>toolchain</em></span>) or the source code to build the Swift library yourself. The Swift.org (<a class="ulink" href="https://swift.org">https://swift.org</a>) website hosts a <span class="strong"><strong>Download</strong></span> section <a class="ulink" href="https://swift.org/download/">https://swift.org/download/</a> that maintains a list of releases, previews and snapshots:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Release builds</strong></span>:<span class="strong"><strong> </strong></span>Maintains links to the current release and older official releases of Swift.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Preview builds</strong></span>:<span class="strong"><strong> </strong></span>Contains links to developer previews, also known as <span class="emphasis"><em>seeds</em></span> or <span class="emphasis"><em>betas</em></span>. These binaries are not considered final releases but do provide a fairly stable version of the work completed to that date for upcoming releases.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Developer snapshots</strong></span> - Are pre-built binaries from the development branch. These builds contain the latest development changes and have gone through automated unit testing but are not guaranteed to be stable. Snapshot builds are not put through the full testing process.</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note4"/>Note</h3><p>Since learning to build the binary isn't critical to your knowledge of learning Swift 3, we will leave compiling the source as an exercise for you to try on your own at some point. You can find the source code on Apple's GitHub (<a class="ulink" href="https://github.com/apple">https://github.com/apple</a>) along with build instructions.</p></div></div></div></div>
<div class="section" title="Swift 3 on Mac"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Swift 3 on Mac</h1></div></div></div><p>To get up and going on a Mac, you simply need to choose the type of Swift <span class="emphasis"><em>toolchain</em></span> you want to develop against. You can choose a version from the <span class="strong"><strong>Download</strong></span> section. Swift on a Mac is included with Xcode, making it really easy to get started. Swift 3 requires you to have macOS 10.11.5 (El Capitan) or later and Xcode 8. Let's walk through the steps together and install Swift 3 on a Mac.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Download a toolchain</strong></span> - Grab the latest Swift 3 release or preview candidate from the downloads page on <a class="ulink" href="https://swift.org/">https://swift.org/</a>. Xcode is created and maintained by Apple, selecting a release to download from <a class="ulink" href="https://swift.org/">https://swift.org/</a> will take you to Apple's downloads section on their developer portal.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note5"/>Note</h3><p>An Xcode toolchain is a special binary with a toolchain extension that includes Xcode and all of the tools and libraries that make up Swift (LLVM, LLDB, REPL, and other tools) all targeted at a specific Swift version. You can think of a toolchain as a bundled development environment that you install and extract onto your system to work with a specific release. When you want to try out a different version, you have to download and install the toolchain that corresponds to the target version.</p></div></div></li><li class="listitem"><span class="strong"><strong>Run the package installer</strong></span> - This will install Xcode (toolchain).<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note6"/>Note</h3><p>The Xcode package that you download for a release or developer snapshot should be digitally signed with a developer ID (Developer ID Installer: Swift Open Source (V9AUD2URP3)) of the open source project to protect against malicious code and tampering. The Swift installer should display a lock on the right side of the title bar. When you click the lock, you should see details on the developer signature.</p></div></div></li><li class="listitem"><span class="strong"><strong>Select a Toolchain [Optional]</strong></span> - If this is the only Swift version on your machine, you can skip this step. However, if you have multiple developer snapshots or previews, you can tell Xcode which version to use by navigating to Preferences, choosing <span class="strong"><strong>Components </strong></span>|<span class="strong"><strong> Toolchains</strong></span> or using the <span class="strong"><strong>Toolchains</strong></span> menu listed under <span class="strong"><strong>Preferences...</strong></span> directly:<p>
</p><div class="mediaobject"><img alt="Swift 3 on Mac" src="graphics/image_02_001.jpg"/><div class="caption"><p>Selecting Toolchains in Xcode 8</p></div></div><p>
</p></li><li class="listitem">Next, you select the <span class="strong"><strong>Toolchain</strong></span> you want to develop against, which will only change the Xcode settings. If you want your command line tools settings to change as well, you need to configure those using the <span class="emphasis"><em>xcrun</em></span> and <span class="emphasis"><em>xcodebuild</em></span>.<p>
</p><div class="mediaobject"><img alt="Swift 3 on Mac" src="graphics/image_02_002.jpg"/><div class="caption"><p>Toolchains menu in Xcode</p></div></div><p>
</p></li><li class="listitem">Each command has an option to point to a specified Swift <code class="literal">toolchain</code>.<pre class="programlisting">
<span class="strong"><strong>       $ xcrun --toolchain swift &#13;
       $ xcodebuild --toolchain swift</strong></span>
</pre></li></ol></div><p>Once you have your <span class="emphasis"><em>toolchain</em></span> installed on your Mac, you simply need to launch Xcode and you can begin developing. Since we will spend the majority of the next few chapters tackling new Swift features using Xcode, we are going to shift gears and spend the rest of this chapter discussing Swift on Linux.</p></div>
<div class="section" title="Swift 3 on Linux"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Swift 3 on Linux</h1></div></div></div><p>The Swift team currently supports installing Linux on Ubuntu 14.04 or 15.10 (64-bit). On Linux, Swift packages are distributed as tar archives. Each package includes the Swift compiler, the LLDB debugger, and tools related to doing development in Swift.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note7"/>Note</h3><p>If you don't have access to a Linux box, you can create a virtual machine using VirtualBox <a class="ulink" href="https://www.virtualbox.org">https://www.virtualbox.org</a> and Vagrant <a class="ulink" href="https://www.vagrantup.com">https://www.vagrantup.com</a>.</p><p>VirtualBox is a virtualization application that runs on multiple platforms and allows you to install another OS. You can download the latest version from <a class="ulink" href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>.</p><p>Vagrant is a configuration and provisioning package that allows you to install and configure a complete development environment. You can find instructions on how to install and configure a Linux box at this location <a class="ulink" href="https://www.vagrantup.com/">https://www.vagrantup.com/</a>
</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to install our required dependencies. Run the following command:<pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install clang libicu-dev</strong></span>
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">clang</code> : The C language front-end for LLVM compiler.</li><li class="listitem" style="list-style-type: disc"><code class="literal">libicu-dev</code> : An Ubuntu package written in C++ and C that provides a solid full-featured Unicode and local support.</li></ul></div></li><li class="listitem">We need to download a <span class="emphasis"><em>toolchain</em></span> along with a <span class="emphasis"><em>.sig</em></span> file that serves as the <span class="emphasis"><em>toolchain</em></span>'s digital signature. The <span class="emphasis"><em>toolchain</em></span> has the format <code class="literal">swift-&lt;VERSION&gt;-&lt;PLATFORM&gt;.tar.gz</code>, and the digital signature file has the same format with extension <span class="emphasis"><em>
<code class="literal">.sig</code>.</em></span></li><li class="listitem">We are going to install a preview <span class="emphasis"><em>toolchain</em></span> for Ubuntu 14.04. Copy the link for the <span class="emphasis"><em>toolchain</em></span> and download the files to your Linux machine.</li><li class="listitem">Download the <code class="literal">toolchain</code> file:<pre class="programlisting">
<span class="strong"><strong>      $ wget https://swift.org/builds/swift-3.0-preview-2/ubuntu1404/&#13;
      swift-3.0-PREVIEW-2/swift-3.0-PREVIEW-2-ubuntu14.04.tar.gz</strong></span>
</pre></li><li class="listitem">Download the digital signature file:<pre class="programlisting">
<span class="strong"><strong>      $ wget https://swift.org/builds/swift-3.0-preview-2/ubuntu1404&#13;
      /swift-3.0- PREVIEW-2/swift-3.0-PREVIEW-2-ubuntu14.04.tar.gz.sig &#13;
 &#13;
</strong></span>
</pre></li><li class="listitem">Import PGP keys for verifying the integrity of our <span class="emphasis"><em>toolchain</em></span>. You only need to download the keys once:<pre class="programlisting">
<span class="strong"><strong>      $ wget -q -O - https://swift.org/keys/all-keys.asc | gpg --import -</strong></span>
</pre></li><li class="listitem">We verify our downloaded <span class="emphasis"><em>toolchain</em></span> using the PGP key we imported.</li><li class="listitem">Refresh your keys and download any newly available certificates:<pre class="programlisting">
<span class="strong"><strong>      $ gpg --keyserver hkp://pool.sks-keyservers.net --refresh-keys Swift</strong></span>
</pre></li><li class="listitem">Then we verify that the signature file we downloaded is good:<pre class="programlisting">
<span class="strong"><strong>      $gpg--verify swift-3.0-PREVIEW-2-ubuntu14.04.tar.gz.sig &#13;
      gpg: Signature made Thu 07 Jul 2016 11:12:12 PM UTC using&#13;
      RSA key ID 91D306C6 &#13;
      gpg: Good signature from "Swift 3.x Release Signing Key &lt;swift-&#13;
      infrastructure@swift.org&gt;" &#13;
      gpg: WARNING: This key is not certified with a trusted signature! &#13;
      gpg: There is no indication that the signature belongs to the owner. &#13;
      Primary key fingerprint: A3BA FD35 56A5 9079 C068 94BD 63BC&#13;
      1CFE 91D3 06C6</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note8"/>Note</h3><p>If our <code class="literal">
<span class="emphasis"><em>gpg</em></span>
</code> verify statement returns a <code class="literal">Bad signature</code> then do not open the <span class="emphasis"><em>toolchain</em></span> and report the problem to <code class="literal">swift-infrastructure@swift.org</code>.</p></div></div></li><li class="listitem">Extract the <span class="emphasis"><em>toolchain</em></span> from the archive:<pre class="programlisting">
<span class="strong"><strong>      $ tar xzf swift-3.0-PREVIEW-2-ubuntu14.04.tar.gz</strong></span>
</pre></li><li class="listitem"> We need to include the <span class="emphasis"><em>/usr</em></span> directory to our path so that we can execute the swift command for using the REPL environment. Add the Swift <span class="emphasis"><em>toolchain</em></span> to your path:<pre class="programlisting">
<span class="strong"><strong>      $ export PATH=/home/vagrant/swift-3.0-PREVIEW-2-&#13;
      ubuntu14.04/usr/bin:"${PATH}"</strong></span>
</pre></li></ol></div></div>
<div class="section" title="Using the REPL"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Using the REPL</h1></div></div></div><p>Once we have Swift installed, we can use the Swift REPL (Read Evaluate Print Loop) environment and give Swift a test run on Linux. The Swift REPL environment and LLDB debugger are tightly linked to the <span class="emphasis"><em>toolchain</em></span>, which aids in Swift type inference, syntax, and expression evaluation. Basically, it makes the compiler, debugger, and REPL environment's jobs easier if there is only one version of Swift to worry about at a time. Let's start the REPL environment and execute a few commands to get familiar with the REPL environment's capabilities.</p><p>To start the Swift REPL, you type the swift command:</p><pre class="programlisting">
<span class="strong"><strong>$ swift</strong></span>
</pre><p>As we add statements, the REPL environment is smart enough to only execute once you have completely entered a statement. We can create assignment statements, functions, or even entire classes.</p><p>At the REPL prompt, let's assign:</p><pre class="programlisting">
<span class="strong"><strong>1&gt; let oneMillion = 1_000_000 &#13;
oneMillion: Int = 1000000 &#13;
2&gt; let twoMillion: Int = 2_000_000 &#13;
twoMillion: Int = 2000000 &#13;
3&gt; oneMillion + twoMillion &#13;
$R0: Int = 3000000 &#13;
4&gt; $R0 / 1_000_000 &#13;
$R1: Int = 3</strong></span>
</pre><p>Each time we execute a statement, the REPL environment adds the result of the statement on the following line. In our case, we have assigned the numerical values to two different variables (<code class="literal">oneMillion</code> and <code class="literal">twoMillion</code>). Our third statement adds the two variables together. Notice that the result displays as <code class="literal">$R0 Int = 3000000</code>. The Swift REPL environment will create a variable name for you if you don't assign an expression to a variable. We can use the assigned variable in future expressions. In our fourth expression, we use the value stored in <code class="literal">$R0to</code> create a new expression that divides the value by<code class="literal"> 1,000,000</code>.</p><p>As I mentioned earlier in this section, the debugger is tightly coupled to the REPL environment. If we add a bad expression, the REPL environment displays the error message as a result:</p><pre class="programlisting">5&gt; oneMillion = "one million" &#13;
error: repl.swift:11:12: error: cannot assign to value: 'oneMillion' is a 'let' constant &#13;
oneMillion = "one million" &#13;
~~~~~~~~~~~^ &#13;
repl.swift:2:1: note: change 'let' to 'var' to make it mutable` &#13;
let oneMillion = 1\_000\_000` &#13;
^~~~ &#13;
var &#13;
</pre><p>The REPL environment also supports multi-line statements, which you could use to create a function or class. To create a multi-line statement, you simply need to arrow down instead of pressing enter.</p><p>If you haven't used the REPL environment in past versions of Swift, you should give it a try. I believe the REPL environment could be very useful for experimenting on creating algorithms or testing out a function for rapid development.</p></div>
<div class="section" title="Swift Package Manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Swift Package Manager</h1></div></div></div><p>The Swift Package Manager is the Swift Army Knife that allows you to manage your code dependencies, share your own packages, and use the libraries created by others. It's an extremely important tool, one that you need to know in order to do anything productive with Swift. My goal is to provide you with a quick overview and then dive into some examples so we can use it in an example to solidify the core concepts.</p><p>Like other languages, Swift allows you to organize and group your Swift code. Swift refers to these groupings as modules. Modules in Swift allow the developer to enforce control on the functionality that is exposed publicly (outside of the module) and the functionality that is only visible within the module.</p><p>As developers, we use modules that we create or that other developers create to write our software. When we use other developers' modules, we create a dependency on their code. Swift allows us to create a package, which consists of the Swift code we write plus a manifest file to manage everything we need to build our products. The manifest file that we include in the package defines what we are building, as it includes a package name and a listing of the contents included. A Swift package can have one or more targets, each of which specifies a product or one or more dependencies.</p><p>If you have ever worked with Node.js, you can quickly see the similarities between node's package manager and Swift's package manager. Both allow the developer to define manifest files that describe the types of dependencies required to make an application work. Swift's package manager requires you to provide either a relative or absolute URL to the source and the version required. Once provided, the package manager takes over, downloading and compiling the required dependencies for you. In fact, the package manager recursively checks each dependency, evaluating a dependency to see if it has any dependencies and repeats this process until it covers the entire graph. This could be a big task depending on the size of your package.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note9"/>Note</h3><p>

<span class="strong"><strong>More Resources</strong></span></p>
:
<p>You can access the source for the Swift Package Manager here: <a class="ulink" href="https://github.com/apple/swift-package-manager">https://github.com/apple/swift-package-manager</a>.</p><p>You can learn more about how to structure your manifest files here: <a class="ulink" href="https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md">https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md
</a></p><p>You can get insights on creating your own packages here: <a class="ulink" href="https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md">https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md</a>
</p></div></div></div>
<div class="section" title="Our first Swift program"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Our first Swift program</h1></div></div></div><p>Let's create our first program on Linux using Swift. Our first project will be a package. Create a directory named <code class="literal">guesswho</code> and then enter the directory:</p><pre class="programlisting">
<span class="strong"><strong>$ mkdir guesswho &#13;
$ cd guess who</strong></span>
</pre><p>Next we need to initialize a new package with the type being an executable:</p><pre class="programlisting">
<span class="strong"><strong>$ swift package init --type executable &#13;
Creating executable package: guesswho &#13;
Creating Package.swift &#13;
Creating .gitignore &#13;
Creating Sources/ &#13;
Creating Sources/main.swift &#13;
Creating Tests/</strong></span>
</pre><p>I want to point out a couple of things about the output of swift package init. First, using the swift package init command is optional and meant only to be a utility mechanism for generating files and directories you may need. Second, the package manager expects you to put your sources files within the Sources directory. You can further nest additional directories under the <code class="literal">Sources</code> directory and the package manager will treat those directories as modules. Finally, when you want to create an executable, you need to include a <code class="literal">main.swift</code> file in the module's subdirectory or directly within the <code class="literal">Sources</code> directory in cases when you only have one target. Let's look at an example of a Swift package.</p><p>Creating a package with multiple modules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/Sources/worker/workerbot.swift</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/Sources/manager/manager.swift</code></li></ul></div><p>Running swift build on the package above creates:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/.build/debug/workerbot.a</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/.build/debug/manager.a</code></li></ul></div><p>Creating a package with one executable and one library module:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/Sources/worker/main.swift</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/Sources/manager/manager.swift</code></li></ul></div><p>Running swift build in this time would result in:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/.build/debug/workerbot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mymodule/.build/debug/manager.a</code></li></ul></div><p>Notice that our executable doesn't have an extension; however, our library file is created with a <code class="literal">
<span class="emphasis"><em>.a</em></span>
</code> extension.</p><p>Open main.swift and remove the code that is currently in there. We are going to replace the existing code with some new logic.</p><p>Let's add a function that will recursively call itself and remove the first letter of its input string from the remaining characters, repeating the task until there are no letters left in the string. Once we are finished, we execute a closure to let the caller know we are done:</p><pre class="programlisting"> func breakWord(combine result:String, input:String, done:(String?)-&gt;Void){ &#13;
      let characterArray = input.characters &#13;
      let breakoutCharacter = characterArray.first &#13;
      let remainingCharacters = characterArray.dropFirst() &#13;
     if characterArray.count &gt; 0{ &#13;
          let line = "\n\(breakoutCharacter!): \(String(remainingCharacters)) " &#13;
 &#13;
          let newResult = "\(result) \(line)" &#13;
          breakWord(combine: newResult, input:    String(remainingCharacters),&#13;
          done: done) &#13;
         return &#13;
     } &#13;
     done(result) &#13;
  } &#13;
</pre><p>Next we need to handle the arguments passed when executing our swift program. First in line 1, we store the argument lists as an array. Next, in line 2 we check to make sure we have at least one argument that we can process using our <code class="literal">breakWord(combine:)</code> function. Lines 3-8 iterate over our argument list and call our<code class="literal">breakWord(combine:)</code> function for each argument. In line 4, we use a closure expression to print the final result of our <code class="literal">breakWord(combine:)</code> routine:</p><pre class="programlisting">  let arguments = Process.arguments &#13;
  if arguments.count &gt; 1{ &#13;
    for n in 1..&lt;arguments.count{ &#13;
       breakWord(combine: "", input: arguments[n]){ (result) in &#13;
           print(result!) &#13;
       } &#13;
    } &#13;
  } &#13;
  else{ &#13;
     print("no arguments passed") &#13;
 }</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>If you prefer to see the source all in one place, you can download the code from this chapter using the following link.</p></div></div><p>Close and save <code class="literal">main.swift</code> and then compile the program using swift build. You can execute the program by typing <code class="literal">guesswho</code> along with one or more arguments:</p><pre class="programlisting">$ .build/debug/guesswho Swift 3 New Features &#13;
S: wift &#13;
w: ift &#13;
i: ft &#13;
f: t &#13;
t: &#13;
 &#13;
3: &#13;
 &#13;
N: ew &#13;
e: w &#13;
w: &#13;
 &#13;
F: eatures &#13;
e: atures &#13;
a: tures &#13;
t: ures &#13;
u: res &#13;
r: es &#13;
e: s &#13;
s: &#13;
</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we covered how to get your development environment configured for Swift development on a Mac or Linux machine. We learned about <span class="emphasis"><em>toolchains</em></span>, using the REPL environment, and the Swift Package Manager. We also created our first Swift package, which we're able to execute on Linux. If you're still with me, we will cover even more awesome things in Swift in the forthcoming chapters! If you're observant, you've probably noticed that our example package lacked a few things. Rest assured, we will take a deep dive into creating and executing tests and debugging techniques in <a class="link" href="ch09.html" title="Chapter 9. Improving Your Code with Xcode Server and LLDB Debugging">Chapter 9</a>, <span class="emphasis"><em>Improving Your Code with Xcode Server and LLDB Debugging</em></span>. We'll also come back to Linux to tackle a more complicated use case that includes adding dependencies to our package in <a class="link" href="ch10.html" title="Chapter 10. Exploring Swift on the Server">Chapter 10</a>,<span class="emphasis"><em> Exploring Swift on the Server</em></span>.</p></div></body></html>