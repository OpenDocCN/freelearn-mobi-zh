使用Swift控制流进行数据处理

编程全部关于做决定。大多数代码的目的涉及获取信息，检查它，做出决定，并产生输出。到目前为止，我们已经看到了许多表示信息的方法，但在这个章节中，我们将探索如何使用Swift的多个控制流语句根据这些信息做出决定。我们将了解它们的区别以及每种情况适用的场景。

在本章中，我们将介绍以下食谱：

+   使用`if`/`else`做出决定

+   使用`switch`处理所有情况

+   使用`for`循环进行循环

+   使用`while`循环进行循环

+   使用`try`、`throw`、`do`和`catch`处理错误

+   使用`guard`提前检查

+   使用`defer`稍后处理

+   使用`fatalError`和`precondition`退出

# 技术要求

本章的所有代码都可以在这个书的GitHub仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03)

查看以下视频以查看代码的实际运行情况：[https://bit.ly/3aq66Us](https://bit.ly/3aq66Us)

# 使用if/else做出决定

if/else语句是几乎所有编程语言的基础。它使代码能够根据布尔语句的结果有条件地执行。在这个食谱中，我们将看到if/else如何使用，包括一些Swift特有的方法。

## 准备工作

如果你曾经玩过台球，你会知道游戏的目标（当玩标准8球台球时）是将一种类型的所有球都入袋，然后入袋黑球。当使用美国台球球时，它们编号为1-15，并且根据它们的类型有不同的图案。1-7号球是实心颜色，9-15号球是带有彩色条纹的白色球，8号球是黑色的：

![](img/e68de254-2938-478c-bf86-aaa825b2a4ca.png)

图3.1 – 美国台球球

在这个食谱中，我们将编写一个函数，该函数将接受台球上的数字并返回球的类型。

## 如何做到...

让我们使用if/else控制流语句编写一个函数来返回正确的台球类型：

1.  创建一个`enum`来描述可能的球类型：

[PRE0]

1.  创建一个方法，该方法将接受一个`Int`并返回`PoolBallType`：

[PRE1]

1.  使用此函数并测试我们是否得到预期的结果：

[PRE2]

## 它是如何工作的...

在函数内部，我们定义了三个代码路径：`if`、`else if`和`else`：

[PRE3]

首先，我们想要确定球是否是实心。由于我们知道1-7号球是实心的，我们可以测试球号是否小于8，使用`number < 8`。如果是`true`，我们返回`enum`的`.solid`情况。

如果它是`false`，则评估`else if`布尔表达式。由于9-15号球是条纹球，我们可以测试球号是否大于8，使用`number > 8`。如果是`true`，我们返回`enum`的`.stripe`情况。

最后，如果前面的布尔表达式都是`false`，我们返回枚举的`.black`情况，因为那只能发生在数字正好是8的情况下。

`else if`和`else`块是可选的，并且你可以声明多个`else if`来覆盖额外的条件。让我们通过添加一个额外的`else if`来扩展前面的示例，以更好地确定台球类型。

如我们之前所述，台球编号介于1到15之间，但我们在实现中并没有考虑这些上下限。所以如果我们向函数提供球号0，它将返回`.solid`，如果我们提供球号16，它将返回`.stripe`，这并不准确地反映我们的意图：

[PRE4]

让我们修改我们的函数，使其仅在数字介于1到15之间时返回台球类型，否则返回`nil`：

[PRE5]

现在我们有四个代码分支在我们的`if`语句中，我们可以使用AND运算符`&&`来组合布尔语句（也有可用的OR运算符`||`）。

现在，我们可以为预期范围内的数字以及范围外的数字调用我们的函数：

[PRE6]

我们改进的函数将为预期范围之外的数字产生`nil`。

## 还有更多...

我们还可以使用其他一些方式来使用if/else语句。

### 理解条件展开

我们创建的函数返回一个可选值，所以如果我们想对结果值做些有用的事情，我们需要`unwrap`可选值。到目前为止，我们看到的唯一方法是通过强制展开，如果值是`nil`，这将导致崩溃。

相反，我们可以使用一个`if`语句来**条件性地展开**可选值，将其转换为更有用的非可选值。

让我们创建一个函数，用于打印给定数字的台球信息。如果提供的数字适用于台球，它将打印球号和类型；否则，它将打印一条消息说明这不是一个有效的数字。

由于我们希望打印`PoolBallType`枚举的值，让我们将其改为`String`支持的，这将使打印其值更容易：

[PRE7]

现在，让我们编写一个函数来打印台球详细信息：

[PRE8]

在我们的`printBallDetails`函数中，我们首先获取给定数字的球类型：

[PRE9]

在我们改进的函数版本中，这返回了`PoolBallType`枚举的可选版本。我们希望在打印球详细信息时包括返回的`enum`的`rawValue`。由于返回值是可选的，我们需要首先展开它：

[PRE10]

在这个 `if` 语句中，我们不是定义一个布尔表达式，而是将我们的可选值赋给一个常量；`if` 语句使用这个常量来 *条件性地解包* 可选值。可选值被检查以确定它是否为 `nil`；如果不是 `nil`，则值被解包并赋给常量作为非可选值。这个常量在 `if` 语句后面的花括号作用域内可用。我们使用这个 `ballType` 非可选值来获取 `print` 语句的原始值。

由于当可选值有值时跟随 `if-else` 语句的 `if` 分支，那么当可选值为 `nil` 时，就跟随 `else` 分支。

由于这意味着给定的数字对于球桌球来说不是有效的，我们打印一条相关的消息：

[PRE11]

我们现在可以用之前相同的值来调用我们的新函数，以打印出球桌球类型：

[PRE12]

我们已经使用条件解包来打印球桌球类型，如果有效，或者解释它为什么无效。

### 链式可选解包

`if` 语句能够条件性地解包可选值的能力可以链式组合起来，生成一些有用且简洁的代码。以下示例可能有些牵强，但它说明了我们如何使用单个 `if` 语句来解包一系列可选值。

当你玩一局斯诺克，称为 *frame*，你第一个入袋的球类型将成为整个帧中你需要入袋的类型，而你的对手则需要入袋相反类型的球。

让我们定义一个斯诺克帧，并说我们想要跟踪每个玩家将要入袋的球类型：

[PRE13]

我们还将创建一个具有可选的 `currentFrame` 属性的 `PoolTable` 对象，该属性将包含有关当前帧的信息，如果正在进行的话：

[PRE14]

现在我们有一个球桌，它有一个可选的帧，每个玩家都有一个可选的球类型。

现在，让我们编写一个函数来打印当前帧中玩家 1 的球类型。当前帧可能是 `nil`，因为没有正在进行的帧，或者玩家 1 的球类型是 `nil`，因为还没有入袋的球。因此，我们需要考虑这两种情况中的任何一种：

[PRE15]

我们的函数接收一个 `PoolTable`，要打印玩家 1 的球类型，我们首先需要检查并解包 `currentFrame` 属性，然后我们需要检查并解包当前帧的 `player1BallType` 属性。

我们可以通过嵌套我们的 `if` 语句来实现这一点：

[PRE16]

相反，我们可以通过按顺序执行解包语句（用逗号分隔）来在一个 `if` 语句中处理这种链式解包，每个语句都可以访问前一个语句解包的值：

[PRE17]

第一个语句解包了 `currentFrame` 属性，第二个语句使用这个解包的帧来解包玩家 1 的球类型。

让我们使用我们刚刚创建的函数：

1.  首先，我们将创建一个表格，并且在没有当前帧的情况下打印玩家 1 的球类型，这将不可用：

[PRE18]

1.  接下来，我们可以创建一个当前帧，但由于玩家1的球类型仍然是`nil`，函数会打印出相同的输出：

[PRE19]

1.  如果我们设置玩家1的球类型，现在我们的函数会打印出类型：

[PRE20]

我们创建了一种方法，可以链式调用条件展开，只有当链中的所有值都不是nil时才打印一个值。

### 使用具有关联值的枚举

正如我们在[第1章](f9d48715-ffca-464f-95bf-722958f02e72.xhtml)的*使用枚举枚举值*菜谱中看到的，*Swift Building Blocks*，枚举可以有关联值，我们可以使用`if`语句在一个表达式中同时检查枚举的case并提取关联值。

让我们创建一个枚举来表示台球游戏的结果，每个case都有一个关联的消息：

[PRE21]

接下来，我们将创建一个函数，它接受一个`Result`并打印祝贺消息或慰问消息：

[PRE22]

调用此函数将打印结果，然后是相关的消息：

[PRE23]

如果`=`右侧的值与左侧的case匹配，则将执行`if case`块。此外，你可以指定一个局部常量来表示关联值（以下示例中的`winMessage`），然后在后续块中可用：

[PRE24]

我们使用了`if case`语句一次性检查枚举值的case并访问其关联值。

## 相关内容

关于if/else的更多信息可以在苹果关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/statements](http://swiftbook.link/docs/statements)。

# 使用switch处理所有情况

`switch`语句允许你通过多种方式测试一个特定的值来控制执行流程。在Objective-C和其他语言中，`switch`语句只能用于可以表示为整数的值，并且最常用于基于枚举案例做出决策。

正如我们所见，**枚举**在Swift中变得更加强大，因为它们可以基于不仅仅是整数，同样`switch`语句也是如此。

Swift中的`switch`语句可以用于任何类型，并具有高级的模式匹配功能。

在这个菜谱中，我们将探索`switch`控制流语句的简单和高级用法来控制逻辑。

## 准备工作

如果你足够老，记得家用电脑的早期日子，你可能也会记得基于文本的冒险游戏。这些游戏通常描述一个场景，然后让你通过输入命令来移动北、南、东或西。你可以找到并捡起物品，并且通常可以将它们组合起来解决问题。

我们可以使用`switch`语句来控制简单文本冒险的逻辑。

## 如何做到这一点...

让我们创建一个基于文本的冒险游戏的部分，并使用`switch`语句来做出决定：

1.  定义一个`enum`来表示我们可以旅行的方向：

[PRE25]

1.  创建一个函数，描述玩家在朝某个方向看时将看到的内容：

[PRE26]

在我们的文字冒险游戏中，用户可以捡起物品并尝试将它们组合起来以产生新的物品并解决问题。

1.  将我们的可用物品定义为 `enum`：

[PRE27]

1.  编写一个函数，它接受两个物品并尝试将它们组合成一个新的物品。如果物品无法组合，它将返回 `nil`：

[PRE28]

1.  在我们的文字冒险游戏中，玩家会遇到不同的角色，并且可以与他们互动。定义玩家可以遇到的角色：

[PRE29]

1.  编写一个函数，允许玩家说些什么，并且可以选择性地提供一个角色，对他说。互动将取决于所说的内容以及所说的角色：

[PRE30]

## 它是如何工作的...

在 `lookTowards` 函数中，我们希望为每个可能的 `CompassPoint` 案例打印不同的消息；为此，我们使用 `switch` 语句：

[PRE31]

在 `switch` 语句的顶部，我们定义想要切换的值；然后我们定义当该值与定义的每个案例匹配时想要执行的操作，使用 `case` 关键字和匹配的模式：

[PRE32]

每个 `case` 语句依次评估，如果模式与值匹配，则执行后续代码。

如果你熟悉 Objective-C 中的 `switch` 语句，你可能记得你需要在每个 `case` 语句的末尾添加 `break;` 来停止执行从下一个 `case` 语句中掉落。在 Swift 中不需要这样做；执行的断开是由下一个 `case` 语句的开始隐含的。唯一不是这种情况的时候，是因为你的 `case` 语句是故意为空的；在这些情况下，你需要添加 `break` 来告诉编译器它故意为这个案例留空。如果你确实想让执行掉落到下一个 `case` 语句，你可以在 `case` 语句的末尾添加 `fallthrough`。

在我们的 `combine` 函数中，我们有两个基于其值需要切换的值。我们可以将多个值以元组的形式提供给 `switch` 语句：

[PRE33]

对于每个 `case` 语句，我们定义元组每个部分的合法值：

[PRE34]

Swift 中的 `switch` 语句要求覆盖所有可能的案例；然而，你可以使用 `default` 案例一次性覆盖所有剩余的可能性：

[PRE35]

对于我们之前的 `combine` 函数，你会注意到，玩家只有在提供正确的顺序时才能组合物品：

[PRE36]

这不是期望的行为，因为玩家无法知道正确的顺序。为了解决这个问题，我们可以在每个 `case` 语句中添加多个模式。因此，当玩家提供 `key` 和 `lockedDoor` 物品时，我们可以使用相同的 `case` 语句处理 `key`，`lockedDoor` 的顺序和 `lockedDoor`，`key` 的顺序，格式如下：

[PRE37]

因此，我们可以将相反的物品顺序作为另一个模式添加到每个案例中：

[PRE38]

现在物品可以以任何顺序组合：

[PRE39]

对于我们的`say`方法，我们再次有两个值想要切换：玩家说的文本和所说的角色。由于`character`值是可选的，我们需要展开值以与非可选值进行比较：

[PRE40]

在`switch`语句中，当值是可选的，你可以通过添加`?`将其包装为可选值来将其与非可选值进行比较，使比较有效。在上一个例子中，我们正在将可选的`character`值与`.wizard?`进行比较。

当对于一组特定选项有两个值时，我们可能只关心其中一个值，另一个值可以是任何值，并且情况仍然有效。在我们的例子中，一旦处理了所有特定的`textToSay`和字符配对，以及处理了没有字符的情况，我们想要展开并检索字符，但我们不关心`textToSay`的值，因此我们可以使用`_`来表示任何值都是可接受的：

[PRE41]

要检索作为此`case`语句一部分输入的字符值，而不是声明一个要匹配的值，我们定义一个将接收值的常量，并且由于我们正在切换的值是可选的，我们也添加了`?`，如果值不是`nil`，它将展开值并将其分配给常量。

## 参见

更多关于`switch`的信息可以在苹果关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/switch](http://swiftbook.link/docs/switch)。

# 使用`for`循环进行循环

`for`循环允许你对集合或范围中的每个元素执行代码。在本食谱中，我们将探讨如何使用`for`循环对集合中的每个元素执行操作。

## 如何做到这一点...

让我们创建一些集合，然后使用`for`循环对集合中的每个元素进行操作：

1.  创建一个元素数组，这样我们就可以对数组中的每个元素进行操作：

[PRE42]

1.  创建一个循环来遍历我们的`theBeatles`数组，并打印出`for`循环提供的每个字符串元素：

[PRE43]

1.  创建一个执行固定次数代码的`for`循环，而不是遍历数组。我们可以通过提供一个范围而不是集合来实现这一点：

[PRE44]

1.  创建一个`for`循环来打印字典的键和值。字典包含键和值的配对，因此当遍历字典时，我们将以元组的形式提供键和值：

[PRE45]

## 它是如何工作的...

让我们看看我们是如何遍历我们的`theBeatles`数组的：

[PRE46]

我们指定`for`关键字，然后为将用于集合或范围中每个元素的局部变量提供一个名称。然后，提供`in`关键字，后面跟着将要遍历的集合或范围：

[PRE47]

对于基于范围的循环，每个循环提供的值是范围内的下一个整数：

[PRE48]

范围可以是一个**闭区间**，其中范围包括起始值和结束值，就像上面指定的那样。或者它可以是**半开区间**，它向上到但不包括最后一个值，如下面的代码所示：

[PRE49]

当遍历字典时，我们需要同时提供键和值；为此，我们提供一个元组，它将接收字典中的每个键和值：

[PRE50]

我们可以定义一个元组并为每个值命名。这个名称随后可以在执行块中使用。让我们将元组的标签改为更好地描述这些值：

[PRE51]

在前面的例子中给元组赋予有意义的名称使代码更容易阅读。

## 参考资料还有

更多关于`for-in`循环的信息可以在Apple关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/for-in](http://swiftbook.link/docs/for-in)。

# 使用while循环进行循环

`for`循环在您知道要循环多少次时很棒，但如果您想循环直到满足某个条件，则需要使用`while`循环。

`while`循环的语法如下：

[PRE52]

代码块将反复执行，直到布尔表达式返回`false`。因此，在代码块中更改某些值以使布尔表达式变为`false`是一种常见的模式。

如果布尔表达式没有变为`true`的机会，代码将无限循环，这可能会锁定您的应用程序。

在这个菜谱中，我们将探讨`while`循环可以用于重复操作的情况。

## 准备工作

这个菜谱将涉及模拟随机抛硬币。为了抛硬币，我们需要随机选择正面或反面，因此我们需要使用来自Foundation框架的随机数生成器。我们将在[第5章](a632f18a-5826-4757-90bc-7701c78edaaf.xhtml)，*超越标准库*中进一步讨论Foundation，但到目前为止，我们只需要在playground的顶部导入Foundation框架：

[PRE53]

这将使我们能够生成一个随机数，我们现在将使用它。

## 如何做到这一点...

让我们来计算一下连续抛硬币得到正面的次数：

1.  创建一个表示硬币抛掷的`enum`，并使用随机数生成器随机选择正面或反面：

[PRE54]

1.  创建一个函数，该函数将返回连续抛硬币得到正面的次数。该函数将在`while`循环中抛硬币，并在硬币抛掷结果为正面时继续循环：

[PRE55]

## 它是如何工作的...

在我们的函数中，我们首先跟踪连续抛硬币得到正面的次数，并保留对当前硬币抛掷的引用，这将形成`while`循环的条件：

[PRE56]

在我们的`while`循环中，我们将继续循环并执行以下代码块中的代码，只要当前的硬币抛掷结果是正面：

[PRE57]

在代码块中，我们将运行总金额加一，并重新翻转硬币。我们正在翻转硬币并将其分配给`currentCoinFlip`，这将在下一次循环中重新检查，如果它仍然是正面，则下一次循环将被执行。由于我们正在更改影响`while`条件的东西，这样它最终可能是`false`，我们可以确信我们不会永远卡在循环中。

一旦硬币翻转结果为反面，`while`循环条件将为`false`，因此执行将继续并返回我们一直在保持的运行总金额：

[PRE58]

现在，每次你调用该函数时，硬币都会随机翻转，并返回连续出现正面次数，所以每次调用时，你可能会得到不同的返回值。试几次看看：

[PRE59]

## 还有更多...

实际上，我们可以通过将硬币翻转作为循环延续检查的一部分来简化我们的`while`循环：

[PRE60]

每次通过循环时，都会评估`while`条件，这涉及到重新翻转硬币并检查结果。

这更简洁，并且消除了跟踪`currentCoinFlip`的需要。

## 参见

更多关于`while`循环的信息可以在苹果公司关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/while](http://swiftbook.link/docs/while)。

# 使用try、throw、do和catch处理错误

编程过程中会发生错误。这些错误可能是由于你自己的代码以意想不到的方式运行，或者由于来自外部系统的意外信息或行为。当这些错误发生时，正确处理它们非常重要。良好的错误处理可以将一个优秀的应用程序与一个伟大的应用程序区分开来。

Swift提供了一种故意且灵活的错误处理模式，允许特定的错误通过复杂系统级联。

在这个菜谱中，我们将了解如何定义错误，并在必要时抛出它们。

## 如何做到这一点...

为了检查错误处理，我们将模拟一个可能会出错的过程，对我来说，那就是烹饪餐点：

1.  首先，让我们定义烹饪餐点涉及的步骤，作为餐点将经历的状态：

[PRE61]

1.  创建一个对象来表示我们将要烹饪的餐点。该对象将持有餐点在过程中移动的状态：

[PRE62]

我们希望允许餐点在状态之间转换，但并非所有状态转换都是可能的。例如，你不能从购买食材直接过渡到上菜。餐点应该按顺序从一个状态转换到下一个状态。我们可以通过只允许在对象内部设置状态来提供这些限制，使用我们在上一章中探讨的访问控制。

1.  将`state`属性定义为只能私有设置：

[PRE63]

1.  为了允许从对象外部更改状态，创建一个函数，如果状态转换不可行，则抛出错误：

[PRE64]

遵循 Swift 的协议导向方法，Swift 中的错误被定义为协议，即 `Error` 协议。这种方法允许你创建自己的类型来表示代码中的错误，并且只需让它符合 `Error` 协议即可。

一种常见的做法是将错误定义为枚举，枚举的案例代表可能发生的不同类型的错误。

1.  定义前面 `Meal` 类中抛出的错误：

[PRE65]

1.  尝试在一个 `do` 块中执行我们的错误抛出方法并捕获可能发生的任何错误：

[PRE66]

## 它是如何工作的...

Swift 错误处理中使用的隐喻（以及其他语言）是 *抛出* 和 *捕获*。如果一个方法在执行过程中遇到问题，它可以 *抛出* 一个错误，此时方法中的其他代码将不会执行，错误将被传递回方法被调用的地方。

为了接收这个错误（可能为了向用户提供错误的详细信息），你必须在方法被调用的地方 *捕获* 这个错误。

要抛出一个错误，你必须声明该方法有抛出错误的可能性。声明一个方法 `throws` 允许编译器期望方法中可能出现的错误，并确保你不会忘记捕获这些错误。

可以使用 `throws` 关键字声明方法可能抛出错误：

[PRE67]

在我们的状态转换方法中，我们只有在移动到下一个顺序状态时才会改变状态。其他任何操作都是不允许的，应该抛出一个错误。我们可以使用 `throw` 关键字，后跟一个符合 `Error` 协议的值来完成这个操作：

[PRE68]

当我们创建 `Meal` 对象并遍历准备餐点的状态时，每个状态的变化都可能抛出一个错误。当我们调用标记为可能抛出错误的函数时，我们必须以某种方式执行。我们定义一个 `do` 块，在其中我们可以调用可能抛出的方法，然后定义一个 `catch` 块，如果这些方法中的任何一个抛出错误，它将被执行。每个抛出方法的调用都必须以 `try` 关键字为前缀：

[PRE69]

如果这些方法中的任何一个抛出错误，执行将立即转移到 `catch` 块。因此，通过在 `try` 方法调用之后放置代码，我们确保只有在方法没有抛出错误的情况下才会执行这些代码。在所有状态转换调用之后打印 `Dinner is served!`，我们知道这只会打印出来，如果我们已经成功通过了所有状态。尝试改变这些状态转换调用的顺序，你会看到错误会被打印出来，而 `Dinner is served!` 不会。

在我们的 `catch` 块中，在 `catch` 关键字之后，我们可以定义想要将捕获的错误分配到的局部常量。然而，如果我们在这里没有指定局部常量，Swift 会隐式地为我们创建一个名为 `error` 的常量，因此我们实际上可以在 `catch` 块中省略常量声明并仍然打印错误的值：

[PRE70]

Swift 已经为我们定义了错误，所以我们仍然可以打印其值。

## 还有更多...

我们已经看到了如何抛出和捕获错误，但在介绍中我们提到我们可以通过系统级联错误，所以让我们看看我们如何做到这一点。

在我们的餐点准备示例中，我们允许通过可以抛出错误的 `change` 方法从外部更改餐点状态。相反，让我们将其更改为私有方法，这样我们就只能从类内部调用它：

[PRE71]

接下来，让我们创建一些具体的方法来移动到每个状态：

[PRE72]

你会注意到，当我们从每个新方法内部调用 `change` 方法时，我们不需要使用 `do` 和 `catch` 块来捕获错误；这是因为我们已经将每个新方法定义为可能抛出错误的，所以如果 `change` 方法的调用抛出错误，这个错误将作为抛出错误传递给我们的新方法的调用者。

这种机制允许在代码的多个层级中可能发生的错误暴露出来并得到适当的处理。

现在我们需要修改我们的餐点准备代码以使用这些新方法：

[PRE73]

让我们添加实际影响我们的餐点的功能。我们将添加一个向餐点中加盐的方法和一个属性，以便我们可以跟踪添加了多少盐。将这些添加到 `Meal` 类的末尾：

[PRE74]

添加盐分可能导致两种错误，要么是因为我们处于不适合添加盐的状态（我们只能在购买食材之后才能添加盐），要么是因为我们添加了过多的盐。让我们将这些两个新的错误添加到我们的 `MealError` 枚举中：

[PRE75]

现在我们有三种可能发生在准备餐点过程中的错误，我们可能希望以不同的方式处理这些错误。我们可以使用多个 `catch` 块来过滤仅特定的错误，这样我们就可以单独处理每个错误：

[PRE76]

确保所有可能的错误都被 `catch` 块处理非常重要，因为未处理的错误会导致程序崩溃。因此，最安全的方法是在最后添加一个未过滤的 `catch` 块来捕获之前块未捕获的任何错误。

由于函数可以抛出错误，而闭包是一种可以作为参数传递的函数类型，因此我们可以有一个接受抛出闭包的函数，其中它也可以抛出错误。可能的情况是，我们的函数将抛出的唯一错误是由作为参数传递的抛出闭包产生的错误。

当这是真的时，可以使用 `rethrows` 关键字定义一个函数作为重新抛出。

这种情况相当令人困惑，所以让我们看看一个例子：

[PRE77]

这个 `makeMeal` 函数接受一个闭包作为参数；这个闭包接受一个 `Meal` 对象作为参数，并且不返回任何内容，但可能会抛出错误。

这个函数的目的是为你处理 `meal` 对象的创建，只让你在块内进行任何餐点准备；然后它返回创建并准备好的餐点。让我们看看它是如何使用的：

[PRE78]

`makeMeal`函数只抛出闭包参数抛出的错误，因此它可以声明为重新抛出。使用`rethrows`关键字声明这种类型的函数不是必需的，可以用`throws`来声明。然而，编译器可以为重新抛出函数进行额外的优化。

## 参见

更多关于错误处理的信息可以在Apple关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/error-handling](http://swiftbook.link/docs/error-handling)。

# 使用`guard`语句提前检查

在之前的菜谱中，我们看到了如何使用`if`语句来检查布尔表达式和展开可选值。在代码块的开头进行一些检查和条件展开是一个常见的用例，然后只有在一切如预期的情况下才执行后续代码。这通常会导致将整个代码块包裹在一个`if`语句中：

[PRE79]

Swift有一个专门为此目的的更好解决方案；`guard`语句。

在这个菜谱中，我们将学习如何使用`guard`语句从方法中提前返回。

## 准备工作

让我们假设我们有一些来自外部来源的数据，我们希望将其转换为我们的代码可以理解的模型对象，目的是将其显示给用户。我们可以使用`guard`语句来确保数据格式正确，如果不正确则提前退出。

## 如何做到这一点...

我们将取一些关于太阳系行星的信息，这些信息可能来自外部来源，并将其转换为我们可以理解的模型：

1.  以字典数组的形式创建行星数据：

[PRE80]

1.  定义一个`Planet`结构体，它将根据数据创建：

[PRE81]

1.  一步一步来，创建一个函数，该函数将接受单个行星字典并创建一个`Planet`结构体，如果可能的话。我们将使用`guard`语句来确保字典包含我们期望的所有值：

[PRE82]

1.  现在我们能够处理单个行星数据，创建一个函数，该函数将接受一个行星字典数组并生成一个`Planet`结构体的数组，使用`guard`语句来确保我们成功创建一个`Planet`结构体：

[PRE83]

## 它是如何工作的...

`guard`语句的工作方式与`if`语句非常相似，因为可选值可以以相同的方式展开和链接。由于我们的行星数据包含字符串、整数、浮点数和布尔值，字典的类型是`[String: Any]`。因此，为了创建我们的`Planet`结构体，我们需要检查给定键的预期值是否存在，并将它们转换为正确的类型。

在我们的`makePlanet`函数中，我们使用`guard`关键字，然后从行星数据字典中访问和条件地转换我们所需的所有值。如果这些条件转换中的任何一个失败，那么在`guard`语句之后定义的`else`块将被执行。我们定义我们的函数返回一个可选的`Planet`，所以如果我们没有预期的信息，`guard`将失败，并返回`nil`：

[PRE84]

`guard`语句解包的任何值都可在同一作用域内`guard`语句下面的任何代码中使用；这使得`guard`语句非常适合在继续之前确保输入值符合预期。这消除了在`if`块内嵌套代码的需要。解包的值随后用于初始化`Planet`结构体。

正如我们所见，`guard`语句用于在`guard`条件失败时中断执行，因此编译器确保在`else`块中放置一个中断执行的语句；这可以是，例如，`return`、`break`或`continue`。

在`makePlanets`函数中，我们使用`for`循环遍历字典，并尝试从每个字典中创建一个`Planet`结构体。如果我们的`makePlanet`调用返回`nil`，我们调用`continue`来跳过这个`for`循环的迭代，并跳到下一个迭代：

[PRE85]

## 还有更多...

`makePlanets`函数接受一个包含行星数据字典的数组，并返回一个`Planet`结构体的数组。如果提供的数组为空，我们可能决定这不是我们函数的有效输入，并且我们想要抛出一个错误；`guard`也可以帮助做到这一点。

我们可以使用`guard`检查任何条件语句是否为真，如果不是，我们可以抛出一个错误：

[PRE86]

## 参见

关于`guard`语句的更多信息可以在Apple关于Swift语言的文档中找到，链接为[http://swiftbook.link/docs/guard](http://swiftbook.link/docs/guard)。

# 使用defer延迟执行

通常，当我们调用一个函数时，控制从调用站点传递到函数，然后函数内的语句按顺序执行，直到函数的末尾或直到出现`return`语句。然后控制返回到调用站点。在以下图中，`print`语句按顺序1、2、然后3执行：

![](img/53322170-0383-4db5-8c1b-b5714aba0dd4.png)

图3.2 – print语句

有时，在函数返回后但在控制返回到调用站点之前执行一些代码可能很有用。这是Swift的`defer`语句的目的。在以下示例中，步骤3在步骤2之后执行，即使它定义在步骤2之上：

![](img/54fba059-3c39-42fb-b646-f9114dbeaee3.png)

图3.3 – defer语句

在这个菜谱中，我们将探讨如何使用`defer`，以及它在什么情况下可能有用。

## 准备工作

`defer`语句在函数执行完成后更改状态或清理不再需要的值时非常有用。让我们看看使用`defer`语句更新状态的例子。

## 如何做...

想象一下，我们有一些带有星级评分的电影评论，我们想要根据它们的星级评分对它们进行分类：

1.  定义电影评论可能被分类为的选项：

[PRE87]

1.  创建一个用于分类的对象：

[PRE88]

1.  使用分类器对评论进行分类：

[PRE89]

这工作得很好，但为了本例的目的，让我们假设这个分类是一个长时间运行的过程，我们想要跟踪分类器的状态，以便我们可以外部检查分类器是否正在分类过程中或已完成。

1.  定义可能的分类状态：

[PRE90]

1.  更新我们的分类器类以保存和更新状态，使用 `defer` 语句将状态移动到完成状态：

[PRE91]

1.  使用分类器对评论进行分类并检查状态：

[PRE92]

## 它是如何工作的...

我们上面定义的 `classify` 方法接受一个输入评分，然后根据这个评分返回 `MovieReviewClass`：

[PRE93]

在执行此操作的同时，它还会更新一个 `state` 值，以指示方法在分类过程中的位置：

[PRE94]

`defer` 语句允许在方法返回后更新状态。

如果我们不使用 `defer` 语句来编写这个方法，我们必须在返回值之前的每个 `if` 语句分支中转换到 `complete` 状态，因为在此之后将不会执行任何操作。该方法的结尾将如下所示：

[PRE95]

当我们使用 `defer` 语句时，可以避免这种更新状态的重复：

[PRE96]

要延迟代码，只需使用 `defer` 关键字，并将要延迟的代码定义在大括号内；这段代码将在方法返回后、控制流返回给调用者之前运行。

## 还有更多...

你可以在方法中定义多个 `defer` 语句，并且它们将按照它们定义的相反顺序执行，所以最后定义的 `defer` 语句是在方法返回后首先执行的一个。

为了演示，添加一个新的状态，当完成第一次分类之后的分类时，我们将切换到该状态：

[PRE97]

现在，让我们修改我们的分类器以跟踪其进行的分类数量，并在完成超过一个分类时将其更改为 `completeAgain` 状态：

[PRE98]

现在更改我们使用分类器的方式；第二次使用它时，它将以不同的状态完成：

[PRE99]

由于我们现在已经定义了两个 `defer` 语句，让我们再次查看它们的执行顺序：

[PRE100]

如前所述，最后定义的 `defer` 语句首先执行。因此，在第一次分类中，一旦方法返回，最后一个 `defer` 语句将执行，状态将更改为 `complete`，因为 `numberOfClassifications` 将为 `0`。接下来，第一个 `defer` 语句执行，将 `1` 添加到 `numberOfClassifications` 变量中，这将现在是 `1`。

在第二次分类中，一旦方法返回，最后一个 `defer` 语句将执行并将状态更改为 `completeAgain`，因为 `numberOfClassifications` 大于 `0`。最后，第一个 `defer` 语句将执行，增加 `numberOfClassifications` 的值，使其变为 `2`。

如果`defer`语句的顺序相反，状态将始终变为`completeAgain`，因为`numberOfClassifications`会在检查之前增加到`1`。

## 参见

关于`defer`语句的更多信息可以在苹果关于Swift语言的文档中找到，请访问[http://swiftbook.link/docs/defer](http://swiftbook.link/docs/defer)。

# 使用fatalError和precondition退出

想到你写的代码中，一切都会如预期发生，并且你的程序可以处理任何事件，这是令人欣慰的。然而，有时事情可能会出错——真的会出错。可能会出现一种你知道是可能的但从未期望发生的情况，如果发生，程序应该终止。在这个菜谱中，我们将探讨这类问题：`fatalError`和`precondition`。

## 准备工作

让我们重用之前的示例；我们有一个可以根据评论中给出的10颗星中的多少颗来对电影评论进行分类的对象。然而，让我们简化它的使用，并说我们只打算让分类器对象对一部电影评论进行一次分类。

## 如何做...

让我们设置我们的电影分类器，使其只能使用一次，并且只能接受10分制的评分：

1.  定义分类状态和电影评论类：

[PRE101]

1.  使用`precondition`和`fatalError`重新定义我们的分类器对象，以指示那些不应该发生且会导致问题的情形：

[PRE102]

## 它是如何工作的...

我们只想使用分类器一次；因此，当我们开始对电影评论进行分类时，当前状态应该是`initial`，因为这个对象之前从未进行过分类，不应该处于分类的中间状态。如果不是这种情况，分类器正在被错误地使用，我们应该终止代码的执行：

[PRE103]

我们使用`precondition`关键字声明一个前置条件，提供一个我们期望为真的布尔语句和一个可选的消息。如果这个布尔语句不为真，代码的执行将终止，并且消息将在控制台显示。

在我们的示例中，我们使状态必须为`initial`，当调用此方法时。

当我们的分类器执行分类时，它期望在1到10之间有一个星号的数量。然而，该方法接受一个`Int`作为参数；因此，可以提供任何整数值，无论是正数还是负数。如果提供的值不在1到10之间，并且分类器无法提供有效的`MovieReviewClass`，那么分类器正在被错误地使用，我们应该终止代码的执行：

[PRE104]

如果-否则语句涵盖了提供的星星对应的所有有效的`MovieReviewClass`选项，所以如果没有触发这些选项之一，我们使用致命错误来指示错误的使用。这是通过使用`fatalError`关键字，并提供一个可选的消息来完成的。

## 参见

关于`fatalError`的更多信息可以在苹果公司关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/fatalerror](http://swiftbook.link/docs/fatalerror)。
