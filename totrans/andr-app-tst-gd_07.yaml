- en: Chapter 7. Testing Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides practical examples of different common situations that
    you will encounter by applying the disciplines and techniques described in the
    previous chapters. The examples are presented in a Cookbook style so you can adapt
    and use them for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Android Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing activities and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing databases and ContentProviders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing local and remote services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing parsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter you will have a reference to apply testing to your projects
    and to know what to do in every situation.
  prefs: []
  type: TYPE_NORMAL
- en: Android Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some cases where you really need to test parts of the application
    in isolation with little connection to the underlying system. In such cases we
    have to select a base class that is high enough in the hierarchy to remove some
    of the dependencies but not high enough for us to be responsible for some of the
    basic infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The candidate base class in this case is possibly `AndroidTestCase`. This example
    has been taken from the **Android CTS** test suite ([http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Up to here we have:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard Android Open Source Project copyright.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package definition. This test lives in `com.android.cts.appaccessdata`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some imports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of `AccessPrivateDataTest`, which extends `AndroidTestCase` because
    it's a unit test that doesn't require the system infrastructure. In this particular
    case we could have also used `TestCase` directly, because we are not accessing
    Context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The definition of the constant `APP_WITH_DATA_PKG`, indicating the package
    name of the application containing the private data we are trying to access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this second part, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `PRIVATE_FILE_NAME`, containing the name of the file we will
    try to access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test method `testAccessPrivateData`, which actually exercises the feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This test method, `testAccessPrivateData()`, tests the access to other packages'
    private data and fails if this is possible. To achieve this, the expected exceptions
    are caught and if this doesn't happen `fail()` is invoked with a custom message.
  prefs: []
  type: TYPE_NORMAL
- en: Testing activities and applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section shows some examples of activities and applications tests. They
    cover some common cases that you will find in your day-to-day testing and you
    can adapt them to suit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Applications and preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android parlance, application refers to a base class used when it is needed
    to maintain a global application state. This is usually utilized for dealing with
    shared preferences. We expect that tests altering these preferences' values don't
    affect the behavior of the real application. Imagine the tests deleting user account
    information for an application storing these values as shared preferences. It
    doesn't sound like a good idea. So what we really need is the ability to mock
    a `Context` that also mocks the access to the `SharedPreferences`.
  prefs: []
  type: TYPE_NORMAL
- en: Our first attempt could be to use `RenamingDelegatingContext`, but unfortunately,
    it does not mock `SharedPreferences`, although it is close because it mocks database
    and filesystem access. So, first we need to create a specialized mock `Context`
    that also mocks the latter.
  prefs: []
  type: TYPE_NORMAL
- en: The RenamingMockContext class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's create the specialized `Context`. The class `RenamingDelegatingContext`
    is a very good point to start from because as we mentioned before, database and
    filesystem access will be mocked. The problem is how to mock `SharedPreferences`
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that `RenamingDelegatingContext` as its name suggests, delegates everything
    to a `Context`. So the root of our problem lies in this `Context`. Because it
    is a mock `Context` as well, `MockContext` seems to be the correct base class.
    As you may remember, in [Chapter 3](ch03.html "Chapter 3. Building Blocks on the
    Android SDK"), *Building Blocks on the Android SDK*, we looked at the mock object
    and we noted that `MockContext` can only be used to inject other dependencies
    and all methods are non-functional and throw `UnsupportedOperationException`.
    However, this is also a feature we can use to our advantage in detecting the minimum
    set of methods that needs to be implemented in a case like this. So let''s start
    creating an empty `MockContext` to whom the other `Context`, that we can name
    `RenamingMockContext`, delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We created a mock `Context, RenamingMockContext`, that delegates to another
    empty `MockContext, DelegatedMockContext`, and uses a renaming prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The TemperatureConverterApplicationTests class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have the `RenamingMockContext`, now we need a test that uses it. Because
    we will be testing an application, the base class for the test would be `ApplicationTestCase`.
    This test case provides a framework in which you can test application classes
    in a controlled environment. It provides basic support for the lifecycle of an
    application, and hooks by which you can inject various dependencies and control
    the environment in which your application is tested. We can inject the `RenamingMockContext`
    before the `Application` is created using the `setContext()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `TemperatureConverter` application, which we started in [Chapter 4](ch04.html
    "Chapter 4. Test Driven Development"), *Test Driven Development*, will be storing
    the decimal places as a shared preference. Consequently we will be creating a
    test to set the decimal places and then retrieving it to verify its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We extend `ApplicationTestCase` using the `TemperatureConverterApplication`
    template parameter. Soon, we will be creating the class extending `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we use the **Given name constructor** pattern that we discussed in [Chapter
    3](ch03.html "Chapter 3. Building Blocks on the Android SDK"), *Building Blocks
    on the Android SDK.*
  prefs: []
  type: TYPE_NORMAL
- en: In the `setUp()` method we create the mock context and set the context for this
    test using `setContext()` method; we create the application using `createApplication()`
    and finally hold a reference to it as it will be used frequently in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding our tests, using the **Test preconditions** pattern that we reviewed
    previously, we check that the recently created application is not null.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly is the test that actually tests for the required behavior setting the
    decimal places, retrieving it, and verifying its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first objective is to get these tests to compile. Later we will focus on
    the success of these tests. To get it to compile, we need to create the class
    `TemperatureConverterApplication` and the getter and setter for decimal places,
    that ultimately should use `SharedPreferences` to store and retrieve the specific
    preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the tests we obtain a failure related to the fact that we are not storing
    the decimal places anywhere. We can implement this using `SharedPreferences` in
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we complete these steps, compile and run the tests, we discover that they
    fail with an `UnsupportedOperationException` in `MockContext.getPackageName()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We change `DelegateMockContext` to override `getPackageName()`, delegating
    to the original context passed as a parameter to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running the tests again, this time we obtain a different, though somewhat expected,
    `UnsupportedOperationException`. This exception is received while invoking `getSharedPreferences()`.
    Thus, the next step is to override this method in `DelegatedMockContext:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Any time that a `SharedPreference` is requested, this method will invoke the
    delegating context, adding the prefix for the name. The original `SharedPreferences`
    used by the application are unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: We can verify this behavior by furnishing the `TemperatureConverterApplication`
    class with the previously mentioned methods, then storing some value in the shared
    preferences, running the tests, and eventually verifying that this value was not
    affected by running the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next example shows how an activity can be tested in complete isolation using
    `ActivityUnitTestCase<Activity>` base class as opposed to `ActivityInstrumentationTestCase2<Activity>`.
    This method requires more care and attention but also provides a greater flexibility
    and control over the `Activity` under test. This kind of test is intended for
    testing general `Activity` behavior and not an `Activity` instance's interaction
    with other system components or UI related tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are taking this example from the ApiDemos sample application ([http://developer.android.com/resources/samples/ApiDemos/index.html](http://developer.android.com/resources/samples/ApiDemos/index.html))
    that is provided as an SDK companion. This sample is somewhat long so we have
    split it into several code snippets to improve its readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This first code snippet has nothing more than the required copyrights and imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This second snippet includes the test case definition extending `ActivityUnitTestCase<Forwarding>`
    as we mentioned earlier as a unit test for an Activity class. This activity under
    test will be disconnected from the system so it is only intended to test internal
    aspects of it and not its interaction with other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The no-argument constructor is also defined here as we mentioned in previous
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `setUp()` method follows the pattern of invoking the super method and initializes
    the field with the Intent used to start the Activity. In this case we are saving
    the `Intent` as member `mStartIntent:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines the `testPreconditions()` method that we also explained before.
    As noted in the method''s comment, remember that this name is just a convention
    and no execution order is guaranteed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This test performs a click on the "go" button of the Forwarding Activity. The
    `onClickListener` of that button invokes `startActivity()` with an `Intent` defining
    the component as the `ForwardTarget` class, thus this is the `Activity` that will
    be started.
  prefs: []
  type: TYPE_NORMAL
- en: After performing this action we verify that the `Intent` used to launch the
    new `Activity` is not null and that `finish()` was called on our `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the activity under test is started using `startActivity(mStartIntent,
    null, null)`, the components are verified to assure that they are as expected.
    In order to do that, the recently started activity is verified for "not null"
    using an assertion on `getActivity()` and then the button that was obtained by
    `findViewById()` is also verified for a "not null" value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is perhaps the most interesting test method in this test case. This test
    case demonstrates how to exercise the `Activity` lifecycle. After starting the
    `Activity, onCreate()` was automatically called, and we then exercise other lifecycle
    methods by invoking them manually. To be able to invoke these methods we use the
    `Intrumentation` of this test.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we don't manually invoke `onDestroy()` as it will be invoked for us
    in `tearDown().`
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `testSubLaunch()` test. This test checks for various conditions
    after starting the `Activity` under test using `startActivity(mStartIntent, null,
    null)`. The `Button` is obtained using `findViewById()` and then it is pressed
    issuing `performClick().` The action when this button is touched is to launch
    a new `Activity` and this is precisely the condition that is checked, asserting
    that `getStartedActivityIntent()` returns "not null". The latter method returns
    the Intent that was used if the `Activity` under tests invoked `startActivity(Intent)`
    or `startActivityForResult(Intent, int)`. The last step is to verify that `finish()`
    was called if the other `Activity` was launched and we do that by verifying the
    return value of `isFinishCalled()`, which returns true if one of the finish methods
    (`finish(), finishFromChild(Activity)`, or `finishActivity(int)`) were called
    in the `Activity` under test.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to exercise the `Activity` lifecycle for which the `testLifeCycleCreate()`
    method is used. This method starts the `Activity` in the same way as the previously
    analyzed test.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the activity is started, its `onCreate()` method is called, and
    the `Instrumentation` is used to invoke other lifecycle methods like `getInstrumentation().callActivityOnStart(activity)`
    and `getInstrumentation().callActivityOnResume(activity)` to complete the `Activity`
    under test start up.
  prefs: []
  type: TYPE_NORMAL
- en: The `Activity` is now completely started and its time to test for the aspects
    we are interested in. Once this is achieved, we can follow other steps in the
    lifecycle. Note that this sample test does not test for anything special here.
  prefs: []
  type: TYPE_NORMAL
- en: To finish the lifecycle, we will call `getInstrumentation().callActivityOnPause(activity)`
    and `getInstrumentation().callActivityOnStop(activity)`. As it's mentioned in
    the method's comments, we don't have to worry about calling `onDestory()` as it
    will be automatically called by `tearDown()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the tests, once you have the `ApiDemos.apk` and its tests
    installed onto a device or emulator, you can run this command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**com.example.android.apis.app.ForwardingTest:... Test results for InstrumentationTestRunner=...
    Time: 0.614 OK (3 tests)**'
  prefs: []
  type: TYPE_NORMAL
- en: This test represents a skeleton you can reuse to test your `Activities` in isolation
    and to test lifecycle related cases. The injection of mock object could also facilitate
    testing other aspects of the `Activity` such as accessing system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Testing files, databases, and ContentProviders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some test cases have the need to exercise databases or ContentProviders operations,
    and soon comes the need to mock these operations. For example, if we are testing
    an application on a real device, we don't want to interfere with the normal operation
    of applications on such devices, mainly when we change values that may be shared
    by more than one application.
  prefs: []
  type: TYPE_NORMAL
- en: Such cases can take advantage of another mock class that is not a part of `android.test.mock`
    package but of `android.test` instead, namely `RenamingDelegatingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: This class lets us mock file and database operations. A prefix supplied in the
    constructor is used to modify the target of these operations. All other operations
    are delegated to the delegating `Context` that you must specify in the constructor
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose our `Activity` under test uses some files or databases that we want
    to control in some way, maybe to introduce specialized content to drive our tests,
    and we don't want to, or we cannot use real files or database. In such cases we
    create `RenamingDelegatingContext` specifying a prefix. We provide mock files
    using this prefix and introduce any content we need to drive our tests, and the
    `Activity` under test could you use them with no alteration.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of keeping our `Activity` unchanged, that is not modifying it
    to read from a different source, is that this assures all tests are valid. If
    we introduce a change only intended for our tests, we will not be able to assure
    that under real conditions, the `Activity` behaves the same.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this case, we will create an extremely simple `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The activity `MockContextExampleActivity` displays the content of a file inside
    `TextView`. What we intend to demonstrate is how it displays different content
    during normal operation of `Activity` as compared to when it is under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is our simple `Activity`. It reads the content of the `myfile.txt` file
    and displays it on a `TextView`. It also displays any error that may occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need some content for this file. Probably the easiest way of creating the
    files is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We created two different files, one named `myfile.txt` and the other `test.myfile.txt`,
    with different content. The latter indicates that it is a mock content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the use of this mock data in our activity tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The class `MockContextExampleTest` extends `ActivityUnitTestCase` because we
    are looking for isolated testing of `MockContextExampleActivity` and because we
    are going to inject a mocked context; in this case the injected context is a `RenamingDelegatinContext`
    as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Our fixture consists of the mock context, `mMockContext`, the `RenamingDelegatingContext`
    using the target context obtained by.getInstrumentation().getTargetContext().
    Note that the context where the instrumentation is run is different than the context
    of the `Activity` under test.
  prefs: []
  type: TYPE_NORMAL
- en: Here a fundamental step follows—since we want to make the existing files and
    databases accessible to this test we have to invoke `makeExistingFilesAndDbsAccessible()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, our test named `testSampleTextDisplayed()` injects the mock context using
    `setActivityContext()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must invoke `setActivityContext()` to inject a mock context **before** you
    start the Activity under test by invoking `startActivity()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then the `Activity` is started by `startActivity()` using an `Intent` just created.
  prefs: []
  type: TYPE_NORMAL
- en: The `Activity` under test is obtained using `getActivity()` and it is verified
    for a "not null" value.
  prefs: []
  type: TYPE_NORMAL
- en: We obtain the text value held by the `TextView` by using a getter we added to
    the `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the text value obtained is checked against the `String`*"This is MOCK*
    data"*. It is important here to notice that the value used for this test is the
    test file content not the real file content.
  prefs: []
  type: TYPE_NORMAL
- en: The BrowserProvider tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These tests are taken from the Android Open Source Project (AOSP). Source code
    can be obtained as a component of the Browser.git project at [http://android.git.kernel.org/?p=platform/packages/apps/Browser.git](http://android.git.kernel.org/?p=platform/packages/apps/Browser.git).
    They are intended to test some aspects of the Browser Bookmarks content provider,
    BrowserProvider, which is part of the standard Browser included with the Android
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This first code snippet has nothing more than the required copyrights and imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This second snippet includes the test case definition extending `AndroidTestCase`.
    The class `BrowserProviderTests` extends `AndroidTestCase` because a `Context`
    is needed to access provider content.
  prefs: []
  type: TYPE_NORMAL
- en: The fixture created in the `setUp()` method creates an `ArrayList` of `Uris`
    that is used to keep track of the inserted `Uris` to be deleted in the `tearDown()`
    method. Perhaps we could have saved all this hassle using a mock content provider,
    maintaining the isolation between our tests and the system. Anyway, `tearDown()`
    iterates over this list and deletes the stored `Uris`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no need to override the constructor here as `AndroidTestCase` is not
    a parameterized class and we don''t need to do anything special in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The next test, `testHasDefaultBookmarks()`, is a test for the default bookmarks.
    Upon startup a cursor iterates over the default bookmarks obtained by invoking
    `getBookmarksSuggest("")`, which returns the bookmarks unfiltered; that is why
    the query parameter is "".
  prefs: []
  type: TYPE_NORMAL
- en: Then, `testPartialFirstTitleWord(), testFullFirstTitleWord(), testFullFirstTitleWordPartialSecond()`,
    and `testFullTitle()` test for the insertion of bookmarks. To achieve this they
    invoke `assertInsertQuery()` using the bookmarked `Url`, its title, and the query.
    The method `assertInsertQuery()` adds the bookmarks to the bookmark provider,
    inserting the `Url` issued as a parameter with the specified title. The `Uri`
    returned is verified to be not null and not exactly the same as the default one.
    Finally the `Uri` is inserted in the list of `Uri` instances to be deleted in
    `testDown():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These tests are similar to the tests presented before, but in this case they
    use Japanese titles and queries. It is recommended to test the application's components
    under different conditions like in this case where other languages with different
    character sets are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several tests that are intended to verify the utilization of this bookmark
    provider for other locales and languages than just English. These particular cases
    cover the Japanese language utilization in bookmark titles. The tests `testFullTitleJapanese(),
    testPartialTitleJapanese()`, and `testSoundmarkTitleJapanese()` are the Japanese
    versions of the tests introduced before using Unicode characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Several utility methods follow. These are the utilities used in the tests. We
    briefly looked at `assertInsertQuery()` before, so now let's look at the other
    methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `assertInsertQuery()` invokes `assertQueryReturns(url, title, query)`,
    after `addBookmark()`, to verify that the `Cursor` returned by `getBookmarksSuggest(query)`
    contains the expected data. This expectation can be summarized as:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of rows returned by the query is greater than 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of rows returned by the query is equal to 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title in the returned row is not null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title returned by the query is exactly the same as the method parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line for the suggestion is not null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL returned by the query is not null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL matches exactly the URL issued as the method parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a simplified Activity Diagram that will help us understand the relationship
    among these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The BrowserProvider tests](img/3500OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These tests follow the basic structure described before and are depicted in
    the UML activity diagram. Firstly, `assertInsertQuery()` is invoked which in turns
    invokes `addBookmark()` and `assertQueryReturns()`. Then, `getBookmarksSuggest()`
    is called and finally the asserts to validate the conditions we are testing. The
    most outstanding thing here is the utilization of asserts in these utility methods,
    which helps us test conditions along the way.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy provides an interesting pattern to follow in our tests. Some of
    the utility methods that we need to create to complete our tests can also carry
    their own verification of several conditions and improve our test quality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating assert methods in our classes allows us to introduce domain-specific
    testing language that can be reused when testing other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Testing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned this before. In [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Testing"), *Getting Started* with *Testing* we stated that you should
    test for exceptions and wrong values instead of just testing positive cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also presented this test before but here we are digging deeper into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Every time we have a method that is supposed to generate an exception, we should
    test this condition. The best way of doing it is by invoking the method inside
    a try-catch block, catching the expected `Exception`, and failing otherwise. In
    this precise case we test for `InvalidTemperature:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Testing local and remote services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This test is also from a ApiDemos sample application ([http://developer.android.com/resources/samples/ApiDemos/index.html](http://developer.android.com/resources/samples/ApiDemos/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to extend the `ServiceTestCase<Service>` class to test a service
    in a controlled environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This first code snippet has nothing more than the required copyrights and imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, we are using the no argument constructor as we did before, invoking the
    super constructor using the service class `LocalService:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we are using the pattern of invoking the super methods in `setUp()` and
    `tearDown()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not setting up any specific fixture in this test so we are just invoking
    super methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have an empty `testPreconditions()`. We don''t need any preconditions
    tested here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The constructor, as in other similar cases, invokes the parent constructor passing
    this service class as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This is followed by a `testStartable()` test. It is annotated with the `SmallTest`
    annotation to categorize this test. Next we start the service using an Intent
    that we create here, setting its class to the class of the service under test.
    We also use the instrumented Context for this Intent. This class allows for some
    dependency injection, as every service depends on the Context in which it runs,
    and the application with which it is associated. This framework allows you to
    inject modified, mock, or isolated replacements for these dependencies, and thus
    performs a true unit test.
  prefs: []
  type: TYPE_NORMAL
- en: As we simply run our tests as-is, the `Service` will be injected with a fully-functional
    `Context`, and a generic `MockApplication` object.
  prefs: []
  type: TYPE_NORMAL
- en: Then we start the service using the `startService(startIntent)` method, in the
    same way as if it was started by `Context.startService()`, providing the arguments
    it supplied. If you use this method to start the service, it will automatically
    be stopped by `tearDown()`.
  prefs: []
  type: TYPE_NORMAL
- en: Another test, `testBindable(),` which is categorized as `MediumTest`, will be
    testing if the service can be bound. This test uses `bindService(startIntent)`,
    which starts the service under test, in the same way as if it was started by `Context.bindService()`,
    providing the arguments it supplied. It returns the communication channel to the
    service. It may return null if clients cannot bind to the service. Most probably
    this test should check for the null return value in the service with an assertion
    like `assertNotNull(service)` to verify that the service was bound correctly,
    but it doesn't. Be sure to include this test when you write code for similar cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned `IBinder` is usually for a complex interface that has been described
    using AIDL. In order to test with this interface, your service must implement
    a `getService()` method, as shown in `samples.ApiDemos.app.LocalService`, which
    has this implementation of that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Extensive use of mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters we described and used the mock classes that are present
    in the Android SDK. While these classes could cover a great number of cases, that
    is not all and you may have the need for other mock objects to furnish your test
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Several libraries provide the infrastructure to satisfy our mocking needs, but
    we are now concentrating on EasyMock which is perhaps the most widely used in
    Android.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is not an EasyMock tutorial. We will just be analyzing its use in Android,
    so if you are not familiar with it I would recommend you take a look at the documentation
    available at its website: [http://easymock.org/](http://easymock.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: EasyMock, an Open Source software project available under the Apache 2.0 license,
    provides mock objects mainly for interfaces. It is a perfect match for Test Driven
    Development due to the way of recording expectations and its dynamically generated
    mock objects because they support refactoring, and test code will not break when
    renaming methods or changing its signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to its documentation, the most relevant benefits of EasyMock are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Hand-writing classes for Mock Objects are not needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports refactoring-safe Mock Objects. Test code will not break at runtime
    when renaming methods or reordering method parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports return values and exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports checking the order of method calls, for one or more Mock Objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate its usage and to establish a style that can be later reproduced
    for other tests we are completing and expanding test cases produced before for
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous `TemperatureConverter` example, we decided to extend `EditText`
    to create `EditNumber`, a text field that accepts only signed decimal numbers.
    `EditNumber` uses an `InputFilter` to provide this feature. In the following tests
    we will be exercising this filter to verify that the correct behavior is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: To create the test we will be using a property that `EditNumber` inherits from
    `EditText`, that can add a listener, actually a `TextWatcher`, to provide methods
    that are called whenever the text of `EditText` changes. This `TextWatcher` is
    a collaborator for the test and we could have implemented it as a separate class,
    but this is tedious and may introduce more errors, so the approach taken is to
    use EasyMock to avoid the need of writing it.
  prefs: []
  type: TYPE_NORMAL
- en: And this is precisely how we are introducing a mock `TextWatcher` to check method
    invocations while text changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The latest version of EasyMock supported by Android as of this writing is EasyMock
    2.5.2\. You may want to try out a different one but it is likely you will encounter
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we should do is add `easymock-2.5.2.jar` to the Test project
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the easymock JAR file was added to the **Java
    Build Path** of the Test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extensive use of mock objects](img/3500_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to use EasyMock in our tests we only need to statically import its
    methods from `org.easymockEasyMock`, which are the only non-internal, non-deprecated
    methods of EasyMock 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It is preferable to use specific imports instead of using the wildcard, but
    it's not so easy to create the static import statement in Eclipse. However, if
    we organize imports (using **Source | Organize Imports** or the shortcut *Shift+Ctrl+O)*,
    Eclipse will create the specific statements.
  prefs: []
  type: TYPE_NORMAL
- en: Importing libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have added an EasyMock library to the project''s Java Build Path. This is
    usually not a problem, but sometimes rebuilding the project leads us to the following
    error that avoids the final APK. The problem is found when this final APK cannot
    be created because there is a problem while it is archived:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[2010-10-28 01:12:29 - TemperatureConverterTest] Error generating final archive:
    duplicate entry: LICENSE**'
  prefs: []
  type: TYPE_NORMAL
- en: This depends on how many libraries are included by the project and what they
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the available Open Source libraries have a similar content as proposed
    by GNU and include files like LICENSE, NOTICE, CHANGES, COPYRIGHT, INSTALL, among
    others. We will find this problem as soon as we try to include more than one in
    the same project to ultimately build a single APK.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to repackage the library content renaming these
    files; for example, `LICENSE` could be renamed to `LICENSE.<library>`. It is recommended
    to add the suffix **android** to the repackaged library to keep track of these
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of the steps you may need to rename those files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to move the common file names to a name suffixed by the library
    name to provide some uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: The testTextChanged test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This test will exercise `EditNumber` behavior, checking the method calls on
    the `TextWatcher` mock and verifying the results.
  prefs: []
  type: TYPE_NORMAL
- en: We are using an `AndroidTestCase` because we are interested in testing `EditNumber`
    in isolation of other components or `Activities`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test defines two `String` arrays: sai and sar. `sai` stands for `String`
    array input and `sar` for `String` array result. As you may have guessed already,
    `sai` contains the input and `sar` the expected result for the corresponding element
    in the input after filters have been applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In real life you should select more descriptive names for the variables used
    in the tests as you should do for your code, but here we are constrained by the
    space and thus we have selected very short names. The names `saInput` and `saResult`
    would be good choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We begin creating `sai` and `sar`. As we explained before they are two `String`
    arrays containing the inputs and results expected.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create a mock `TextWatcher` using `createMock(TextWatcher.class)` and
    assign it to `mEditNumber`, the `EditNumber` created in the test fixture.
  prefs: []
  type: TYPE_NORMAL
- en: We create a loop to iterate over every element of the `sai` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we take the seven common steps usually needed to use the mock object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the mock using `createMock(), createNiceMock(),` or `createStrictMock()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record the expected behavior; all methods invoked will be recorded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replay, to change the state of the object from record to play when it really
    behaves like a mock object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise the methods, usually by invoking methods of the class under test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the results of the exercised methods using asserts. This step is optional
    for simpler cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the behavior specified was actually followed. If this was not the
    case we will receive an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset can be used to reuse a mock object, clearing its state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the record step we declare all the methods we are expecting to be invoked
    on the mock object together with its arguments. We use comparators for the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using a special `Comparator, stringCmp()`, because we are interested
    in comparing the `String` content for different classes used by Android, such
    as `Editable, CharSequence, String`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The other comparator, `eq()`, expects an `int` that is equal to the given value.
    The latter is provided by EasyMock for all primitive types and `Object`, but we
    need to implement `stringCmp()` as it supports some Android-specific usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'EasyMock has a predefined matcher that would help us in creating our comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `cmp` comparator method expects an argument that will be compared using
    the provided comparator using the operator. The comparison that will take place
    is `comparator.compare(actual, value) operator 0` where operator can be one of
    logical operator values in EasyMock's `LogicalOperator enum`, representing <,<=,>,>=,
    or ==.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have already realized, its frequent use in a test could be really
    complex and may lead to errors, so to simplify this process we will be using a
    helper class that we call `StringComparator:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This class implements the `Comparator<T>` interface, which has an abstract
    method named `compare`. We implement this method by returning the result of the
    comparison of the objects passed as arguments after they are converted to String.
    Remember that `compareTo(String string)` applied to a String compares the string
    specified as a parameter to the string using the Unicode values of the characters.
    Its return value is:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 (zero) if the strings contain the same characters in the same order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative integer if the first non-equal character in this string has a Unicode
    value which is less than the Unicode value of the character at the same position
    in the specified string, or if this string is a prefix of the specified string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive integer if the first non-equal character in this string has a Unicode
    value which is greater than the Unicode value of the character at the same position
    in the specified string, or if the specified string is a prefix of this string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could invoke `EasyMock.cmp()` directly using this comparator but to simplify
    things even further we will create a generic static method `stringCmp:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This method will invoke `EasyMock.cmp()` using the right comparator for the
    specific type and using `EQUAL` as the operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is why in our test we can simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Introducing Hamcrest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the previous method is valid, a more generic approach would be to introduce
    **hamcrest**, a library of matcher objects (also known as constraints or predicates)
    allowing *match* rules to be defined declaratively, to be used in other frameworks.
    Hamcrest also provides adaptors for EasyMock 2.
  prefs: []
  type: TYPE_NORMAL
- en: We will be revisiting our previous example introducing hamcrest for our matchers.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use hamcrest we need to include it to the **Java Build Path**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example we use hamcrest-1.2, which is the latest release. Instead of
    using `hamcrest-1.2-all.jar` we use the individual components and the method described
    before to avoid several `LICENSE.txt` files from clashing.
  prefs: []
  type: TYPE_NORMAL
- en: Download hamcrest library from [http://code.google.com/p/hamcrest.](http://code.google.com/p/hamcrest.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to include the following JAR files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hamcrest-core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hamcrest-library`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hamcrest-integration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the new project properties after adding hamcrest
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Hamcrest](img/3500_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hamcrest matchers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hamcrest comes with a library of useful matchers. Here are some of the most
    important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**anything:** Always matches; useful if you don''t care what the object under
    test is'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**describedAs:** Decorator to adding custom failure description'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is:** Decorator to improve readability'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**allOf:** Matches if all matchers match, short circuits (like Java &&)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**anyOf:** Matches if any matchers match, short circuits (like Java ||)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**not:** Matches if the wrapped matcher doesn''t match and vice versa'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**equalTo:** Test object equality using `Object.equals`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hasToString:** Test `Object.toString`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**instanceOf, isCompatibleType:** Test type'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**notNullValue, nullValue:** Test for null'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sameInstance:** Test object identity'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beans**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hasProperty:** Test JavaBeans properties'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array:** Test an array''s elements against an array of matchers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hasEntry, hasKey, hasValue:** Test a map containing an entry, key, or value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hasItem, hasItems:** Test a collection containing elements'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hasItemInArray:** Test an array containing an element'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**closeTo:** Test floating point values are close to a given value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo:** Test ordering'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**equalToIgnoringCase:** Test string equality ignoring case'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**equalToIgnoringWhiteSpace:** Test string equality ignoring differences in
    runs of whitespace'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**containsString, endsWith, startsWith:** Test string matching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The hasToString matcher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our next step is to create the matcher to replace the previous use of the `stringCmp()`
    Comparator. `EasyMock2Adapter` is an adapter class provided by hamcrest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Having this matcher implemented, the following step is still required. We need
    to adapt the `testTextChanged()` method to include this newly created matcher
    instead of `stringCmp():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Testing Views in isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test we are analyzing here also belongs to the ApiDemos project. It demonstrates
    how some properties of the `Views` conforming a `Layout` can be tested when the
    behavior itself cannot be isolated. Testing focus is one of these situations.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid creating the full `Activity`, this test is extending `AndroidTestCase:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As in previous cases we start with the required copyright and imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, this test extends `AndroidTestCase` to provide a lightweight
    alternative to `ActivityInstrumentationTestCase<Activity>` when possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have thought about using just `TestCase`, but unfortunately this is
    not possible as we need a `Context` to inflate the XML layout via `LayoutInflater`,
    and `AndroidTestCase` will provide us with this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The fixture set up is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FocusFinder` is a class that provides the algorithm used to find the next
    focusable `View`. It implements the singleton pattern and that''s why we use `FocusFinder.getInstance()`
    to obtain a reference to it. This class has several methods to help us find focusable
    and touchable items as we mentioned, given various conditions as the nearest in
    a given direction or searching from a particular rectangle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we get the `LayoutInflater` and inflate the layout under test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing we need to take into account, as our test is isolated from other parts
    of the system, is that we have to manually measure and layout the components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we use the *find views* pattern and we assign the found views to the
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the fixture has been configured we describe the precondition in a test
    which, as we mentioned earlier is named `testPreconditions()`. However, because
    tests are found using reflection, there is no guarantee that it will run in a
    particular order, as all of the test methods are looked for by evaluating if their
    name begins with test.
  prefs: []
  type: TYPE_NORMAL
- en: These preconditions include the verification of the relative position on the
    screen for the components. In this case their edges relative to the parent are
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a previous chapter we enumerated all the available asserts in our arsenal
    and you may remember that to test `Views` position, we had a complete set of assertions
    in the `ViewAsserts` class. However, this depends on how the layout is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The method `testGoingRightFromLeftButtonJumpsOverCenterToRight()`, as its name
    suggests, tests the focus gained by the right button when the focus moves from
    the right to the left button. To achieve this search, the instance of `FocusFinder`
    obtained during the `setUp()` method is employed. This class has a `findNextFocus()`
    method to obtain the View receiving focus in a given direction. The value obtained
    is checked against our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, the test `testGoingLeftFromRightButtonGoesToCenter()`, tests
    the focus going in the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: Testing parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many occasions where your Android application relies on external XML,
    JSON messages, or documents obtained from web services. These documents are used
    for data interchange between the local application and the server. There are many
    use cases where XML or JSON documents are obtained from the server or generated
    by the local application to be sent to the server. Ideally, methods invoked by
    these activities have to be tested in isolation to have real unit tests and to
    achieve this, we need to include some mock files somewhere in our APK to run the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: But the question is where can we include these files?
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Android assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, a brief review of the assets definition can be found in the Android
    SDK documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between "resources" and "assets" isn't much on the surface, but
    in general, you'll use resources to store your external content much more often
    than you'll use assets. The real difference is that anything placed in the resources
    directory will be easily accessible from your application from the R class, which
    is compiled by Android. Whereas, anything placed in the assets directory will
    maintain its raw file format and, in order to read it, you must use the AssetManager
    to read the file as a stream of bytes. So keeping files and data in resources
    (res/) makes them easily accessible.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Clearly, assets are what we need to store the files that will be parsed to test
    the parser.
  prefs: []
  type: TYPE_NORMAL
- en: So our XML or JSON files should be placed on the assets folder to prevent manipulation
    at compile time and to be able to access their raw content while the application
    or test run.
  prefs: []
  type: TYPE_NORMAL
- en: But be careful; we need to place them in the assets folder of our **test project**
    because they are not part of the application and we don't want them packed with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The parser activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is an extremely simple activity to demonstrate the case. Our activity
    obtains an XML or JSON document from a server and then parses it. Let''s assume
    we have a `parseXml` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is an oversimplified example of an activity that includes a parser method
    to illustrate the use of assets. Your real application may look very different
    and your parser could be implemented as an external class that could be tested
    in isolation and integrated at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: The parser test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This test implements an `ActivityInstrumentationTestCase2` for the `ParserExampleActivity`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Almost all the methods are simple implementations of the default ones and the
    only interesting method for us is `testParseXml().` Firstly, the activity is obtained
    by invoking `getActivity()`. Then an `InputStream` is obtained, opening the file
    `my_document.xml` from the assets by `getInstrumentation().getContext().getAssets()`.
    Note that the `Context` and thus the assets obtained here are from the tests package
    not from the `Activity` under test.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the activity `parseXml()` method is invoked using the recently obtained
    `InputStream`. If there is an `Exception, fail()` is invoked and if everything
    goes well we test that the result is not null.
  prefs: []
  type: TYPE_NORMAL
- en: We should then provide the XML we want to use for the test in an asset named
    `my_document.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Testing for memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes memory consumption is an important factor to measure the good behavior
    of the test target, be it an Activity, Service, ContentProvider, or other Component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test for this condition, we can use a utility test that you can invoke from
    other tests mainly after having run a test loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This assertion can be called from other tests. At the beginning it obtains the
    `MemoryInfo` from `ActivityManager` using `getMemoryInfo()`, after getting the
    instance using `getSystemService()`. The field `lowMemory` is set to true if the
    system considers itself to currently be in a low memory situation.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases we want to dive even deeper in the resource usage and we can obtain
    more detailed information from the process table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create another helper method to obtain process information and use it
    in our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To obtain this information, a command (in this case, `ps` is used but you can
    adapt it to your needs) is executed using `Runtime.exec()`. The output of this
    command is concatenated in a `String` that is later returned. We can use the return
    value to print it to the logs in our test or we can further process the content
    to obtain summary information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example if logging the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When this test is run we obtain information about the running processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): USER PID PPID VSIZE RSS WCHAN
    PC NAME**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 1 0 312 220 c009b74c 0000ca4c
    S /init**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 2 0 0 0 c004e72c 00000000
    S kthreadd**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 3 2 0 0 c003fdc8 00000000
    S ksoftirqd/0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 4 2 0 0 c004b2c4 00000000
    S events/0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 5 2 0 0 c004b2c4 00000000
    S khelper**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 6 2 0 0 c004b2c4 00000000
    S suspend**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 7 2 0 0 c004b2c4 00000000
    S kblockd/0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 8 2 0 0 c004b2c4 00000000
    S cqueue**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 9 2 0 0 c018179c 00000000
    S kseriod**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[…]**'
  prefs: []
  type: TYPE_NORMAL
- en: The output was cut for brevity but you will get the complete list of processes
    running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief explanation of the information obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| USER | This is the textual user ID. |'
  prefs: []
  type: TYPE_TB
- en: '| PID | Process ID number of the process. |'
  prefs: []
  type: TYPE_TB
- en: '| PPID | Parent process ID. |'
  prefs: []
  type: TYPE_TB
- en: '| VSIZE | Virtual memory size of the process in KiB. This is the virtual memory
    the process reserves. |'
  prefs: []
  type: TYPE_TB
- en: '| RSS | Resident set size, the non-swapped physical memory that a task has
    used (in pages). This is the actual amount of real memory the process takes in
    pages.This does not include pages which have not been demand-loaded in. |'
  prefs: []
  type: TYPE_TB
- en: '| WCHAN | This is the "channel" in which the process is waiting. It is the
    address of a system call, and can be looked up in a namelist if you need a textual
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| PC | The current EIP (instruction pointer). |'
  prefs: []
  type: TYPE_TB
- en: '| State (no header) | The process state.'
  prefs: []
  type: TYPE_NORMAL
- en: S for sleeping in an interruptible state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R for running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T for a stopped process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z for a zombie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| NAME | Command name. Application processes in Android are renamed after its
    package name. |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, several real world examples of tests that cover a wide range
    of cases were presented. You can use them as a starting point while creating your
    own tests.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a variety of testing recipes that you can extend for your own tests.
    We used mock contexts and showed how a `RenamingDelegatingContext` can be used
    in various situations to change the data obtained by the tests. We also analyzed
    the injection of these mock context into test dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we used `ActivityUnitTestCase` to test Activities in complete isolation.
    We tested Views in isolation using `AndroidTestCase`. We demonstrated the use
    of EasyMock 2 to mock objects combined with Hamcrest to provide comparators. Finally
    we treated the analysis of potential memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter focuses on automating the testing process using Continuous
    Integration.
  prefs: []
  type: TYPE_NORMAL
