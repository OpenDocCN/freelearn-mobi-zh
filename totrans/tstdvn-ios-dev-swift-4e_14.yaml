- en: '*Chapter 10*: Testing Networking Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：测试网络代码'
- en: Almost all iOS apps communicate with some kind of server to synchronize data
    to other devices or to provide additional features that are not possible on the
    iOS device alone. As the code of the server application is separate from the code
    of the iOS application, the unit tests for the iOS app should not test features
    implemented in the server application. The unit tests for the iOS app should only
    fail if the code of the iOS app has bugs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有iOS应用程序都需要与某种服务器通信，以同步数据到其他设备或提供iOS设备本身无法实现的附加功能。由于服务器应用程序的代码与iOS应用程序的代码是分开的，因此iOS应用程序的单元测试不应测试服务器应用程序中实现的功能。iOS应用程序的单元测试仅在iOS应用程序的代码有错误时才应失败。
- en: 'To achieve that, the unit tests need to be independent of the server application.
    This separation has several advantages. The main ones are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，单元测试需要独立于服务器应用程序。这种分离有几个优点。主要如下：
- en: The unit tests are faster when they don't need to wait for the responses of
    the server.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当单元测试不需要等待服务器的响应时，它们运行得更快。
- en: The unit tests do not fail because the server is not available.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试不会因为服务器不可用而失败。
- en: The networking code can be developed using test-driven development, even before
    the server application is available.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使服务器应用程序尚未可用，也可以使用测试驱动开发来开发网络代码。
- en: In this chapter, we will implement two different kinds of networking code using
    test-driven development and mock objects. After you have worked through this chapter,
    you will be able to write tests for code that communicates with `CLGeoCoder`.
    You will also learn how to write tests for networking code using the new async/await
    API of `URLSession`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用测试驱动开发和模拟对象实现两种不同类型的网络代码。在您完成本章后，您将能够为与`CLGeoCoder`通信的代码编写测试。您还将学习如何使用`URLSession`的新异步/等待API编写网络代码的测试。
- en: 'This chapter is structured as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结构如下：
- en: Mocking `CLGeoCoder`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟`CLGeoCoder`
- en: Testing async/await code that communicates with a `URLSession` instance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与`URLSession`实例通信的异步/等待代码
- en: Handling errors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: Writing tests for networking code is exciting, so let's get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编写网络代码的测试非常有趣，让我们开始吧。
- en: Mocking CLGeoCoder
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟`CLGeoCoder`
- en: '`CLGeoCoder` is a class provided by Apple that helps you to get coordinates
    from an address string and vice versa. The methods in `CLGeoCoder` are based on
    completion closures. In this chapter, we will explore how to mock and test such
    methods.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLGeoCoder`是Apple提供的一个类，它可以帮助您从地址字符串获取坐标，反之亦然。`CLGeoCoder`中的方法基于完成闭包。在本章中，我们将探讨如何模拟和测试此类方法。'
- en: Cleaning your project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理项目
- en: 'Before we write the first test for this chapter, let''s clean up the project
    a bit. Add sections in the project navigator and move the files to those sections
    according to your structure scheme. For inspiration, here is the structure I use
    for the main target:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为本章编写第一个测试之前，让我们稍微清理一下项目。在项目导航器中添加部分，并根据您的结构方案将文件移动到这些部分。为了获得灵感，以下是我在主要目标中使用的结构：
- en: '![Figure 10.1 – Adding structure in the project navigator'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 在项目导航器中添加结构'
- en: '](img/Figure_10.1_B18127.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.1_B18127.jpg)'
- en: Figure 10.1 – Adding structure in the project navigator
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 在项目导航器中添加结构
- en: Your structure can be completely different. Use the structure you usually use
    in iOS projects. Also, add a similar structure to the files in the test target.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结构可以完全不同。使用您在iOS项目中通常使用的结构。此外，将类似的结构添加到测试目标中的文件。
- en: When you add new files to the project, you have to choose the correct folder
    depending on the structure you applied.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向项目中添加新文件时，您必须根据您应用的结构选择正确的文件夹。
- en: Preparations for the tests
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试准备
- en: 'Before we can write tests for the `APIClient` class we added in [*Chapter 9*](B18127_09_ePub.xhtml#_idTextAnchor324),
    *Test-Driven Input View in SwiftUI*, we need a new test case class. Follow these
    steps to add it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为在[*第9章*](B18127_09_ePub.xhtml#_idTextAnchor324)中添加的`APIClient`类编写测试之前，即*SwiftUI中的测试驱动输入视图*，我们需要一个新的测试用例类。按照以下步骤添加它：
- en: Add a new `APIClientTests` to the test target. Remove the two test template
    methods.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`APIClientTests`添加到测试目标中。删除两个测试模板方法。
- en: 'Import the `ToDo` module using the `@testable` keyword and add setup and teardown
    code to the `TestCase` class:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@testable`关键字导入`ToDo`模块，并将设置和清理代码添加到`TestCase`类中：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating the first test
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建第一个测试
- en: 'With this preparation, we are ready to write the first test for the `APIClient`
    class. Follow these steps to add a test for fetching the coordinate of an address
    using a `CLGeoCoder` instance and make it pass:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，我们可以开始编写 `APIClient` 类的第一个测试。按照以下步骤添加一个用于使用 `CLGeoCoder` 实例获取地址坐标的测试，并使其通过：
- en: 'To be able to replace `CLGeoCoder` in the `APIClient` class with a mock object,
    we need to define the interface we expect in a protocol. Import the `CoreLocation`
    framework to `APIClient.swift` and add the following protocol definition to `APIClient.swift`
    outside of the `APIClient` class implementation:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够在 `APIClient` 类中将 `CLGeoCoder` 替换为模拟对象，我们需要在协议中定义我们期望的接口。将 `CoreLocation`
    框架导入到 `APIClient.swift` 中，并在 `APIClient` 类实现之外添加以下协议定义到 `APIClient.swift`：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to tell the compiler that `CLGeoCoder` already conforms to that
    protocol. It does so because it already implements a method with this exact signature.
    Add this line below the `GeoCoderProtocol` implementation:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉编译器 `CLGeoCoder` 已经符合该协议。它是这样做的，因为它已经实现了一个具有这个确切签名的方 法。在 `GeoCoderProtocol`
    实现下方添加此行：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can define a mock object we will use in the test. Add a new Swift file
    to the test target and call it `GeoCoderProtocolMock.swift`. Replace its content
    with the following:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个在测试中使用的模拟对象。向测试目标添加一个新的 Swift 文件，并将其命名为 `GeoCoderProtocolMock.swift`。用以下内容替换其内容：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the test, we want to call the `geocodeAddressString(_:completionHandler:)`
    method and pass a `CLPlacemark` instance into the completion handler. To create
    a `CLPlacemark` instance in a test, we need to import the `Intents` and `Contacts`
    frameworks, because the initializer we need is defined in the `Intents` framework
    and uses classes from the `Contacts` framework (I got this tip from the *StackOverflow*
    answer fo[und at https://stackoverflow.com/a/52932708](https://stackoverflow.com/a/52932708/498796)/498796):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试中，我们想要调用 `geocodeAddressString(_:completionHandler:)` 方法，并将 `CLPlacemark`
    实例传递到完成处理程序中。为了在测试中创建 `CLPlacemark` 实例，我们需要导入 `Intents` 和 `Contacts` 框架，因为所需的初始化器在
    `Intents` 框架中定义，并使用来自 `Contacts` 框架的类（我从 StackOverflow 的答案中得到了这个提示，该答案可在 https://stackoverflow.com/a/52932708/498796/498796
    找到）：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can start with writing the tests. Add the following fragment of a test
    to `APIClientTests`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写测试。将以下测试片段添加到 `APIClientTests` 中：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Xcode tells us that we need to add a property for the `geoCoder` property to
    `APIClient`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 告诉我们，我们需要为 `geoCoder` 属性在 `APIClient` 中添加一个属性。
- en: 'Go to the `APIClient` class and add the following property:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `APIClient` 类，并添加以下属性：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `lazy` keyword means that the initializer is called the first time the property
    is accessed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy` 关键字意味着初始化器是在属性第一次被访问时调用的。'
- en: 'Go back to the test and make it look like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到测试，使其看起来像这样：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After we have set up the `geoCoderMock` instance, we create dummy variables
    and call the method we want to test. The `GeoCoderProtocolMock` class captures
    the completion handler of the `geocodeAddressString(_:complectionHandler:)` call.
    This allows us to call this completion handler with a placemark we created. In
    the test assertions, we check whether the method was called with the address string
    we provided and whether the coordinate was passed into the `completion` closure
    of the `coordinate(for:completion:)` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置了 `geoCoderMock` 实例之后，我们创建虚拟变量并调用我们想要测试的方法。`GeoCoderProtocolMock` 类捕获了
    `geocodeAddressString(_:completionHandler:)` 调用的完成处理程序。这允许我们使用我们创建的地点标记来调用这个完成处理程序。在测试断言中，我们检查方法是否使用我们提供的地址字符串被调用，以及坐标是否传递到了
    `coordinate(for:completion:)` 方法的 `completion` 闭包中。
- en: 'Replace the implementation of `coordinate(for:completion:)` in `APIClient`
    with the following implementation:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `APIClient` 中的 `coordinate(for:completion:)` 方法的实现替换为以下实现：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we added an internal name for the address string parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为地址字符串参数添加了一个内部名称。
- en: 'Run the tests. The new test still fails, but the first assertion doesn''t fail
    anymore. This tells us that our test does too much. We should split this test
    into two tests: one that checks whether the method is called with the address
    string we provide, and another one that checks that the coordinate is passed into
    the completion closure.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。新的测试仍然失败，但第一个断言不再失败。这告诉我们我们的测试做得太多。我们应该将这个测试拆分为两个测试：一个检查方法是否使用我们提供的地址字符串被调用，另一个检查坐标是否传递到了完成闭包中。
- en: 'We should always only have one failing test, so add `x_` in front of the method
    name of `test_coordinate_fetchesCoordinate`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该始终只有一个失败的测试，所以将 `x_` 添加到 `test_coordinate_fetchesCoordinate` 方法的名称前：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the test runner searches for methods beginning with the word `test`, adding
    `x_` hides the method from the test runner. To confirm that this is true, run
    all tests again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试运行器正在搜索以单词 `test` 开头的方法，添加 `x_` 可以隐藏方法从测试运行器。为了确认这一点，再次运行所有测试。
- en: 'Now, add the following test method to `APIClientTests`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `APIClientTests` 添加以下测试方法：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remove the code we added to `coordinate(for:completion:)` in `APIClient` and
    run the tests to see this new test fail.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `APIClient` 中的 `coordinate(for:completion:)` 方法中删除我们添加的代码，并运行测试以查看这个新测试失败。
- en: Add the code again and run the tests. All tests should pass now.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次添加代码并运行测试。现在所有测试都应该通过。
- en: 'Now, we can remove the check for the address string from `test_coordinate_fetchesCoordinate()`
    because it is now asserted in `test_coordinate_shouldCallGeoCoderWithAddress()`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从 `test_coordinate_fetchesCoordinate()` 中删除对地址字符串的检查，因为它现在已在 `test_coordinate_shouldCallGeoCoderWithAddress()`
    中断言：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run all tests to see this test fail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以查看这个测试失败。
- en: 'To make this test pass, we need to get the coordinate from the `CLGeoCoder`
    instance and pass it into the completion handler. Replace the `coordinate(for:completion:)`
    method with the following implementation:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们需要从 `CLGeoCoder` 实例获取坐标并将其传递给完成处理程序。将 `coordinate(for:completion:)`
    方法替换为以下实现：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, Xcode complains that `@escaping` keyword to the `completion` parameter
    in the `APIClientProtocol` protocol.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Xcode 抱怨 `@escaping` 关键字在 `APIClientProtocol` 协议中的 `completion` 参数。
- en: 'Replace the `APIClientProtocol` definition with the following:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `APIClientProtocol` 定义替换为以下内容：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run all tests to confirm that now all tests pass.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试以确认现在所有测试都通过。
- en: With this implementation, our app can now fetch the coordinate of an address
    string. This feature enables our users to add a location to a to-do item.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实现，我们的应用现在可以获取地址字符串的坐标。此功能使用户能够将位置添加到待办事项中。
- en: In the next section, we will implement fetching to-do items from a server. We
    don't need an actual server to write the tests and the implementation for this
    feature. This is one of the many advantages of test-driven development.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现从服务器获取待办事项。我们不需要实际的服务器来编写测试和实现此功能。这是测试驱动开发的优势之一。
- en: Testing async/await code that communicates with URLSession
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试与 URLSession 通信的 async/await 代码
- en: In 2021, Apple introduced async/await in Swift. With async/await, asynchronous
    code (for example, fetching information from a server) is easier to write and
    easier to understand. In this section, we will learn how to implement fetching
    data from a web server using the async/await APIs of the `URLSession` class; and
    we will do this, of course, using test-driven development.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年，苹果在 Swift 中引入了 async/await。有了 async/await，异步代码（例如，从服务器获取信息）更容易编写和理解。在本节中，我们将学习如何使用
    `URLSession` 类的 async/await API 实现从网络服务器获取数据；当然，我们将使用测试驱动开发来完成这项工作。
- en: Unit tests need to be fast and repeatable. This means we don't want to rely
    on a connection to a real server in our unit tests. Instead, we will replace the
    communication with the server with a mock object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试需要快速且可重复。这意味着我们不想在我们的单元测试中依赖于与真实服务器的连接。相反，我们将用模拟对象替换与服务器的通信。
- en: 'Follow these steps to implement fetching to-do items from a server:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现从服务器获取待办事项：
- en: In the test, we will use a mock object of a `URLSession` class instead of the
    real `URLSession` instance. To be able to replace the real `URLSession` instance
    with the mock, we need a protocol that defines the interface we want to replace.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试中，我们将使用 `URLSession` 类的模拟对象而不是真实的 `URLSession` 实例。为了能够用模拟对象替换真实的 `URLSession`
    实例，我们需要一个定义我们想要替换的接口的协议。
- en: 'Add the following protocol definition to `APIClient.swift`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `APIClient.swift` 添加以下协议定义：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to tell the compiler that the `URLSession` class already conforms
    to this protocol. Add the following code to `APIClient.swift`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉编译器 `URLSession` 类已经符合此协议。将以下代码添加到 `APIClient.swift`：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Select the `URLSessionProtocolMock`. Replace its contents with the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `URLSessionProtocolMock`。将其内容替换为以下内容：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This mock object allows us to define the return value of `data(for:delegate:)`
    in the test we are going to write.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟对象允许我们在将要编写的测试中定义 `data(for:delegate:)` 的返回值。
- en: 'With this preparation, we can start writing the test. Add the following fragment
    of the test method to `APIClientTests`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备就绪后，我们可以开始编写测试。将以下测试方法的片段添加到`APIClientTests`：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code, we define the URL and the data to be used in the mock response.
    The `urlSessionMock` class returns a JSON object with one `ToDoItem` object and
    an `HTTPURLResponse` instance with the expected URL and the status code `200`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了URL和用于模拟响应的数据。`urlSessionMock`类返回一个包含一个`ToDoItem`对象和一个带有预期URL和状态码`200`的`HTTPURLResponse`实例的JSON对象。
- en: We have to pause writing the test because the system under test (the `APIClient`
    class) doesn't have a `session` property yet.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须暂停编写测试，因为系统测试（`APIClient`类）还没有`session`属性。
- en: 'Go to `APIClient` and add the property like this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`APIClient`并添加如下属性：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Switch back to the test class and add the call to fetch the to-do items:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回测试类并添加获取待办事项的调用：
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, we have to pause because this method is not defined yet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们必须暂停，因为这个方法尚未定义。
- en: 'Go to `APIClient` and add the minimal implementation to make the test compile:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`APIClient`并添加最小实现以使测试编译：
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can finish the test. Add the assertion call as shown in this code
    snippet:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以完成测试。添加如代码片段所示的断言调用：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the tests to confirm that this new test fails.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败。
- en: 'To make the test pass, replace the `toDoItems` method in the `APIClient` class
    with the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，将`APIClient`类中的`toDoItems`方法替换为以下代码：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we define the URL, create a request, call `data(for:delegate:)`
    on the session property, and try to decode the result into an array of `ToDoItems`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了URL，创建了一个请求，在会话属性上调用`data(for:delegate:)`，并尝试将结果解码为`ToDoItems`数组。
- en: Run the tests to confirm that this code makes the tests pass.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这段代码使测试通过。
- en: But, there is something strange with this code. The URL is wrong. We need to
    expand the test to also check for the used URL.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这段代码中有些奇怪。URL是错误的。我们需要扩展测试以检查使用的URL。
- en: 'Add the following assert function call to the end of `test_doToItems_shouldFetchesItems`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下断言函数调用添加到`test_doToItems_shouldFetchesItems`的末尾：
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the tests to confirm that the test now fails because we used the wrong URL
    in the implementation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认测试现在失败，因为我们使用了错误的URL。
- en: 'To make the test pass, replace the URL initialization in the `toDoItems` method
    with this implementation:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，将`toDoItems`方法中的URL初始化替换为以下实现：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the tests to confirm that now all tests pass.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认现在所有测试都通过。
- en: Of course, this implementation is just an example to get you started testing
    network calls. In a real app, you would add authorization to the network calls
    to ensure that users can only access their to-do items and not the ones of other
    users.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个实现只是一个示例，帮助你开始测试网络调用。在实际应用中，你会在网络调用中添加授权，以确保用户只能访问他们的待办事项，而不能访问其他用户的待办事项。
- en: Fetching data from a web service can go wrong. In the following section, we
    will test whether the error from the `URLSession` instance is passed down to the
    caller of `toDoItems`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络服务获取数据可能会出错。在以下部分，我们将测试`URLSession`实例的错误是否传递给了`toDoItems`的调用者。
- en: Handling errors
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'To test the handling of errors in the `URLSession` call to the web service,
    we first need to enhance `URLSessionProtocolMock`. Follow these steps to test
    that an error in fetching data is passed down to the caller of the `APIClient`
    instance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试对网络服务`URLSession`调用的错误处理，我们首先需要增强`URLSessionProtocolMock`。按照以下步骤测试从`APIClient`实例调用中传递下来的数据获取错误：
- en: 'Add the following property to `URLSessionProtocolMock`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`URLSessionProtocolMock`：
- en: '[PRE25]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, add the following handling of the error to the start of `data(for:delegate:)`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下错误处理添加到`data(for:delegate:)`的开始部分：
- en: '[PRE26]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If there is an error set to the `dataForDelegateError` property, we throw it
    before we do anything else in this method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将错误设置到`dataForDelegateError`属性中，我们会在执行此方法中的其他任何操作之前抛出它。
- en: 'Now, we are ready to add the test method to `APIClientTests`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好将测试方法添加到`APIClientTests`。
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this code, we create an error and assign it to the `dataForDelegateError`
    property of `urlSessionMock`. Then, we call `sut.toDoItems()` within a `do-catch`
    block to catch the error we expect from the call. If no error is thrown from `toDoItems()`
    the test fails with `XCTFail`. Otherwise, we compare the error with the expected
    value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个错误并将其分配给`urlSessionMock`的`dataForDelegateError`属性。然后，我们在`do-catch`块中调用`sut.toDoItems()`以捕获我们期望从调用中得到的错误。如果没有从`toDoItems()`抛出错误，测试将因`XCTFail`而失败。否则，我们比较错误与期望的值。
- en: Run the tests. All tests pass already. This is bad. As you already learned,
    in test-driven development we need to see a test fail before we make it green.
    Otherwise, we can't be sure that the tests can fail. It's easy to write tests
    that always pass. So, let's make the test fail.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试。所有测试已经通过。这是不好的。正如你已经学到的，在测试驱动开发中，在我们将其变为绿色之前，我们需要看到测试失败。否则，我们无法确定测试是否可以失败。编写总是通过测试很容易。所以，让我们让这个测试失败。
- en: 'Change the implementation of `data(for:delegate:)` in `URLSessionProtocolMock`
    so that it looks like this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`URLSessionProtocolMock`中的`data(for:delegate:)`的实现更改，使其看起来像这样：
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the tests again to confirm that with this change, the new test fails.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试以确认这个更改导致新的测试失败。
- en: 'Remove the `throw NSError(domain: "dummy", code: 0)` line again and run the
    tests to see all tests pass again.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '再次删除`throw NSError(domain: "dummy", code: 0)`行并运行测试以查看所有测试都通过。'
- en: With this test, we have confirmed that an error in fetching the data from the
    web service is passed down to the caller of `toDoItems()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个测试，我们确认了从网络服务获取数据时出现的错误会被传递给`toDoItems()`的调用者。
- en: 'But what happens when the data from the web service is not in the format we
    expect? What should happen in this case? Follow these steps to add a test for
    this case:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当网络服务的数据不是我们期望的格式时会发生什么？在这种情况下应该发生什么？按照以下步骤添加对这个情况的测试：
- en: 'Add the following test method to `APIClientTests`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`APIClientTests`中：
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The data we return here when `toDoItems` of `urlSessionMock` is called is a
    JSON object of the `dummy` string. Trying to decode this into an array of `ToDoItem`
    objects should result in an error of the `Swift.DecodingError` type. This is what
    the last assertion in the test asserts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`urlSessionMock`的`toDoItems`时，我们返回的数据是`dummy`字符串的JSON对象。尝试将其解码为`ToDoItem`对象数组应导致`Swift.DecodingError`类型的错误。这是测试中的最后一个断言所断言的。
- en: Run the tests. Again, all tests pass. And again, we need to change something
    to see this test fail.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。再次，所有测试都通过了。但是，我们还需要更改一些东西才能看到这个测试失败。
- en: 'Go to `APIClient` and replace `toDoItems()` with the following implementation:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`APIClient`并将`toDoItems()`替换为以下实现：
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this code, we have changed the last three lines of that method. Instead of
    `try`, we use `try?` when we try to decode the data from the web service. When
    the data cannot be decoded into an array of `ToDoItem`s, the result is optional
    and no error is thrown. As a result, we also need to change the `return` value.
    When the value of the `items` property is `nil`, we return an `empty` array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们更改了那个方法中的最后三行。当我们尝试从网络服务解码数据时，我们使用`try?`而不是`try`。当数据无法解码为`ToDoItem`数组时，结果是可选的，不会抛出错误。因此，我们还需要更改`return`值。当`items`属性的值为`nil`时，我们返回一个空数组。
- en: Run the tests. The test we added last now fails and we have confirmed that it
    actually can fail.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。我们最近添加的测试现在失败了，并且我们已经确认它确实可能会失败。
- en: 'Change the implementation of `toDoItems()` to what it was before:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`toDoItems()`的实现更改为之前的版本：
- en: '[PRE31]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the tests again to see all tests pass again.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试以查看所有测试都通过。
- en: There are many more tests to write for the implementation of this web service
    call. For example, you should also write tests for cases when the web service
    answers with an HTTP status code other than `200`. These tests are left as an
    exercise for you. Add tests for this API call until you are confident that this
    feature does not break unnoticed in the future.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个网络服务调用的实现，还有许多更多的测试需要编写。例如，你应该也为网络服务以除`200`以外的HTTP状态码响应的情况编写测试。这些测试留给你作为练习。添加对这个API调用的测试，直到你确信这个功能在未来不会在未被发现的情况下破坏。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to write tests for calls to `CLGeoCoder`
    and how to test the async/await REST API calls of `URLSession`. We have seen what
    we need to do in the test method to test whether an error is thrown in an async/await
    call. In addition, we have learned how to make our network code tests independent
    from the implementation of server infrastructure. This way we made our tests fast
    and robust.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们学习了如何编写对`CLGeoCoder`的调用测试，以及如何测试`URLSession`的异步/等待REST API调用。我们看到了在测试方法中需要做什么来测试异步/等待调用中是否抛出错误。此外，我们还学习了如何使我们的网络代码测试与服务器基础设施的实现独立。这样我们使测试变得快速且健壮。
- en: You can use the skills gained in this chapter to write tests for the complete
    network layer of your apps. But you don't have to stop there. The strategies we've
    covered in this chapter also help to write tests for all kinds of async/await
    APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本章学到的技能来编写您应用完整网络层的测试。但您不必止步于此。本章中我们讨论的策略同样有助于编写各种异步/等待（async/await）API的测试。
- en: In the next chapter, we will put all the code that we wrote up to now together,
    and finally see the app running on the simulator.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把到目前为止编写的所有代码整合在一起，并最终在模拟器上运行应用程序。
- en: Exercises
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We have deactivated a test method using the `x_` prefix to hide it from the
    test runner. There are other ways to deactivate a single test. Do some research
    on the internet to figure these out.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`x_`前缀禁用了一个测试方法，以将其从测试运行器中隐藏。还有其他方法可以禁用单个测试。在网上做一些研究，找出这些方法。
- en: In this chapter, we wrote tests for the async/await API of `URLSession`. But,
    `URLSession` also provides an API that uses the delegate pattern and one that
    uses Combine. Do some research on the internet to find out how to write unit tests
    for these APIs. Make sure that these tests also run when there is no connection
    to the server.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中，我们为`URLSession`的异步/等待API编写了测试。但是，`URLSession`还提供了一个使用代理模式（delegate pattern）的API和一个使用Combine的API。在网上做一些研究，找出如何为这些API编写单元测试。确保这些测试在没有连接到服务器的情况下也能运行。
