<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Behavioral Patterns – Chain of Responsibility and Command</h1></div></div></div><p>In this chapter, we will continue to explore the behavioral patterns—the <strong>chain of responsibility</strong> and <strong>command</strong> patterns. Both of these patterns are concerned with passing requests to appropriate objects that will then execute the action.</p><p>The main difference between these two patterns is the way that the requests are passed between objects.</p><p>In this chapter, we will discuss the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The chain of responsibility pattern</li><li class="listitem" style="list-style-type: disc">The command pattern</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec29"/>The chain of responsibility pattern</h1></div></div></div><p>When <a class="indexterm" id="id280"/>you write an application, it may be that an event generated by an object needs to be handled by another object. You may also want the handle to be inaccessible by another object.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec108"/>Roles</h2></div></div></div><p>In this section, you<a class="indexterm" id="id281"/> will notice that the chain of responsibility pattern creates a chain of objects in such a way that if an object of this chain cannot handle the request, it sends the request to the next object, the successor, until one of them can handle the request.</p><p>This pattern allows an object to send a request without knowing which object will receive and handle it. The request is sent from one object to another, making them parts of a chain. Each object of this chain can handle the request, pass it to its successor, or do both.</p><p>You may want to use this pattern when:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You <a class="indexterm" id="id282"/>want to decouple the sender of a request to its receiver, allowing other objects to handle the request too</li><li class="listitem" style="list-style-type: disc">Objects that can handle the request are part of a chain of work, the request passes from one object to another until at least one of these objects can handle it</li><li class="listitem" style="list-style-type: disc">You want to allow objects that can process requests to be ordered in a preferential sequence that can be reordered, without having any impact on the calling component</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec109"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id283"/> following diagram illustrates the generic representation of the chain of responsibility pattern:</p><div><img alt="Design" src="img/B04852_06_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec110"/>Participants</h2></div></div></div><p>This<a class="indexterm" id="id284"/> pattern has three participants, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AbstractHandler</code>: This <a class="indexterm" id="id285"/>defines the interface of the requests and implements the association of the chain of responsibility pattern.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteHandlers</code>: These <a class="indexterm" id="id286"/>objects can handle requests that they are responsible for. If it cannot handle the request, it passes the request to its successor or stops the chain.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Client</code>: The<a class="indexterm" id="id287"/> client sends the request to the first object of the chain that may handle the request.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec111"/>Collaboration</h2></div></div></div><p>The <a class="indexterm" id="id288"/>following sequence diagram illustrates the collaboration between objects:</p><div><img alt="Collaboration" src="img/B04852_06_02.jpg"/></div><p>The client sends the request to the first object of the chain. Then, this request is propagated throughout the chain until at least one of the objects of the chain can handle it.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec112"/>Illustration</h2></div></div></div><p>Suppose<a class="indexterm" id="id289"/> that you are supervising the development of a mobile application, and you want to handle some log messages differently, depending on the priority of the logger.</p><p>You define three types of priority, which means three levels of loggers: <code class="literal">DEBUG</code>, <code class="literal">INFO</code>, and <code class="literal">ERROR</code>.</p><p>Depending on the level of the log messages, you can handle it as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the level (or priority) is <code class="literal">DEBUG</code>, then this will be handled by the standard output logger</li><li class="listitem" style="list-style-type: disc">If the level is <code class="literal">INFO</code>, then we will use the standard output logger and e-mail logger that will send an e-mail with the message</li><li class="listitem" style="list-style-type: disc">If the level is <code class="literal">ERROR</code>, then all the three loggers will handle the message: the standard output logger, e-mail logger, and error logger</li></ul></div><p>As we can see here, we need to define a chain of objects in the following order: <code class="literal">StdOutLogger</code>, <code class="literal">EmailLogger</code>, and <code class="literal">ErrorLogger</code>.</p><p>The client will then only call the first concrete handler, the class that may handle the request: <code class="literal">StdOutLogger</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec113"/>Implementation</h2></div></div></div><p>To implement<a class="indexterm" id="id290"/> our pattern, we will need to prepare our abstract class first. Remember that with Swift, an abstract class does not really exist. We will write our abstract class as a class, but methods that need to be overridden will have the following statement:</p><div><pre class="programlisting">preconditionFailure("Must be overridden")</pre></div><p>In this case, if the code of the abstract class is called instead of the one available in the derived class, an exception similar to the following will be raised:</p><div><img alt="Implementation" src="img/4852_06_03.jpg"/></div><p>Let's now begin with the implementation.</p><p>First, open the <code class="literal">ChainOfResponsibilityPattern</code> project that you will find in the <code class="literal">Chapter 6</code> folder.</p><p>The project is<a class="indexterm" id="id291"/> organized with the following structure:</p><div><img alt="Implementation" src="img/4852_06_04.jpg"/></div><p>There's nothing complex here; we will define our chain and make a call to the <code class="literal">main.swift</code> file. The abstract class is defined in the <code class="literal">Logger.swift</code> file, and our three <code class="literal">concreteHandlers</code> classes have their own respective Swift files.</p><p>We will define the abstract class as follows:</p><div><pre class="programlisting">class Logger {
  static var ERROR = 1
  static var INFO = 2
  static var DEBUG = 3
  
  var mask:Int?
  var next:Logger?
  
  func nextHandler(nextLogger:Logger) -&gt; Logger? {
    next = nextLogger
    return next
  }
  
  func message(message: String, priority: Int){
    if priority &lt;= mask {
      writeMessage(message)
      if let next = next {
        next.message(message, priority: priority)
      }
    }
  }
  
  func writeMessage(message: String) {
    preconditionFailure("Must be overridden")
  }

  static func prepareDefaultChain() -&gt; Logger? {
    var l: Logger?
    var l1: Logger?
    
    l = StdOutLogger(mask: Logger.DEBUG)
    l1 = l!.nextHandler(EmailLogger(mask: Logger.INFO))
    l1 = l1!.nextHandler(ErrLogger(mask: Logger.ERROR))
    return l
  }}</pre></div><p>We define three <a class="indexterm" id="id292"/>static variables that will represent our different levels of logs: <code class="literal">ERROR</code>, <code class="literal">INFO</code>, and <code class="literal">DEBUG</code>.</p><p>Then, we have two other variables that are declared, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mask</strong>: This variable <a class="indexterm" id="id293"/>is intrinsic to the object and will be set during the initialization of the handler. This variable will be used to compare its value against the level of the received request, which means that if the mask is less than or equal to the level, the object will be able to handle the request.</li><li class="listitem" style="list-style-type: disc"><strong>Next</strong>: This <a class="indexterm" id="id294"/>variable is also intrinsic to the object and this permits the chaining. This variable contains the next <code class="literal">ConcreteHandler</code> where the request will be passed.</li></ul></div><p>We have the following three functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func nextHandler(…)</code>: This is<a class="indexterm" id="id295"/> a function that allows you to assign the next concrete handler to the <code class="literal">next</code> variable. Note that this function returns a logger. This is called <code class="literal">nextLogger</code>.<p>So, if we write the following statement:</p><div><pre class="programlisting">l = StdOutLogger(mask: Logger.DEBUG)
l1 = l!.nextHandler(EmailLogger(mask: Logger.INFO))</pre></div><p>Then, <code class="literal">l1</code> is an <code class="literal">EmailLogger</code> instance and not a <code class="literal">StdOutLogger</code>.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">func message(…)</code>: This <a class="indexterm" id="id296"/>is the main function that has the responsibility (or not) to process the request and/or pass it to the next object of the chain.</li><li class="listitem" style="list-style-type: disc"><code class="literal">writeMessage(…)</code>: This <a class="indexterm" id="id297"/>function is called by the <code class="literal">message(…)</code>function to simulate the work applied on the request. Here, we will only display a message that is linked to the current concrete handler object. Since we are in an abstract class, we add a <code class="literal">preconditionfailure(…)</code> statement that will inform us that <code class="literal">this</code> function must be overridden in the derived class. If the code is executed and the derived class does not override <code class="literal">this</code> method, a fatal error will be raised, which is explained in the <em>Implementation</em> section of this pattern.</li><li class="listitem" style="list-style-type: disc"><code class="literal">prepareDefaultChain(…)</code>: This <a class="indexterm" id="id298"/>is a class function that encapsulates the creation of our default chain.</li></ul></div><p>Our abstract <a class="indexterm" id="id299"/>class is now ready; we have only to write our derived classes. Remember that the <code class="literal">writeMessage(…)</code> function must be overridden, and we need to initialize the mask of our concrete handler.</p><p>First, let's take a look at the <code class="literal">StdOutLogger</code> concrete handler, which is as follows:</p><div><pre class="programlisting">class StdOutLogger: Logger {
  init(mask: Int) {
    super.init()
    self.mask = mask
  }
  
  override func writeMessage(message: String) {
    print("Sending to StdOutLogger: \(message)")
  }
}</pre></div><p>Next, we have the <code class="literal">EmailLogger</code> class:</p><div><pre class="programlisting">class EmailLogger: Logger {
  init(mask: Int) {
    super.init()
    self.mask = mask
  }
  
  override func writeMessage(message: String) {
    print("Sending by Email: \(message)")
  }
}</pre></div><p>In addition, we have the <code class="literal">ErrLogger</code> class:</p><div><pre class="programlisting">class ErrLogger: Logger {
  init(mask: Int) {
    super.init()
    self.mask = mask
  }
  
  override func writeMessage(message: String) {
    print("Sending to ErrorLogger: \(message)")
  }
}</pre></div><p>All of our concrete<a class="indexterm" id="id300"/> handlers are now ready. It is time for us to write our test in the <code class="literal">main.swift</code> file.</p><p>We first prepare our chain using the <code class="literal">Logger</code> class function, <code class="literal">prepareDefaultChain</code>:</p><div><pre class="programlisting">print("Building the Chain")
var l: Logger?

l = Logger.prepareDefaultChain()</pre></div><p>Then, we send a request (a string message with a logger type) to the first object of the chain (<code class="literal">l</code> is <code class="literal">StdOutLogger</code>):</p><div><pre class="programlisting">print("- *** stdOutLogger:")
// Handled by StdOutLogger
l?.message("Entering the func Y()", priority: Logger.DEBUG)

print("- StdOutLogger &amp;&amp; EmailLogger:")
// Handled by StdOutLogger &amp;&amp; EmailLogger
l?.message("Step 1 Completed", priority: Logger.INFO)


print("- all three loggers:")
// Handled by all Logger
l?.message("An error occurred", priority: Logger.ERR)</pre></div><p>Now, we will build and run the project. You will see the following result on the console:</p><div><img alt="Implementation" src="img/4852_06_05.jpg"/></div><p>The console <a class="indexterm" id="id301"/>output is very clear. The first handler has handled the first request only, and the second request has been handled by the <code class="literal">StdOutLogger</code> class and the <code class="literal">EmailLogger</code> class. The third request has been handled by all three handlers.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec30"/>The command pattern</h1></div></div></div><p>The <a class="indexterm" id="id302"/>concept behind this pattern is to transform <a class="indexterm" id="id303"/>a request into an object in order to facilitate some actions, such as undo/redo, insertion into a queue, or tracking of the request.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec114"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id304"/>command pattern creates distance between the client that requests an operation and the object that can perform it. The request is encapsulated into an object. This object contains a reference to the receiver who will effectively execute the operation.</p><p>The real operation is managed by the receiver and the command is like an order; it only contains a reference to the invoker, the object that will perform the action and an execute function will call the real operation on the worker.</p><p>This pattern allows the following <a class="indexterm" id="id305"/>features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sending requests to different receivers</li><li class="listitem" style="list-style-type: disc">Queuing, logging, and rejecting requests</li><li class="listitem" style="list-style-type: disc">Undoable actions (the <code class="literal">execute</code> method can memorize the state and allows you to go back to that state)</li><li class="listitem" style="list-style-type: disc">Encapsulate a request in an object</li><li class="listitem" style="list-style-type: disc">Allows <a class="indexterm" id="id306"/>the parameterization of clients with different requests</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec115"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id307"/> generic diagram class is represented as follows:</p><div><img alt="Design" src="img/B04852_06_06.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec116"/>Participants</h2></div></div></div><p>The classes<a class="indexterm" id="id308"/> participating in this pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Command</code>: This <a class="indexterm" id="id309"/>declares the interface for executing an operation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteCommand</code>: This<a class="indexterm" id="id310"/> implements the <code class="literal">Command</code> interface with the <code class="literal">execute</code> method by invoking the corresponding operations on <code class="literal">Receiver</code>. It defines a link between the <code class="literal">Receiver</code> class and the action.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Client</code>: This<a class="indexterm" id="id311"/> creates a <code class="literal">ConcreteCommand</code> object and sets its receiver.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Invoker</code>: This<a class="indexterm" id="id312"/> asks the command to carry out the request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Receiver</code>: This<a class="indexterm" id="id313"/> knows how to perform the operations.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec117"/>Collaboration</h2></div></div></div><p>The <a class="indexterm" id="id314"/>following sequence diagram defines the collaboration between all objects participating in the command pattern:</p><div><img alt="Collaboration" src="img/B04852_06_07.jpg"/></div><p>Let's discuss the preceding diagram in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The client asks for a command to be executed and specifies its receivers</li><li class="listitem" style="list-style-type: disc">The client then sends the command to the invoker that stores it (or places it in a queue system if some actions needs to be performed before execution of the command) in order to execute it later</li><li class="listitem" style="list-style-type: disc">The invoker is then called to launch the command by invoking the execute function on the appropriate command object</li><li class="listitem" style="list-style-type: disc">The concrete command asks the receiver to execute the appropriate operation</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec118"/>Illustration</h2></div></div></div><p>Imagine<a class="indexterm" id="id315"/> that your company is working on a new universal controller that can manage up to four commands. This controller has four slots where we can add two commands to each of them. Near each slot, we have two buttons: the "On" and "Off" buttons.</p><p>Your team has <a class="indexterm" id="id316"/>already two objects and their specifications that allow a remote control to manipulate them:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The objects that we will work with are a light and audio player</li><li class="listitem" style="list-style-type: disc">The light can only be turned on and off</li><li class="listitem" style="list-style-type: disc">The audio player can be turned on or off, and we can play or stop the music</li></ul></div><p>Your job is to conceptualize commands that will be stored in the universal remote controller.</p><p>When we press the on or off button of a slot, the appropriate command should be sent to the appropriate device (the audio player or the light).</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>In this example, we will not implement the undo/redo action. We will show you another pattern that is dedicated to this situation in the next chapter.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec119"/>Implementation</h2></div></div></div><p>Open <a class="indexterm" id="id317"/>the Xcode project called <code class="literal">CommandPattern.xcodeproj</code>. Here is the organization of our project:</p><div><img alt="Implementation" src="img/4852_06_08.jpg"/></div><p>The structure <a class="indexterm" id="id318"/>of our project reflects the class diagram that we have seen in the <em>Design</em> section of the command pattern:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have the <code class="literal">Invoker</code> folder that contains our <code class="literal">UniversalRemoteController</code> object</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Receiver</code> folder contains two devices that will be able to receive commands to execute the appropriate operation</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Interface</code> folder contains the definition of a command</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ConcreteCommand</code> folder contains all the commands that we want to use with our universal remote controller</li><li class="listitem" style="list-style-type: disc">Lastly, the <code class="literal">main.swift</code> file contains the code that will allow us to see the demo</li></ul></div><p>To implement this example, let's begin with defining our <code class="literal">Command</code> interface.</p><p>We only need an <code class="literal">execute()</code> method to execute the command:</p><div><pre class="programlisting">protocol ICommand {
  func execute()
}</pre></div><p>Before we write <a class="indexterm" id="id319"/>our concrete command objects, let's see how our <code class="literal">Light</code> and <code class="literal">AudioPlayer</code> objects are implemented:</p><div><pre class="programlisting">class Light {
  
  func on() {
    print("Light is On")
  }
  
  func off() {
    print("Light is Off")
  }
}</pre></div><p>It is quite simple; the <code class="literal">on()</code> function will turn on the light and the <code class="literal">off()</code> function will turn it off.</p><p>Now, let's define the <code class="literal">AudioPlayer</code> class:</p><div><pre class="programlisting">class AudioPlayer {
  
  enum AudioPlayerState {
    case On
    case Off
    case Playing
  }
  
  private var state = AudioPlayerState.Off
  
  func on() {
    state = AudioPlayerState.On
    print("Audio Player is On")
  }
  
  func off() {
    state = AudioPlayerState.Off
    print("Audio Player is Off")
  }
  
  func playCD(){
    if state == AudioPlayerState.Off {
      print("doesn't work : the audio player is currently off")
    } else {
      state = AudioPlayerState.Playing
      print("AudioPlayer is playing")
    }
  }

  func stopCD(){
    if state == AudioPlayerState.Off {
      print("doesn't work : the audio player is currently off")
    }
    if state == AudioPlayerState.On {
      print("doesn't work : the audio player currently doesn't play music")
    } else {
      state = AudioPlayerState.On
      print("AudioPlayer has stopped to play music")
    }
  }
}</pre></div><p>This object is <a class="indexterm" id="id320"/>more complex. We have the same <code class="literal">on()</code> and <code class="literal">off()</code>methods, but we also have the <code class="literal">playCD()</code> and <code class="literal">StopCD()</code> methods.</p><p>We see that this object has an internal state. The state changes depending on the function called and the state is also used to control if the asked function is possible.</p><p>Now that we have all the necessary information, we can start writing our commands.</p><p>Let's begin with the light. What we want is to be able to use our universal remote controller to turn a light on or off, depending on the button pushed near the slot.</p><p>Therefore, we can first write our <code class="literal">LightOnCommand</code> concrete command object:</p><div><pre class="programlisting">class LightOnCommand: ICommand {
  
  var light:Light
  
  init(light: Light) {
    self.light = light
  }
  
  func execute() {
    self.light.on()
  }
}</pre></div><p>Here, we created an object called <code class="literal">LightOnCommand</code> that implements the <code class="literal">ICommand</code> interface.</p><p>The command needs to know what the receiver object is, so we pass an argument to it during the initialization of the object:</p><div><pre class="programlisting">
<strong>  init(light: Light) {</strong>
    self.light = light
  }</pre></div><p>Then, the <code class="literal">execute</code> method <a class="indexterm" id="id321"/>encapsulates the call to the <code class="literal">on()</code> function of the <code class="literal">Light</code> object to effectively process the command.</p><p>That's all; your <code class="literal">LightOnCommand</code> object is now ready.</p><p>We do the same with the <code class="literal">LightOffCommand</code> class and make changes wherever it is appropriate in order to use the <code class="literal">off()</code> function of the <code class="literal">Light</code> object instead of <code class="literal">on()</code>:</p><div><pre class="programlisting">class LightOffCommand: ICommand {
  
  var light:Light
  
  init(light: Light) {
    self.light = light
  }
  
  func execute() {
    self.light.off()
  }
}</pre></div><p>Our commands to control lights are both ready. Let's now see what we will do for the audio player. What we want is to be able to turn on or off the audio player, play, or stop music. These commands are similar to what we have already done with the light.</p><p>The <a class="indexterm" id="id322"/>
<code class="literal">AudioPlayerOnCommand</code> class is written as follows:</p><div><pre class="programlisting">class AudioPlayerOnCommand: ICommand {
  var audioPlayer:AudioPlayer
  
  init(audioPlayer:AudioPlayer) {
    self.audioPlayer = audioPlayer
  }
  
  func execute() {
    audioPlayer.on()
  }
} </pre></div><p>The <a class="indexterm" id="id323"/>
<code class="literal">AudioPlayerOffCommand</code> class is written as follows:</p><div><pre class="programlisting">class AudioPlayerOffCommand: ICommand {
  var audioPlayer:AudioPlayer
  
  init(audioPlayer:AudioPlayer) {
    self.audioPlayer = audioPlayer
  }
  
  func execute() {
    audioPlayer.off()
  }
}</pre></div><p>The <a class="indexterm" id="id324"/>
<code class="literal">AudioPlayerPlayCdCommand</code> class is <a class="indexterm" id="id325"/>written as follows:</p><div><pre class="programlisting">class AudioPlayerPlayCDCommand: ICommand {
  var audioPlayer:AudioPlayer
  
  init(audioPlayer:AudioPlayer) {
    self.audioPlayer = audioPlayer
  }
  
  func execute() {
    audioPlayer.playCD()
  }
}</pre></div><p>The <a class="indexterm" id="id326"/>
<code class="literal">AudioPlayerStopCDCommand</code> class is written as follows:</p><div><pre class="programlisting">class AudioPlayerStopCDCommand: ICommand {
  var audioPlayer:AudioPlayer
  
  init(audioPlayer:AudioPlayer) {
    self.audioPlayer = audioPlayer
  }
  
  func execute() {
    audioPlayer.stopCD()
  }
}</pre></div><p>At this point, all the commands needed are written.</p><p>We want to use our remote controller that has only four slots, as shown in the following diagram. With the remote controller, we want to be able to manipulate two lights: one in the bedroom, one in the hall, and an audio player to play and stop music:</p><div><img alt="Implementation" src="img/4852_06_10.jpg"/></div><p>Why not create a command that will turn on the audio player and play the music in the same command object? Indeed, using our remote controller to execute only the on or off command is useless. What we want is to play or stop the music.</p><p>Imagine that <a class="indexterm" id="id327"/>you want to be able to turn on the audio player and play the CD only by pressing one button; in the same way, you want to be able to stop the CD player and turn off the audio player only by pressing one button.</p><p>To implement this, we only have to encapsulate appropriate functions of the audio player object on the execute function of the command. When our remote controller will invoke the <code class="literal">execute</code> method, we will first call the <code class="literal">on</code> function of the <code class="literal">audioPlayer</code> class and then the <code class="literal">playCD()</code> function:</p><div><pre class="programlisting">class AudioPlayerSetOnAndPlayCommand: ICommand {
  var audioPlayer:AudioPlayer
  
  init(audioPlayer:AudioPlayer) {
    self.audioPlayer = audioPlayer
  }
  
  func execute() {
    audioPlayer.on()
    audioPlayer.playCD()
  }
  
}</pre></div><p>Similarly, we proceed with our <code class="literal">StopMusicAndSetOff</code> command:</p><div><pre class="programlisting">class AudioPlayerStopMusicAndSetOff: ICommand {
  var audioPlayer:AudioPlayer
  
  init(audioPlayer:AudioPlayer) {
    self.audioPlayer = audioPlayer
  }
  
  func execute() {
    audioPlayer.stopCD()
    audioPlayer.off()
  }
  
}</pre></div><p>Our devices are <a class="indexterm" id="id328"/>ready to accept commands and command objects are ready. Before we start writing our demo code, let's see how the remote controller works:</p><div><pre class="programlisting">class UniversalRemoteControl {
  var onCommands = [ICommand]()
  var offCommands = [ICommand]()
  
  init() {
    for _ in 1...4 {
      onCommands.append(NoCommand())
      offCommands.append(NoCommand())
    }
  }
  
  func addCommandToSlot(slot:Int, onCommand:ICommand, offCommand:ICommand) {
    onCommands[slot] = onCommand
    offCommands[slot] = offCommand
  }
  
  func buttonOnIsPushedOnSlot(slot:Int) {
    onCommands[slot].execute()
  }
  
  func buttonOffIsPushedOnSlot(slot:Int) {
    offCommands[slot].execute()
  }
}</pre></div><p>When the remote controller is initialized, the four slots have a <code class="literal">NoCommand</code> object that is assigned. This object is as follows:</p><div><pre class="programlisting">class NoCommand: ICommand {
  
  func execute() {
    print("No command associated to this")
  }
}</pre></div><p>So, if we do not <a class="indexterm" id="id329"/>use the <code class="literal">addCommandToSlot(…)</code> function, each button will call the <code class="literal">execute</code> function of the <code class="literal">NoCommand</code> object, which means that there is nothing to do.</p><p>The remote controller has two buttons near each slot. Depending on the button and slot, <code class="literal">buttonOnIsPushedOnSlot(…)</code> or <code class="literal">buttonOffIsPushedOnSlot</code> is called.</p><p>As commands are stored in the <code class="literal">onCommands</code> and <code class="literal">offCommands</code> arrays, when <code class="literal">addCommandToSlot</code> is called, we call the <code class="literal">execute</code> command of the appropriate object. To execute the on command of a slot, we will run the following code:</p><div><pre class="programlisting">    onCommands[slot].execute()</pre></div><p>To execute the off command of the same slot we will also run the following code:</p><div><pre class="programlisting">    offCommands[slot].execute()</pre></div><p>Here, <code class="literal">slot</code> is the index of the button slot. Now, it is time to implement our demo code.</p><p>First, we initialize our remote controller, create our <code class="literal">audioPlayer</code>, and create our two lights: the bedroom light and hall light:</p><div><pre class="programlisting">let uRemoteControl = UniversalRemoteControl()

let audioPlayerLivingRoom = AudioPlayer()
let lightBedroom = Light()
let lightHall = Light()</pre></div><p>Then, we create all our command objects:</p><div><pre class="programlisting">// MARK: Definition of our commands
let bedroomLightOnCommand = LightOnCommand(light: lightBedroom)
let bedroomLightOffCommand = LightOffCommand(light: lightBedroom)

let hallLightOnCommand = LightOnCommand(light: lightHall)
let hallLightOffCommand = LightOffCommand(light: lightHall)

let audioPlayerLivingRoomOnCommand = AudioPlayerOnCommand(audioPlayer: audioPlayerLivingRoom)
let audioPlayerLivingRoomOffCommand = AudioPlayerOffCommand(audioPlayer: audioPlayerLivingRoom)

let audioPlayerOnAndPlayLivingRoom = AudioPlayerSetOnAndPlayCommand(audioPlayer: audioPlayerLivingRoom)
let audioPlayerStopAndOffLivingRoom = AudioPlayerStopMusicAndSetOff(audioPlayer: audioPlayerLivingRoom)</pre></div><p>Once our<a class="indexterm" id="id330"/> commands are ready, we can assign them to the remote controller using the <code class="literal">addCommandToSlot</code> function:</p><div><pre class="programlisting">// Mark: Assign commands to the remote controller
uRemoteControl.addCommandToSlot(0, onCommand: bedroomLightOnCommand, offCommand: bedroomLightOffCommand)
uRemoteControl.addCommandToSlot(1, onCommand: hallLightOnCommand, offCommand: hallLightOffCommand)

uRemoteControl.addCommandToSlot(2, onCommand: audioPlayerLivingRoomOnCommand, offCommand: audioPlayerLivingRoomOffCommand)
uRemoteControl.addCommandToSlot(3, onCommand: audioPlayerOnAndPlayLivingRoom, offCommand: audioPlayerStopAndOffLivingRoom)</pre></div><p>The last thing that is needed for the demo is to simulate the press on each button:</p><div><pre class="programlisting">// Mark: Usage of the remote controller
uRemoteControl.buttonOnIsPushedOnSlot(0)
uRemoteControl.buttonOffIsPushedOnSlot(0)

uRemoteControl.buttonOnIsPushedOnSlot(1)
uRemoteControl.buttonOffIsPushedOnSlot(1)

uRemoteControl.buttonOnIsPushedOnSlot(2)
uRemoteControl.buttonOffIsPushedOnSlot(2)

uRemoteControl.buttonOnIsPushedOnSlot(3)
uRemoteControl.buttonOffIsPushedOnSlot(3)</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Here, note that we have not added the concurrency protection. If the command is used by several components, we should make sure that the concurrency protection is added.</p><p>For this, we need to create a queue that will receive all the commands, execute them in a synchronous way, and have the first command receive in the queue, being the first command executed (first in first out). To see how to implement concurrency protection, you can check the implementation of the mediator pattern in <a class="link" href="ch07.html" title="Chapter 7. Behavioral Patterns – Iterator, Mediator, and Observer">Chapter 7</a>, <em>Behavioral Patterns – Iterator, Mediator, and Observer </em>and the note about concurrency protection available in the same chapter.</p></div></div><p>Click on build and run the demo.</p><p>You will now see the following result on the console, corresponding to each button pressed on the <a class="indexterm" id="id331"/>universal remote controller:</p><div><img alt="Implementation" src="img/4852_06_09.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Comparison between the chain of responsibility and command patterns</h1></div></div></div><p>The <a class="indexterm" id="id332"/>difference between the two patterns is the way in which the request is decoupled.</p><p>In the chain of responsibility pattern, the request is passed to potential receivers, whereas the command pattern uses a command object that encapsulates a request.</p><p>The following table describes the difference between the chain of responsibility and command patterns:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Chain of responsibility</p>
</th><th style="text-align: left" valign="bottom">
<p>Command</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Client creates</p>
</td><td style="text-align: left" valign="top">
<p>Handler objects</p>
</td><td style="text-align: left" valign="top">
<p>Command objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Different kinds of</p>
</td><td style="text-align: left" valign="top">
<p>Handler classes at different levels</p>
</td><td style="text-align: left" valign="top">
<p>Command classes and receiver classes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Client can work with</p>
</td><td style="text-align: left" valign="top">
<p>Multiple handlers</p>
</td><td style="text-align: left" valign="top">
<p>Different receivers</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Client calls</p>
</td><td style="text-align: left" valign="top">
<p>Handler objects</p>
</td><td style="text-align: left" valign="top">
<p>Receiver objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Work is done in</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">HandleRequest</code> in a handler</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ActionToPerform</code> in a receiver</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Decision based on</p>
</td><td style="text-align: left" valign="top">
<p>Mask in handlers</p>
</td><td style="text-align: left" valign="top">
<p>Routing in commands</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Summary</h1></div></div></div><p>I hope this chapter was interesting. In this chapter, we learned how to decouple senders and receivers in both the chain of responsibility and command patterns, thus improving the layering and reusability of a system.</p><p>In the next chapter, we will explore three new patterns: the iterator, mediator, and observer patterns that are dedicated to the communication between objects while maintaining their independence.</p></div></body></html>