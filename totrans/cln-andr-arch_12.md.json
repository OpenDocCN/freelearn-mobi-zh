["```kt\nclass MyViewModel @Inject constructor(\n    private val getMyDataUseCase: GetMyDataUseCase\n) : ViewModel() {\n    private val _myDataFlow =\n        MutableStateFlow<MyData>(MyData())\n    val myDataFlow: StateFlow<MyData> = _myDataFlow\n    var text: String = \"\"\n    fun loadMyData() {\n        viewModelScope.launch {\n            getMyDataUseCase.execute\n                (GetPostsWithUsersWithInteractionUseCase.\n                    Request)\n                .collect {\n                    _myDataFlow.value = it\n                }\n        }\n    }\n}\n```", "```kt\ndata class MyState(\n        val myData: MyData = MyData(),\n        val text: String = \"\"\n)\n```", "```kt\n    sealed class MyAction {\n        object LoadAction : MyAction()\n        data class UpdateAction(val text: String) : \n            MyAction()\n    }\n```", "```kt\n    private val _myStateFlow = MutableStateFlow<MyState>\n        (MyState())\n    val myStateFlow: StateFlow<MyState> = _myDataFlow\n    private val _actionFlow: MutableSharedFlow<MyAction> = \n        MutableSharedFlow()\n```", "```kt\nclass MyViewModel @Inject constructor(\n    private val getMyDataUseCase: GetMyDataUseCase\n) : ViewModel() {\n    …\n    init {\n        viewModelScope.launch {\n            action.collect { action ->\n                when (action) {\n                    is MyViewModel.MyAction.LoadAction -> {\n                        loadMyData()\n                    }\n                    is MyViewModel.MyAction.UpdateAction -> {\n                        _myDataFlow.emit(_myDataFlow.value.copy(text = \n    action.text))\n                    }\n                }\n            }\n        }\n    }\n    fun submitAction(action: MyAction) {\n        viewModelScope.launch {\n            _action.emit(action)\n        }\n    }\n    private fun loadMyData() {\n        getMyDataUseCase.execute\n            (GetPostsWithUsersWithInteractionUseCase.\n                Request)\n            .collect {\n                _myDataFlow.value = it\n            }\n    }\n    …\n}\n```", "```kt\n    private val _myStateFlow = MutableStateFlow<MyState>(MyState())\n    val myStateFlow: StateFlow<MyState> = _myDataFlow\n    private val actionFlow: MutableSharedFlow<MyAction> = MutableSharedFlow()\n```", "```kt\nclass MyViewModel @Inject constructor(\n    private val getMyDataUseCase: GetMyDataUseCase\n) : ViewModel() {\n    …\n    private val _myStateFlow = MutableStateFlow<MyState>\n        (MyState())\n    val myStateFlow: StateFlow<MyState> = _myDataFlow\n    private val actionFlow: MutableSharedFlow<MyAction> = \n        MutableSharedFlow()\n    private val _myOneOffFlow = Channel<MyOneOffEvent>()\n    val myOneOffFlow = _myOneOffFlow.receiveAsFlow()\n    … \n}\n```", "```kt\ninterface UiState\ninterface UiAction\ninterface UiSingleEvent\n```", "```kt\nabstract class MviViewModel<S : UiState, A : UiAction, E : UiSingleEvent> : ViewModel() {\n    private val _uiStateFlow: MutableStateFlow<S> by lazy {\n        MutableStateFlow(initState())\n    }\n    val uiStateFlow: StateFlow<S> = _uiStateFlow\n    private val actionFlow: MutableSharedFlow<A> = \n        MutableSharedFlow()\n    private val _singleEventFlow = Channel<E>()\n    val singleEventFlow = _singleEventFlow.receiveAsFlow()\n    …\n}\n```", "```kt\nabstract class MviViewModel<S : UiState, A : UiAction, E : UiSingleEvent> : ViewModel() {\n    …\n    init {\n        viewModelScope.launch {\n            actionFlow.collect {\n                handleAction(it)\n            }\n        }\n    }\n    abstract fun initState(): S\n    abstract fun handleAction(action: A)\n}\n```", "```kt\nabstract class MviViewModel<S : UiState, A : UiAction, E : \n    UiSingleEvent> : ViewModel() {\n    …\n    fun submitAction(action: A) {\n        viewModelScope.launch {\n            actionFlow.emit(action)\n        }\n    }\n    fun submitState(state: S) {\n        viewModelScope.launch {\n            _uiStateFlow.value = state\n        }\n    }\n    fun submitSingleEvent(event: E) {\n        viewModelScope.launch {\n            _singleEventFlow.send(event)\n        }\n    }\n}\n```", "```kt\nsealed class MyUiState : UiState {\n    data class Success(val myData: MyData) : MyUiState()\n    object Error : MyUiState()\n    object Loading : MyUiState()\n}\n```", "```kt\nsealed class MyUiAction : UiAction {\n    object Load : MyUiAction()\n    object Click : MyUiAction()\n}\n```", "```kt\nsealed class MyUiSingleEvent : UiSingleEvent {\n    data class ShowToast(val text: String) : \n        MyUiSingleEvent()\n}\n```", "```kt\nclass MyViewModel : MviViewModel<MyUiState, MyUiAction, \n    MyUiSingleEvent>() {\n    override fun initState(): MyUiState = MyUiState.Loading\n    override fun handleAction(action: MyUiAction) {\n        when (action) {\n            is MyUiAction.Load -> {\n                viewModelScope.launch {\n                    val state: UiState = // Fetch UI state\n                    submitState(state)\n                }\n            }\n            is MyUiAction.Click -> {\n                // Handle logic for clicks\n                submitSingleEvent(MyUiSingleEvent.\n                    ShowToast(\"Toast\"))\n            }\n        }\n    }\n}\n```", "```kt\n@Composable\nfun MyScreen(\n    viewModel: MyViewModel\n) {\n    viewModel.submitAction(MyUiAction.Load)\n    viewModel.uiStateFlow.collectAsState().value.let { \n        state ->\n        when (state) {\n            is MyUiState.Loading -> {\n            }\n            is MyUiState.Success -> {\n                MySuccessScreen(state.myData) {\n                    viewModel.submitAction(MyUiAction.\n                        Click)\n                }\n            }\n            is MyUiState.Error -> {\n            }\n        }\n    }\n}\n```", "```kt\n@Composable\nfun MyScreen(\n    viewModel: MyViewModel\n) {\n    …\n    LaunchedEffect(Unit, {\n        viewModel.singleEventFlow.collectLatest {\n            when (it) {\n                is MyUiSingleEvent.ShowToast -> {\n                    // Show Toast\n                }\n            }\n        }\n    })\n}\n```", "```kt\n@Composable\nfun MyScreen(\n    viewModel: MyViewModel\n) {\n    LaunchedEffect(Unit, {\n        viewModel.submitAction(MyUiAction.Load)\n    }\n}\n```", "```kt\n    interface UiAction\n    ```", "```kt\n    interface UiSingleEvent\n    ```", "```kt\n    abstract class MviViewModel<T : Any, S : UiState<T>, A : UiAction, E : UiSingleEvent> : ViewModel() {\n    }\n    ```", "```kt\n    abstract class MviViewModel<T : Any, S : UiState<T>, A : UiAction, E : UiSingleEvent> : ViewModel() {\n        private val _uiStateFlow: MutableStateFlow<S> by \n            lazy {\n            MutableStateFlow(initState())\n        }\n        val uiStateFlow: StateFlow<S> = _uiStateFlow\n        private val actionFlow: MutableSharedFlow<A> = \n            MutableSharedFlow()\n        private val _singleEventFlow = Channel<E>()\n        val singleEventFlow = _singleEventFlow.\n            receiveAsFlow()\n    }\n    ```", "```kt\n    abstract class MviViewModel<T : Any, S : UiState<T>, A : UiAction, E : UiSingleEvent> : ViewModel() {\n        …\n        init {\n            viewModelScope.launch {\n                actionFlow.collect {\n                    handleAction(it)\n                }\n            }\n        }\n        abstract fun initState(): S\n        abstract fun handleAction(action: A)\n    }\n    ```", "```kt\n    abstract class MviViewModel<T : Any, S : UiState<T>, A : UiAction, E : UiSingleEvent> : ViewModel() {\n        …\n        fun submitAction(action: A) {\n            viewModelScope.launch {\n                actionFlow.emit(action)\n            }\n        }\n        fun submitState(state: S) {\n            viewModelScope.launch {\n                _uiStateFlow.value = state\n            }\n        }\n        fun submitSingleEvent(event: E) {\n            viewModelScope.launch {\n                _singleEventFlow.send(event)\n            }\n        }\n    }\n    ```", "```kt\n    sealed class PostListUiAction : UiAction {\n        object Load : PostListUiAction()\n        data class UserClick(val userId: Long, val \n            interaction: Interaction) : PostListUiAction()\n        data class PostClick(val postId: Long, val \n            interaction: Interaction) : PostListUiAction()\n    }\n    ```", "```kt\n    sealed class PostListUiSingleEvent : UiSingleEvent {\n        data class OpenUserScreen(val navRoute: String) : \n            PostListUiSingleEvent()\n        data class OpenPostScreen(val navRoute: String) : \n            PostListUiSingleEvent()\n    }\n    ```", "```kt\n    @HiltViewModel\n    class PostListViewModel @Inject constructor(\n        private val useCase: \n            GetPostsWithUsersWithInteractionUseCase,\n        private val converter: PostListConverter,\n        private val updateInteractionUseCase: \n            UpdateInteractionUseCase\n    ) : MviViewModel<PostListModel, UiState<PostListModel>\n    , PostListUiAction, PostListUiSingleEvent>() {\n         …\n    }\n    ```", "```kt\n    @HiltViewModel\n    class PostListViewModel @Inject constructor(\n        …\n    ) : MviViewModel<PostListModel, UiState<PostListModel>\n        , PostListUiAction, PostListUiSingleEvent>() {\n        override fun initState(): UiState<PostListModel> = \n            UiState.Loading\n    }\n    ```", "```kt\n    @HiltViewModel\n    class PostListViewModel @Inject constructor(\n        …\n    ) : MviViewModel<PostListModel, UiState<PostListModel>\n        , PostListUiAction, PostListUiSingleEvent>() {\n        …\n        override fun handleAction(action: \n            PostListUiAction) {\n            when (action) {\n                is PostListUiAction.Load -> {\n                    loadPosts()\n                }\n                is PostListUiAction.PostClick -> {\n                    updateInteraction(action.interaction)\n                    submitSingleEvent(\n                        PostListUiSingleEvent.\n                            OpenPostScreen(\n                            NavRoutes.Post.routeForPost(\n                                PostInput(action.postId)\n                            )\n                        )\n                    )\n                }\n                is PostListUiAction.UserClick -> {\n                    updateInteraction(action.interaction)\n                    submitSingleEvent(\n                        PostListUiSingleEvent.\n                            OpenUserScreen(\n                            NavRoutes.User.routeForUser(\n                                UserInput(action.userId)\n                            )\n                        )\n                    )\n                }\n            }\n        }\n    }\n    ```", "```kt\n    @HiltViewModel\n    class PostListViewModel @Inject constructor(\n        …\n    ) : MviViewModel<PostListModel, UiState<PostListModel>\n        , PostListUiAction, PostListUiSingleEvent>() {\n        …\n        private fun loadPosts() {\n            viewModelScope.launch {\n                useCase.execute\n                (GetPostsWithUsersWithInteractionUseCase.\n                Request)\n                    .map {\n                        converter.convert(it)\n                    }\n                    .collect {\n                        submitState(it)\n                    }\n            }\n        }\n    }\n    ```", "```kt\n    @HiltViewModel\n    class PostListViewModel @Inject constructor(\n        …\n    ) : MviViewModel<PostListModel, UiState<PostListModel>\n        , PostListUiAction, PostListUiSingleEvent>() {\n        …\n        private fun updateInteraction(interaction: \n            Interaction) {\n            viewModelScope.launch {\n                updateInteractionUseCase.execute(\n                    UpdateInteractionUseCase.Request(\n                        interaction.copy(\n                            totalClicks = interaction.\n                                totalClicks + 1\n                        )\n                    )\n                ).collect()\n            }\n        }\n    }\n    ```", "```kt\n    @Composable\n    fun PostListScreen(\n        viewModel: PostListViewModel,\n        navController: NavController\n    ) {\n        LaunchedEffect(Unit) {\n            viewModel.submitAction(PostListUiAction.Load)\n        }\n        viewModel.uiStateFlow.collectAsState().value.let { \n            state ->\n            CommonScreen(state = state) {\n                PostList(it, { postListItem ->\n                    viewModel.submitAction\n                        (PostListUiAction.PostClick\n                        (postListItem.id, it.interaction))\n                }) { postListItem ->\n                    viewModel.submitAction\n                        (PostListUiAction.UserClick\n                        (postListItem.id, it.interaction))\n                }\n            }\n        }\n    }\n    ```", "```kt\n    @Composable\n    fun PostListScreen(\n        viewModel: PostListViewModel,\n        navController: NavController\n    ) {\n        …\n        LaunchedEffect(Unit) {\n            viewModel.singleEventFlow.collectLatest {\n                when (it) {\n                    is PostListUiSingleEvent.\n                        OpenPostScreen -> {    navController.navigate\n                        (it.navRoute)\n                    }\n                    is PostListUiSingleEvent.\n                        OpenUserScreen -> {\n                        navController.navigate\n                        (it.navRoute)\n                    }\n                }\n            }\n        }\n    }\n    ```", "```kt\n    sealed class PostUiAction : UiAction {\n        data class Load(val postId: Long) : PostUiAction()\n    }\n    ```", "```kt\n    @HiltViewModel\n    class PostViewModel @Inject constructor(\n        private val postUseCase: GetPostUseCase,\n        private val postConverter: PostConverter\n    ) : MviViewModel<PostModel, UiState<PostModel>, \n        PostUiAction, UiSingleEvent>() {\n    }\n    ```", "```kt\n    @HiltViewModel\n    class PostViewModel @Inject constructor(\n        …\n    ) : MviViewModel<PostModel, UiState<PostModel>, \n        PostUiAction, UiSingleEvent>() {\n        override fun initState(): UiState<PostModel> = \n            UiState.Loading\n        override fun handleAction(action: PostUiAction) {\n            when (action) {\n                is PostUiAction.Load -> {\n                    loadPost(action.postId)\n                }\n            }\n        }\n        private fun loadPost(postId: Long) {\n            viewModelScope.launch {\n                postUseCase.execute\n                    (GetPostUseCase.Request(postId))\n                    .map {\n                        postConverter.convert(it)\n                    }\n                    .collect {\n                        submitState(it)\n                    }\n            }\n        }\n    }\n    ```", "```kt\n    @Composable\n    fun PostScreen(\n        viewModel: PostViewModel,\n        postInput: PostInput\n    ) {\n        viewModel.uiStateFlow.collectAsState().value.let {\n            result ->\n            CommonScreen(result) { postModel ->\n                Post(postModel)\n            }\n        }\n        LaunchedEffect(postInput.postId) {\n            viewModel.submitAction(PostUiAction.\n                Load(postInput.postId))\n        }\n    }\n    ```", "```kt\n    sealed class UserUiAction : UiAction {\n        data class Load(val userId: Long) : UserUiAction()\n    }\n    ```", "```kt\n    @HiltViewModel\n    class UserViewModel @Inject constructor(\n        private val userUseCase: GetUserUseCase,\n        private val converter: UserConverter\n    ) : MviViewModel<UserModel, UiState<UserModel>, \n        UserUiAction, UiSingleEvent>() {\n    }\n    ```", "```kt\n    @HiltViewModel\n    class UserViewModel @Inject constructor(\n        …\n    ) : MviViewModel<UserModel, UiState<UserModel>, \n        UserUiAction, UiSingleEvent>() {\n        override fun initState(): UiState<UserModel> = \n            UiState.Loading\n        override fun handleAction(action: UserUiAction) {\n            when (action) {\n                is UserUiAction.Load -> {\n                    loadUser(action.userId)\n                }\n            }\n        }\n        private fun loadUser(userId: Long) {\n            viewModelScope.launch {\n                userUseCase.execute\n                    (GetUserUseCase.Request(userId))\n                    .map {\n                        converter.convert(it)\n                    }\n                    .collect {\n                        submitState(it)\n                    }\n            }\n        }\n    }\n    ```", "```kt\n    @Composable\n    fun UserScreen(\n        viewModel: UserViewModel,\n        userInput: UserInput\n    ) {\n        viewModel.uiStateFlow.collectAsState().value.let { \n            result ->\n            CommonScreen(result) { userModel ->\n                User(userModel)\n            }\n        }\n        LaunchedEffect(userInput.userId) {\n            viewModel.submitAction(UserUiAction.\n                Load(userInput.userId))\n        }\n    }\n    ```"]