<html><head></head><body>
        

                            
                    <h1 class="header-title">Menus and Action Mode</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating an options menu</li>
<li>Modifying menus and menu items during runtime</li>
<li>Enabling Contextual Action Mode for a view</li>
<li>Using Contextual Batch Mode with <kbd>RecyclerView</kbd></li>
<li>Creating a pop-up menu</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>The Android OS is an ever-changing environment. The earliest Android devices (prior to Android 3.0), were required to have a hardware menu button. Though a hardware button is no longer required, menus are no less important. In fact, the Menu API has expanded to now support three different types of menus:</p>
<ul>
<li><strong>Options menu and action bar</strong>: This is the standard menu, which is used for global options of your application. Use this for additional features such as search, settings, and so on.</li>
<li><strong>Contextual</strong><strong>Mode</strong> (<strong>Contextual Action Mode</strong>): This is generally activated by a long press. (Think of this as similar to a right-click on the desktop.) This is used to take an action on the pressed item, such as replying to an email or deleting a file.</li>
<li><strong>Pop-up m</strong><strong>enu</strong>: This provides a pop-up selection (like a spinner) for an additional action. The menu options are not meant to affect the item pressed; instead, use Contextual Mode as described previously. An example would be hitting the share button and getting an additional list of share options.</li>
</ul>
<p>Menu resources are similar to other Android UI components; they are generally created in XML, but can be created in code as well. Our first recipe, as shown in the following section, will show the XML menu format and how to inflate it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an options menu</h1>
                
            
            
                
<p>Before we actually create and display a menu, let's look at a menu to see the end result. The following is a screenshot showing the menu section of the Chrome app:</p>
<div><img src="img/04c89fb1-5c84-4baa-80dd-6559f969fbe7.png" style="width:35.58em;height:6.83em;"/></div>
<p>The most obvious feature to note is that the menu will look different based on the screen size. By default, menu items will be added to the overflow menu—that's the menu you see when you press the three dots at the far right edge.</p>
<p>Menus are typically created in resource files using XML (like many other Android resources) stored in the <kbd>res/menu</kbd> directory, though they can also be created in code. To create a menu resource, use the <kbd>&lt;menu&gt;</kbd> element as shown:</p>
<pre>&lt;menu &gt; 
&lt;/menu&gt; </pre>
<p>The <kbd>&lt;item&gt;</kbd> element defines each individual menu item and is enclosed in the <kbd>&lt;menu&gt;</kbd> element. A basic menu item looks as follows:</p>
<pre>&lt;item  
    android:id="@+id/settings" 
    android:title="@string/settings" /&gt; </pre>
<p>The most common <kbd>&lt;item&gt;</kbd> attributes are the following:</p>
<ul>
<li><kbd>id</kbd>: This is the standard resource identifier</li>
<li><kbd>title</kbd>: This indicates the text to display</li>
<li><kbd>icon</kbd>: This is a drawable resource</li>
<li><kbd>showAsAction</kbd>: This is explained in the following paragraph</li>
<li><kbd>enabled</kbd>: This is enabled by default</li>
</ul>
<p>Let's look at <kbd>showAsAction</kbd> in more detail.</p>
<p>The <kbd>showAsAction</kbd> attribute controls how the menu item is shown. The options include<br/>
the following:</p>
<ul>
<li><kbd>ifRoom</kbd>: This menu item should be included in the action bar if there's enough space</li>
<li><kbd>withText</kbd>: This indicates that both the title and the icon should be shown</li>
<li><kbd>never</kbd>: This indicates that the menu item should never be included in the action bar; it is always shown in the overflow menu</li>
<li><kbd>always</kbd>: This indicates that the menu item should be always included in the action bar (use sparingly as space is limited)</li>
</ul>
<p>Multiple options can be combined using the pipe (<kbd>|</kbd>) separator, such as <kbd>showAsAction="ifRoom|withText"</kbd>.</p>
<p>With the fundamentals of the menu resource covered, we are now ready to create a standard options menu and inflate it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Use Android Studio to create a new project called <kbd>OptionsMenu</kbd>. Use the default Phone &amp; Tablet option and select the Empty Activity option when prompted for the Activity Type. The Android Studio wizard does not create the <kbd>res/menu</kbd> folder by default. You can create it manually using File | New | Directory, or create it using the Android Resource Directory wizard.</p>
<p>Here are the steps to use the wizard:</p>
<ol>
<li>First, right-click on the <kbd>res</kbd> folder and select New | Android Resource Directory as shown here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2222d1e5-7528-4228-9a49-dfd8f015422d.png" style="width:44.58em;height:48.50em;"/></p>
<ol start="2">
<li>On the New Resource Directory dialog, select the Resource type drop-down menu and choose the menu option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ce9f1789-d9d2-43d9-a5a4-7f951d391464.png" style="width:45.83em;height:30.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>With the new project created as described in the preceding section, you are ready to create a menu. First, we will add a string resource to <kbd>strings.xml</kbd>. We will use the new string for the menu title when we create the XML for the menu. Here are the steps:</p>
<ol>
<li>Start by opening the <kbd>strings.xml</kbd> file and adding the following <kbd>&lt;string&gt;</kbd> element to the <kbd>&lt;resources&gt;</kbd> element:</li>
</ol>
<pre>    &lt;string name="menu_settings"&gt;Settings&lt;/string&gt; </pre>
<ol start="2">
<li>Create a new file in the <kbd>res/menu</kbd> directory and call it <kbd>menu_main.xml</kbd>.</li>
</ol>
<ol start="3">
<li>Open the <kbd>menu_main.xml</kbd> file and add the following XML to define the menu:</li>
</ol>
<pre>    &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    &lt;menu xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>        &lt;item android:id="@+id/menu_settings"<br/>            android:title="@string/menu_settings"<br/>            app:showAsAction="never"&gt;<br/>        &lt;/item&gt;<br/>    &lt;/menu&gt;</pre>
<ol start="4">
<li>With the menu now defined in the XML, we just have to override the <kbd>onCreateOptionsMenu()</kbd> method in <kbd>ActivityMain.java</kbd> to inflate the menu:</li>
</ol>
<pre>    @Override<br/>    public boolean onCreateOptionsMenu(Menu menu) {<br/>        getMenuInflater().inflate(R.menu.menu_main, menu);<br/>        return true;<br/>    }</pre>
<ol start="5">
<li>Run the program on a device or emulator to see the menu in the action bar.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>There are two basic steps here:</p>
<ol>
<li>Define the menu in XML</li>
<li>Inflate the menu when the activity is created</li>
</ol>
<p>As a good programming habit, we define the string in the <kbd>strings.xml</kbd> file rather than hard coding it in the XML. We then use the standard Android string identifier to set the title for the menu in step 3. Since this is a Settings menu item, we used the <kbd>showAsAction="never"</kbd> option so it wouldn't be shown as an individual menu option in the action bar. </p>
<p>With the menu defined, we will use the menu inflater in step 4 to load the menu during the activity creation. Notice the <kbd>R.menu.menu_main</kbd> menu resource syntax? This is why we create the XML in the <kbd>res/menu</kbd> directory—so the system will know this is a menu resource.</p>
<p>In step 4, we used <kbd>app:showAsAction</kbd> rather than Android: <kbd>android:showAsAction</kbd>. This is because we are using the <kbd>AppCompat</kbd> library (also referred to as the Android Support Library). By default, the Android Studio new project wizard includes the support library in the project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you ran the program in step 5, then you must have seen the Settings menu item when you pressed the menu overflow button. But that was it. Nothing else happened. Obviously, menu items aren't very useful if the application doesn't respond to them. Responding to the Options menu is done through the <kbd>onOptionsItemSelected()</kbd> callback.</p>
<p>Add the following method to the application to see a Toast when the Settings menu is selected:</p>
<pre>@Override<br/>public boolean onOptionsItemSelected(MenuItem item) {<br/>    if (item.getItemId() == R.id.menu_settings) {<br/>        Toast.makeText(this, "Settings", Toast.LENGTH_LONG).show();<br/>    } else {<br/>        return super.onContextItemSelected(item);<br/>    }<br/>    return true;<br/>}</pre>
<p>That's it. You now have a working menu!</p>
<p>As shown in the preceding example, return <kbd>true</kbd> when you've handled the callback; otherwise, call the super class as shown in the <kbd>else</kbd> statement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a menu item to launch an activity</h1>
                
            
            
                
<p>In the above example, we show a Toast in response to the menu click; however, we could just as easily launch a new activity if needed. To start an activity, create an Intent and call it with <kbd>startActivity()</kbd> as shown in the <em>Starting a new activity with an Intent object</em> recipe in <a href="ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml">Chapter 1</a>, <em>Activities.</em> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating submenus</h1>
                
            
            
                
<p><strong>Submenus</strong> are created and accessed in almost exactly the same manner as other menu elements. They can be placed in any of the provided menus but not within other submenus. To define a submenu, include a <kbd>&lt;menu&gt;</kbd> element within an <kbd>&lt;item&gt;</kbd> element. Here is the XML for this recipe with two submenu items added:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;menu 
     
    &gt; 
    &lt;item android:id="@+id/menu_settings 
        android:title="@string/menu_settings" 
        app:showAsAction="never"&gt; 
        &lt;menu&gt; 
            &lt;item android:id="@+id/menu_sub1" 
                android:title="Storage Settings" /&gt; 
            &lt;item android:id="@+id/menu_sub2" 
                android:title="Screen Settings" /&gt; 
        &lt;/menu&gt; 
    &lt;/item&gt; 
&lt;/menu&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Grouping menu items</h1>
                
            
            
                
<p>Another menu feature that Android supports is grouping menu items. Android provides several methods for groups, including the following:</p>
<ul>
<li><kbd>setGroupVisible()</kbd>: Show or hide all items</li>
<li><kbd>setGroupEnabled()</kbd>: Enable or disable all items</li>
<li><kbd>setGroupCheckable()</kbd>: Set the checkable behavior</li>
</ul>
<p>Android will keep all grouped items with <kbd>showAsAction="ifRoom"</kbd> together. This means all items in the group with <kbd>showAsAction="ifRoom"</kbd> will be in the action bar or all items will be in the overflow.</p>
<p>To create a group, add the <kbd>&lt;item&gt;</kbd> menu elements to a <kbd>&lt;group&gt;</kbd> element. Here is an example using the menu XML from this recipe with two additional items in a group:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>    &lt;group android:id="@+id/group_one" &gt;<br/>        &lt;item android:id="@+id/menu_item1"<br/>            android:title="Item 1"<br/>            app:showAsAction="ifRoom"/&gt;<br/>        &lt;item android:id="@+id/menu_item2"<br/>            android:title="Item 2"<br/>            app:showAsAction="ifRoom"/&gt;<br/>    &lt;/group&gt;<br/>    &lt;item android:id="@+id/menu_settings"<br/>        android:title="@string/menu_settings"<br/>        app:showAsAction="never"/&gt;<br/>&lt;/menu&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>For complete details on the menu, visit the Android Developer Menu Resources site at <a href="http://developer.android.com/guide/topics/resources/menu-resource.html">http://developer.android.com/guide/topics/resources/menu-resource.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying menus and menu items during runtime</h1>
                
            
            
                
<p>Though it's been stated many times it's considered the <em>best</em> programming practice to create UIs in XML rather than in Java, there are still times when using code is the better option. This is especially true if you wanted a menu item to be visible (or enabled) based on some external criteria. Menus can also be included in resource folders, but there are times when you need code to perform the logic of which resource to use. One example might be if you wanted to offer an upload menu item only if the user is logged in to your app.</p>
<p>In this recipe, we will create and modify the menu only through code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>RuntimeMenu</kbd> using the default Phone &amp; Tablet option. Select the Empty Activity option when prompted to add an activity. Since we will create and modify the menu completely in code, we will not need to create a<br/>
<kbd>res/menu</kbd> directory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To start, we will add string resources for our menu items and a button to toggle the menu visibility. Open the <kbd>res/strings.xml</kbd> file and follow these steps:</p>
<ol>
<li>Add the following two strings to the existing <kbd>&lt;resources&gt;</kbd> element:</li>
</ol>
<pre>    &lt;string name="menu_download"&gt;Download&lt;/string&gt; 
    &lt;string name="menu_settings"&gt;Settings&lt;/string&gt; </pre>
<ol start="2">
<li>Delete the existing <kbd>TextView</kbd> and add a button to <kbd>activity_main.xml</kbd> with <kbd>onClick()</kbd> set to <kbd>toggleMenu</kbd> as shown here:</li>
</ol>
<pre>    &lt;Button<br/>        android:id="@+id/buttonToggleMenu"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Toggle Menu"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="3">
<li>Open <kbd>ActivityMain.java</kbd> and add the following three lines of code just below the class declaration:</li>
</ol>
<pre>    private final int MENU_DOWNLOAD = 1; 
    private final int MENU_SETTINGS = 2; 
    private boolean showDownloadMenu = false; </pre>
<ol start="4">
<li>Add the following method for the button click callback:</li>
</ol>
<pre>    public void toggleMenu(View view) { 
        showDownloadMenu=!showDownloadMenu; 
    } </pre>
<ol start="5">
<li>When the activity is first created, Android calls <kbd>onCreateOptionsMenu()</kbd> to create the menu. Here is the code to dynamically build the menu:</li>
</ol>
<pre>    @Override<br/>    public boolean onCreateOptionsMenu(Menu menu) {<br/>        menu.add(0, MENU_DOWNLOAD, 0, R.string.menu_download);<br/>        menu.add(0, MENU_SETTINGS, 0, R.string.menu_settings);<br/>        return true;<br/>    }</pre>
<ol start="6">
<li>For best programming practice, don't use <kbd>onCreateOptionsMenu()</kbd> to update or change your menu; instead, use <kbd>onPrepareOptionsMenu()</kbd>. Here is the code to change the visibility of the Download menu item based on our flag:</li>
</ol>
<pre>    @Override 
    public boolean onPrepareOptionsMenu(Menu menu) { 
        MenuItem menuItem = menu.findItem(MENU_DOWNLOAD); 
        menuItem.setVisible(showDownloadMenu); 
        return true; 
    } </pre>
<ol start="7">
<li>Though not technically required for this recipe, this <kbd>onOptionsItemSelected()</kbd> code shows how to respond to each menu item:</li>
</ol>
<pre>    @Override<br/>    public boolean onOptionsItemSelected(MenuItem item) {<br/>        switch (item.getItemId()) {<br/>            case MENU_DOWNLOAD:<br/>                Toast.makeText(this, R.string.menu_download, <br/>                Toast.LENGTH_LONG).show();<br/>     <strong>    </strong>       break;<br/>            case MENU_SETTINGS:<br/>                Toast.makeText(this, R.string.menu_settings,     <br/>                Toast.LENGTH_LONG).show();<br/>                break;<br/>            default:<br/>                return super.onContextItemSelected(item);<br/>        }<br/>        return true;<br/>    }</pre>
<ol start="8">
<li>Run the program on a device or emulator to see the menu changes.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We created an override for <kbd>onCreateOptionsMenu()</kbd>, just like we did in the previous recipe, <em>Creating an options menu</em>. But instead of inflating an existing menu resource, we created the menu using the <kbd>Menu.add()</kbd> method. Since we want to modify the menu items later as well as respond to the menu item events, we defined our own menu IDs and passed them to the <kbd>add()</kbd> method. The <kbd>onOptionsItemSelected()</kbd> object is called for all the menu items, so we get the menu ID and use a <kbd>switch</kbd> statement based on the ID. We return <kbd>true</kbd> if we are handling the menu event, otherwise we pass the event to the super class.</p>
<p>Changing the menu occurs in the <kbd>onPrepareOptionsMenu()</kbd> method. To simulate an external event, we created a button to toggle a Boolean flag. The visibility of the Download menu is determined by the flag. This is where you would want to create your custom code based on whatever criteria you set. Your flag could be set using the current player level or maybe when a new level is ready for release, you send a push message to enable the menu item.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>What if we wanted the Download option to stand out when it's available? We could tell Android we want the menu in the action bar by adding the following code to <kbd>onPrepareOptionsMenu()</kbd> (before the return statement):</p>
<pre>menuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS); </pre>
<p>Now if you run the code, you will see the Download menu item in the action bar, but the behavior isn't correct.</p>
<p>Earlier, when we didn't have a menu item in the action bar, Android called <kbd>onPrepareOptionsMenu()</kbd> each time we opened the overflow menu so the visibility was always updated. To correct this behavior, add the following line of code to the <kbd>toggleMenu()</kbd> method:</p>
<pre>invalidateOptionsMenu(); </pre>
<p>The <kbd>invalidateOptionsMenu()</kbd> call tells Android that our option menu is no longer valid, which then forces a call to <kbd>onPrepareOptionsMenu()</kbd>, giving us the behavior we expect.</p>
<p>Android considers the menu as always open if a menu item is displayed in the action bar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enabling Contextual Action Mode for a view</h1>
                
            
            
                
<p>A context menu provides additional options related to a specific view—the same concept as a right-click on the desktop. Android currently supports two different approaches: the floating context menu and Contextual Mode. Contextual Action Mode was introduced in Android 3.0. The older floating context menu could lead to confusion since there was no indication of the currently selected item and it didn't support actions on multiple items—such as selecting multiple emails to delete in one action.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a floating context menu</h1>
                
            
            
                
<p>If you need to use the old-style context menu, for example to support pre-Android 3.0 devices, it's very similar to the Option Menu API, you just different method names. To create the menu, use <kbd>onCreateContextMenu()</kbd> instead of <kbd>onCreateOptionsMenu()</kbd>. To handle the menu item selection, use <kbd>onContextItemSelected()</kbd> instead of <kbd>onOptionsItemSelected()</kbd>. Finally, call <kbd>registerForContextMenu()</kbd> to let the system know you want context menu events for the view.</p>
<p>Since Contextual Mode is considered the preferred way to display context options, this recipe will focus on the newer API. Contextual Mode offers the same features as the floating context menu, but also adds additional functionality by allowing multiple item selection when using batch mode.</p>
<p>This recipe will demonstrate the setup of Contextual Mode for a single view. Once activated, with a long press in our example, a <strong>contextual action bar</strong> (<strong>CAB</strong>) will replace the action bar until Contextual Mode is finished.</p>
<p>The CAB is not the same as the action bar and your activity does not need to include an action bar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Use Android Studio to create a new project and call it <kbd>ContextualMode</kbd>. Use the default Phone &amp; Tablet option and select Empty Activity when prompted to add an activity. Create a menu directory (<kbd>res/menu</kbd>) as we did in the first recipe, <em>Creating an options menu</em>, to store the XML for the contextual menu.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will create <kbd>ImageView</kbd> to serve as the host view to initialize Contextual Mode. Since Contextual Mode is usually triggered with a long press, we will set up a long click listener in <kbd>onCreate()</kbd> for <kbd>ImageView</kbd>. When called, we will start Contextual Mode and pass an <kbd>ActionMode</kbd> callback to handle the Contextual Mode events. Here are the steps:</p>
<ol>
<li>We will start by adding two new string resources. Open the <kbd>strings.xml</kbd> file and add the following:</li>
</ol>
<pre>    &lt;string name="menu_cast"&gt;Cast&lt;/string&gt; 
    &lt;string name="menu_print"&gt;Print&lt;/string&gt; </pre>
<ol start="2">
<li>With the strings created, we can now create the menu by creating a new file in <kbd>res/menu</kbd> called <kbd>context_menu.xml</kbd> using the following XML:</li>
</ol>
<pre>    &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    &lt;menu xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>        &lt;item android:id="@+id/menu_cast"<br/>            android:title="@string/menu_cast" /&gt;<br/>        &lt;item android:id="@+id/menu_print"<br/>            android:title="@string/menu_print" /&gt;<br/>    &lt;/menu&gt;</pre>
<ol start="3">
<li>Now add <kbd>ImageView</kbd> to <kbd>activity_main.xml</kbd> to serve as the source for initiating Contextual Mode. Here is the XML for <kbd>ImageView</kbd>:</li>
</ol>
<pre>    &lt;ImageView<br/>        android:id="@+id/imageView"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent"<br/>        app:srcCompat="@mipmap/ic_launcher" /&gt;</pre>
<ol start="4">
<li>With the UI now set up, we can add the code for Contextual Mode. First, we need a global variable to store the <kbd>ActionMode</kbd> instance returned when we call <kbd>startActionMode()</kbd>. Add the following line of code to <kbd>MainActivity.java</kbd> below the class constructor:</li>
</ol>
<pre>    ActionMode mActionMode;</pre>
<ol start="5">
<li>Next, create an <kbd>ActionMode</kbd> callback to pass to <kbd>startActionMode().</kbd> Add the following code to the <kbd>MainActivity</kbd> class below the code in the previous step:</li>
</ol>
<pre>    private ActionMode.Callback mActionModeCallback = new <br/>    ActionMode.Callback() {<br/>        @Override<br/>        public boolean onCreateActionMode(ActionMode mode, Menu menu) {<br/>            mode.getMenuInflater().inflate(R.menu.context_menu, menu);<br/>            return true;<br/>        }<br/><br/>        @Override<br/>        public boolean onPrepareActionMode(ActionMode mode, Menu menu)   <br/>        {<br/>            return false;<br/>        }<br/><br/>        @Override<br/>        public boolean onActionItemClicked(ActionMode mode, MenuItem            <br/>        item) {<br/>            switch (item.getItemId()) {<br/>                case R.id. menu_cast:<br/>                    Toast.makeText(MainActivity.this, "Cast",  <br/>                    Toast.LENGTH_SHORT).show();<br/>                    mode.finish();<br/>                    return true;<br/>                case R.id. menu_print:<br/>                    Toast.makeText(MainActivity.this, "Print", <br/>                    Toast.LENGTH_SHORT).show();<br/>                    mode.finish();<br/>                    return true;<br/>                default:<br/>                    return false;<br/>            }<br/>        }<br/><br/>        @Override<br/>        public void onDestroyActionMode(ActionMode mode) {<br/>            mActionMode = null;<br/>        }<br/>    };</pre>
<ol start="6">
<li>With the <kbd>ActionMode</kbd> callback created, we just need to call <kbd>startActionMode()</kbd> to begin Contextual Mode. Add the following code to the <kbd>onCreate()</kbd> method to set up the long click listener:</li>
</ol>
<pre>    ImageView imageView = findViewById(R.id.imageView);<br/>    imageView.setOnLongClickListener(new View.OnLongClickListener() {<br/>        public boolean onLongClick(View view) {<br/>            if (mActionMode != null) return false;<br/>            mActionMode = startSupportActionMode(mActionModeCallback);<br/>            return true;<br/>        }<br/>    });</pre>
<ol start="7">
<li>Run the program on a device or emulator to see the CAB in action.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As you saw in step 2, we used the same menu XML to define the contextual menu as the other menus.</p>
<p>The main piece of code to understand is the <kbd>ActionMode</kbd> callback. This is where we handle the Contextual Mode events: initializing the menu, handling menu item selections, and cleaning up. We start Contextual Mode in the long press event with a call to <kbd>startActionMode()</kbd> by passing in the <kbd>ActionMode</kbd> callback created in step 5.</p>
<p>When action mode is triggered, the system calls the <kbd>onCreateActionMode()</kbd> callback, which inflates the menu and displays it in the CAB. The user can dismiss the CAB by pressing the back arrow or the back key. The CAB is also dismissed when the user makes a menu selection. We show a Toast to give a visual feedback for this recipe but this is where you would implement your functionality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In this example, we store <kbd>ActionMode</kbd> returned from the <kbd>startActionMode()</kbd> call. We use it to prevent a new instance from being created when the Action Mode is already active. We could also use this instance to make changes to the CAB itself, such as changing the title with the following:</p>
<pre>mActionMode.setTitle("New Title"); </pre>
<p>This is particularly useful when working with multiple item selections as we'll see in the next recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>See the next recipe, <em>Using Contextual Batch Mode with RecyclerView</em>, to work with multiple item selection</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Contextual Batch Mode with RecyclerView</h1>
                
            
            
                
<p>As discussed in the previous recipe, Contextual Mode supports two forms of use: single View mode (as demonstrated) and multiple selection (or batch) mode. Batch mode is where Contextual Mode outperforms the old-style context menu as multiple selections were not supported.</p>
<p>If you've ever used an email app such as Gmail or a file browser, you've probably seen Contextual Mode when selecting multiple items. Here is a screenshot from Solid Explorer, which shows an excellent implementation of Material Theme and Contextual Mode:</p>
<div><img src="img/85d5a22f-ca2c-4c51-903a-3257d12c4c78.png" style="width:22.50em;height:40.17em;"/></div>
<p>When we introduced <kbd>RecyclerView</kbd> in <a href="0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml">Chapter 2</a>, <em>Layouts</em>, we discussed how many features from the old <kbd>ListView</kbd> were not already included in the new <kbd>RecyclerView</kbd>. Multiple item selection is one of the most missed features. In this recipe, we will demonstrate multiple item selection with the <kbd>RecyclerView</kbd> using Action Mode. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will use the <kbd>RecyclerView</kbd> example created in <a href="0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml">Chapter 2</a><em>, Layouts</em> as the base for this recipe. If you have not already done so, go back to the <em>RecyclerView replaces ListView </em>recipe in that chapter<em>,</em> then add the menu directory (<kbd>res/menu</kbd>) for the contextual menu as demonstrated previously. From this point, you can perform the following steps to add multiple item selection to <kbd>RecyclerView</kbd>. The project will be called <kbd>RecyclerViewActionMode</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll be combining several concepts already learned in previous recipes to enable multiple item selection with <kbd>RecyclerView</kbd>. We'll start by adding the menu and related code, then modify the <kbd>RecyclerView</kbd> item to show the state selection. Finally, we'll modify the <kbd>RecyclerView</kbd> adapter to support click notification, which will start Action Mode. Here are the steps:</p>
<ol>
<li>Open the <kbd>strings.xml</kbd> file and add two new string resources for the menu items as follows:</li>
</ol>
<pre>    &lt;string name="delete_all"&gt;Delete All&lt;/string&gt;</pre>
<ol start="2">
<li>Create a new file called <kbd>contextual_menu.xml</kbd> in the <kbd>res/menu</kbd> folder with the following XML:</li>
</ol>
<pre>    &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    &lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt;<br/>        &lt;item android:id="@+id/delete_all"<br/>            android:title="@string/delete_all" /&gt;<br/>    &lt;/menu&gt;</pre>
<ol start="3">
<li>Next, add a new file to the <kbd>res/drawable</kbd> folder called <kbd>item_selector.xml</kbd> with the following XML:</li>
</ol>
<pre>    &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    &lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt;<br/>        &lt;item android:id="@+id/delete_all"<br/>        android:title="@string/delete_all" /&gt;<br/>    &lt;/menu&gt;</pre>
<ol start="4">
<li>Open the <kbd>item.xml</kbd> file in <kbd>res/layout</kbd> and add the following line to the <kbd>LinearLayout</kbd>:</li>
</ol>
<pre>    android:background="@drawable/item_selector"</pre>
<ol start="5">
<li>Next, create a new Java file called <kbd>SelectMode</kbd> to server as the click event interface. The code is as follows:</li>
</ol>
<pre>    public interface SelectMode {<br/>        void onSelect();<br/>    }</pre>
<ol start="6">
<li>Now open the <kbd>MyAdapter</kbd> file and add <kbd>implements SelectMode</kbd> to the class. The final result will be as follows:</li>
</ol>
<pre>    public class MyAdapter extends <br/>    RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt;<br/>        implements SelectMode { </pre>
<ol start="7">
<li>Add the <kbd>onSelect</kbd> method to the class using the following code: </li>
</ol>
<pre>    @Override<br/>    public void onSelect() {<br/>        if (mListener!=null) {<br/>            mListener.onSelect();<br/>        }<br/>    }</pre>
<ol start="8">
<li>Add the following declaration to the class to hold the list of selected items: </li>
</ol>
<pre>    private SparseArray&lt;Boolean&gt; selectedList = new SparseArray&lt;&gt;();</pre>
<ol start="9">
<li>We'll add another method to the adapter to handle the actual <kbd>delete</kbd> method called from the Action Mode: </li>
</ol>
<pre style="padding-left: 60px">public void deleteAllSelected() {<br/>    if (selectedList.size()==0) { return; }<br/>    for (int index = nameList.size()-1; index &gt;=0; index--) {<br/>        if (selectedList.get(index,false)) {<br/>            remove(index);<br/>        }<br/>    }<br/>    selectedList.clear();<br/>}</pre>
<ol start="10">
<li>The final change to make to the <kbd>MyAdapter</kbd> class is to replace the existing <kbd>onClick()</kbd> . The final code will be as follows: </li>
</ol>
<pre>    @Override<br/>    public void onClick(View v) {<br/>        holder.itemView.setSelected(!holder.itemView.isSelected());<br/>        if (holder.itemView.isSelected()) {<br/>           selectedList.put(position, true);<br/>        } else {<br/>            selectedList.remove(position);<br/>        }<br/>        onSelect();<br/>    }</pre>
<ol start="11">
<li>Now that we have the menu created and the adapter updated, we need to hook it all up in the <kbd>MainActivity</kbd> class. To start, modify the <kbd>MainActivity</kbd> declaration to implement the <kbd>SelectMode</kbd> interface. The final code will be as follows: </li>
</ol>
<pre>    public class MainActivity extends AppCompatActivity<br/>    implements SelectMode {</pre>
<ol start="12">
<li>Below the class declaration, add the following two variable declarations: </li>
</ol>
<pre>    MyAdapter myAdapter;<br/>    ActionMode mActionMode;</pre>
<ol start="13">
<li>Then add the <kbd>ActionMode</kbd> callback declaration: </li>
</ol>
<pre>    private ActionMode.Callback mActionModeCallback = new <br/>    ActionMode.Callback() {<br/>        @Override<br/>        public boolean onCreateActionMode(ActionMode mode, Menu menu) {<br/>            mode.getMenuInflater().inflate(R.menu.context_menu, menu);<br/>            return true;<br/>        }<br/><br/>        @Override<br/>        public boolean onPrepareActionMode(ActionMode mode, Menu menu) <br/>        {<br/>            return false;<br/>        }<br/><br/>        @Override<br/>        public boolean onActionItemClicked(ActionMode mode, MenuItem <br/>        item) {<br/>            switch (item.getItemId()) {<br/>                case R.id. delete_all:<br/>                    myAdapter.deleteAllSelected();<br/>                    mode.finish();<br/>                    return true;<br/>                default:<br/>                    return false;<br/>            }<br/>        }<br/><br/>        @Override<br/>        public void onDestroyActionMode(ActionMode mode) {<br/>            mActionMode = null;<br/>        }<br/>    };</pre>
<ol start="14">
<li>We need to store the <kbd>MyAdapter</kbd> reference so it can be called from <kbd>ActionMode</kbd>. To do this, modify the <kbd>myAdapter</kbd> instantiation call in the <kbd>onCreate()</kbd> method as follows: </li>
</ol>
<pre>    myAdapter = new MyAdapter(list, this);</pre>
<ol start="15">
<li>The final code is to implement the <kbd>onSelect</kbd> method to connect the adapter callback to the Action Mode. Add the following method to the <kbd>MainActivity</kbd> class: </li>
</ol>
<pre>    @Override<br/>    public void onSelect() {<br/>        if (mActionMode != null) return;<br/>        mActionMode = startSupportActionMode(mActionModeCallback);<br/>    }</pre>
<ol start="16">
<li>Run the program on a device or emulator to see the CAB in action.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As mentioned in the <em>Introduction</em> to this recipe, multiple item selection is one of the most missed features of <kbd>RecyclerView</kbd> and the one that receives the most questions. As you can see from this example, even a basic implementation requires many steps but the end result can be the exact implementation required for your task. You won't be limited to an existing feature set since you'll be creating it yourself. </p>
<p>This recipe combines several concepts learned from previous recipes, including the following:</p>
<ul>
<li><kbd>RecyclerView</kbd></li>
<li>The <kbd>RecyclerView</kbd> adapter</li>
<li>The contextual menu</li>
<li>The action mode callback</li>
</ul>
<p>To tie everything together, we created a custom interface so the adapter could notify when an item was selected. <kbd>MainActivity</kbd> receives the <kbd>onSelect()</kbd> event to trigger <kbd>ActionMode</kbd>. The <kbd>ActionMode</kbd> menu item calls the adapter when the user clicks the Delete All menu item and then closes the CAB. </p>
<p>This is just one-way <kbd>ActionMode</kbd> could be implemented. We could start <kbd>ActionMode</kbd> with a long press, a checkbox on the item, or maybe a menu item. The choice is yours.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you ran the application using the code shown previously, everything works as you'd expect. But there's a problem. Our example only has a few items in the list—probably not enough to even allow scrolling. The point of <kbd>RecyclerView</kbd> though is to efficiently handle many items when scrolling. If you add many more items to the list, enough to allow scrolling a screen or two, you'll see the problem. <kbd>RecyclerView</kbd> does exactly what it says: it recycles the views. If you select the first item, then scroll down, you'll see the problem - items you didn't select are selected. </p>
<p>What's happening is a common issue and confuses many developers new to <kbd>RecyclerView</kbd>. Because the view is being reused, it's showing the state from the previous item. The solution is simple: just set the state appropriately when binding a new item. We can fix the preceding problem just by setting the initial state in the <kbd>onBindViewHolder()</kbd> call. Add the following line of code to the <kbd>onBindViewHolder()</kbd> method in the <kbd>MyAdapter</kbd> class:</p>
<pre>holder.itemView.setSelected(selectedList.get(position,false));</pre>
<p>As you can see, we set the initial state by checking our list to see if the item was selected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>For more information on <kbd>RecyclerView</kbd>, refer to <a href="0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml">Chapter 2</a><em>, Layouts</em></li>
<li>For more information on the SparseArray, refer to <a href="https://developer.android.com/reference/android/util/SparseArray">https://developer.android.com/reference/android/util/SparseArray</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a pop-up menu</h1>
                
            
            
                
<p>A pop-up menu is attached to a view similar to the drop-down menu on a spinner. The idea of a pop-up menu is to provide additional options to complete an action. A common example might be a Reply button in an email app. When pressed, several reply options are shown, such as: Reply, Reply All, and Forward.</p>
<p>Here is an example of the pop-up menu from the following recipe:</p>
<div><img src="img/08cb6ea0-0eb1-44d4-bbeb-0beab4c9681a.png" style="width:12.17em;height:11.83em;"/></div>
<p>Android will show the menu options below the anchor view if there is room; otherwise, the menu will be shown above the view.</p>
<p>A pop-up menu is <em>not</em> meant to affect the view itself. That is the purpose of a Context Menu. Instead refer to the Floating Menu/Context Mode described in the <em>Enabling Contextual Action Mode for a view</em> recipe.</p>
<p>In this recipe, we will create the pop-up menu shown previously, using <kbd>ImageButton</kbd> as the anchor view.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>PopupMenu</kbd>. Use the default Phone &amp; Tablet option and select Empty Activity on the Add an Activity to Mobile dialog. As detailed in the first exercise of this chapter, create a menu directory (<kbd>res/menu</kbd>) to store the menu XML.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We start by creating the XML menu to inflate on the button press. After inflating the pop-up menu, we call <kbd>setOnMenuItemClickListener()</kbd> by passing in the callback to handle the menu item selection. Start by opening the <kbd>strings.xml</kbd> file located in the <kbd>res/values</kbd> folder, then follow these steps:</p>
<ol>
<li>Add the following strings:</li>
</ol>
<pre>    &lt;string name="menu_reply"&gt;Reply&lt;/string&gt; 
    &lt;string name="menu_reply_all"&gt;Reply All&lt;/string&gt; 
    &lt;string name="menu_forward"&gt;Forward&lt;/string&gt; </pre>
<ol start="2">
<li>Create a new file in the <kbd>res/menu</kbd> directory called <kbd>menu_popup.xml</kbd> using the following XML:</li>
</ol>
<pre>    &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    &lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/>        &lt;item android:id="@+id/menu_reply"<br/>            android:title="@string/menu_reply" /&gt;<br/>        &lt;item android:id="@+id/menu_reply_all"<br/>            android:title="@string/menu_reply_all" /&gt;<br/>        &lt;item android:id="@+id/menu_forward"<br/>            android:title="@string/menu_forward" /&gt;<br/>    &lt;/menu&gt;</pre>
<ol start="3">
<li>Create <kbd>ImageButton</kbd> in <kbd>activity_main.xml</kbd> to provide the anchor view for the pop-up menu. Create it as shown in the following XML code:</li>
</ol>
<pre>    &lt;ImageButton<br/>        android:id="@+id/imageButtonReply"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:layout_marginStart="8dp"<br/>        android:layout_marginTop="8dp"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent"<br/>        app:srcCompat="@android:drawable/ic_menu_revert"<br/>        android:onClick="showPopupMenu"/&gt;</pre>
<ol start="4">
<li>Open <kbd>MainActivity.java</kbd> and add the following <kbd>OnMenuItemClickListener</kbd> below the class constructor:</li>
</ol>
<pre>    private PopupMenu.OnMenuItemClickListener mOnMenuItemClickListener  <br/>    = new<br/>            PopupMenu.OnMenuItemClickListener() {<br/>                @Override<br/>                public boolean onMenuItemClick(MenuItem item) {<br/>                    switch (item.getItemId()) {<br/>                        case R.id.menu_reply:<br/>                            Toast.makeText(MainActivity.this, "Reply", <br/>                            Toast.LENGTH_SHORT).show();<br/>                            return true;<br/>                        case R.id.menu_reply_all:<br/>                            Toast.makeText(MainActivity.this,"Reply <br/>                            All",Toast.LENGTH_SHORT).show();<br/>                            return true;<br/>                        case R.id.menu_forward:<br/>                            Toast.makeText(MainActivity.this,"Forward", <br/>                            Toast.LENGTH_SHORT).show();<br/>                            return true;<br/>                        default:<br/>                            return false;<br/>                    }<br/>                }<br/>            };</pre>
<ol start="5">
<li>The final code is to handle the button <kbd>onClick()</kbd> event, as follows:</li>
</ol>
<pre>    public void showPopupMenu(View view) {<br/>        PopupMenu popupMenu = new PopupMenu(MainActivity.this,view);<br/>        popupMenu.inflate(R.menu.menu_popup);<br/>        popupMenu.setOnMenuItemClickListener(mOnMenuItemClickListener);<br/>        popupMenu.show();<br/>    }</pre>
<ol start="6">
<li>Run the program on a device or emulator to see the pop-up menu.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>If you read the previous menu recipes, this will probably look very familiar. Basically, we just inflate a pop-up menu when <kbd>ImageButton</kbd> is pressed. We set up a menu item listener to respond to the menu selection.</p>
<p>The key is to understand each of the menu options available in Android so you can use the correct menu type for a given scenario. This will help your application by providing a consistent user experience and reducing the learning curve for the user as they will already be familiar with the <em>standard</em> way of doing things.</p>


            

            
        
    </body></html>