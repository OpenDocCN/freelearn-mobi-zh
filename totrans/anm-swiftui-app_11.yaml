- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating an Elevator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the elevator project! In this one, we’re going to create a working
    elevator, complete with sounds, floor lights, a button, and even some images of
    people inside. We will control the elevator using timers that are available from
    the Swift timer class, as we have done in previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: To bring these elements together, we’ll create a data model using the `@ObservableObject`
    protocol. Apple recommends making a data model as the place to store and process
    the data that the application uses. The data model is also separate from the app’s
    user interface, where the views are created. The reason to keep data and the UI
    separate is that this paradigm fosters modularity and testability. It’s easier
    to find bugs in your logic when the data is not mixed in with UI code. Once we
    have the data model set up, we can then publish that data anywhere in the app
    using publishing wrappers, as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project and adding a `Binding` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembling the elevator using images and the `GeometryReader` view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting people inside the elevator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data model and using the `@``ObservableObject` protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the data model functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the background, a button, and animating the doors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding floor indicator lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project and adding a Binding variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let’s get started! As always, we’ll create a new Xcode project (I’m going
    to call mine `Elevator`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the GitHub repo, take all the images from the `Chapter 11` folder and
    drop them into the Asset Catalog. These images include `doorDrame`, `leftDoor`,
    `rightDoor`, `inside`, `man`, `man2`, `man3`, and `man4`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, drop the audio files – `doorsOpenClose` and `elevatorChime` – into the
    Project Navigator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’re going to need a new file where we can assemble the elevator and
    add the people, so create a new SwiftUI View file and call it `ElevatorAndPeopleView`.
    We only need one variable in this file, which will be the Binding variable. Let’s
    add it at the top, inside the `ElevatorAndPeopleView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This variable will control the elevator doors opening and closing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `Previews` so that the code will build without errors. At
    the bottom of the file, alter the `Previews` struct so that it looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code adds a value of `false` to both binding properties, and the project
    once again builds cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to building out the elevator.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the elevator using images and the GeometryReader view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to use some of the images from the Assets catalog and make
    an elevator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by adding the inside part of the elevator, which we’ll do by adding
    the following code inside the `body` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we have `ZStack` to hold all the views that will follow, and a `GeometryReader`
    view.
  prefs: []
  type: TYPE_NORMAL
- en: The `GeometryReader` view is a container view that defines its content as a
    function of its own size and coordinate space. It’s a little bit like the other
    containers that we have used, such as `VStack` or `HStack`, but the difference
    is that `GeometryReader` has more flexibility because of its proxy parameter,
    the `geo` constant (which you can name whatever you want).
  prefs: []
  type: TYPE_NORMAL
- en: This proxy will contain information about the container’s size and coordinate
    space, and we can pass that information to the child views inside `GeometryReader`,
    which helps us precisely size and position its children relative to the container.
    The `GeometryReader` view also makes the views within it line up perfectly on
    all iPhone and iPad devices, whatever their size.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use `GeometryReader` to size and position all the parts of the
    elevator, as well as the people inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add the code that creates the elevator’s interior within `GeometryReader`’s
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Image` initializer adds the image called `inside` to the scene, and then
    uses the `frame` modifier to set the size of this image to the maximum width and
    maximum height of the screen. It sets this size using the `geo` proxy constant
    we created with the `GeometryReader` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previews now display the inside of the elevator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The inside of the elevator ](img/B18674_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The inside of the elevator'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue assembling the elevator by adding doors next. The doors will
    have animations attached to them so that they slide open and close, and then later,
    we will add timers to them so that they can operate automatically after an initial
    button press. So, continuing inside the `GeometryReader` view, add this code for
    the doors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We put the doors in `HStack` because they need to be positioned side by side.
    The doors are sized using the `frame` modifier and `geo` proxy constant, just
    as we did with the `inside` elevator image. Both doors also get the `offset` modifier
    tacked on to them, which will position them on opposite sides of the screen, opening
    them up fully.
  prefs: []
  type: TYPE_NORMAL
- en: The process to open and close the doors is handled by the `geo` proxy constant.
    When the `doorsOpened` property becomes `true` for the left door, the `geo` proxy
    constant will move the door on the *x*-axis, to the left and off the screen. The
    amount that the door moves is the width of the door divided by 2\. The reason
    why the left door moves to the left and not the right is that we prefix the `geo`
    constant with a negative sign. When a negative value is used and an object is
    being offset on the *x*-axis, that object will move to the left, whereas a positive
    value will move the object to the right.
  prefs: []
  type: TYPE_NORMAL
- en: When the `doorsOpened` property becomes `false`, the `offset` modifier reverses
    the animation and the left door closes.
  prefs: []
  type: TYPE_NORMAL
- en: For the right door, we do the same thing, except a positive value is used for
    the `geo` constant, which moves the door to the right along the *X* axis to open
    it. The values of `4` and -`4` that are used for both doors are included to help
    keep the two doors snug with each other when they are in the closed position.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, this is what the scene looks like in the `ElevatorAndPeopleView` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: The elevator doors ](img/B18674_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: The elevator doors'
  prefs: []
  type: TYPE_NORMAL
- en: We have the elevator’s interior and doors placed together, and we have the animation
    mechanism to operate the doors, but we won’t see any motion happening until we
    call this file inside `ContentView`, and we still have some more assembly to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put a frame around the outside of the elevator so that it will look like
    the actual elevator, and provide a place to add the elevator’s button. Add the
    following code just after the closing bracket of `HStack`, still within the `GeometryReader`
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are adding the `doorFrame` image to the scene, and as we want the
    frame to go around the entire elevator, we used the same code that we used for
    the `inside` image – we used the `geo` proxy constant again, and by setting the
    image at the maximum width and height, the door frame creates a nice border around
    the elevator doors. This is the result so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: The elevator frame ](img/B18674_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: The elevator frame'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the animation code that will open and close the doors, and control
    the speed and delay of the doors when activated later in the `ContentView`. Its
    only one line of code, and it can be placed right after the closing bracket of
    the `GeometryReader` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `animation` modifier. Then, we pass in a value of `0.09` for
    the `speed` function, which will control how fast the doors open and close. There’s
    also a slight `delay` added of `0.3` seconds, which will delay the door opening
    and closing just enough to keep things in sync with the floor lights, which we
    will add soon.
  prefs: []
  type: TYPE_NORMAL
- en: We’re getting close to finishing using this file – the only parts left to add
    are the people images. Of course, you can put the people code into a separate
    file if you prefer, but since there isn’t a lot of code in this file, it will
    be fine to continue to work here.
  prefs: []
  type: TYPE_NORMAL
- en: Putting people inside the elevator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll be adding four characters into our elevator, Let’s start with the `manOne`
    image – add the following code right after the `frame` modifier near the top of
    the file, inside the `GeometryReader` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is bringing the `manOne` image into the scene and then
    adding the correct aspect ratio to the image. Next, we use the `frame` modifier
    to set the size for the image, but what’s different this time is that we use the
    proxy constant of `GeometryReader` to set the size dynamically; when the width
    and height of an image are set this way, the scene will proportionally scale up
    or down on all Apple devices to fit the various screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: I’m trimming off 200 and 300 points for the width and height values so that
    the image will fit nicely inside the elevator. Once we have the images sized and
    positioned the way we want, they will scale dynamically when they appear on different
    devices, so we do need to size and position them initially.
  prefs: []
  type: TYPE_NORMAL
- en: We will then add some `shadow` with `30` points around the image on the *X*
    and *Y* axes, which gives a nice depth of field for the man when placed inside
    the shiny metal elevator. And finally, we offset the image on the *Y* axis so
    that the feet are on the floor of the elevator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how `manOne` looks in our elevator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: The first man ](img/B18674_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: The first man'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t have the animation hooked up yet, to open the door and see inside
    the elevator while we continue to work, you can simply comment out the door code,
    and the door images will disappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the three remaining people is similar to what we’ve just added,
    so I’m going to add the other three images directly under the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code for the `manTwo`, `manThree`, and `manFour` images are largely the
    same as the code for the `manOne` image, just with slightly different values for
    the `frame` modifier, the `offset` modifier, and their positions in the elevator.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the `manTwo` code, I’m adding a rotation effect to this image because
    I want to turn this image a little bit toward the left, as he appears to be talking,
    and it looks a little bit better if we position him in the direction of the person
    on his right. This is accomplished with the `rotation3DEffect` modifier; simply
    turning him `20` degrees on the *Y* axis is enough to point him in the right direction
    of the other image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our elevator full of people:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: The rest of the people ](img/B18674_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: The rest of the people'
  prefs: []
  type: TYPE_NORMAL
- en: And that finishes off this file. We can now move on to creating the data model
    file and adding the necessary functions for the timers and sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data model and using the ObservableObject protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a new file – although this time, choose the `DataModel`. In this
    file, we will put the data that we can access from `ContentView` later, using
    the `@ObservableObject` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this protocol, we first need to import the SwiftUI framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a class to hold all the data, and we also need to make the class
    conform to the `@ObservableObject` protocol, so let’s add that now. You can name
    the class anything you want, but many developers like to name the class the same
    name as the file it is in, so we will do the same, naming the class `DataModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let’s understand what `@``ObservableObject` does.
  prefs: []
  type: TYPE_NORMAL
- en: In previous projects, we used the `@State` property to pass data to the views
    and display them to the user, but this is limited because the `@State` property
    wrapper can only store values that control the states of a single view; we can’t
    make `@State` properties and pass them around to other structs, as they work in
    only one struct.
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `@Binding` property wrapper, which helped to re-establish the
    connection to other views or structs with a bidirectional link that the `@State`
    property could not provide. However, this would not work globally to hold and
    pass data to all files in the app.
  prefs: []
  type: TYPE_NORMAL
- en: So, what we need now is an object that can globally control all the app’s data
    and its states and update the views accordingly when there are any changes to
    the properties, either by user input or changes made by other means, such as downloads
    from a server or the web.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `@ObservableObject` protocol comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@ObservableObject` protocol defines three distinct property wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: An `@StateObject` property wrapper that listens for changes in `@ObservableObject`
    and receives the new values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `@ObservedObject` property wrapper that listens for changes in the `@StateObject`
    property and receives those new values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `@Published` property wrapper that reports all the changes to the system
    and publishes those changes to the view app-wide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of using `@ObservableObject` over the `@State` property wrapper
    is, again, that we can update more than one view with any changes, and the state
    can be checked from views anywhere in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, that’s a lot to take in, but it will become clearer as we build out the
    data model. We already have the `DataModel` class created, and it conforms to
    the `@ObservableObject` protocol – that’s the first step. Next, we want to declare
    the properties we need, prefixing them with the `@Published` property wrapper
    so that they will hold the various data and states and be published to the views
    when needed. Let’s do that now by adding the following properties inside the `DataModel`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are several properties here that hopefully are self-explanatory. The four
    Booleans will be used to let us know when the doors of the elevator are opened,
    whether floor 1 or floor 2 is the active floor, and whether the elevator is going
    up or going down. The timers will control the timing of the doors opening and
    closing, as well as when to play the floor chimes and when to play the door opening
    and closing sounds.
  prefs: []
  type: TYPE_NORMAL
- en: With the properties listed, we next need a way to access them from other parts
    of the app. This is done by going up the hierarchy to the `Root` view and injecting
    an instance of the data model there – the `Root` view is the entry point of the
    app, the point from which the app starts up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go into the `App.swift` file in the Project navigator and create an instance
    of the `DataModel` class there inside the struct, sending a reference to `ContentView`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned, this file is the entry point for our app, as denoted by the
    `@main` wrapper at the top, and it creates the `Root` view window and takes care
    of creating all the objects we need for the app to start up. Since this file is
    at the top of the hierarchy, it’s the perfect place to create the `DataModel`
    instance and pass it into the `Root` view, `ContentView`, so it can be available
    app-wide.
  prefs: []
  type: TYPE_NORMAL
- en: The `DataModel` instance is called `appData`, and it gets prefixed with the
    `@StateObject` property wrapper – this wrapper will listen for changes in `@ObservableObject`
    and receive any new values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `@StateObject` property wrapper that we called `appData` is injected
    into `ContentView` by passing it into the `ContentView` initializer to, again,
    make the data in the data model available throughout the app.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to complete the connection from our data here, and from any view in the
    project, all we have to do is include an `@ObservedObject` property inside every
    view that we want to have a connection to this model. The job of `@ObservedObject`
    is to listen for changes in the `@StateObject` property and receive those new
    values so that it can update the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now go into `ContentView` and add an `@ObservedObject` property to complete
    the bidirectional binding between the `AppData` class, which holds all the data,
    and `ContentView`, which is in charge of displaying all of that data on a screen
    to a user. Add the following property to the `ContentView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have an instance of `DataModel`, which will monitor all the data for
    us; if there are any changes to the data, `ObservedObject` will know about it
    and update the views accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we create more files and need to access the data model from those new
    files, all we have to do is create another instance of the data model and use
    it in those files too, like we did with the `appData` instance here, and they
    will have the same access and be updated with any changes that occur.
  prefs: []
  type: TYPE_NORMAL
- en: We have the instance of the data model ready to be used in `ContentView`, but
    now we need to add some functions that will take care of setting different timers,
    which will trigger the doors to open and close, trigger the floor number lights,
    and also trigger the sound effects at the right moments.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the data model functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create five functions, and each one oversees a specific
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: A function to open and close the doors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to play the chimes bell sound that signifies the elevator has reached
    its destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to play the door opening and closing sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to light up the floor indicator lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to stop all the timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by creating the function that will open and close the doors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the doorOpenTimer function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Come back into the `DataModel` class, and directly underneath the last variable,
    add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function is called `openDoors`, and what this does is set the `doorsOpenTimer`
    object to a value specified by the `scheduledTimer` method. The `scheduledTimer`
    method will execute the code in its block after a certain amount of time has elapsed
    – in this case, 8 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `scheduledTimerWithInterval` function also has a `repeats` parameter, which
    lets you repeat the triggering of the code in its body. In the code, we set the
    `repeats` parameter to `false`, as we only want the code in its body to be triggered
    when the elevator button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The code that it will trigger will involve toggling the `doorsOpened` property
    to its opposite value. We’re going to add a button to the elevator, and we will
    call this function when that button is pressed. When it’s pressed, if the `doorsOpened`
    property is `true`, it will be toggled to `false`, and vice versa, thus opening
    and closing the doors as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the playChimeSound function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create another function that will trigger the chimes sound effect; this
    sound signifies the elevator has reached its destination and will play just before
    the doors open. Add the following function, directly underneath the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function is called `playChimeSound`, and it is like the previous function
    we just added.
  prefs: []
  type: TYPE_NORMAL
- en: When the function is called, it sets the `chimesTimer` property to a value specified
    by the `scheduledTimer` method, which is `5.5` seconds. After 5.5 seconds have
    elapsed, the `scheduledTimer` method will call the `playSound` function within
    its body.
  prefs: []
  type: TYPE_NORMAL
- en: The `playSound` function has two parameters – one for the name of the sound
    file that we imported into the project, and the other for the file’s extension
    type. However, we haven’t created this function yet, so we will get an error!
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we need to create a separate Swift file, which we will call `PlaySound`.
    Then, add the following code to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we’ve done in previous projects, we imported the `AVFoundation` framework
    to have access to the audio classes and methods we need. Next, we created an `audio
    player` instance and then added the `playSound` function.
  prefs: []
  type: TYPE_NORMAL
- en: You should be familiar with how this function works; all we need to do is call
    this function in any file in which we need to have sound playing, passing the
    name of the sound file into its `sound` parameter and its extension type into
    its `type` parameter. Now, the `playChimeSound` function should play error-free.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s head back to the `DataModel` class and continue to add the rest of
    the functions that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the playDoorOpenCloseSound function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an elevator door opens and closes, it makes a distinctive sound, similar
    to a mechanical whooshing sound. We want to add that sound to the project, and
    we’ll need a function that can trigger it at the right moment. Let’s do that right
    after the previous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`playDoorOpenCloseSound` is a function in which we set the `doorSoundTimer`
    property to a value specified by the `scheduledTimer` method, and the value it
    will use for the interval parameter will be passed into this function when it
    gets called in `ContentView`. When this function is called, it triggers the code
    in its body after the interval time has passed, and in its body is the `playSound`
    function, as we have seen before, which will play the doors’ opening and closing
    sounds.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the floorNumbers function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, the functions that we’ve created have been simple and straightforward,
    with only one or two lines of code each. But to have the floor indicator lights
    working correctly, we need to add some more complexity and a little bit of logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective of this next function is to have the appropriate floor light
    activate when the elevator reaches its intended floor, and deactivate when the
    elevator leaves that floor, as a real working elevator would do. So, let’s add
    the following function underneath the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The function is called `floorNumbers`, and it starts off by checking various
    properties to see whether they are `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The first `if` statement in the function checks to see whether the `floor2`
    property is `false` – if it is `false`, then we want to toggle the `floor1` property
    to its opposite value. We always want to make sure that the `floor1` and `floor2`
    variables have values that are opposite each other, as they represent the different
    floors that the elevator goes to.
  prefs: []
  type: TYPE_NORMAL
- en: After that first `if` statement, there is another `if` statement. This one checks
    to see whether the doors are open; if they are not open, then the code will open
    the doors and play the chimes sound.
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside that `if` statement is another `if` statement, which makes this
    a nested `if` statement. An `if` statement will not run the code in its body if
    the variable it is checking is `false`; it will just move to the next line of
    code in the file. This one is checking to see whether the `goingUp` property is
    `true`; if it is `true`, let’s make `floor2` true and `floor1` `false` because
    we want to light up `floor2`.
  prefs: []
  type: TYPE_NORMAL
- en: This code is all being triggered in the `withAnimation` function, after a delay
    of `4` seconds. That’s the amount of time to wait before turning on the `floor2`
    light and turning off the `floor1` light. The `withAnimation` function is going
    to add a default animation, which is just a fade-in/fade-out animation that looks
    good when turning on and off lights – in our case, the elevator floor lights.
  prefs: []
  type: TYPE_NORMAL
- en: When the elevator reaches the top floor and the button is pressed again to go
    down, the elevator waits `5` seconds, and then the `floor1` light turns on and
    the `floor2` light turns off because the elevator is on its way down. Also, we’re
    going to trigger the open and close door sounds after `8.5` seconds, which is
    enough time for the elevator to reach the bottom floor, at which point the sound
    needs to be playing. Again, we’re doing this in the body of the `withAnimation`
    function, so it adds a default fade animation to the lights being turned on and
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to use similar code for when the `goingUp` variable is not `true`,
    so both states, `true` and `false`, will operate the lights and sounds correctly.
    We do that in an `else if` statement. `else if` offers another alternative to
    the `if` statement that proceeds it, should that `if` statement be `false`. So
    here, `else if` checks whether `goingUp` is `false`; if so, the code turns the
    `floor1` light on after 5 seconds because the elevator is heading down, turns
    the `floor2` light off, and then plays the door opening and closing sounds. Otherwise,
    after 5 seconds, it will do the opposite, turning `floor2` back on and `floor1`
    off.
  prefs: []
  type: TYPE_NORMAL
- en: This is the logic now in place that is used to operate the timers and trigger
    the appropriate sounds at the right moment, by using `if` and `else if` statements.
    Now, the thing with timers is that when a few of them are created, they can overlap
    with each other and cause unintended consequences in the app, so we need to stop
    them before creating new ones.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the stopTimer function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do have a lot of timers firing at various times in the app, and some of these
    timers can overlap with each other in the background and cause unintended side
    effects in the app. We need to stop any timer that has served its purpose so that
    there are no problems. New ones will be created when needed, but they all should
    be stopped after the completion of their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s handle the deactivation of all the timers in a separate function.
    Add the following final function to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This function is called `stopTimer`, and it invalidates all the timers that
    were created and sets them to `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Invalidating a timer effectively stops the timer from ever firing again and
    requests its removal from its run loop. Setting an object to `nil` is equivalent
    to a variable being set to zero; it makes sure that it is completely stopped.
    We will call this method inside the elevator button press and make it the first
    method to be called, thus removing any timers that might still be going.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `DataModel` is complete with all the functions and properties set up to
    be used anywhere in the app; we’re going to use them in `ContentView`. Let’s head
    over there and start to put things together so that we can start to see some results.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the background, a button, and animating the doors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s continue and start to fill out `ContentView` so that we can see the elevator,
    and then we can animate things.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a black background to the whole scene. To do this, add a
    constant at the top just after the `appData` variable to hold some color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside the `body` property, let’s add `ZStack` and call our `backgroundColor`
    constant, setting the color for the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to call the `ElevatorAndPeople` view so that we can make
    it visible in this file. Add the following code, still working inside `ZStack`,
    and in fact, all subsequent code we add into this file will be within this `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we’ve seen before, to show another view in `ContentView`, we simply call
    it here inside the `body` property and pass in the binding variable that we created
    to access the model class. Remember that we use the dollar sign to access binding
    variables, which tells the system that we are bidirectionally connecting to another
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can access our data by using the `appData` observed object, and
    by typing a dot, we can then choose any of the properties or functions within
    the model file. Here, I’m choosing the `doorsOpened` property, and we will be
    toggling that on in a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'And speaking of buttons, let’s add the elevator button right now; we’ll put
    it on the left side of the elevator frame, and when pressed, the doors will open
    and close. Add the following code under the previous line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by using `GeometryReader`. As we have seen, using `GeometryReader`
    will align the views so that they fit perfectly in the scene, and they will resize
    correctly on other size devices by accessing the `geo` constant inside the closure.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a button inside `GeometryReader` – the button will run all the
    code in its body when pressed. We want to check out how the doors work first,
    so I added the code to toggle the `doorsOpened` property when the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at what else we’re doing here with the button code by looking at
    the button closure, where the styling is being done. The code uses the `Circle`
    view to create a circle shape for the button. I gave it a dimension of 10 x 10
    and then added several modifiers to help with the styling:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use the `foregroundColor` modifier for the circle, which is either
    going to be white when the doors are open, or black when they are closed. This
    is achieved by accessing our model’s `ObservedObject` instance, `appData`, and
    calling up the `doorsOpened` property from the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next modifier is `overlay`, where we pass in another `Circle` view. Then,
    by adding the `stroke` modifier, it turns it into a stroked circle (and not a
    filled circle). The color of the stroke is set to red and has a line width of
    `1` point. This stroke will look like a small red ring within the button, as you
    sometimes see in an actual elevator button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we use the `padding` modifier, with a value of `5` points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we use a `background` color modifier, positioned underneath the red ring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a `cornerRadius` value of `30` is added to the black background color
    view, as that is by default a rectangle and we need a rounded shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, all we have to do is position the button exactly where it needs to be on
    the elevator frame, and we can do that with the `position` modifier, passing in
    the `geo` proxy constant, which has the precise size of an iPhone’s screen. Here,
    the code locates the button on the X axis by using the width of the button, and
    divides the `GeometryReader` (the width of the iPhone screen) by 33; this value
    will move the button exactly to the left portion of the elevator frame. Now that
    we have the *X* location for the button, we need the *Y* location. Using the `geo`
    constant again, and dividing `height` by `2`, we can place the button in the middle
    of the frame for the *Y* axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And with that, the button is complete. Let’s try out the animation that we
    have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: The opening doors and button ](img/B18674_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: The opening doors and button'
  prefs: []
  type: TYPE_NORMAL
- en: Press the button and you should see the doors open; if you press the button
    again, the doors will close. And the doors work perfectly, opening and closing
    at a nice pace, and the button changes color when the doors are open.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue and add floor indicator lights to the elevator.
  prefs: []
  type: TYPE_NORMAL
- en: Adding floor indicator lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, elevators have lights, usually at the top of the frame, to let
    people know what floor the elevator is on at any time. Let’s simulate that by
    adding the lights that represent both floors of the elevator, one and two. Add
    the following code directly after the previous line of code we have just written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We start off with `HStack` so that we can put two circle images side by side.
    These are system images, and they have specific names of `1.circle` and `2.circle`.
    The first circle represents the first floor, and the second circle represents
    the second floor.
  prefs: []
  type: TYPE_NORMAL
- en: The color of the first circle light will depend on the `floor1` variable – if
    it’s `true`, it will make the color red; otherwise, if it’s `false`, it will turn
    it black. The opacity of this circle will also depend on the `floor1` variable
    – again, if `true`, the circle will have a fully opaque look; otherwise, we will
    make the opacity `.3`. We use the same code for both circles.
  prefs: []
  type: TYPE_NORMAL
- en: Then, by putting the `position` modifier at the end of `HStack`, we can position
    both circles directly at the top of the frame and keep the position in place by,
    again, using the `geo` proxy. Finally, we will use a font size of `25` for the
    floor numbers.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the floor indicator lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, all we need to do is to call the rest of our functions inside the
    button body, so that when the button is pressed, all the lights and sounds will
    work on timers. So, add the following code to complete the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code accesses the model functions using the `appData` instance and runs
    each one when the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the project and you’ll see that when the button is pressed, the doors
    will open and you’ll see the people inside. Also, notice that the button changes
    color and the indicator for the floor lights up, along with chimes and the sounds
    of doors opening. When the elevator is moving between floors, the doors, lights,
    and sounds will work on their own, at the right times.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: The completed project ](img/B18674_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: The completed project'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a nice animation, and it really simulates the timing of an actual elevator
    very well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now completed our elevator project. Let’s look at what we have done.
  prefs: []
  type: TYPE_NORMAL
- en: We used `GeometryReader` and the proxy constant to add images to the project
    and position them where needed, which will resize all the images in the project
    dynamically, based on the device that displays them, whether iPhones or iPads.
  prefs: []
  type: TYPE_NORMAL
- en: We created `DataModel` to store all the app’s data and functions, and we accessed
    all that data using the `@``ObservableObject` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: We used timers to trigger door and light animations at different moments in
    the scene, making the animations happen on their own. We also added and styled
    a button to change color, when pressed, and we made floor lights turn on and off
    with timers.
  prefs: []
  type: TYPE_NORMAL
- en: The skills learned here can be useful and applied to other projects. For example,
    if you were putting together a game app that has several levels, maybe you could
    incorporate an elevator scene into the game to take the user to another level
    after they have completed a certain skill, or to search for power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: How about a challenge? To take the project further, see whether you can add
    more floors to the scene. Or how about animating the people inside the elevator
    using the same techniques we used with the girl on the swing project? Cut up the
    images and make different parts move in different ways – for example, you could
    cut up the second man’s mouth so it looks like he’s talking when the doors open.
    You could also animate the legs so that they shuffle a little bit inside the elevator,
    or animate their bodies so that they sway a little, basically simulating human
    motion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start putting together a language-learning game and
    animate various aspects of the UI to make the game fluid and interesting. We’ll
    also make the game work across three different languages – English, Spanish, and
    Italian – so that it can appeal to a broad range of language learners.
  prefs: []
  type: TYPE_NORMAL
