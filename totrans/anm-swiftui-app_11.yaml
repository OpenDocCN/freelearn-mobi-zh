- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Animating an Elevator
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画电梯
- en: Welcome to the elevator project! In this one, we’re going to create a working
    elevator, complete with sounds, floor lights, a button, and even some images of
    people inside. We will control the elevator using timers that are available from
    the Swift timer class, as we have done in previous projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到电梯项目！在这个项目中，我们将创建一个带有声音、楼层灯光、按钮，甚至内部人员图像的工作电梯。我们将使用从 Swift timer 类中可用的计时器来控制电梯，就像我们在之前的项目中做的那样。
- en: To bring these elements together, we’ll create a data model using the `@ObservableObject`
    protocol. Apple recommends making a data model as the place to store and process
    the data that the application uses. The data model is also separate from the app’s
    user interface, where the views are created. The reason to keep data and the UI
    separate is that this paradigm fosters modularity and testability. It’s easier
    to find bugs in your logic when the data is not mixed in with UI code. Once we
    have the data model set up, we can then publish that data anywhere in the app
    using publishing wrappers, as we will see later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些元素组合在一起，我们将使用 `@ObservableObject` 协议创建一个数据模型。苹果建议将数据模型作为存储和处理应用程序使用的数据的地方。数据模型也与应用程序的用户界面分开，其中创建视图。保持数据和
    UI 分开的原因是这种范式促进了模块化和可测试性。当数据不与 UI 代码混合时，更容易找到逻辑中的错误。一旦我们设置了数据模型，我们就可以使用发布包装器在应用程序的任何地方发布该数据，就像我们稍后将要看到的那样。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a project and adding a `Binding` variable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目和添加 `Binding` 变量
- en: Assembling the elevator using images and the `GeometryReader` view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图片和 `GeometryReader` 视图组装电梯
- en: Putting people inside the elevator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将人员放入电梯内
- en: Creating a data model and using the `@``ObservableObject` protocol
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据模型并使用 `@ObservableObject` 协议
- en: Adding the data model functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加数据模型函数
- en: Adding the background, a button, and animating the doors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加背景、按钮和动画门
- en: Adding floor indicator lights
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加楼层指示灯
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the resources and finished project on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上下载资源和完成的项目：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: Setting up the project and adding a Binding variable
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目和添加 Binding 变量
- en: Okay, let’s get started! As always, we’ll create a new Xcode project (I’m going
    to call mine `Elevator`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始吧！像往常一样，我们将创建一个新的 Xcode 项目（我将我的项目命名为 `Elevator`）。
- en: Next, in the GitHub repo, take all the images from the `Chapter 11` folder and
    drop them into the Asset Catalog. These images include `doorDrame`, `leftDoor`,
    `rightDoor`, `inside`, `man`, `man2`, `man3`, and `man4`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 GitHub 仓库中，将 `Chapter 11` 文件夹中的所有图片拖放到资产目录中。这些图片包括 `doorDrame`、`leftDoor`、`rightDoor`、`inside`、`man`、`man2`、`man3`
    和 `man4`。
- en: Then, drop the audio files – `doorsOpenClose` and `elevatorChime` – into the
    Project Navigator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将音频文件 – `doorsOpenClose` 和 `elevatorChime` – 放入项目导航器。
- en: 'Next, we’re going to need a new file where we can assemble the elevator and
    add the people, so create a new SwiftUI View file and call it `ElevatorAndPeopleView`.
    We only need one variable in this file, which will be the Binding variable. Let’s
    add it at the top, inside the `ElevatorAndPeopleView` struct:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个新的文件，我们可以在这个文件中组装电梯并添加人员，因此创建一个新的 SwiftUI 视图文件，并将其命名为 `ElevatorAndPeopleView`。我们在这个文件中只需要一个变量，它将是绑定变量。让我们在
    `ElevatorAndPeopleView` 结构体顶部添加它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This variable will control the elevator doors opening and closing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将控制电梯门的开启和关闭。
- en: 'Let’s update the `Previews` so that the code will build without errors. At
    the bottom of the file, alter the `Previews` struct so that it looks like the
    following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `Previews`，以便代码可以无错误地构建。在文件底部，修改 `Previews` 结构体，使其看起来如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code adds a value of `false` to both binding properties, and the project
    once again builds cleanly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将 `false` 的值添加到两个绑定属性中，项目再次干净地构建。
- en: We can now move on to building out the elevator.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续构建电梯。
- en: Assembling the elevator using images and the GeometryReader view
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图片和 GeometryReader 视图组装电梯
- en: The next step is to use some of the images from the Assets catalog and make
    an elevator.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用资产目录中的一些图片来制作一个电梯。
- en: 'We’ll start by adding the inside part of the elevator, which we’ll do by adding
    the following code inside the `body` property:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加电梯的内部部分，这将在 `body` 属性内部添加以下代码来完成：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we have `ZStack` to hold all the views that will follow, and a `GeometryReader`
    view.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `ZStack` 来容纳所有后续视图，以及一个 `GeometryReader` 视图。
- en: The `GeometryReader` view is a container view that defines its content as a
    function of its own size and coordinate space. It’s a little bit like the other
    containers that we have used, such as `VStack` or `HStack`, but the difference
    is that `GeometryReader` has more flexibility because of its proxy parameter,
    the `geo` constant (which you can name whatever you want).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeometryReader` 视图是一个容器视图，它将其内容定义为它自己的大小和坐标空间的一个函数。它有点像我们使用的其他容器，例如 `VStack`
    或 `HStack`，但不同之处在于 `GeometryReader` 由于其代理参数 `geo` 常量（你可以将其命名为任何你想要的）而具有更多的灵活性。'
- en: This proxy will contain information about the container’s size and coordinate
    space, and we can pass that information to the child views inside `GeometryReader`,
    which helps us precisely size and position its children relative to the container.
    The `GeometryReader` view also makes the views within it line up perfectly on
    all iPhone and iPad devices, whatever their size.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此代理将包含有关容器大小和坐标空间的信息，我们可以将此信息传递给 `GeometryReader` 内部的子视图，这有助于我们精确地相对于容器调整其子视图的大小和位置。`GeometryReader`
    视图还确保了所有 iPhone 和 iPad 设备上的视图都能完美对齐，无论其大小如何。
- en: We’re going to use `GeometryReader` to size and position all the parts of the
    elevator, as well as the people inside.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `GeometryReader` 来调整电梯的所有部分以及内部人的大小和位置。
- en: 'Next, let’s add the code that creates the elevator’s interior within `GeometryReader`’s
    body:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `GeometryReader` 的主体内部添加创建电梯内部结构的代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Image` initializer adds the image called `inside` to the scene, and then
    uses the `frame` modifier to set the size of this image to the maximum width and
    maximum height of the screen. It sets this size using the `geo` proxy constant
    we created with the `GeometryReader` view.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image` 初始化器将名为 `inside` 的图像添加到场景中，然后使用 `frame` 修改器将此图像的大小设置为屏幕的最大宽度和最大高度。它使用我们用
    `GeometryReader` 视图创建的 `geo` 代理常量来设置此大小。'
- en: 'The previews now display the inside of the elevator:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 预览现在显示电梯的内部：
- en: '![Figure 11.1: The inside of the elevator ](img/B18674_11_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：电梯内部](img/B18674_11_01.jpg)'
- en: 'Figure 11.1: The inside of the elevator'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：电梯内部
- en: 'Let’s continue assembling the elevator by adding doors next. The doors will
    have animations attached to them so that they slide open and close, and then later,
    we will add timers to them so that they can operate automatically after an initial
    button press. So, continuing inside the `GeometryReader` view, add this code for
    the doors:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续组装电梯，接下来添加门。门将附加动画，以便它们可以滑动打开和关闭，然后稍后我们将为它们添加计时器，以便在按下初始按钮后自动运行。因此，继续在
    `GeometryReader` 视图内部，添加以下代码以设置门：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We put the doors in `HStack` because they need to be positioned side by side.
    The doors are sized using the `frame` modifier and `geo` proxy constant, just
    as we did with the `inside` elevator image. Both doors also get the `offset` modifier
    tacked on to them, which will position them on opposite sides of the screen, opening
    them up fully.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将门放入 `HStack` 中，因为它们需要并排定位。门的大小使用 `frame` 修改器和 `geo` 代理常量设置，就像我们对 `inside`
    电梯图像所做的那样。两扇门也附加了 `offset` 修改器，这将使它们位于屏幕的相对两侧，完全打开。
- en: The process to open and close the doors is handled by the `geo` proxy constant.
    When the `doorsOpened` property becomes `true` for the left door, the `geo` proxy
    constant will move the door on the *x*-axis, to the left and off the screen. The
    amount that the door moves is the width of the door divided by 2\. The reason
    why the left door moves to the left and not the right is that we prefix the `geo`
    constant with a negative sign. When a negative value is used and an object is
    being offset on the *x*-axis, that object will move to the left, whereas a positive
    value will move the object to the right.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 打开门和关闭的过程由 `geo` 代理常量处理。当左侧门的 `doorsOpened` 属性变为 `true` 时，`geo` 代理常量将沿着 *x*-
    轴移动门，向左移动并离开屏幕。门移动的量是门宽度的二分之一。左侧门向左移动而不是向右移动的原因是我们给 `geo` 常量前加了负号。当使用负值并且对象正在沿
    *x*- 轴偏移时，该对象将向左移动，而正值将使对象向右移动。
- en: When the `doorsOpened` property becomes `false`, the `offset` modifier reverses
    the animation and the left door closes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当`doorsOpened`属性变为`false`时，`offset`修改器反转动画，左门关闭。
- en: For the right door, we do the same thing, except a positive value is used for
    the `geo` constant, which moves the door to the right along the *X* axis to open
    it. The values of `4` and -`4` that are used for both doors are included to help
    keep the two doors snug with each other when they are in the closed position.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于右门，我们做同样的事情，只是使用正值的`geo`常量，将门沿*X*轴向右移动以打开它。用于两个门的`4`和`-4`的值包括在内，以帮助在关闭位置时使两扇门紧密贴合。
- en: 'So far, this is what the scene looks like in the `ElevatorAndPeopleView` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是`ElevatorAndPeopleView`文件中的场景看起来像什么：
- en: '![Figure 11.2: The elevator doors ](img/B18674_11_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：电梯门](img/B18674_11_02.jpg)'
- en: 'Figure 11.2: The elevator doors'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：电梯门
- en: We have the elevator’s interior and doors placed together, and we have the animation
    mechanism to operate the doors, but we won’t see any motion happening until we
    call this file inside `ContentView`, and we still have some more assembly to do.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将电梯的内部和门放在一起，并且我们有操作门的动画机制，但直到我们在`ContentView`中调用此文件，我们才看不到任何动作发生，我们还有一些组装工作要做。
- en: 'Let’s put a frame around the outside of the elevator so that it will look like
    the actual elevator, and provide a place to add the elevator’s button. Add the
    following code just after the closing bracket of `HStack`, still within the `GeometryReader`
    view:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在电梯的外侧添加一个框架，使其看起来像实际的电梯，并为添加电梯按钮提供一个地方。在`HStack`的闭合括号之后添加以下代码，仍然在`GeometryReader`视图中：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we are adding the `doorFrame` image to the scene, and as we want the
    frame to go around the entire elevator, we used the same code that we used for
    the `inside` image – we used the `geo` proxy constant again, and by setting the
    image at the maximum width and height, the door frame creates a nice border around
    the elevator doors. This is the result so far:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将`doorFrame`图像添加到场景中，并且因为我们希望框架围绕整个电梯，所以我们使用了与`inside`图像相同的代码——我们再次使用了`geo`代理常量，并通过将图像设置为最大宽度和高度，门框架在电梯门周围创建了一个漂亮的边框。到目前为止的结果如下：
- en: '![Figure 11.3: The elevator frame ](img/B18674_11_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：电梯框架](img/B18674_11_03.jpg)'
- en: 'Figure 11.3: The elevator frame'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：电梯框架
- en: 'Now, let’s add the animation code that will open and close the doors, and control
    the speed and delay of the doors when activated later in the `ContentView`. Its
    only one line of code, and it can be placed right after the closing bracket of
    the `GeometryReader` view:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加打开和关闭门的动画代码，并控制在`ContentView`中激活后的门的速度和延迟。这只有一行代码，可以放在`GeometryReader`视图的闭合括号之后：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we use the `animation` modifier. Then, we pass in a value of `0.09` for
    the `speed` function, which will control how fast the doors open and close. There’s
    also a slight `delay` added of `0.3` seconds, which will delay the door opening
    and closing just enough to keep things in sync with the floor lights, which we
    will add soon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`animation`修改器。然后，我们为`speed`函数传递了`0.09`的值，这将控制门开启和关闭的速度。还增加了一个`0.3`秒的轻微延迟，这将使门开启和关闭的延迟恰到好处，以保持与即将添加的楼层灯的同步。
- en: We’re getting close to finishing using this file – the only parts left to add
    are the people images. Of course, you can put the people code into a separate
    file if you prefer, but since there isn’t a lot of code in this file, it will
    be fine to continue to work here.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近完成使用此文件——剩下要添加的部分只有人图像。当然，如果你愿意，可以将人代码放入一个单独的文件中，但由于此文件中的代码不多，在这里继续工作将没问题。
- en: Putting people inside the elevator
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将人放入电梯中
- en: 'We’ll be adding four characters into our elevator, Let’s start with the `manOne`
    image – add the following code right after the `frame` modifier near the top of
    the file, inside the `GeometryReader` view:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的电梯中添加四个角色，让我们从`manOne`图像开始——在文件的顶部附近`frame`修改器之后添加以下代码，在`GeometryReader`视图中：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we are doing here is bringing the `manOne` image into the scene and then
    adding the correct aspect ratio to the image. Next, we use the `frame` modifier
    to set the size for the image, but what’s different this time is that we use the
    proxy constant of `GeometryReader` to set the size dynamically; when the width
    and height of an image are set this way, the scene will proportionally scale up
    or down on all Apple devices to fit the various screen sizes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是将 `manOne` 图像引入场景，然后为图像添加正确的宽高比。接下来，我们使用 `frame` 修改器设置图像的大小，但这次不同的是，我们使用
    `GeometryReader` 的代理常量来动态设置大小；当以这种方式设置图像的宽度和高度时，场景将在所有苹果设备上按比例放大或缩小以适应各种屏幕尺寸。
- en: I’m trimming off 200 and 300 points for the width and height values so that
    the image will fit nicely inside the elevator. Once we have the images sized and
    positioned the way we want, they will scale dynamically when they appear on different
    devices, so we do need to size and position them initially.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在将宽度和高度值裁剪掉 200 和 300 点，以便图像可以很好地放置在电梯内。一旦我们以我们想要的方式调整了图像的大小和位置，它们将在不同设备上动态缩放，因此我们确实需要最初调整它们的大小和位置。
- en: We will then add some `shadow` with `30` points around the image on the *X*
    and *Y* axes, which gives a nice depth of field for the man when placed inside
    the shiny metal elevator. And finally, we offset the image on the *Y* axis so
    that the feet are on the floor of the elevator.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在图像的 *X* 和 *Y* 轴周围添加一些 `shadow`，大小为 `30` 点，这样当图像放置在闪亮的金属电梯内部时，会给男士一个很好的景深。最后，我们在
    *Y* 轴上偏移图像，使脚位于电梯的地板上。
- en: 'This is how `manOne` looks in our elevator:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `manOne` 在我们的电梯中的样子：
- en: '![Figure 11.4: The first man ](img/B18674_11_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：第一位男士](img/B18674_11_04.jpg)'
- en: 'Figure 11.4: The first man'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：第一位男士
- en: Since we don’t have the animation hooked up yet, to open the door and see inside
    the elevator while we continue to work, you can simply comment out the door code,
    and the door images will disappear.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有连接动画，为了在我们继续工作时打开门并看到电梯内部，你可以简单地注释掉门代码，门图像将消失。
- en: 'The code for the three remaining people is similar to what we’ve just added,
    so I’m going to add the other three images directly under the previous code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的三个人的代码与我们已经添加的类似，所以我将直接在之前的代码下添加其他三个图像：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code for the `manTwo`, `manThree`, and `manFour` images are largely the
    same as the code for the `manOne` image, just with slightly different values for
    the `frame` modifier, the `offset` modifier, and their positions in the elevator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`manTwo`、`manThree` 和 `manFour` 图片的代码与 `manOne` 图片的代码基本相同，只是 `frame` 修改器、`offset`
    修改器以及它们在电梯中的位置略有不同。'
- en: Regarding the `manTwo` code, I’m adding a rotation effect to this image because
    I want to turn this image a little bit toward the left, as he appears to be talking,
    and it looks a little bit better if we position him in the direction of the person
    on his right. This is accomplished with the `rotation3DEffect` modifier; simply
    turning him `20` degrees on the *Y* axis is enough to point him in the right direction
    of the other image.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `manTwo` 代码，我在这个图像上添加了一个旋转效果，因为我想要将这个图像稍微向左转，因为他看起来像是在说话，如果我们将他定位在右边人的方向，看起来会更好。这是通过
    `rotation3DEffect` 修改器实现的；只需将他在 *Y* 轴上旋转 `20` 度就足以指向其他图像的正确方向。
- en: 'Here is our elevator full of people:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的电梯，里面装满了人：
- en: '![Figure 11.5: The rest of the people ](img/B18674_11_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：其他的人](img/B18674_11_05.jpg)'
- en: 'Figure 11.5: The rest of the people'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：其他的人
- en: And that finishes off this file. We can now move on to creating the data model
    file and adding the necessary functions for the timers and sound effects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，这个文件就完成了。我们现在可以继续创建数据模型文件，并添加定时器和音效所需的功能。
- en: Creating a data model and using the ObservableObject protocol
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据模型和使用 `ObservableObject` 协议
- en: Let’s create a new file – although this time, choose the `DataModel`. In this
    file, we will put the data that we can access from `ContentView` later, using
    the `@ObservableObject` protocol.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件——尽管这次，选择 `DataModel`。在这个文件中，我们将放置我们稍后可以通过 `ContentView` 访问的数据，使用
    `@ObservableObject` 协议。
- en: 'To use this protocol, we first need to import the SwiftUI framework:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此协议，我们首先需要导入 SwiftUI 框架：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we need a class to hold all the data, and we also need to make the class
    conform to the `@ObservableObject` protocol, so let’s add that now. You can name
    the class anything you want, but many developers like to name the class the same
    name as the file it is in, so we will do the same, naming the class `DataModel`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个类来保存所有数据，并且我们还需要使这个类符合 `@ObservableObject` 协议，所以现在让我们添加它。你可以给这个类起任何名字，但许多开发者喜欢将类的名字与它所在的文件名相同，所以我们将这样做，将类命名为
    `DataModel`：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s understand what `@``ObservableObject` does.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 `@ObservableObject` 协议的作用。
- en: In previous projects, we used the `@State` property to pass data to the views
    and display them to the user, but this is limited because the `@State` property
    wrapper can only store values that control the states of a single view; we can’t
    make `@State` properties and pass them around to other structs, as they work in
    only one struct.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的项目中，我们使用 `@State` 属性将数据传递到视图并显示给用户，但这是有限的，因为 `@State` 属性包装器只能存储控制单个视图状态的值；我们不能创建
    `@State` 属性并将它们传递到其他结构体中，因为它们只在单个结构体中工作。
- en: We also used the `@Binding` property wrapper, which helped to re-establish the
    connection to other views or structs with a bidirectional link that the `@State`
    property could not provide. However, this would not work globally to hold and
    pass data to all files in the app.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 `@Binding` 属性包装器，它有助于通过 `@State` 属性无法提供的双向链接重新建立与其他视图或结构体的连接。然而，这不会在全局范围内工作，以保留和传递数据到应用程序中的所有文件。
- en: So, what we need now is an object that can globally control all the app’s data
    and its states and update the views accordingly when there are any changes to
    the properties, either by user input or changes made by other means, such as downloads
    from a server or the web.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在需要一个可以全局控制应用程序的所有数据和状态的对象，并在属性有任何更改时（无论是通过用户输入还是通过其他方式，如从服务器或网络下载）相应地更新视图。
- en: This is where the `@ObservableObject` protocol comes in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `@ObservableObject` 协议发挥作用的地方。
- en: 'The `@ObservableObject` protocol defines three distinct property wrappers:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ObservableObject` 协议定义了三个不同的属性包装器：'
- en: An `@StateObject` property wrapper that listens for changes in `@ObservableObject`
    and receives the new values
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `@StateObject` 属性包装器，它监听 `@ObservableObject` 的变化并接收新的值
- en: An `@ObservedObject` property wrapper that listens for changes in the `@StateObject`
    property and receives those new values
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `@ObservedObject` 属性包装器，它监听 `@StateObject` 属性的变化并接收那些新值
- en: An `@Published` property wrapper that reports all the changes to the system
    and publishes those changes to the view app-wide
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `@Published` 属性包装器，它向系统报告所有更改并将这些更改发布到全局视图
- en: The advantage of using `@ObservableObject` over the `@State` property wrapper
    is, again, that we can update more than one view with any changes, and the state
    can be checked from views anywhere in the app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@ObservableObject` 而不是 `@State` 属性包装器的优势在于，我们可以更新多个视图以反映任何更改，并且状态可以在应用程序的任何地方进行检查。
- en: 'Now, that’s a lot to take in, but it will become clearer as we build out the
    data model. We already have the `DataModel` class created, and it conforms to
    the `@ObservableObject` protocol – that’s the first step. Next, we want to declare
    the properties we need, prefixing them with the `@Published` property wrapper
    so that they will hold the various data and states and be published to the views
    when needed. Let’s do that now by adding the following properties inside the `DataModel`
    class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要吸收的信息量很大，但随着我们构建数据模型，它将变得更加清晰。我们已经有了一个名为 `DataModel` 的类，并且它符合 `@ObservableObject`
    协议——这是第一步。接下来，我们想要声明所需的属性，并在它们前面加上 `@Published` 属性包装器，以便它们可以保存各种数据和状态，并在需要时将它们发布到视图中。现在让我们通过在
    `DataModel` 类内部添加以下属性来实现这一点：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are several properties here that hopefully are self-explanatory. The four
    Booleans will be used to let us know when the doors of the elevator are opened,
    whether floor 1 or floor 2 is the active floor, and whether the elevator is going
    up or going down. The timers will control the timing of the doors opening and
    closing, as well as when to play the floor chimes and when to play the door opening
    and closing sounds.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个属性，希望它们是自解释的。四个布尔值将用于告诉我们电梯的门何时打开，是第1层还是第2层是活动楼层，以及电梯是上升还是下降。定时器将控制门的开关时间，以及何时播放楼层铃声和门开关声音。
- en: With the properties listed, we next need a way to access them from other parts
    of the app. This is done by going up the hierarchy to the `Root` view and injecting
    an instance of the data model there – the `Root` view is the entry point of the
    app, the point from which the app starts up.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据列出的属性，我们接下来需要一种方法来从应用的其它部分访问它们。这是通过向上到`Root`视图并注入数据模型的一个实例来完成的——`Root`视图是应用的入口点，应用从这里启动。
- en: 'Let’s go into the `App.swift` file in the Project navigator and create an instance
    of the `DataModel` class there inside the struct, sending a reference to `ContentView`,
    like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入项目导航器中的`App.swift`文件，并在结构体内部创建`DataModel`类的实例，发送对`ContentView`的引用，如下所示：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As I mentioned, this file is the entry point for our app, as denoted by the
    `@main` wrapper at the top, and it creates the `Root` view window and takes care
    of creating all the objects we need for the app to start up. Since this file is
    at the top of the hierarchy, it’s the perfect place to create the `DataModel`
    instance and pass it into the `Root` view, `ContentView`, so it can be available
    app-wide.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，此文件是应用的入口点，如顶部标记的`@main`包装器所示，它创建`Root`视图窗口并负责创建应用启动所需的所有对象。由于此文件位于层次结构的顶部，它是创建`DataModel`实例并将其传递给`Root`视图、`ContentView`以使其在应用范围内可用的完美位置。
- en: The `DataModel` instance is called `appData`, and it gets prefixed with the
    `@StateObject` property wrapper – this wrapper will listen for changes in `@ObservableObject`
    and receive any new values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataModel`实例称为`appData`，并使用`@StateObject`属性包装器进行前缀——此包装器将监听`@ObservableObject`中的更改并接收任何新值。'
- en: Next, the `@StateObject` property wrapper that we called `appData` is injected
    into `ContentView` by passing it into the `ContentView` initializer to, again,
    make the data in the data model available throughout the app.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们称为`appData`的`@StateObject`属性包装器通过将其传递给`ContentView`初始化器注入到`ContentView`中，再次使数据模型中的数据在整个应用中可用。
- en: Now, to complete the connection from our data here, and from any view in the
    project, all we have to do is include an `@ObservedObject` property inside every
    view that we want to have a connection to this model. The job of `@ObservedObject`
    is to listen for changes in the `@StateObject` property and receive those new
    values so that it can update the views.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成从我们这里的数据以及项目中的任何视图的数据连接，我们只需在每个我们想要与该模型建立连接的视图中包含一个`@ObservedObject`属性。`@ObservedObject`的职责是监听`@StateObject`属性中的更改并接收这些新值，以便它可以更新视图。
- en: 'Let’s now go into `ContentView` and add an `@ObservedObject` property to complete
    the bidirectional binding between the `AppData` class, which holds all the data,
    and `ContentView`, which is in charge of displaying all of that data on a screen
    to a user. Add the following property to the `ContentView` struct:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入`ContentView`并添加一个`@ObservedObject`属性，以完成`AppData`类（它包含所有数据）和`ContentView`（它负责在屏幕上向用户显示所有这些数据）之间的双向绑定。将以下属性添加到`ContentView`结构体中：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we have an instance of `DataModel`, which will monitor all the data for
    us; if there are any changes to the data, `ObservedObject` will know about it
    and update the views accordingly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个`DataModel`的实例，它将为我们监控所有数据；如果数据有任何更改，`ObservedObject`将知道并相应地更新视图。
- en: Also, if we create more files and need to access the data model from those new
    files, all we have to do is create another instance of the data model and use
    it in those files too, like we did with the `appData` instance here, and they
    will have the same access and be updated with any changes that occur.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们创建了更多文件并需要从这些新文件中访问数据模型，我们只需创建数据模型的一个新实例并在这些文件中使用它，就像我们在这里使用`appData`实例一样，它们将具有相同的访问权限，并且会随着任何更改而更新。
- en: We have the instance of the data model ready to be used in `ContentView`, but
    now we need to add some functions that will take care of setting different timers,
    which will trigger the doors to open and close, trigger the floor number lights,
    and also trigger the sound effects at the right moments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了`ContentView`中使用的`DataModel`实例，但现在我们需要添加一些函数来设置不同的计时器，这些计时器将触发门的开关，触发楼层灯光，并在适当的时候触发声音效果。
- en: Adding the data model functions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据模型函数
- en: 'In this section, we will create five functions, and each one oversees a specific
    task:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建五个函数，每个函数负责一个特定任务：
- en: A function to open and close the doors
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于打开和关闭门的函数
- en: A function to play the chimes bell sound that signifies the elevator has reached
    its destination
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示电梯已到达目的地的铃声声音的播放函数
- en: A function to play the door opening and closing sounds
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放开门和关门声音的函数
- en: A function to light up the floor indicator lights
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮楼层指示灯的函数
- en: A function to stop all the timers
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止所有计时器的函数
- en: Let’s start by creating the function that will open and close the doors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个打开和关闭门的函数。
- en: Adding the doorOpenTimer function
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`doorOpenTimer`函数
- en: 'Come back into the `DataModel` class, and directly underneath the last variable,
    add the following function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`DataModel`类，并在最后一个变量直接下方添加以下函数：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is called `openDoors`, and what this does is set the `doorsOpenTimer`
    object to a value specified by the `scheduledTimer` method. The `scheduledTimer`
    method will execute the code in its block after a certain amount of time has elapsed
    – in this case, 8 seconds.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被命名为`openDoors`，它所做的是将`doorsOpenTimer`对象设置为`scheduledTimer`方法指定的值。`scheduledTimer`方法将在一定时间后执行其代码块中的代码——在这种情况下，8秒。
- en: The `scheduledTimerWithInterval` function also has a `repeats` parameter, which
    lets you repeat the triggering of the code in its body. In the code, we set the
    `repeats` parameter to `false`, as we only want the code in its body to be triggered
    when the elevator button is pressed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheduledTimerWithInterval`函数还有一个`repeats`参数，它允许你重复触发其体内的代码。在代码中，我们将`repeats`参数设置为`false`，因为我们只想在电梯按钮被按下时触发其体内的代码。'
- en: The code that it will trigger will involve toggling the `doorsOpened` property
    to its opposite value. We’re going to add a button to the elevator, and we will
    call this function when that button is pressed. When it’s pressed, if the `doorsOpened`
    property is `true`, it will be toggled to `false`, and vice versa, thus opening
    and closing the doors as needed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将触发的代码将涉及切换`doorsOpened`属性到其相反值。我们将在电梯上添加一个按钮，并在按下该按钮时调用这个函数。当按下时，如果`doorsOpened`属性是`true`，它将被切换到`false`，反之亦然，从而根据需要打开和关闭门。
- en: Adding the playChimeSound function
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`playChimeSound`函数
- en: 'Let’s create another function that will trigger the chimes sound effect; this
    sound signifies the elevator has reached its destination and will play just before
    the doors open. Add the following function, directly underneath the previous one:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个函数，该函数将触发铃声声音效果；这个声音表示电梯已到达目的地，将在门打开前播放。在之前的函数下方添加以下函数：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function is called `playChimeSound`, and it is like the previous function
    we just added.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被命名为`playChimeSound`，它和之前我们添加的函数类似。
- en: When the function is called, it sets the `chimesTimer` property to a value specified
    by the `scheduledTimer` method, which is `5.5` seconds. After 5.5 seconds have
    elapsed, the `scheduledTimer` method will call the `playSound` function within
    its body.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，它将`chimesTimer`属性设置为`scheduledTimer`方法指定的值，即`5.5`秒。在5.5秒后，`scheduledTimer`方法将在其体内调用`playSound`函数。
- en: The `playSound` function has two parameters – one for the name of the sound
    file that we imported into the project, and the other for the file’s extension
    type. However, we haven’t created this function yet, so we will get an error!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`playSound`函数有两个参数——一个用于我们导入到项目中的声音文件名，另一个用于文件的扩展类型。然而，我们还没有创建这个函数，所以我们会得到一个错误！'
- en: 'To fix this, we need to create a separate Swift file, which we will call `PlaySound`.
    Then, add the following code to this file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要创建一个单独的Swift文件，我们将称之为`PlaySound`。然后，将以下代码添加到这个文件中：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we’ve done in previous projects, we imported the `AVFoundation` framework
    to have access to the audio classes and methods we need. Next, we created an `audio
    player` instance and then added the `playSound` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在之前的项目中做的那样，我们导入了`AVFoundation`框架以访问我们需要的音频类和方法。接下来，我们创建了一个`audio player`实例，然后添加了`playSound`函数。
- en: You should be familiar with how this function works; all we need to do is call
    this function in any file in which we need to have sound playing, passing the
    name of the sound file into its `sound` parameter and its extension type into
    its `type` parameter. Now, the `playChimeSound` function should play error-free.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉这个函数的工作方式；我们只需要在任何需要播放声音的文件中调用这个函数，将声音文件名传递给其`sound`参数，将扩展类型传递给其`type`参数。现在，`playChimeSound`函数应该能够无错误地播放。
- en: Now, let’s head back to the `DataModel` class and continue to add the rest of
    the functions that we need.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`DataModel`类，并继续添加我们需要的其余函数。
- en: Adding the playDoorOpenCloseSound function
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 playDoorOpenCloseSound 函数
- en: 'When an elevator door opens and closes, it makes a distinctive sound, similar
    to a mechanical whooshing sound. We want to add that sound to the project, and
    we’ll need a function that can trigger it at the right moment. Let’s do that right
    after the previous function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当电梯门开启和关闭时，会发出特有的声音，类似于机械的呼啸声。我们想在项目中添加这个声音，并且我们需要一个函数能够在正确的时间触发它。让我们在之前的函数之后立即做这件事：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`playDoorOpenCloseSound` is a function in which we set the `doorSoundTimer`
    property to a value specified by the `scheduledTimer` method, and the value it
    will use for the interval parameter will be passed into this function when it
    gets called in `ContentView`. When this function is called, it triggers the code
    in its body after the interval time has passed, and in its body is the `playSound`
    function, as we have seen before, which will play the doors’ opening and closing
    sounds.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`playDoorOpenCloseSound` 是一个函数，我们在这个函数中将 `doorSoundTimer` 属性设置为 `scheduledTimer`
    方法指定的值，并且当它在 `ContentView` 中被调用时，它将使用作为间隔参数的值传递到这个函数中。当这个函数被调用时，在经过间隔时间后，它会触发其体内的代码，其体内是之前见过的
    `playSound` 函数，这个函数将播放门的开启和关闭声音。'
- en: Adding the floorNumbers function
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 floorNumbers 函数
- en: Up until this point, the functions that we’ve created have been simple and straightforward,
    with only one or two lines of code each. But to have the floor indicator lights
    working correctly, we need to add some more complexity and a little bit of logic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的函数都相对简单直接，每个函数只有一到两行代码。但是为了让楼层指示灯正常工作，我们需要增加一些复杂性和一点逻辑。
- en: 'The objective of this next function is to have the appropriate floor light
    activate when the elevator reaches its intended floor, and deactivate when the
    elevator leaves that floor, as a real working elevator would do. So, let’s add
    the following function underneath the previous one:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的目标是在电梯到达目标楼层时激活适当的楼层灯光，并在电梯离开该楼层时关闭灯光，就像一个真正工作的电梯那样。所以，让我们在之前的函数下面添加以下函数：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The function is called `floorNumbers`, and it starts off by checking various
    properties to see whether they are `true` or `false`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被命名为 `floorNumbers`，它一开始会检查各种属性以确定它们是 `true` 还是 `false`。
- en: The first `if` statement in the function checks to see whether the `floor2`
    property is `false` – if it is `false`, then we want to toggle the `floor1` property
    to its opposite value. We always want to make sure that the `floor1` and `floor2`
    variables have values that are opposite each other, as they represent the different
    floors that the elevator goes to.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的第一个 `if` 语句检查 `floor2` 属性是否为 `false` —— 如果是 `false`，那么我们希望将 `floor1` 属性切换到其相反值。我们总是想确保
    `floor1` 和 `floor2` 变量的值是相反的，因为它们代表电梯到达的不同楼层。
- en: After that first `if` statement, there is another `if` statement. This one checks
    to see whether the doors are open; if they are not open, then the code will open
    the doors and play the chimes sound.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 `if` 语句之后，还有一个 `if` 语句。这个语句检查门是否开启；如果门没有开启，那么代码将打开门并播放铃声。
- en: Then, inside that `if` statement is another `if` statement, which makes this
    a nested `if` statement. An `if` statement will not run the code in its body if
    the variable it is checking is `false`; it will just move to the next line of
    code in the file. This one is checking to see whether the `goingUp` property is
    `true`; if it is `true`, let’s make `floor2` true and `floor1` `false` because
    we want to light up `floor2`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `if` 语句内部还有一个 `if` 语句，这使得它成为一个嵌套的 `if` 语句。如果一个 `if` 语句检查的变量是 `false`，它将不会运行其体内的代码；它只会移动到文件中的下一行代码。这个
    `if` 语句检查 `goingUp` 属性是否为 `true`；如果是 `true`，那么我们将 `floor2` 设置为 `true`，`floor1`
    设置为 `false`，因为我们想要点亮 `floor2`。
- en: This code is all being triggered in the `withAnimation` function, after a delay
    of `4` seconds. That’s the amount of time to wait before turning on the `floor2`
    light and turning off the `floor1` light. The `withAnimation` function is going
    to add a default animation, which is just a fade-in/fade-out animation that looks
    good when turning on and off lights – in our case, the elevator floor lights.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码都是在 `withAnimation` 函数中触发的，延迟 `4` 秒。这是在打开 `floor2` 灯光并关闭 `floor1` 灯光之前需要等待的时间。`withAnimation`
    函数将添加一个默认动画，这是一个淡入淡出动画，当打开和关闭灯光时看起来很好——在我们的案例中，是电梯楼层灯光。
- en: When the elevator reaches the top floor and the button is pressed again to go
    down, the elevator waits `5` seconds, and then the `floor1` light turns on and
    the `floor2` light turns off because the elevator is on its way down. Also, we’re
    going to trigger the open and close door sounds after `8.5` seconds, which is
    enough time for the elevator to reach the bottom floor, at which point the sound
    needs to be playing. Again, we’re doing this in the body of the `withAnimation`
    function, so it adds a default fade animation to the lights being turned on and
    off.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当电梯到达顶层并且再次按下按钮以向下行驶时，电梯会等待`5`秒，然后`floor1`灯亮起，`floor2`灯熄灭，因为电梯正在向下行驶。此外，我们将在`8.5`秒后触发开门和关门的声音，这足以让电梯到达底层，此时声音需要播放。同样，我们是在`withAnimation`函数的主体中这样做，因此它为开关灯添加了默认的淡入淡出动画。
- en: Next, we need to use similar code for when the `goingUp` variable is not `true`,
    so both states, `true` and `false`, will operate the lights and sounds correctly.
    We do that in an `else if` statement. `else if` offers another alternative to
    the `if` statement that proceeds it, should that `if` statement be `false`. So
    here, `else if` checks whether `goingUp` is `false`; if so, the code turns the
    `floor1` light on after 5 seconds because the elevator is heading down, turns
    the `floor2` light off, and then plays the door opening and closing sounds. Otherwise,
    after 5 seconds, it will do the opposite, turning `floor2` back on and `floor1`
    off.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`goingUp`变量不是`true`的情况使用类似的代码，这样两种状态，`true`和`false`，都能正确地操作灯光和声音。我们在`else
    if`语句中这样做。`else if`为它前面的`if`语句提供了一个备选方案，如果那个`if`语句是`false`的话。所以在这里，`else if`检查`goingUp`是否为`false`；如果是，代码将在5秒后打开`floor1`灯，因为电梯正在向下行驶，关闭`floor2`灯，然后播放开门和关门的声音。否则，在5秒后，它将执行相反的操作，重新打开`floor2`并关闭`floor1`。
- en: This is the logic now in place that is used to operate the timers and trigger
    the appropriate sounds at the right moment, by using `if` and `else if` statements.
    Now, the thing with timers is that when a few of them are created, they can overlap
    with each other and cause unintended consequences in the app, so we need to stop
    them before creating new ones.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正在使用的逻辑是用于操作计时器并在正确时刻触发适当的音效，这是通过使用`if`和`else if`语句实现的。现在，关于计时器的问题在于，当创建几个计时器时，它们可能会相互重叠，并在应用中引起意外的后果，因此我们需要在创建新的计时器之前停止它们。
- en: Adding the stopTimer function
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加停止计时器函数
- en: We do have a lot of timers firing at various times in the app, and some of these
    timers can overlap with each other in the background and cause unintended side
    effects in the app. We need to stop any timer that has served its purpose so that
    there are no problems. New ones will be created when needed, but they all should
    be stopped after the completion of their tasks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实在应用中有很多计时器在不同的时间触发，其中一些计时器在后台可能会相互重叠，并在应用中引起意外的副作用。我们需要停止任何已经完成其任务的计时器，以确保没有问题。在需要时将创建新的计时器，但它们在完成任务后都应该被停止。
- en: 'So, let’s handle the deactivation of all the timers in a separate function.
    Add the following final function to the file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在单独的函数中处理所有计时器的停用。将以下最终函数添加到文件中：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function is called `stopTimer`, and it invalidates all the timers that
    were created and sets them to `nil`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数名为`stopTimer`，它使所有创建的计时器无效，并将它们设置为`nil`。
- en: Invalidating a timer effectively stops the timer from ever firing again and
    requests its removal from its run loop. Setting an object to `nil` is equivalent
    to a variable being set to zero; it makes sure that it is completely stopped.
    We will call this method inside the elevator button press and make it the first
    method to be called, thus removing any timers that might still be going.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无效化一个计时器实际上会阻止计时器再次触发，并请求将其从其运行循环中移除。将对象设置为`nil`相当于将变量设置为零；它确保它被完全停止。我们将在电梯按钮按下时调用此方法，并使其成为第一个调用的方法，从而移除可能仍在运行的任何计时器。
- en: Now, `DataModel` is complete with all the functions and properties set up to
    be used anywhere in the app; we’re going to use them in `ContentView`. Let’s head
    over there and start to put things together so that we can start to see some results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`DataModel`已经完成，所有函数和属性都已设置好，可以在应用的任何地方使用；我们将在`ContentView`中使用它们。让我们转到那里，开始将这些事情组合起来，以便我们可以开始看到一些结果。
- en: Adding the background, a button, and animating the doors
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加背景、按钮和动画门
- en: Let’s continue and start to fill out `ContentView` so that we can see the elevator,
    and then we can animate things.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并开始填充 `ContentView`，以便我们可以看到电梯，然后我们可以进行动画处理。
- en: 'First, we will add a black background to the whole scene. To do this, add a
    constant at the top just after the `appData` variable to hold some color:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为整个场景添加一个黑色背景。为此，在 `appData` 变量之后添加一个常量来保存一些颜色：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, inside the `body` property, let’s add `ZStack` and call our `backgroundColor`
    constant, setting the color for the screen:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `body` 属性内部，让我们添加 `ZStack` 并调用我们的 `backgroundColor` 常量，为屏幕设置颜色：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will need to call the `ElevatorAndPeople` view so that we can make
    it visible in this file. Add the following code, still working inside `ZStack`,
    and in fact, all subsequent code we add into this file will be within this `ZStack`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要调用 `ElevatorAndPeople` 视图，以便我们可以在文件中使其可见。在 `ZStack` 内添加以下代码，实际上，我们将在此文件中添加的所有后续代码都将位于此
    `ZStack` 内：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we’ve seen before, to show another view in `ContentView`, we simply call
    it here inside the `body` property and pass in the binding variable that we created
    to access the model class. Remember that we use the dollar sign to access binding
    variables, which tells the system that we are bidirectionally connecting to another
    view.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，要显示 `ContentView` 中的另一个视图，我们只需在这里的 `body` 属性中调用它，并传入我们创建的用于访问模型类的绑定变量。记住，我们使用美元符号来访问绑定变量，这告诉系统我们正在双向连接到另一个视图。
- en: Note that we can access our data by using the `appData` observed object, and
    by typing a dot, we can then choose any of the properties or functions within
    the model file. Here, I’m choosing the `doorsOpened` property, and we will be
    toggling that on in a button.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过使用 `appData` 观察对象，并通过输入一个点来访问模型文件中的任何属性或函数。在这里，我选择了 `doorsOpened` 属性，我们将在按钮中切换该属性。
- en: 'And speaking of buttons, let’s add the elevator button right now; we’ll put
    it on the left side of the elevator frame, and when pressed, the doors will open
    and close. Add the following code under the previous line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关于按钮，我们现在就添加电梯按钮；我们将它放在电梯框架的左侧，当按下时，门将打开和关闭。在上一行下添加以下代码：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code starts off by using `GeometryReader`. As we have seen, using `GeometryReader`
    will align the views so that they fit perfectly in the scene, and they will resize
    correctly on other size devices by accessing the `geo` constant inside the closure.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先使用 `GeometryReader`。正如我们所见，使用 `GeometryReader` 将使视图对齐，以便它们完美地适应场景，并且它们将通过访问闭包内的
    `geo` 常量在具有其他尺寸的设备上正确调整大小。
- en: We then create a button inside `GeometryReader` – the button will run all the
    code in its body when pressed. We want to check out how the doors work first,
    so I added the code to toggle the `doorsOpened` property when the button is pressed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在 `GeometryReader` 内创建一个按钮——当按钮被按下时，它将运行其体内的所有代码。我们首先想查看门是如何工作的，所以我添加了当按钮被按下时切换
    `doorsOpened` 属性的代码。
- en: 'Let’s look at what else we’re doing here with the button code by looking at
    the button closure, where the styling is being done. The code uses the `Circle`
    view to create a circle shape for the button. I gave it a dimension of 10 x 10
    and then added several modifiers to help with the styling:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看按钮代码中我们还做了什么，通过查看进行样式设置的按钮闭包。代码使用 `Circle` 视图创建按钮的圆形形状。我给它设置了 10 x 10 的尺寸，然后添加了几个修饰符来帮助进行样式设置：
- en: First, we use the `foregroundColor` modifier for the circle, which is either
    going to be white when the doors are open, or black when they are closed. This
    is achieved by accessing our model’s `ObservedObject` instance, `appData`, and
    calling up the `doorsOpened` property from the model.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `foregroundColor` 修饰符为圆形设置颜色，当门打开时将是白色，当门关闭时将是黑色。这是通过访问我们的模型实例 `appData`
    的 `ObservedObject` 并从模型中调用 `doorsOpened` 属性来实现的。
- en: The next modifier is `overlay`, where we pass in another `Circle` view. Then,
    by adding the `stroke` modifier, it turns it into a stroked circle (and not a
    filled circle). The color of the stroke is set to red and has a line width of
    `1` point. This stroke will look like a small red ring within the button, as you
    sometimes see in an actual elevator button.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个修饰符是 `overlay`，我们传递另一个 `Circle` 视图。然后，通过添加 `stroke` 修饰符，它变成了一个描边圆形（而不是填充圆形）。描边的颜色设置为红色，线宽为
    `1` 点。这个描边将看起来像按钮中的一个红色小环，就像你在实际的电梯按钮中有时看到的那样。
- en: Then, we use the `padding` modifier, with a value of `5` points.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `padding` 修饰符，值为 `5` 点。
- en: Then, we use a `background` color modifier, positioned underneath the red ring.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用一个`background`颜色修饰符，位于红色环的下方。
- en: Finally, a `cornerRadius` value of `30` is added to the black background color
    view, as that is by default a rectangle and we need a rounded shape.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在黑色背景颜色视图中添加一个`cornerRadius`值为`30`，因为默认情况下它是一个矩形，我们需要一个圆角形状。
- en: Now, all we have to do is position the button exactly where it needs to be on
    the elevator frame, and we can do that with the `position` modifier, passing in
    the `geo` proxy constant, which has the precise size of an iPhone’s screen. Here,
    the code locates the button on the X axis by using the width of the button, and
    divides the `GeometryReader` (the width of the iPhone screen) by 33; this value
    will move the button exactly to the left portion of the elevator frame. Now that
    we have the *X* location for the button, we need the *Y* location. Using the `geo`
    constant again, and dividing `height` by `2`, we can place the button in the middle
    of the frame for the *Y* axis.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们只需要将按钮精确地放置在电梯框架所需的位置，我们可以使用`position`修饰符来实现，传递`geo`代理常量，它具有iPhone屏幕的精确尺寸。在这里，代码通过使用按钮的宽度在X轴上定位按钮，并将`GeometryReader`（iPhone屏幕的宽度）除以33；这个值将按钮精确地移动到电梯框架的左侧。现在我们已经有了按钮的X位置，我们需要Y位置。再次使用`geo`常量，并将`height`除以2，我们可以在Y轴的框架中间放置按钮。
- en: 'And with that, the button is complete. Let’s try out the animation that we
    have so far:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，按钮就完成了。让我们尝试到目前为止的动画：
- en: '![Figure 11.6: The opening doors and button ](img/B18674_11_06.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6：开门和按钮](img/B18674_11_06.jpg)'
- en: 'Figure 11.6: The opening doors and button'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：开门和按钮
- en: Press the button and you should see the doors open; if you press the button
    again, the doors will close. And the doors work perfectly, opening and closing
    at a nice pace, and the button changes color when the doors are open.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按下按钮，你应该看到门打开；如果你再次按下按钮，门将关闭。而且门工作得非常完美，以合适的速度打开和关闭，当门打开时按钮会改变颜色。
- en: Let’s continue and add floor indicator lights to the elevator.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，并在电梯中添加楼层指示灯。
- en: Adding floor indicator lights
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加楼层指示灯
- en: 'As we know, elevators have lights, usually at the top of the frame, to let
    people know what floor the elevator is on at any time. Let’s simulate that by
    adding the lights that represent both floors of the elevator, one and two. Add
    the following code directly after the previous line of code we have just written:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，电梯通常在框架顶部有灯光，以让人们在任何时候都知道电梯在哪个楼层。让我们通过添加代表电梯一、二楼的灯光来模拟这一点。将以下代码直接添加到我们刚刚写的上一行代码之后：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We start off with `HStack` so that we can put two circle images side by side.
    These are system images, and they have specific names of `1.circle` and `2.circle`.
    The first circle represents the first floor, and the second circle represents
    the second floor.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`HStack`开始，这样我们就可以将两个圆形图像并排放置。这些是系统图像，它们有特定的名称`1.circle`和`2.circle`。第一个圆代表第一层，第二个圆代表第二层。
- en: The color of the first circle light will depend on the `floor1` variable – if
    it’s `true`, it will make the color red; otherwise, if it’s `false`, it will turn
    it black. The opacity of this circle will also depend on the `floor1` variable
    – again, if `true`, the circle will have a fully opaque look; otherwise, we will
    make the opacity `.3`. We use the same code for both circles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个圆灯的颜色将取决于`floor1`变量——如果它是`true`，它将使颜色变红；否则，如果它是`false`，它将变成黑色。这个圆的透明度也将取决于`floor1`变量——再次，如果`true`，圆将具有完全不透明的外观；否则，我们将透明度设置为`.3`。我们对两个圆使用相同的代码。
- en: Then, by putting the `position` modifier at the end of `HStack`, we can position
    both circles directly at the top of the frame and keep the position in place by,
    again, using the `geo` proxy. Finally, we will use a font size of `25` for the
    floor numbers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在`HStack`的末尾放置`position`修饰符，我们可以将两个圆直接放置在框架顶部，并通过再次使用`geo`代理保持位置不变。最后，我们将楼层数字的字体大小设置为`25`。
- en: That completes the floor indicator lights.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了楼层指示灯。
- en: 'Finally, all we need to do is to call the rest of our functions inside the
    button body, so that when the button is pressed, all the lights and sounds will
    work on timers. So, add the following code to complete the project:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要在按钮体内调用剩余的函数，这样当按钮被按下时，所有的灯光和声音都会在定时器上工作。因此，添加以下代码以完成项目：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code accesses the model functions using the `appData` instance and runs
    each one when the button is pressed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`appData`实例访问模型功能，并在按钮按下时运行每个功能。
- en: Now, run the project and you’ll see that when the button is pressed, the doors
    will open and you’ll see the people inside. Also, notice that the button changes
    color and the indicator for the floor lights up, along with chimes and the sounds
    of doors opening. When the elevator is moving between floors, the doors, lights,
    and sounds will work on their own, at the right times.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目，你会看到当按下按钮时，门会打开，你会看到里面的人。注意，按钮会改变颜色，楼层指示灯亮起，同时伴有铃声和门开启的声音。当电梯在楼层之间移动时，门、灯光和声音将自行在正确的时间工作。
- en: '![Figure 11.7: The completed project ](img/B18674_11_07.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：完成的项目](img/B18674_11_07.jpg)'
- en: 'Figure 11.7: The completed project'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：完成的项目
- en: It’s a nice animation, and it really simulates the timing of an actual elevator
    very well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的动画，它非常真实地模拟了实际电梯的时间。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have now completed our elevator project. Let’s look at what we have done.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了电梯项目。让我们看看我们完成了什么。
- en: We used `GeometryReader` and the proxy constant to add images to the project
    and position them where needed, which will resize all the images in the project
    dynamically, based on the device that displays them, whether iPhones or iPads.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`GeometryReader`和代理常量来向项目中添加图片并将它们放置在所需的位置，这将根据显示它们的设备（无论是iPhone还是iPad）动态调整项目中所有图片的大小。
- en: We created `DataModel` to store all the app’s data and functions, and we accessed
    all that data using the `@``ObservableObject` protocol.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`DataModel`来存储所有应用程序的数据和功能，并使用`@ObservableObject`协议访问所有这些数据。
- en: We used timers to trigger door and light animations at different moments in
    the scene, making the animations happen on their own. We also added and styled
    a button to change color, when pressed, and we made floor lights turn on and off
    with timers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用计时器在场景的不同时刻触发门和灯光动画，使动画自行发生。我们还添加并设计了用于改变颜色的按钮，当按下时，我们使用计时器使地板灯光开启和关闭。
- en: The skills learned here can be useful and applied to other projects. For example,
    if you were putting together a game app that has several levels, maybe you could
    incorporate an elevator scene into the game to take the user to another level
    after they have completed a certain skill, or to search for power-ups.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里学到的技能可以很有用，并应用于其他项目。例如，如果你正在制作一个有多个级别的游戏应用程序，也许你可以将电梯场景融入游戏中，在用户完成某个技能后将其带到另一个级别，或者寻找升级物品。
- en: How about a challenge? To take the project further, see whether you can add
    more floors to the scene. Or how about animating the people inside the elevator
    using the same techniques we used with the girl on the swing project? Cut up the
    images and make different parts move in different ways – for example, you could
    cut up the second man’s mouth so it looks like he’s talking when the doors open.
    You could also animate the legs so that they shuffle a little bit inside the elevator,
    or animate their bodies so that they sway a little, basically simulating human
    motion.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样，来个挑战？为了进一步推进项目，看看你是否能向场景中添加更多楼层。或者，使用我们在秋千项目中使用的相同技术来动画化电梯内的人？切割图片，使不同的部分以不同的方式移动——例如，你可以切割第二个人的嘴巴，使其在门打开时看起来像在说话。你也可以动画化腿，使其在电梯内轻微摇晃，或者动画化身体，使其轻微摇摆，基本上模拟人类动作。
- en: In the next chapter, we’ll start putting together a language-learning game and
    animate various aspects of the UI to make the game fluid and interesting. We’ll
    also make the game work across three different languages – English, Spanish, and
    Italian – so that it can appeal to a broad range of language learners.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始组装一个语言学习游戏，并动画化UI的各个方面，使游戏流畅且有趣。我们还将使游戏支持三种不同的语言——英语、西班牙语和意大利语——以便它能吸引广泛的语言学习者。
