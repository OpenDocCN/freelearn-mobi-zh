<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Extensions, Photos, and More</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Developing the geekiest keyboard</li><li class="listitem">Time to take your pill</li><li class="listitem">Adding effects to your photos</li><li class="listitem">Being a film critic</li><li class="listitem">Leaving breadcrumbs</li><li class="listitem">Creating the Currency Converter app</li><li class="listitem">Method swizzling in Swift</li><li class="listitem">Associated objects in Swift</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec82" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">This is the last chapter of this book. Here, we are going to learn different topics that weren't mentioned in the previous chapters, mainly new features of Xcode 6.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec83" class="calibre1"/>Developing the geekiest keyboard</h1></div></div></div><p class="calibre7">App <a id="id528" class="calibre1"/>extensions are a new feature where an application can come with some kind of plugins, which can even interact with other apps.</p><p class="calibre7">In this case, we are <a id="id529" class="calibre1"/>going to develop a keyboard for geek people. This keyboard will contain only two keys: key <em class="calibre9">0</em> and key <em class="calibre9">1</em>. When you type a combination of eight keys, you will get a new character.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec256" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">For this recipe, make sure that you have iOS 8, it doesn't matter if you are using the simulator or a physical device. The custom keyboard feature is only available on iOS 8.</p><p class="calibre7">Create a new single view application called <code class="email">Chapter 11 Geekboard</code> and let's start coding.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec257" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">The main development of this recipe is based on the app extension of the custom <a id="id530" class="calibre1"/>keyboard. However, as we are going <a id="id531" class="calibre1"/>to need a view for testing our keyboard, let's start by clicking on the storyboard and adding a text field on our view. Link this text field with the view controller calling it <code class="email">inputTextField</code>:<div><pre class="programlisting">    @IBOutlet weak var inputTextField: UITextField!</pre></div></li><li class="listitem" value="2">Now, let's make this text field the first responder, just as the application is about to launch. You won't need to tap on the field for displaying the keyboard:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        <strong class="calibre8">self.inputTextField.becomeFirstResponder()</strong>
    }</pre></div></li><li class="listitem" value="3">This is everything we have to code with this view controller; everything else will be done on the application extension. The next step is opening the menu and adding a new target to our project. In this case, select <strong class="calibre8">Custom Keyboard</strong> from the <strong class="calibre8">Application Extension</strong> section:<div><img src="img/00169.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Call this target <a id="id532" class="calibre1"/><code class="email">Geekboard</code> and press <strong class="calibre8">Yes</strong> when a dialog asks for activating the <strong class="calibre8">Geekboard</strong> scheme:<div><img src="img/00170.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Before coding, let's start by adding a new view to this target; therefore click on the new file <a id="id533" class="calibre1"/>from the menu and choose <strong class="calibre8">View</strong> <a id="id534" class="calibre1"/>from the <strong class="calibre8">User Interface</strong> section:<div><img src="img/00171.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="6">Call this view <code class="email">Geekboard</code> (again) but before pressing the <strong class="calibre8">Create</strong> button ensure that this file belongs to the extension target as shown in the following screenshot:<div><img src="img/00172.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="7">Once it is created, click on the new file (<code class="email">Geekboard.xib</code>), select the only view it has, and let's change some properties of it by clicking on the <strong class="calibre8">Attribute Inspector</strong>. Here you have to change the size to <strong class="calibre8">Freeform</strong>, the status bar to <strong class="calibre8">None</strong>, and the background color to silver:<div><img src="img/00173.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">Great! After <a id="id535" class="calibre1"/>that, select the <strong class="calibre8">Size Inspector</strong> and change the view size to <strong class="calibre8">320</strong> by <strong class="calibre8">160</strong>:<div><img src="img/00174.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="9">The view <a id="id536" class="calibre1"/>properties are done, now we need to set the file's owner class. To do it click on the file's owner icon (the yellow cube), select the identity inspector, and change the class name to <a id="id537" class="calibre1"/><code class="email">KeyboardViewController</code>:<div><img src="img/00175.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="10">There is one more thing we need to do in this XIB file: we have to add a few components for this layout. Add a label, for letting the user know the binary combination that was made, and two buttons: one that represents digit 0 and another one that represents digit <strong class="calibre8">1</strong>. It should look something similar to the following screenshot:<div><img src="img/00176.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="11">Of course the label is going to be changed and the buttons don't need a different action due to the only difference being the digit value; therefore we will create the same action for both buttons and differentiate them by checking the sender. To summarize, link the label and the buttons with the <code class="email">KeyboardViewController</code> as per the following code:<div><pre class="programlisting">    @IBOutlet var button0: UIButton!
    @IBOutlet var button1: UIButton!
    @IBOutlet var label:UILabel!</pre></div><div><h3 class="title2"><a id="note46" class="calibre1"/>Note</h3><p class="calibre7">Don't remove any code done by the Xcode on the <code class="email">KeyboardViewController</code> yet. If it's necessary to remove any code, it will be explicitly written.</p></div></li><li class="listitem" value="12">Link both buttons with an empty action called <code class="email">addBit</code>. Don't worry about by its contents, we are going to develop it later:<div><pre class="programlisting">    @IBAction func addBit(sender: UIButton){
    }</pre></div></li><li class="listitem" value="13">On the <code class="email">KeyboardViewController</code> we are also going to add two attributes for controlling the current keyboard state:<div><pre class="programlisting">    var currentBinaryText:String = ""
    var currentBinaryNumber:Int = 0</pre></div></li><li class="listitem" value="14">Now we need to <a id="id538" class="calibre1"/>set up the view, so go to <a id="id539" class="calibre1"/>the <code class="email">viewDidLoad</code> method and add some lines of code after <code class="email">super.viewDidLoad</code> and before the Apple precooked code:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        // Perform custom UI setup here
<strong class="calibre8">        var geekNib = UINib(nibName: "Geekboard", bundle: nil)</strong>
<strong class="calibre8">        self.view = geekNib.instantiateWithOwner(self, options: nil)[0] as UIView</strong>
<strong class="calibre8">        self.label.text = currentBinaryText</strong>
        self.nextKeyboardButton = UIButton.buttonWithType(.System) as UIButton
…</pre></div></li><li class="listitem" value="15">Once we have typed that, we can complete our app by developing the buttons event:<div><pre class="programlisting">    @IBAction func addBit(sender: UIButton){
        var number: Int
        switch sender{
        case button0:
            number = 0
        case button1:
            number = 1
        default:
            return
        }
        currentBinaryText += "\(number)"
        currentBinaryNumber = currentBinaryNumber * 2 + number
        if countElements(currentBinaryText) == 8 {
            var proxy = textDocumentProxy as UITextDocumentProxy
            proxy.insertText(String(UnicodeScalar(currentBinaryNumber)))
            
            currentBinaryNumber = 0
            currentBinaryText = ""
        }
        self.label.text = currentBinaryText
    }</pre></div></li><li class="listitem" value="16">The application is done, let's test it. Press play, and when the application launches the keyboard is shown but, that's not our keyboard!!! What happened? The reason is that you have to add this keyboard the same way you add another language keyboard on your device.</li><li class="listitem" value="17">Bearing that in <a id="id540" class="calibre1"/>mind, press the home button, go to settings, choose general, then keyboard, then another option of keyboards, and at last the option <strong class="calibre8">Add new keyboard...</strong>.</li><li class="listitem" value="18">You should <a id="id541" class="calibre1"/>see some suggested keyboards and another section with third-party keyboards. Select the <strong class="calibre8">Geekboard</strong> from this section:<div><img src="img/00177.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="19">Return to your app (<strong class="calibre8">Chapter 11 Geekboard</strong>) and you will see that the keyboard is not there yet. So you have to tap the globe icon until you get your keyboard and, voila!, it's working. Type this binary message: <code class="email">01001000 01000101 01001100 01001100 01001111</code> for example, but if you are really geeky, you can go to the <strong class="calibre8">Mail</strong> application and write an e-mail with only this <a id="id542" class="calibre1"/>keyboard. Do you accept the <a id="id543" class="calibre1"/>challenge?</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec258" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">A custom keyboard is a <a id="id544" class="calibre1"/>feature called <strong class="calibre8">App Extension</strong>. It has some limitations, for example, it can't be used for passwords and other text field types such as phone contacts. It also can't display anything above its top.</p><p class="calibre7">Creating a custom keyboard implies creating a controller of type <code class="email">UIInputViewController</code>, which is a class that inherits from <code class="email">UIViewController</code>, meaning that you can use the <code class="email">UIViewController</code> methods if necessary.</p><p class="calibre7">For making the keyboard development simpler, we added a new XIB file, which allowed us to visually create the layout. Some developers think that the XIB files were removed from the Xcode since <a id="id545" class="calibre1"/>the storyboard was incorporated, however <a id="id546" class="calibre1"/>you can see that this is not true; you can still use the XIB files for customizing some views such as a keyboard or a table cell.</p><p class="calibre7">Submitting a text to the text field is very easy: you only need to create a <code class="email">UITextDocumentProxy</code> object and use the <code class="email">insertText</code> method. It will know the active text field magically.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec259" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">The custom keyboards communication is a bit limited because it can't use the network or share any file with the containing app by default. In case you desire to use these features, you have to go to its <code class="email">Info.plist</code> and set the option <code class="email">RequestsOpenAccess</code> to <code class="email">yes</code>.</p><p class="calibre7">In the next recipe, we are going to learn something different: we are going to develop for the Apple Watch.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec84" class="calibre1"/>Time to take your pill</h1></div></div></div><p class="calibre7">Who in this world has <a id="id547" class="calibre1"/>never fallen sick? Let's face it, soon or later we get sick and we have to follow the doctor's prescription. If you are like me and look at your watch frequently when it's time to take a pill, maybe what we need is an app that can tell us about it, and this time it will be an Apple Watch application.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec260" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">For this recipe you will need Xcode 6.2 or higher, because we are going to use the WatchKit, which is not available on previous versions.</p><p class="calibre7">Start as usual by just <a id="id548" class="calibre1"/>creating a single view iOS application and call it <code class="email">Chapter 11 Red Pill</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec261" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">The first step we need to do is just create a new target, but this time you have to add the <strong class="calibre8">WatchKit App</strong> from the <strong class="calibre8">WatchKit</strong> section:<div><img src="img/00178.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">On the <strong class="calibre8">Next</strong> dialog <a id="id549" class="calibre1"/>uncheck the notifications, glance and complications options; it will make the project cleaner:<div><img src="img/00179.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">After that, a dialog requesting to activate the WatchKit App will appear; accept it by pressing the <strong class="calibre8">Activate</strong> button:<div><img src="img/00180.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">You can see that there are two new groups on your project: one for the WatchKit extension and another one for the WatchKit app. Open your extension group and add a new Swift file called <code class="email">FrequencyData.swift</code>. Here you only need <a id="id550" class="calibre1"/>to type this simple code:<div><pre class="programlisting">class FrequencyData: CustomStringConvertable {
    var description: String {
        switch self.time {
        case 0 ..&lt; 60:
            return "Every \(self.time) minutes"
        case 60 ..&lt; (24 * 60):
            return "Every \(self.time/60) hours"
        default:
            return "Every \(self.time/60/24) days"
        }
    }
    
    var time:Int // minutes
    
    init(time:Int){
        self.time = time
    }   
}</pre></div></li><li class="listitem" value="5">Now go to your WatchKit app group, expand it, and click on the storyboard. Here you have something like the view controller but here it's called interface. In your interface, add a label and try to make it fit on the whole screen. Connect it <a id="id551" class="calibre1"/>with the interface controller as an IBOutlet:<div><pre class="programlisting">    @IBOutlet var label:WKInterfaceLabel!</pre></div></li><li class="listitem" value="6">Create a new interface and place another label; you don't have to connect it just change its text to <code class="email">It's time to take your pill</code>. If it doesn't fit, change the label number of lines to two.</li><li class="listitem" value="7">Now click on the first interface, hold the control key and drag it to the second interface. You may now have your storyboard looking like the following:<div><img src="img/00181.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">Select the second interface and go to its attribute inspector. Set the identifier to <code class="email">its_time</code>:<div><img src="img/00182.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="9">Return to the extension group and open the <code class="email">InterfaceController</code> file. As usual we are going to start by adding the necessary attributes:<div><pre class="programlisting">    var timer:NSTimer?
    var remainingTime:Int?
    var context:AnyObject?
    var options = [FrequencyData(time: 2), FrequencyData(time:4 * 60), FrequencyData(time: 8 * 60), FrequencyData(time: 24 * 60)]</pre></div></li><li class="listitem" value="10">Now initialize the <a id="id552" class="calibre1"/>context on the <code class="email">awakeWithContext</code> method:<div><pre class="programlisting">    override func awakeWithContext(context: AnyObject?) {
        super.awakeWithContext(context)
        self.context = context
    }</pre></div></li><li class="listitem" value="11">After that, we have to request the user to select the time he needs to take his pill. Do it on the method <code class="email">willActivate</code>:<div><pre class="programlisting">    override func willActivate() {
        super.willActivate()
        let texts = options.map({ (freq) -&gt; String in
            return freq.description
        })
        self.presentTextInputControllerWithSuggestions(texts, allowedInputMode: WKTextInputMode.Plain, completion: {
        selections in
           var index = find(texts, selections[0] as String)!
            var frequency = self.options[index]
            self.timer?.invalidate()
            self.remainingTime = frequency.time * 60
            self.timer = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: Selector("tick"), userInfo: nil, repeats: true)
        })
    }</pre></div></li><li class="listitem" value="12">As you can see, we need a method called <code class="email">tick</code>, which is going to be called every second. Code it this way:<div><pre class="programlisting">    func tick(){
        var rt = remainingTime!
        let formatter = NSDateComponentsFormatter()
        formatter.unitsStyle = .Short
        let components = NSDateComponents()
        components.second = rt % 60
        rt = rt / 60
        components.minute = rt % 60
        rt = rt / 60
        components.hour = rt % 24
        rt = rt / 24
        components.day = rt
        if components.hour &gt; 6 {
            label.setText("Still have time")
        }else if components.hour == 0 &amp;&amp; components.minute == 0{
            label.setText("A few secs: \(components.second)")
        }else {
            label.setText( formatter.stringFromDateComponents(components))
        }
        remainingTime!--
        if(remainingTime == 0){
            
            presentControllerWithName("its_time", context: self.context)
            timer?.invalidate()
        }
    }</pre></div></li><li class="listitem" value="13">The app is <a id="id553" class="calibre1"/>done, let's test it by changing the current scheme to <code class="email">Chapter 11 Red Pill WatchKit App</code> and pressing play. You should see a dialog like the following one:<div><img src="img/00183.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p><div><h3 class="title2"><a id="note47" class="calibre1"/>Note</h3><p class="calibre7">Choose 2 minutes, which was done just for testing, and wait until you get your alert.</p></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec262" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">As you can see, the <a id="id554" class="calibre1"/>components classes are different; instead of <code class="email">UIViewController</code> we have <code class="email">WKInterfaceController</code>, and instead of <code class="email">UILabel</code> we have <code class="email">WKInterfaceLabel</code>. Some methods are different, for example the interface controller initializes its attributes on the <code class="email">awakeWithContext</code> method rather than <code class="email">viewDidLoad</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec263" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">There is one component called <code class="email">WKInterfaceTimer</code>, which works as a label with an <code class="email">NSTimer</code> like we did. In this recipe we used the <code class="email">WKInterfaceLabel</code> with an <code class="email">NSTimer</code> because it is more flexible and you can customize the text that is on your component.</p><div><h3 class="title2"><a id="note48" class="calibre1"/>Note</h3><p class="calibre7">WatchKit has <a id="id555" class="calibre1"/>more features such as notifications and glance. Try to have a look on the official documentation at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969">https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969</a></p></div><p class="calibre7">In the next recipe, we <a id="id556" class="calibre1"/>are going to return to iOS and learn how to use the camera for taking pictures.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec85" class="calibre1"/>Adding effects to your photos</h1></div></div></div><p class="calibre7">It is unbelievable how <a id="id557" class="calibre1"/>mobile phones have replaced traditional photo <a id="id558" class="calibre1"/>cameras. I remember when we used to take the camera only to special events and nowadays our cameras follow us everywhere. We can say that the mobile phone has gone even further: you can take a picture of yourself on the phone, edit it, and share it with your friends and family.</p><p class="calibre7">In this recipe, we are going to learn how to take a picture with your phone and edit it in a very easy way.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec264" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">As we are going to use the device camera for this recipe you will need a physical device for testing this app. You can change it if you are using photos from the gallery, but you will also need to upload some pictures to the simulator.</p><p class="calibre7">Create a project called <code class="email">Chapter 11 Photo Effects</code> and let's move on.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec265" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">Open your project, click on the <strong class="calibre8">General Settings</strong> of your target and add a framework called <strong class="calibre8">CoreImage</strong>. After that go to the storyboard, add an image view and four buttons under it. Change the button labels to <code class="email">Take photo</code>, <code class="email">Sepia</code>, <code class="email">Blur,</code> and <code class="email">Dots</code>.</li><li class="listitem" value="2">Connect the image with the view controller as an attribute and call it <code class="email">imageView</code>. Now create one action for each button and call them <code class="email">takePhoto</code>, <code class="email">sepia</code>, <code class="email">blur</code>, and <code class="email">dots</code>. Don't worry about their contents now, we are going to fill them in later:<div><pre class="programlisting">    @IBOutlet var imageView: UIImageView!
    @IBAction func takePhoto(sender: UIButton) {
    }
    @IBAction func sepia(sender: AnyObject) {
    }
    @IBAction func blur(sender: AnyObject) {
    }
    @IBAction func dots(sender: AnyObject) {
    }</pre></div></li><li class="listitem" value="3">Click on the view controller source code and let's start completing it by adding a new attribute called <code class="email">image</code> of optional type <code class="email">UIImage</code>:<div><pre class="programlisting">    var image:UIImage?</pre></div></li><li class="listitem" value="4">The <code class="email">UIImagePickerController</code> requires a delegate and only accepts objects that are also <a id="id559" class="calibre1"/>navigation controller delegates, therefore append these protocols to the view controller definition:<div><pre class="programlisting">class ViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate {</pre></div></li><li class="listitem" value="5">It's almost time to start coding functions, however we still need to add a detail: we have to <a id="id560" class="calibre1"/>import the core image on the top of the file:<div><pre class="programlisting">import CoreImage</pre></div></li><li class="listitem" value="6">Good, at this time we can start coding the view controller methods. Start by checking whether your device has a camera on the <code class="email">viewDidLoad</code> method:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        if !UIImagePickerController.isSourceTypeAvailable(.Camera){
            UIAlertView(title: "Error", message: "There is no camera", delegate: nil , cancelButtonTitle: "OK").show()
        }
    }</pre></div></li><li class="listitem" value="7">The next step is completing the <code class="email">takePhoto</code> method. This method initializes the image picker and calls the camera view:<div><pre class="programlisting">    @IBAction func takePhoto(sender: UIButton) {
        let imagePicker = UIImagePickerController()
        imagePicker.delegate = self
        imagePicker.allowsEditing = true
        imagePicker.sourceType = .Camera
        self.presentViewController(imagePicker, animated: true, completion: nil)
    }</pre></div></li><li class="listitem" value="8">As you might imagine, the delegate needs to have at least one method; in this case we need one method for receiving the picture from the user and another in case of canceling it:<div><pre class="programlisting">    func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]){
        image = info[UIImagePickerControllerEditedImage] as? UIImage
        self.imageView.image = image;
        picker.dismissViewControllerAnimated(true, completion: nil)
    }
    func imagePickerControllerDidCancel(picker: UIImagePickerController){
        picker.dismissViewControllerAnimated(true, completion: nil)
    }</pre></div></li><li class="listitem" value="9">Once we have <a id="id561" class="calibre1"/>done that, we only need to complete the <a id="id562" class="calibre1"/>effects code; they are very similar but not the same, so here you have them:<div><pre class="programlisting">    @IBAction func sepia(sender: AnyObject) {
        if image != nil {
            var ciImage = CIImage(image: image)
            let filter = CIFilter(name: "CISepiaTone")
            filter.setValue(ciImage, forKey: kCIInputImageKey)
            filter.setValue(0.8, forKey: "inputIntensity")
            ciImage = filter.outputImage
            self.imageView.image = UIImage(CIImage: ciImage)
        }
    }
    @IBAction func dots(sender: AnyObject) {
        if image != nil {
            var ciImage = CIImage(image: image)
            let filter = CIFilter(name: "CIDotScreen")
            filter.setValue(ciImage, forKey: kCIInputImageKey)
            ciImage = filter.outputImage
            self.imageView.image = UIImage(CIImage: ciImage)
        }
    }
    @IBAction func blur(sender: AnyObject) {
        if image != nil {
            var ciImage = CIImage(image: image)
            let filter = CIFilter(name: "CIGaussianBlur")
            filter.setValue(ciImage, forKey: kCIInputImageKey)
            ciImage = filter.outputImage
            self.imageView.image = UIImage(CIImage: ciImage)
        }
    }</pre></div></li><li class="listitem" value="10">The app is done. Now press play, take a photo, and choose the effect you like most.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec266" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7"><code class="email">UIImagePickerController</code> was created for using the camera easily; this way we don't have to use complicated camera settings and worry about different states of it. To use the <code class="email">UIImagePickerController</code> you need a delegate and on its method you can retrieve the taken picture as a <code class="email">UIImage</code>.</p><p class="calibre7">After receiving the picture you can use the Core Image for adding some effects; however you need to convert from <code class="email">UIImage</code> to <code class="email">CIImage</code>. If you loaded the <code class="email">UIImage</code> from a local file you can convert it <a id="id563" class="calibre1"/>easily by calling a property <code class="email">CIImage</code>; however this is <a id="id564" class="calibre1"/>not the case, as this picture was loaded from the camera so you need to create a new object and send your <code class="email">UIImage</code> as an argument.</p><p class="calibre7">Now you can use the filter that you want with the corresponding values. When you use a <code class="email">CIFilter</code> you have to check the attributes that are accepted by it; sometimes you can use the default values and sometimes you would like to change them.</p><p class="calibre7">After using the filter you can retrieve your picture by using the <code class="email">outputImage</code> attribute and after that you can construct a new <code class="email">UIImage</code> with the <code class="email">CIImage</code> generated.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec267" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><code class="email">CoreImage</code> has a lot of filters, so nowadays it's not necessary to look for libraries or algorithms <a id="id565" class="calibre1"/>that modify our pictures. Check the filters that are available at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346">https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346</a> and test them with different attributes.</li><li class="listitem">In the next recipe, we are going to learn how we can send information from the iPhone to our Mac.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec86" class="calibre1"/>Being a film critic</h1></div></div></div><p class="calibre7">There are times that an app needs to transfer information from your device to the computer and vice versa; for example, you might be watching a movie on your iPad on your way home (assuming that you are not the driver) and then you will continue watching it on your computer.</p><p class="calibre7">For scenarios like this one, Apple <a id="id566" class="calibre1"/>has created a new technology called <strong class="calibre8">Handoff</strong>. The idea is simple: continue the task you are doing on another device.</p><p class="calibre7">In this recipe we are going to create an app where the user can start writing his opinion about a film on one device and check it on a Mac application. This recipe will be divided into smaller sections for easier consumption.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec268" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">The Handoff framework has software and hardware requirements. The software requirements are Xcode 6, iOS 8, and OS X Yosemite (10.10); therefore make sure that your hardware is able to use all these software versions (or higher). Unfortunately Handoff can't be used with the simulator. Another software requirement is that both devices (the computer and your Apple mobile device) must be logged into the same iCloud account and they must be paired.</p><p class="calibre7">The requirement for the hardware is that it has Bluetooth LE 4.0. The easiest way to check whether your iPhone or iPad can use this feature is by opening your settings, going to general and checking whether there is an option called <strong class="calibre8">Handoff &amp; Suggested Apps</strong>:</p><div><img src="img/00184.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Make sure that the <a id="id567" class="calibre1"/>
<strong class="calibre8">Handoff</strong> option is on, as shown in the following screenshot:</p><div><img src="img/00185.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Once you have checked the device requirements, it's time to check whether the computer meets the requirements. On your Mac computer, open the system preferences, then open the <strong class="calibre8">General options</strong>, and ascertain that there is a Handoff option and it is checked:</p><div><img src="img/00186.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><div><h3 class="title2"><a id="note49" class="calibre1"/>Note</h3><p class="calibre7">Of all requirements, the most complicated one is that this technology needs the application signed by a team (or a developer), which implies being enrolled on the Apple Development Program for each platform. This means that if you are going to use this <a id="id568" class="calibre1"/>technology between mobile devices and mac computers, you need both subscriptions.</p></div><p class="calibre7">In this recipe we are going to use both platforms but if you only have an iOS subscription, it is very straightforward to change the Mac app to an iOS app.</p><p class="calibre7">Now we can start coding the project; in this case start creating a workspace called <code class="email">Chapter 11 Films</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec269" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">We will split the recipe into three mini-recipes for better understanding.</p><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec01" class="calibre1"/>Creating the workspace</h3></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">Create the <a id="id569" class="calibre1"/>workspace in a group called <code class="email">Common Code</code>; here you have to add a new Swift file called <code class="email">FilmData.swift</code>, and we are going to add this simple class:<div><pre class="programlisting">class FilmData {
    var name:String
    var year:Int?
    var director:String?
    var score:Int?
    var opinion = ""
    
    init(name:String){
        self.name = name
    }
}</pre></div></li><li class="listitem" value="2">Let's create a new iOS project called <code class="email">Chapter 11 Films iOS</code>. Ensure that it is going to be added to your workspace on the combo box:<div><img src="img/00187.jpeg" alt="Creating the workspace" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Repeat the <a id="id570" class="calibre1"/>procedure with a Mac OS X Cocoa application called <code class="email">Chapter 11 Films MacOSX</code>, but be aware that you have to add it to the workspace and the group must be in the workspace too:<div><img src="img/00188.jpeg" alt="Creating the workspace" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Once we have both projects, let's add to both of them the first file we created at the beginning of this recipe (<code class="email">FilmData.swift</code>). This way we don't have to repeat the code for each project:<div><img src="img/00189.jpeg" alt="Creating the workspace" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Once we have these common parts we are going to continue with the Mac application. So <a id="id571" class="calibre1"/>click on the Mac project, go to <strong class="calibre8">General Settings</strong>, change the signing section to <strong class="calibre8">Developer ID</strong>, and select your team account:<div><img src="img/00190.jpeg" alt="Creating the workspace" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="6">Now click on the <code class="email">info.plist</code> file, which is located on the <strong class="calibre8">Supporting Files</strong> group and add a new key called <strong class="calibre8">NSUserActivityTypes</strong>. Change its type to array, try to expand it but as you can see there is no item, so click on the plus sign and write the value <code class="email">com.packtpub.editingfilm</code>:<div><img src="img/00191.jpeg" alt="Creating the workspace" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="7">The next step is clicking on the XIB file and adding five labels into the only window we have. Put one under the other and, after that, start from the first one connecting to the <code class="email">AppDelegate.swift</code>:<div><pre class="programlisting">    @IBOutlet var titleLabel: NSTextField!
    @IBOutlet var directorLabel: NSTextField!
    @IBOutlet var yearLabel: NSTextField!
    @IBOutlet var scoreLabel: NSTextField!
    @IBOutlet var opinionLabel: NSTextField!</pre></div></li><li class="listitem" value="8">After that we <a id="id572" class="calibre1"/>only need to add the following code to the <code class="email">AppDelegate</code>:<div><pre class="programlisting">func application(application: NSApplication, willContinueUserActivityWithType userActivityType: String) -&gt; Bool {
        return userActivityType == "com.packtpub.editingfilm"
    }
       
    func application(application: NSApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]!) -&gt; Void) -&gt; Bool {
        func setField (fieldName:String, uiField:NSTextField) {
            if let value = userActivity.userInfo![fieldName] as? String {
                uiField.stringValue = value
            }else if let value = userActivity.userInfo![fieldName] as? Int {
                uiField.stringValue = String(value)
            }
            else{
                uiField.stringValue = "-"
            }
        }
        setField("title", titleLabel)
        setField("director", directorLabel)
        setField("year", yearLabel)
        setField("score", scoreLabel)
        setField("opinion", opinionLabel)

        return true
    }</pre></div></li><li class="listitem" value="9">Good, the Mac application is done; before we press play remember that you have to log in on iCloud to do it, so you have to open the <strong class="calibre8">System Preferences</strong>, then <a id="id573" class="calibre1"/>go to iCloud and log in.<div><h3 class="title2"><a id="note50" class="calibre1"/>Note</h3><p class="calibre7">Remember that this account must be the same one that you are going to use on the mobile device. Once it is done, return to your app and press play. You should see just a window with some labels—don't worry about them now as we are going to check them later.</p></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec02" class="calibre1"/>Developing the iOS part of the app</h3></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">At this time, we <a id="id574" class="calibre1"/>are ready to develop the iOS part of the app. First, you have to set your team on the main project target and also add the key <code class="email">NSUserActivityTypes</code> on the <code class="email">info.plist</code>. As we did on the Mac application, change its type to Array and add the value <code class="email">com.packtpub.editingfilm</code> as we also did on the Mac application.</li><li class="listitem" value="2">Click on the storyboard and, as usual, you might see only a view controller. Click on it, go to the <strong class="calibre8">Editor</strong> menu, move down to the option <code class="email">Embed in</code> and select <strong class="calibre8">Navigation controller</strong>. As you might expect, we are going to add a second view controller later. Now just remove the navigation bar by clicking on the navigation controller, select the attribute inspector, and uncheck the option <strong class="calibre8">Show Navigation Bar</strong>:<div><img src="img/00192.jpeg" alt="Developing the iOS part of the app" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Now return to the original view controller and simply add a table view on that. In this case we need to display some cells with contents and we also need to do something when they are selected. This means that we will need to set the view controller to <code class="email">UITableViewDelegate</code> and <code class="email">UITableViewDatasource</code>:<div><pre class="programlisting">class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {</pre></div></li><li class="listitem" value="4">After that, bind the table view with the view controller as the data source and delegate. As a data source, we need an array of <code class="email">FilmData</code>, which will be an attribute initialized with a private function:<div><pre class="programlisting">    let movies = createBasicMovieArray()</pre></div></li><li class="listitem" value="5">Of course, we are going to receive an error here because we need to implement this function, so <a id="id575" class="calibre1"/>do it outside the class:<div><pre class="programlisting">private func createBasicMovieArray() -&gt; [FilmData] {
    var movieArray = [FilmData]()
    
    var filmData = FilmData(name: "A Clockwork Orange")
    filmData.year = 1971
    filmData.director = "Stanley Kubrick"
    movieArray.append(filmData)
    
    filmData = FilmData(name: "Monty Python and the Holy Grail")
    filmData.year = 1975
    filmData.director = "Terry Gilliam"
    movieArray.append(filmData)
    
    filmData = FilmData(name: "Kill Bill")
    filmData.year = 2003
    filmData.director = "Quentin Tarantino"
    movieArray.append(filmData)
    
    filmData = FilmData(name: "Ghost Busters")
    filmData.year = 1984
    movieArray.append(filmData)
    
    return movieArray
}</pre></div></li><li class="listitem" value="6">After that we need to complete the data source methods on the view controller class:<div><pre class="programlisting">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int{
        return movies.count
    }
    
    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell{
        var cell  = tableView.dequeueReusableCellWithIdentifier("filmcell") as? UITableViewCell
        
        if (cell == nil) {
            cell = UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: "filmcell")
        }
        
        let currentFilm = movies[indexPath.row]
        cell!.textLabel?.text = currentFilm.name
        let unknown = "????"
        cell!.detailTextLabel?.text = "\(currentFilm.year != nil ? String(currentFilm.year!) : unknown) - \(currentFilm.director != nil ? currentFilm.director! : unknown)"
        
        return cell!
    }</pre></div></li><li class="listitem" value="7">Even then, the app is not finished yet. You should press play and test it, and you will see a <a id="id576" class="calibre1"/>view similar to the following one. Don't forget to make sure that you have chosen the right schema; otherwise it will restart the application:<div><img src="img/00193.jpeg" alt="Developing the iOS part of the app" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">Once this phase is done, we can return to our view controller and implement the last method. Don't worry when you get some compiler errors, they are going to be fixed soon:<div><pre class="programlisting">    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        var filmDetailViewController = self.storyboard?.instantiateViewControllerWithIdentifier("film_detail") as FilmDetailViewController
        filmDetailViewController.film = movies[indexPath.row]
        self.navigationController?.pushViewController(filmDetailViewController, animated: true)
    }</pre></div></li><li class="listitem" value="9">This view controller is done, the next step is to create a new Cocoa Touch class that inherits <a id="id577" class="calibre1"/>from the UIViewController, called <code class="email">FilmDetailViewController</code>. Uncheck the <strong class="calibre8">XIB</strong> option:<div><img src="img/00194.jpeg" alt="Developing the iOS part of the app" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="10">Once you have your new Swift file you can return to the storyboard and add a new view controller. In this storyboard add five labels, one stepper, a text view, and a button. Change the text view background to gray. You should have a layout similar to the following one:<div><img src="img/00195.jpeg" alt="Developing the iOS part of the app" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="11">The new view controller needs to know that its class is not the default view controller, therefore select the view controller, go to its identity inspector and change its <a id="id578" class="calibre1"/>class to <strong class="calibre8">FilmDetailViewController</strong>. Levering that we are here, we should also set <strong class="calibre8">Storyboard ID</strong> to <code class="email">film_detail</code>:<div><img src="img/00196.jpeg" alt="Developing the iOS part of the app" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="12">Now link the labels, the stepper, and the text view with the view controller:<div><pre class="programlisting">    @IBOutlet var movieTitle: UILabel!
    @IBOutlet var director: UILabel!
    @IBOutlet var year: UILabel!
    @IBOutlet var score: UILabel!
    @IBOutlet var opinion: UITextView!
    @IBOutlet var stepper: UIStepper!</pre></div></li><li class="listitem" value="13">Once we have these attributes we can set the actions. The only one that will need a protocol is the text view; then start adding the <code class="email">UITextViewDelegate</code> to the class header:<div><pre class="programlisting">class FilmDetailViewController: UIViewController, <strong class="calibre8">UITextViewDelegate</strong> {</pre></div></li><li class="listitem" value="14">After that we can connect the view controller as the text view delegate, create an action called <a id="id579" class="calibre1"/>done for the button, and another one called <code class="email">changeScore</code> as the stepper value changed event:<div><pre class="programlisting">    @IBAction func done(sender: AnyObject) {
    }
    @IBAction func changeScore(sender: UIStepper) {
    }</pre></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec03" class="calibre1"/>Coding the class</h3></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">Great, now we can <a id="id580" class="calibre1"/>code the previous class without worrying about the storyboard. Let's start with the attribute <code class="email">film</code>, which will contain the information of the movie that is on screen:<div><pre class="programlisting">    var film:FilmData?</pre></div></li><li class="listitem" value="2">Then we can initialize the views we have on screen and an inherited attribute called <code class="email">userActivity</code>. Remember that here we suppose that the attribute film was already set:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        movieTitle.text = film?.name
        director.text = film?.director
        year.text = film?.year != nil ? "\(film!.year!)" : "???"
        if let score = film?.score {
            self.score.text = String(score)
            self.stepper.value = Double(score)
        }else {
            self.score.text = ""
            self.stepper.value = 1
        }
        self.opinion.text = film?.opinion
        self.userActivity = NSUserActivity(activityType: "com.packtpub.editingfilm")
        self.userActivity!.userInfo = [NSObject: AnyObject]()
    }</pre></div></li><li class="listitem" value="3">After that we <a id="id581" class="calibre1"/>can complete the views events; here we are going to add a new one called <code class="email">textViewDidChange</code>, which belongs to the <code class="email">UITextViewDelegate</code>:<div><pre class="programlisting">    @IBAction func done(sender: AnyObject) {
        self.userActivity!.invalidate()
        self.navigationController?.popViewControllerAnimated(true)
    }
    @IBAction func changeScore(sender: UIStepper) {
        self.film?.score = Int(sender.value)
        self.score.text = String(self.film!.score!)
        self.updateUserActivityState(self.userActivity!)
    }
    func textViewDidChange(textView: UITextView) {
         film?.opinion = self.opinion.text
        self.updateUserActivityState(self.userActivity!)
    }</pre></div></li><li class="listitem" value="4">The last part of this code is about getting all of the information we want to transmit and updating the <code class="email">userActivity</code> state:<div><pre class="programlisting">    override func updateUserActivityState(activity: NSUserActivity) {
        self.userActivity!.userInfo!["title"] = film?.name
        self.userActivity!.userInfo!["year"] = film?.year
        self.userActivity!.userInfo!["director"] = film?.director
        self.userActivity!.userInfo!["score"] = film?.score
        self.userActivity!.userInfo!["opinion"] = film?.opinion
        super.updateUserActivityState(activity)
    }</pre></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec04" class="calibre1"/>Testing the app</h3></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">The app is done <a id="id582" class="calibre1"/>and as you know, we have to test it. Before pressing play, make sure that the right schema is selected and the app is going to be installed on your mobile device, not on the simulator.</li><li class="listitem" value="2">Press play, select a movie you like most (or hate most), set a score for it, and write your comment. Return to your Mac (remember that you haven't stopped the Mac application) and check that your dock has a new icon. It means that it detected a user activity that can be read. Click on this icon:<div><img src="img/00197.jpeg" alt="Testing the app" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">You will see that <a id="id583" class="calibre1"/>your Mac app is in the foreground and it will show the information received from your device:<div><img src="img/00198.jpeg" alt="Testing the app" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec270" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Handoff works with a feature called <strong class="calibre8">Activity</strong>. Activities are some kind of information about what the user is <a id="id584" class="calibre1"/>doing right now, such as composing an <a id="id585" class="calibre1"/>e-mail, editing a video, and so on.</p><p class="calibre7">When using Handoff you have to plan three phases for your activities: creating the activity, updating it, and destroying it. We created it on the <code class="email">viewDidLoad</code> method, updated it every time the user changed the score or the opinion text, and destroyed it when the user pressed the done button.</p><p class="calibre7">If you want to use Handoff <a id="id586" class="calibre1"/>on your own classes you have to add an <code class="email">NSUserActivity</code> object. A good feature about this class is that it is the same using the AppKit (OS X) and the UIKit (iOS). Some classes already have this object as a property such as <code class="email">NSDocument</code>, <code class="email">UIDocuments</code>, <code class="email">NSResponder</code>, and <code class="email">UIResponder</code>.</p><p class="calibre7">As the <code class="email">UIViewController</code> inherits from <code class="email">UIResponder</code>, we could use the existing attribute <code class="email">userActivity</code>. Every time that we or the app thinks that the activity needs to be updated, the method <code class="email">updateUserActivityState</code> is called. Here it should set the whole information that should be transmitted even when the information hasn't changed such as the movie title, the director, or the production year because after updating the state, the <code class="email">userInfo</code> dictionary is going to empty.</p><div><h3 class="title2"><a id="tip54" class="calibre1"/>Tip</h3><p class="calibre7">Don't overload the user info dictionary; Apple recommends storing up to 3k of information, more than that can affect the application performance.</p></div><p class="calibre7">For receiving the information we need two steps: the first one is checking whether the app accepts the activity at that moment by implementing the method <code class="email">willContinueUserActivityWithType</code> on the app delegate. The other one is implementing the app delegate method <code class="email">continueUserActivity</code> for retrieving the information and sending it to the corresponding view or object.</p><p class="calibre7">An important detail is that Handoff is for being used between apps by the same company or developer and only with the same user; that's the reason that you have to use the same team signature and the user must be logged in.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec271" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">In this case, we created an app that edits your movie opinion and another one that can receive it, however you can modify the Mac application in a way that it can also edit and retransmit it to the device application. Try to do it as homework.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch11lvl2sec272" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">Apple has a good <a id="id587" class="calibre1"/>sample about how to use Handoff with photos; have a look at <a class="calibre1" href="https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html">https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html</a> to download it.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec87" class="calibre1"/>Leaving breadcrumbs</h1></div></div></div><p class="calibre7">Have you ever <a id="id588" class="calibre1"/>gone somewhere and started wondering whether your path was the best one? At times, we would like to review our journey once we've reached the destination. Usually we do this when the journey has been a very long one. In this recipe, we are going to create an app for recording our steps and then we can check the path we took.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec273" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new single-view application called <code class="email">Chapter 11 Breadcrumbs</code>, add the <code class="email">Core Location</code> framework, and the <code class="email">Map Kit</code> framework. You can use the simulator or a physical device for testing this app, however if you are as lazy as me, it will be better using the simulator, that way you don't have to stand up and walk to test it:</p><div><img src="img/00199.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec274" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Once you have added the <a id="id589" class="calibre1"/>frameworks, you just need to follow these steps for creating the app:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the storyboard, add a label on the top, a button under it, and a map view under that. The result can be similar to the following screenshot:<div><img src="img/00200.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">As usual, start connecting the label and the map view with the view controller:<div><pre class="programlisting">    @IBOutlet var mapView: MKMapView!
    @IBOutlet var positionLabel: UILabel!</pre></div></li><li class="listitem" value="3">Now you can click on the view controller and start by importing the core location and the map kit frameworks, and of course don't remove the UIKit:<div><pre class="programlisting">import UIKit
import MapKit
import CoreLocation</pre></div></li><li class="listitem" value="4">After that, complete the <code class="email">ViewController</code> class by adding the <code class="email">CLLocationManagerDelegate</code> and the <code class="email">MKMapViewDelegate</code> protocols, as shown:<div><pre class="programlisting">class ViewController: UIViewController, <strong class="calibre8">CLLocationManagerDelegate, MKMapViewDelegate</strong> {</pre></div></li><li class="listitem" value="5">The next step is <a id="id590" class="calibre1"/>adding the view controller attributes. In this case we will need the location manager for receiving the current position, an array of positions that we have passed through, and a Boolean attribute for following the user on the map:<div><pre class="programlisting">    var manager = CLLocationManager()
    var locationsStack = [CLLocation]()
    var follow = true</pre></div></li><li class="listitem" value="6">Now we need to initialize the manager attribute and the map view to do it, so we are going to use the method <code class="email">viewDidLoad</code>:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        
        manager.delegate = self
        manager.desiredAccuracy = kCLLocationAccuracyBest
        manager.requestAlwaysAuthorization()
        manager.startUpdatingLocation()
        
        mapView.delegate = self
        mapView.mapType = .Standard
        mapView.showsUserLocation = true
    }</pre></div></li><li class="listitem" value="7">Then we need to update the map view and the <code class="email">locationStack</code> every time we receive a new location:<div><pre class="programlisting">    func locationManager(manager:CLLocationManager, didUpdateLocations locations:[AnyObject]) {
        
        var currentLocation = locations[0] as CLLocation
        positionLabel.text = "\(currentLocation.coordinate.latitude), \(currentLocation.coordinate.longitude)"
        locationsStack.append(currentLocation)
        
        if follow {
            var currentRegion = MKCoordinateRegion(center: mapView.userLocation.coordinate, span: MKCoordinateSpanMake(0.01, 0.01))
            mapView.setRegion(currentRegion, animated: true)
        }
        
        if locationsStack.count &gt; 1{
            var destination = locationsStack.count - 2
            let sourceCoord = locationsStack.last!.coordinate
            let destinationCoord = locationsStack[destination].coordinate
            var coords = [sourceCoord, destinationCoord]
            let polyline = MKPolyline(coordinates: &amp;coords, count: coords.count)
            mapView.addOverlay(polyline)
        }
        
    }</pre></div></li><li class="listitem" value="8">The app is <a id="id591" class="calibre1"/>still not displaying the path; the reason is that we need to draw it by writing the map view method <code class="email">renderForOverlay</code>:<div><pre class="programlisting">    func mapView(mapView: MKMapView!, rendererForOverlay overlay: MKOverlay!) -&gt; MKOverlayRenderer! {
        if overlay is MKPolyline {
            var polylineRenderer = MKPolylineRenderer(overlay: overlay)
            polylineRenderer.strokeColor = UIColor.blueColor()
            polylineRenderer.lineWidth = 3
            return polylineRenderer
        }
        return nil
    }</pre></div></li><li class="listitem" value="9">Now the app is working; however it can be quite difficult to check our journey because it is always being updated, so it is time to add the button event:<div><pre class="programlisting">    @IBAction func followAction(sender: UIButton) {
        follow = !follow
        if  follow {
            sender.setTitle("Stop following", forState: .Normal)
        }else {
            sender.setTitle("Resume following", forState: .Normal)
        }
    }</pre></div></li><li class="listitem" value="10">The app is almost done. There is one detail that you still need to set up: the permission on iOS 9. So go to your <code class="email">info.plist</code>, then add a new record with the key <strong class="calibre8">Required background modes</strong>, and write in <code class="email">Item 0</code> a string value of <strong class="calibre8">App registers for location updates</strong>:<div><img src="img/00201.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="11">Now the app is done, press play and walk around if you are using a physical device or <a id="id592" class="calibre1"/>click on <strong class="calibre8">Debug</strong>, then scroll down to location and select freeway drive if you are using the simulator.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec275" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">The core location framework allows us to retrieve the current device position but of course it needs a delegate; that's the reason we had to implement the <code class="email">CLLocationManagerDelegate</code> protocol. This protocol receives positions from the method <code class="email">didUpdateLocations</code>.</p><p class="calibre7">Once we receive it, we could store the location into the <code class="email">locationStack</code> array. Actually if you don't want to keep information of the whole journey, you can just store the last location.</p><p class="calibre7">After storing a new location, we can create a polyline, which is like a segment of our journey. This information is submitted to the map view.</p><p class="calibre7">The map view needs to render it with the method <code class="email">rendererForOverlay</code> of the <code class="email">MKMapViewDelegate</code>. The reason for that is that you are free to draw what you want on the map, and you can create shapes such as circles, squares, and so on for highlighting an area.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec276" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Drawing a route on a <a id="id593" class="calibre1"/>map view is something very common, mainly if you would like to use directions. Have a look at MKDirections, which can be very useful.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec88" class="calibre1"/>Creating the Currency Converter app</h1></div></div></div><p class="calibre7">Nowadays, our <a id="id594" class="calibre1"/>apps must be prepared to be executed everywhere; therefore your app should have as many languages as possible. Consider that internationalization is very important for using different languages or different number formats.</p><p class="calibre7">In this recipe, we are going to create an app that will show us the currency exchange rate, but more important than that, it will be adapted to the current location.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec277" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a single-view application called <code class="email">Chapter 11 Currency Converter</code> and place the two flag pictures on the <code class="email">images.xcassets</code>. These pictures can be downloaded from the book resources.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec278" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Follow these steps to create the Currency Converter app:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, click on the <strong class="calibre8">Supporting Files</strong> group and add a new file. In this case, go to the <strong class="calibre8">Resource</strong> section and select the <strong class="calibre8">Strings File</strong>:<div><img src="img/00202.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Inside this <a id="id595" class="calibre1"/>file, add these keys with their corresponding values:<div><pre class="programlisting">"Rate" = "Rate: %@";
"Total" = "Total: %@";
"Choose Currency" = "Choose a currency";
"flagicon" = "english";
"Cancel" = "Cancel";</pre></div></li><li class="listitem" value="3">Now, go to the storyboard and add four labels, two buttons, a text field, and an image view on the bottom, similar to the following screenshot:<div><img src="img/00203.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Once you have <a id="id596" class="calibre1"/>your layout done, connect the UI components (except the title label) with the view controller with the following names:<div><pre class="programlisting">    @IBOutlet var fromButton: UIButton!
    @IBOutlet var toButton: UIButton!
    @IBOutlet var amountTextField: UITextField!
    @IBOutlet var dateLabel: UILabel!
    @IBOutlet var rateLabel: UILabel!
    @IBOutlet var totalLabel: UILabel!
    @IBOutlet var flagImage: UIImageView!</pre></div></li><li class="listitem" value="5">Change the text field <strong class="calibre8">Keyboard Type</strong> to <strong class="calibre8">Numbers and Punctuations</strong> in the attribute inspector:<div><img src="img/00204.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="6">Add the protocol <code class="email">UITextFieldDelegate</code> to the view controller:<div><pre class="programlisting">class ViewController: UIViewController, <strong class="calibre8">UITextFieldDelegate</strong> {</pre></div></li><li class="listitem" value="7">Now, set the view <a id="id597" class="calibre1"/>controller as the text field delegate and write <code class="email">Amount of money</code> as the text field placeholder.</li><li class="listitem" value="8">Another important action is changing the view class from <code class="email">UIView</code> to <code class="email">UIControl</code> so we can hide the keyboard easily:<div><img src="img/00205.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="9">Go to the view controller and add the following attributes:<div><pre class="programlisting">    let currencies = ["AUD", "BGN", "BRL", "CAD", "CHF",
        "CNY", "CZK", "DKK", "EUR", "GBP", "HKD",
        "HRK", "HUF", "IDR", "ILS", "INR", "JPY", "KRW",
        "MXN", "MYR", "NOK", "NZD", "PHP", "PLN", "RON",
        "RUB", "SEK", "SGD", "THB", "TRY", "USD", "ZAR"]
    let baseurl = "http://api.fixer.io/latest"
    var fromCurrency = "USD"
    var toCurrency = "EUR"</pre></div></li><li class="listitem" value="10">At this time, we can start coding the view controller methods; starting from the beginning we are going to implement the <code class="email">viewDidLoad</code> method:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        flagImage.image = UIImage(named: NSLocalizedString("flagicon", comment: ""))
        setup()
    }</pre></div></li><li class="listitem" value="11">As you can see, there is a private method called <code class="email">setup</code>, which we are going to implement <a id="id598" class="calibre1"/>right now. This method is responsible for retrieving the currency rate from the Internet and calculates the value of the amount of money that the user has entered:<div><pre class="programlisting">    private func setup(){
        fromButton.setTitle(fromCurrency, forState: .Normal)
        toButton.setTitle(toCurrency, forState: .Normal)
        var session = NSURLSession.sharedSession()
        var url = NSURL(string: "\(baseurl)?base=\(fromCurrency)&amp;symbols=\(toCurrency)")!

        session.dataTaskWithURL(url, completionHandler: { (data, response, error) -&gt; Void in
        var json = {}
            do {
        json = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers) as [String:AnyObject]
    } catch {
        let alert = UIAlertController(title: "Error", message: "Error parsing JSON", preferredStyle:.Alert)
        self.presentViewController(alert, animated: true, completion: nil)
    }
            let dateComponentsArray = (json["date"] as String).componentsSeparatedByString("-")
            let dateComponents = NSDateComponents()
            dateComponents.year   = dateComponentsArray[0].toInt()!
            dateComponents.month  = dateComponentsArray[1].toInt()!
            dateComponents.day    = dateComponentsArray[2].toInt()!
            
            let rates = json["rates"] as [String:Double]
            let date = NSCalendar.currentCalendar().dateFromComponents(dateComponents)
            let ratio = rates[self.toCurrency]
            let amount = self.amountTextField.text == "" ? 1.0 : (self.amountTextField.text as NSString).doubleValue
            
            NSOperationQueue.mainQueue().addOperationWithBlock({ () -&gt; Void in
                let dateFormatter = NSDateFormatter()
                dateFormatter.dateStyle = .LongStyle
                self.dateLabel.text = dateFormatter.stringFromDate(date!)
                
                let currencyFormatter = NSNumberFormatter()
                currencyFormatter.currencyCode = self.toCurrency
                currencyFormatter.numberStyle = .CurrencyStyle
                self.rateLabel.text = String(format: NSLocalizedString("Rate", comment: ""), arguments: [currencyFormatter.stringFromNumber(ratio!)!])
                let total = amount * ratio!
                
                self.totalLabel.text = String(format: NSLocalizedString("Total", comment: ""), arguments: [currencyFormatter.stringFromNumber(total)!])
                
            })
        }).resume()
        
    }</pre></div></li><li class="listitem" value="12">We are going to <a id="id599" class="calibre1"/>implement the buttons event. The event is the same for both of them, so connect the touch up event with this method:<div><pre class="programlisting">    @IBAction func chooseCurrency(sender: UIButton) {
        let alertController = UIAlertController(title: NSLocalizedString("Choose Currency", comment: ""), message: nil, preferredStyle: .ActionSheet)
        
        let cancelAction = UIAlertAction(title: NSLocalizedString("Cancel", comment: ""), style: .Cancel) { (action) in
        }
        alertController.addAction(cancelAction)
        
        for currency in currencies {
            let currAction = UIAlertAction(title: currency, style: .Default) { (action) in
                if sender == self.fromButton {
                    self.fromCurrency = action.title
                }else {
                    self.toCurrency = action.title
                }
                self.setup()
            }
            alertController.addAction(currAction)
        }
        
        self.presentViewController(alertController, animated: true, completion: nil)
    }</pre></div></li><li class="listitem" value="13">Connect the main view (the one that we changed to <code class="email">UIControl</code>) touch up event with the view controller creating a method called touchup:<div><pre class="programlisting">    @IBAction func touchup(sender: UIControl) {
        self.amountTextField.resignFirstResponder()
        self.setup()
    }</pre></div></li><li class="listitem" value="14">Now we can <a id="id600" class="calibre1"/>complete the view controller with the last method, which allows us to hide the keyboard when the return key is pressed:<div><pre class="programlisting">    func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
        self.touchup(self.view as UIControl)
        return true
    }</pre></div></li><li class="listitem" value="15">The app is basically done, however we can only say that it is ready for localization, but except for the currency format we can say that there is nothing that could demonstrate it. So click on your project on the project navigator, and go to the info tab of the project. Make sure that you selected the project and not the target. Scroll down to the <strong class="calibre8">Locations</strong> section and click on the plus sign. Select <strong class="calibre8">Spanish,</strong> a new language:<div><img src="img/00206.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="16">Now expand <a id="id601" class="calibre1"/>your storyboard and select <strong class="calibre8">Main.strings (Spanish)</strong>:<div><img src="img/00207.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="17">Change the title from <code class="email">Currency Converter</code> to <code class="email">Conversor de monedas</code> and the text field place holder from <code class="email">Amount of money</code> to <code class="email">Cantidad de dinero</code>. The modified lines should be similar to the following ones:<div><pre class="programlisting">/* Class = "UILabel"; text = "Currency Converter"; ObjectID = "hFW-19-dID"; */
"hFW-19-dID.text" = "Conversor de Monedas";

/* Class = "UITextField"; placeholder = "Amount of money"; ObjectID = "vzh-tY-rr3"; */
"vzh-tY-rr3.placeholder" = "Cantidad de dinero";</pre></div><div><h3 class="title2"><a id="tip55" class="calibre1"/>Tip</h3><p class="calibre7">Try to design the whole layout before translating it to other languages; adding components to your view sometimes makes you translate everything again.</p></div></li><li class="listitem" value="18">Return to <code class="email">Localizable.strings</code>, and on the file inspector, click on the <strong class="calibre8">Localize…</strong> button, which is located in the <strong class="calibre8">Localization</strong> section:<div><img src="img/00208.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="19">A dialog <a id="id602" class="calibre1"/>requesting to move this file to the <code class="email">lproj</code> folder will appear. Choose the base language:<div><img src="img/00209.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="20">As you can see, the localization section has replaced the old button with some language options; check the <strong class="calibre8">Spanish</strong> option:<div><img src="img/00210.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="21">Expand the <code class="email">Localizable.strings</code> and click the Spanish one:<div><img src="img/00211.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="22">Now update the values translating them to the Spanish language, as in the following lines:<div><pre class="programlisting">"Rate" = "Tasa de conversión: %@";
"Total" = "Total: %@";
"Choose Currency" = "Elija la moneda";
"flagicon" = "spanish";
"Cancel" = "Cancelar";</pre></div></li><li class="listitem" value="23">It's time to test our app, press play and check that the app works perfectly fine, then press <a id="id603" class="calibre1"/>the home button, go to <strong class="calibre8">Settings</strong>, enter into the <strong class="calibre8">General</strong> section, tap (or click) on <strong class="calibre8">Language &amp; Region</strong>, and change the region to <strong class="calibre8">Spain</strong> and the language to <strong class="calibre8">Spanish</strong>. Now return to your app and you should see it with Spanish text; the numbers should be represented with the Spanish format:<div><img src="img/00212.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec279" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">When you would like to translate your app to other languages you first have to create it with the base language (default language) but bear in mind that every text can be translated; therefore instead of using hardcoded text, you have to retrieve it from the <code class="email">Localizable.strings</code> file.</p><p class="calibre7">Use the <code class="email">NSLocalizedString</code> for retrieving strings from the Localizable file. You can also get format strings and use them in the String format initializer.</p><p class="calibre7">You can also use date and number formatters using <code class="email">NSDateFormatter</code> and <code class="email">NSNumberFormatter</code>; that way you don't have to worry about local dates and numbers.</p><p class="calibre7">It's also possible to translate your storyboard, so it is not necessary to set the labels and placeholders on the view did load.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec280" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">You can also translate <a id="id604" class="calibre1"/>other files such as the launch screen and the <code class="email">Info.plist</code>. For example you can change the application name according to the language using the <code class="email">Bundle display name</code> key (<code class="email">CFBundleDisplayName</code>).</p><p class="calibre7">The <code class="email">NSLocalizedString</code> has other options that allow you to use translation in complex applications.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec89" class="calibre1"/>Method swizzling in Swift</h1></div></div></div><p class="calibre7">Method swizzling is a <a id="id605" class="calibre1"/>well-known practice with programming languages <a id="id606" class="calibre1"/>that support a dynamic method dispatch. This is also very common in Objective-C. With method swizzling, you are able to swap out a method implementation for a different one at runtime. It is recommended to use method swizzling sparingly and only when an alternative (possibly protocols or extensions) is not present.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec281" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a playground and name it <code class="email">Swizzling</code>. We will not be using a project for this recipe so do not worry about project settings.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec282" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">We will use <code class="email">UIViewController</code> as an example. Add the following code to your playground:<div><pre class="programlisting">extension UIViewController {
    public override static func initialize() {
        struct Static {
            static var token: dispatch_once_t = 0
        }
        
        dispatch_once(&amp;Static.token) {
            let originalSelector = Selector("viewWillAppear:")
            let swizzledSelector = Selector("ViewWillDefinitelyAppear:")
            
            let originalMethod = class_getInstanceMethod(self, originalSelector)
            let swizzledMethod = class_getInstanceMethod(self, swizzledSelector)
            
            let didAddMethod = class_addMethod(self, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))
            
            if didAddMethod {
                class_replaceMethod(self, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))
            } else {
                method_exchangeImplementations(originalMethod, swizzledMethod);
            }
        }
    }
}</pre></div></li><li class="listitem" value="2">We also want to <a id="id607" class="calibre1"/>make sure that we are not swizzling from a <a id="id608" class="calibre1"/>subclass when we expect the super class. Add the following code after initializing the static struct:<div><pre class="programlisting">// Verify this is not a subclass
if self !== UIViewController.self {
    return
}</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec283" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">For this example we want additional actions to be taken for every <code class="email">UIViewController</code>; however, we need to preserve the original functionality of <code class="email">viewWillAppear</code>. This can only be accomplished with method swizzling. Although Swift takes a more static approach to method dispatch, you are still able to swizzle methods at runtime.</p><p class="calibre7">We wrap every call in a <code class="email">dispatch_once</code> block to guarantee this only happens once at runtime. We define each Selector, both the existing and the new one. Once we make a call to <code class="email">class_addMethod</code> we check that it worked, and if so, swap implementations (happens at runtime).</p><p class="calibre7">If you are familiar with Objective-C, you will note that normally swizzling methods occur in the load method, which is guaranteed to be called when a class definition is loaded. Considering this is <a id="id609" class="calibre1"/>an Objective-C method only, we call the swizzling code in initialize, which occurs before any class methods are called.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec284" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">In addition to swizzling system methods, you can also swizzle methods created in custom Swift classes. There are <a id="id610" class="calibre1"/>some extra considerations, however. The class must extend NSObject and the desired method must also include the dynamic attribute in their definition. Using <code class="email">@objc</code> will cause your code to run through the Objective-C runtime (thus supporting dynamic method dispatch); however, it does not guarantee the dynamic dispatch of a property or method.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec90" class="calibre1"/>Associated objects in Swift</h1></div></div></div><p class="calibre7">In addition to <a id="id611" class="calibre1"/>method swizzling, we can also utilize another runtime process <a id="id612" class="calibre1"/>known as associated objects. This is similar to extensions in Swift; however, extensions do not allow you to add a new property to an existing class. Let's add a descriptive name property to all UIViewControllers.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec285" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a playground and name it <code class="email">Associated Objects</code>. We will not be using a project for this recipe so do not worry about project settings. If you used the previous recipe, you may continue with the same playground file.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec286" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">Add the following code to your playground file:<div><pre class="programlisting">extension UIViewController {
    
    private struct AssociatedKeys {
        static var DescriptiveName = "nsh_DescriptiveName"
    }
    
    var descriptiveName: String? {
        get {
            return objc_getAssociatedObject(self, &amp;AssociatedKeys.DescriptiveName) as? String
        }
        
        set {
            if let newValue = newValue {
                objc_setAssociatedObject(
                    self,
                    &amp;AssociatedKeys.DescriptiveName,
                    newValue as NSString?,
                    .OBJC_ASSOCIATION_RETAIN_NONATOMIC
                )
            }
        }
    }
    
}</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec287" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">First, we create a private static struct to store keys that reference our objects. In this case, it will only be the <code class="email">DescriptiveName</code> object. Now we define a new variable for <code class="email">UIViewController</code> <a id="id613" class="calibre1"/>and perform the required methods in the get and set methods.</p><p class="calibre7">We use the <code class="email">objc_getAssociatedObject()</code> to return the proper object and cast it as a String object. For set, we call the <code class="email">objc_setAssociatedObject()</code> method. Here we pass in self to let the <a id="id614" class="calibre1"/>runtime know we are adding to the <code class="email">UIViewController</code> and then reference our static struct for the object we want to associate with the class. Last, we set up the property to be retained and non-atomic.</p><p class="calibre7">The result is that every <code class="email">UIViewController</code> will contain a new property, <code class="email">DescriptiveName</code>, which can be accessed anywhere in code.</p></div></div></body></html>