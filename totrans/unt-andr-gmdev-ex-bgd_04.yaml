- en: Chapter 4. Setting the Stage – Camera Effects and Lighting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。搭建舞台 – 摄像头效果和照明
- en: '*In the previous chapter, you learned about the basic building blocks of any
    game: meshes, materials, and animations. We created a Tank Battle game that utilized
    all of these blocks.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在上一章中，你学习了任何游戏的基本构建块：网格、材质和动画。我们创建了一个利用所有这些块的坦克大战游戏。*'
- en: '*In this chapter, we will expand upon the Tank Battle game. We will start with
    the addition of a skybox and distance fog. The exploration of camera effects continues
    with a target indicator overlay that uses a second camera. The creation of a turbo
    boost effect for the tank will round out our look at camera effects. Continuing
    with a look at lighting, we will finish off our tank environment with the addition
    of lightmaps and shadows.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将扩展坦克大战游戏。我们将从添加天空盒和距离雾开始。通过使用第二个摄像头，继续探索摄像头效果，并添加一个坦克的涡轮加速效果，以完善我们对摄像头效果的观察。继续观察照明，我们将通过添加光照贴图和阴影来完成坦克环境的设置。*'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Skyboxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天空盒
- en: Distance fog
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离雾
- en: Using multiple cameras
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个摄像头
- en: Adjusting the field of view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整视野
- en: Adding lights
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加灯光
- en: Creating lightmaps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建光照贴图
- en: Adding cookies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加饼干
- en: We will be directly piggybacking off the project from [Chapter 3](ch03.html
    "Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations"), *The
    Backbone of Any Game – Meshes, Materials, and Animation*. So, open it in Unity
    and we will get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接利用[第3章](ch03.html "第3章。任何游戏的骨架 – 网格、材质和动画")的项目，即《任何游戏的骨架 – 网格、材质和动画》。因此，在Unity中打开它，我们就可以开始了。
- en: The camera effects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像头效果
- en: There are many great camera effects that you should add to give your game the
    last great finishing touch. In this chapter, we will be covering a few options
    that are easy to add. These will also give our tank game a great finished look.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的摄像头效果你应该添加，以给你的游戏带来最后的完美触感。在本章中，我们将介绍一些易于添加的选项。这些也将使我们的坦克游戏看起来非常完美。
- en: Skyboxes and distance fog
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 天空盒和距离雾
- en: When a camera renders a frame of a game, it starts by clearing the screen. By
    default, cameras in Unity do this by coloring everything in solid blue. All of
    the game's meshes are then drawn on top of this blank screen. Blue is rather boring
    for an exciting battle of tanks. So, lucky for us, Unity allows us to change the
    color. But, pink is not better than blue, so we have to change the method of clearing
    the screen. This is where the skybox comes in. A skybox is just a fancy word for
    the series of images that form the background sky of any game. Distance fog works
    in conjunction with the skybox by easing the visual transition between models
    and background.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当摄像头渲染游戏的帧时，它首先会清除屏幕。默认情况下，Unity中的摄像头通过将一切染成纯蓝色来完成这一操作。然后，所有的游戏网格都会绘制在这个空白屏幕上。对于一场激动人心的坦克大战来说，蓝色相当无聊。所以，幸运的是，Unity允许我们更改颜色。但是，粉红色并不比蓝色好，所以我们必须改变清除屏幕的方法。这就是天空盒的用武之地。天空盒只是指形成任何游戏背景天空的一系列图像。距离雾与天空盒协同工作，通过简化模型和背景之间的视觉过渡。
- en: Time for action – adding a skybox and distance fog
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加天空盒和距离雾
- en: The very first thing we need is a skybox, obviously. We could create our own;
    however, Unity provides us with several excellent ones that will fit our needs
    just fine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是一个天空盒，这是显而易见的。我们可以自己创建一个；然而，Unity为我们提供了几个非常出色的天空盒，它们完全可以满足我们的需求。
- en: At the top of the Unity Editor, select **Assets** followed by **Import Package**.
    About half way down this list, select **Skyboxes**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，选择**资产**然后选择**导入包**。在这个列表大约一半的位置，选择**天空盒**。
- en: After a little bit of processing, a new window will pop up. A package in Unity
    is just a compressed group of assets that have already been set up in Unity. This
    window displays the contents and allows us to selectively import them. We want
    them all, so just click on **Import** in the bottom-right corner of this window.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过一点处理，一个新窗口将弹出。在Unity中，一个包只是一个已经设置好的资产的压缩组。这个窗口显示了内容，并允许我们选择性地导入它们。我们想要所有这些，所以只需点击窗口右下角的**导入**按钮。
- en: A new folder, `Standard Assets`, will be added to the **Project** window. This
    contains a folder, `Skyboxes`, which contains various skybox materials. Select
    any one of these. You can see in the **Inspector** window that they are normal
    materials that make use of the Skybox shader. They each have six images, one for
    each direction.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project** 窗口中将添加一个新的文件夹，`Standard Assets`。这个文件夹包含一个名为 `Skyboxes` 的文件夹，其中包含各种天空盒材质。选择其中任何一个。你可以在
    **Inspector** 窗口中看到它们是使用 Skybox 着色器的普通材质。每个都有六个图像，每个方向一个。
- en: To add the skybox of your choice to the game, first make sure you have the correct
    scene loaded. If you do not, simply double-click on it in the **Inspector** window.
    This is necessary because the settings we are about to change are specific to
    each scene.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将你选择的天空盒添加到游戏中，首先确保你已加载了正确的场景。如果没有，只需在 **Inspector** 窗口中双击它。这是必要的，因为我们即将更改的设置是针对每个场景特定的。
- en: Go to the top of the Unity Editor and select **Edit**, followed by **Render
    Settings**. The new group of settings will appear in the **Inspector** window.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Unity 编辑器的顶部，选择 **Edit**，然后选择 **Render Settings**。新的设置组将出现在 **Inspector**
    窗口中。
- en: At the moment we are concerned with the value that is fifth from the bottom,
    **Skybox Material**. Just drag-and-drop the skybox material into the **Skybox
    Material** slot and it will be automatically updated. The change can be viewed
    in the **Game** window.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前我们关注的是从底部起的第五个值，**Skybox Material**。只需将天空盒材质拖放到 **Skybox Material** 槽中，它将自动更新。变化可以在
    **Game** 窗口中查看。
- en: To add distance fog, we also adjust it in **Render Settings**. To turn it on,
    simply click on the **Fog** checkbox.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加距离雾，我们也在 **Render Settings** 中进行调整。要启用它，只需点击 **Fog** 复选框。
- en: The next setting, **Fog Color**, allows us to pick a color for the fog. It is
    good to pick a color that is close to the general color of the skybox.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个设置，**Fog Color**，允许我们为雾选择一个颜色。选择一个接近天空盒一般颜色的颜色是好的。
- en: '**Fog Mode** is a drop-down list of options that dictate the method Unity will
    use to calculate the distance fog. For nearly all cases, the default of **Exp2**
    is suitable.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Fog Mode** 是一个下拉列表，用于指定 Unity 将使用哪种方法来计算距离雾。对于几乎所有情况，默认的 **Exp2** 都很合适。'
- en: The next three settings, **Fog Density**, **Linear Fog Start**, and **Linear
    Fog End**, all determine how much fog there is and how close it starts. **Fog
    Density** is used for the **Exponential** and **Exp2** fog modes while the others
    are used for the **Linear** fog mode. Settings that put the fog at the edge of
    sight are generally good.![Time for action – adding a skybox and distance fog](img/2014OT_04_01.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的三个设置，**Fog Density**、**Linear Fog Start** 和 **Linear Fog End**，都决定了雾的密度和开始距离。**Fog
    Density** 用于 **Exponential** 和 **Exp2** 雾模式，而其他用于 **Linear** 雾模式。将雾置于视线边缘的设置通常很好。[添加天空盒和距离雾的时间
    - 添加天空盒和距离雾](img/2014OT_04_01.jpg)
- en: '*What just happened?*'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We imported several skyboxes and added them to the scene. The distance fog settings
    were also turned on and adjusted. Now, our scene has started to look like a real
    game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了几个天空盒并将它们添加到场景中。距离雾设置也被打开并调整。现在，我们的场景开始看起来像一款真正的游戏。
- en: Target indicator
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标指示器
- en: Another camera effect that is rather interesting is the use of multiple cameras.
    A second camera could be used for making a 3D GUI, a minimap, or perhaps a security
    camera pop-up. In this next section, we will be creating a system that will point
    at targets that are nearby. Using a second camera, we will make it appear above
    the player's tank.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当有趣的游戏摄像机效果是使用多个摄像机。第二个摄像机可以用来制作 3D GUI、小地图，或者可能是弹出式安全摄像头。在接下来的这一节中，我们将创建一个指向附近目标的系统。使用第二个摄像机，我们将使其出现在玩家的坦克上方。
- en: Time for action – creating the pointer
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加指针的时间 - 创建指针
- en: 'We are going to start by creating an object that will point at targets. We
    will be making a prefab that can be used repeatedly. However, you will need a
    model for the player to see. We will use a pie-slice type mesh. The size isn''t
    particularly important; we will be adjusting the scale later. Let''s perform the
    following steps to create the pointer:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个指向目标的物体。我们将制作一个可以重复使用的预制件。然而，你需要一个玩家可以看到的模型。我们将使用一种饼状类型的网格。大小并不特别重要；我们稍后会调整其比例。让我们执行以下步骤来创建指针：
- en: Once you have created and imported your mesh, add it to the scene.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建并导入你的网格，将其添加到场景中。
- en: Create an empty `GameObject` and rename it to `IndicatorSlice`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 `GameObject` 并将其重命名为 `IndicatorSlice`。
- en: Make your mesh a child of `IndicatorSlice` and position it so that it points
    along the GameObject's z axis. `IndicatorSlice` will be centered in our indicator.
    Each slice that is created will have its z axis pointing in the direction of a
    target.![Time for action – creating the pointer](img/2014OT_04_02.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的网格设置为`IndicatorSlice`的子对象，并定位它，使其沿着GameObject的z轴指向。`IndicatorSlice`将位于我们的指示器中心。每个创建的切片都将使其z轴指向目标的方向。![行动时间
    – 创建指针](img/2014OT_04_02.jpg)
- en: Now, we need to create a new script that will control our indicator. Create
    a new script called **TargetIndicator** in the **Project** window.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的脚本，用来控制我们的指示器。在**项目**窗口中创建一个名为**TargetIndicator**的新脚本。
- en: We start this script off with a pair of variables. The first will hold a reference
    to the target that this indicator piece will point at. The indicator is also going
    to grow and shrink based on how far away the target is. The second variable will
    control the distance at which the indicator will start to grow.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从这个脚本开始，定义一对变量。第一个变量将保存对目标对象的引用，该指示器组件将指向这个目标。指示器的大小将根据目标距离的远近而增长或缩小。第二个变量将控制指示器开始增长的距离。
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next function will be used to set the `target` variable when the indicator
    piece is created.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数将用于在创建指示器组件时设置`target`变量。
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last set of code goes in the `LateUpdate` function. The `LateUpdate` function
    is used so the indicator pieces can point at a target after our tank moves in
    the `Update` function. We start the function with a check to make sure the target
    variable has a value. If it is null, the indicator slice is destroyed. The `Destroy`
    function can be used to remove any object that exists from the game. The `gameObject`
    variable is automatically provided by the `MonoBehaviour` class and holds a reference
    to the `GameObject` that the script component is attached to. Destroying it will
    also destroy everything that is a child of (or attached to) it.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一段代码放在`LateUpdate`函数中。`LateUpdate`函数用于确保在`Update`函数中坦克移动之后，指示器组件可以指向目标。函数开始时，我们检查目标变量是否有值。如果它是null，则销毁指示器切片。`Destroy`函数可以用来从游戏中移除任何存在的对象。`gameObject`变量由`MonoBehaviour`类自动提供，并持有与脚本组件附加的`GameObject`的引用。销毁它也将销毁其所有子对象（或附加对象）。
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next bit of code sets the scale of the indicator slice. As you can see in
    the following code snippet, the first line of code uses `Vector3.Distance` to
    determine how far the two positions are from each other. The next code line determines
    the vertical scale, y axis, of the slice. It does so by using a bit of carefully
    applied math and the `Mathf.Clamp01` function. This function limits the supplied
    value to be between zero and one. The last line of code sets the indicator slice's
    local scale. By adjusting the local scale, we can easily control how big the whole
    indicator is by just changing the scale of the parent object.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块设置了指示器切片的缩放比例。正如你在下面的代码片段中可以看到，第一行代码使用`Vector3.Distance`来确定两个位置之间的距离。下一行代码确定了切片的垂直缩放，即y轴。这是通过一些精心应用的数学和`Mathf.Clamp01`函数来实现的。这个函数将提供的值限制在零和一之间。最后一行代码设置了指示器切片的本地缩放。通过调整本地缩放，我们可以通过仅更改父对象的缩放来轻松控制整个指示器的大小。
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One last set of code for this script. The `transform.LookAt` function is just
    a fancy, automatic way of rotating a `GameObject` so its z axis points to a specific
    spot in the world. However, we want all of the indicator slices to lay flat on
    the ground and not pointing into the air at any targets that might be above us.
    So, we collect the target's position. By setting the variable's Y value to the
    position of the slice, we ensure that the slice remains flat. That last line,
    of course, closes off the `LateUpdate` function.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这段代码用于此脚本。`transform.LookAt`函数是一种自动旋转`GameObject`以使其z轴指向世界中的特定位置的高级方式。然而，我们希望所有指示器切片都平铺在地面上，而不是指向可能在我们上面的任何目标。因此，我们收集目标的位置。通过将变量的Y值设置为切片的位置，我们确保切片保持平铺。当然，最后一行关闭了`LateUpdate`函数。
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That is the last code for this script. Return to Unity and add the `TargetIndicator`
    script to the `IndicatorSlice` object in the scene.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是此脚本的最后一部分代码。返回Unity，并将`TargetIndicator`脚本添加到场景中的`IndicatorSlice`对象。
- en: To finish off the indicator, create a prefab of it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成指示器的创建，创建一个它的预制件。
- en: Lastly, delete the `IndicatorSlice` object from the scene. We will be creating
    slices dynamically when the game starts. That requires the prefab, but not the
    one in the scene.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从场景中删除`IndicatorSlice`对象。游戏开始时我们将动态创建切片。这需要预制件，但不是场景中的那个。
- en: '*What just happened?*'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a prefab of the object we will be using to indicate the direction
    of targets. The script that was created and attached will rotate each instance
    of the prefab to point at the target. It will also adjust the scale to indicate
    how far the target is from the player.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个我们将用来指示目标方向的物体的预制件。附加的脚本将旋转预制件的每个实例以指向目标。它还将调整比例以指示目标与玩家之间的距离。
- en: Time for action – controlling the indicator
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 控制指示器
- en: We now need to create a script that will control the indicator slices. This
    will include creating new slices as they are needed. Also, the `GameObject` it
    is attached to will act as a center point for the indicator slices, that we just
    created, to rotate around.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个控制指示切片的脚本。这包括在需要时创建新的切片。此外，它附加到的`GameObject`将作为我们刚刚创建的指示切片的中心点，围绕它旋转。
- en: Create a new script and name it `IndicatorControl`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并将其命名为`IndicatorControl`。
- en: We start this script off with a pair of variables. The first will hold a reference
    to the prefab that was just created. This will allow us to spawn instances of
    it whenever we desire. The second is a static variable, meaning it can be easily
    accessed without a reference to the component that exists in the scene. It will
    be filled when the game starts with a reference to the instance of this script
    that is in the scene.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从这个脚本开始，有一对变量。第一个将保存对刚刚创建的预制件的引用。这将允许我们随时生成其实例。第二个是静态变量，这意味着它可以很容易地被访问，而无需对场景中存在的组件的引用。游戏开始时，它将填充场景中此脚本实例的引用。
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This next function will be used by the targets. Soon, we will be updating the
    target's script to call this function at the beginning of the game. The function
    is static, just like the variable, and starts by checking to see whether there
    is a reference to any object in it. If it is empty, equal to null, `Object.FindObjectOfType`
    is used to attempt to fill the variable. By telling it what type of object we
    want to find, it will search in the game and try to find one. This is relatively
    a slow process and should not be used often, but we use this process and the variable
    so that we can always be sure that the system can find the script. The second
    part of the `CreateSlice` function checks to make sure our static variable is
    not empty. If so, it then tells the instance to create a new indicator slice and
    passes it to the target.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数将由目标使用。很快，我们将更新目标的脚本，使其在游戏开始时调用此函数。该函数是静态的，就像变量一样，首先检查其中是否有对任何对象的引用。如果它是空的，等于null，则使用`Object.FindObjectOfType`尝试填充变量。通过告诉它我们想要找到的对象类型，它将在游戏中搜索并尝试找到。这是一个相对较慢的过程，不应经常使用，但我们使用这个过程和变量，以确保系统总能找到脚本。`CreateSlice`函数的第二部分检查确保我们的静态变量不为空。如果是这样，它就会告诉实例创建一个新的指示切片并将其传递给目标。
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One more function for this script. The `NewSlice` function does as its name
    implies, it creates new indicator slices when called. It does this by first using
    the `Instantiate` function to create a copy of the `GameObject` that is passed
    to it. The second line of the function makes the new slice a child of the control's
    transform. The next line just zeroes out the local position of the new slice.
    This way it will be centered properly after it is created. The last line uses
    the slice's `SendMessage` function to call the `SetTarget` function that we created
    previously and passes it the desired target object.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此脚本添加一个额外的函数。`NewSlice`函数正如其名所示，在调用时创建新的指示切片。它是通过首先使用`Instantiate`函数创建传递给它的`GameObject`的副本来完成的。函数的第二行使新的切片成为控制变换的子对象。下一行将新切片的局部位置归零。这样，在创建后它将正确居中。最后一行使用切片的`SendMessage`函数调用我们之前创建的`SetTarget`函数，并传递所需的靶对象。
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that the script is created, we need to use it. Create an empty `GameObject`
    and name it `IndicatorControl`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本创建好了，我们需要使用它。创建一个空的`GameObject`并将其命名为`IndicatorControl`。
- en: The new `GameObject` needs to be made a child of your tank, followed by having
    its position set to zero on each axis.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`GameObject`需要成为你的坦克的子对象，然后将其在每个轴上的位置设置为零。
- en: Add the script we just created to `IndicatorControl`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚创建的脚本添加到`IndicatorControl`中。
- en: Finally, with the `GameObject` selected, add the reference to the `IndicatorSlice`
    prefab. Do this by dragging the prefab from the **Project** window to the proper
    slot in the **Inspector** window.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择`GameObject`后，添加对`IndicatorSlice`预设件的引用。通过将预设件从**项目**窗口拖动到**检查器**窗口的正确槽位来完成此操作。
- en: '*What just happened?*'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a script that will control the spawning of our target indicator slices.
    The `GameObject` we created at the end will also allow us to control the size
    of the whole indicator with ease. We are almost done with the target indicator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个脚本，用于控制目标指示切片的生成。我们创建的`GameObject`也将使我们能够轻松地控制整个指示器的大小。我们几乎完成了目标指示器的制作。
- en: Time for action – working with a second camera
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——使用第二个相机
- en: If you were to play the game now, it would still look no different. This is
    because the targets do not yet make the call to create the indicator slices. We
    will also be adding that second camera in this section as we finish off the target
    indicator.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在开始玩游戏，它看起来仍然没有不同。这是因为目标还没有调用创建指示切片。我们将在完成目标指示器后，在本节中添加第二个相机。
- en: Start by opening the `Target` script and adding the following line of code to
    the end of the `Awake` function. This line tells the `IndicatorControl` script
    to create a new indicator slice for this target.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`Target`脚本，并在`Awake`函数的末尾添加以下代码行。这一行告诉`IndicatorControl`脚本为这个目标创建一个新的指示切片。
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Time for action – working with a second camera](img/2014OT_04_03.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![是时候行动了——使用第二个相机](img/2014OT_04_03.jpg)'
- en: On playing the game now, you can see the indicator in action. However, it is
    probably too large and certainly appears inside the tank. A bad solution would
    be to move the `IndicatorControl` object until the whole thing appears above the
    tank. However, when explosions occur and things start flying through the air,
    they will obscure the target indicator all over again. A better solution is to
    add a second camera. Do so now by selecting **GameObject** from the top of the
    Unity Editor, followed by **Create Other**, and finally **Camera**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在玩游戏时，你可以看到指示器正在起作用。然而，它可能太大，并且显然出现在坦克内部。一个不好的解决方案是将`IndicatorControl`对象移动，直到整个指示器都出现在坦克上方。然而，当爆炸发生，东西开始在空中飞舞时，它们将再次遮挡目标指示器。一个更好的解决方案是添加一个第二个相机。现在通过从Unity编辑器的顶部选择**GameObject**，然后选择**创建其他**，最后选择**相机**来完成此操作。
- en: Additionally, make the camera a child of `Main Camera`. Be sure to set the new
    camera's position and rotation values to zero.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将相机设置为`Main Camera`的子对象。确保将新相机的位置和旋转值设置为零。
- en: 'By default, every camera in Unity is given a variety of components: **Camera**,
    **Flare Layer**, **GUI Layer**, and **Audio Listener**. Besides the **Camera**
    component, the others are generally unimportant to every other camera, and there
    should only be one **Audio Listener** component in the whole of the scene. Remove
    the excess components from the camera, leaving just the **Camera** component.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Unity中的每个相机都配备了各种组件：**相机**、**光晕层**、**GUI层**和**音频监听器**。除了**相机**组件外，其他组件对每个相机通常都不重要，整个场景中应该只有一个**音频监听器**组件。从相机中移除多余的组件，只留下**相机**组件。
- en: Before we do anything else with the camera, we need to change the layer that
    the `IndicatorSlice` prefab is on. Layers are used to cause selective interaction
    between objects. They are used primarily for physics and rendering. First select
    the prefab in the **Project** window.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们对相机进行任何其他操作之前，我们需要更改`IndicatorSlice`预设件所在的层。层用于在对象之间引起选择性的交互。它们主要用于物理和渲染。首先在**项目**窗口中选择预设件。
- en: At the top of the **Inspector** window is the **Layer** label with a drop-down
    list that reads **Default**. Click on the drop-down list and select **Add Layer...**
    from the list.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的顶部是带有下拉列表的**层**标签，列表中显示为**默认**。点击下拉列表，从列表中选择**添加层...**。
- en: A list of layers will now appear in the **Inspector** window. These are all
    the layers used in the game. The first few are reserved for use by Unity; hence,
    they are grayed out. The rest are for our use. Click on the right-hand side of
    **User Layer 8** and name it **Indicator**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将出现在**检查器**窗口中一个层的列表。这些都是游戏中使用的层。前几个是为Unity保留的；因此，它们被灰色显示。其余的是供我们使用的。点击**用户层8**的右侧，将其命名为**指示器**。
- en: Select the `IndicatorSlice` prefab again. This time select the new **Indicator**
    layer from the **Layer** drop-down list.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择`IndicatorSlice`预设件。这次从**层**下拉列表中选择新的**指示器**层。
- en: Unity will ask if we want to change the layer of all the child objects as well.
    We would want the whole object rendered on this layer, so select **Yes, change
    children** and we will be able to do so.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity会询问我们是否想要更改所有子对象所在的层。我们希望整个对象都渲染在这个层上，因此选择**是，更改子对象**，我们就可以这样做。
- en: Now, back to our second camera. Select it and take a look in the **Inspector**
    window.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到我们的第二个相机。选择它，并在**检查器**窗口中查看。
- en: The first attribute of the **Camera** component is **Clear Flags**. This list
    of options dictate what the camera will fill the background with before drawing
    all of the models in the game. The second camera does not block out everything
    drawn by the first camera. We select **Depth only** from the **Clear Flags** drop-down
    list. This means that, instead of putting the skybox in the background, it will
    leave what was already rendered and just draw new things on top.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**相机**组件的第一个属性是**清除标志**。此选项列表决定了相机在绘制游戏中的所有模型之前将填充背景的内容。第二个相机不会阻挡第一个相机绘制的内容。我们从**清除标志**下拉列表中选择**深度仅**。这意味着，而不是在背景中放置天空盒，它将保留已经渲染的内容，并在其上绘制新内容。'
- en: The next attribute, **Culling Mask**, controls which layers are rendered by
    the camera. The first two options, **Nothing** and **Everything**, are for deselection
    and quick selection of all of the layers. For this camera, deselect all other
    layers, so that only the **Indicator** layer has a check next to it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个属性，**裁剪遮罩**，控制相机渲染哪些层。前两个选项，**无**和**所有**，用于取消选择和快速选择所有层。对于这个相机，取消选择所有其他层，以便只有**指示器**层旁边有勾选。
- en: The last thing to do is to adjust the scale of `IndicatorControl` so that the
    target indicator is not too large or small.![Time for action – working with a
    second camera](img/2014OT_04_04.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要做的事情是调整`IndicatorControl`的缩放比例，以确保目标指示器的大小适中。![行动时间 - 使用第二个相机](img/2014OT_04_04.jpg)
- en: '*What just happened?*'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a system to indicate the direction of potential targets. To do this,
    we used a second camera. By adjusting the layers in the **Culling Mask** attribute,
    we can make a camera render only a part of a scene. Also, by changing the **Clear
    Flags** attribute to **Depth only**, the second camera can draw on top of what
    was drawn by the first camera.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个系统来指示潜在目标的方位。为此，我们使用了第二个相机。通过调整**裁剪遮罩**属性中的层，我们可以使相机只渲染场景的一部分。此外，通过将**清除标志**属性更改为**深度仅**，第二个相机可以在第一个相机绘制的内容之上绘制。
- en: Have a go hero – adjusting the position
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 调整位置
- en: It is possible to change where the indicator is drawn by moving the camera.
    If you were to instead move the `IndicatorControl` object, it will change how
    the distance from and direction to targets are calculated. Move and angle the
    second camera so that there is a more pleasing view of the target indicator.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移动相机，可以改变指示器的绘制位置。如果你移动`IndicatorControl`对象，它将改变目标距离和方向的计算方式。移动并调整第二个相机，以便获得更令人愉悦的目标指示器视图。
- en: When you were moving the second camera or when you use the boost from the next
    section, you probably noticed that the target indicator can still be seen in the
    tank. Adjust the main camera so that it does not render the target indicator.
    This is done very similarly to how we made the second camera only render the target
    indicator.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动第二个相机或使用下一节中的加速功能时，你可能注意到目标指示器仍然可以在坦克中看到。调整主相机，使其不渲染目标指示器。这和我们在第二个相机上只渲染目标指示器的方式非常相似。
- en: Turbo boost
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 涡轮加速
- en: The last camera effect we will be looking at in this chapter is a turbo boost.
    It is going to be a button on the screen that will propel the player forward rapidly
    for a short amount of time. The camera effect comes in because a simple adjustment
    to the **Field of View** attribute can make it look as if we are going much faster.
    A similar method is used by movies to make the car chases look even faster.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的最后一种相机效果是涡轮加速。它将在屏幕上显示一个按钮，玩家按下后会快速向前推进一段时间。相机效果之所以重要，是因为对**视野**属性的简单调整可以使我们看起来移动得更快。电影中通常使用类似的方法来使汽车追逐看起来更快。
- en: Time for action – using the boost effect
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用加速效果
- en: We will only be making a single script in this section. It will move the tank
    in a similar manner to the `ChassisControls` script we created in the last chapter.
    The difference is, we won't have to hold down a button for the boost to work.
    Let's get to it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只将编写一个脚本。它将以与我们在上一章中创建的`ChassisControls`脚本类似的方式移动坦克。不同之处在于，我们不需要按住按钮来使加速功能生效。让我们开始吧。
- en: Start by creating a new script and calling it `TurboBoost`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的脚本，并将其命名为`TurboBoost`。
- en: To start the script off, we need four variables. The first is a reference to
    `CharacterController`. We need this for movement. The second is how fast we will
    be moving while boosting. The third is how long, in seconds, we will be boosting.
    The last is used internally for whether or not we can boost and when we should
    stop.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动脚本，我们需要四个变量。第一个是`CharacterController`的引用。我们需要这个来移动坦克。第二个是我们加速时的移动速度。第三个是我们将加速多长时间，以秒为单位。最后一个用于内部判断我们是否可以加速以及何时应该停止。
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next bit of code returns to our good friend, the `OnGUI` function. Here
    we are just drawing a button on the screen, the same as we did several times before.
    If the button is pressed, it calls the `StartBoost` function that we will be writing
    in a moment.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的代码返回到我们熟悉的朋友`OnGUI`函数。在这里，我们只是在屏幕上绘制一个按钮，就像我们之前多次做的那样。如果按钮被按下，它将调用我们即将编写的`StartBoost`函数。
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `StartBoost` function is pretty simple. It checks to see if the `startTime`
    variable is less than zero. If it is, the variable is set to the current time
    as provided by `Time.time`. Being less than zero means that we are not currently
    boosting.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StartBoost`函数相当简单。它检查`startTime`变量是否小于零。如果是，变量被设置为`Time.time`提供的当前时间。小于零意味着我们目前没有在加速。'
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last function we are going to use is the `Update` function. It begins with
    a check of `startTime` to see if we are currently boosting. If we are not boosting,
    the function is exited early. The next line of code checks to make sure we have
    our `CharacterController` reference. If the variable is empty, then we can't make
    the tank move.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要使用的最后一个函数是`Update`函数。它从检查`startTime`是否正在加速开始。如果我们没有在加速，函数会提前退出。下一行代码检查我们是否有了`CharacterController`引用。如果变量为空，那么我们无法使坦克移动。
- en: '[PRE12]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next line of code should look familiar. This is the line that makes the
    tank move.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码看起来应该很熟悉。这是使坦克移动的行。
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following few lines of code actually apply the camera effect. First is a
    check to see whether we are in the first half-second of the boost. If we are,
    we transition the camera by adjusting the `fieldOfView` value. The `Camera.main`
    value is just a reference provided by Unity to the main camera used in the scene.
    The `Mathf.Lerp` function takes a starting value and moves it towards a goal value
    based on a third value between zero and one. Using this, the camera's `fieldOfView`
    is moved towards our goal over the half-second. The second half of this set of
    code checks for the last half-second of our boost and uses the same method to
    transition the `fieldOfView` value back to the default.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下几行代码实际上应用了相机效果。首先是一个检查，看看我们是否处于加速的前半秒。如果是，我们通过调整`fieldOfView`值来过渡相机。`Camera.main`值是Unity提供的对场景中使用的主相机的引用。`Mathf.Lerp`函数根据介于零和一之间的第三个值将起始值移动到目标值。使用这个函数，相机的`fieldOfView`在半秒内移动到目标值。这组代码的第二部分检查我们加速的最后半秒，并使用相同的方法将`fieldOfView`值过渡回默认值。
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last bit of code checks to see whether we are done boosting. If so, `startTime`
    is set to negative one to indicate that we can start another boost. That last
    curly brace, of course, closes off the `Update` function.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一段代码检查我们是否已经完成加速。如果是，`startTime`被设置为负一，以表示我们可以开始另一个加速。当然，最后一个花括号关闭了`Update`函数。
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are almost done. Add the script to your tank and connect the `CharacterController`
    reference.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了。将脚本添加到坦克中，并连接`CharacterController`引用。
- en: Try it out.![Time for action – using the boost effect](img/2014OT_04_05.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一下。![行动时间 - 使用加速效果](img/2014OT_04_05.jpg)
- en: '*What just happened?*'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a turbo boost. The same method of movement used in the last chapter
    moves the tank here. By adjusting the **Field of View** attribute of the camera,
    we make it look like the tank is moving even faster.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个涡轮增压。与上一章中使用的相同移动方法在这里移动坦克。通过调整相机的**视野**属性，我们让坦克看起来移动得更快。
- en: Have a go hero – styling and control
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄级操作——风格和控制
- en: The easy and obvious challenge here is to style the button. To spice it up,
    try changing it so there is a label while boosting and a button when not boosting.
    The label and button could each have their own style.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的简单挑战是设计按钮样式。为了增加趣味性，尝试将其改为在加速时有标签，在不加速时有按钮。标签和按钮可以各自有不同的样式。
- en: Another thing you might notice while playing the game is that you can still
    turn while boosting. Try adding a check to the `ChassisControls` script to lock
    the controls, if we are boosting. You are going to need to add a reference to
    the `TurboBoost` script.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏时，你可能还会注意到，你可以在加速的同时转向。尝试向`ChassisControls`脚本添加一个检查，以锁定控制，如果我们正在加速。你需要添加对`TurboBoost`脚本的引用。
- en: 'For an added, extra challenge try adding a cooldown to the boost. Make it so
    the player can''t constantly use the boost. Also, try canceling the boost if the
    tank runs into something. This is a big one, so you will start off with a hint:
    take a look at `OnControllerColliderHit`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加额外的挑战，尝试为加速添加冷却时间。让玩家不能持续使用加速。此外，尝试在坦克撞到东西时取消加速。这是一个很大的问题，所以你将从一个提示开始：查看`OnControllerColliderHit`。
- en: Lights
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光源
- en: 'Unity provides a variety of light types for brightening the game world. They
    are **Directional Light**, **Spotlight**, **Point Light**, and **Area Light**.
    Each of them projects light in a different way and are explained in detail as
    follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了各种光源类型来照亮游戏世界。它们是**方向光源**、**聚光灯**、**点光源**和**区域光源**。每种光源都以不同的方式投射光线，以下将详细解释：
- en: '**Directional Light**: This functions very much like the sun. It projects all
    of its light in a single direction. The position of the light does not matter,
    only the rotation. Light is projected over the entirety of the scene in one direction.
    This makes it perfect for initially adding light to a scene.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光源**：这非常像太阳。它将所有光线投射到单一方向。光源的位置并不重要，只有旋转。光线以单一方向投射到场景的整个区域。这使得它非常适合最初向场景添加光线。'
- en: '**Spotlight**: This functions just like the ones on a stage. Light is projected
    in a cone-like shape in a specific direction. Because of this, it is also the
    most complex light type for the system to calculate. Unity has made significant
    improvements in how it calculates lights, but overuse of these lights should be
    avoided.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**：这就像舞台上的聚光灯一样工作。光线以锥形形状向特定方向投射。正因为如此，它也是系统计算中最复杂的光源类型。Unity在计算光线方面做出了重大改进，但应避免过度使用这些光源。'
- en: '**Point Light**: This is the primary light type that will be used in your games.
    It emits light in every direction. This functions just like a light bulb.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**：这是你游戏中将使用的主要光源类型。它向所有方向发射光线。这就像一个灯泡一样工作。'
- en: '**Area Light**: This is a special-use light. It emits light in a single direction
    from a plane. Think of it as the big neon sign used to advertise a hotel or restaurant.
    Because of their complexity, these lights can only be used when baking shadows.
    There are too many calculations for them to be used when the game is running.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域光源**：这是一种特殊用途的光源。它从平面以单一方向发射光线。想象一下，它就像用来宣传酒店或餐厅的大型霓虹灯招牌。由于它们的复杂性，这些光源只能在烘焙阴影时使用。当游戏运行时，由于计算量太大，它们无法使用。'
- en: The next obvious question when talking about lights concerns shadows, especially
    real-time shadows. While real-time shadows add a lot to a scene and are technically
    possible on any platform, they are very expensive. On top of that, they are a
    Unity Pro feature. All in all, that makes them a bit too much for your average
    mobile game.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到光线时，下一个明显的问题就是阴影，尤其是实时阴影。虽然实时阴影可以为场景增添很多效果，并且在技术上任何平台都可行，但它们非常昂贵。此外，它们是Unity
    Pro的功能。总的来说，这使得它们对于普通移动游戏来说有点过于复杂。
- en: On the other hand, there are perfectly viable alternatives that do not cost
    nearly as much and often look more realistic than real-time shadows. The first
    is for your environment. In general, the environment in a game never moves and
    never changes within a specific scene. For this, we have lightmaps. They are extra
    textures that contain shadow data. Using Unity you can create these textures while
    making your game. Then, when the game is running, they are automatically applied
    and your shadows appear. This however does not work for dynamic objects (anything
    that moves).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些完全可行的替代方案，成本远低于实时阴影，而且通常看起来比实时阴影更真实。第一个是针对你的环境。一般来说，游戏中的环境永远不会移动，也不会在特定场景中改变。为此，我们有光照贴图。这些是包含阴影数据的额外纹理。使用Unity，你可以在制作游戏时创建这些纹理。然后，当游戏运行时，它们会自动应用，你的阴影就会出现。然而，这并不适用于动态对象（任何移动的物体）。
- en: For dynamic objects we have cookies. These are not your grandmother's cookies.
    In lighting, a cookie is a black and white image that is projected onto meshes
    in the game. This is similar to shadow puppets. The shadow puppets use a cutout
    to block a part of the light, whereas cookies use black and white images to tell
    the light where it can cast its light.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态对象，我们有饼干。这些不是你祖母的饼干。在照明中，饼干是一种黑白图像，它被投射到游戏中的网格上。这类似于影子戏。影子戏使用剪影来遮挡光线的一部分，而饼干使用黑白图像来告诉光线它可以投射到哪些地方。
- en: Cookies can also be used to create other nice effects, both static and dynamic,
    such as cloud cover that pans across the scene. Perhaps light projecting out from
    a cage. Or, you could use them for making the uneven focus point of a flashlight.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 饼干也可以用来创建其他一些很棒的效果，无论是静态的还是动态的，比如云层在场景中移动的效果。也许是从笼子里投射出的光线。或者，你可以用它们来制作手电筒不均匀的焦点。
- en: Time for action – adding more lights
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是时候添加更多灯光了
- en: Adding additional lights to the scene is rather simple. Also, as long as one
    sticks to point lights, the cost to render them stays low.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 向场景添加额外的灯光相当简单。此外，只要坚持使用点光源，渲染它们的成本就会保持较低。
- en: At the top of the Unity Editor, select **GameObject**, followed by **Create
    Other**, and lastly **Point Light**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，选择**GameObject**，然后选择**Create Other**，最后选择**Point Light**。
- en: With the new light selected, there are a few attributes that we are concerned
    about in the **Inspector** window.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择新的灯光后，在**Inspector**窗口中我们关注几个属性。
- en: '**Range**: This is how far light will be emitted from the object. The light
    emitted from this point is brightest at the center and fades to nothing as it
    reaches the extent of the range. The range is additionally represented as a yellow
    wire sphere in the **Scene** view.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：这是光线从物体发出的距离。从这个点发出的光线在中心最亮，随着达到范围的极限而逐渐变暗。范围在**场景**视图中还以黄色线球的形式表示。'
- en: '**Color**: This is simply the color of the light. By default, it is white;
    however, any color can be used here. This setting is shared between all light
    types.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：这仅仅是光线的颜色。默认情况下，它是白色的；然而，这里可以使用任何颜色。这个设置在所有灯光类型之间共享。'
- en: '**Intensity**: This is the brightness of the light. The greater the intensity
    of the light, the brighter the light will be at its center. This setting is also
    shared between all light types.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强度**：这是光线的亮度。光线的强度越大，光线中心的亮度就越高。这个设置在所有灯光类型之间共享。'
- en: Create and position several more lights, arranging them along the streets to
    add some more interest to the environment.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并放置更多灯光，沿着街道排列，以增加环境的趣味性。
- en: Using *Ctrl* + *D* will duplicate the selected object. This can greatly speed
    up the creation process.![Time for action – adding more lights](img/2014OT_04_06.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *D*可以复制选定的对象。这可以大大加快创建过程。![现在是时候添加更多灯光](img/2014OT_04_06.jpg)
- en: While adding these lights, you probably noticed one of their major drawbacks.
    There is a limit to how many lights will affect a surface in real time. It is
    possible to somewhat get around this by using more complex meshes. The better
    option is to use lightmaps, which we'll be seeing in the next section.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加这些灯光时，你可能注意到了它们的一个主要缺点。实时影响表面的灯光数量是有限的。通过使用更复杂的网格，可以在一定程度上绕过这一点。更好的选择是使用光照贴图，我们将在下一节中看到。
- en: At the top of the Unity Editor again, select **GameObject**, followed by **Create
    Other**, and this time select **Spotlight**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在Unity编辑器的顶部，选择**GameObject**，然后选择**Create Other**，这次选择**Spotlight**。
- en: Again, select the new light and take a look at it in the **Inspector** window.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择新的灯光，并在**Inspector**窗口中查看它。
- en: '**Spot Angle**: This is unique to this type of light. It dictates how wide
    a cone the light emits. Together with **Range**, it is represented by a yellow
    wire cone in the **Scene** view.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光角度**：这是此类灯光的独特之处。它决定了光线发出的锥形范围有多宽。与**范围**一起，它在**场景**视图中以黄色线锥的形式表示。'
- en: Add a few spotlights around the fountain in the center of our tank battle city.![Time
    for action – adding more lights](img/2014OT_04_07.jpg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们坦克战斗城市中心的喷泉周围添加几个聚光灯。![行动时间——添加更多灯光](img/2014OT_04_07.jpg)
- en: Having so many objects in a scene starts to clutter the **Hierarchy** window,
    making it hard to find anything. To organize it, you can use empty `GameObjects`.
    Create one and name it `PointLights`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景中有这么多对象开始使**层次结构**窗口变得杂乱，难以找到任何东西。为了组织它们，你可以使用空的`GameObject`。创建一个并命名为`PointLights`。
- en: By making all of your point lights children of this empty `GameObject`, the
    **Hierarchy** window becomes significantly less cluttered.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使所有点光源成为这个空`GameObject`的子对象，**层次结构**窗口变得明显更加整洁。
- en: '*What just happened?*'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added several lights to the game. By changing the lights of the colors, we
    make the scene much more interesting to look at and play in. However, a drawback
    of the lighting system is revealed. The city we are using is very simple and there
    is a limit to the number of lights that can affect a plane at one time. While
    the look of our scene is still improved, much of the impressiveness is stolen
    by this drawback.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向游戏中添加了几个光源。通过改变灯光的颜色，我们使场景看起来更加有趣，玩起来也更加吸引人。然而，照明系统的缺点也被揭露了。我们使用的城市非常简单，一次能影响平面的灯光数量有限。虽然我们的场景外观得到了改善，但大部分的震撼效果都被这个缺点所削弱。
- en: Lightmaps
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光照贴图
- en: Lightmaps are great for complex lighting setups that would be too expensive
    or simply won't work at runtime. They also allow you to add detailed shadows to
    your game world without the expense of real-time shadows. However, it will only
    work for objects that do not move over the course of a game.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 光照贴图非常适合复杂的照明设置，这些设置在运行时可能过于昂贵或根本无法实现。它们还允许你在不使用实时阴影的情况下，为游戏世界添加详细的阴影。然而，它只适用于在整个游戏过程中不移动的对象。
- en: Time for action – creating a lightmap
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建光照贴图
- en: Lightmaps are a great effect for any game environment, but we need to explicitly
    tell Unity which objects will not move and then use lightmaps.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 光照贴图是任何游戏环境的绝佳效果，但我们需要明确告诉Unity哪些对象不会移动，然后使用光照贴图。
- en: The first thing to do is make our environment meshes static. To do this start
    by selecting a piece of your city.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首件事是使我们的环境网格静态。为此，首先选择你城市的一部分。
- en: In the top-right corner of the **Inspector** window to the right of the object
    name field are a checkbox and a **Static** label. Checking this box will make
    the object static.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象名称字段右侧的**检查器**窗口的右上角有一个复选框和一个**静态**标签。勾选此框将使对象变为静态。
- en: Make all of the city's meshes static.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使整个城市的网格都变为静态。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Instead of selecting each checkbox one by one, if you have any sort of grouping
    (as we just did for the lights), this step can be completed much faster.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你有任何类型的分组（就像我们刚才对灯光所做的），这个步骤可以完成得更快。
- en: Select the root object of your city, the one that is the parent to all the pieces
    of our city, the buildings, and streets.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你城市的根对象，即所有城市部分、建筑和街道的父对象。
- en: Now go and select the **Static** checkbox.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在去选择**静态**复选框。
- en: On the new pop-up, select **Yes, change children** to cause all of the subobjects
    to become static as well.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的弹出窗口中，选择**是，更改子对象**以使所有子对象也变为静态。
- en: Any mesh that is either not unwrapped or has UV positions outside the normalized
    UV space will be skipped when Unity generates a lightmap. In the **Model Import
    Settings** window, there is an option to have Unity automatically generate lightmap
    coordinates, **Generate Lightmap**. If you are using `TankBattleCity` for your
    environment, this option should be turned on now.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何未展开或UV位置超出归一化UV空间的网格在Unity生成光照贴图时将被跳过。在**模型导入设置**窗口中，有一个选项可以让Unity自动生成光照贴图坐标，**生成光照贴图**。如果你正在使用`TankBattleCity`作为你的环境，现在应该打开此选项。
- en: Go to the top of the Unity Editor and select **Window** followed by **Lightmapping**,
    near the bottom.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Unity编辑器的顶部，选择**窗口**然后选择**光照贴图**，位于底部附近。
- en: Most of your time will be spent on the **Bake** page looking at this window.
    Select **Bake** at the top of the window to switch to it.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你大部分时间都会花在**烘焙**页面上查看这个窗口。在窗口顶部选择**烘焙**以切换到该页面。
- en: '**Mode** dictates what types of lightmaps will be rendered by the system. To
    save on processing speed and file size, select **Single Lightmaps** from the **Mode**
    drop-down list to the right. This means that only a **Far** set of lightmaps is
    created rather than both **Near** and **Far**. Using **Dual Lightmaps** also requires
    special shaders that you won''t use most of the time.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式**决定了系统将渲染哪些类型的光照贴图。为了节省处理速度和文件大小，从右侧的**模式**下拉列表中选择**单光照贴图**。这意味着只创建**远**光照贴图集，而不是**近**和**远**。使用**双光照贴图**还需要特殊的着色器，您在大多数情况下都不会使用。'
- en: '**Quality** is a set of presets that dictates how good the lightmaps look.
    **High** is obviously the best and **Low** is the fastest to process. For our
    purposes, **Low** will look good enough and should be selected.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**品质**是一组预设，决定了光照贴图看起来有多好。**高**显然是最好的，而**低**是处理速度最快的。对于我们的目的，**低**看起来已经足够好，应该被选中。'
- en: '**Resolution** is how much space an object will take up on a single lightmap.
    To the right of the input field, it reads texels per world unit. A texel is just
    a fancy type of pixel used for lightmaps. It is the number of pixels a single
    unit of space in the world will take up on the lightmap. A setting of 30 here
    will maintain the desired level of quality while making the whole thing run faster.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分辨率**决定了对象在单个光照贴图上占据的空间大小。在输入字段右侧，它显示为每世界单位texels。texel是一种用于光照贴图的高级像素类型。它是世界空间中单个单位空间在光照贴图上占据的像素数。这里的30设置将保持所需的品质水平，同时使整个过程运行得更快。'
- en: At the bottom of the page is a **Bake Scene** button. Clicking on this button
    will start the render process. A loading bar will appear in the bottom-right corner
    of Unity so you can monitor the progress.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部有一个**烘焙场景**按钮。点击此按钮将开始渲染过程。Unity右下角将出现一个加载条，以便您可以监控进度。
- en: If you are still adjusting lights and settings and desire to see what a portion
    of the game will look like, start by selecting the meshes you wish to see.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您仍在调整灯光和设置，并希望看到游戏的一部分外观，请先选择您希望看到的网格。
- en: Next, click on the little arrow to the right of the **Bake Scene** button.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**烘焙场景**按钮右侧的小箭头。
- en: From the new drop-down list, select **Bake Selected**. This will run an identical
    process to **Bake Scene**, except it will only be for the selected objects rather
    than the entire scene.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的下拉列表中选择**烘焙所选**。这将运行与**烘焙场景**相同的过程，但它只针对所选对象而不是整个场景。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be warned, this process will likely take a while. Especially as the complexity
    of the environment and the number of lights increases, this will take longer and
    longer to run. And, unless you have a superior computer, there isn't much you
    can do in Unity while it is running.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告，这个过程可能需要一段时间。特别是随着环境和灯光数量的增加，运行时间会越来越长。而且，除非您有一台性能优越的电脑，否则在它运行时在Unity中您几乎无法做什么。
- en: If you clicked on the button and realized you made a mistake, don't fret. After
    **Bake Scene** is selected, the button changes to **Cancel**. At this time it
    is possible to select it and stop the process from continuing. However, once the
    textures have been created and Unity starts to import them, there is no stopping
    it.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击了按钮并意识到自己犯了一个错误，不要担心。在**烘焙场景**被选中后，按钮将变为**取消**。此时您可以选中它并停止进程继续。然而，一旦纹理被创建并且Unity开始导入它们，就无法停止了。
- en: To the left of **Bake Scene** is **Clear**. This button is the quickest and
    easiest way to delete and remove all of the lightmaps that are currently being
    used in the scene. This cannot be undone.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**烘焙场景**左侧是**清除**。这个按钮是删除和移除场景中当前使用的所有光照贴图最快、最简单的方法。这无法撤销。
- en: In order to add shadows to your buildings, select **Directional Light** in your
    scene and take a look at the **Inspector** window.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给您的建筑添加阴影，在场景中选择**方向光**，并查看**检查器**窗口。
- en: From the **Shadow Type** drop-down list, select **Soft Shadows**. This simply
    turns shadows on for this light. It also turns on real-time shadows for this light,
    if you are using Unity Pro. The more lights with shadows turned on, the more expensive
    they become to render.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**阴影类型**下拉列表中选择**软阴影**。这将为这个灯光打开阴影。如果您使用Unity Pro，它还会打开这个灯光的实时阴影。打开阴影的灯光越多，渲染成本就越高。
- en: When all of your lights and settings match your desires, select **Bake Scene**
    and gaze in wonder at the now beautiful scene before you.![Time for action – creating
    a lightmap](img/2014OT_04_08.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的所有灯光和设置都符合你的期望时，选择**烘焙场景**，并惊奇地凝视现在在你面前的美丽场景。![行动时间 – 创建光照贴图](img/2014OT_04_08.jpg)
- en: '*What just happened?*'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added lightmaps to our game world. The length of time it takes to just process
    this step makes it difficult to make minor tweaks. However, our lighting has vastly
    improved with a few clicks. While before the lights were broken by the meshes,
    we now have smooth patches of color and light.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向游戏世界中添加了光照贴图。仅处理这一步骤所需的时间就使得进行细微调整变得困难。然而，通过几次点击，我们的照明得到了极大的改善。在此之前，灯光被网格破坏，我们现在有了平滑的颜色和灯光区域。
- en: Have a go hero – reason and speed
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 理由和速度
- en: 'When playing a game, there is only one light that people will not question
    the source of: the Sun. Every other light looks weird if a source cannot be seen.
    Create a mesh and add it to the game to give the lights you are using a reason.
    This could be something along the lines of torches, or lamp posts, or even glowing
    alien goo balls. Whatever they end up being, having them adds that touch of completeness
    that makes the difference between an alright OK-looking game and a great-looking
    game.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏时，人们不会质疑的唯一光源是太阳。如果看不到光源，其他任何灯光看起来都很奇怪。创建一个网格并将其添加到游戏中，为使用的灯光提供一个理由。这可能是火炬、路灯，甚至是发光的外星粘液球。无论它们最终变成什么，拥有它们都会增加那种完整性，使游戏从一般的外观变得出色。
- en: As a second challenge, take a look at your lightmap's quality. Play with the
    various quality settings we discussed to see what the differences are. Also, find
    out how low the resolution can go before you notice any pixelation. Can the settings
    go even lower when running on the smaller, mobile device screens? Go find out.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个挑战，看看你的光照贴图的质量。玩一下我们讨论的各种质量设置，看看有什么区别。同时，找出在出现像素化之前分辨率可以降低多少。当在较小的移动设备屏幕上运行时，设置可以进一步降低吗？去找出答案。
- en: Cookies
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookies
- en: Cookies are a great way to add interest to the lights in your game. They use
    a texture to adjust how the light is emitted. This effect can cover a wide range
    of uses from sparkling crystals to caged industrial lights and, in our case, headlights.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies是给你的游戏中的灯光增加兴趣的绝佳方式。它们使用纹理来调整光线的发射方式。这种效果可以覆盖从闪耀的晶体到笼子工业灯光的广泛用途，在我们的案例中，是车头灯。
- en: Time for action – applying headlights
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 应用车头灯
- en: By giving our tank headlights, we give the player the ability to control the
    light in their world. Using cookies, we can make them look more interesting than
    just circles of light.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给我们的坦克添加车头灯，我们给玩家提供了控制他们世界中灯光的能力。使用cookie，我们可以使它们比光圈更有趣。
- en: Start by creating a **Spotlight**.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个**聚光灯**。
- en: Position the light in front of the tank and pointing away.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将灯光放置在坦克前方，并指向远离的方向。
- en: In the **Inspector** window, increase the value of the **Intensity** attribute
    to three. This will make our headlights bright like real headlights.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，将**强度**属性值增加到三。这将使我们的车头灯像真实的车头灯一样明亮。
- en: Now we need some cookie textures. At the top of the Unity Editor, select **Assets**,
    followed by **Import Package**, and lastly **Light Cookies**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一些cookie纹理。在Unity编辑器的顶部，选择**资产**，然后选择**导入包**，最后选择**Light Cookies**。
- en: On the new window, select **Import** and wait for the loading bar to finish.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，选择**导入**并等待加载条完成。
- en: We now have a few options to choose from. Inside the `Standard Assets` folder,
    a new folder was created, `Light Cookies` that contains the new textures. Drag
    `Flashlight` from the **Project** window and drop it onto the **Cookie** field
    on the **Spotlight** in the **Inspector** window. It is as simple as that to add
    a cookie to a light.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有几个选项可供选择。在`Standard Assets`文件夹内，创建了一个新的文件夹，`Light Cookies`，其中包含新的纹理。从**项目**窗口中拖动`Flashlight`并将其放置在**检查器**窗口中**Cookie**字段上的**聚光灯**。添加cookie到灯光就这么简单。
- en: To finish it off, duplicate the light for the second headlight and make them
    both children of the tank. What good is having headlights if they don't come with
    us?![Time for action – applying headlights](img/2014OT_04_09.jpg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成它，复制第二个车头灯的光源，并使它们都成为坦克的孩子。如果没有和我们一起，车头灯有什么用呢？![行动时间 – 应用车头灯](img/2014OT_04_09.jpg)
- en: '*What just happened?*'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a pair of headlights for our tank using cookies. This is exactly
    how many other games, especially horror games, create flashlight effects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用饼干为我们的坦克创建了一对车头灯。这正是许多其他游戏，尤其是恐怖游戏，创建手电筒效果的方式。
- en: Have a go hero – adding a switch
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 添加开关
- en: Try making a script that will allow the player to turn the headlights on and
    off. It should be a simple button that toggles the lights. Take a look at the
    enabled variable that is supplied as part of the light.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个脚本，允许玩家打开和关闭车头灯。它应该是一个简单的按钮，用于切换灯光。查看作为灯光一部分提供的enabled变量。
- en: As a simpler challenge, create a lamp that sits on the turret of the tank. Give
    it a light as well. With this, the player can point a light to where they are
    shooting and not just in the direction their tank is pointing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项更简单的挑战，创建一个位于坦克炮塔上的灯。给它也加上灯光。这样，玩家就可以将灯光指向他们射击的方向，而不仅仅是坦克指向的方向。
- en: Blob shadow
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blob阴影
- en: Blob shadows are a simpler and cheaper method for adding a shadow to a character.
    They have been around since the dawn of time. A normal shadow is a solid, dark
    projection of an object onto another surface. The contours of the shadow exactly
    match the contours of the object. This becomes expensive to calculate when characters
    start to move around randomly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Blob阴影是给角色添加阴影的一种更简单、更经济的办法。它们自时间之初就存在。正常阴影是一个物体在另一个表面上形成的固态、深色的投影。阴影的轮廓与物体的轮廓完全一致。当角色开始随机移动时，这会变得计算成本高昂。
- en: A blob shadow is a blot of black texture underneath a character or an object.
    It usually does not have a clearly definable shape and never matches the contours
    of the object it is meant to be the shadow of. The blob shadow also, generally,
    does not change sizes. This makes it significantly easier to calculate, making
    it the shadow of choice for many generations of video games. That also means it
    is a better option for our mobile devices where processing speed can quickly become
    an issue.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Blob阴影是位于角色或物体下方的黑色纹理块。它通常没有明确可定义的形状，并且永远不会与它打算成为阴影的物体的轮廓相匹配。Blob阴影通常也不会改变大小。这使得它计算起来显著更容易，因此成为许多代视频游戏的首选阴影。这也意味着它对于我们的移动设备来说是一个更好的选择，因为在移动设备上处理速度可能会迅速成为一个问题。
- en: Time for action – a tank with a shadow
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 带阴影的坦克
- en: We are going to add a blob shadow to our tank. Unity has already done the bulk
    of the work for us; we just need to add it to the tank.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给我们的坦克添加一个Blob阴影。Unity已经为我们做了大部分工作；我们只需要将其添加到坦克上。
- en: We start this one off by importing Unity's blob shadow. Go to the top of the
    Unity Editor, select **Assets**, **Import Package**, and finally **Projectors**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过导入Unity的Blob阴影开始。在Unity编辑器的顶部，选择**资产**，**导入包**，最后选择**投影器**。
- en: Select **Import** in the new window and take a look in the **Project** window
    for a new folder called `Projectors` created under `Standard Assets`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中选择**导入**，并在**项目**窗口中查看在`Standard Assets`下创建的新文件夹`Projectors`。
- en: Drag the `Blob Shadow Projector` prefab from the **Project** window to the scene
    and position it above the tank.![Time for action – a tank with a shadow](img/2014OT_04_10.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Blob阴影投影器`预制体从**项目**窗口拖到场景中，并将其放置在坦克上方。![行动时间 - 带阴影的坦克](img/2014OT_04_10.jpg)
- en: Unfortunately, the shadow is appearing on top of our tank. To fix this, we need
    to again make use of layers. So, select the tank.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，阴影出现在我们的坦克上方。为了解决这个问题，我们需要再次利用层。因此，选择坦克。
- en: From the **Layer** drop-down list, select **Add Layer...**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层**下拉列表中选择**添加层...**。
- en: Click on the right-hand side of **User Layer 9** and give it the name `PlayerTank`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**用户层9**的右侧，并将其命名为`PlayerTank`。
- en: Select your tank once more, but select `PlayerTank` from the **Layer** drop-down
    list this time.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择你的坦克，但这次从**层**下拉列表中选择`PlayerTank`。
- en: When the new window pops up, be sure to select **Yes, change children** to change
    the layer of the whole tank. If you don't, the blob shadow may appear on some
    parts of the tank while not on other parts.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当新窗口弹出时，务必选择**是，更改子项**以更改整个坦克的层。如果不这样做，Blob阴影可能会出现在坦克的一些部分上，而不会出现在其他部分上。
- en: Now, select `Blob Shadow Projector` from the **Hierarchy** window.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**层次结构**窗口中选择`Blob阴影投影器`。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The blob shadow is created by the **Projector** component. This component functions
    in a similar manner to the **Camera** component. However, it puts an image on
    the world rather than turning the world into an image and putting it on your screen.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阴影是由**投影器**组件创建的。这个组件的功能与**摄像头**组件类似。然而，它将图像放在世界上，而不是将世界变成图像并显示在屏幕上。
- en: Take a look at the **Inspector** window. The value we are concerned with right
    now is that of **Ignore Layers**. Right now it is set to **Nothing**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下**检查器**窗口。我们现在关心的是**忽略图层**的值。目前它设置为**无**。
- en: Click on **Nothing** and select `PlayerTank` from the **Layers** drop-down list.
    This will make the projector ignore the tank and only make the blob shadow appear
    underneath it.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**无**，然后从**图层**下拉列表中选择`PlayerTank`。这将使投影仪忽略坦克，并且只在它下面显示阴影。
- en: The next step is to change the size of the shadow to roughly match the size
    of the tank. Adjust the value of the **Field of View** attribute until the size
    is about right. A value of about 70 seems to be a good place to start from.![Time
    for action – a tank with a shadow](img/2014OT_04_11.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将阴影的大小调整到与坦克大小大致匹配。调整**视野**属性的值，直到大小看起来大致合适。大约70的值似乎是一个不错的起点。![行动时间 – 带阴影的坦克](img/2014OT_04_11.jpg)
- en: The final step is to make `Blob Shadow Projector` a child of the tank. We need
    to be able to bring our shadow with us; we don't want to lose it.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将**Blob Shadow Projector**设置为坦克的子对象。我们需要能够带着我们的阴影一起移动；我们不希望丢失它。
- en: '*What just happened?*'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We gave our tank a shadow. Shadows are great for making objects, and especially
    characters, look like they are actually touching the ground. The blob shadow that
    we used is better than real-time shadows because it is processed faster.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给我们的坦克添加了阴影。阴影非常适合让物体，尤其是角色，看起来像它们实际上是在接触地面。我们使用的阴影比实时阴影更好，因为它处理得更快。
- en: Have a go hero – making it square
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 让它变得方形
- en: The texture that the blob shadow came with is round but our tank is mostly square.
    Try creating your own texture for the blob shadow and use that. Some sort of rectangle
    should work well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 随着阴影一起提供的纹理是圆形的，但我们的坦克主要是方形的。尝试为阴影创建自己的纹理并使用它。某种矩形形状应该会很好。
- en: If you managed to add your own texture to the blob shadow, then how about taking
    a look at that cannon? The cannon sticks out of our tank and ruins its otherwise
    square profile. Use a second blob shadow, attached to the turret, to project a
    shadow for the cannon. The texture for it will also have to be a rectangle-type
    shape.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功地为阴影添加了自己的纹理，那么不妨看看那个大炮？大炮从我们的坦克中伸出，破坏了它原本的方形轮廓。使用一个附加在炮塔上的第二个阴影，为大炮投射阴影。它的纹理也将需要是矩形形状。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: At this point, you should be well and truly familiar with camera effects and
    lights.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经非常熟悉摄像头效果和灯光了。
- en: In this chapter, we started with a look at using multiple cameras. We then played
    around with a turbo boost camera effect. The chapter continued with the lighting
    of our city. The lights improved greatly when we made use of lightmaps. We finished
    it off with a look at cookies and blob shadows for use with some special lighting
    effects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了使用多个摄像头。然后我们尝试了涡轮增压摄像头效果。本章继续讲述了我们城市的照明。当我们使用光照贴图时，灯光得到了极大的改善。我们通过查看用于特殊照明效果的cookie和阴影来结束本章。
- en: In the next chapter, will see the creation of enemies for our game. We will
    use Unity's pathfinding system to make them move around and chase the player.
    After this, the player is going to need to be much more active if they hope to
    keep their points.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到为我们的游戏创建敌人。我们将使用Unity的路径查找系统让它们移动并追逐玩家。之后，如果玩家希望保持他们的分数，他们需要变得更加活跃。
