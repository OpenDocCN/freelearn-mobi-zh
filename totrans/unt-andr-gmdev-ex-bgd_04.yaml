- en: Chapter 4. Setting the Stage – Camera Effects and Lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, you learned about the basic building blocks of any
    game: meshes, materials, and animations. We created a Tank Battle game that utilized
    all of these blocks.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we will expand upon the Tank Battle game. We will start with
    the addition of a skybox and distance fog. The exploration of camera effects continues
    with a target indicator overlay that uses a second camera. The creation of a turbo
    boost effect for the tank will round out our look at camera effects. Continuing
    with a look at lighting, we will finish off our tank environment with the addition
    of lightmaps and shadows.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Skyboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance fog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the field of view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating lightmaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be directly piggybacking off the project from [Chapter 3](ch03.html
    "Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations"), *The
    Backbone of Any Game – Meshes, Materials, and Animation*. So, open it in Unity
    and we will get started.
  prefs: []
  type: TYPE_NORMAL
- en: The camera effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many great camera effects that you should add to give your game the
    last great finishing touch. In this chapter, we will be covering a few options
    that are easy to add. These will also give our tank game a great finished look.
  prefs: []
  type: TYPE_NORMAL
- en: Skyboxes and distance fog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a camera renders a frame of a game, it starts by clearing the screen. By
    default, cameras in Unity do this by coloring everything in solid blue. All of
    the game's meshes are then drawn on top of this blank screen. Blue is rather boring
    for an exciting battle of tanks. So, lucky for us, Unity allows us to change the
    color. But, pink is not better than blue, so we have to change the method of clearing
    the screen. This is where the skybox comes in. A skybox is just a fancy word for
    the series of images that form the background sky of any game. Distance fog works
    in conjunction with the skybox by easing the visual transition between models
    and background.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a skybox and distance fog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very first thing we need is a skybox, obviously. We could create our own;
    however, Unity provides us with several excellent ones that will fit our needs
    just fine.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, select **Assets** followed by **Import Package**.
    About half way down this list, select **Skyboxes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a little bit of processing, a new window will pop up. A package in Unity
    is just a compressed group of assets that have already been set up in Unity. This
    window displays the contents and allows us to selectively import them. We want
    them all, so just click on **Import** in the bottom-right corner of this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new folder, `Standard Assets`, will be added to the **Project** window. This
    contains a folder, `Skyboxes`, which contains various skybox materials. Select
    any one of these. You can see in the **Inspector** window that they are normal
    materials that make use of the Skybox shader. They each have six images, one for
    each direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add the skybox of your choice to the game, first make sure you have the correct
    scene loaded. If you do not, simply double-click on it in the **Inspector** window.
    This is necessary because the settings we are about to change are specific to
    each scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the top of the Unity Editor and select **Edit**, followed by **Render
    Settings**. The new group of settings will appear in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the moment we are concerned with the value that is fifth from the bottom,
    **Skybox Material**. Just drag-and-drop the skybox material into the **Skybox
    Material** slot and it will be automatically updated. The change can be viewed
    in the **Game** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add distance fog, we also adjust it in **Render Settings**. To turn it on,
    simply click on the **Fog** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next setting, **Fog Color**, allows us to pick a color for the fog. It is
    good to pick a color that is close to the general color of the skybox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fog Mode** is a drop-down list of options that dictate the method Unity will
    use to calculate the distance fog. For nearly all cases, the default of **Exp2**
    is suitable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next three settings, **Fog Density**, **Linear Fog Start**, and **Linear
    Fog End**, all determine how much fog there is and how close it starts. **Fog
    Density** is used for the **Exponential** and **Exp2** fog modes while the others
    are used for the **Linear** fog mode. Settings that put the fog at the edge of
    sight are generally good.![Time for action – adding a skybox and distance fog](img/2014OT_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We imported several skyboxes and added them to the scene. The distance fog settings
    were also turned on and adjusted. Now, our scene has started to look like a real
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Target indicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another camera effect that is rather interesting is the use of multiple cameras.
    A second camera could be used for making a 3D GUI, a minimap, or perhaps a security
    camera pop-up. In this next section, we will be creating a system that will point
    at targets that are nearby. Using a second camera, we will make it appear above
    the player's tank.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start by creating an object that will point at targets. We
    will be making a prefab that can be used repeatedly. However, you will need a
    model for the player to see. We will use a pie-slice type mesh. The size isn''t
    particularly important; we will be adjusting the scale later. Let''s perform the
    following steps to create the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created and imported your mesh, add it to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty `GameObject` and rename it to `IndicatorSlice`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make your mesh a child of `IndicatorSlice` and position it so that it points
    along the GameObject's z axis. `IndicatorSlice` will be centered in our indicator.
    Each slice that is created will have its z axis pointing in the direction of a
    target.![Time for action – creating the pointer](img/2014OT_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to create a new script that will control our indicator. Create
    a new script called **TargetIndicator** in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start this script off with a pair of variables. The first will hold a reference
    to the target that this indicator piece will point at. The indicator is also going
    to grow and shrink based on how far away the target is. The second variable will
    control the distance at which the indicator will start to grow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next function will be used to set the `target` variable when the indicator
    piece is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last set of code goes in the `LateUpdate` function. The `LateUpdate` function
    is used so the indicator pieces can point at a target after our tank moves in
    the `Update` function. We start the function with a check to make sure the target
    variable has a value. If it is null, the indicator slice is destroyed. The `Destroy`
    function can be used to remove any object that exists from the game. The `gameObject`
    variable is automatically provided by the `MonoBehaviour` class and holds a reference
    to the `GameObject` that the script component is attached to. Destroying it will
    also destroy everything that is a child of (or attached to) it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next bit of code sets the scale of the indicator slice. As you can see in
    the following code snippet, the first line of code uses `Vector3.Distance` to
    determine how far the two positions are from each other. The next code line determines
    the vertical scale, y axis, of the slice. It does so by using a bit of carefully
    applied math and the `Mathf.Clamp01` function. This function limits the supplied
    value to be between zero and one. The last line of code sets the indicator slice's
    local scale. By adjusting the local scale, we can easily control how big the whole
    indicator is by just changing the scale of the parent object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One last set of code for this script. The `transform.LookAt` function is just
    a fancy, automatic way of rotating a `GameObject` so its z axis points to a specific
    spot in the world. However, we want all of the indicator slices to lay flat on
    the ground and not pointing into the air at any targets that might be above us.
    So, we collect the target's position. By setting the variable's Y value to the
    position of the slice, we ensure that the slice remains flat. That last line,
    of course, closes off the `LateUpdate` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is the last code for this script. Return to Unity and add the `TargetIndicator`
    script to the `IndicatorSlice` object in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish off the indicator, create a prefab of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, delete the `IndicatorSlice` object from the scene. We will be creating
    slices dynamically when the game starts. That requires the prefab, but not the
    one in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a prefab of the object we will be using to indicate the direction
    of targets. The script that was created and attached will rotate each instance
    of the prefab to point at the target. It will also adjust the scale to indicate
    how far the target is from the player.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – controlling the indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to create a script that will control the indicator slices. This
    will include creating new slices as they are needed. Also, the `GameObject` it
    is attached to will act as a center point for the indicator slices, that we just
    created, to rotate around.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script and name it `IndicatorControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start this script off with a pair of variables. The first will hold a reference
    to the prefab that was just created. This will allow us to spawn instances of
    it whenever we desire. The second is a static variable, meaning it can be easily
    accessed without a reference to the component that exists in the scene. It will
    be filled when the game starts with a reference to the instance of this script
    that is in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This next function will be used by the targets. Soon, we will be updating the
    target's script to call this function at the beginning of the game. The function
    is static, just like the variable, and starts by checking to see whether there
    is a reference to any object in it. If it is empty, equal to null, `Object.FindObjectOfType`
    is used to attempt to fill the variable. By telling it what type of object we
    want to find, it will search in the game and try to find one. This is relatively
    a slow process and should not be used often, but we use this process and the variable
    so that we can always be sure that the system can find the script. The second
    part of the `CreateSlice` function checks to make sure our static variable is
    not empty. If so, it then tells the instance to create a new indicator slice and
    passes it to the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One more function for this script. The `NewSlice` function does as its name
    implies, it creates new indicator slices when called. It does this by first using
    the `Instantiate` function to create a copy of the `GameObject` that is passed
    to it. The second line of the function makes the new slice a child of the control's
    transform. The next line just zeroes out the local position of the new slice.
    This way it will be centered properly after it is created. The last line uses
    the slice's `SendMessage` function to call the `SetTarget` function that we created
    previously and passes it the desired target object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that the script is created, we need to use it. Create an empty `GameObject`
    and name it `IndicatorControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `GameObject` needs to be made a child of your tank, followed by having
    its position set to zero on each axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the script we just created to `IndicatorControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, with the `GameObject` selected, add the reference to the `IndicatorSlice`
    prefab. Do this by dragging the prefab from the **Project** window to the proper
    slot in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a script that will control the spawning of our target indicator slices.
    The `GameObject` we created at the end will also allow us to control the size
    of the whole indicator with ease. We are almost done with the target indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – working with a second camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were to play the game now, it would still look no different. This is
    because the targets do not yet make the call to create the indicator slices. We
    will also be adding that second camera in this section as we finish off the target
    indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening the `Target` script and adding the following line of code to
    the end of the `Awake` function. This line tells the `IndicatorControl` script
    to create a new indicator slice for this target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – working with a second camera](img/2014OT_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: On playing the game now, you can see the indicator in action. However, it is
    probably too large and certainly appears inside the tank. A bad solution would
    be to move the `IndicatorControl` object until the whole thing appears above the
    tank. However, when explosions occur and things start flying through the air,
    they will obscure the target indicator all over again. A better solution is to
    add a second camera. Do so now by selecting **GameObject** from the top of the
    Unity Editor, followed by **Create Other**, and finally **Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, make the camera a child of `Main Camera`. Be sure to set the new
    camera's position and rotation values to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, every camera in Unity is given a variety of components: **Camera**,
    **Flare Layer**, **GUI Layer**, and **Audio Listener**. Besides the **Camera**
    component, the others are generally unimportant to every other camera, and there
    should only be one **Audio Listener** component in the whole of the scene. Remove
    the excess components from the camera, leaving just the **Camera** component.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we do anything else with the camera, we need to change the layer that
    the `IndicatorSlice` prefab is on. Layers are used to cause selective interaction
    between objects. They are used primarily for physics and rendering. First select
    the prefab in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **Inspector** window is the **Layer** label with a drop-down
    list that reads **Default**. Click on the drop-down list and select **Add Layer...**
    from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of layers will now appear in the **Inspector** window. These are all
    the layers used in the game. The first few are reserved for use by Unity; hence,
    they are grayed out. The rest are for our use. Click on the right-hand side of
    **User Layer 8** and name it **Indicator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `IndicatorSlice` prefab again. This time select the new **Indicator**
    layer from the **Layer** drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity will ask if we want to change the layer of all the child objects as well.
    We would want the whole object rendered on this layer, so select **Yes, change
    children** and we will be able to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, back to our second camera. Select it and take a look in the **Inspector**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first attribute of the **Camera** component is **Clear Flags**. This list
    of options dictate what the camera will fill the background with before drawing
    all of the models in the game. The second camera does not block out everything
    drawn by the first camera. We select **Depth only** from the **Clear Flags** drop-down
    list. This means that, instead of putting the skybox in the background, it will
    leave what was already rendered and just draw new things on top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next attribute, **Culling Mask**, controls which layers are rendered by
    the camera. The first two options, **Nothing** and **Everything**, are for deselection
    and quick selection of all of the layers. For this camera, deselect all other
    layers, so that only the **Indicator** layer has a check next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do is to adjust the scale of `IndicatorControl` so that the
    target indicator is not too large or small.![Time for action – working with a
    second camera](img/2014OT_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a system to indicate the direction of potential targets. To do this,
    we used a second camera. By adjusting the layers in the **Culling Mask** attribute,
    we can make a camera render only a part of a scene. Also, by changing the **Clear
    Flags** attribute to **Depth only**, the second camera can draw on top of what
    was drawn by the first camera.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adjusting the position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to change where the indicator is drawn by moving the camera.
    If you were to instead move the `IndicatorControl` object, it will change how
    the distance from and direction to targets are calculated. Move and angle the
    second camera so that there is a more pleasing view of the target indicator.
  prefs: []
  type: TYPE_NORMAL
- en: When you were moving the second camera or when you use the boost from the next
    section, you probably noticed that the target indicator can still be seen in the
    tank. Adjust the main camera so that it does not render the target indicator.
    This is done very similarly to how we made the second camera only render the target
    indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Turbo boost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last camera effect we will be looking at in this chapter is a turbo boost.
    It is going to be a button on the screen that will propel the player forward rapidly
    for a short amount of time. The camera effect comes in because a simple adjustment
    to the **Field of View** attribute can make it look as if we are going much faster.
    A similar method is used by movies to make the car chases look even faster.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using the boost effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will only be making a single script in this section. It will move the tank
    in a similar manner to the `ChassisControls` script we created in the last chapter.
    The difference is, we won't have to hold down a button for the boost to work.
    Let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new script and calling it `TurboBoost`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To start the script off, we need four variables. The first is a reference to
    `CharacterController`. We need this for movement. The second is how fast we will
    be moving while boosting. The third is how long, in seconds, we will be boosting.
    The last is used internally for whether or not we can boost and when we should
    stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next bit of code returns to our good friend, the `OnGUI` function. Here
    we are just drawing a button on the screen, the same as we did several times before.
    If the button is pressed, it calls the `StartBoost` function that we will be writing
    in a moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `StartBoost` function is pretty simple. It checks to see if the `startTime`
    variable is less than zero. If it is, the variable is set to the current time
    as provided by `Time.time`. Being less than zero means that we are not currently
    boosting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function we are going to use is the `Update` function. It begins with
    a check of `startTime` to see if we are currently boosting. If we are not boosting,
    the function is exited early. The next line of code checks to make sure we have
    our `CharacterController` reference. If the variable is empty, then we can't make
    the tank move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next line of code should look familiar. This is the line that makes the
    tank move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following few lines of code actually apply the camera effect. First is a
    check to see whether we are in the first half-second of the boost. If we are,
    we transition the camera by adjusting the `fieldOfView` value. The `Camera.main`
    value is just a reference provided by Unity to the main camera used in the scene.
    The `Mathf.Lerp` function takes a starting value and moves it towards a goal value
    based on a third value between zero and one. Using this, the camera's `fieldOfView`
    is moved towards our goal over the half-second. The second half of this set of
    code checks for the last half-second of our boost and uses the same method to
    transition the `fieldOfView` value back to the default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last bit of code checks to see whether we are done boosting. If so, `startTime`
    is set to negative one to indicate that we can start another boost. That last
    curly brace, of course, closes off the `Update` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are almost done. Add the script to your tank and connect the `CharacterController`
    reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it out.![Time for action – using the boost effect](img/2014OT_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a turbo boost. The same method of movement used in the last chapter
    moves the tank here. By adjusting the **Field of View** attribute of the camera,
    we make it look like the tank is moving even faster.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – styling and control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easy and obvious challenge here is to style the button. To spice it up,
    try changing it so there is a label while boosting and a button when not boosting.
    The label and button could each have their own style.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you might notice while playing the game is that you can still
    turn while boosting. Try adding a check to the `ChassisControls` script to lock
    the controls, if we are boosting. You are going to need to add a reference to
    the `TurboBoost` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an added, extra challenge try adding a cooldown to the boost. Make it so
    the player can''t constantly use the boost. Also, try canceling the boost if the
    tank runs into something. This is a big one, so you will start off with a hint:
    take a look at `OnControllerColliderHit`.'
  prefs: []
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity provides a variety of light types for brightening the game world. They
    are **Directional Light**, **Spotlight**, **Point Light**, and **Area Light**.
    Each of them projects light in a different way and are explained in detail as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional Light**: This functions very much like the sun. It projects all
    of its light in a single direction. The position of the light does not matter,
    only the rotation. Light is projected over the entirety of the scene in one direction.
    This makes it perfect for initially adding light to a scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spotlight**: This functions just like the ones on a stage. Light is projected
    in a cone-like shape in a specific direction. Because of this, it is also the
    most complex light type for the system to calculate. Unity has made significant
    improvements in how it calculates lights, but overuse of these lights should be
    avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point Light**: This is the primary light type that will be used in your games.
    It emits light in every direction. This functions just like a light bulb.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Area Light**: This is a special-use light. It emits light in a single direction
    from a plane. Think of it as the big neon sign used to advertise a hotel or restaurant.
    Because of their complexity, these lights can only be used when baking shadows.
    There are too many calculations for them to be used when the game is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next obvious question when talking about lights concerns shadows, especially
    real-time shadows. While real-time shadows add a lot to a scene and are technically
    possible on any platform, they are very expensive. On top of that, they are a
    Unity Pro feature. All in all, that makes them a bit too much for your average
    mobile game.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are perfectly viable alternatives that do not cost
    nearly as much and often look more realistic than real-time shadows. The first
    is for your environment. In general, the environment in a game never moves and
    never changes within a specific scene. For this, we have lightmaps. They are extra
    textures that contain shadow data. Using Unity you can create these textures while
    making your game. Then, when the game is running, they are automatically applied
    and your shadows appear. This however does not work for dynamic objects (anything
    that moves).
  prefs: []
  type: TYPE_NORMAL
- en: For dynamic objects we have cookies. These are not your grandmother's cookies.
    In lighting, a cookie is a black and white image that is projected onto meshes
    in the game. This is similar to shadow puppets. The shadow puppets use a cutout
    to block a part of the light, whereas cookies use black and white images to tell
    the light where it can cast its light.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies can also be used to create other nice effects, both static and dynamic,
    such as cloud cover that pans across the scene. Perhaps light projecting out from
    a cage. Or, you could use them for making the uneven focus point of a flashlight.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding more lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding additional lights to the scene is rather simple. Also, as long as one
    sticks to point lights, the cost to render them stays low.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, select **GameObject**, followed by **Create
    Other**, and lastly **Point Light**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the new light selected, there are a few attributes that we are concerned
    about in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Range**: This is how far light will be emitted from the object. The light
    emitted from this point is brightest at the center and fades to nothing as it
    reaches the extent of the range. The range is additionally represented as a yellow
    wire sphere in the **Scene** view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color**: This is simply the color of the light. By default, it is white;
    however, any color can be used here. This setting is shared between all light
    types.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intensity**: This is the brightness of the light. The greater the intensity
    of the light, the brighter the light will be at its center. This setting is also
    shared between all light types.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and position several more lights, arranging them along the streets to
    add some more interest to the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using *Ctrl* + *D* will duplicate the selected object. This can greatly speed
    up the creation process.![Time for action – adding more lights](img/2014OT_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While adding these lights, you probably noticed one of their major drawbacks.
    There is a limit to how many lights will affect a surface in real time. It is
    possible to somewhat get around this by using more complex meshes. The better
    option is to use lightmaps, which we'll be seeing in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the Unity Editor again, select **GameObject**, followed by **Create
    Other**, and this time select **Spotlight**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, select the new light and take a look at it in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spot Angle**: This is unique to this type of light. It dictates how wide
    a cone the light emits. Together with **Range**, it is represented by a yellow
    wire cone in the **Scene** view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a few spotlights around the fountain in the center of our tank battle city.![Time
    for action – adding more lights](img/2014OT_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having so many objects in a scene starts to clutter the **Hierarchy** window,
    making it hard to find anything. To organize it, you can use empty `GameObjects`.
    Create one and name it `PointLights`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By making all of your point lights children of this empty `GameObject`, the
    **Hierarchy** window becomes significantly less cluttered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added several lights to the game. By changing the lights of the colors, we
    make the scene much more interesting to look at and play in. However, a drawback
    of the lighting system is revealed. The city we are using is very simple and there
    is a limit to the number of lights that can affect a plane at one time. While
    the look of our scene is still improved, much of the impressiveness is stolen
    by this drawback.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lightmaps are great for complex lighting setups that would be too expensive
    or simply won't work at runtime. They also allow you to add detailed shadows to
    your game world without the expense of real-time shadows. However, it will only
    work for objects that do not move over the course of a game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a lightmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lightmaps are a great effect for any game environment, but we need to explicitly
    tell Unity which objects will not move and then use lightmaps.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is make our environment meshes static. To do this start
    by selecting a piece of your city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-right corner of the **Inspector** window to the right of the object
    name field are a checkbox and a **Static** label. Checking this box will make
    the object static.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make all of the city's meshes static.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of selecting each checkbox one by one, if you have any sort of grouping
    (as we just did for the lights), this step can be completed much faster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the root object of your city, the one that is the parent to all the pieces
    of our city, the buildings, and streets.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go and select the **Static** checkbox.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the new pop-up, select **Yes, change children** to cause all of the subobjects
    to become static as well.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Any mesh that is either not unwrapped or has UV positions outside the normalized
    UV space will be skipped when Unity generates a lightmap. In the **Model Import
    Settings** window, there is an option to have Unity automatically generate lightmap
    coordinates, **Generate Lightmap**. If you are using `TankBattleCity` for your
    environment, this option should be turned on now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the top of the Unity Editor and select **Window** followed by **Lightmapping**,
    near the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of your time will be spent on the **Bake** page looking at this window.
    Select **Bake** at the top of the window to switch to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mode** dictates what types of lightmaps will be rendered by the system. To
    save on processing speed and file size, select **Single Lightmaps** from the **Mode**
    drop-down list to the right. This means that only a **Far** set of lightmaps is
    created rather than both **Near** and **Far**. Using **Dual Lightmaps** also requires
    special shaders that you won''t use most of the time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Quality** is a set of presets that dictates how good the lightmaps look.
    **High** is obviously the best and **Low** is the fastest to process. For our
    purposes, **Low** will look good enough and should be selected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resolution** is how much space an object will take up on a single lightmap.
    To the right of the input field, it reads texels per world unit. A texel is just
    a fancy type of pixel used for lightmaps. It is the number of pixels a single
    unit of space in the world will take up on the lightmap. A setting of 30 here
    will maintain the desired level of quality while making the whole thing run faster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the page is a **Bake Scene** button. Clicking on this button
    will start the render process. A loading bar will appear in the bottom-right corner
    of Unity so you can monitor the progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are still adjusting lights and settings and desire to see what a portion
    of the game will look like, start by selecting the meshes you wish to see.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the little arrow to the right of the **Bake Scene** button.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: From the new drop-down list, select **Bake Selected**. This will run an identical
    process to **Bake Scene**, except it will only be for the selected objects rather
    than the entire scene.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Be warned, this process will likely take a while. Especially as the complexity
    of the environment and the number of lights increases, this will take longer and
    longer to run. And, unless you have a superior computer, there isn't much you
    can do in Unity while it is running.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you clicked on the button and realized you made a mistake, don't fret. After
    **Bake Scene** is selected, the button changes to **Cancel**. At this time it
    is possible to select it and stop the process from continuing. However, once the
    textures have been created and Unity starts to import them, there is no stopping
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the left of **Bake Scene** is **Clear**. This button is the quickest and
    easiest way to delete and remove all of the lightmaps that are currently being
    used in the scene. This cannot be undone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to add shadows to your buildings, select **Directional Light** in your
    scene and take a look at the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Shadow Type** drop-down list, select **Soft Shadows**. This simply
    turns shadows on for this light. It also turns on real-time shadows for this light,
    if you are using Unity Pro. The more lights with shadows turned on, the more expensive
    they become to render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all of your lights and settings match your desires, select **Bake Scene**
    and gaze in wonder at the now beautiful scene before you.![Time for action – creating
    a lightmap](img/2014OT_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added lightmaps to our game world. The length of time it takes to just process
    this step makes it difficult to make minor tweaks. However, our lighting has vastly
    improved with a few clicks. While before the lights were broken by the meshes,
    we now have smooth patches of color and light.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – reason and speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When playing a game, there is only one light that people will not question
    the source of: the Sun. Every other light looks weird if a source cannot be seen.
    Create a mesh and add it to the game to give the lights you are using a reason.
    This could be something along the lines of torches, or lamp posts, or even glowing
    alien goo balls. Whatever they end up being, having them adds that touch of completeness
    that makes the difference between an alright OK-looking game and a great-looking
    game.'
  prefs: []
  type: TYPE_NORMAL
- en: As a second challenge, take a look at your lightmap's quality. Play with the
    various quality settings we discussed to see what the differences are. Also, find
    out how low the resolution can go before you notice any pixelation. Can the settings
    go even lower when running on the smaller, mobile device screens? Go find out.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies are a great way to add interest to the lights in your game. They use
    a texture to adjust how the light is emitted. This effect can cover a wide range
    of uses from sparkling crystals to caged industrial lights and, in our case, headlights.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – applying headlights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By giving our tank headlights, we give the player the ability to control the
    light in their world. Using cookies, we can make them look more interesting than
    just circles of light.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a **Spotlight**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the light in front of the tank and pointing away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, increase the value of the **Intensity** attribute
    to three. This will make our headlights bright like real headlights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need some cookie textures. At the top of the Unity Editor, select **Assets**,
    followed by **Import Package**, and lastly **Light Cookies**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the new window, select **Import** and wait for the loading bar to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a few options to choose from. Inside the `Standard Assets` folder,
    a new folder was created, `Light Cookies` that contains the new textures. Drag
    `Flashlight` from the **Project** window and drop it onto the **Cookie** field
    on the **Spotlight** in the **Inspector** window. It is as simple as that to add
    a cookie to a light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish it off, duplicate the light for the second headlight and make them
    both children of the tank. What good is having headlights if they don't come with
    us?![Time for action – applying headlights](img/2014OT_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a pair of headlights for our tank using cookies. This is exactly
    how many other games, especially horror games, create flashlight effects.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding a switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try making a script that will allow the player to turn the headlights on and
    off. It should be a simple button that toggles the lights. Take a look at the
    enabled variable that is supplied as part of the light.
  prefs: []
  type: TYPE_NORMAL
- en: As a simpler challenge, create a lamp that sits on the turret of the tank. Give
    it a light as well. With this, the player can point a light to where they are
    shooting and not just in the direction their tank is pointing.
  prefs: []
  type: TYPE_NORMAL
- en: Blob shadow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blob shadows are a simpler and cheaper method for adding a shadow to a character.
    They have been around since the dawn of time. A normal shadow is a solid, dark
    projection of an object onto another surface. The contours of the shadow exactly
    match the contours of the object. This becomes expensive to calculate when characters
    start to move around randomly.
  prefs: []
  type: TYPE_NORMAL
- en: A blob shadow is a blot of black texture underneath a character or an object.
    It usually does not have a clearly definable shape and never matches the contours
    of the object it is meant to be the shadow of. The blob shadow also, generally,
    does not change sizes. This makes it significantly easier to calculate, making
    it the shadow of choice for many generations of video games. That also means it
    is a better option for our mobile devices where processing speed can quickly become
    an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – a tank with a shadow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add a blob shadow to our tank. Unity has already done the bulk
    of the work for us; we just need to add it to the tank.
  prefs: []
  type: TYPE_NORMAL
- en: We start this one off by importing Unity's blob shadow. Go to the top of the
    Unity Editor, select **Assets**, **Import Package**, and finally **Projectors**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Import** in the new window and take a look in the **Project** window
    for a new folder called `Projectors` created under `Standard Assets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Blob Shadow Projector` prefab from the **Project** window to the scene
    and position it above the tank.![Time for action – a tank with a shadow](img/2014OT_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, the shadow is appearing on top of our tank. To fix this, we need
    to again make use of layers. So, select the tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Layer** drop-down list, select **Add Layer...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the right-hand side of **User Layer 9** and give it the name `PlayerTank`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your tank once more, but select `PlayerTank` from the **Layer** drop-down
    list this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the new window pops up, be sure to select **Yes, change children** to change
    the layer of the whole tank. If you don't, the blob shadow may appear on some
    parts of the tank while not on other parts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select `Blob Shadow Projector` from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The blob shadow is created by the **Projector** component. This component functions
    in a similar manner to the **Camera** component. However, it puts an image on
    the world rather than turning the world into an image and putting it on your screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take a look at the **Inspector** window. The value we are concerned with right
    now is that of **Ignore Layers**. Right now it is set to **Nothing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Nothing** and select `PlayerTank` from the **Layers** drop-down list.
    This will make the projector ignore the tank and only make the blob shadow appear
    underneath it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to change the size of the shadow to roughly match the size
    of the tank. Adjust the value of the **Field of View** attribute until the size
    is about right. A value of about 70 seems to be a good place to start from.![Time
    for action – a tank with a shadow](img/2014OT_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to make `Blob Shadow Projector` a child of the tank. We need
    to be able to bring our shadow with us; we don't want to lose it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We gave our tank a shadow. Shadows are great for making objects, and especially
    characters, look like they are actually touching the ground. The blob shadow that
    we used is better than real-time shadows because it is processed faster.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – making it square
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The texture that the blob shadow came with is round but our tank is mostly square.
    Try creating your own texture for the blob shadow and use that. Some sort of rectangle
    should work well.
  prefs: []
  type: TYPE_NORMAL
- en: If you managed to add your own texture to the blob shadow, then how about taking
    a look at that cannon? The cannon sticks out of our tank and ruins its otherwise
    square profile. Use a second blob shadow, attached to the turret, to project a
    shadow for the cannon. The texture for it will also have to be a rectangle-type
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be well and truly familiar with camera effects and
    lights.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we started with a look at using multiple cameras. We then played
    around with a turbo boost camera effect. The chapter continued with the lighting
    of our city. The lights improved greatly when we made use of lightmaps. We finished
    it off with a look at cookies and blob shadows for use with some special lighting
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, will see the creation of enemies for our game. We will
    use Unity's pathfinding system to make them move around and chase the player.
    After this, the player is going to need to be much more active if they hope to
    keep their points.
  prefs: []
  type: TYPE_NORMAL
