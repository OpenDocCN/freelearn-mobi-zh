<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Oh Goodness! Look Whats New in the Foundation Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Oh Goodness! Look Whats New in the Foundation Framework</h1></div></div></div><p>Last year, Apple delivered a great talk on the benefits of using value types and protocol-oriented design patterns in our code. This year with Swift 3, the team at Apple added value types to the Foundation framework. Many of our favorite and heavily used classes now have value type equivalents. We will cover how to use Foundation value types throughout this chapter and have you wondering why value types weren't included with Swift from the beginning!</p><p>New to Foundation and made possible by Swift 3, the new measurements and units API <a class="ulink" href="https://developer.apple.com/reference/foundation/nsmeasurement">https://developer.apple.com/reference/foundation/nsmeasurement</a> addresses pain points that have been with Objective-C and Swift developers for a long time. Apple has created an extremely well thought out solution to our problems. We will use several examples to hammer in the concepts so that you will leave this chapter better prepared to handle your measurement challenges in the future.</p><div class="section" title="Mutability and Foundation value types"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec38"/>Mutability and Foundation value types</h1></div></div></div><p>One of the key concepts of the Swift language is to give developers the ability to control the mutability of their objects. We use <code class="literal">let</code> to make a value a constant and <code class="literal">var</code> to make the value a variable. However, certain types, when imported from Objective-C, do not provide easy mutability features. Swift 3 aims to change this by adding a new set of Foundation value types to wrap reference types in order to provide mutable options for developers. In fact, this really isn't all that new as Foundation already uses many value types in both Objective-C and Swift. Foundation has existing types such as primitives, Enumerations, Option sets, and C structure types that already were value types in previous versions of Swift and Objective-C.</p><p>To make the conversion from reference type to value type possible, Swift uses the <span class="emphasis"><em>copy-on-write</em></span> technique for new value types whose underlying data contains more than just simple data. With <span class="emphasis"><em>copy-on-write</em></span>, the value type represents a pointer to shared data and only makes a copy of the data, if there is a request to change the data by one of the references to it. The following table lists the new value types added to the Foundation framework.</p><p>Table 1: new value types:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>Value type</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>class Type</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">AffineTransform</code>
</p>
</td><td>
<p>
<code class="literal">NSAffineTransform</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">CharacterSet</code>
</p>
</td><td>
<p>
<code class="literal">NSCharacterSet</code>, <code class="literal">NSMutableCharacterSet</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">Data</code>
</p>
</td><td>
<p>
<code class="literal">NSData</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">Date</code>
</p>
</td><td>
<p>
<code class="literal">NSDate</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">DateComponents</code>
</p>
</td><td>
<p>
<code class="literal">NSDateComponents</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">DateInterval</code> (new)</p>
</td><td>
</td></tr><tr><td>
<p>
<code class="literal">Decimal</code>
</p>
</td><td>
<p>
<code class="literal">NSDecimal</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">IndexPath</code>
</p>
</td><td>
<p>
<code class="literal">NSIndexPath</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">IndexSet</code>
</p>
</td><td>
<p>
<code class="literal">NSIndexSet</code>, <code class="literal">NSMutableIndexSet</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">Measurement</code> (new)</p>
</td><td>
</td></tr><tr><td>
<p>
<code class="literal">Notification</code>
</p>
</td><td>
<p>
<code class="literal">NSNotification</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">PersonNameComponents</code>
</p>
</td><td>
<p>
<code class="literal">NSPersonNameComponents</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">URL</code>
</p>
</td><td>
<p>
<code class="literal">NSURL</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">URLComponents</code>
</p>
</td><td>
<p>
<code class="literal">NSURLComponents</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">URLRequest</code>
</p>
</td><td>
<p>
<code class="literal">NSURLRequest</code>, <code class="literal">NSMutableURLRequest</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">URLQueryItem</code>
</p>
</td><td>
<p>
<code class="literal">NSURLQueryItem</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">UUID</code>
</p>
</td><td>
<p>
<code class="literal">NSUUID</code>
</p>
</td></tr></tbody></table></div><p>These new value types work just like their counterparts, with the added value that you can control the mutability in a more transparent way. Some of the new value types are implemented as structure types and will have one or more mutating methods exposed. The good news is that the new Foundation value types will have no impact on existing Objective-C code. However, there will be an impact on the Swift side. Any existing Swift code migrated to Swift 3 that uses reference types will shift to call the new value types. While the migrator will do much of the heavy lifting, you will still have opportunities to further enhance your code use. This is because the migrator utilizes a strategy of making the minimum number of changes possible. As an example, the migrator will not attempt to change any Swift subclasses for reference types.</p></div></div>
<div class="section" title="Value types versus reference types"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Value types versus reference types</h1></div></div></div><p>As a refresher, let's quickly cover the difference between value and reference types. Value types hold values and copy content on assignment or when they are passed to methods as a parameter.</p><pre class="programlisting">let avg1: Double = 98.1 &#13;
var avg2 = avg1 &#13;
avg2 += 1.2   // -&gt; 99.3 &#13;
</pre><p>In the preceding example, <code class="literal">avg2</code> copies the value of <code class="literal">avg1</code>, and is free to change its value without affecting the value of <code class="literal">avg1</code>. Reference types, on the other hand, share content by default. Changing one of the variables will change the underlying value that each reference shares.</p><pre class="programlisting"> &#13;
let dateComponents1 = NSDateComponents() &#13;
dateComponents1.setValue(10, forComponent: .Day) &#13;
dateComponents1.day // =&gt; 10 &#13;
var dateComponents2 = dateComponents1 &#13;
dateComponents2.setValue(2, forComponent: .Day) &#13;
dateComponents1.day // =&gt; 2 &#13;
dateComponents2.day // =&gt; 2 &#13;
</pre><p>In this example, we use the reference type <code class="literal">NSDateComponents</code> to create <code class="literal">dateComponents1</code> and set the day calendar unit to 10. We then create another variable and assign our first value to it. Since both variables share their underlying data, modifying either variable changes both values.</p></div>
<div class="section" title="Nested enumerations"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Nested enumerations</h1></div></div></div><p>The Foundation framework takes advantage of Swift 3's new nested enumeration feature. This feature allows the migrator to import related Objective-C enumerations into Swift under a common type. For example, the <code class="literal">NSDateFormatterStyle</code> and <code class="literal">NSDateFormatterBehavior</code> enumerations are imported as nested enumerations to the <code class="literal">DateFormatter</code> class in Swift. Let's see how we get to a nested enumeration in Swift 3, starting with an Objective-C enumeration.</p><p>In Objective-C:</p><pre class="programlisting">typedef NS_ENUM(NSUInteger, NSDateFormatterStyle), &#13;
{ &#13;
   NSDateFormatterNoStyle     = kCFDateFormatterNoStyle, &#13;
   NSDateFormatterShortStyle  = kCFDateFormatterShortStyle, &#13;
   NSDateFormatterMediumStyle = kCFDateFormatterMediumStyle, &#13;
   NSDateFormatterLongStyle   = kCFDateFormatterLongStyle, &#13;
   NSDateFormatterFullStyle   = kCFDateFormatterFullStyle &#13;
}; &#13;
 &#13;
typedef NS_ENUM(NSUInteger, NSDateFormatterBehavior){ &#13;
   NSDateFormatterBehaviorDefault = 0, &#13;
   NSDateFormatterBehavior10_0    = 1_000, &#13;
   NSDateFormatterBehavior10_4    = 1_040, &#13;
}; &#13;
</pre><p>In Swift 2.2-Better but not quite done:</p><pre class="programlisting">enum NSDateFormatterStyle : UInt { &#13;
    case NoStyle &#13;
    case ShortStyle &#13;
    case MediumStyle &#13;
    case LongStyle &#13;
    case FullStyle &#13;
} &#13;
 &#13;
enum NSDateFormatterBehavior : UInt { &#13;
    case BehaviorDefault &#13;
    case Behavior10_0 &#13;
    case Behavior10_4 &#13;
} &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">DateFormatter { &#13;
 &#13;
    public enum Style : UInt { &#13;
        case none &#13;
        case short &#13;
        case medium &#13;
        case long &#13;
        case full &#13;
    } &#13;
 &#13;
    public enum Behavior : UInt { &#13;
        case `default` &#13;
        case behavior10_4 &#13;
    } &#13;
} &#13;
</pre><p>Working with nested enumerations in Swift 3 is an improvement over Swift 2.2 because we no longer have to worry about a polluted global namespace of C-based enumerations.</p></div>
<div class="section" title="Strongly typed string enumerations"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Strongly typed string enumerations</h1></div></div></div><p>The Foundation framework has a lot of string-based constants. For example, <code class="literal">UIKit</code> uses <code class="literal">NSNotifications</code> to publishing notifications for an iOS app's lifecycle.</p><pre class="programlisting">NSString *const UIApplicationDidEnterBackgroundNotification        &#13;
NSString *const UIApplicationWillEnterForegroundNotification      NSString *const UIApplicationDidFinishLaunchingNotification; &#13;
</pre><p>New for Foundation, Objective-C now has the ability to use strongly typed string enumerations. This new feature allowed the Foundation team to update the enumerations in Objective-C. Our notifications listed earlier can now use the <code class="literal">NSNotificationName</code> type and convert our preceding constants to:</p><p>In Objective-C:</p><pre class="programlisting">typedef NSString *NSNotificationName NS_EXTENSIBLE_STRING_ENUM; &#13;
NSNotificationName const UIApplicationDidEnterBackgroundNotification        &#13;
NSNotificationName const UIApplicationWillEnterForegroundNotification      NSNotificationName const UIApplicationDidFinishLaunchingNotification; &#13;
</pre><p>In Swift, <code class="literal">NSNotificationName</code> types are imported as an extension on <code class="literal">NSNotification.Name</code>.</p><pre class="programlisting">extension NSNotification.Name { &#13;
public static let UIApplicationDidEnterBackground: NSNotification.Name &#13;
public static let UIApplicationWillEnterForeground: NSNotification.Name &#13;
public static let UIApplicationDidFinishLaunching: NSNotification.Name &#13;
} &#13;
</pre></div>
<div class="section" title="Class properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Class properties</h1></div></div></div><p>For historical reasons, the Foundation framework contains many cases where the state of a property is closely associated with the type. Therefore, you will find lots of class properties on Objective-C types. New for the Swift 3 release, we get a tweak to Objective-C that allows us to use a new syntax for creating class properties. These class properties in Objective-C will be imported into Swift as class properties as well.</p><p>In Objective-C (old way):</p><pre class="programlisting">@interface NSCharacterSet  &#13;
+ (NSCharacterSet *)controlCharacterSet; &#13;
+ (NSCharacterSet *)whitespaceCharacterSet; &#13;
+ (NSCharacterSet *)whitespaceAndNewlineCharacterSet; &#13;
@end &#13;
</pre><p>In Objective-C (new way):</p><pre class="programlisting">@interface NSCharacterSet  &#13;
@property(class, readonly, strong) controlCharacterSet; &#13;
@property(class, readonly, strong) whitespaceCharacterSet; &#13;
@property(class, readonly, strong) whitespaceAndNewlineCharacterSet; &#13;
@end &#13;
</pre><p>In Swift 2.2:</p><pre class="programlisting">class NSCharacterSet{ &#13;
 class func controlCharacters() -&gt; NSCharacterSet &#13;
 class func whitespaces() -&gt; NSCharacterSet &#13;
 class func whitespacesAndNewlines() -&gt; NSCharacterSet &#13;
} &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">class NSCharacterSet{ &#13;
 class var controlCharacters: CharacterSet { get } &#13;
 class var whitespaces: CharacterSet { get } &#13;
 class var whitespacesAndNewlines: CharacterSet { get } &#13;
} &#13;
 &#13;
</pre></div>
<div class="section" title="Type safe access with value types"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Type safe access with value types</h1></div></div></div><p>New with Swift 3, you can use Foundation value types to get compile time checks to eliminate many of the errors that couldn't be discovered until runtime when using reference-based Foundation types. Let's work through an example that demonstrates a runtime check in Swift 2.2.</p><p>In Swift 2.2:</p><pre class="programlisting"> &#13;
if let filePath = NSBundle.mainBundle().pathForResource("testFile", ofType: "txt"){ &#13;
    let fileURL = NSURL.fileURLWithPath(filePath) &#13;
    let keys = [NSURLCreationDateKey, NSURLPathKey, NSURLFileSizeKey,NSURLTagNamesKey] &#13;
    var values = try fileURL.resourceValuesForKeys(keys) &#13;
    if let creationDate = values[NSURLCreationDateKey]{ &#13;
        print("creationDate: \(creationDate)") &#13;
    } &#13;
     &#13;
    values[NSURLTagNamesKey] = ["test", "sample", "playground"] &#13;
    values[NSURLCreationDateKey] = "now"   // à creates an error &#13;
    print(values[NSURLTagNamesKey]) &#13;
    print(values[NSURLCreationDateKey]) &#13;
    try fileURL.setResourceValues(values)  &#13;
} &#13;
</pre><p>In our example, I created a reference to an existing file named <code class="literal">testFile.txt</code>. I would like to know some of the attributes of the file, which I can get by passing an array of strings to the <code class="literal">resourceValuesForKeys</code> method of my file reference. I can read the values using subscript notation and even update the values. Further, I can write the new values back to file with the <code class="literal">setResourceValues</code> method. The problem we experience is subtle and not shown until we execute this block of code. The <code class="literal">NSURLCreationDateKey</code> expects its value to be a valid <code class="literal">NSDate</code>.</p><p>However, I passed a string value. At runtime, our code block crashes with an error as we attempt to update our file with the new resource values. What we want is a way to check our constraints at compile time. Swift 3 now gives us a way to do this, and the Foundation framework has been updated to reflect this new feature. Let's update our example to reflect using type safe access to our file resources.</p><p>In Swift 3:</p><pre class="programlisting">if let filePath = Bundle.main.path(forResource: "testFile",  &#13;
ofType: "txt") { &#13;
    var fileURL = URL(fileURLWithPath: filePath) &#13;
    let keys: Set&lt;URLResourceKey&gt; = [.creationDateKey, .pathKey, &#13;
                                     .fileSizeKey, .tagNamesKey] &#13;
    let values = try fileURL.resourceValues(forKeys: keys)  &#13;
    if let creationDate = values.creationDate{ &#13;
        print("creationDate: \(creationDate)") &#13;
    } &#13;
 &#13;
    var newvalues = values &#13;
    newvalues.creationDate = "now" &#13;
    //error: cannot assign value of type 'String' to type 'Date?' &#13;
    //    newvalues.creationDate = "now" &#13;
    //                             ^~~~~ &#13;
} &#13;
</pre><p>In our updated example, our resource types are now strongly typed values of type <code class="literal">URLResourceKey</code>. When we request the resources from our file, we are returned a struct that contains strongly typed properties. These two changes allow us to have type safe access and help us to catch issues at compile time. That's a pretty nice feature to have and the Foundation team agrees, which is evident by all of the APIs they updated to provide us better type constraints.</p></div>
<div class="section" title="Measurements and units"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Measurements and units</h1></div></div></div><p>With Swift 3's release, the Foundation team is releasing a new API to make handling measurements easier for developers. By allowing developers to create measurements from common built-in units (or create custom ones), convert between units and format them for display. We will cover each of the main areas of the Measurement API to get you ready to use them in your projects.</p><div class="section" title="Measurement"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec33"/>Measurement</h2></div></div></div><p>A measurement is composed of a unit and a value. A unit is a class that contains a single property to hold a symbol. We will come back to units in a moment. For now, let's focus on what you can do with a measurement.</p><pre class="programlisting">public struct Measurement&lt;UnitType : Unit&gt; : ReferenceConvertible, Comparable, Equatable { &#13;
 &#13;
    public typealias ReferenceType = NSMeasurement &#13;
 &#13;
    /// The unit component of the `Measurement`. &#13;
    public let unit: UnitType &#13;
 &#13;
    /// The value component of the `Measurement`. &#13;
    public var value: Double &#13;
 &#13;
    /// Create a `Measurement` given a specified value and unit. &#13;
    public init(value: Double, unit: UnitType) &#13;
} &#13;
 &#13;
let initialAngle = Measurement(value: 30, unit: UnitAngle.degrees) &#13;
let maxAngle = Measurement(value: 90, unit: UnitAngle.degrees) &#13;
var currentAngle = initialAngle * 2.5  // 75.0 ° &#13;
     &#13;
if currentAngle &gt; maxAngle{ &#13;
    print("Angle is greater than max supported angle") &#13;
} &#13;
</pre><p>With a measurement, we can define a value and its unit type, which can be used to convert to another type. We also gain validation that we aren't mixing measurement values that don't work together. It would not necessarily make sense to add a length unit to one that stores a volume. Without the measurement's API, you would have to write your own methods to ensure the proper constraints held true.</p></div><div class="section" title="Unit and dimension"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec34"/>Unit and dimension</h2></div></div></div><p>A <span class="emphasis"><em>Unit</em></span> is a class that has symbol property. A <code class="literal">Dimension</code> is a subclass of <code class="literal">Unit</code> and is used to express categories of units. A <code class="literal">Dimension</code> contains a base unit and allows conversion between units via the <code class="literal">UnitConverter</code> type. <code class="literal">Dimension</code> types also contain singletons for many of the common units you will encounter when dealing with measurements.</p><pre class="programlisting">class Unit : NSObject, NSCopying, NSSecureCoding { &#13;
    open var symbol: String { get } &#13;
    public init(symbol: String) &#13;
} &#13;
 &#13;
class Dimension : Unit, NSSecureCoding {     &#13;
    @NSCopying open var converter: UnitConverter { get } &#13;
    public init(symbol: String, converter: UnitConverter) &#13;
    class func baseUnit() -&gt; Self &#13;
} &#13;
</pre><p>The following table contains a listing of the <code class="literal">Dimension</code> subclasses that are available with Foundation.</p><p>Table 2, Dimension subclasses:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<code class="literal">UnitAcceleration</code>
</p>
</td><td>
<p>
<code class="literal">UnitAngle</code>
</p>
</td><td>
<p>
<code class="literal">UnitArea</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">UnitConcentrationMass</code>
</p>
</td><td>
<p>
<code class="literal">UnitDispersion</code>
</p>
</td><td>
<p>
<code class="literal">UnitDuration</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">UnitElectricCharge</code>
</p>
</td><td>
<p>
<code class="literal">UnitElectricCurrent</code>
</p>
</td><td>
<p>
<code class="literal">UnitElectricPotentialDifference</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">UnitElectricResistance</code>
</p>
</td><td>
<p>
<code class="literal">UnitEnergy</code>
</p>
</td><td>
<p>
<code class="literal">UnitFrequency</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">UnitFuelEfficiency</code>
</p>
</td><td>
<p>
<code class="literal">UnitLength</code>
</p>
</td><td>
<p>
<code class="literal">UnitIlluminance</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">UnitMass</code>
</p>
</td><td>
<p>
<code class="literal">UnitPower</code>
</p>
</td><td>
<p>
<code class="literal">UnitPressure</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">UnitSpeed</code>
</p>
</td><td>
<p>
<code class="literal">UnitTemperature</code>
</p>
</td><td>
<p>
<code class="literal">UnitVolume</code>
</p>
</td></tr></tbody></table></div><p>When using the built-in <code class="literal">Dimension</code> subclasses, you get basic conversion for free. For example, I created a <code class="literal">boxHeight</code> measurement with units of <code class="literal">UnitLength.feet</code> and a <code class="literal">
<span class="emphasis"><em>smallBoxHeight</em></span>
</code> with units of <code class="literal">UnitLength.inches</code>. Next, I added the two measurements together and stored the value. The <code class="literal">totalHeight</code> variable stores the combined value using <code class="literal">UnitLength</code> base value of meters.</p><pre class="programlisting">let boxHeight = Measurement(value: 3.2, unit: UnitLength.feet) &#13;
let smallBoxHeight = Measurement(value: 20, unit: UnitLength.inches)  &#13;
let totalHeight = boxHeight + smallBoxHeight &#13;
print(totalHeight) // 1.48336 m  &#13;
</pre><p>We can also use our comparison operations like <code class="literal">==</code>,<code class="literal"> &gt;</code>,<code class="literal"> &lt;</code> because our measurements convert to the base unit before doing the conversions.</p><pre class="programlisting">if boxHeight &gt; smallBoxHeight{ &#13;
    print("boxHeight is still larger") &#13;
} &#13;
</pre></div><div class="section" title="Custom units"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec35"/>Custom units</h2></div></div></div><p>There are going to be times when you need a unit type that doesn't conform to one of the pre-built <code class="literal">Dimension</code> subclasses. To make your own units, you will need to create a unit type on an existing <code class="literal">Dimension</code>, supplying a symbol and unit converter function.</p><pre class="programlisting">let burgerSymbol = "\u{1F354}" //  &#13;
let burgers = UnitLength(symbol: burgerSymbol , converter: UnitConverterLinear(coefficient: 2)) &#13;
</pre><p>You can add new units to any of the <code class="literal">Dimension</code> subclasses. Our preceding example creates a new <code class="literal">burgers</code> unit on <code class="literal">UnitLength</code>. If you need more of a time-based unit, you could create a unit on <code class="literal">UnitDuration</code>.</p><pre class="programlisting">let gittieSecond = UnitDuration(symbol: "gs", converter: UnitConverterLinear(coefficient: 0.5)) &#13;
</pre><p>By providing a converter function, you ensure that your unit can be converted between its unit and the base unit on the <code class="literal">Dimension</code> with which it is associated.</p></div><div class="section" title="Custom Dimension types"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec36"/>Custom Dimension types</h2></div></div></div><p>Now that we know how to create our new units for the <code class="literal">Dimension</code> subclasses, the questions that begs to be asked is whether you can create custom <code class="literal">Dimension</code> types. As you might have already guessed, creating a new <code class="literal">Dimension</code> subclass is also possible and straightforward.</p><pre class="programlisting">public class ToddlerMovement: Dimension{ &#13;
    static let tummyCrawl = ToddlerMovement(symbol: "crawls", converter: UnitConverterLinear(coefficient: 0.25)) &#13;
    static let allFours = ToddlerMovement(symbol: "allfours", converter: UnitConverterLinear(coefficient: 2.0)) &#13;
    static let shakySteps = ToddlerMovement(symbol: "shaky_steps", converter: UnitConverterLinear(coefficient: 1)) &#13;
} &#13;
 &#13;
let playPenDistance = Measurement(value: 4, unit: ToddleMovement.tummyCrawl) &#13;
let kitchenFloorDistance = Measurement(value: 20, unit: ToddleMovement.shakySteps) &#13;
let almostThereDistance = Measurement(value: 10, unit: ToddleMovement.allFours) &#13;
 &#13;
print(playPinDistance) // 4.0 crawls &#13;
print(kitchenFloorDistance) // 20.0 shaky_steps &#13;
print(almostThereDistance) // 10.0 allfours &#13;
</pre></div><div class="section" title="Convert functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec37"/>Convert functions</h2></div></div></div><p>In each of the prior <code class="literal">Measurement</code> examples, we used the <code class="literal">UnitConverterLinear</code> function as our converter function. As mentioned earlier, you need to include a converter function any time you add a new unit to a <code class="literal">Dimension</code>. The converter method is used to convert to and from the <code class="literal">Dimension</code> base unit value. The <code class="literal">UnitConverterLinear</code> converter allows you to make conversions between units when the relation is linear (for example, <span class="emphasis"><em>y = mx + b)</em></span>. This class has two initializers:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">One to provide just the slope (coefficient or <span class="emphasis"><em>m </em></span>in our line equation) when there is no offset.</li><li class="listitem">The other to allow you to provide both a slope and offset (b).</li></ol></div><pre class="programlisting">class UnitConverterLinear : UnitConverter { &#13;
   var coefficient: Double { get } &#13;
   var constant: Double { get } &#13;
   init(coefficient: Double) &#13;
   init(coefficient: Double, constant: Double) &#13;
} &#13;
</pre><p>Linear Conversion:</p><pre class="programlisting">baseUnit = value * coefficient + constant &#13;
value = (baseUnit - constant) / coefficient &#13;
</pre><p>The <code class="literal">UnitConverterLinear</code> converter is really useful and will allow you to cover many conversions by just providing the ratio between two unit values. However, this converter won't fit every relationship between two units. Therefore, you can also subclass <code class="literal">UnitConverter</code> and create a conversion formula that meets your use case when the need arises.</p><pre class="programlisting">class UnitConverter : NSObject { &#13;
   open func baseUnitValue(fromValue value: Double) -&gt; Double &#13;
   open func value(fromBaseUnitValue baseUnitValue: Double) -&gt; Double &#13;
} &#13;
</pre><p>If you choose to create your own custom unit converter, you are will need to override the <code class="literal">baseUnitValue(fromValue value: Double)</code> and <code class="literal">value(fromBaseUnitValue baseUnitValue: Double)</code> methods. These two methods are used internally to perform conversions for you.</p></div><div class="section" title="Formatting measurements"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec38"/>Formatting measurements</h2></div></div></div><p>Dealing with formatting is tough, and you don't have to look any further than the <code class="literal">NSDateFormatter</code> to see how complicated things could be when working with dates. Fortunately, the Foundation team added a new measurements formatter to do all of the heavy lifting for us. <code class="literal">MeasurementFormatter</code> will handle formatting our <code class="literal">Measurements</code> and <code class="literal">Unit</code> types, while taking into account the user's locale.</p><pre class="programlisting">class MeasurementFormatter : Formatter, NSSecureCoding { &#13;
   var unitOptions: MeasurementFormatter.UnitOptions &#13;
   var unitStyle: Formatter.UnitStyle &#13;
   @NSCopying var locale: Locale! &#13;
   @NSCopying var numberFormatter: NumberFormatter! &#13;
   func string(from measurement: Measurement&lt;Unit&gt;) -&gt; String &#13;
   func string(from unit: Unit) -&gt; String &#13;
} &#13;
</pre><p>The <code class="literal">UnitOptions</code> property on <code class="literal">MeasurementFormatter</code> is a special property that we need to take a moment to discuss. The <code class="literal">UnitOptions</code> property is a struct on the <code class="literal">MeasurementFormatter</code> and instructs our formatter to use the preferred unit of the user's locale by default.</p><pre class="programlisting">extension MeasurementFormatter { &#13;
   public struct UnitOptions : OptionSet { &#13;
    &#13;
   public init(rawValue: UInt) &#13;
    &#13;
   public static var providedUnit:  &#13;
                           MeasurementFormatter.UnitOptions { get } &#13;
   public static var naturalScale:  &#13;
                           MeasurementFormatter.UnitOptions { get } &#13;
   public static var temperatureWithoutUnit: &#13;
                           MeasurementFormatter.UnitOptions { get } &#13;
    } &#13;
} &#13;
</pre><p>In our example here, we create a custom unit (<code class="literal">
<span class="emphasis"><em>gittieSecond</em></span>
</code>) and a measurement using this unit. We then create a <code class="literal">MeasurementFormatter</code> and call the <code class="literal">string</code> method, passing our measurement, to get a formatted measurement using the <code class="literal">Dimension</code> base unit. Even though our custom unit has a <code class="literal">gs</code> symbol, the formatter converts and displays our measurement using <code class="literal">seconds</code>.</p><pre class="programlisting">let formatter = MeasurementFormatter() &#13;
let gittieSecond = UnitDuration(symbol: "gs", converter: UnitConverterLinear(coefficient: 0.5)) &#13;
let getterThere = Measurement(value: 5, unit: gittieSecond) // 5.0 gs &#13;
let formattedGS = formmatter.string(from: getterThere) &#13;
print(formattedGS) // 2.5 sec &#13;
</pre><p>To change the output of the formatter from using the base unit to instead use our <code class="literal">gittieSecond</code> unit, we need to modify the <code class="literal">UnitOptions</code> property on the formatter. In my locale, the preferred unit for <code class="literal">UnitDuration</code> is <code class="literal">seconds</code>. By changing the <code class="literal">UnitOptions</code> use reference <code class="literal">providedUnit</code>, we ensure that our formatter will use the same unit as the <code class="literal">getterThere</code> measurement passed to the formatter.</p><pre class="programlisting">formatter.unitOptions = .providedUnit &#13;
formatter.string(from: getterThere) // 5 gs &#13;
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we covered changes to the Foundation framework. We started with a discussion on mutability and new value types in Foundation. You learned that both value and reference types have their place in our code. Next, we covered nested enumerations and strongly typed string enumerations. We explored class properties and the type-safe access benefits of value types. Finally, we spent a great deal of time discussing the new Measurements API introduced this year in Foundation. In the next chapter, we will cover testing and debugging. Swift 3 introduces several changes in testing and debugging that should help improve the quality of the code you write.</p></div></body></html>