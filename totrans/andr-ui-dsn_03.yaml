- en: Chapter 3. Expanding your UI – Fragments, Resources, and Gathering User Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。扩展你的 UI – 片段、资源以及收集用户输入
- en: In the previous chapter, we concentrated on creating a strong foundation for
    your app's user interface. In this chapter, we'll build on these foundations using
    additional resources, such as arrays, dimensions, and 9-patch images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们专注于为你的应用程序用户界面创建一个坚实的基础。在本章中，我们将使用额外的资源，如数组、尺寸和 9-patch 图像，在此基础上构建。
- en: 'Once we''ve perfected the *appearance* of your UI, we''ll explore how to make
    the UI react to user input, before taking a look at one UI component that can
    help us make the most out of devices with larger screens: *fragments*. And since
    fragments aren''t the *only* way to take advantage of the extra screen space,
    we''ll also take a look at the multi-window and picture-in-picture modes coming
    up in Android N.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完善了 UI 的 *外观*，我们将探讨如何使 UI 对用户输入做出反应，然后再看看一个可以帮助我们充分利用大屏幕设备的 UI 组件：*片段*。由于片段不是利用额外屏幕空间的
    *唯一* 方法，我们还将看看 Android N 中即将推出的多窗口和画中画模式。
- en: More resource types
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源类型
- en: If your app features any text, then as a general rule, the text belongs in your
    project's `res/strings.xml` file as a string resource and *not* in your application
    code. Although we've touched on string resources in the previous chapter, they're
    such an integral part of the vast majority of Android applications that it makes
    sense to look at them in more detail, particularly in regards to some of the more
    complex tasks you can perform with string resources, such as creating string arrays.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序有任何文本，那么一般来说，文本应该属于你项目中的 `res/strings.xml` 文件作为字符串资源，而不是在应用程序代码中。尽管我们在上一章中提到了字符串资源，但它们是绝大多数
    Android 应用程序的一个基本组成部分，因此有必要更详细地研究它们，特别是关于你可以使用字符串资源执行的一些更复杂的任务，例如创建字符串数组。
- en: Creating and styling string resources
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和样式化字符串资源
- en: A string is a simple resource that you define once in your project's `res/values/strings.xml`
    file, and then use it multiple times throughout your project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一个简单的资源，你只需在项目中的 `res/values/strings.xml` 文件中定义一次，然后在整个项目中多次使用它。
- en: 'You define string resources using the following syntax:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语法定义字符串资源：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You also have the option to add style attributes to your string resources,
    so every time you use the string resource in your application, it has exactly
    the same styling. Android supports the following HTML markup:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择为字符串资源添加样式属性，这样每次你在应用程序中使用字符串资源时，它都有完全相同的样式。Android 支持以下 HTML 标记：
- en: '`<b>` for bold text'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<b>` 用于加粗文本'
- en: '`<i>` for italic text'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<i>` 用于斜体文本'
- en: '`<u>` for underlined text'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<u>` 用于下划线文本'
- en: 'Wrap your chosen HTML markup around the text you want to style:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将你选择的 HTML 标记包裹在你想样式的文本周围：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although you''ll typically reference string resources from your application''s
    layout resource files, you can also reference a string via your Java code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你通常会在应用程序的布局资源文件中引用字符串资源，但你也可以通过 Java 代码引用字符串：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating string arrays
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建字符串数组
- en: 'A string array is exactly what it sounds like: an array of string resources.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数组正如其名：字符串资源数组。
- en: String arrays are useful when you have multiple related strings that always
    appear together, such as a list of options in a recurring menu.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多个相关的字符串总是同时出现时，字符串数组非常有用，例如在重复出现的菜单中的选项列表。
- en: While you *could* define every item as a separate string resource and then reference
    each string individually, this is pretty time consuming, plus you'll need to remember
    a long list of different string IDs! It usually makes more sense to add all your
    string resources to a single array, so you can display all these strings just
    by referencing a single string array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将每个项目定义为单独的字符串资源，然后单独引用每个字符串，但这非常耗时，而且你还需要记住一个长长的不同字符串 ID 列表！通常，将所有字符串资源添加到单个数组中更有意义，这样你只需通过引用单个字符串数组就可以显示所有这些字符串。
- en: 'You typically create string arrays in a dedicated `res/values/arrays.xml` file.
    For example, the following XML defines a string array called **ingredients** that
    consists of five string resources:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常在专门的 `res/values/arrays.xml` 文件中创建字符串数组。例如，以下 XML 定义了一个名为 **ingredients**
    的字符串数组，它包含五个字符串资源：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To load this string array, use the `getStringArray()` method of the `Resources`
    class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载这个字符串数组，请使用 `Resources` 类的 `getStringArray()` 方法：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: String arrays are also useful for rapidly populating spinner controls. Assuming
    the spinner control's options are static and predetermined, you can define all
    these options in a string array and then load the array inside the spinner control.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数组对于快速填充旋转器控件也非常有用。假设旋转器控件的选项是静态和预定的，您可以在字符串数组中定义所有这些选项，然后加载数组到旋转器控件中。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **spinner** is a UI element where the user selects one value from a list of
    options. When the user touches the spinner control, a drop down appears displaying
    all the available options. The user can then select an option from the list, and
    the spinner control then displays this selected option in its default, unopened
    state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**旋转器**是一个用户界面元素，用户可以从选项列表中选择一个值。当用户触摸旋转器控件时，会弹出一个下拉菜单，显示所有可用选项。用户可以从列表中选择一个选项，然后旋转器控件将显示所选选项在其默认未打开状态下。'
- en: To populate a spinner using a string array, add the spinner control to your
    activity's layout resource file, and then reference the array using `android:entries:`
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用字符串数组填充一个旋转器，请将旋转器控件添加到您的活动布局资源文件中，然后使用`android:entries:`引用数组
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Defining dimensions in dimens.xml
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`dimens.xml`中定义维度
- en: 'Android supports several different units of measurement that you can hardcode
    into your project using XML or Java, such as `android:textSize="20sp"`. However,
    you can also define the dimensions you want to use in advance in your project''s
    `res/values/dimens.xml` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持多种不同的度量单位，您可以使用XML或Java将其硬编码到项目中，例如`android:textSize="20sp"`。然而，您也可以在项目中的`res/values/dimens.xml`文件中预先定义您想要使用的维度：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you can set the size of your UI components by referencing the corresponding
    value within your `dimens.xml` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过引用`dimens.xml`文件中的相应值来设置您的UI组件的大小：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also apply values from your `dimens.xml` file using Java:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Java应用`dimens.xml`文件中的值：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But why go to the extra effort of using the `dimens.xml` file, when you can
    just add dimension information to your layout directly?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么还要费劲使用`dimens.xml`文件，当您可以直接在布局中添加维度信息时？
- en: Though this may seem like the quickest option, it isn't good practice to mix
    your dimensions with your layout and application code. Similar to string resources,
    the `dimens.xml` file provides a single, dedicated place where you can change
    your project's dimensions *without* having to touch the rest of your code. It
    also helps you create a consistent user interface, as it encourages you to define
    a set of values once and then use these same values throughout your app.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这似乎是最快的选择，但将维度与布局和应用程序代码混合并不是一个好的实践。类似于字符串资源，`dimens.xml`文件提供了一个单一、专门的地点，您可以在这里更改项目维度，而无需触及您的其他代码。它还有助于创建一致的用户界面，因为它鼓励您定义一组值一次，然后在您的整个应用程序中使用这些相同的值。
- en: Secondly, you can use multiple `dimens.xml` files to create a more flexible
    user interface. Using the `dimens.xml` files in this way does require a bit of
    prep work, as you'll need to create multiple `res/values` folders that target
    Android's different generalized densities. In the same way you, create multiple
    `drawable` folders to manage your project's images.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您可以使用多个`dimens.xml`文件来创建一个更灵活的用户界面。以这种方式使用`dimens.xml`文件确实需要一些准备工作，因为您需要创建多个针对Android不同通用密度的`res/values`文件夹。同样地，您也需要创建多个`drawable`文件夹来管理您项目中的图片。
- en: 'Open your project''s `res` folder and create the following folders:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您项目的`res`文件夹，并创建以下文件夹：
- en: '`values-ldpi`: Targets 120dpi devices'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values-ldpi`：针对120dpi设备'
- en: '`values-mdpi`: Targets 60dpi devices'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values-mdpi`：针对60dpi设备'
- en: '`values-hdpi`: Targets 240dpi devices'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values-hdpi`：针对240dpi设备'
- en: '`values-xhdpi`: Targets 320dpi devices'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values-xhdpi`：针对320dpi设备'
- en: '`values-xxhdpi`: Targets 480dpi devices'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values-xxhdpi`：针对480dpi设备'
- en: 'Then, create a `dimens.xml` file inside each folder:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个文件夹中创建一个`dimens.xml`文件：
- en: '![Defining dimensions in dimens.xml](img/B05061_3_1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![在`dimens.xml`中定义维度](img/B05061_3_1.jpg)'
- en: This may seem like a lot of work, but once you have this structure in place,
    you can use your `dimens`. files to define the sets of values that are optimized
    for each screen density category. Then, when the Android system loads your layout,
    it'll select the most appropriate `dimens.xml` file for the current screen configuration
    and apply the file's dimensions to your layout.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来工作量很大，但一旦您建立了这种结构，您就可以使用您的`dimens`文件来定义针对每个屏幕密度类别的优化值集。然后，当Android系统加载您的布局时，它将选择最适合当前屏幕配置的`dimens.xml`文件，并将文件中的维度应用到您的布局上。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: 'You can download the example code files for this book from your account at
    [http://www.packtpub.com](http://www.packtpub.com). If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. You can download the
    code files by following these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载本书的示例代码文件。如果您在其他地方购买了此书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。您可以通过以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的**支持**选项卡上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**代码下载与勘误**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入书籍名称。
- en: Select the book for which you're looking to download the code files.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买此书的来源。
- en: Click on **Code Download**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**代码下载**。
- en: You can also download the code files by clicking on the **Code Files** button
    on the book's webpage at the Packt Publishing website. This page can be accessed
    by entering the book's name in the **Search** box. Please note that you need to
    be logged in to your Packt account.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过点击 Packt Publishing 网站上书籍网页上的**代码文件**按钮来下载代码文件。您可以通过在**搜索**框中输入书籍名称来访问此页面。请注意，您需要登录您的
    Packt 账户。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载完成后，请确保使用最新版本的软件解压缩或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Windows 的 WinRAR / 7-Zip
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Mac 的 Zipeg / iZip / UnRarX
- en: 7-Zip / PeaZip for Linux
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 7-Zip / PeaZip
- en: Color state lists
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色状态列表
- en: 'Each time the user interacts with a UI element, your app will signal that it''s
    registered this interaction. Sometimes, this signal will be built-in: a new screen
    loads up, a pop up opens, or a *tick* appears in a checkbox. However, if it isn''t
    immediately obvious that a UI element has registered the user''s input, you should
    give them a visual clue. One possible method is to use the **color state list**.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户与 UI 元素交互时，您的应用程序都会发出信号，表明它已记录此交互。有时，此信号是内置的：新屏幕加载，弹出窗口打开，或复选框中出现*勾选*。然而，如果无法立即明显地看出
    UI 元素已记录用户的输入，您应提供视觉提示。一种可能的方法是使用**颜色状态列表**。
- en: A color state list defines a series of states and assigns a color to each of
    these states. When you apply a color state list to a view, the view displays different
    colors from the list based on its current state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色状态列表定义了一系列状态，并为这些状态中的每一个分配了一种颜色。当您将颜色状态列表应用于视图时，视图将根据其当前状态显示列表中的不同颜色。
- en: Color state lists are most commonly applied to buttons. For example, a grey
    button may briefly turn a darker shade of grey when it's in a depressed state,
    leaving the user in no doubt about whether the button has registered their interaction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色状态列表最常应用于按钮。例如，一个灰色按钮在按下状态时可能会短暂地变成更深的灰色，这样用户就不会对按钮是否已记录他们的交互产生任何疑问。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Color state lists are similar to the state list resources that we looked at
    in the previous chapter—we're just signaling changes of state using colors rather
    than images.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色状态列表类似于我们在上一章中查看的状态列表资源——我们只是使用颜色而不是图像来表示状态的变化。
- en: To create a color state list, open your project's `res/drawable` folder and
    create a new XML file; give the file a name that indicates its purpose, such as
    `res/drawable/button_background.xml`. Then, fill this file with all the different
    states that you want to trigger a color change and the colors you'd like to use.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建颜色状态列表，打开您的项目`res/drawable`文件夹，并创建一个新的 XML 文件；给文件起一个表明其用途的名字，例如`res/drawable/button_background.xml`。然后，在此文件中填写所有想要触发颜色变化的不同状态以及您想要使用的颜色。
- en: 'The potential states include the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的状态包括以下内容：
- en: '`android:state_pressed="true/false."`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:state_pressed="true/false."`'
- en: '`android:state_focused="true/false."`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:state_focused="true/false."`'
- en: '`android:state_selected="true/false."`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:state_selected="true/false."`'
- en: '`android:state_checkable="true/false."`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:state_checkable="true/false."`'
- en: '`android:state_checked="true/false."`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:state_checked="true/false."`'
- en: '`android:state_enabled="true/false."`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:state_enabled="true/false."`'
- en: '`android:state_window_focused= "true/false."`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:state_window_focused= "true/false."`'
- en: 'In this example, we''re going to add two states to a color state list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将向颜色状态列表中添加两个状态：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order you place your `<item>` element within the selector element is crucial,
    as the system works its way through the color state list in order and selects
    the first item that applies to the view's current state. As you saw in the preceding
    example, you can create a default color that'll be applied to the view when none
    of the other states are applicable. If you create a default state, then you must
    *always* place it at the very end of the color state list as a final resort.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你在选择元素内放置`<item>`元素的顺序至关重要，因为系统会按照顺序遍历颜色状态列表，并选择第一个适用于视图当前状态的项。正如前一个示例中看到的，你可以创建一个默认颜色，当其他状态都不适用时，这个颜色将被应用到视图中。如果你创建了默认状态，那么你必须*始终*将其放置在颜色状态列表的末尾，作为最后的手段。
- en: 'The only thing left to do is apply the color state list resource to your view:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是将颜色状态列表资源应用到你的视图中：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can also refer to your color state list resource in Java using `R.drawable.button_text`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`R.drawable.button_text`在Java中引用你的颜色状态列表资源。
- en: Working with 9-patch images
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与9-patch图像一起工作
- en: A 9-patch graphic is a stretchable bitmap that allows you to define which areas
    the system can and can't stretch when it needs to resize your image to fit the
    current screen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 9-patch图形是一种可拉伸位图，允许你在需要调整图像大小以适应当前屏幕时，定义系统可以和不可以拉伸的区域。
- en: 'When you convert a regular image into a 9-patch image, you add an extra 1-pixel-wide
    border around your image''s top and left areas. This 1-pixel border pinpoints
    exactly which pixels the system should replicate if it needs to create a stretched
    effect rather than simply resizing the entire image:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将普通图像转换为9-patch图像时，你会在图像的顶部和左侧添加一个额外的1像素宽的边框。这个1像素的边框精确地指出了系统在需要创建拉伸效果而不是简单地调整整个图像大小时应该复制的像素：
- en: '![Working with 9-patch images](img/B05061_3_2.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![与9-patch图像一起工作](img/B05061_3_2.jpg)'
- en: Your border doesn't have to be a continuous line; if there's any area you don't
    want the system to stretch, just leave the area as a gap in your border. In the
    previous example, the system can stretch the drawable horizontally and vertically
    by replicating the pixels marked with the black line. However, the corners aren't
    marked, so these will remain the same size, creating a sharper, more defined corner.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你的边框不必是连续的线条；如果你有任何不想让系统拉伸的区域，只需在该区域留出空白即可。在先前的示例中，系统可以通过复制带有黑色线条标记的像素来水平或垂直拉伸可绘制元素。然而，角落没有被标记，所以这些角落将保持相同的大小，从而创建一个更尖锐、更清晰的角落。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Converting an image into 9-patch format adds an extra pixel to your image's
    perimeter. Keep this in mind when you're creating images with the intention of
    converting them into 9-patches!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像转换为9-patch格式会在你的图像外围添加一个额外的像素。当你创建图像的目的是将其转换为9-patch时，请记住这一点！
- en: Although your image can include multiple stretchable sections, your lines must
    be exactly 1 pixel wide for the Android system to correctly recognize these lines;
    stretch your image accordingly (if appropriate), and then remove the lines from
    the finished image. If you add any lines that are thicker than one pixel, the
    system will treat these lines as just another part of your image.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你的图像可以包含多个可拉伸部分，但你的线条必须正好是1像素宽，Android系统才能正确识别这些线条；相应地拉伸你的图像（如果适用），然后从完成的图像中移除线条。如果你添加任何超过一个像素宽的线条，系统将把这些线条视为图像的另一个部分。
- en: If you do use 9-patches, you still need to provide alternate versions of these
    images for each of Android's generalized screen densities (`ldpi`, `mdpi`, `hdpi`,
    `xhdpi`, and `xxhdpi`). When the system loads your app, it'll select the 9-patch
    image that's the best fit for the current screen density, and then it will stretch
    the image's *stretchable* sections if required.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实使用了9-patch，你仍然需要为Android的通用屏幕密度（`ldpi`、`mdpi`、`hdpi`、`xhdpi`和`xxhdpi`）中的每一个提供这些图像的备用版本。当系统加载你的应用时，它会选择最适合当前屏幕密度的9-patch图像，然后如果需要，它会拉伸图像的可拉伸部分。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 9-patch images can stretch, but they can't shrink. For the best results when
    creating 9-patch images that target the different density folders, you should
    target the lowest common resolution for each density category.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 9-patch图像可以拉伸，但不能缩小。在创建针对不同密度文件夹的9-patch图像时，为了获得最佳效果，你应该针对每个密度类别选择最低的共同分辨率。
- en: How do I create 9-patch images?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我该如何创建9-patch图像？
- en: There are lots of different PNG editors out there, but I'll be using Draw 9-patch
    as this editor is included in the Android SDK, so chances are you already have
    it installed on your computer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的PNG编辑器，但我会使用Draw 9-patch，因为这个编辑器包含在Android SDK中，所以您很可能已经在计算机上安装了它。
- en: You'll find the `Draw9patch.bat` program in your computer's `sdk/tools` folder.
    Launch the editor and import your image by dragging it into the Draw 9-patch window.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在计算机的`sdk/tools`文件夹中找到`Draw9patch.bat`程序。启动编辑器，通过将其拖动到Draw 9-patch窗口中导入您的图像。
- en: 'The 9-patch workspace consists of the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 9-patch工作空间包括以下内容：
- en: '**Left pane**: This is the drawing area where you define your image''s stretchable
    sections.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左侧面板**：这是绘图区域，您在这里定义图像的可拉伸部分。'
- en: '**Right pane**: This is the preview area, which displays a preview of how your
    graphic will appear when stretched. As you''re editing your image in the left
    pane, make sure you keep an eye on this preview.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右侧面板**：这是预览区域，它显示了图形拉伸后的预览效果。当您在左侧面板中编辑图像时，请确保您关注这个预览。'
- en: '![How do I create 9-patch images?](img/B05061_3_3.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![如何创建9-patch图像？](img/B05061_3_3.jpg)'
- en: To define the area that can be stretched horizontally, draw a line along the
    top of your image by clicking. Every time you click, a new pixel will be added
    to your line.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义可以水平拉伸的区域，通过点击在图像顶部绘制一条线。每次点击都会在您的线上添加一个新像素。
- en: '![How do I create 9-patch images?](img/B05061_3_4.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何创建9-patch图像？](img/B05061_3_4.jpg)'
- en: If you make a mistake, you can remove pixels by holding the ***Shift*** key
    while clicking each pixel you want to remove.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您犯了错误，可以在点击每个要删除的像素时按住***Shift***键来删除像素。
- en: To define the area that can be stretched vertically, click to draw a line along
    your image's left edge.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义可以垂直拉伸的区域，点击以在图像的左侧边缘绘制一条线。
- en: Once you're happy with the results, save your 9-patch image by selecting **File**
    | **Save 9-patch**. This saves your image with the `.9.png` extension. You can
    then add this graphical resource to your project as normal.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对结果满意，通过选择**文件** | **保存9-patch**来保存您的9-patch图像。这将使用`.9.png`扩展名保存您的图像。然后您可以将此图形资源添加到您的项目中。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not a fan of Draw 9-patch, or you just want to try an alternative,
    there are several free online tools that you can use to create 9-patch images,
    including [http://draw9patch.com/](http://draw9patch.com/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢Draw 9-patch，或者您只是想尝试一个替代方案，有几个免费的在线工具可以帮助您创建9-patch图像，包括[http://draw9patch.com/](http://draw9patch.com/)。
- en: Registering the user input
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册用户输入
- en: Input controls are your UI's interactive components, such as buttons, `EditText`
    fields, and checkboxes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输入控件是您UI的交互组件，例如按钮、`EditText`字段和复选框。
- en: We've already seen how you can drop input controls into your UI, but input controls
    don't register user input out of the box.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将输入控件拖放到您的UI中，但输入控件默认不注册用户输入。
- en: To turn UI components, such as buttons and `EditText` fields, into fully-functioning
    interactive components, you'll need to write some extra code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要将UI组件，如按钮和`EditText`字段，转换为完全功能的交互组件，您需要编写一些额外的代码。
- en: Handling click events
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理点击事件
- en: Click events are one of the most common input events your UI will have to handle.
    A click event is simply where the user touches an onscreen element, such as tapping
    a button or a checkbox.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 点击事件是您的UI必须处理的最常见的输入事件之一。点击事件简单地说是用户触摸屏幕上的元素，例如点击按钮或复选框。
- en: A button cannot process clicks on its own; you'll need to create a listener
    and then assign it to the button. When the user taps the button, the listener
    registers the tap and executes the code from your `onClick` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮不能单独处理点击事件；您需要创建一个监听器并将其分配给按钮。当用户点击按钮时，监听器会注册点击并执行您的`onClick`方法中的代码。
- en: Let's imagine that your layout contains a single button, and you want that button
    to register click events. As with many things in Android, you can create the same
    effect via XML or via your application code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设您的布局中只有一个按钮，并且您希望该按钮能够注册点击事件。与Android中的许多事物一样，您可以通过XML或通过您的应用程序代码创建相同的效果。
- en: Handling onClick Via Java
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Java处理onClick
- en: Here's how you can handle these events using `Java`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Java`来处理这些事件。
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Handling onClick Via XML
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过XML处理onClick
- en: 'You can create the same functionality via your layout resource file by adding
    the `android:onClick` attribute to your view, and then adding the `onClick` method
    to the corresponding Java file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在布局资源文件中添加`android:onClick`属性到您的视图，然后添加相应的Java文件中的`onClick`方法来创建相同的功能：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Whenever the user clicks this button, the `buttonClicked` method will be executed,
    so the next step is to add this method to your Java file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 无论用户何时点击此按钮，都会执行 `buttonClicked` 方法，因此下一步是将此方法添加到您的 Java 文件中：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Registering the EditText input
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册 EditText 输入
- en: When you drop `EditText` into your UI, the user can type text into the field,
    but by default, `EditText` cannot read or use this information.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将 `EditText` 添加到 UI 中时，用户可以在字段中输入文本，但默认情况下，`EditText` 无法读取或使用这些信息。
- en: 'For `EditText` to acquire user input, you need to do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `EditText` 获取用户输入，您需要执行以下操作：
- en: Get a reference to the `EditText` field using `findViewById`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `findViewById` 获取 `EditText` 字段的引用。
- en: Get the text from the `EditText` field using `getText()`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `getText()` 从 `EditText` 字段获取文本。
- en: You may then want to display this text elsewhere in your UI using `setText()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望使用 `setText()` 在 UI 的其他地方显示此文本。
- en: Now that you know how to register click events and retrieve the user input from
    `EditText`, let's look at an example app that combines all this functionality.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何注册点击事件并从 `EditText` 获取用户输入，让我们看看一个结合所有这些功能的示例应用。
- en: The example app
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例应用
- en: We'll create a simple app that asks users to enter their name into `EditText`
    and then tap a **Submit** button. The app will then retrieve the user's name from
    the `EditText` field and display it in `TextView` as the part of a welcome message.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用，要求用户在 `EditText` 中输入他们的名字，然后轻触 **提交** 按钮。应用将然后从 `EditText` 字段中检索用户的姓名，并在
    `TextView` 中作为欢迎信息的一部分显示它。
- en: 'Create a simple layout that contains these three onscreen elements:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含这三个屏幕元素的简单布局：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, open `res/values/strings.xml` and create your string resources:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `res/values/strings.xml` 并创建字符串资源：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![The example app](img/B05061_3_5.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![示例应用](img/B05061_3_5.jpg)'
- en: Now that you have your UI, it's time to give these on-screen elements the ability
    to register and process the user input.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了 UI，是时候让这些屏幕元素能够注册并处理用户输入了。
- en: 'In this example, we create an event listener and assign it to our `submitButton`.
    When the user taps the **Submit** button, the app registers this interaction and
    retrieves whatever text is currently in the `EditText` field. It then sets this
    value to `TextView`, replacing the default **Please complete the form below**
    text with the `EditText` value, plus two other bits of text, to create our complete
    welcome message:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了一个事件监听器并将其分配给我们的 `submitButton`。当用户轻触 **提交** 按钮时，应用会注册此交互并检索 `EditText`
    字段中当前的所有文本。然后它将此值设置为 `TextView`，用 `EditText` 的值替换默认的 **请完成以下表格** 文本，并添加其他两段文本，以创建我们的完整欢迎信息：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is it—boot up your app and try interacting with the different UI elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——启动您的应用并尝试与不同的 UI 元素进行交互。
- en: '![The example app](img/B05061_3_6.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![示例应用](img/B05061_3_6.jpg)'
- en: Working with fragments
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段
- en: When you're developing your UI for pre-Android N devices, one of the major restrictions
    you'll encounter is that you can only ever display a single activity on the screen
    at any one time. Fragments give you a way to overcome this restriction; although
    *technically* you can still only display one activity at a time; each activity
    can consist of multiple fragments.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为预 Android N 设备开发 UI 时，您将遇到的一个主要限制是，在任何时候您只能显示屏幕上的单个活动。片段为您提供了一种克服这种限制的方法；尽管**技术上**您仍然一次只能显示一个活动；每个活动可以由多个片段组成。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android N introduced multi-window mode, which gives users the ability to display
    more than one app at a time, allowing them to see multiple activities at once,
    albeit from different applications! We'll take a closer look at multi-window mode
    later in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Android N 引入了多窗口模式，这使用户能够同时显示多个应用，尽管它们来自不同的应用，但可以一次性查看多个活动！我们将在本章后面更详细地探讨多窗口模式。
- en: A fragment is a self-contained, modular section of your app's user interface
    that you embed inside an activity. You *cannot* instantiate a fragment as a standalone
    application element. Think of a fragment as a kind of *sub activity* that has
    its own life cycle, behavior, and (usually) its own user interface.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个片段是您应用用户界面中的一个独立、模块化的部分，您可以在一个活动中嵌入它。您**不能**将片段作为一个独立的应用程序元素实例化。将片段视为一种具有自己的生命周期、行为和（通常是）自己的用户界面的*子活动*。
- en: Why do we need fragments?
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要片段？
- en: The Android team introduced fragments in Android version 3.0, also known as
    **Honeycomb**, mainly to help developers make better use of all the extra screen
    space available on larger devices, such as tablets. Using fragments, you can divide
    each activity into distinct components and then control each part separately.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Android 团队在 Android 3.0 版本中引入了片段，也称为**蜂巢**，主要是为了帮助开发者更好地利用大设备（如平板电脑）上可用的额外屏幕空间。使用片段，您可以把每个活动分成不同的组件，然后分别控制每个部分。
- en: You can also create multiple layouts that combine your project's fragments in
    different ways depending on the current screen configuration. For example, you
    could create a multi pane layout that combines multiple fragments in a single
    activity; and you could create a single pane layout that displays each fragment
    separately, which is better suited to smaller screens. Your app can then select
    the most appropriate layout (multi pane or single pane) depending on the current
    device.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建多个布局，根据当前屏幕配置以不同的方式组合您项目中的片段。例如，您可以创建一个多栏布局，在单个活动中组合多个片段；您还可以创建一个单栏布局，单独显示每个片段，这更适合较小的屏幕。然后，您的应用程序可以根据当前设备选择最合适的布局（多栏或单栏）。
- en: In this way, fragments are useful for making the most out of devices with larger
    screens, while also providing a good user experience for users viewing your app
    on smaller screens.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，片段对于充分利用大屏幕设备非常有用，同时也能为在较小屏幕上查看您的应用的用户提供良好的用户体验。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may also want to use fragments to create layouts that are optimized for
    devices held in landscape and portrait orientation. For example, you can create
    a layout for landscape devices that displays multiple fragments in a side-by-side
    configuration, and you can create a single-pane layout that displays one fragment
    at a time when the device is in portrait mode.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能想使用片段来创建针对横向和纵向握持优化的布局。例如，您可以为横向握持设备创建一个布局，在该布局中，多个片段并排显示，而当设备处于纵向模式时，您可以创建一个单栏布局，一次显示一个片段。
- en: The final major benefit of using fragments is that when a fragment's host activity
    is running, you can add, remove, and replace each fragment independently to create
    a truly dynamic user interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用片段的最后一个主要好处是，当片段的主活动正在运行时，您可以独立地添加、删除和替换每个片段，以创建一个真正动态的用户界面。
- en: Let's take a look at an example of how an app that provides single-pane and
    multi-pane layouts may work.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个提供单栏和多栏布局的应用程序可能的工作方式示例。
- en: 'Imagine an activity (**Activity 1**) that contains two fragments: **Fragment
    A** and **Fragment B**. **Fragment A** displays a list of items. When the user
    selects an item in **Fragment A**, **Fragment B** updates to display information
    related to the selected item.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个包含两个片段的活动（**活动 1**）：**片段 A** 和 **片段 B**。**片段 A** 显示项目列表。当用户在**片段 A**中选择一个项目时，**片段
    B** 会更新以显示与所选项目相关的信息。
- en: This app includes two different layouts, and it selects which layout to display
    based on the size of the device's screen. If the screen is large enough to accommodate
    both **Fragment A** and **Fragment B**, the app displays these fragments side-by-side
    in **Activity 1**, in a multi-pane layout.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序包含两个不同的布局，并根据设备屏幕的大小选择要显示的布局。如果屏幕足够大，可以容纳**片段 A**和**片段 B**，则应用程序在**活动 1**中以多栏布局并排显示这些片段。
- en: '![Why do we need fragments?](img/B05061_3_7.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![为什么我们需要片段？](img/B05061_3_7.jpg)'
- en: If there isn't enough room to accommodate both fragments, the app will display
    each fragment separately, as different screens in a single-pane layout.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有足够的空间容纳两个片段，应用程序将分别显示每个片段，就像单栏布局中的不同屏幕一样。
- en: 'In this scenario, **Activity 1** displays **Fragment A** *only*. When the user
    selects an item from **Fragment A**, the screen updates to display **Fragment
    B**. This means your app creates an entirely new activity (**Activity 2**) that
    exists simply to host **Fragment B**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**活动 1**仅显示**片段 A**。当用户从**片段 A**中选择一个项目时，屏幕更新以显示**片段 B**。这意味着您的应用程序创建了一个全新的活动（**活动
    2**），它仅仅是为了托管**片段 B**：
- en: '![Why do we need fragments?](img/B05061_3_8.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![为什么我们需要片段？](img/B05061_3_8.jpg)'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While fragments are important tools that can help you create more flexible layouts,
    fragments aren't a magical cure. Even if you do include fragments in your user
    interface, you'll still need to follow all the usual guidelines and best practices
    *in addition to using fragments*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然片段是重要的工具，可以帮助您创建更灵活的布局，但片段并不是万能的解决方案。即使您在用户界面中包含了片段，您仍然需要遵循所有常规的指南和最佳实践*以及使用片段*。
- en: The fragment life cycle
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段生命周期
- en: Although a fragment has its own life cycle, the life cycle is directly affected
    by the life cycle of the host activity. Each life cycle callback for the host
    activity results in a similar callback for all its fragments; for example, when
    the host activity's `onStop()` method is called, all the fragments within the
    activity also receive a call to `onStop()`, and when the activity is destroyed,
    so are all its fragments.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管片段有自己的生命周期，但它的生命周期会直接受到宿主活动生命周期的直接影响。宿主活动的每个生命周期回调都会导致其所有片段产生类似的回调；例如，当宿主活动的`onStop()`方法被调用时，活动中的所有片段也会收到`onStop()`的调用，当活动被销毁时，其所有片段也会被销毁。
- en: You can only manipulate a fragment's life cycle independently while the host
    activity is in its resumed state. At this point, you can add, remove, and replace
    fragments. However, once the host activity leaves its resumed state, all its fragments
    lose their independence and are once again dependent on the host activity's life
    cycle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在宿主活动处于恢复状态时独立操作片段的生命周期。此时，您可以添加、移除和替换片段。然而，一旦宿主活动离开恢复状态，所有片段都会失去独立性，再次依赖于宿主活动的生命周期。
- en: 'Like an activity, a fragment can exist in three states:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像活动一样，片段可以存在于三种状态：
- en: '**Resumed**: The fragment is visible in the running activity.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复状态**：片段在运行的活动中可见。'
- en: '**Paused**: Another activity is in the foreground and has focus, but the fragment''s
    host activity is still visible.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂停状态**：另一个活动在前台并且有焦点，但片段的宿主活动仍然可见。'
- en: '**Stopped**: Either the host activity has been stopped, or the fragment has
    been removed from the activity and added to the back stack. A stopped fragment
    is still alive, but it''s no longer visible to the user.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止状态**：要么是宿主活动已被停止，要么是片段已被从活动中移除并添加到返回栈中。停止状态的片段仍然存活，但对用户来说不再可见。'
- en: 'One major difference between the life cycle of an activity and the life cycle
    of a fragment is how you restore each one and get its state back:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 活动生命周期和片段生命周期的最大区别在于如何恢复每个生命周期并获取其状态：
- en: '**Activity**: When an activity is stopped, it''s placed into a back stack of
    activities that''s managed by the system.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动**：当一个活动被停止时，它会被放入由系统管理的活动返回栈中。'
- en: '**Fragment**: When a fragment is stopped, it''s only placed into a back stack
    that''s managed by the host activity *if* you explicitly request that the instance
    should be saved. To make this request, call `addToBackStack()` during the transaction
    that removes the fragment.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段**：当一个片段被停止时，它只会被放入由宿主活动管理的返回栈中*如果*您明确请求保存该实例。为了进行此请求，在移除片段的事务中调用`addToBackStack()`。'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What is the back stack? And why is it so important?**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是返回栈？为什么它如此重要？**'
- en: The back stack keeps track of all the actions the user can reverse by tapping
    the device's **Back** button, whether that's a physical back key or one of Android's
    illuminated soft keys. If you add a fragment to the back stack, then the user
    can backtrack to that fragment. If you don't add a fragment to the back stack,
    the user cannot recover that fragment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 返回栈会跟踪用户可以通过点击设备的**返回**按钮撤销的所有操作，无论是物理返回键还是Android的背光软键。如果您将片段添加到返回栈中，那么用户就可以回退到该片段。如果您没有将片段添加到返回栈中，用户就无法恢复该片段。
- en: Creating a fragment
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建片段
- en: 'In this section, I''ll show you how to create a simple fragment. The first
    step is defining the fragment''s UI component:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何创建一个简单的片段。第一步是定义片段的UI组件：
- en: Open your project's `res` folder.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您项目的`res`文件夹。
- en: Right-click the `layout` folder and select **New**, followed by **Layout resource
    file**.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`layout`文件夹，选择**新建**，然后选择**布局资源文件**。
- en: Give your layout resource file a descriptive name, such as `list_fragment`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的布局资源文件起一个描述性的名称，例如`list_fragment`。
- en: Select the **Root Element** option you want to use.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要使用的**根元素**选项。
- en: Double-check the **Directory name** option is set to **layout**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保**目录名称**选项设置为**布局**。
- en: Click **OK**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: 'Open your new layout resource file and define your fragment''s UI:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的新布局资源文件并定义您的片段UI：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Before we create the actual fragment, let's take a moment to look at the issue
    of backwards compatibility; specifically, how you can reap the benefits of fragments
    even on devices that run pre-Honeycomb versions of Android.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建实际的片段之前，让我们花一点时间来探讨向后兼容性问题；具体来说，如何在运行 Android Honeycomb 之前版本的 Android 设备上也能享受到片段的好处。
- en: Fragments and backwards compatibility
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 片段和向后兼容性
- en: When you're developing an app, you should aim to support as many versions of
    Android as possible, as this will give you the widest potential audience. Since
    fragments didn't find their way into Android until version 3.0, if you want your
    app to be compatible with devices running anything earlier than Android Honeycomb,
    you'll need to add `v4` of **Android Support Library** to your project.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发应用程序时，你应该尽可能支持尽可能多的 Android 版本，因为这将为你提供最广泛的潜在受众。由于片段直到 Android 3.0 才被引入
    Android，如果你的应用程序需要与运行 Android Honeycomb 之前版本的设备兼容，你需要在项目中添加 **Android 支持库** 的
    `v4` 版本。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android Support Library is a handy set of code libraries that enable you to
    use features and APIs that wouldn't otherwise be available to the earlier versions
    of the Android platform.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持库是一组方便的代码库，它使你能够使用在 Android 平台的早期版本中不可用的特性和 API。
- en: Once you add the v4 library to your project, you can use fragments while remaining
    backwards compatible with devices running versions as low as Android 1.6.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 v4 库添加到你的项目中，你就可以使用片段，同时保持与运行 Android 1.6 及以上版本的设备的向后兼容性。
- en: To add this library to your project, launch Android SDK Manager, open the `Extras`
    folder and download the **Android Support Library** (if you're using Eclipse)
    or **Android Support Repository** (if you're using Android Studio).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此库添加到你的项目中，请启动 Android SDK 管理器，打开 `Extras` 文件夹并下载 **Android 支持库**（如果你使用 Eclipse）或
    **Android 支持存储库**（如果你使用 Android Studio）。
- en: 'If you''re using Android Studio, add the library to your project by opening
    its module-level `build.gradle` file and adding the support library to the dependencies
    section:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Android Studio，请通过打开其模块级别的 `build.gradle` 文件并将支持库添加到依赖项部分来将库添加到你的项目中：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you''re developing in Eclipse, perform the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Eclipse 进行开发，请执行以下操作：
- en: Create the `libs` directory in the root of your project.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录下创建 `libs` 目录。
- en: Locate the support library called the JAR file in your Android SDK directory
    (for example, `<sdk>/extras/android/support/v4/android-support-v4.jar`). Copy
    this JAR into the `libs` directory you created in the previous step.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Android SDK 目录中定位名为 JAR 文件的支持库（例如，`<sdk>/extras/android/support/v4/android-support-v4.jar`）。将此
    JAR 文件复制到你在上一步中创建的 `libs` 目录中。
- en: Right-click the JAR file and select **Build Path**, followed by **Add to Build
    Path**.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 JAR 文件，选择 **Build Path**，然后选择 **Add to Build Path**。
- en: You'll also need to import the fragment class from the v4 support library (`import
    android.support.v4.app.Fragment`) and extend `FragmentActivity` instead of the
    usual `Activity` class (`public class ListFragment extends FragmentActivity`).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从 v4 支持库中导入片段类（`import android.support.v4.app.Fragment`），并使用 `FragmentActivity`
    而不是常规的 `Activity` 类来扩展（`public class ListFragment extends FragmentActivity`）。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are no hard and fast rules about which versions of the Android system
    you should support, though you'll generally want to support as many versions as
    you feasibly can without compromising on your app's functionality. If you do decide
    against supporting the earlier versions of the Android platform, then you don't
    need to use the support library. If you're unsure, it may help you to look at
    Google's stats about the percentage of Android devices currently running each
    version of the Android platform, available at [http://developer.android.com/about/dashboards/index.html](http://developer.android.com/about/dashboards/index.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于应该支持哪些版本的 Android 系统并没有硬性规定，尽管你通常会希望尽可能多地支持版本，同时不牺牲你的应用程序功能。如果你决定不支持 Android
    平台的早期版本，那么你不需要使用支持库。如果你不确定，查看 Google 关于当前运行每个 Android 平台版本的 Android 设备百分比的统计数据可能会有所帮助，这些数据可在
    [http://developer.android.com/about/dashboards/index.html](http://developer.android.com/about/dashboards/index.html)
    找到。
- en: Creating your fragment class
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你的片段类
- en: In addition to creating a layout, you need to have a class associated with your
    fragment. This class must extend `Fragment` or `FragmentActivity`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建布局之外，你还需要有一个与你的片段关联的类。这个类必须扩展 `Fragment` 或 `FragmentActivity`。
- en: 'To add a new class to your project, perform the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新类添加到你的项目中，请执行以下操作：
- en: Open your `Java` folder and right-click on your project's package name.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`Java`文件夹，然后右键单击你的项目包名。
- en: Select **New** followed by **Java Class**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新建**然后**Java类**。
- en: Give your class a descriptive name, for example, `ListFragment`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的类一个描述性的名称，例如，`ListFragment`。
- en: 'Open your new `ListFragment` class; it will look similar to this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的新`ListFragment`类；它将看起来像这样：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You''ll want to make the following changes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做出以下更改：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `inflate()` method (in the preceding code) takes the following arguments:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`inflate()`方法（在前面代码中）接受以下参数：'
- en: The layout file that's being inflated (`R.layout.list_fragment`).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在填充的布局文件（`R.layout.list_fragment`）。
- en: The parent `ViewGroup` where the inflated fragment layout should be inserted
    (`container`).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将填充的片段布局插入的父`ViewGroup`（`container`）。
- en: The `false` Boolean that indicates the inflated layout should be attached to
    the `ViewGroup` during inflation.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示填充的布局应在填充期间附加到`ViewGroup`上的`false`布尔值。
- en: 'The next step is to add the fragment to your activity. You have two options:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将片段添加到你的活动中。你有两种选择：
- en: Embed the fragment in your activity's corresponding XML layout file
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的活动对应的XML布局文件中嵌入片段
- en: Add the fragment at runtime via your application code
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过你的应用程序代码在运行时添加片段
- en: The most straightforward option is embedding your fragmentinside a layout file;
    however, this does have one big drawback—when you add a fragment declaratively,
    the fragment is static and will remain on the host activity until it's destroyed.
    You *won't* be able to add or remove this fragment during the host activity's
    life cycle.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是将你的片段嵌入到布局文件中；然而，这确实有一个很大的缺点——当你声明性地添加片段时，片段是静态的，将一直保留在宿主活动上，直到它被销毁。你*无法*在宿主活动的生命周期中添加或删除此片段。
- en: Adding a fragment to an activity via your application code gives you more freedom
    and flexibility, but it is more difficult to implement a fragment programmatically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用程序代码向活动添加片段提供了更多的自由和灵活性，但以编程方式实现片段会更困难。
- en: Since it's the most straightforward approach, let's start by looking at how
    to add a fragment via your layout resource file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是最直接的方法，让我们先看看如何通过你的布局资源文件添加片段。
- en: Adding a fragment to your activity declaratively
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明性地向你的活动添加片段
- en: 'You can add a fragment to an activity using `<fragment>` in the same way you
    declare a view:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与声明视图相同的方式使用`<fragment>`向活动添加片段：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, you can identify the fragment using `android:name`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`android:name`来识别片段：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When it's time to create this activity's layout, the system will instantiate
    the specified fragment, retrieve its layout, and then display it in place of the
    original `<fragment>` tags.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建此活动的布局时，系统将实例化指定的片段，检索其布局，然后将其显示在原始`<fragment>`标签的位置。
- en: Adding a fragment to an activity at runtime
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时向活动添加片段
- en: If you want to add, remove, or replace your fragments during the life cycle
    of the host activity, things get a bit more complicated, as you'll need to place
    these fragments in your activity at runtime, which means delving into your application
    code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在宿主活动的生命周期中添加、删除或替换你的片段，事情会变得稍微复杂一些，因为你需要在运行时将这些片段放置在活动中，这意味着需要深入研究你的应用程序代码。
- en: 'In this example, we''ll be using the same `list_fragment.xml` file and the
    `ListFragment.java` class we created earlier. However, instead of the `<fragment>`
    placeholder, we''ll be using `FrameLayout`, a special container view that indicates
    where the fragment will eventually be displayed in the layout file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用相同的`list_fragment.xml`文件和之前创建的`ListFragment.java`类。然而，我们将使用`FrameLayout`而不是`<fragment>`占位符，这是一个特殊的容器视图，指示片段最终将在布局文件中显示的位置：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You then need to tell your activity to replace the `FrameLayout` container
    with your fragment at runtime:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要告诉你的活动在运行时用你的片段替换`FrameLayout`容器：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you add a fragment at runtime, you're free to add, remove, and replace
    this fragment as and when required. These changes are known as **fragment transactions**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在运行时添加片段时，你可以自由地根据需要添加、删除和替换此片段。这些更改被称为**片段事务**。
- en: Fragment transactions and the back stack
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 片段事务和返回栈
- en: Fragment transactions are changes you commit to an activity in response to user
    interaction.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 片段事务是对活动做出的响应用户交互的更改。
- en: Whenever you perform a fragment transaction, you have the option to save this
    transaction to the back stack. If you do add a transaction to the back stack,
    the user can navigate back to this fragment state by pressing the device's physical
    *back* button or the softkey.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您执行片段事务时，您都有选择将此事务保存到回退栈中的选项。如果您确实将事务添加到回退栈，用户可以通过按设备的物理 *返回* 按钮或软键来导航回此片段状态。
- en: If you perform a transaction that removes or replaces a fragment and *doesn't*
    add the transaction to the back stack, when you commit that transaction, the fragment
    is destroyed and the user can't navigate back to it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行的事务移除或替换了一个片段，并且**没有**将事务添加到回退栈，当您提交该事务时，该片段将被销毁，用户无法导航回它。
- en: If you want the option to add a fragment transaction to the back stack, make
    sure you add the fragment to the host activity during that activity's `onCreate()`
    method. You can then add the fragment to the back stack by calling `transaction.addToBackStack`
    before you commit a transaction that'll remove the fragment.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要将片段事务添加到回退栈中，请确保在活动 `onCreate()` 方法期间将片段添加到宿主活动中。然后，在提交将移除片段的事务之前，您可以通过调用
    `transaction.addToBackStack` 来将片段添加到回退栈。
- en: 'In the next section, you''ll learn how to add, remove, and replace fragments.
    Regardless of the kind of fragmenttransaction you''re performing, you''ll need
    to get an instance of `FragmentTransaction` from the `FragmentManager` class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何添加、移除和替换片段。无论您执行的是哪种片段事务，您都需要从 `FragmentManager` 类获取 `FragmentTransaction`
    实例：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can then perform the following fragment transactions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以执行以下片段事务。
- en: Adding a fragment
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加片段
- en: You can add a fragment to an activity using the `add()` method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `add()` 方法将片段添加到活动中。
- en: 'Pass the `add()` method to `ViewGroup` where you want to place the fragment,
    identify the fragment you want to add, and then commit the transaction. For example,
    take a look here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `add()` 方法传递给您想要放置片段的 `ViewGroup`，识别您想要添加的片段，然后提交事务。例如，看看这里：
- en: '[PRE26]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Removing a fragment
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除片段
- en: To remove a fragment from an activity, you need to use the `remove()` method.
    This method takes a reference to the fragment instance you want to remove, plus
    the aforementioned `commit()` method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要从活动中移除一个片段，您需要使用 `remove()` 方法。此方法需要一个引用到您想要移除的片段实例，以及前面提到的 `commit()` 方法。
- en: 'In this example, we''re removing a fragment called `previousFragment`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在移除一个名为 `previousFragment` 的片段：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Replacing a fragment
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 替换片段
- en: To replace one fragment with another fragment at runtime, you need to call the
    `replace()` method of the fragmenttransaction instance.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时用一个片段替换另一个片段，您需要调用片段事务实例的 `replace()` 方法。
- en: 'The following example shows you how to replace one fragment with another fragment
    (`newFragment`) so that the user has the option to navigate back to the previous
    fragment. We''ll also add the replaced fragment to the back stack:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何用一个片段替换另一个片段（`newFragment`），以便用户可以选择导航回上一个片段。我们还将替换的片段添加到回退栈中：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you add multiple changes to the transaction and then call `addToBackStack()`,
    all changes applied *before* you called `commit()` are added to the back stack
    as a single transaction.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在事务中添加了多个更改，然后调用 `addToBackStack()`，则在您调用 `commit()` 之前应用的所有更改都将作为一个单独的事务添加到回退栈中。
- en: The multi-window support in Android N
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android N 中的多窗口支持
- en: Beginning with Android N, the Android operating system supports multi-window
    natively on both tablets and smartphones.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android N 开始，Android 操作系统在平板电脑和智能手机上都原生支持多窗口。
- en: This new multi-window mode gives users the option to display more than one app
    at a time in a split-screen environment, either side-by-side or arranged one above
    the other. The user can resize these split-screen apps by dragging the dividing
    line that separates them, making one app larger and the other one smaller.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的多窗口模式为用户提供了在分屏环境中同时显示多个应用的选择，可以是并排排列或上下排列。用户可以通过拖动分隔线来调整这些分屏应用的大小，使一个应用更大，另一个应用更小。
- en: Giving users the ability to view multiple apps simultaneously is good news for
    productivity, paving the way for multi-app multitasking, such as bringing up a
    restaurant's address in Google Chrome and then typing the address directly into
    Google Maps, or replying to an incoming SMS without having to abandon the video
    you were watching on YouTube.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 给用户同时查看多个应用的能力对生产力是个好消息，为多应用多任务处理铺平了道路，例如在Google Chrome中打开餐厅的地址，然后直接将地址输入到Google
    Maps中，或者在观看YouTube视频时无需放弃回复即将到来的短信。
- en: Another major benefit of the multi-window support is that users can drag data
    from one activity and drop it into another activity directly, whenever these activities
    are sharing the same screen. Since this direct drag and drop can come in handy
    for all sorts of everyday tasks, if your app doesn't already support drag and
    drop, then you should enable it for Android N.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 多窗口支持的另一个主要好处是，用户可以直接从一项活动拖动数据并将其放入另一项活动中，只要这些活动共享同一屏幕。由于这种直接拖放对于各种日常任务都很有用，如果你的应用尚未支持拖放，那么你应该为Android
    N启用它。
- en: How does the multi-window mode work?
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多窗口模式是如何工作的？
- en: 'Android smartphone and tablet users can switch to multi-window mode in the
    following ways:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓智能手机和平板电脑用户可以通过以下方式切换到多窗口模式：
- en: This can happen by opening the Overview screen (also known as the **recent apps
    screen** or **task list**) and long pressing an activity title. The user can then
    drag the activity to a highlighted portion of the screen to open that activity
    in the multi-window mode.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也可以通过打开概览屏幕（也称为**最近应用屏幕**或**任务列表**）并长按活动标题来实现。然后用户可以将活动拖动到屏幕的高亮部分以在多窗口模式下打开该活动。
- en: This can happen by opening the activity they want to view in the multi-window
    mode and then pressing the **Overview** button. The device will then put the current
    activity in multi-window mode and open the Overview screen ready for the user
    to select another activity to share the screen.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可以通过打开他们想要在多窗口模式下查看的活动，然后按下**概览**按钮来实现。然后设备将当前活动置于多窗口模式，并打开概览屏幕，以便用户选择另一个活动来共享屏幕。
- en: In the multi-window mode, only one activity is active at any given time; that's
    the activity the user has most recently interacted with, also known as the topmost
    activity. All other activities are placed in a paused state even though they're
    still visible to the user. This means that certain activities may need to continue
    running even when they're paused; for example, video-playing activities should
    continue playing video content even when they're not the topmost activity.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在多窗口模式下，任何给定时间只有一个活动是活跃的；这是用户最近与之交互的活动，也称为最顶层活动。所有其他活动都处于暂停状态，尽管它们对用户仍然可见。这意味着某些活动即使在暂停时可能也需要继续运行；例如，视频播放活动即使在它们不是最顶层活动时也应该继续播放视频内容。
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're developing a video-playing app, the solution is to pause the video
    in `onStop` and resume playback in `onStart`, rather than in your app's `onPause`
    handlers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个视频播放应用，解决方案是在`onStop`中暂停视频，并在`onStart`中恢复播放，而不是在你的应用`onPause`处理程序中。
- en: When the user interacts with a paused activity, the activity is resumed and
    it's the *other* app's turn to be placed in a paused state.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与暂停的活动交互时，该活动将被恢复，而**其他**应用则被置于暂停状态。
- en: Getting your app ready for multi-window mode
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为多窗口模式准备你的应用
- en: If your app targets Android N or higher and you *don't* specify whether your
    app supports multi-window mode, the Android system assumes that your app does
    include multi-window support.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用针对Android N或更高版本，并且**没有**指定你的应用是否支持多窗口模式，Android系统会假设你的应用包含多窗口支持。
- en: 'However, it''s good practice to explicitly state whether your app or activity
    supports multi-window mode by adding the new `android:resizeableActivity` attribute
    to the `<activity>` or `<application>` sections of your project''s `Manifest`
    file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，明确指出你的应用或活动是否支持多窗口模式，通过将新的`android:resizeableActivity`属性添加到项目`Manifest`文件的`<activity>`或`<application>`部分是一个好的做法：
- en: '`android:resizeableActivity="true."`: This app or activity can be launched
    in multi-window mode on phones and tablets.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:resizeableActivity="true."`：此应用或活动可以在手机和平板电脑上以多窗口模式启动。'
- en: '`android:resizeableActivity="false."`: This app or activity cannot be launched
    in multi-window mode. If the user attempts to launch this activity in multi-window
    mode, the app will take over the entire screen instead. If you want to ensure
    that the system only ever displays your app in full-screen mode, you''ll need
    to use `android:resizeableActivity="false"` to *explicitly* disable multi-window
    support.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:resizeableActivity="false."`：此应用或活动不能以多窗口模式启动。如果用户尝试以多窗口模式启动此活动，应用将接管整个屏幕。如果您想确保系统始终以全屏模式显示您的应用，您需要使用`android:resizeableActivity="false"`来**明确**禁用多窗口支持。'
- en: You can also set minimum allowable dimensions so that users cannot shrink your
    UI further than a specified size; you can do so using the `android:minimalSize`
    attribute. If the user tries to resize the activity so it's smaller than `android:minimalSize`,
    the system crops the activity to the size the user requests instead of shrinking
    your content.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以设置最小允许尺寸，以便用户无法将您的UI缩小到指定的尺寸；您可以使用`android:minimalSize`属性这样做。如果用户尝试调整活动的大小，使其小于`android:minimalSize`，系统将裁剪活动到用户请求的大小，而不是缩小您的内容。
- en: 'Since your app may need to behave differently when it''s in multi-window mode,
    Android N extends the `Activity` class so you can query an activity to find out
    whether it''s in multi-window mode:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用在多窗口模式下可能需要以不同的方式行为，Android N扩展了`Activity`类，以便您可以查询活动以确定它是否处于多窗口模式：
- en: '`Activity.inMultiWindow`: This is called to find out whether the current activity
    is in multi-window mode. The `Fragment` version of this method is `Fragment.inMultiWindow`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity.inMultiWindow`：此方法用于确定当前活动是否处于多窗口模式。此方法的`Fragment`版本是`Fragment.inMultiWindow`。'
- en: '`Activity.onMultiWindowChanged`: This is called whenever the activity switches
    into or out of multi-window mode. The fragment version of this method is `Fragment.onMultiWindowChanged`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity.onMultiWindowChanged`：每当活动切换到或退出多窗口模式时，都会调用此方法。此方法的片段版本是`Fragment.onMultiWindowChanged`。'
- en: Testing your app's multi-window support
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试您的应用的多窗口支持
- en: If your app targets Android N or higher and you *haven't* explicitly disabled
    multi-window support, then you'll need to test your app in multi-window mode to
    ensure you're providing the best possible user experience.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用针对Android N或更高版本，并且您**没有**明确禁用多窗口支持，那么您需要以多窗口模式测试您的应用，以确保您提供了最佳的用户体验。
- en: 'In particular, you should check the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，您应该检查以下内容：
- en: '*Your app switches between full-screen and multi-window mode smoothly*. Launch
    your app in a full-screen mode, and then switch to multi-window mode. Check that
    this action happens quickly, smoothly, and doesn''t cause your app to lag.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您的应用在全屏和多窗口模式之间平滑切换**。以全屏模式启动您的应用，然后切换到多窗口模式。检查此操作是否快速、平滑，并且不会导致您的应用延迟。'
- en: '*Your app resizes properly in multi-window mode*. Launch your app in multi-window
    mode, open another app, and then drag the divider line to test your app across
    a range of sizes. In particular, check that all UI elements remain visible and
    reachable, check that touch targets never shrink to the point where they become
    difficult to interact with, and check that your app''s text remains readable.
    Test how your app handles resizing when it''s sharing space with another app in
    both side-by-side and one-above-the-other configurations. You should also check
    that performing multiple resizing operations in quick succession doesn''t result
    in lag or cause your app to crash.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您的应用在多窗口模式下正确调整大小**。以多窗口模式启动您的应用，打开另一个应用，然后拖动分隔线以测试您的应用在不同尺寸下的表现。特别是，检查所有UI元素是否保持可见和可访问，检查触摸目标是否不会缩小到难以交互的程度，并检查您的应用文本是否可读。测试您的应用在与其他应用共享空间时，在并排和一上一下配置下的调整大小处理方式。您还应该检查连续执行多次调整大小操作不会导致延迟或使您的应用崩溃。'
- en: '*The system respects your app''s minimum dimensions*. If you have specified
    a minimum dimension, check that the system will prevent users from shrinking your
    app beyond this `android:minimalSize` value, by dragging the divider line.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统尊重您的应用的最小尺寸**。如果您已指定最小尺寸，请检查系统是否会通过拖动分隔线防止用户将您的应用缩小到`android:minimalSize`值以下。'
- en: '*Your app behaves as expected when it''s visible but not active*. For example,
    if you''ve developed a video-playing app, you should verify that your app continues
    to play video as expected when it''s not the topmost activity.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您的应用在可见但非活动状态下的行为符合预期**。例如，如果您开发了一个视频播放应用，您应该验证当它不是最顶层活动时，您的应用是否继续按预期播放视频。'
- en: If you explicitly disable multi-window support (by including `android:resizableActivity="false"`
    in `Manifest`), then you should also install your app on an Android N device and
    verify that it's not possible to view your app in multi-window mode.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你明确禁用了多窗口支持（通过在`Manifest`中包含`android:resizableActivity="false"`），那么你也应该在Android
    N设备上安装你的应用，并验证是否无法以多窗口模式查看你的应用。
- en: Picture-by-picture mode
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐帧模式
- en: Android N doesn't restrict the multitasking fun to smartphones and tablets!
    Android 7.0 also introduces a multitasking feature especially for Android TV users.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Android N并没有将多任务功能限制在智能手机和平板电脑上！Android 7.0还引入了专为Android TV用户设计的多任务功能。
- en: This new **picture-in-picture** (**PIP**) mode gives Android TV users the ability
    to watch a pinned window in a corner of the screen, while another activity runs
    in the background. The user can then toggle between the PIP window and the full-screen
    mode. If the user tries to play another video on the main screen, the PIP window
    will automatically close.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的**画中画**（**PIP**）模式为Android TV用户提供了在屏幕角落观看固定窗口的能力，同时另一个活动在后台运行。用户可以在这两个模式之间切换。如果用户尝试在主屏幕上播放另一个视频，PIP窗口将自动关闭。
- en: To use this feature in your Android TV apps, you need to register your app's
    video activity by adding `android:resizeableActivity="true"` and `android:supportsPictureInPictur="true"`
    to `Manifest`. You can then decide what events trigger the PIP mode in your app
    by calling `getActivity().enterPictureInPicture`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的Android TV应用中使用此功能，你需要通过在`Manifest`中添加`android:resizeableActivity="true"`和`android:supportsPictureInPictur="true"`来注册你的应用的视频活动。然后，你可以通过调用`getActivity().enterPictureInPicture`来决定触发你的应用中PIP模式的事件。
- en: 'When your activity switches to PIP, the system considers the activity to be
    in a paused state and calls your activity''s `onPause` method. However, the whole
    point of PIP is that your app continues to play video in the corner of the screen.
    Therefore, it''s crucial that your app checks whether an activity is paused because
    it''s in the PIP mode. If it is, your app will continue to play its video content:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的活动切换到PIP时，系统认为活动处于暂停状态，并调用你的活动的`onPause`方法。然而，PIP的整个目的就是你的应用继续在屏幕角落播放视频。因此，确保你的应用检查活动是否因为处于PIP模式而暂停是至关重要的。如果是，你的应用将继续播放其视频内容：
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Bear in mind that in PIP mode, your video content is displayed in a small overlay
    window. This means users won't be able to clearly see small details or interact
    with any UI elements. So, if your video activity features either of these, you
    should remove them when your activity enters PIP. You can then restore these UI
    elements when your activity switches back to the full-screen mode.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在PIP模式下，你的视频内容在一个小的叠加窗口中显示。这意味着用户无法清楚地看到小细节或与任何UI元素交互。因此，如果你的视频活动具有这些功能之一，你应该在活动进入PIP时移除它们。然后，当你的活动切换回全屏模式时，你可以恢复这些UI元素。
- en: 'For example, look at this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看这个：
- en: '[PRE30]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to take a basic UI to the next level using arrays,
    dimensions, 9-patch images, and color state lists. We also looked at how to create
    a more flexible user interface by incorporating fragments and multi-window mode
    into your design.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用数组、维度、9-patch图像和颜色状态列表将基本UI提升到下一个层次。我们还探讨了如何通过将片段和多窗口模式纳入你的设计来创建一个更灵活的用户界面。
- en: Now that we've spent a few chapters looking at the mechanics of how to build
    an effective UI, it's time to switch things up a bit and look at the *theory*
    behind creating a great Android user interface.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花费了几章来探讨构建有效UI的机制，现在是时候转换一下思路，看看创建出色的Android用户界面的*理论*了。
- en: There's no shortage of best practices and guidelines that have come and gone
    with the different versions of the Android platform, but in version 5.0, the Android
    team announced a completely new direction for the Android UI.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Android平台不同版本的推出，已经出现并消失了大量的最佳实践和指南，但在5.0版本中，Android团队宣布了Android UI的全新方向。
- en: It's called Material Design, and it's the subject of our next chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为Material Design，这是我们下一章的主题。
