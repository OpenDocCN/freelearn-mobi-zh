- en: Chapter 3. Expanding your UI – Fragments, Resources, and Gathering User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we concentrated on creating a strong foundation for
    your app's user interface. In this chapter, we'll build on these foundations using
    additional resources, such as arrays, dimensions, and 9-patch images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve perfected the *appearance* of your UI, we''ll explore how to make
    the UI react to user input, before taking a look at one UI component that can
    help us make the most out of devices with larger screens: *fragments*. And since
    fragments aren''t the *only* way to take advantage of the extra screen space,
    we''ll also take a look at the multi-window and picture-in-picture modes coming
    up in Android N.'
  prefs: []
  type: TYPE_NORMAL
- en: More resource types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your app features any text, then as a general rule, the text belongs in your
    project's `res/strings.xml` file as a string resource and *not* in your application
    code. Although we've touched on string resources in the previous chapter, they're
    such an integral part of the vast majority of Android applications that it makes
    sense to look at them in more detail, particularly in regards to some of the more
    complex tasks you can perform with string resources, such as creating string arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and styling string resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string is a simple resource that you define once in your project's `res/values/strings.xml`
    file, and then use it multiple times throughout your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You define string resources using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You also have the option to add style attributes to your string resources,
    so every time you use the string resource in your application, it has exactly
    the same styling. Android supports the following HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<b>` for bold text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<i>` for italic text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<u>` for underlined text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap your chosen HTML markup around the text you want to style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you''ll typically reference string resources from your application''s
    layout resource files, you can also reference a string via your Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating string arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A string array is exactly what it sounds like: an array of string resources.'
  prefs: []
  type: TYPE_NORMAL
- en: String arrays are useful when you have multiple related strings that always
    appear together, such as a list of options in a recurring menu.
  prefs: []
  type: TYPE_NORMAL
- en: While you *could* define every item as a separate string resource and then reference
    each string individually, this is pretty time consuming, plus you'll need to remember
    a long list of different string IDs! It usually makes more sense to add all your
    string resources to a single array, so you can display all these strings just
    by referencing a single string array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You typically create string arrays in a dedicated `res/values/arrays.xml` file.
    For example, the following XML defines a string array called **ingredients** that
    consists of five string resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To load this string array, use the `getStringArray()` method of the `Resources`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: String arrays are also useful for rapidly populating spinner controls. Assuming
    the spinner control's options are static and predetermined, you can define all
    these options in a string array and then load the array inside the spinner control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **spinner** is a UI element where the user selects one value from a list of
    options. When the user touches the spinner control, a drop down appears displaying
    all the available options. The user can then select an option from the list, and
    the spinner control then displays this selected option in its default, unopened
    state.
  prefs: []
  type: TYPE_NORMAL
- en: To populate a spinner using a string array, add the spinner control to your
    activity's layout resource file, and then reference the array using `android:entries:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Defining dimensions in dimens.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android supports several different units of measurement that you can hardcode
    into your project using XML or Java, such as `android:textSize="20sp"`. However,
    you can also define the dimensions you want to use in advance in your project''s
    `res/values/dimens.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can set the size of your UI components by referencing the corresponding
    value within your `dimens.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also apply values from your `dimens.xml` file using Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But why go to the extra effort of using the `dimens.xml` file, when you can
    just add dimension information to your layout directly?
  prefs: []
  type: TYPE_NORMAL
- en: Though this may seem like the quickest option, it isn't good practice to mix
    your dimensions with your layout and application code. Similar to string resources,
    the `dimens.xml` file provides a single, dedicated place where you can change
    your project's dimensions *without* having to touch the rest of your code. It
    also helps you create a consistent user interface, as it encourages you to define
    a set of values once and then use these same values throughout your app.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you can use multiple `dimens.xml` files to create a more flexible
    user interface. Using the `dimens.xml` files in this way does require a bit of
    prep work, as you'll need to create multiple `res/values` folders that target
    Android's different generalized densities. In the same way you, create multiple
    `drawable` folders to manage your project's images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your project''s `res` folder and create the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`values-ldpi`: Targets 120dpi devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values-mdpi`: Targets 60dpi devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values-hdpi`: Targets 240dpi devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values-xhdpi`: Targets 320dpi devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values-xxhdpi`: Targets 480dpi devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, create a `dimens.xml` file inside each folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining dimensions in dimens.xml](img/B05061_3_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This may seem like a lot of work, but once you have this structure in place,
    you can use your `dimens`. files to define the sets of values that are optimized
    for each screen density category. Then, when the Android system loads your layout,
    it'll select the most appropriate `dimens.xml` file for the current screen configuration
    and apply the file's dimensions to your layout.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the example code files for this book from your account at
    [http://www.packtpub.com](http://www.packtpub.com). If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. You can download the
    code files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in or register to our website using your e-mail address and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Code Downloads & Errata**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of the book in the **Search** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the book for which you're looking to download the code files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose from the drop-down menu where you purchased this book from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Code Download**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also download the code files by clicking on the **Code Files** button
    on the book's webpage at the Packt Publishing website. This page can be accessed
    by entering the book's name in the **Search** box. Please note that you need to
    be logged in to your Packt account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR / 7-Zip for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipeg / iZip / UnRarX for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7-Zip / PeaZip for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color state lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each time the user interacts with a UI element, your app will signal that it''s
    registered this interaction. Sometimes, this signal will be built-in: a new screen
    loads up, a pop up opens, or a *tick* appears in a checkbox. However, if it isn''t
    immediately obvious that a UI element has registered the user''s input, you should
    give them a visual clue. One possible method is to use the **color state list**.'
  prefs: []
  type: TYPE_NORMAL
- en: A color state list defines a series of states and assigns a color to each of
    these states. When you apply a color state list to a view, the view displays different
    colors from the list based on its current state.
  prefs: []
  type: TYPE_NORMAL
- en: Color state lists are most commonly applied to buttons. For example, a grey
    button may briefly turn a darker shade of grey when it's in a depressed state,
    leaving the user in no doubt about whether the button has registered their interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Color state lists are similar to the state list resources that we looked at
    in the previous chapter—we're just signaling changes of state using colors rather
    than images.
  prefs: []
  type: TYPE_NORMAL
- en: To create a color state list, open your project's `res/drawable` folder and
    create a new XML file; give the file a name that indicates its purpose, such as
    `res/drawable/button_background.xml`. Then, fill this file with all the different
    states that you want to trigger a color change and the colors you'd like to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The potential states include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:state_pressed="true/false."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:state_focused="true/false."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:state_selected="true/false."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:state_checkable="true/false."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:state_checked="true/false."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:state_enabled="true/false."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:state_window_focused= "true/false."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we''re going to add two states to a color state list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order you place your `<item>` element within the selector element is crucial,
    as the system works its way through the color state list in order and selects
    the first item that applies to the view's current state. As you saw in the preceding
    example, you can create a default color that'll be applied to the view when none
    of the other states are applicable. If you create a default state, then you must
    *always* place it at the very end of the color state list as a final resort.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is apply the color state list resource to your view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can also refer to your color state list resource in Java using `R.drawable.button_text`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with 9-patch images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A 9-patch graphic is a stretchable bitmap that allows you to define which areas
    the system can and can't stretch when it needs to resize your image to fit the
    current screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you convert a regular image into a 9-patch image, you add an extra 1-pixel-wide
    border around your image''s top and left areas. This 1-pixel border pinpoints
    exactly which pixels the system should replicate if it needs to create a stretched
    effect rather than simply resizing the entire image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with 9-patch images](img/B05061_3_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your border doesn't have to be a continuous line; if there's any area you don't
    want the system to stretch, just leave the area as a gap in your border. In the
    previous example, the system can stretch the drawable horizontally and vertically
    by replicating the pixels marked with the black line. However, the corners aren't
    marked, so these will remain the same size, creating a sharper, more defined corner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting an image into 9-patch format adds an extra pixel to your image's
    perimeter. Keep this in mind when you're creating images with the intention of
    converting them into 9-patches!
  prefs: []
  type: TYPE_NORMAL
- en: Although your image can include multiple stretchable sections, your lines must
    be exactly 1 pixel wide for the Android system to correctly recognize these lines;
    stretch your image accordingly (if appropriate), and then remove the lines from
    the finished image. If you add any lines that are thicker than one pixel, the
    system will treat these lines as just another part of your image.
  prefs: []
  type: TYPE_NORMAL
- en: If you do use 9-patches, you still need to provide alternate versions of these
    images for each of Android's generalized screen densities (`ldpi`, `mdpi`, `hdpi`,
    `xhdpi`, and `xxhdpi`). When the system loads your app, it'll select the 9-patch
    image that's the best fit for the current screen density, and then it will stretch
    the image's *stretchable* sections if required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 9-patch images can stretch, but they can't shrink. For the best results when
    creating 9-patch images that target the different density folders, you should
    target the lowest common resolution for each density category.
  prefs: []
  type: TYPE_NORMAL
- en: How do I create 9-patch images?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots of different PNG editors out there, but I'll be using Draw 9-patch
    as this editor is included in the Android SDK, so chances are you already have
    it installed on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find the `Draw9patch.bat` program in your computer's `sdk/tools` folder.
    Launch the editor and import your image by dragging it into the Draw 9-patch window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 9-patch workspace consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Left pane**: This is the drawing area where you define your image''s stretchable
    sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right pane**: This is the preview area, which displays a preview of how your
    graphic will appear when stretched. As you''re editing your image in the left
    pane, make sure you keep an eye on this preview.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How do I create 9-patch images?](img/B05061_3_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To define the area that can be stretched horizontally, draw a line along the
    top of your image by clicking. Every time you click, a new pixel will be added
    to your line.
  prefs: []
  type: TYPE_NORMAL
- en: '![How do I create 9-patch images?](img/B05061_3_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you make a mistake, you can remove pixels by holding the ***Shift*** key
    while clicking each pixel you want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: To define the area that can be stretched vertically, click to draw a line along
    your image's left edge.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're happy with the results, save your 9-patch image by selecting **File**
    | **Save 9-patch**. This saves your image with the `.9.png` extension. You can
    then add this graphical resource to your project as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're not a fan of Draw 9-patch, or you just want to try an alternative,
    there are several free online tools that you can use to create 9-patch images,
    including [http://draw9patch.com/](http://draw9patch.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Registering the user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input controls are your UI's interactive components, such as buttons, `EditText`
    fields, and checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: We've already seen how you can drop input controls into your UI, but input controls
    don't register user input out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: To turn UI components, such as buttons and `EditText` fields, into fully-functioning
    interactive components, you'll need to write some extra code.
  prefs: []
  type: TYPE_NORMAL
- en: Handling click events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Click events are one of the most common input events your UI will have to handle.
    A click event is simply where the user touches an onscreen element, such as tapping
    a button or a checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: A button cannot process clicks on its own; you'll need to create a listener
    and then assign it to the button. When the user taps the button, the listener
    registers the tap and executes the code from your `onClick` method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that your layout contains a single button, and you want that button
    to register click events. As with many things in Android, you can create the same
    effect via XML or via your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Handling onClick Via Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's how you can handle these events using `Java`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Handling onClick Via XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create the same functionality via your layout resource file by adding
    the `android:onClick` attribute to your view, and then adding the `onClick` method
    to the corresponding Java file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the user clicks this button, the `buttonClicked` method will be executed,
    so the next step is to add this method to your Java file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Registering the EditText input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you drop `EditText` into your UI, the user can type text into the field,
    but by default, `EditText` cannot read or use this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `EditText` to acquire user input, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a reference to the `EditText` field using `findViewById`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the text from the `EditText` field using `getText()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may then want to display this text elsewhere in your UI using `setText()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to register click events and retrieve the user input from
    `EditText`, let's look at an example app that combines all this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The example app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll create a simple app that asks users to enter their name into `EditText`
    and then tap a **Submit** button. The app will then retrieve the user's name from
    the `EditText` field and display it in `TextView` as the part of a welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple layout that contains these three onscreen elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `res/values/strings.xml` and create your string resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![The example app](img/B05061_3_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have your UI, it's time to give these on-screen elements the ability
    to register and process the user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create an event listener and assign it to our `submitButton`.
    When the user taps the **Submit** button, the app registers this interaction and
    retrieves whatever text is currently in the `EditText` field. It then sets this
    value to `TextView`, replacing the default **Please complete the form below**
    text with the `EditText` value, plus two other bits of text, to create our complete
    welcome message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is it—boot up your app and try interacting with the different UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![The example app](img/B05061_3_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're developing your UI for pre-Android N devices, one of the major restrictions
    you'll encounter is that you can only ever display a single activity on the screen
    at any one time. Fragments give you a way to overcome this restriction; although
    *technically* you can still only display one activity at a time; each activity
    can consist of multiple fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android N introduced multi-window mode, which gives users the ability to display
    more than one app at a time, allowing them to see multiple activities at once,
    albeit from different applications! We'll take a closer look at multi-window mode
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A fragment is a self-contained, modular section of your app's user interface
    that you embed inside an activity. You *cannot* instantiate a fragment as a standalone
    application element. Think of a fragment as a kind of *sub activity* that has
    its own life cycle, behavior, and (usually) its own user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need fragments?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android team introduced fragments in Android version 3.0, also known as
    **Honeycomb**, mainly to help developers make better use of all the extra screen
    space available on larger devices, such as tablets. Using fragments, you can divide
    each activity into distinct components and then control each part separately.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create multiple layouts that combine your project's fragments in
    different ways depending on the current screen configuration. For example, you
    could create a multi pane layout that combines multiple fragments in a single
    activity; and you could create a single pane layout that displays each fragment
    separately, which is better suited to smaller screens. Your app can then select
    the most appropriate layout (multi pane or single pane) depending on the current
    device.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, fragments are useful for making the most out of devices with larger
    screens, while also providing a good user experience for users viewing your app
    on smaller screens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may also want to use fragments to create layouts that are optimized for
    devices held in landscape and portrait orientation. For example, you can create
    a layout for landscape devices that displays multiple fragments in a side-by-side
    configuration, and you can create a single-pane layout that displays one fragment
    at a time when the device is in portrait mode.
  prefs: []
  type: TYPE_NORMAL
- en: The final major benefit of using fragments is that when a fragment's host activity
    is running, you can add, remove, and replace each fragment independently to create
    a truly dynamic user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an example of how an app that provides single-pane and
    multi-pane layouts may work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an activity (**Activity 1**) that contains two fragments: **Fragment
    A** and **Fragment B**. **Fragment A** displays a list of items. When the user
    selects an item in **Fragment A**, **Fragment B** updates to display information
    related to the selected item.'
  prefs: []
  type: TYPE_NORMAL
- en: This app includes two different layouts, and it selects which layout to display
    based on the size of the device's screen. If the screen is large enough to accommodate
    both **Fragment A** and **Fragment B**, the app displays these fragments side-by-side
    in **Activity 1**, in a multi-pane layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![Why do we need fragments?](img/B05061_3_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If there isn't enough room to accommodate both fragments, the app will display
    each fragment separately, as different screens in a single-pane layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, **Activity 1** displays **Fragment A** *only*. When the user
    selects an item from **Fragment A**, the screen updates to display **Fragment
    B**. This means your app creates an entirely new activity (**Activity 2**) that
    exists simply to host **Fragment B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why do we need fragments?](img/B05061_3_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While fragments are important tools that can help you create more flexible layouts,
    fragments aren't a magical cure. Even if you do include fragments in your user
    interface, you'll still need to follow all the usual guidelines and best practices
    *in addition to using fragments*.
  prefs: []
  type: TYPE_NORMAL
- en: The fragment life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although a fragment has its own life cycle, the life cycle is directly affected
    by the life cycle of the host activity. Each life cycle callback for the host
    activity results in a similar callback for all its fragments; for example, when
    the host activity's `onStop()` method is called, all the fragments within the
    activity also receive a call to `onStop()`, and when the activity is destroyed,
    so are all its fragments.
  prefs: []
  type: TYPE_NORMAL
- en: You can only manipulate a fragment's life cycle independently while the host
    activity is in its resumed state. At this point, you can add, remove, and replace
    fragments. However, once the host activity leaves its resumed state, all its fragments
    lose their independence and are once again dependent on the host activity's life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like an activity, a fragment can exist in three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resumed**: The fragment is visible in the running activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paused**: Another activity is in the foreground and has focus, but the fragment''s
    host activity is still visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopped**: Either the host activity has been stopped, or the fragment has
    been removed from the activity and added to the back stack. A stopped fragment
    is still alive, but it''s no longer visible to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One major difference between the life cycle of an activity and the life cycle
    of a fragment is how you restore each one and get its state back:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity**: When an activity is stopped, it''s placed into a back stack of
    activities that''s managed by the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment**: When a fragment is stopped, it''s only placed into a back stack
    that''s managed by the host activity *if* you explicitly request that the instance
    should be saved. To make this request, call `addToBackStack()` during the transaction
    that removes the fragment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is the back stack? And why is it so important?**'
  prefs: []
  type: TYPE_NORMAL
- en: The back stack keeps track of all the actions the user can reverse by tapping
    the device's **Back** button, whether that's a physical back key or one of Android's
    illuminated soft keys. If you add a fragment to the back stack, then the user
    can backtrack to that fragment. If you don't add a fragment to the back stack,
    the user cannot recover that fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a fragment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, I''ll show you how to create a simple fragment. The first
    step is defining the fragment''s UI component:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your project's `res` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `layout` folder and select **New**, followed by **Layout resource
    file**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your layout resource file a descriptive name, such as `list_fragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Root Element** option you want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-check the **Directory name** option is set to **layout**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your new layout resource file and define your fragment''s UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Before we create the actual fragment, let's take a moment to look at the issue
    of backwards compatibility; specifically, how you can reap the benefits of fragments
    even on devices that run pre-Honeycomb versions of Android.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments and backwards compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you're developing an app, you should aim to support as many versions of
    Android as possible, as this will give you the widest potential audience. Since
    fragments didn't find their way into Android until version 3.0, if you want your
    app to be compatible with devices running anything earlier than Android Honeycomb,
    you'll need to add `v4` of **Android Support Library** to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Support Library is a handy set of code libraries that enable you to
    use features and APIs that wouldn't otherwise be available to the earlier versions
    of the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: Once you add the v4 library to your project, you can use fragments while remaining
    backwards compatible with devices running versions as low as Android 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: To add this library to your project, launch Android SDK Manager, open the `Extras`
    folder and download the **Android Support Library** (if you're using Eclipse)
    or **Android Support Repository** (if you're using Android Studio).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using Android Studio, add the library to your project by opening
    its module-level `build.gradle` file and adding the support library to the dependencies
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re developing in Eclipse, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `libs` directory in the root of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the support library called the JAR file in your Android SDK directory
    (for example, `<sdk>/extras/android/support/v4/android-support-v4.jar`). Copy
    this JAR into the `libs` directory you created in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the JAR file and select **Build Path**, followed by **Add to Build
    Path**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll also need to import the fragment class from the v4 support library (`import
    android.support.v4.app.Fragment`) and extend `FragmentActivity` instead of the
    usual `Activity` class (`public class ListFragment extends FragmentActivity`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no hard and fast rules about which versions of the Android system
    you should support, though you'll generally want to support as many versions as
    you feasibly can without compromising on your app's functionality. If you do decide
    against supporting the earlier versions of the Android platform, then you don't
    need to use the support library. If you're unsure, it may help you to look at
    Google's stats about the percentage of Android devices currently running each
    version of the Android platform, available at [http://developer.android.com/about/dashboards/index.html](http://developer.android.com/about/dashboards/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating your fragment class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to creating a layout, you need to have a class associated with your
    fragment. This class must extend `Fragment` or `FragmentActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new class to your project, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your `Java` folder and right-click on your project's package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New** followed by **Java Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your class a descriptive name, for example, `ListFragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your new `ListFragment` class; it will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll want to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inflate()` method (in the preceding code) takes the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The layout file that's being inflated (`R.layout.list_fragment`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent `ViewGroup` where the inflated fragment layout should be inserted
    (`container`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `false` Boolean that indicates the inflated layout should be attached to
    the `ViewGroup` during inflation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to add the fragment to your activity. You have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Embed the fragment in your activity's corresponding XML layout file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the fragment at runtime via your application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most straightforward option is embedding your fragmentinside a layout file;
    however, this does have one big drawback—when you add a fragment declaratively,
    the fragment is static and will remain on the host activity until it's destroyed.
    You *won't* be able to add or remove this fragment during the host activity's
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a fragment to an activity via your application code gives you more freedom
    and flexibility, but it is more difficult to implement a fragment programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Since it's the most straightforward approach, let's start by looking at how
    to add a fragment via your layout resource file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a fragment to your activity declaratively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add a fragment to an activity using `<fragment>` in the same way you
    declare a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can identify the fragment using `android:name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When it's time to create this activity's layout, the system will instantiate
    the specified fragment, retrieve its layout, and then display it in place of the
    original `<fragment>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a fragment to an activity at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to add, remove, or replace your fragments during the life cycle
    of the host activity, things get a bit more complicated, as you'll need to place
    these fragments in your activity at runtime, which means delving into your application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll be using the same `list_fragment.xml` file and the
    `ListFragment.java` class we created earlier. However, instead of the `<fragment>`
    placeholder, we''ll be using `FrameLayout`, a special container view that indicates
    where the fragment will eventually be displayed in the layout file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You then need to tell your activity to replace the `FrameLayout` container
    with your fragment at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you add a fragment at runtime, you're free to add, remove, and replace
    this fragment as and when required. These changes are known as **fragment transactions**.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment transactions and the back stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fragment transactions are changes you commit to an activity in response to user
    interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you perform a fragment transaction, you have the option to save this
    transaction to the back stack. If you do add a transaction to the back stack,
    the user can navigate back to this fragment state by pressing the device's physical
    *back* button or the softkey.
  prefs: []
  type: TYPE_NORMAL
- en: If you perform a transaction that removes or replaces a fragment and *doesn't*
    add the transaction to the back stack, when you commit that transaction, the fragment
    is destroyed and the user can't navigate back to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the option to add a fragment transaction to the back stack, make
    sure you add the fragment to the host activity during that activity's `onCreate()`
    method. You can then add the fragment to the back stack by calling `transaction.addToBackStack`
    before you commit a transaction that'll remove the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, you''ll learn how to add, remove, and replace fragments.
    Regardless of the kind of fragmenttransaction you''re performing, you''ll need
    to get an instance of `FragmentTransaction` from the `FragmentManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can then perform the following fragment transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a fragment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can add a fragment to an activity using the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the `add()` method to `ViewGroup` where you want to place the fragment,
    identify the fragment you want to add, and then commit the transaction. For example,
    take a look here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Removing a fragment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To remove a fragment from an activity, you need to use the `remove()` method.
    This method takes a reference to the fragment instance you want to remove, plus
    the aforementioned `commit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''re removing a fragment called `previousFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Replacing a fragment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To replace one fragment with another fragment at runtime, you need to call the
    `replace()` method of the fragmenttransaction instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to replace one fragment with another fragment
    (`newFragment`) so that the user has the option to navigate back to the previous
    fragment. We''ll also add the replaced fragment to the back stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you add multiple changes to the transaction and then call `addToBackStack()`,
    all changes applied *before* you called `commit()` are added to the back stack
    as a single transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-window support in Android N
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beginning with Android N, the Android operating system supports multi-window
    natively on both tablets and smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: This new multi-window mode gives users the option to display more than one app
    at a time in a split-screen environment, either side-by-side or arranged one above
    the other. The user can resize these split-screen apps by dragging the dividing
    line that separates them, making one app larger and the other one smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Giving users the ability to view multiple apps simultaneously is good news for
    productivity, paving the way for multi-app multitasking, such as bringing up a
    restaurant's address in Google Chrome and then typing the address directly into
    Google Maps, or replying to an incoming SMS without having to abandon the video
    you were watching on YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: Another major benefit of the multi-window support is that users can drag data
    from one activity and drop it into another activity directly, whenever these activities
    are sharing the same screen. Since this direct drag and drop can come in handy
    for all sorts of everyday tasks, if your app doesn't already support drag and
    drop, then you should enable it for Android N.
  prefs: []
  type: TYPE_NORMAL
- en: How does the multi-window mode work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android smartphone and tablet users can switch to multi-window mode in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: This can happen by opening the Overview screen (also known as the **recent apps
    screen** or **task list**) and long pressing an activity title. The user can then
    drag the activity to a highlighted portion of the screen to open that activity
    in the multi-window mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can happen by opening the activity they want to view in the multi-window
    mode and then pressing the **Overview** button. The device will then put the current
    activity in multi-window mode and open the Overview screen ready for the user
    to select another activity to share the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the multi-window mode, only one activity is active at any given time; that's
    the activity the user has most recently interacted with, also known as the topmost
    activity. All other activities are placed in a paused state even though they're
    still visible to the user. This means that certain activities may need to continue
    running even when they're paused; for example, video-playing activities should
    continue playing video content even when they're not the topmost activity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're developing a video-playing app, the solution is to pause the video
    in `onStop` and resume playback in `onStart`, rather than in your app's `onPause`
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: When the user interacts with a paused activity, the activity is resumed and
    it's the *other* app's turn to be placed in a paused state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting your app ready for multi-window mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your app targets Android N or higher and you *don't* specify whether your
    app supports multi-window mode, the Android system assumes that your app does
    include multi-window support.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s good practice to explicitly state whether your app or activity
    supports multi-window mode by adding the new `android:resizeableActivity` attribute
    to the `<activity>` or `<application>` sections of your project''s `Manifest`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:resizeableActivity="true."`: This app or activity can be launched
    in multi-window mode on phones and tablets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:resizeableActivity="false."`: This app or activity cannot be launched
    in multi-window mode. If the user attempts to launch this activity in multi-window
    mode, the app will take over the entire screen instead. If you want to ensure
    that the system only ever displays your app in full-screen mode, you''ll need
    to use `android:resizeableActivity="false"` to *explicitly* disable multi-window
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also set minimum allowable dimensions so that users cannot shrink your
    UI further than a specified size; you can do so using the `android:minimalSize`
    attribute. If the user tries to resize the activity so it's smaller than `android:minimalSize`,
    the system crops the activity to the size the user requests instead of shrinking
    your content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since your app may need to behave differently when it''s in multi-window mode,
    Android N extends the `Activity` class so you can query an activity to find out
    whether it''s in multi-window mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Activity.inMultiWindow`: This is called to find out whether the current activity
    is in multi-window mode. The `Fragment` version of this method is `Fragment.inMultiWindow`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Activity.onMultiWindowChanged`: This is called whenever the activity switches
    into or out of multi-window mode. The fragment version of this method is `Fragment.onMultiWindowChanged`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your app's multi-window support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your app targets Android N or higher and you *haven't* explicitly disabled
    multi-window support, then you'll need to test your app in multi-window mode to
    ensure you're providing the best possible user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, you should check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Your app switches between full-screen and multi-window mode smoothly*. Launch
    your app in a full-screen mode, and then switch to multi-window mode. Check that
    this action happens quickly, smoothly, and doesn''t cause your app to lag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your app resizes properly in multi-window mode*. Launch your app in multi-window
    mode, open another app, and then drag the divider line to test your app across
    a range of sizes. In particular, check that all UI elements remain visible and
    reachable, check that touch targets never shrink to the point where they become
    difficult to interact with, and check that your app''s text remains readable.
    Test how your app handles resizing when it''s sharing space with another app in
    both side-by-side and one-above-the-other configurations. You should also check
    that performing multiple resizing operations in quick succession doesn''t result
    in lag or cause your app to crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The system respects your app''s minimum dimensions*. If you have specified
    a minimum dimension, check that the system will prevent users from shrinking your
    app beyond this `android:minimalSize` value, by dragging the divider line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your app behaves as expected when it''s visible but not active*. For example,
    if you''ve developed a video-playing app, you should verify that your app continues
    to play video as expected when it''s not the topmost activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you explicitly disable multi-window support (by including `android:resizableActivity="false"`
    in `Manifest`), then you should also install your app on an Android N device and
    verify that it's not possible to view your app in multi-window mode.
  prefs: []
  type: TYPE_NORMAL
- en: Picture-by-picture mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android N doesn't restrict the multitasking fun to smartphones and tablets!
    Android 7.0 also introduces a multitasking feature especially for Android TV users.
  prefs: []
  type: TYPE_NORMAL
- en: This new **picture-in-picture** (**PIP**) mode gives Android TV users the ability
    to watch a pinned window in a corner of the screen, while another activity runs
    in the background. The user can then toggle between the PIP window and the full-screen
    mode. If the user tries to play another video on the main screen, the PIP window
    will automatically close.
  prefs: []
  type: TYPE_NORMAL
- en: To use this feature in your Android TV apps, you need to register your app's
    video activity by adding `android:resizeableActivity="true"` and `android:supportsPictureInPictur="true"`
    to `Manifest`. You can then decide what events trigger the PIP mode in your app
    by calling `getActivity().enterPictureInPicture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your activity switches to PIP, the system considers the activity to be
    in a paused state and calls your activity''s `onPause` method. However, the whole
    point of PIP is that your app continues to play video in the corner of the screen.
    Therefore, it''s crucial that your app checks whether an activity is paused because
    it''s in the PIP mode. If it is, your app will continue to play its video content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that in PIP mode, your video content is displayed in a small overlay
    window. This means users won't be able to clearly see small details or interact
    with any UI elements. So, if your video activity features either of these, you
    should remove them when your activity enters PIP. You can then restore these UI
    elements when your activity switches back to the full-screen mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to take a basic UI to the next level using arrays,
    dimensions, 9-patch images, and color state lists. We also looked at how to create
    a more flexible user interface by incorporating fragments and multi-window mode
    into your design.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've spent a few chapters looking at the mechanics of how to build
    an effective UI, it's time to switch things up a bit and look at the *theory*
    behind creating a great Android user interface.
  prefs: []
  type: TYPE_NORMAL
- en: There's no shortage of best practices and guidelines that have come and gone
    with the different versions of the Android platform, but in version 5.0, the Android
    team announced a completely new direction for the Android UI.
  prefs: []
  type: TYPE_NORMAL
- en: It's called Material Design, and it's the subject of our next chapter.
  prefs: []
  type: TYPE_NORMAL
