<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;3D Game Programming with OpenGL"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. 3D Game Programming with OpenGL</h1></div></div></div><p class="calibre8">In this chapter, we will focus on the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Introducing OpenGL</li><li class="listitem">Building a mini three-dimensional animation game using OpenGL</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;3D Game Programming with OpenGL">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec56" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">In the previous chapters, you learned about the anatomy of physics simulation in depth. Now, we will explore the most interesting part of the game, which is to add three-dimensional objects to your games. In this chapter, we will start exploring the basics of OpenGL. Then, step-by-step, we will explore OpenGL in depth by crafting some three-dimensional models. In this chapter, we will start learning by using the two-dimensional model project, and then we will enhance the project to accommodate three-dimensional models.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Introducing OpenGL"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec57" class="calibre1"/>Introducing OpenGL</h1></div></div></div><p class="calibre8">OpenGL stands<a id="id400" class="calibre1"/> for Open Graphics Library. This is a widely used library for visualizing two-dimensional and three-dimensional objects. This is a standard multipurpose two-dimensional and three-dimensional content creation graphics library. It is used in various streams, such as mechanical design, architectural design, gaming, prototyping, flight simulation, and many more. OpenGL is used to configure and submit three-dimensional graphics data to the device. All the data is prepared in the form of matrices and they are transformed to vertices, which are transformed and assembled to produce two-dimensional rasterized images. Two-dimensional graphics have two axes, which are x and y; however, in the case of three-dimensional graphics, we have three-dimensional axes, which are x, y, and z, where z is the depth.</p><p class="calibre8">This library is designed to compile normal function calls into graphical commands, which will get executed on the graphics rendering hardware. All the graphics hardware is designed to execute the graphics commands. OpenGL<a id="id401" class="calibre1"/> draws and renders views very fast.</p></div>

<div class="book" title="Introducing OpenGL">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec136" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Xcode provides a built-in OpenGL-ES project template; still, we think it will be confusing for beginners to start with that template. A typical approach is to write the code step-by-step, in order to understand how the code works and the functionality of each function.</p><p class="calibre8">Here, we will write all the code from scratch, which will help you to understand the nitty-gritty of each and every line of code written to render views using OpenGL. To add frameworks, perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start up Xcode. Make a single-view application and click on <span class="strong"><strong class="calibre2">Next</strong></span>. Name your project OpenGLSample, click on <span class="strong"><strong class="calibre2">Next</strong></span>, choose a folder to save it in, and click on <span class="strong"><strong class="calibre2">Create</strong></span>.</li><li class="listitem" value="2">Now, we will add all the required frameworks in the project. To add the frameworks, the first step is to add the two required frameworks for our OpenGL project. They are <code class="email">OpenGLES.frameworks</code> and <code class="email">GLKit.framework</code>.</li><li class="listitem" value="3">To add these frameworks in Xcode 6, click on your OpenGLSample project in the Groups &amp; Files tree, and select the <span class="strong"><strong class="calibre2">OpenGLSample</strong></span> target. Expand the <span class="strong"><strong class="calibre2">Link Binary with the Libraries</strong></span> section, click on the plus button, and select <span class="strong"><strong class="calibre2">OpenGLES.framework</strong></span>. Repeat for <span class="strong"><strong class="calibre2">GLKit.framework</strong></span> as well, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00157.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Introducing OpenGL">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec137" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">To create<a id="id402" class="calibre1"/> three-dimensional textures in our app, perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">Main.storyboard</code> file and select the view controller. You will see a view already added in the view controller.</li><li class="listitem" value="2">Select<a id="id403" class="calibre1"/> the view, open the Identity inspector, and set the view's class to <code class="email">GLKView</code>, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00158.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Open <code class="email">ViewController.h</code>, import <code class="email">GLKit</code>/<code class="email">GLKit.h</code>, and change the ViewController's parent class from <code class="email">UIViewController</code> to <code class="email">GLKViewController</code>. <code class="email">GLKViewController</code> provides the OpenGL render loop in addition to all <a id="id404" class="calibre1"/>native view controller functionalities. The code will be as follows:<div class="informalexample"><pre class="programlisting">#import"GLKit/GLKit.h"
@interface ViewController : GLKViewController</pre></div></li><li class="listitem" value="4">Modify <code class="email">viewController.m</code>. Add the following code to <code class="email">viewDidLoad</code>:<div class="informalexample"><pre class="programlisting">GLKView* view = (GLKView*)self.view;

    view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</pre></div></li><li class="listitem" value="5">Add the<a id="id405" class="calibre1"/> following methods:<div class="informalexample"><pre class="programlisting">(void)glkView:(GLKView *)view drawInRect:(CGRect)rect{
glClearColor(0.0, 0.5, 0.0, 1.0); glClear(GL_COLOR_BUFFER_BIT);
}</pre></div><p class="calibre15">The first line of the code calls <code class="email">glClearColor</code>, which effectively tells OpenGL that the clear color should be set to the RGBA value (0.0, 0.5, 0.0, 1.0)—that is, fully opaque, dark green. The next line instructs OpenGL to actually clear the color buffer—that is, it fills the entire screen with the clear color that was set on the previous line.</p></li><li class="listitem" value="6">Now, compile and run the project. You should see something similar to the following screenshot:<div class="mediaobject"><img src="../images/00159.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="7">Now, it's time <a id="id406" class="calibre1"/>to create OpenGL context. Drawing triangles in OpenGL is easier than drawing squares because triangles are always coplanar, that is, all of the points in the shape are on the same plane. So, to draw a square, we first draw two triangles that share an edge.</li><li class="listitem" value="8">To inform <a id="id407" class="calibre1"/>OpenGL about where the vertices are, we use a structure for vertices and for making an array. This will later show on <code class="email">GLView</code> as follows:<div class="informalexample"><pre class="programlisting">    typedef struct {
    GLKVector3 position;
    } Vertex;
    const Vertex SquareVertices[] = {
    {-1, -1 , 0},// vertex 0: bottom left 
    {1, -1 , 0}, // vertex 1: bottom right
    {1, 1 , 0}, // vertex 2: top right
    {-1, 1 , 0}, // vertex 4: top left
    };</pre></div></li><li class="listitem" value="9">Now we need to define which triangle uses which vertices. In OpenGL, we do this by numbering each vertex, and then describing triangles by giving OpenGL three numbers at a time:<div class="informalexample"><pre class="programlisting">   const GLubyte SquareTriangles[] = {
   0, 1, 2, // BL-&gt;BR-&gt;TR
   2, 3, 0 // TR-&gt;TL-&gt;BL
   };</pre></div><p class="calibre15">In this case, <code class="email">Glubyte</code> is the type in which the first triangle uses vertices <code class="email">0</code>, <code class="email">1</code>, and <code class="email">2</code>, and the second triangle uses vertices <code class="email">2</code>, <code class="email">3</code>, and <code class="email">0</code>. Note that both triangles use vertices <code class="email">0</code> and <code class="email">2</code>. This means that they share an edge, which means that there won't be any gap between the two triangles.</p></li><li class="listitem" value="10">Both<a id="id408" class="calibre1"/> the <code class="email">SquareVertices</code> and <code class="email">SquareTriangles</code> arrays need to <a id="id409" class="calibre1"/>be stored in a buffer so that OpenGL can use them for rendering as follows:<div class="informalexample"><pre class="programlisting">   @interface ViewController () {
   GLuint _vertexBuffer;
   GLuint _indexBuffer;
   GLKBaseEffect* _squareEffect;
   }
   @end</pre></div></li><li class="listitem" value="11">First, we set up the <code class="email">GLKView</code> with an OpenGL context, as shown in the following code. Because, if we don't do this, none of our OpenGL commands will do anything.<div class="informalexample"><pre class="programlisting">   GLKView* view = (GLKView*)self.view;
   view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
   [EAGLContext setCurrentContext:view.context];</pre></div></li><li class="listitem" value="12">Next, we create the buffers starting with the vertex buffer:<div class="informalexample"><pre class="programlisting">   glGenBuffers(1, &amp;_vertexBuffer);
   glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</pre></div></li><li class="listitem" value="13">The vertex buffer is then filled with the vertex information:<div class="informalexample"><pre class="programlisting">     glBufferData(GL_ARRAY_BUFFER, sizeof(SquareVertices),
     SquareVertices, GL_STATIC_DRAW);</pre></div></li><li class="listitem" value="14">The same thing is then done for the index buffer, which you'll recall stores information on which vertices the two triangles will use:<div class="informalexample"><pre class="programlisting">   glGenBuffers(1, &amp;_indexBuffer);
   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);
   glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(SquareTriangles), SquareTriangles, GL_STATIC_DRAW);</pre></div><p class="calibre15">Once this is done, all of the information has been passed to OpenGL. GLKit provide several effects, which are the objects that contain information such as color, position, orientation, and so on. In this activity, we will make one square to be red and to be present it in the middle of the screen.</p></li><li class="listitem" value="15">The first<a id="id410" class="calibre1"/> step<a id="id411" class="calibre1"/> is to create the effect object, and then provide it with a projection matrix. The projection matrix controls the overall sizes of things on the screen. In this case, we create a projection matrix that uses the aspect ratio of the screen and uses a 60 degrees field of view:<div class="informalexample"><pre class="programlisting">_squareEffect = [[GLKBaseEffect alloc] init];
float aspectRatio = self.view.bounds.size.width/self.view.bounds.size.height;
float fieldOfViewDegrees = 60.0;

GLKMatrix4 projectionMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(fieldOfViewDegrees),aspectRatio, 0.1, 10.0);
_squareEffect.transform.projectionMatrix = projectionMatrix;</pre></div></li><li class="listitem" value="16">Now, we need to provide a model view matrix. The model view matrix controls the position of the object, relative to the camera:<div class="informalexample"><pre class="programlisting">  GLKMatrix4 modelViewMatrix = GLKMatrix4MakeTranslation(0.0f,   0.0f, -6.0f);
  _squareEffect.transform.modelviewMatrix = modelViewMatrix;
//Set the constant color red for the effects.
  _squareEffect.useConstantColor = YES;
  _squareEffect.constantColor = GLKVector4Make(1.0, 0.0, 0.0, 1.0);</pre></div></li><li class="listitem" value="17">Create the <code class="email">drawInRect</code> method after the <code class="email">viewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">  - (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {
   }</pre></div></li><li class="listitem" value="18">The actual work of rendering is done in the <code class="email">glkView:drawInRect</code> method. The first thing that happens in this is that the view is cleared, by filling the screen with black:<div class="informalexample"><pre class="programlisting">   glClearColor(0.0, 0.0, 0.0, 1.0);
   glClear(GL_COLOR_BUFFER_BIT);</pre></div></li><li class="listitem" value="19">Now call <code class="email">prepareToDraw</code>. It configures OpenGL in such a way that anything we draw will use the effect's setting:<div class="informalexample"><pre class="programlisting">   [_squareEffect prepareToDraw];</pre></div></li><li class="listitem" value="20">We first<a id="id412" class="calibre1"/> tell OpenGL that we're going to be working with positions, and then tell OpenGL where to find the position information in the vertex data:<div class="informalexample"><pre class="programlisting">   glEnableVertexAttribArray(GLKVertexAttribPosition);
   glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, 0);</pre></div></li><li class="listitem" value="21">Finally, we <a id="id413" class="calibre1"/>need to know how many vertices we're asking OpenGL to draw. This can be figured out by taking the size of the entire index array, and dividing that by the size of one element in that array:<div class="informalexample"><pre class="programlisting">  int numberOfTriangles = sizeof(SquareTriangles)/sizeof(SquareTriangles[0]);
  glDrawElements(GL_TRIANGLES, numberOfTriangles, GL_UNSIGNED_BYTE, 0);</pre></div></li></ol><div class="calibre14"/></div><p class="calibre8">So, our final implementation class probably looks like the following code:</p><div class="informalexample"><pre class="programlisting">#import "ViewController.h"
typedef struct {
GLKVector3 position;
} Vertex;
const Vertex SquareVertices[] = {
{-1, -1 , 0}, {1, -1 , 0}, {1, 1 , 0}, {-1, 1 , 0}
};
const GLubyte SquareTriangles[] = {
0, 1, 2, 
2, 3, 0 
};
@interface ViewController () {
GLuint _vertexBuffer;
GLuint _indexBuffer;
GLKBaseEffect* _squareEffect;
}
@end
@implementation ViewController
- (void)viewDidLoad
{
[super viewDidLoad];
GLKView* view = (GLKView*)self.view;
view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
[EAGLContext setCurrentContext:view.context];

glGenBuffers(1, &amp;_vertexBuffer);
glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);
glBufferData(GL_ARRAY_BUFFER, sizeof(SquareVertices), SquareVertices,
GL_STATIC_DRAW);
glGenBuffers(1, &amp;_indexBuffer);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(SquareTriangles),
SquareTriangles, GL_STATIC_DRAW);
_squareEffect = [[GLKBaseEffect alloc] init];
float aspectRatio = self.view.bounds.size.width/self.view.bounds.size.height;
float fieldOfViewDegrees = 60.0;
GLKMatrix4 projectionMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(fieldOfViewDegrees),aspectRatio, 0.1, 10.0);
_squareEffect.transform.projectionMatrix = projectionMatrix;

GLKMatrix4 modelViewMatrix = GLKMatrix4MakeTranslation(0.0f, 0.0f, -6.0f);
_squareEffect.transform.modelviewMatrix = modelViewMatrix;

_squareEffect.useConstantColor = YES;
_squareEffect.constantColor = GLKVector4Make(1.0, 0.0, 0.0, 1.0);
}
- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {
glClearColor(0.0, 0.0, 0.0, 1.0);
glClear(GL_COLOR_BUFFER_BIT);

[_squareEffect prepareToDraw];
glEnableVertexAttribArray(GLKVertexAttribPosition);
glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, 0);
int numberOfVertices = sizeof(SquareTriangles)/sizeof(SquareTriangles[0]);
glDrawElements(GL_TRIANGLES, numberOfVertices, GL_UNSIGNED_BYTE, 0);
}
@end</pre></div><p class="calibre8">Run the project, and <a id="id414" class="calibre1"/>you <a id="id415" class="calibre1"/>will see the red square box on the black screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00160.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Building a mini 3D animation game using OpenGL"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec58" class="calibre1"/>Building a mini 3D animation game using OpenGL</h1></div></div></div><p class="calibre8">In this recipe, we<a id="id416" class="calibre1"/> will load a texture and apply it to the square. Later, we will make a cube, and finally we will learn how to implement <a id="id417" class="calibre1"/>three-dimensional animation by rotating our cube in three-dimensions.</p></div>

<div class="book" title="Building a mini 3D animation game using OpenGL">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec138" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Now we will start from the place we have left before and will load all the textures. To load the textures, follow the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, in our vertex structure, we need to include texture coordinate information:<div class="informalexample"><pre class="programlisting">typedef struct {
GLKVector3 position; // the location of each vertex in space
GLKVector2 textureCoordinates; // the texture coordinates for each vertex
} Vertex;
const Vertex SquareVertices[] = {
{{-1, -1 , 0}, {0,0}}, // bottom left
{{1, -1 , 0}, {1,0}}, // bottom right
{{1, 1 , 0}, {1,1}}, // top right
{{-1, 1 , 0}, {0,1}}, // top left
};</pre></div></li><li class="listitem" value="2">Next, add <a id="id418" class="calibre1"/> an image (any) in our<a id="id419" class="calibre1"/> project, rename it as <code class="email">Texture.png</code>, and then add the following code in <code class="email">viewDidLoad</code>:<div class="informalexample"><pre class="programlisting">NSString* imagePath = [[NSBundle mainBundle]
pathForResource:@"Texture" ofType:@"png"];
NSError* error = nil;
GLKTextureInfo* texture = [GLKTextureLoader textureWithContentsOfFile:imagePath options:nil error:&amp;error];
if (error != nil) {
NSLog(@"Problem loading texture: %@", error);
}
_squareEffect.texture2d0.name = texture.name;</pre></div></li><li class="listitem" value="3">To modify the earlier square color, remove the following lines:<div class="informalexample"><pre class="programlisting">_squareEffect.useConstantColor = YES;
_squareEffect.constantColor = GLKVector4Make(1.0, 0.0, 0.0, 1.0);</pre></div></li><li class="listitem" value="4">Finally, when rendering in <code class="email">glkView:drawInRect</code>, we indicate to OpenGL where to find texture coordinates in the vertex information:<div class="informalexample"><pre class="programlisting">glEnableVertexAttribArray(GLKVertexAttribTexCoord0);
glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE,
sizeof(Vertex), (void*)offsetof(Vertex, textureCoordinates));</pre></div><p class="calibre15">When the square is rendered, you'll see your image appear on it, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00161.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">Now we<a id="id420" class="calibre1"/> will make it as a cube. The<a id="id421" class="calibre1"/> cube is made up of eight vertices, so we need to provide information for each vertex, including its position and texture coordinates. From now on, rename <code class="email">SquareVertices</code> to <code class="email">CubeVertices</code> to follow a better naming convention.<div class="informalexample"><pre class="programlisting">const Vertex CubeVertices[] = {
{{-1, -1, 1}, {0,0}}, // bottom left front
{{1, -1, 1}, {1,0}}, // bottom right front
{{1, 1, 1}, {1,1}}, // top right front
{{-1, 1, 1}, {0,1}}, // top left front
{{-1, -1, -1}, {1,0}}, // bottom left back
{{1, -1, -1}, {0,0}}, // bottom right back
{{1, 1, -1}, {0,1}}, // top right back
{{-1, 1, -1}, {1,1}}, // top left back
};

const GLubyte CubeTriangles[] = {
0, 1, 2, // front face 1
2, 3, 0, // front face 2
4, 5, 6, // back face 1
6, 7, 4, // back face 2
7, 4, 0, // left face 1
0, 3, 7, // left face 2
2, 1, 5, // right face 1
5, 6, 2, // right face 2
7, 3, 6, // top face 1
6, 2, 3, // top face 2
4, 0, 5, // bottom face 1
5, 1, 0, // bottom face 2
};</pre></div></li><li class="listitem" value="6">The next<a id="id422" class="calibre1"/> step is a purely aesthetic one: the <a id="id423" class="calibre1"/>cube will be rotated, in order to illustrate that it is in fact a three-dimensional object.<p class="calibre15">Select the following lines:</p><div class="informalexample"><pre class="programlisting">GLKMatrix4 modelViewMatrix = GLKMatrix4MakeTranslation(0.0f, 0.0f, -6.0f);
_squareEffect.transform.modelviewMatrix = modelViewMatrix;</pre></div><p class="calibre15">Replace them with the following:</p><div class="informalexample"><pre class="programlisting">GLKMatrix4 modelViewMatrix = GLKMatrix4MakeTranslation(0.0f, 0.0f, -6.0f);
modelViewMatrix = GLKMatrix4RotateX(modelViewMatrix,GLKMathDegreesToRadians(45));
modelViewMatrix = GLKMatrix4RotateY(modelViewMatrix,GLKMathDegreesToRadians(45));
_squareEffect.transform.modelviewMatrix = modelViewMatrix;</pre></div><p class="calibre15">However, to draw our cube, a depth buffer needs to be added and enabled. The depth buffer is needed to provide a three-dimensional and more realistic look to the object.</p></li><li class="listitem" value="7">Add the following code immediately after the call to EAGLContext's <code class="email">setCurrentContext</code> method:<div class="informalexample"><pre class="programlisting">view.drawableDepthFormat = GLKViewDrawableDepthFormat24;
glEnable(GL_DEPTH_TEST);</pre></div></li><li class="listitem" value="8">Finally, replace the <code class="email">glClear(GL_COLOR_BUFFER_BIT);</code> line with the <code class="email">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code> line.</li><li class="listitem" value="9">Compile <a id="id424" class="calibre1"/>and run the project to see the cube in three-dimensions, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00162.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="10">Now we <a id="id425" class="calibre1"/>will take it to the next level by adding a code to rotate a cube. Now we will animate movement in a view, such as rotation. Add the following instance variable to the <code class="email">ViewController</code> class in the interface part:<div class="informalexample"><pre class="programlisting">   float rotation;</pre></div></li><li class="listitem" value="11">Next, add<a id="id426" class="calibre1"/> the following method to the class:<div class="informalexample"><pre class="programlisting">- (void) update {
NSTimeInterval timeInterval = self.timeSinceLastUpdate;
float rotationSpeed = 15 * timeInterval;
rotation += rotationSpeed;
GLKMatrix4 modelViewMatrix = GLKMatrix4MakeTranslation(0.0f, 0.0f, -6.0f);
modelViewMatrix = GLKMatrix4RotateX(modelViewMatrix,
GLKMathDegreesToRadians(45));
modelViewMatrix = GLKMatrix4RotateY(modelViewMatrix,
GLKMathDegreesToRadians(rotation));
_squareEffect.transform.modelviewMatrix = modelViewMatrix;
}</pre></div></li><li class="listitem" value="12">Now, the <a id="id427" class="calibre1"/>update function should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00163.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="13">Now compile and run the application. You will find your cube rotating at the angle we have specified, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00164.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Building a mini 3D animation game using OpenGL">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec139" class="calibre1"/>See also</h2></div></div></div><p class="calibre8">So far we have learned various ways to create two-dimensional and three-dimensional models using OpenGL. OpenGL serves as the backbone of the three-dimensional game programming, and hence is a very vast topic to dive into. We have just taken a glance of OpenGL, to <a id="id428" class="calibre1"/>know more about it, you can refer to <a class="calibre1" href="https://developer.apple.com/opengl/">https://developer.apple.com/opengl/</a>.</p></div></div></body></html>